<!-- Static SQL CSP Tags -->
<!-- Copyright (c) 2001 InterSystems Inc. ALL RIGHTS RESERVED. -->

<csr:rule name="%ESQL" match="script[language=esql]" textonly>
<csr:description>
    The <b>script language=esql</b> tag inserts the contents of the tag
    as embedded SQL in the class generated by the CSP page.
</csr:description>
<csr:action>
<script language="Cache" runat="compiler">
	Do ..WriteCSPServer("	&SQL( "_..InnerText()_" )")
</script>
</csr:action>
</csr:rule>

<csr:rule name="%ESQLBASIC" match="script[language=esql]" textonly language="basic">
<csr:action>
<script language="Cache" runat="compiler">
	Set %statuscode=$$$ERROR($$$CSPBasicNoStaticSQL,..LineNumber)
</script>
</csr:action>
</csr:rule>

<csr:rule name="%ESQLMVBASIC" match="script[language=esql]" textonly language="mvbasic">
<csr:action>
<script language="Cache" runat="compiler">
	Set %statuscode=$$$ERROR($$$CSPBasicNoStaticSQL,..LineNumber)
</script>
</csr:action>
</csr:rule>

<csr:rule name="%SQLCURSOR" match="script[language=sql,cursor]" textonly>
<csr:attribute name=Cursor required description="The name of the SQL cursor that is being declared." type="cursorName:STRING">
<csr:attribute name=Mode description="Mode of the query:  DISPLAY, LOGICAL, ODBC or SYSTEM.  Runtime mode by default." type="Mode:STRING" >
<csr:description>
    The <b>script language=sql</b> creates embedded SQL for a DECLARE CURSOR 
    statement in the class generated by the CSP page.  The declared cursor 
    will be opened using an SQL OPEN statement and the SQLCODE will
    be returned.  It is the programmers responsibilty to display any error
    indicated by the SQLCODE value.<p>
    The mode of the query is determined by the MODE attribute.  The mode is
    taken to be a runtime mode by default.  If the COMPILERMODE attribute
    is specified, then the mode is taken to be a compile time mode that
    is defined by a generated #SQLCOMPILE statement.
    <p>For example:
    <EXAMPLE>
    <script language="SQL" cursor="prsn">
        select name,ssn from sample.person where ssn %STARTSWITH '2' order by ssn
    </script>
    <csp:while cursor="prsn" into="Name,ssn" counter="x" condition="(x<3)">
        Name: #(Name)#<br>
        SSN: #(ssn)#<br>
    </csp:while>
    </EXAMPLE>
    <p>Will display all people whose ssn begins with 1:
    <OUTPUT>
    Name: Smith, Joe<br>
     SSN: 111-11-1111<br>
    Name: Jones, Harry<br>
     SSN: 111-11-1122<br>
    etc...<br>
    etc...<br>
    </OUTPUT>
</csr:description>
<csr:action>
<script language="Cache" runat="compiler">
	New mode,compilemode,runmode,cursor
	
	// test if name is valid
	If ..IsDefined("NAME") {
		Set %statuscode=$$$ERROR($$$CSPBadSQLTag,..LineNumber)
		Quit
	}
	Set cursor=..GetAttribute("CURSOR")
	If '$zname(cursor) {
		Set %statuscode=$$$ERROR($$$CSPSQLInvalidName,"CURSOR","script LANGUAGE=SQL",..LineNumber)
		Quit
	}
	If %compiler.IsDefinedByKey("%CSPcursor",cursor) {
		Set %statuscode=$$$ERROR($$$CSPSQLDuplicate,cursor,..LineNumber)
		Quit
	}
	
	// test and convert runtime mode.
	Set mode=$zcvt(..GetAttribute("MODE","DISPLAY"),"U")
	If ..IsDefined("COMPILERMODE") {
		Set compilemode=mode
		Set runmode=""
	} Else {
		If mode="LOGICAL" {
			Set runmode=0
		}
		ElseIf mode="ODBC" {
			Set runmode=1
		}
		ElseIf mode="DISPLAY" {
			Set runmode=2
		}
		ElseIf mode="SYSTEM" {
			Set runmode=""
		}
		Else {
			Set %statuscode=$$$ERROR($$$CSPSQLInvalidMode,..LineNumber)
			Quit
		}
		Set compilemode="RUNTIME"
	}
		
	Do %compiler.SetByKey("%CSPcursor",cursor,runmode)

	Do:compilemode'="SYSTEM" ..WriteServer("#SQLCOMPILE SELECT="_compilemode)
	Do:runmode'="" ..WriteServer("	Set %"_cursor_"=$zu(115,5,"_runmode_")")
	Do ..WriteCSPServer("	&SQL( DECLARE "_cursor_" CURSOR FOR "_..InnerText()_" )")
	Do ..WriteServer("	&SQL( OPEN "_cursor_" )")
	Do:runmode'="" ..WriteServer("	Do $zu(115,5,%"_cursor_")")
	
</script>

</csr:action>
</csr:rule>

<csr:rule name="%SQLCURSORBASIC" match="script[language=sql,cursor]" textonly language="basic">
<csr:action>
<script language="Cache" runat="compiler">
	Set %statuscode=$$$ERROR($$$CSPBasicNoStaticSQL,..LineNumber)
</script>
</csr:action>
</csr:rule>

<csr:rule name="%SQLCURSORMVBASIC" match="script[language=sql,cursor]" textonly language="mvbasic">
<csr:action>
<script language="Cache" runat="compiler">
	Set %statuscode=$$$ERROR($$$CSPBasicNoStaticSQL,..LineNumber)
</script>
</csr:action>
</csr:rule>

<csr:rule name="%SQLWHILE" match="csp:while[cursor]">
<csr:attribute name=Cursor required description="An SQL cursor that gets the row for the next iteration." type="cursorName:STRING">
<csr:attribute name=Into description="Comma sparated INTO list for the SQL FETCH of the next row.  Specifies the variables to receive the row's data" type="intoList:STRING">
<csr:attribute name=Condition description="A Cache expression evaluated after each iteration. If the expression evaluated to TRUE, then the loop is iterated again." type="expression:STRING">
<csr:attribute name=Counter description="The name of a local variable that is automatically incremented upon each iteration. It is equal to 1 upon the first iteration." type="counterName:STRING">
<csr:description>
    The <b>csp:while</b> tag repeatedly executes its contents while 
    additional rows exist for the specified CURSOR and the 
    Cach&eacute; expression specified by <var>condition</var> is TRUE.
    <p>For each iteration, the next row of data is read for CURSOR and
    the values are assigned to the local variables specified in the INTO list.
    The while clause will be terminated when the SQLCODE for the SQL FETCH
    becomes non-zero.  It is the programmer's responsibility to take any 
    needed action such as displaying an error message.
    <p>After completion of the while clause, the specified cursor will be closed.
    <p>Upon each iteration, a local variable specified by <var>COUNTER</var> 
    is incremented. The counter variable is equal to 1 upon the first iteration. 
    Its value is tested after each iteration.  The counter variable will not
    be New'ed and it is the user's responsibility to avoid conflict with other variables.
    If <var>counter</var> is not specfied, no counter will be generated.
    <p>For example:
    <EXAMPLE>
    <script language="SQL" cursor="prsn">
        select name,ssn from sample.person where ssn %STARTSWITH '2' order by ssn
    </script>
    <csp:while cursor="prsn" into="Name,ssn" counter="x" condition="(x<3)">
        Name: #(Name)#<br>
        SSN: #(ssn)#<br>
    </csp:while>
    </EXAMPLE>
    <p>Will produce the following result:
    <OUTPUT>
    Name: Smith, Joe<br>
     SSN: 111-11-1111<br>
    Name: Jones, Harry<br>
     SSN: 111-11-1122<br>
    Name: Smith, Ann<br>
     SSN: 111-11-1133<br>
    </OUTPUT>
    Only 3 people are displayed based on the <var>condition</var>.  If no <var>condition</var>
    was specified, then all people whose ssn begins with 1 would have been displayed.<p>
</csr:description>
<csr:action>

<script language="Cache" runat="compiler">
	New cursor,runmode,counter,condition,into
	Set cursor=..GetAttribute("CURSOR")
	If '%compiler.IsDefinedByKey("%CSPcursor",cursor) {
		Set %statuscode=$$$ERROR($$$CSPSQLNoCursor,cursor,..LineNumber)
		Quit
	}
	
	Set runmode=%compiler.GetByKey("%CSPcursor",cursor)
	
	If runmode'="" {
		Do ..WriteServer("	Set %"_cursor_"=$zu(115,5,"_runmode_")")
	}
	
	Set counter=..GetAttribute("COUNTER")
	Set condition="(SQLCODE=0)"
	If ..GetAttribute("CONDITION")'="" {
		Set condition=condition_"&&("_$$UnEscapeHTML^%cspQuote(..GetAttribute("CONDITION"))_")"
	}
	Set into=..GetAttribute("INTO")
	If into'="" Set into=" INTO "_into
	
	If counter'="" Do ..WriteServer("	Set "_counter_" = 0")
	Do ..WriteServer("	While "_condition_" {")
	If counter'="" Do ..WriteServer("	Set "_counter_" = "_counter_" + 1")
	Do ..WriteServer("	&SQL( FETCH "_cursor_into_" )")
	Do ..WriteServer("	If SQLCODE=0 {")
</script>

<csr:children>

<script language="Cache" runat="compiler">
	New cursor,runmode
	Set cursor=..GetAttribute("CURSOR")
	Set runmode=%compiler.GetByKey("%CSPcursor",cursor)
	
	Do ..WriteServer("	} }")
	Do ..WriteServer("	&SQL( CLOSE "_cursor_" )")
	If runmode'="" {
		Do ..WriteServer("	Do $zu(115,5,%"_cursor_")")
	}
	
</script>
</csr:action>
</csr:rule>

<csr:rule name="%SQLWHILEBASIC" match="csp:while[cursor]" language="basic">
<csr:action>
<script language="Cache" runat="compiler">
	Set %statuscode=$$$ERROR($$$CSPBasicNoStaticSQL,..LineNumber)
</script>
</csr:action>
</csr:rule>

<csr:rule name="%SQLWHILEMVBASIC" match="csp:while[cursor]" language="mvbasic">
<csr:action>
<script language="Cache" runat="compiler">
	Set %statuscode=$$$ERROR($$$CSPBasicNoStaticSQL,..LineNumber)
</script>
</csr:action>
</csr:rule>

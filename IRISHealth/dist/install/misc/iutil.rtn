s io=$i r d f  u io r R q:R="  s L=$L(R,"."),R=$p(R,".",L-1) zl  zs @R u 0 w:$x>70 ! w ?$x+9/10*10,R
%RO on Jan 09 2025  1:08 PM
%SYS.API^INT^1^67214,47330
%SYSAPI ;API's which require code to be in CACHESYS
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 Quit
ComputeFullDBDir(filename) PUBLIC {
 If filename="" q $zu(12,$zu(12),1,1)
 If ($zversion(1)=1) {
	If (filename'["[")&&(filename[":") Quit filename_"[000000]"
	If $e(filename,*)'="]" {
		s filename=$e($zu(12),1,*-1)_"."_filename_"]"
	} ElseIf $e(filename,1,2)="[." {
		s filename=$e($zu(12),1,*-1)_$e(filename,2,*)
	}
 } ElseIf ($zversion(1)=3) {
	s filename=$translate(filename,"\","/")
	s:$e(filename)'="/" filename=$zu(12)_filename
 } Else {
	s filename=$translate(filename,"/","\")
	s:$e(filename)'="\"&($e(filename,2)'=":") filename=$zu(12)_filename
 }
 s fn=$zu(12,filename,1,1)
 Quit $s(fn]"":fn,1:filename)
}

%SYS.Access^INT^1^67214,47330
%SYSAccess ; Access to globals in the system database
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 Quit
GetNLSLocaleGbl(loc) PUBLIC {
 If '$D(loc) Set loc=$G(^|"^^"_$zu(12)|%SYS("LOCALE","CURRENT"),"enu"_$E("8w",$ZBitget($ZVersion(0),1)+1))
 Set rloc=$Name(^|"^^"_$zu(12)|SYS("NLS","LocalesD")),rloc=$Name(@rloc@(loc))
 Quit $G(@rloc)
}
GetNLSCollations(Array,IsLoaded,OldCollations,Format) PUBLIC {
 If OldCollations {
	If Format=0 {
		Set Array(0)="1;0;"_"ISM Pre-6.2"
 		Set Array(1)="1;1;"_"ISM 6.2->6.4"
 		Set Array(2)="1;2;"_"Ipsum/Cobra"
 		Set Array(3)="1;3;"_"DTM-compatible"
 		Set Array(4)="1;4;"_"Ipsum/Cobra-2"
 		Set Array(128)="1;128;"_"ISM Pre-6.2 string"
 		Set Array(129)="1;129;"_"ISM 6.2->6.4 string"
	} ElseIf Format=1 {
		Set Array("ISM Pre-6.2")=$LB("ISM Pre-6.2","OANS",0,"Built-in")
 		Set Array("ISM 6.2->6.4")=$LB("ISM 6.2->6.4","ANSI",1,"Built-in")
 		Set Array("Ipsum/Cobra")=$LB("Ipsum/Cobra","COBR",2,"Built-in")
 		Set Array("DTM-compatible")=$LB("DTM-compatible","DTMC",3,"Built-in")
 		Set Array("Ipsum/Cobra-2")=$LB("Ipsum/Cobra-2","CBR2",4,"Built-in")
 		Set Array("ISM Pre-6.2 string")=$LB("ISM Pre-6.2 string","OSTR",128,"Built-in")
 		Set Array("ISM 6.2->6.4 string")=$LB("ISM 6.2->6.4 string","NSTR",129,"Built-in")
	} Else {
		Set Array(0)="ISM Pre-6.2"
 		Set Array(1)="ISM 6.2->6.4"
 		Set Array(2)="Ipsum/Cobra"
 		Set Array(3)="DTM-compatible"
 		Set Array(4)="Ipsum/Cobra-2"
 		Set Array(128)="ISM Pre-6.2 string"
 		Set Array(129)="ISM 6.2->6.4 string"
	}
 }
 If Format=0 {
	Set Array(5)="1;5;"_"IRIS standard"
	Set Array(133)="1;133;"_"IRIS standard string"
 } ElseIf Format=1 {
 	Set Array("IRIS standard")=$LB("IRIS standard","UNIC",5,"Built-in")
 	Set Array("IRIS standard string")=$LB("IRIS standard string","USTR",133,"Built-in")
 } Else {
	Set Array(5)="IRIS standard"
	Set Array(133)="IRIS standard string"
 }
 Set ref=$Name(^|"^^"_$zu(12)|SYS("NLS","TablesD")),ref=$Name(@ref@("COL"))
 Set chs=$O(@ref@(""))
 While (chs'="") {
	If $E(chs,1,5)="Latin"||($E(chs,1,2)="CP")||(chs="Unicode") {
		Set nam=$O(@ref@(chs,""))
		While (nam'="") {
			Set trec=$G(@ref@(chs,nam))
			If trec'="",nam'="IRIS standard",nam'="Cache standard" {
				Set rules=$LG(trec,14),num=$List(rules,1)
				Set load=$p($zu(23,2,num),"^",1,2)'="255^255"*2
				If 'IsLoaded||load {
					Set nums=num+128,loads=$p($zu(23,2,nums),"^",1,2)'="255^255"*2,nams=nam_" string"
					If Format=0 {
						Set Array(num)=load_";"_num_";"_nam
						If load Set Array(nums)=loads_";"_nums_";"_nams
					} ElseIf Format=1 { 
						Set Array(nam)=$LB(nam,$ZCVT($E(nam,1,3)_$E(nam,$L(nam)),"U"),num,$S(load:"Available",1:"Not Loaded"))
						If load Set Array(nams)=$LB(nams,$ZCVT($E(nams,1,3)_$E(nam,$L(nam))_"S","U"),nums,$S(loads:"Available",1:"Not Loaded"))
					} Else {
						Set Array(num)=nam
						If load Set Array(nums)=nams
					}
				}
			}
			Set nam=$O(@ref@(chs,nam))
		}
	}
	Set chs=$O(@ref@(chs))
 }
}

%SYS.Capture^INT^1^67214,47330
%SYSCapture ; Capture output ; $Change: 7440104 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	Quit
BeginCapture(&pCookie) Public {
	Set tSC=1
	Try {
		If $Data(^||%capture) Set tSC=$$Error^%apiOBJ(5001,"Capture Already Active") Quit
		Set pCookie=$lb($zutil(82,12),$zutil(96,12))
		Kill ^||%capture
		Use $io::("^"_$ZNAME)
		Do $zutil(82,12,1)
	} Catch (e) {
		Set tSC=e.AsStatus()
	}
	Quit tSC
}
EndCapture(pCookie, &pText) Public {
	If pCookie'="",$listvalid(pCookie) {
		Use $io::("^"_$list(pCookie,2))
		Do $zutil(82,12,$list(pCookie,1))
	} else {
		Do $zutil(82,12,0)
	}   
	Set pText = []
	Try {
		Set tLast=$Get(^||%capture(0),0)
		For tKey=1:1:tLast-1 {
			Do pText.%Push(^||%capture(tKey))
		}
		If tLast,^||%capture(tLast)'="" {
			Do pText.%Push(^||%capture(tLast))
		}
	} Catch {
		Do pText.%Push("Capture error: "_$ZE)
	}
	Kill ^||%capture
	Quit 1
}
rstr(sz,to) [rt] public {
	New rt Set vr="rt"
	Set rd=$zutil(82,12,0)
	Set:$data(sz) vr=vr_"#"_sz Set:$data(to) vr=vr_":"_to
	Read @vr
	Do:$data(to) $zutil(96,4,$t)
	Do $zutil(82,12,rd)
	Quit rt
}
wchr(s) public { Do write($char(s)) }
wff() public { Do write($char(12)) }
wnl(nozr) public {
	If '$Get(nozr) Set zr=$ZR
	If '$data(^||%capture(0)) Set ^||%capture(0)=1,^(1)=""
	Set ^||%capture($increment(^||%capture(0)))=""
	If $Data(zr) Do restzr(zr)
}
wstr(s) public { Do write(s) }
wtab(s) public { Do write($justify("",s-$x)) }
write(s,nozr) public {
	If '$Get(nozr) Set zr=$ZR
	Set lf=$find(s,$C(10))
	While lf {
		Do write($Extract(s,1,lf-2),1),wnl(1)
		Set s=$Extract(s,lf,*)
		Set lf=$find(s,$C(10))
	}
	Set lno=$get(^||%capture(0)) Set:lno="" lno=1,^||%capture(0)=1
	Set ^||%capture(lno)=$get(^||%capture(lno))_$translate(s,$char(13))
	If $Data(zr) Do restzr(zr)
}
restzr(zr) {
	If $ZBITGET($ZVERSION(0),30) Set $ZR=zr Quit
	If zr="" Do $zu(96,28) Quit
	Try { Set tmp=$Get(@zr) }
	Catch { Do $zu(96,28) }
}

%SYS.DATABASE^INT^1^67214,47330
%SYSDATABASE ; API for database management ;$Change: 7440104 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	; Revision: $Id: //iris/2024.1.3/databases/sys/rtn/general/_sys.database.mac#1 $
ShowMessage(sc,device) [] PRIVATE {
    Do DecomposeStatus^%SYS.DATABASE(sc,.msglist,0,"")
    Do wrtmsg($C(13,10),device)
    For i=1:1:msglist {	Do wrtmsg(msglist(i)_$C(13,10),device) }
}
wrtmsg(msg,device) [] PRIVATE {
    Quit:'$L(msg)  ; Avoid argumentless writes...
    If device=-1 { Do $zu(9,"",msg,0,0) Quit }
    If $g(%UI,"CHUI")="CHUI" { Use device Write msg Quit }
    Do:$$IjcMsg^%Wprima("DI"_msg)="CANCEL"  ; Return value could be cancel message 
    . i $$IjcMsg^%Wprima("DI"_$C(13,10)_"Abort received!"_$C(13,10))
    . zt "Abort"
}
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/FILEINC.inc#1 $ ($Change: 7440104 $) */
 q
GetDatabaseInfo(dir,info) [] PUBLIC
{
 s System=""
 if $length(dir,"^")>2 s System=$p(dir,"^",2),dir=$p(dir,"^",3,999)
 if ((System'="") && ($system.ECP.GetClientIndex(System)'=-1)) {
	s conn=$system.ECP.GetClientIndex(System)
	s SystemStatus=$system.ECP.GetClientState(conn)
	i ("3,4,6,7"[+SystemStatus) {
		q $$Error^%apiOBJ(179,"<NETWORK>")
	}
	;; If connection state is not connected, reconnect/start the connection
	Do:(+SystemStatus=1) $system.ECP.SetClientState(conn,3,0)
	;; Update the connection state
	s SystemStatus=$system.ECP.GetClientState(conn)
	;; Wait up to 10 seconds for the connection to establish
	s retry=100
	while ((+SystemStatus '= 5)&&(retry>0)) { 
		h .1
		s retry=retry-1
		set SystemStatus=$system.ECP.GetClientState(conn)
	}
	i "1,2,3,4,6"[+SystemStatus q $$Error^%apiOBJ(179,"<NETWORK>")
	if $d(^|"^"_System_"^"_dir|Routine)
	s sysnum=$p(SystemStatus,"^",2)
	f i=1:1:15999 s x=$zu(49,i,3) q:((+x=sysnum)&&($p(x,"^",2)=dir))
	if ((i < 15999)&&(+($p(x,"^",8))>0)) {
		s DirectoryBlock=$p(x,"^",8)
		s ResourceName=$p(x,"^",3)
		s info=i_","_($p(x,"^",4)*1024)_",0,0,0,0,"_DirectoryBlock_",0,0,0,0,0,"_$p(x,"^",5)_",0,0,0,0,"_$p(x,"^",7)_",0,0,0,0,0,0,"_ResourceName
		Quit 1
	}
 }
 if System'="" s info="" Quit 1
 if dir="^" {
	 /* Private globals, look up where they're stored and set up
	    dbinfo/DirectoryBlock accordingly */
	s info=$ZU(21,0)  /* sfn^block */
	s privsfn=+info
	s DirectoryBlock=$P(info,"^",2)
	if privsfn=$zu(40,0,41) q $$Error^%apiOBJ(184)
	s Directory=$P($ZU(49,+privsfn,3),"^",2)  ; look up name
	s info=$zu(49,Directory)  ; now get dir info
	s $p(info,",",7)=DirectoryBlock
 } else {
    s info=$zu(49,dir)
 }
 If (+info)<0  {
    Quit $$Error^%apiOBJ($case(+info,-1:300,-2:6046,:314),dir)
 }
 Quit 1
}
MountDatabase(dir,clustermode,readonly) [] PUBLIC
{
 Set dir=$zu(12,dir)
 Set sc=1
 Set dirinfo=$zu(49,dir)
 If (+dirinfo)<-1 Quit $$Error^%apiOBJ(184)
 If '$case($v($Piece(dirinfo,",",21)*$ZU(40,0,1)+$zu(40,2,128),-2,$ZU(40,0,1)),4294967295:0,:1) Quit $$Error^%apiOBJ(327,$Piece(dirinfo,",",2)\1024)
 If $S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0) {
    If $Get(clustermode)=1 {
       Set nonetwork=$Select($Get(^NET(0,"INIT"))="":1,1:0)
       If nonetwork Quit $$Error^%apiOBJ(322,dir)
       Set enqstat=+$Zutil(59)
       If 'enqstat If $$^STRTENQ()<1 Quit $$Error^%apiOBJ(323,dir)
    }
    Set rc=$Zutil(17,dir,$Get(clustermode,0),$Get(readonly,0))
 }
 Else {
    Set rc=$Zutil(17,dir,0,$Get(readonly,0))
 }
 If rc<0 {
    Set sc=$select(+sc:$$Error^%apiOBJ(178),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(178)))
    Set sc=$select(+sc:$$Error^%apiOBJ(-rc),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(-rc)))
 }
 Quit sc
}
ModifyDatabase(dir,uic,filsiz,expandby,maxfilsiz,gdir,gpblk,ggblk,freeze,readonly,clmode,nowait,collate) [] PUBLIC
{
 Set $Ztrap="errMod"
 i $g(dir)']"" s dir=$zu(12,"")
 Set info=$zu(49,dir) i (+info)<-1 Quit $$Error^%apiOBJ(184)
 If '$Data(filsiz) Set filsiz=$Piece(info,",",4)
 If '$Data(gdir) Set gdir=$Piece(info,",",7)
 If '$Data(gpblk) Set gpblk=$Piece(info,",",8)
 If '$Data(ggblk) Set ggblk=$Piece(info,",",11)
 If '$Data(freeze) Set freeze=$Piece(info,",",12)
 If '$Data(collate) Set collate=$Piece(info,",",3)
 Set blksiz=$Piece(info,",",2)
 If $Data(expandby)#10 {
   Set expandby=$p(expandby,".",1)+$Case($p(expandby,".",2)>.5,1:1,:0)
   Set expandby=(expandby*1048576)\blksiz
 } Else {
   Set expandby=$Piece(info,",",5)
 }
 If $Data(maxfilsiz) {
   Set maxfilsiz=$p(maxfilsiz,".",1)+$Case($p(maxfilsiz,".",2)>.5,1:1,:0)
   Set maxfilsiz=(maxfilsiz*1048576)\blksiz
 }
 Else {
   Set maxfilsiz=$Piece(info,",",6)
 }
 If $Data(filsiz) {
    Set filsiz=$p(filsiz,".",1)+$Case($p(filsiz,".",2)>.5,1:1,:0) ;$s($p(filsiz,".",2)>.5:1,0:0)
 }
 Set rc=$Zutil(1,dir,blksiz,0,filsiz,expandby,maxfilsiz,gdir,gpblk,0,0,ggblk,freeze,$g(readonly,0),$g(clmode,0),0,collate)
 i rc<0 g ModErr
 If +$Get(nowait) Quit 1
 i '$$ModWait g ModErr 
 If $Get(readonly) Set rc=$Zutil(3,dir)
 If +$Zutil(49,dir)=-1,('+$$MountDatabase(dir)) Goto ModErr
 Quit 1
ModWait() ;wait while database is being modified 
 s $ZT="ModW2" 
 s X=$ZU(40,2,46)
 f  s V=$V(X,-2,"1A") q:V'=1  h 1 ;continue until not 'running'
 i V=2 q 0
ModW2 s $ZT=""
 i $G(X) d
 . V X:-2:1:0 ;reset internal flag so others can use it
 . I $V(X,-2,1)=2 V X:-2:1:0
 q 1 ;having an error really doesn't mean anything
ModErr 
 Set sc=$$Error^%apiOBJ(313,dir)
 Set sc=$select(+sc:$$Error^%apiOBJ(-rc),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(-rc)))
 Quit sc
errMod
 Set $Ztrap="" Quit $$Error^%apiOBJ(5002,$Zerror)
}
SetDatabaseVariables(dir,blksiz,uic,filsiz,expandby,maxfilsiz,gdir,gpblk,ggblk,rdirblk,rgblk,totvol,isbig,curblks,blkspermap,curmaps,freeze,collate,readonly,clmode) [] PUBLIC
{
 s info=$zu(49,dir) i (+info)<-1 Quit $$Error^%apiOBJ(184)
 s blksiz=$Piece(info,",",2)
 s uic=$p(info,",",3)
 s filsiz=$p(info,",",4)
 Set expval=$Piece(info,",",5)
 s expandby=(expval*blksiz)\1048576
 If blksiz=2048 Set expandby=expandby+(((expval*blksiz)/1048576)-((expval*blksiz)\1048576)>.5)
 Set maxfil=$Piece(info,",",6)
 s maxfilsiz=(maxfil*blksiz)\1048576
 If blksiz=2048 Set maxfilsiz=maxfilsiz+(((maxfil*blksiz)/1048576)-((maxfil*blksiz)\1048576)>.5)
 s gdir=$p(info,",",7)
 s gpblk=$p(info,",",8)
 s ggblk=$p(info,",",11)
 s rdirblk=$p(info,",",9)
 s rgblk=$p(info,",",10)
 s totvol=$p(info,",",15)
 s isbig=$p(info,",",21)
 s curblks=$p(info,",",22)
 s blkspermap=$p(info,",",23)
 s curmaps=$p(info,",",24)
 s freeze=$p(info,",",12)
 s collate=$p(info,",",13)
 s readonly=$zb(+$p(info,",",18),$zu(40,8,2),1)
 s clmode=$Case($zb(+$p(info,",",17),$zu(40,8,15),1),0:$ZU(40,8,16),:$ZU(40,8,17))
 Quit 1
}
GetDatabaseStatus(dir,state,mountflag) [] PUBLIC
{
 Set dir=$zu(12,dir)
 Set info=$zu(49,dir)
 Set rc=+info
 Set state=1
 Quit:rc>-1&(rc<$ZU(40,0,41)) 1    ; mounted
 If rc=-2 Set state=0 Quit 1
 If rc=$ZU(40,0,41),$ZB(+$Piece(info,",",16),$ZU(40,8,9),1) {
    Set ^SYS("UCI",dir)="<SKELETON>",state=3
    Quit $$Error^%apiOBJ(315)
 }
 If $g(mountflag) {
    Set rc=$zu(17,dir)
    If rc<0 {
       Set state=2
       Quit $select(+$$Error^%apiOBJ(350,dir):$$Error^%apiOBJ(-rc),1:$$AppendStatus^%occSystem($$Error^%apiOBJ(350,dir),$$Error^%apiOBJ(-rc)))
    }
    Quit 1
 }
 Set state=2 Quit 1
}
DeleteDatabase(dir) [] PUBLIC
{
 Set $Ztrap="errDel"
 Set dir=$zu(12,dir)
del1
 Set rc=$Zutil(2,dir)
 If rc<0 Quit $select(+$$Error^%apiOBJ(316,dir):$$Error^%apiOBJ(-rc),1:$$AppendStatus^%occSystem($$Error^%apiOBJ(316,dir),$$Error^%apiOBJ(-rc)))
 s $zt="delok" o 63:"^^"_dir g delerr ;didn't get deleted if you can open it
delok ;
 Set $Ztrap=""
delsec 
 d KillDatabaseByUCI^%SYS.CONFIG(dir)
 Quit 1
delerr 
 c 63
 s try=$g(try)+1
 i try=1,+$ZU(49,dir)'=-1 h 1 g del1 
 i try>1,+$ZU(49,dir)'=-1 Quit $$Error^%apiOBJ(317)
 g delsec 
errDel
 Set $Ztrap="" Quit $$Error^%apiOBJ(5002,$Zerror)
}
CreateDatabase(dir,blksiz,filsiz,uic,expandby,maxfilsiz,gdir,gpblk,ggblk,freeze,collation,sparsedb,reinit,clmntmode,enckeyid) [] PUBLIC 
{
 Set $Ztrap="errCreate"
 Set dir=$zu(12,dir)
 Set uic=0
 If $Length(dir)>$ZU(40,0,78) Quit $$Error^%apiOBJ(15,dir)
 if $e(dir,$l(dir))="\" s dir=$e(dir,1,$l(dir)-1)
 If $zu(140,4,dir)=-2 Quit $$Error^%apiOBJ(41)
 If $$IsMaxDBMounted Quit $$Error^%apiOBJ(68)
 Set sc=1
 If '$Get(blksiz) Set blksiz=$$GetDefaultBlockSize()
 If '$case($v($Case(blksiz,2048:0,4096:1,8192:2,16384:3,32768:4,:5)*$ZU(40,0,1)+$zu(40,2,128),-2,$ZU(40,0,1)),4294967295:0,:1) Quit $$Error^%apiOBJ(327,blksiz\1024)
 If $Data(filsiz) {
    Set filsiz=$p(filsiz,".",1)+$Case($p(filsiz,".",2)>.5,1:1,:0) ;$s($p(filsiz,".",2)>.5:1,0:0)
    If 'filsiz Set filsiz=1
 }
 If $G(enckeyid)'="" Do $zu(9,"","Encrypting "_dir_" with key "_enckeyid,(0>0),0)
 If $G(reinit) {
	 s dbobj=##class(SYS.Database).%OpenId(dir,,.status)
	 if (''status) {
		 if dbobj.Mounted {
			 d dbobj.Dismount()
		 }
		 s dbobj=""
	 }
 }
 Set rc=$zu(27,dir,dir,$g(blksiz),$g(filsiz),$G(sparsedb),$G(reinit),$G(enckeyid))
 If $Length(rc,"^")<6 {
    Set sc=$select(+sc:$$Error^%apiOBJ(320),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(320))) Quit $$packZU27Error(sc,rc)
    Set dir=$p(rc,"^",1),blksiz=$p(rc,"^",6)
 }
 If '$Get(blksiz) Set blksiz=$Piece(rc,"^",6)
 S ^SYS("UCI",$zu(12,dir))="<SKELETON>^"_$Piece(rc,"^",4)
 If $Get(expandby) {
   Set expandby=$p(expandby,".",1)+$Case($p(expandby,".",2)>.5,1:1,:0) ;$s($p(expandby,".",2)>.5:1,0:0)
 }
 If $Data(maxfilsiz) {
   Set maxfilsiz=$p(maxfilsiz,".",1)+$Case($p(maxfilsiz,".",2)>.5,1:1,:0)
 }
 If $Data(maxfilsiz) Set maxfilsiz=(maxfilsiz*1048576)\blksiz
 Else  Set maxfilsiz=0
 If $Data(expandby) Set expandby=(expandby*1048576)\blksiz
 Else  Set expandby=0
 If '$Data(collation) Set collation=$Zutil(23,0)
 if blksiz=2048 {
    s rc=$zu(0,dir,blksiz,uic,0,expandby,maxfilsiz,$g(gdir,2),$g(gpblk),0,0,$g(ggblk),$g(freeze,1),0,$g(clmntmode,0),0,collation)
 }
 else {
    s rc=$zu(0,dir,blksiz,uic,0,expandby,maxfilsiz,0,$g(gpblk,$zu(40,0,40)),0,0,$g(ggblk,50),$g(freeze,1),0,$g(clmntmode,0),0,collation)
 }
 i rc<0 Quit $$Error^%apiOBJ(-rc)
 s rc=$zu(17,dir) 
 i rc=-35 f  h 1 s rc=$zu(17,dir) q:rc'=-35
 i 'rc!(rc<0) Set sc=1_$e($$Error^%apiOBJ(307,dir,rc),2,*)
 e  d  
 . s Collation=5
 . s Protect=-1
 . s Keep=1
 . s Journal=0
 . s PtrBlk=-1
 . s GrowthBlk=-1
 . f glo="ROUTINE","rBACKUP","rMAC","rMACSAVE","rINC","rINCSAVE","rINDEX","oddDEF","oddCOM","oddEXT","oddEXTR","oddMAP","oddPROC","oddPROJECT","oddPKG","oddPYTHON","oddSQL","oddStudioDocument","oddStudioMenu","rINDEXCLASS" d
 . . Set rc=$zu(178,"^^"_dir,glo,Collation,Protect,Journal,Keep,PtrBlk,GrowthBlk)
 . Set ^|"^^"_dir|rINDEX=$ztimestamp,^|"^^"_dir|rINDEXCLASS=$ztimestamp
 . Set rc=$zu(178,"^^"_dir,"rOBJ",133,Protect,Journal,Keep,PtrBlk,GrowthBlk)
 s ^SYS("UCI",$zu(12,dir))=""
 Quit sc
errCreate
 Set $Ztrap="" Quit $$Error^%apiOBJ(5002,$Zerror)
}
packZU27Error(sc,rc) 
 Set dir=$Piece(rc,"|"),errnum=$Piece(rc,"|",2),code=$Piece(rc,"|",3)
 Set sc=1
 Set sc=$select(+sc:$$Error^%apiOBJ(70),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(70)))
 Set sc=$select(+sc:$$Error^%apiOBJ(-errnum),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(-errnum)))
 Set error=$Case(code,1:71,2:$case($Extract(dir,1,5),"/dev":72,:73),5:74,6:75,13:76,16:77,17:78,19:79,23:80,24:81,30:82,:83)
 If error=83 Set sc=$select(+sc:$$Error^%apiOBJ(error,code),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(error,code)))
 Quit sc
GetDefaultBlockSize()
 n ans,allowed
 s allowed=$G(^SYS("DBSIZES","ALLOWED"))  ;JO1737
 s ans=8192
 q:'$L(allowed) ans  ;not restricted, use system default
 q:allowed[(","_ans_",") ans      ;system default is allowed
 ; system default is not allowed. Return the largest allowed
 ; size as the default.
 q $P(allowed,",",$L(allowed,",")-1)
GetGlobalDirectoryInfo(NSP,save,tally,gsetflag) [] PUBLIC
{
 s rc=$$GetDatabaseInfo(NSP,.DBINFO)
 i ('rc) q rc
 Quit $$GetGlobalDirectoryInfoFromDBInfo(NSP,DBINFO,save,.tally,$G(gsetflag,0))
}
GetGlobalDirectoryInfoFromDBInfo(NSP,dbinfo,save,tally,gsetflag) [] PUBLIC
{
    Set remlock=0,$zt="errdir"
    If dbinfo="" {
	Set System=$p(NSP,"^",2)
	i '($e($roles,1,$l("%All"))="%All") { n $ET,$roles s $ET="",$roles=$roles_","_"%All"} ; verified 9/26/16 STC
	Set oldval=$zu(68,7,0) 
	Try {
		s resultgn=$G(^|"^"_System_"^IRISSYS"|SYS("TempResultGlobalName"))
		s isIRIS=1,ok=1   ; Remote is IRIS system.
		s:$e(resultgn)="^" resultgn=$e(resultgn,2,*)
		s oldver=10000
	} catch {
		s resultgn=""
	}
	if resultgn="" {
		Try {
			s oldver=$G(^|"^"_System_"^IRISSYS"|SYS("SystemDBVersion"))
			s ok=(oldver'="")
			s isIRIS=1
		} catch {
			s ok=0,isIRIS=0
		}
		if 'ok {
			Try {
				s oldver=$G(^|"^"_System_"^CACHESYS"|SYS("CACHESYSVersion"))
				s ok=(oldver'="")
			} catch {
				s ok=0,oldver=""
			}
		}
    }
	If 'ok {
	    Set remnode=$name(^|NSP|UTILITY("%GD"))
	} Else {
	    Set tempdir=$s(+$p($SYSTEM.ECP.GetClientState($SYSTEM.ECP.GetClientIndex(System)),"^",10)'=0:$s(isIRIS:":ds:IRISTEMP",1:":ds:CACHETEMP"),isIRIS:$g(^|"^"_System_"^IRISSYS"|%SYS("IRISTempDir")),1:$g(^|"^"_System_"^CACHESYS"|%SYS("CacheTempDir")))
	    Set:resultgn="" resultgn="CacheTempUtil"
	    Set remnode=$name(@("^|""^"_System_"^"_tempdir_"""|"_resultgn_"(""%GD"")"))
	}
	Do $zu(68,7,oldval)
	Lock +@remnode:2
	If '$t { Quit $$Error^%apiOBJ(179,"<NETWORK>") }
	Set remlock=1
	Kill @remnode
	If oldver="" {
	    Job RemJob^%GD[NSP]
	} ElseIf oldver>5.2 {
	    Job RemJobSys^%SYS.GD[NSP]
	} Else {
	    Job RemJob^%SYS.GD[NSP]
	}
	If $zchild=0 { s $ze="<REM JOB FAILS>" g errdir }
	For t=.2:.2:10 {
	    Hang t
	    Quit:$d(@remnode)#2  ; wait for job to finish, hopefully
	}
	If '$d(@remnode)#2 { s $ze="<REM JOB FAILS>" g errdir }
	If @remnode]"" { s $ze=@remnode g errdir } ; remote error report
	Merge @save=@remnode
	Kill @remnode
	Lock -@remnode
	Quit 1
    }
    If $Piece(dbinfo,",",2)=2048 { Quit $$Error^%apiOBJ(90) }
    If NSP="^" {
	s info=$ZU(49,+dbinfo,3)
	if +info'=0 {  ;0=local, -2 = doesn't exist, 1=remote
		set $ze="<SFN #"_+dbinfo_" IS NOT LOCAL>" 
		goto errdir  
	}
	s DIR=$P(info,"^",2)  ; look up name
	s NSP="^^"_DIR
    } else {
	s DIR=$p(NSP,"^",3,999)
    }
    Set GDBLOCK=+$p(dbinfo,",",7)
    If GDBLOCK<0 { Quit $$Error^%apiOBJ(6075,GDBLOCK) }
    Set ResourceName=$Piece(dbinfo,",",25)
    Open 63:NSP 
    Set tally=0
    Do {
	View GDBLOCK
	If $v($zu(40,32,0),0,4) {
	    For i=1:2 {
		Set name=$e($v(i,-5),2,*)
		Quit:name=""
		Set viewstr=$v(i+1,-6)
		Set tally=tally+1
		If $g(gsetflag) {
		    Set @save@(name)=$p(viewstr,",",4)_"^"_$p(viewstr,",",5)_"^"_$p(viewstr,",",2)_"^"_$p(viewstr,",",1)_"^"_$p(viewstr,",",3)_"^"_ResourceName
		} Else {
		    Set @save@(name)=$p(viewstr,",",5)_"^"_$p(viewstr,",",2)_"^"_$p(viewstr,",",1)_"^"_$p(viewstr,",",4)_"^"_$p(viewstr,",",3)_"^"_ResourceName
		}
	    }
	}
	Set GDBLOCK=$v($Zutil(40,32,4),0,4)
    } While GDBLOCK
    Close 63
    Quit 1
errdir s $zt="",errlog=$Get(errlog)+1,errlog(errlog)=$p($ze,">")_">"_NSP
    Lock:remlock -@remnode
    Quit $$Error^%apiOBJ(5002,$Zerror)
}
InitIRISTemp(dir,debug) [QUIETLY] PUBLIC
{
 i '$d(debug) s debug=0
 i debug d $zu(9,"","InitIRISTemp: starting",(1>0),1)
 i $ZU(173)'=$ZU(40,0,41) d  q res
 . s res=1
 . i debug d $zu(9,"","InitIRISTemp: IRIStemp already defined, sfn="_$ZU(173),(1>0),1)
 s reinit=1
 s dirinfo=$zu(49,dir)
 s sfn=+dirinfo
 If sfn<=-2 {
	Set reinit = 0
	i $e(dir,$l(dir))=$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"") s dir=$e(dir,1,$l(dir)-1)
	Do $zu(9,"","Creating missing IRISTEMP database in "_dir,(0>0),0)
	Set sc1=$zu(140,4,dir)
	If sc1'=0 {
		i '##Class(%Library.File).CreateDirectoryChain(dir) Do $zu(9,"","Failed to create IRISTEMP directory in "_dir,(3  /* Fatal */>0),3  /* Fatal */)
	}
 }
 s is2kdatabase=$p(dirinfo,",",2)=2048
 i debug d $zu(9,"","InitIRISTemp: "_dir_" mounted as sfn: "_sfn_" is2KB: "_is2kdatabase,(1>0),1)
 i is2kdatabase d
 . i $zu(17,dir)  ; try to mount it
 . s dirinfo=$zu(49,dir),sfn=+dirinfo
 i 'sfn q $$Error^%apiOBJ(310)
 i (sfn>0)&(sfn<$ZU(40,0,41)) d  i ('res) q res
 . s reinit=0
 . s res=$$DeleteDatabase(dir)
 . if debug d
 . . if ('res) d  
 . . . s msgtext=""
 . . . d DecomposeStatus(res,msglist,0,"") For i=1:1:msglist s msgtext=msgtext_msglist(i)
 . . . d $zu(9,"","InitIRISTemp: Failed to delete "_dir_": "_msgtext,(0>0),0)
 . . e  d $zu(9,"","InitIRISTemp: deleted database "_dir,(1>0),1)
 i reinit {
	Set blksiz=$p(dirinfo,",",2)
	Set expandby=$Piece(dirinfo,",",5)*blksiz\1048576
	Set maxblocks=$Piece(dirinfo,",",6)*blksiz\1048576
	Set filsiz=$Piece(dirinfo,",",4) ;already in MB
	Set collation=$Piece(dirinfo,",",13) ; preserve collation if we changed it on restart
	i debug d $zu(9,"","InitIRISTemp: reinitializing to size: "_filsiz_" expby: "_expandby_" max: "_maxblocks_" coll: "_collation,(1>0),1)
	If filsiz>240 s filsiz=240
 } else {
	i debug d $zu(9,"","InitIRISTemp: iristemp did not exist, creating new db",(1>0),1)
	s filsiz=1     ; system will increase if this is too small
	s expandby=0    ;0 means use system default of the larger of 10% or 10MB
	s maxblocks=0   ; unlimited
	s collation=$zu(23,0) ; System default
	i debug d $zu(9,"","InitIRISTemp: iristemp did not exist coll:"_collation,(1>0),1)
 }
 s blksiz=0      ; use system default
 s uic=0         ; no owner
 s gdir=0        ; use system default
 s gpblk=0       ; use system default
 s ggblk=0       ; use system default
 s freeze=0      ; don't freeze on errors (also set by $ZU(173))
 s sparsedb=1
 s enckeyid=""
 s $zt="skip"
 s sys=##class(Security.System).%OpenId("SYSTEM")
 i sys.DBEncIRISTemp s enckeyid=$System.Security.System.GetDBEncKeyID()
skip s $zt=""
 s res=$$CreateDatabase(dir,blksiz,filsiz,uic,expandby,maxblocks,gdir,gpblk,ggblk,freeze,collation,sparsedb,reinit,,enckeyid)
 i ('res) d:debug  q res
 . s msgtext=""
 . d DecomposeStatus(res,.msglist,0,"") For i=1:1:msglist s msgtext=msgtext_msglist(i)
 . d $zu(9,"","InitIRISTemp: Failed to create "_dir_": "_msgtext,(0>0),0)
 i debug d $zu(9,"","InitIRISTemp: "_$S(reinit:"Reinitialized",1:"Created new")_" database for "_dir,(1>0),1)
 s sfn=+$ZU(49,dir)
 i (sfn<0)!(sfn=$ZU(40,0,41)) d:debug  Quit $$Error^%apiOBJ(312)
 . d $zu(9,"","InitIRISTemp: Failed to lookup sfn for iristemp",(1>0),1)
 s res=$zu(173,sfn)
 i 'res d:debug  q $$Error^%apiOBJ(311,dir)
 . d $zu(9,"","InitIRISTemp: Failed to designate "_dir_" as iristemp",(1>0),1)
 i debug d $zu(9,"","InitIRISTemp: Marked "_dir_" as iristemp",(1>0),1)
 s sc=##Class(SYS.Database).ModifyDatabase(dir,,"%DB_"_"IRISTEMP")
 If ('sc) s $zt="afterstatus" Set sc=$System.Status.GetErrorText(sc) Do $zu(9,"",sc,(1>0),1)
afterstatus s $zt="" s $ze=""
 s ^%SYS("IRISTempDir")=$zu(12,dir)
 s ^%SYS("CacheTempDir")=$zu(12,dir)
 q 1
}
MakeIRISTemp(dir,PrintMsg=0) [QUIETLY] PUBLIC
{
 i '$d(QUIETLY) n QUIETLY s QUIETLY=1
 s res=$$InitIRISTemp(dir)
 i PrintMsg d
 . i +res d $zu(9,"",dir_" initialized as IRISTEMP",(0>0),0) q
 . d DecomposeStatus(res,.msglist,0,"")
 . s msg="" f msgi=1:1:msglist s msg=msglist(msgi)_$c(13,10)
 . d $zu(9,"","MakeIRISTemp^"_$ZN_": "_$c(13,10)_msg,(1>0),1)
 q res
}
MakeIRISLocalData(dir) Public {
 s $zt="skip" ;Security DB may not be initialized yet
 s Encrypt=0
 s sys=##class(Security.System).%OpenId("SYSTEM")
 i sys.DBEncIRISTemp s Encrypt=1
skip s $zt=""
 s dirinfo=$zu(49,dir)
 s sfn=+dirinfo
 If sfn<=-2 {
	d $zu(9,"","Creating IRISLOCALDATA database in "_dir,0,0  /* Informational message */)
	Set sc1=$zu(140,4,dir)
	If sc1'=0 {
		i '##Class(%Library.File).CreateDirectoryChain(dir) {
			q $$Error^%apiOBJ(5001,"Failed to create IRISLOCALDATA directory in "_dir)
		}
	}
 } else {
 	s CurrentlyEncrypted=$Case($zb(+$p(dirinfo,",",16),$zu(40,8,27),1),0:0,:1)
 	i CurrentlyEncrypted=Encrypt k ^|"^^"_dir|IRIS.WorkQueue q 1
	s Status=$$DeleteCacheDB(dir)   ;##Class(SYS.Database).DeleteDatabase(dir)
	i '(''Status) q Status
	d $zu(9,"","Reinitializing IRISLOCALDATA database in "_dir,1 /* broadcast and log message*/,1  /* Warning */)
 }
 s Status=##Class(SYS.Database).CreateDatabase(dir,,,Encrypt,"%DB_IRISLOCALDATA",2 /* Not Journaled */)
 i '(''Status) q Status
 s Status=##Class(%Library.GlobalEdit).Create("^^"_dir,"%cspSession",5,,,1)
 s Status=##Class(%Library.GlobalEdit).Create("^^"_dir,"%sqlcq",5,,,1)
 s Status=##Class(%Library.GlobalEdit).Create("^^"_$zu(12),"%sqlcq",5,,,1)
 s Status=##Class(%Library.GlobalEdit).Create("^^"_dir,"IRIS.WorkQueue",5,,,1)
 i $d(^|"^^"_dir|%ISCWorkQueue) k ^|"^^"_dir|%ISCWorkQueue
 q 1
}
DeleteCacheDB(dir) PRIVATE {
 s $ZT="ERROR"
 i '$SYSTEM.Security.Check("%Admin_Manage","USE") q $$Error^%apiOBJ(921,"%Admin_Manage"_":"_"USE")
 s x=$zu(49,dir)
 If x<-3 Quit $$Error^%apiOBJ(184)
 i x=-3 q $$Error^%apiOBJ(42)
 i x=-2 q $$Error^%apiOBJ(6046,dir)
 s dir=$zu(12,dir)
 s SFN=+$p(x,",",14)
 Try {
	i SFN=$zu(40,0,41) i $d(^|"^^"_dir|X)
 } Catch {
 }
 Set rc=$Zutil(2,dir)
 If rc<0 {
	Set rc1=$Zutil(140,5,dir_"IRIS"_".DAT")
	If rc1<0 {
		Try {
			i SFN=$zu(40,0,41) d $zu(3,dir)	 
		} Catch {}
		Quit $select(+$$Error^%apiOBJ(316,dir):$$Error^%apiOBJ(-rc),1:$$AppendStatus^%occSystem($$Error^%apiOBJ(316,dir),$$Error^%apiOBJ(-rc)))
	}
 }
 d KillDatabaseByUCI^%SYS.CONFIG(dir)
 Quit 1
ERROR s $zt=""
 i $G(SFN)=$zu(40,0,41) d $zu(3,dir)	 
 Quit $$Error^%apiOBJ(5002,$ze)
}
GetKeepType(dir,global,val) [] PUBLIC
{
 Set $Ztrap="errGetKeep"
 i $g(dir)']"" s dir=$zu(12,"")
 s dirinfo=$zu(49,dir)
 i +dirinfo<0 q $select(+$$Error^%apiOBJ(321,global):$$Error^%apiOBJ(184),1:$$AppendStatus^%occSystem($$Error^%apiOBJ(321,global),$$Error^%apiOBJ(184)))
 s rc=$zu(167,6,1,dir,global)
 if rc=-1 Quit $$Error^%apiOBJ(336,global)
 if rc=-2 Quit $$Error^%apiOBJ(308,global)
 if rc=-3 Quit $select(+$$Error^%apiOBJ(321,global):$$Error^%apiOBJ(184),1:$$AppendStatus^%occSystem($$Error^%apiOBJ(321,global),$$Error^%apiOBJ(184)))
 s val=rc
 Quit 1
errGetKeep
 Set $Ztrap="" Quit $$Error^%apiOBJ(179,$Zerror)
}
SetKeepType(dir,global,set) [] PUBLIC
{
 Set $Ztrap="errSetKeepType"
 i $g(dir)']"" s dir=$zu(12,"")
 s dirinfo=$zu(49,dir)
 i +dirinfo<0 q $select(+$$Error^%apiOBJ(321,global):$$Error^%apiOBJ(184),1:$$AppendStatus^%occSystem($$Error^%apiOBJ(321,global),$$Error^%apiOBJ(184)))
 s rc=$zu(167,6,1,dir,global,$s(set:$zu(40,0,57),1:0))
 if rc=-1 Quit $$Error^%apiOBJ(336,global)
 if rc=-2 Quit $$Error^%apiOBJ(308,global)
 if rc=-3 Quit $select(+$$Error^%apiOBJ(321,global):$$Error^%apiOBJ(184),1:$$AppendStatus^%occSystem($$Error^%apiOBJ(321,global),$$Error^%apiOBJ(184)))
 if rc=-4 Quit $$Error^%apiOBJ(348,set)
 Do effectChange(global,dir,0)
 If 'set,'$D(@global) Set @global=1 Kill @global
 Quit 1
errSetKeepType
 Set $Ztrap="" Quit $$Error^%apiOBJ(5002,$Zerror)
}
SetJournalType(dir,global,set) [] PUBLIC
{
 Set $Ztrap="errSetJournalType"
 i $g(dir)']"" s dir=$zu(12,"")
 Set dirinfo=$zu(49,dir)
 If +dirinfo<0 Quit $select(+$$Error^%apiOBJ(325,global):$$Error^%apiOBJ(184),1:$$AppendStatus^%occSystem($$Error^%apiOBJ(325,global),$$Error^%apiOBJ(184)))
 Quit 1
errSetJournalType
 Set $Ztrap="" Quit $$Error^%apiOBJ(5002,$Zerror)
}
GetJournalType(dir,global,val) [] PUBLIC
{
 i $g(dir)']"" s dir=$zu(12,"")
 Set dirinfo=$zu(49,dir)
 If +dirinfo<0 q $$Error^%apiOBJ(184)
 Set $Ztrap="errGetJournalType"
 s val=0 Quit 1
errGetJournalType
 Set $Ztrap="" If $Zerror["<NOTOPEN>" Quit $$Error^%apiOBJ(184)
 Quit $$Error^%apiOBJ(5002,$Zerror)
} 
GetCollationType(dir,global,val) [] PUBLIC
{
 i $g(dir)']"" s dir=$zu(12,"")
 Set dirinfo=$zu(49,dir)
 If +dirinfo<0 q $$Error^%apiOBJ(184)
 Set $Ztrap="errGetCollation"
 s rc=$zu(167,6,2,dir,global)
 if rc=-1 Quit $$Error^%apiOBJ(336,global)
 if rc=-2 Quit $$Error^%apiOBJ(308,global)
 if rc=-3 Quit $$Error^%apiOBJ(184)
 s val=rc
 q 1
errGetCollation
 Quit $$Error^%apiOBJ(179,$Zerror)
} 
findTypeOffset(glo,dirinfo,blk) [] PRIVATE
{
    If '$Piece(dirinfo,",",21) { Quit $$Error^%apiOBJ(90) }
    Set blk=$Piece(dirinfo,",",7)
    If (blk\1'=blk)||(blk<1) {
        Quit $$Error^%apiOBJ(6075,blk)
    }
    Set:$e(glo)'="^" glo="^"_glo
    Do {
	View blk
	If $v($zu(40,32,0),0,4) {
	    For i=1:2 {
		Set name=$v(i,-5)
		Quit:name=""
		Goto:name=glo fin
	    }
	}
	Set blk=$v($Zutil(40,32,4),0,4)
    } While blk
    Quit $$Error^%apiOBJ(308,glo)
fin Set node=(i+1)/2
    Set off=$zu(40,32,10),nodeinfo=$Zutil(167,0,0,$View(off,0,4))
    For i=1:1:node-1 {
        Set nodeinfo=$Zutil(167,0,0,$v(off,0,4)),len=$Piece(nodeinfo,"^",4)
	Set off=off+len
    }
    Set nodeinfo=$Zutil(167,0,0,$View(off,0,4))
    Set off=off+4 ; past the info word
    Set off=off+$Piece(nodeinfo,"^",2)+$Piece(nodeinfo,"^",5)
    If 'off { Quit $$Error^%apiOBJ(324) }
    Quit off
}
CheckPointerIntegrity(dir,blk,errmaxperglobal,numblks,glo,&glolist) [errorLogged,errorreturn] PUBLIC {
    New errorreturn
    Quit $$CheckIntegrity(0,.numblks,dir,blk,.errmaxperglobal,.glo,.glolist)
}
CheckGlobalIntegrity(dir,glo,errmaxperglobal,
                     &glototblks,&glopntblks,&glototbytes,&glopntbytes,
                     &globigblks,&globigbytes,&globigstrings,&datasize,
                     maperrflg,&errarr)
                     [errorLogged,errorreturn] PUBLIC {
    New errorLogged
    Quit $$CheckIntegrity(1,0,dir,,.errmaxperglobal,glo,,,
                          .glototblks,.glopntblks,.glototbytes,.glopntbytes,
                          .globigblks,.globigbytes,.globigstrings,.datasize,
                          .maperrflg,.errarr)
}
CheckDirIntegrity(dir,&%err,skipglobals,errmaxperglobal,errmaxperdir,globals) [errorLogged,errorreturn] PUBLIC {
	New errorLogged,errorreturn
	Set startdirtime=$zh
	Set errdirtotal=0
	Set skipglobals=$g(skipglobals)
	Set errmaxperglobal=$g(errmaxperglobal,100)
	Set errmaxperdir=$g(errmaxperdir,500)
	Set globals=$g(globals)
	Set out=$g(%err)
	Set:out="" out="%err",%err=""
	Set sc=1,scunexpected=1
	Try {
		Kill @out@(dir)
	} Catch {
		If $ZE["<SYNTAX" {
			Set sc=$$Error^%apiOBJ(216,out)
		} ElseIf $ZE["<SUBSCRIPT" {
			Set sc=$$Error^%apiOBJ(5007,dir)
		} Else {
			Set sc=$$Error^%apiOBJ(5002,$ZE)
		}
	}
	Quit:('sc) sc
	Set dirinfo=$zu(49,dir)
	If dirinfo<0 {
		If +dirinfo=-1,'$case($v($Piece(dirinfo,",",21)*$ZU(40,0,1)+$zu(40,2,128),-2,$ZU(40,0,1)),4294967295:0,:1) {
			Set sc=$$Error^%apiOBJ(327,$Piece(dirinfo,",",2)\1024)
		} Else {
			Set sc=$$Error^%apiOBJ($case(+dirinfo,-1:300,-2:6046,:314),dir)
		}
		Set @out@(dir)=$lb(1,$lb($zh-startdirtime),$e(sc,3,*))
		Quit sc
	}
	Set bigdb=$Piece(dirinfo,",",21)
	If 'bigdb {
		Set sc=$$Error^%apiOBJ(344)
		Set @out@(dir)=$lb(1,$lb($zh-startdirtime),$e(sc,3,*))
		Quit sc
	}
	Set scdir=$$GetDirGlobalsINTEG(dir,.glolist,.errs,.numgdir),sc=scdir
	For i=1:1:errs { Set sc=$select(+sc:errs(i),1:$$AppendStatus^%occSystem(sc,errs(i))) }
	Set errdirtotal=errdirtotal+errs 					// JPL1701
	If 'scdir { Set @out@(dir)=$lb(1,$lb($zh-startdirtime),$e(sc,3,*)) Quit scdir }
	Set rc=$$CheckFreeCount(dir,.freecount)
	If ('+rc) {
		Set errdirtotal=errdirtotal+1
		Set sc=$select(+sc:rc,1:$$AppendStatus^%occSystem(sc,rc))
	}
	Set rc=$$CheckMaps(dir)
	If ('+rc) {
		Set errdirtotal=errdirtotal+1
		Set sc=$select(+sc:rc,1:$$AppendStatus^%occSystem(sc,rc))
	}
	Set rc=$$CheckMIB(dir)
	If ('+rc) {
		Set errdirtotal=errdirtotal+1
		Set sc=$select(+sc:rc,1:$$AppendStatus^%occSystem(sc,rc))
	}
	Set nummaps=$p(dirinfo,",",24)
	Set contig=$Case(bigdb,0:0,1:16,2:8,3:4,4:2,5:1)
	Set maxsat=$Case(bigdb,1:5,2:2,3:1,4:1,5:1)
	Set diraddblks=2+numgdir
	For i=1:1:nummaps {
		If i=1 { Set diraddblks=diraddblks+12 }
		ElseIf i=2 { Set diraddblks=diraddblks+($case(contig,1:1,:(contig-1))*6)+((maxsat-1)*6) }
		ElseIf i#contig=1 { Set diraddblks=diraddblks+(contig*6) }
	}
	Set (dirpntbytes,dirtotbytes,dirpntblks,dirtotblks,dirbigbytes,dirbigblks,dirbigstrings)=0
	Set glo="",listptr=0,numglo=0
	For {
		If globals="" {
			Set glo=$o(glolist(glo))
			Quit:glo=""
		} Else {
			Quit:'$listnext(globals,listptr,glo)
			Continue:glo=""
		}
		Continue:$LF(skipglobals,glo)
		Set numglo=numglo+1
		Set rc=$$CheckIntegrity(1,0,dir,,errmaxperglobal,glo,.glolist,dirinfo,
		                        .glototblks,.glopntblks,.glototbytes,.glopntbytes,
		                        .globigblks,.globigbytes,.globigstrings,.datasize,
		                        1,.%err)
		If ('+rc) {
			Set errdirtotal=errdirtotal+1
			Set:errdirtotal'<errmaxperdir errorreturn="abortdir"
			If ($system.Status.GetErrorCodes(rc)'=267) {
				Set scunexpected=$select(+scunexpected:rc,1:$$AppendStatus^%occSystem(scunexpected,rc))
				Set sc=$select(+sc:rc,1:$$AppendStatus^%occSystem(sc,rc))
			}
		}
		Set dirtotblks=dirtotblks+glototblks,
		    dirtotbytes=dirtotbytes+glototbytes,
		    dirpntblks=dirpntblks+glopntblks,
		    dirpntbytes=dirpntbytes+glopntbytes,
		    dirbigblks=dirbigblks+globigblks,
		    dirbigbytes=dirbigbytes+globigbytes,
		    dirbigstrings=dirbigstrings+globigstrings
		Set:errorreturn="abortglo" errorreturn=""
		Quit:$g(errorreturn)'=""
	}
	Set tmp=$lb(errdirtotal,
	            $lb($zh-startdirtime,freecount,dirtotblks,dirtotbytes,dirpntblks,dirpntbytes,dirbigblks,dirbigbytes,dirbigstrings,diraddblks),
	            $select(sc:"",1:$e(sc,3,*)),
	            dirinfo,
	            errorreturn,
				$listbuild(numglo,numglo))	// RJF367
	Set @out@(dir)=tmp
	Set:errdirtotal sc=$$Error^%apiOBJ(267)
	Set:('scunexpected) sc=$select(+sc:scunexpected,1:$$AppendStatus^%occSystem(sc,scunexpected))
	Quit sc
}
CheckIntegrity(mode=1,numblks,dir,blk,errmaxperglobal=100,glo,&glolist,dirinfo,
               &glototblks,&glopntblks,&glototbytes,&glopntbytes,&globigblks,&globigbytes,&globigstrings,&datasize,
               maperrflg,&%err) [errorLogged,errorreturn] PUBLIC {
	Set $zt="errIntegrit"
	Set (sc,scmap,scmsg,scwar)=1
	Set (topptr,errglobaltotal,errsave,maperrtotal,blkchange,topptr,glototblks,glopntblks,glototbytes,glopntbytes,globigblks,globigbytes,globigstrings,nextlower,elapsed)=0
	Set (lowerblktype,errorreturn)=""
	Set level=1,st=$ZH
	Set strategy=0 ; assume original behavior
	Try { Set strategy=+$Get(^%SYS("Integrity","Strategy")) } Catch {}
	Set:$Extract($Get(glo))="^" glo=$Extract(glo,2,*)
	Set:'$D(dirinfo) dirinfo=$zu(49,dir)
	If dirinfo<0 { Quit $$Error^%apiOBJ(184) }
	Set blksize=$p(dirinfo,",",2)
	If blksize=2048 { Quit $$Error^%apiOBJ(344) }
	Set curblks=$p(dirinfo,",",22)
	Set datasize=$Case(blksize,2048:2036,:(blksize-$zu(40,32,10)))
	Set bigdatasize=datasize
	Set big=$p(dirinfo,",",21)
	Set out=$Select('$Data(%err):"",%err="":"%err",1:%err)
	If mode {
		Set startattop=1,numblks=0,range=-1,buildranges=0
		If out'="" { Set outsub=$Name(@out@(dir,glo)) Kill @outsub }
	} ElseIf mode=0 {
		Set startattop=0,numblks=$Get(numblks,1),range=-1,buildranges=0
		If out'="" { Set outsub=$Name(@out@(dir,glo)) Kill @outsub }
	} ElseIf mode="p" {
		Set startattop=1,numblks=0,range=0,buildranges=0
		If out'="" { Set outsub=$Name(@out@(dir,glo)) Kill @outsub }
	} ElseIf mode="q" {
		Quit:(out="") $$Error^%apiOBJ(52)
		Set startattop=1,numblks=0,range=0,buildranges=1
		Set outsub=$Name(@out@(dir,glo,"range",0))
		Kill @out@(dir,glo)
		Set @out@(dir,glo,"range")=1
		Set @out@(dir,glo,"range","ref",1)=glo
	} ElseIf mode="r" {
		Quit:(out="") $$Error^%apiOBJ(52)
		Set numblks=0,range=+blk,buildranges=0
		Set startattop='range
		Set outsub=$Name(@out@(dir,glo,"range",range)) 
		Kill @outsub
	} ElseIf mode="a" {
		Quit:(out="") $$Error^%apiOBJ(52)
		Set outsub=$Name(@out@(dir,glo))
		For range=0:1:+@outsub@("range") {
			Kill tmp
			Merge tmp=@outsub@("range",range)
			Continue:$Get(tmp)=""
			Set numrangeresults=$Get(numrangeresults)+1
			Set errglobaltotal=errglobaltotal+$List(tmp,1)
			If range=0 {
				Set scmsg=$$AppendStatus^%occSystem(scmsg,"1 "_tmp(0))
				Set inf=$List(tmp,3,*)
				Set $ListBuild(elapsed,level,glototblks,glototbytes,glopntblks,glopntbytes,globigblks,globigbytes,globigstrings)=$List(tmp,2)
			} Else {
				Set $ListBuild(rangeelapsed,,rangetotblks,rangetotbytes,rangepntblks,rangepntbytes,rangebigblks,rangebigbytes,rangebigstrings)=$List(tmp,2)
				Do $I(elapsed,rangeelapsed),$I(totblks,rangetotblks),$I(totbytes,rangetotbytes),
				   $I(pntblks,rangepntblks),$I(pntbytes,rangepntbytes),
				   $I(bigblks,rangebigblks),$I(bigbytes,rangebigbytes),$I(bigstrings,rangebigstrings)
			}
			Set:$Get(tmp(1))'="" scwar="1 "_tmp(1)
			If $Get(tmp(2))'="" {
				Set sc=$select(+sc:1_$e($$Error^%apiOBJ(210),2,*),1:$$AppendStatus^%occSystem(sc,1_$e($$Error^%apiOBJ(210),2,*)))
				Set sc=$select(+sc:"0 "_tmp(2),1:$$AppendStatus^%occSystem(sc,"0 "_tmp(2)))
			}
			Set:$Get(tmp(3))'="" errorreturn=tmp(3)
		}
		Set missing=$Get(numrangeresults)-1-range
		If missing {
			Set errglobaltotal=errglobaltotal+1
			Set sc=$select(+sc:1_$e($$Error^%apiOBJ(210),2,*),1:$$AppendStatus^%occSystem(sc,1_$e($$Error^%apiOBJ(210),2,*)))
			Set sc=$select(+sc:$$Error^%apiOBJ(222,missing),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(222,missing)))
		}
		Set totblks=totblks-bigblks,totbytes=totbytes-bigbytes
		Set startattop=1,numblks=0,range=-1,buildranges=0
		Set lowerblktype=8
		ZKill @outsub
		Kill @outsub@(1),@outsub@(2),@outsub@(3)
		Goto postnewlevel
	} Else {
		Quit $$Error^%apiOBJ(52)
	}
	If $Get(glolist)'=dir {
		Set sc=$$GetDirGlobalsINTEG(dir,.glolist)
		If ('sc) {
			Set errglobaltotal=errglobaltotal+1
			Goto intdone
		}
	}
	Open 63:"^^"_dir
	If 'startattop {
		If range>0 {
			Set ref=@out@(dir,glo,"range","ref",range)
			Set endref=$Get(@out@(dir,glo,"range","ref",range+1))
			Set blk=+$ListGet($Get(glolist(glo)))
			If 'blk {
				Set sc=$$Error^%apiOBJ(172)
				Set errglobaltotal=errglobaltotal+1
				Goto intdone
			}
			Try { Set tmp=$$ViewBlockFromTop^%GSIZE(-1,dir,ref,.blk,,blk) }
			Catch { Set tmp="0,"_$ze }
			If 'tmp	{
				Set ref("internal")=ref,col=$LG($g(glolist(glo)),2)
				Set:'$$GetPrintableRef^|"%SYS"|DMREPAIR(.ref,$zu(70,1,col)) ref("printable")="..."
				Set sc=$$Error^%apiOBJ(221,ref("printable"),$Piece(tmp,",",2))
				Set errglobaltotal=errglobaltotal+1
				Set errorreturn="abortglo"
				Goto intdone		
			}
		} Else { // mode=0
			If (blk\1'=blk)||(blk<1) {
				Set sc=$select(+sc:$$Error^%apiOBJ(6075,blk),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(6075,blk)))
				Set errglobaltotal=errglobaltotal+1
				Goto intdone
			}
			View blk
			Set pntblktype=$v($Zutil(40,32,1),0,1)
			If '($c(2,6,66,70)[$c(pntblktype)) {
					Set sc=$select(+sc:$$Error^%apiOBJ(173,blk,pntblktype),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(173,blk,pntblktype)))
				Set errglobaltotal=errglobaltotal+1
				Goto intdone
			}
			Set blkglo=$$GetGlobalName^|"%SYS"|DMREPAIR(1)
			If blkglo="" {
				Set sc=$$Error^%apiOBJ(283,blk)
				Set errglobaltotal=errglobaltotal+1
				Goto intdone
			}
			If '($d(glo)#2) {
				Set glo=blkglo
			} ElseIf glo'=blkglo {
				Set sc=$$Error^%apiOBJ(211)
				Set errglobaltotal=errglobaltotal+1
				Goto intdone
			}
			If '$LG($g(glolist(glo))) {
				Set sc=$$Error^%apiOBJ(172)
				Set errglobaltotal=errglobaltotal+1
				Goto intdone
			}
		}
		Set gcollate=$v($zu(40,32,2),0,1)
		Set col=$LG($g(glolist(glo)),2)
		If gcollate'=col {
			Set sc=$$Error^%apiOBJ(252,col,gcollate)
			Set errglobaltotal=errglobaltotal+1
			Goto intdone
		}
		Set blkimage=$v(0,0,-blksize)
		Kill mapblknum ; must be unset on input to $$IsBlockAllocated
		Set sc=$$IsBlockAllocated^|"%SYS"|DMREPAIR(dir,blk,.result,.mapblknum)
		If ('sc) {
			Set errglobaltotal=errglobaltotal+1
			Goto intdone
		} ElseIf 'result {
			Set sc=$$Error^%apiOBJ(284,"Pointer",blk,mapblknum)
			Set errglobaltotal=errglobaltotal+1
			Goto intdone
		}
		Open 63:"^^"_dir
		View 0:0:-blksize:blkimage
	} Else { // startattop is TRUE
		Set blk=+$LG($g(glolist(glo))),gcollate=$LG($g(glolist(glo)),2)
		If 'blk {
			Set sc=$$Error^%apiOBJ(172)
			Set errglobaltotal=errglobaltotal+1
			Goto intdone
		}
		If (blk\1'=blk)||(blk<0) {
			Set sc=$$Error^%apiOBJ(6075,blk)
			Set errglobaltotal=errglobaltotal+1
			Goto intdone
		}
		Set sc=$$IsBlockAllocated^|"%SYS"|DMREPAIR(dir,blk,.result)
		If ('sc) {
			Set errglobaltotal=errglobaltotal+1
			Goto intdone
		}
		Set:'result topptr=blk
		Open 63:"^^"_dir
		View blk
		Set link=$v($Zutil(40,32,4),0,4)
		If link {
			Set sc=$$Error^%apiOBJ(276,blk,link)
			Set errglobaltotal=errglobaltotal+1
			Goto intdone
		}
		Set glototblks=1,glopntblks=1,glototbytes=$v($zu(40,32,0),0,4),glopntbytes=glototbytes
		Do writelevel($v($Zutil(40,32,1),0,1),glopntblks,glopntbytes,0,0,0,blksize,datasize,bigdatasize,.scmsg,.inf)
		Set prevtotblks=(glototbytes+7)\8
	}
	Do newlevel
	Set elapsed=$zh-st
postnewlevel
	Set:'totblks totblks=1
	Set prevtotblks=totblks
	If errorreturn'="" { Goto intdone }
	Do writelevel(lowerblktype,totblks,totbytes,bigstrings,bigblks,bigbytes,blksize,datasize,bigdatasize,.scmsg,.inf)
	Set glototblks=glototblks+totblks+bigblks,
		glototbytes=glototbytes+totbytes+bigbytes,
		globigblks=globigblks+bigblks,
		globigbytes=globigbytes+bigbytes,
		globigstrings=globigstrings+bigstrings
	Set:(lowerblktype'=8) glopntblks=glopntblks+totblks,
									glopntbytes=glopntbytes+totbytes
	If startattop {
		Set level=level+1
		If (lowerblktype=8) {
			Set kb=glototblks*(blksize\1024),mb=0
			Set:kb>10240 kb=kb\1024,mb=1
			Set kb=$fn(kb,","),a=$fn(glototblks,",")
			Set scmsg=$$AppendStatus^%occSystem(scmsg,1_$e($$Error^%apiOBJ($Select(mb:202,1:106),a,kb,(glototbytes\glototblks*100\datasize)),2,*))
			Set scmsg=$$AppendStatus^%occSystem(scmsg,1_$e($$Error^%apiOBJ(107,$fn(elapsed,"",1),$zdt($h,-1)),2,*))
			Goto intdone
		}
		If (range=0) && (lowerblktype=6) &&
		   ('buildranges || (level>2)) { 
			Goto intdone
		}
		Set blk=nextlower
		If (blk\1'=blk)||(blk<1) {
			Set sc=$select(+sc:$$Error^%apiOBJ(6075,blk),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(6075,blk)))
			Set errglobaltotal=errglobaltotal+1
			Set errorreturn="abortglo"
			Goto intdone
		}
		View blk
		Do newlevel
		Set elapsed=$zh-st
		Goto postnewlevel
	}
intdone ; Save messages and return
	Close 63
	If buildranges && ((errorreturn'="") || (lowerblktype=8) || (level=1)) {
		Kill @out@(dir,glo,"range")
		Set outsub=$Name(@out@(dir,glo))
		Set range=-1
	}
	Set:((errorreturn'="")&&(range<0)) sc=$select(+sc:$case(errorreturn,"abortglo":$$Error^%apiOBJ(182),"abortdir":$$Error^%apiOBJ(181),:$$Error^%apiOBJ(223)),1:$$AppendStatus^%occSystem(sc,$case(errorreturn,"abortglo":$$Error^%apiOBJ(182),"abortdir":$$Error^%apiOBJ(181),:$$Error^%apiOBJ(223))))
	If out="" {
		If 'sc {
			// We have some global errors
			Set tmp=$$AppendStatus^%occSystem(scmap,scmsg)
			Set tmp=$$AppendStatus^%occSystem(tmp,1_$e($$Error^%apiOBJ(210),2,*))
			If blkchange {
				Set tmp=$$AppendStatus^%occSystem(tmp,$$Error^%apiOBJ(272,$Get(glo)))
				Set tmp=$$AppendStatus^%occSystem(tmp,$$Error^%apiOBJ(273))
			} Else {
				Set tmp=$$AppendStatus^%occSystem(tmp,$$Error^%apiOBJ(123,$Get(glo)))
			}
			Set:'scwar tmp=$$AppendStatus^%occSystem(tmp,scwar)
			Set sc=$$AppendStatus^%occSystem(tmp,sc)
		} ElseIf scwar'=1 {	// Check if it is not simply 1 (i.e. has warning messages)
			// We have some global warnings, no errors
			Set tmp=$$AppendStatus^%occSystem(scmap,scmsg)
			Set tmp=$$AppendStatus^%occSystem(tmp,1_$e($$Error^%apiOBJ(210),2,*))
			Set tmp=$$AppendStatus^%occSystem(tmp,1_$e($$Error^%apiOBJ(271,$Get(glo)),2,*))
			Set sc=tmp
		} Else {
			// We may have some database map errors, or only messages
			Set sc=$$AppendStatus^%occSystem(scmap,scmsg)
		}
	} Else {
		If 'scmap {
			Set tmp=$g(@out@(dir)),tmpmap=$lg(tmp,3,1),tmpmap=$$remduperr($select(+tmpmap:scmap,1:$$AppendStatus^%occSystem(tmpmap,scmap)))
			Set maperrtotal=$ll(tmpmap),$li(tmp)=maperrtotal,$li(tmp,3)=tmpmap,@out@(dir)=tmp
		}
		If sc {
			Set sc=scmsg
		} Else {
			Set @outsub@(2)=$e(sc,3,*)
			Set sc=$$Error^%apiOBJ(267)
		}
		Set:'scwar @outsub@(1)=$e(scwar,3,*)
		Set @outsub@(0)=$e(scmsg,3,*)
		Set:errorreturn'="" @outsub@(3)=errorreturn
		Set @outsub=$lb(errglobaltotal-maperrtotal,$lb(elapsed,level,glototblks,glototbytes,glopntblks,glopntbytes,globigblks,globigbytes,globigstrings))_$g(inf)
	}
	Quit sc
errIntegrit
	Set $Ztrap=""
	Close 63
	Quit:$ze["<NOTOPEN>" $$Error^%apiOBJ(184)
	Quit $$Error^%apiOBJ(5002,$Zerror)
newlevel ;
	Set $zt="errtrap"
	Set totblks=0,totbytes=0,bigblks=0,bigbytes=0,bigstrings=0
	Kill errsave Set errsave=0
	Set scabort=1
	Set rangeref=""
	Set pntblktype=$v($Zutil(40,32,1),0,1)
	If '($c(2,6,66,70)[$c(pntblktype)) { Set scabort=($$Error^%apiOBJ(173,blk,pntblktype)) Goto donelevel }
	If pntblktype'=66,pntblktype'=70 {
		If level=1,startattop { Set scabort=($$Error^%apiOBJ(174,blk,pntblktype)) Goto donelevel }
	} ElseIf level>1 { Set scabort=($$Error^%apiOBJ(175,blk,pntblktype)) Goto donelevel }
	If startattop {
		try { Set tmp=$v(1,-6) } 
		catch { Set scabort=($$Error^%apiOBJ(283,blk)) Goto donelevel }
		If (tmp'=glo) {
			If (level=1) { Set scabort=($$Error^%apiOBJ(285,blk,"^"_glo)) Goto donelevel } 
			Else { Set scabort=($$Error^%apiOBJ(286,blk,"^"_glo)) Goto donelevel }
		}
	}
	Set lowerblktype=$case(pntblktype,6:8,70:8,:0)
	Set gcol=$G(gcollate)*65536
	try { Set nextlower=$v(2,-5) } 
	catch { Set scabort=($$Error^%apiOBJ(283,blk)) Goto donelevel }
	Set nextlowergref=""
	Set prevpntblk=0
	Set value=""
	Set pntcount=1
	Set lowerlink=0
	Set:startattop maxblks=$S(prevtotblks<1000:2000,1:2*prevtotblks)
	Kill oldblks
	Do $zu(92,1)
	For {
		Set crc=$$calccrc(blksize)
		Set value=$v(lowerlink,-7,nextlowergref,lowerblktype+gcol)
		If value {
			If +value=1 {
				Set errorreturn="abortdir",
					errglobaltotal=errglobaltotal+1,
					sc=$select(+sc:$$Error^%apiOBJ(111),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(111)))
				Quit
			}
			For i=1:1:3 {
				Do cluwdwait(dir)
				View blk
				Set ncrc=$$calccrc(blksize)
				Set pntlink=$v($Zutil(40,32,4),0,4)
				Set oldval=value
				Set value=$v(lowerlink,-7,nextlowergref,lowerblktype+gcol)
				If 'value {
					Set:crc'=ncrc errsave=errsave+1,errsave(errsave)=$LB(lowerblktype,blk,ncrc,lowerlink,nextlowergref,prevpntblk,0,-1)
					Set rangeref=""
					Goto addblks
				}
				If ncrc=crc {
					Quit:value=oldval
				}
			}
			Set errsave=errsave+1
			Set errsave(errsave)=$LB(lowerblktype,blk,ncrc,lowerlink,nextlowergref,prevpntblk,value,crc'=ncrc)
			Quit:(pntlink>curblks)||(+value=39)
			Set lowerlink=0 ; We don't know what should be in this case
		} Else {
addblks
			Set totblks=totblks+$p(value,",",2),
				totbytes=totbytes+$p(value,",",3),
				pntlink=$p(value,",",4),
				lowerlink=$p(value,",",5),
				lowerblktype=$p(value,",",6),
				bigblks=bigblks+$p(value,",",7),
				bigbytes=bigbytes+$p(value,",",8),
				bigstrings=bigstrings+$p(value,",",9)
			Set:rangeref'="" @out@(dir,glo,"range","ref",$i(@out@(dir,glo,"range")))=rangeref
		}
		Quit:'pntlink
		If numblks { Set numblks=numblks-1 Quit:'numblks }
		Set prevpntblk=blk,blk=pntlink,pntcount=pntcount+1
		If (blk\1'=blk)||(blk<1) { Set scabort=($$Error^%apiOBJ(6075,blk)) Goto donelevel }
		If startattop {
			If maxblks<2048 {
				If $d(oldblks(blk)) { Set scabort=($$Error^%apiOBJ(278,level,prevpntblk,blk)) Goto donelevel }
				Set oldblks(blk)=""
			}
			If pntcount>maxblks { Set scabort=($$Error^%apiOBJ(277,level,prevtotblks,pntcount)) Goto donelevel }
		}
		View blk
		Set nextlowergref=$p(value,",",10,999)
		If buildranges && (lowerblktype=6) && (pntblktype'=66) {
			Try { Set rangeref=$View(1,-6)} 
			Catch { Set rangeref="" }
		}
		If ($Get(endref)'="") && ($v($Zutil(40,32,1),0,1)=pntblktype) {
			Try { Set tmp=$View(1,-6),tmpblk=$View(2,-5) }
			Catch { Set (tmp,tmpblk)="" }
			If ($Piece(tmp,$C(0),1)=glo) && (endref']tmp) {
				If (lowerlink && (lowerlink'=tmpblk)) ||
				   ((nextlowergref'="") && 
					  $Select(lowerblktype=8:tmp'=nextlowergref,
													 1:tmp']nextlowergref)) {
					Set numblks=1
				} Else { 
					Quit
				}
			}			
		}
	}
donelevel
	Do $zu(92,2)
	Set errcnt=0,chgcnt=0
	If topptr {
		Set sc=$select(+sc:$$Error^%apiOBJ(266,topptr),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(266,topptr)))
		Set topptr=0,errcnt=errcnt+1,errglobaltotal=errglobaltotal+1
	}
	For curerr=1:1:$o(errsave(""),-1) {
		Quit:errorreturn'=""
		Continue:'$D(errsave(curerr),val)
		Set blk=$LI(val,2),
			lowerlink=$LI(val,4),
			nextlowergref=$LI(val,5),
			prevpntblk=$LI(val,6),
			flg=$LG(val,8),
			val=$LI(val,7)
		If flg {
			If flg=-1 {
				Set:scwar'=1 scwar=1_$e($$Error^%apiOBJ(255),2,*)
				Continue
			}
			Set sc=$select(+sc:1_$e($$Error^%apiOBJ(210),2,*),1:$$AppendStatus^%occSystem(sc,1_$e($$Error^%apiOBJ(210),2,*)))
			Set sc=$select(+sc:$$Error^%apiOBJ(256,blk),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(256,blk)))
			Set chgcnt=chgcnt+1
		}
		Set errcnt=errcnt+1
		Set numerrs=$l(val,"^")
		For errnum=1:1:numerrs { 
			Set value=$p(val,"^",errnum) 
			Do errorprc
		}
	}
	If 'scabort {
		Set errglobaltotal=errglobaltotal+1
		Set sc=$select(+sc:1_$e($$Error^%apiOBJ(210),2,*),1:$$AppendStatus^%occSystem(sc,1_$e($$Error^%apiOBJ(210),2,*)))
		Set sc=$select(+sc:scabort,1:$$AppendStatus^%occSystem(sc,scabort))
		Set:errorreturn="" errorreturn="abortglo"
	}
	Set:level=1 blkchange=1
	Set:errcnt'=chgcnt blkchange=0
	Set:errorreturn'="" blkchange=0
	Quit
errtrap
	Set $zt=""
	Set errglobaltotal=errglobaltotal+1
	Set errorreturn="abortglo"
	If $ze["<INTERRUPT>" { 
		try {
			Use 0
			Write !,$p($SYSTEM.Status.GetErrorText($$Error^%apiOBJ(206)),":",2)
			If $$YESNO(0) { Set errorreturn="abortsys" Quit }
			Write !,$p($SYSTEM.Status.GetErrorText($$Error^%apiOBJ(207)),":",2)
			If $$YESNO(0) { Set errorreturn="abortdir" Quit }
		} catch {}
	}
	Set sc=$select(+sc:1_$e($$Error^%apiOBJ(210),2,*),1:$$AppendStatus^%occSystem(sc,1_$e($$Error^%apiOBJ(210),2,*)))
	Set sc=$select(+sc:$$Error^%apiOBJ(5002,$ZE),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(5002,$ZE)))
	Set:$ze'["<INTERRUPT>" sc=$select(+sc:$$Error^%apiOBJ(180,$Get(value)_" ["_$zu(56,2)_"]"),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(180,$Get(value)_" ["_$zu(56,2)_"]")))
	Quit   
errorprc ;
	Set errcode=+value,
		curnode=+$p(value,",",2),
		errmapblk=+$p(value,",",3),
		errvalue=+$p(value,",",4),
		errdatblk=+$p(value,",",5)
	If errcode=1 {
		Set sc=$select(+sc:$$Error^%apiOBJ(111),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(111)))
		Set errorreturn="abortdir"
		Goto errdone
	}
	If errcode=20,$g(maperrflg) { Set errorreturn="" Quit }
	Set sc=$select(+sc:1_$e($$Error^%apiOBJ(210),2,*),1:$$AppendStatus^%occSystem(sc,1_$e($$Error^%apiOBJ(210),2,*)))
	Set sc=$select(+sc:$$Error^%apiOBJ(108,errcode,blk),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(108,errcode,blk)))
	If prevpntblk,big {
		Set sc=$select(+sc:$$Error^%apiOBJ(113,prevpntblk),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(113,prevpntblk)))
		Close 63  
		If +$$FindLeftBlock^|"%SYS"|DMREPAIR(dir,prevpntblk,.left),'left {
			Set sc=$select(+sc:$$Error^%apiOBJ(112),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(112)))
		}
		Open 63:"^^"_dir
	}
	If (blk\1'=blk)||(blk<1) {					// SJ2912+
		Set sc=$select(+sc:$$Error^%apiOBJ(6075,blk),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(6075,blk)))
		Set errorreturn="abortglo"
		Goto errdone
	}								// SJ2912-
	Set pntref="",pntvalue=""
	View blk
	Goto:errcode=8 err8
	Goto:errcode=29 err29
	If errdatblk {
		If (errdatblk\1'=errdatblk)||(errdatblk<0) {		// SJ2912+
			Set sc=$select(+sc:$$Error^%apiOBJ(6075,errdatblk),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(6075,errdatblk)))
			Set errorreturn="abortglo"
			Goto errdone
		}							// SJ2912-
		View errdatblk
		Set:('+$$GetNodeReferences^|"%SYS"|DMREPAIR(curnode-1*2+1,,.pntref)) pntref="..."
		Set sc=$select(+sc:$$Error^%apiOBJ(109,curnode),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(109,curnode)))
		Set sc=$select(+sc:$$Error^%apiOBJ(274,pntref,errdatblk),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(274,pntref,errdatblk)))
	} ElseIf curnode {
		Set:('+$$GetNodeReferences^|"%SYS"|DMREPAIR(curnode-1*2+1,,.pntref)) pntref="..."
		Set sc=$select(+sc:$$Error^%apiOBJ(109,curnode),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(109,curnode)))
		Try {							// SJ3022+
			Set pntvalue=$v(curnode*2,-5)
			Set sc=$select(+sc:$$Error^%apiOBJ(122,pntref,pntvalue),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(122,pntref,pntvalue)))
		} Catch {
			Set sc=$select(+sc:$$Error^%apiOBJ(275,pntref),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(275,pntref)))
		}							// SJ3022-
	}
	Goto $Case(errcode,2:err2,3:err3,4:err4,5:err5,6:err6,7:err7,8:err8,9:err9,
					   10:err10,11:err11,12:err12,13:err13,14:err14,15:err15,
					   16:err16,17:err17,18:err18,19:err19,20:err20,21:err21,
					   22:err22,23:err23,24:err24,25:err25,26:err26,27:err27,
					   28:err28,30:err30,31:err31,32:err32,33:err33,34:err34,
					   35:err35,36:err36,37:err37,38:err38,39:err39,
			   :errdone)
err2 ;
	Set sc=$select(+sc:$$Error^%apiOBJ(116),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(116))) Goto errdone
err3 ;
	Set:('+$$GetNodeReferences^|"%SYS"|DMREPAIR(1,,.eref)) eref="..."
	Set sc=$select(+sc:$$Error^%apiOBJ(117,eref,$v(2,-5),lowerlink),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(117,eref,$v(2,-5),lowerlink)))
	Goto errdone
err4 ;
	Set:('+$$GetNodeReferences^|"%SYS"|DMREPAIR(1,,.eref)) eref="..."
	Set sc=$select(+sc:$$Error^%apiOBJ(118,eref),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(118,eref)))
	If lowerblktype=8 {
		Set sc=$select(+sc:$$Error^%apiOBJ(120),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(120)))
	} Else {
		Set sc=$select(+sc:$$Error^%apiOBJ(119),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(119)))
	}
	Set sc=$select(+sc:$$Error^%apiOBJ(121,$$decodeReference(nextlowergref,$Zutil(70,1,$View($Zutil(40,32,2),0,1)))),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(121,$$decodeReference(nextlowergref,$Zutil(70,1,$View($Zutil(40,32,2),0,1))))))
	Goto errdone
err5 ;
	Set sc=$select(+sc:$$Error^%apiOBJ(125,errvalue),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(125,errvalue)))
	Set sc=$select(+sc:$S(lowerblktype:$$Error^%apiOBJ(126,lowerblktype),1:$$Error^%apiOBJ(268)),1:$$AppendStatus^%occSystem(sc,$S(lowerblktype:$$Error^%apiOBJ(126,lowerblktype),1:$$Error^%apiOBJ(268))))
	Goto errdone
err6 ;
	Set sc=$select(+sc:$$Error^%apiOBJ(128),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(128)))
	Set sc=$select(+sc:$$Error^%apiOBJ(130),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(130)))
	Set sc=$select(+sc:$$Error^%apiOBJ(132),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(132)))
	Goto errdone
err7 ;
	Set sc=$select(+sc:$$Error^%apiOBJ(127),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(127)))
	Set sc=$select(+sc:$$Error^%apiOBJ(130),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(130)))
	Set sc=$select(+sc:$$Error^%apiOBJ(131),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(131)))
	Goto errdone
err8 ; 
	Set sc=$select(+sc:$$Error^%apiOBJ(114),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(114)))
	Goto errdone
err9 ;
	Set sc=$select(+sc:$$Error^%apiOBJ(115),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(115)))
	Goto errdone
err10 ;
	Set sc=$select(+sc:$$Error^%apiOBJ(133),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(133)))
	Set sc=$select(+sc:$$Error^%apiOBJ(134),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(134)))
	Goto errdone
err11 ;
	Set sc=$select(+sc:$$Error^%apiOBJ(133),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(133)))
	Set sc=$select(+sc:$$Error^%apiOBJ(135),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(135)))
	Goto errdone
err12 ;
	Set sc=$select(+sc:$$Error^%apiOBJ(133),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(133)))
	Set sc=$select(+sc:$$Error^%apiOBJ(136),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(136)))
	Goto errdone
err13 ;
	Set sc=$select(+sc:$$Error^%apiOBJ(133),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(133)))
	Set sc=$select(+sc:$$Error^%apiOBJ(138),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(138)))
	Goto errdone
err14 ;
	Set sc=$select(+sc:$$Error^%apiOBJ(133),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(133)))
	Set sc=$select(+sc:$$Error^%apiOBJ(139),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(139)))
	Goto errdone
err15 ;
	Set sc=$select(+sc:$$Error^%apiOBJ(140),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(140)))
	Set sc=$select(+sc:$$Error^%apiOBJ(142),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(142)))
	Goto errdone
err16 ;
	Set sc=$select(+sc:$$Error^%apiOBJ(141),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(141)))
	Set sc=$select(+sc:$$Error^%apiOBJ(143),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(143)))
	Goto errdone
err17 ;
	Set sc=$select(+sc:$$Error^%apiOBJ(115),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(115)))
	Set sc=$select(+sc:$$Error^%apiOBJ(144),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(144)))
	Goto errdone
err18 ;
	Set sc=$select(+sc:$$Error^%apiOBJ(145,errvalue),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(145,errvalue)))
	Goto errdone
err19 ;
	Set sc=$select(+sc:$$Error^%apiOBJ(150),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(150)))
	Set sc=$select(+sc:$$Error^%apiOBJ(151),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(151)))
	Goto errdone
err20 ;
	Set scmap=$select(+scmap:$$Error^%apiOBJ(152,errmapblk),1:$$AppendStatus^%occSystem(scmap,$$Error^%apiOBJ(152,errmapblk)))
	Set maperrtotal=maperrtotal+1
	Goto errdone
err21 ;
	Set sc=$select(+sc:$$Error^%apiOBJ(153,errvalue,errmapblk),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(153,errvalue,errmapblk)))
	Goto errdone
err22 ;
	Set sc=$select(+sc:$$Error^%apiOBJ(154,errvalue),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(154,errvalue)))
	Set sc=$select(+sc:$$Error^%apiOBJ(155,errmapblk),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(155,errmapblk)))
	Goto errdone
err23 ;
	Set sc=$select(+sc:$$Error^%apiOBJ(156),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(156)))
	Goto errdone
err24 ;
	Set sc=$select(+sc:$$Error^%apiOBJ(157),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(157)))
	Set sc=$select(+sc:$$Error^%apiOBJ(158),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(158)))
	If lowerblktype=8 {
		Set sc=$select(+sc:$$Error^%apiOBJ(160),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(160)))
	} Else {
		Set sc=$select(+sc:$$Error^%apiOBJ(159),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(159)))
	}
	If (pntvalue\1'=pntvalue)||(pntvalue<1) {			// SJ2912+
		Set sc=$select(+sc:$$Error^%apiOBJ(6075,pntvalue),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(6075,pntvalue)))
		Set errorreturn="abortglo"
		Goto errdone
	}								// SJ2912-
	Try { View pntvalue Set:('+$$GetNodeReferences^|"%SYS"|DMREPAIR(-1,,.eref)) eref="..." }
	Catch { Set eref="..." }
	Set sc=$select(+sc:$$Error^%apiOBJ(161,eref),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(161,eref)))
	View blk
	Set:('+$$GetNodeReferences^|"%SYS"|DMREPAIR(curnode*2+1,,.eref)) eref="..."
	Set sc=$select(+sc:$$Error^%apiOBJ(162,eref),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(162,eref)))
	Goto errdone
err25 ;
	Set sc=$select(+sc:$$Error^%apiOBJ(163),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(163)))
	Set sc=$select(+sc:$$Error^%apiOBJ(164),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(164)))
	If (pntvalue\1'=pntvalue)||(pntvalue<1) {			// SJ2912+
		Set sc=$select(+sc:$$Error^%apiOBJ(6075,pntvalue),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(6075,pntvalue)))
		Set errorreturn="abortglo"
		Goto errdone
	}								// SJ2912-
	Try { View pntvalue Set:('+$$GetNodeReferences^|"%SYS"|DMREPAIR(0,,.eref)) eref="..." }
	Catch { Set eref="..." }
	If lowerblktype=8 {
	   Set sc=$select(+sc:$$Error^%apiOBJ(166),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(166)))
	   Set sc=$select(+sc:$$Error^%apiOBJ(167,eref),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(167,eref)))
	} Else {
	   Set sc=$select(+sc:$$Error^%apiOBJ(165,eref),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(165,eref)))
	}
	Goto errdone
err26 ;
	View blk
	Set sc=$select(+sc:$$Error^%apiOBJ(110,errvalue),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(110,errvalue)))
	Try {							// SJ3050+
		Set pntvalue=$v(curnode+1*2,-5)
		Set sc=$select(+sc:$$Error^%apiOBJ(168,pntvalue),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(168,pntvalue)))
	} Catch {
		Set sc=$select(+sc:$$Error^%apiOBJ(279),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(279)))
	}								// SJ3050-
	Goto errdone
err27 ;
	Set sc=$select(+sc:$$Error^%apiOBJ(169,errvalue),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(169,errvalue)))
	Set sc=$select(+sc:$$Error^%apiOBJ(170),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(170)))
	Goto errdone
err28 ;
	Set sc=$select(+sc:$$Error^%apiOBJ(171,errvalue),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(171,errvalue)))
	Set sc=$select(+sc:$$Error^%apiOBJ(170),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(170)))
	Goto errdone
err29 ;
	Set sc=$select(+sc:$$Error^%apiOBJ(171,0),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(171,0)))
	Set sc=$select(+sc:$$Error^%apiOBJ(203,errvalue),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(203,errvalue)))
	Goto errdone
err30 ;
	Set sc=$select(+sc:$$Error^%apiOBJ(209,errmapblk,errvalue),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(209,errmapblk,errvalue)))
	Goto errdone
err31 ;
	Set sc=$select(+sc:$$Error^%apiOBJ(133),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(133)))
	Set sc=$select(+sc:$$Error^%apiOBJ(250),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(250)))
	Goto errdone
err32 ;
	Set $ZT="err32a"
	If (pntvalue\1'=pntvalue)||(pntvalue<1) {			// SJ2912+
		Set sc=$select(+sc:$$Error^%apiOBJ(6075,pntvalue),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(6075,pntvalue)))
		Set errorreturn="abortglo"
		Goto errdone
	}								// SJ2912-
	View pntvalue
	For N=1:1 {
	Set X=$V(N-1*2+1,-6)
	Quit:X=""
	}
	Goto errdone
err32a ;
	Set $ZT=""
	If $ZE["<FUNCTION" {
		Set sc=$select(+sc:$$Error^%apiOBJ(251,N,pntvalue),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(251,N,pntvalue)))
	}
	Goto errdone
err33 ;
	Set sc=$select(+sc:$$Error^%apiOBJ(252,errvalue,gcollate),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(252,errvalue,gcollate)))
	Goto errdone
err34 ;
	Set sc=$select(+sc:$$Error^%apiOBJ(253,errmapblk,errvalue),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(253,errmapblk,errvalue)))
	Goto errdone
err35 ;
	Set sc=$select(+sc:$$Error^%apiOBJ(254,errmapblk,errvalue),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(254,errmapblk,errvalue)))
	Goto errdone
err36 ;
	Set sc=$select(+sc:$$Error^%apiOBJ(171,errvalue),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(171,errvalue)))
	Set sc=$select(+sc:$$Error^%apiOBJ(203,0),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(203,0)))
	Goto errdone
err37 ; 
	Set sc=$select(+sc:$$Error^%apiOBJ(281),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(281)))
	Goto errdone
err38 ;
	Set sc=$select(+sc:$$Error^%apiOBJ(282),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(282)))
	Goto errdone
err39		
	Set sc=$select(+sc:$$Error^%apiOBJ(291,errvalue),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(291,errvalue)))
	Goto errdone
 ;
errdone ;
	Set errglobaltotal=errglobaltotal+1
	Quit:errorreturn'=""
	If errglobaltotal'<errmaxperglobal {
		Set errorreturn="abortglo"
		Quit
	}
	Quit
}
remduperr(sc) PRIVATE {
	Set sc=$e(sc,3,*)
	For i=1:1:$ll(sc) {	Set tmp($li(sc,i))="" }
	Set tmp=""
	Set i="" For { Set i=$o(tmp(i)) Quit:i=""  Set tmp=tmp_i }
	Quit tmp
}
calccrc(blksize) [] PRIVATE { Set crc=0 For i=0:2048:blksize-2048 { Set crc=$zcrc($v(i,0,-2048),7,crc) } Quit crc }
cluwdwait(dir) PRIVATE {
	If $S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0),$ZU(59),$P($ZU(49,dir,2),",",2) {
		Set wdphase=$V($ZU(40,2,145),-2,4)
		Set wdpass=$V($ZU(40,2,147),-2,4) ;non-zero = wd's in the middle of a cycle
		Set:wdphase wdpass=wdpass+1  ;wait for this cycle and the next one
		For {
			Quit:$ZU(51,129)
			Set curwdpass=$v($ZU(40,2,147),-2,4)
			Quit:curwdpass>wdpass
			Hang 1
		}
	} Else {
		Hang .5
	}
}
writelevel(blktype,totblks,totbytes,bigstrings,bigblks,bigbytes,blksize,datasize,bigdatasize,&sc,&inf) PRIVATE {
	Set inf=$g(inf)_$lb($s(blktype=8:$lb(1,totblks,totbytes,bigstrings,bigblks,bigbytes),1:$lb(0,totblks,totbytes)))
	Set kb=totblks*(blksize\1024),mb=0
	Set:kb>10240 kb=kb\1024,mb=1
	Set kb=$fn(kb,","),a=$fn(totblks,",")
	If (blktype=8 || (blktype=9) || (blktype=12) || (blktype=24)) {
		Set sc=$$AppendStatus^%occSystem(sc,1_$e($$Error^%apiOBJ($Select(mb:201,1:105),a,kb,(totbytes\totblks*100\datasize)),2,*))
	} ElseIf blktype=70 {
		Set sc=$$AppendStatus^%occSystem(sc,1_$e($$Error^%apiOBJ($Select(mb:200,1:104),a,kb,(totbytes\totblks*100\datasize)),2,*))
	} ElseIf blktype=2 {
		Set sc=$$AppendStatus^%occSystem(sc,1_$e($$Error^%apiOBJ($Select(mb:199,1:103),a,kb,(totbytes\totblks*100\datasize)),2,*))
	} ElseIf blktype=6 {
		Set sc=$$AppendStatus^%occSystem(sc,1_$e($$Error^%apiOBJ($Select(mb:198,1:102),a,kb,(totbytes\totblks*100\datasize)),2,*))
	} ElseIf blktype=66 {
		Set sc=$$AppendStatus^%occSystem(sc,1_$e($$Error^%apiOBJ($Select(mb:197,1:101),a,kb,(totbytes\totblks*100\datasize)),2,*))
	}
	If bigstrings {
		Set kb=bigblks*(blksize\1024),mb=0
		Set:kb>10240 kb=kb\1024,mb=1
		Set kb=$fn(kb,","),a=$fn(bigblks,",")
		Set sc=$$AppendStatus^%occSystem(sc,1_$e($$Error^%apiOBJ($Select(mb:176,1:177),$fn(bigstrings,","),a,kb,bigbytes\bigblks*100\bigdatasize),2,*))
	}
}
GetDirGlobals(dir,array) [temp] PUBLIC
{
 new temp
 k array
 if $e(dir)'="^"&&(dir'["^") s dir="^^"_dir
 s rc=$$GetGlobalDirectoryInfo(dir,"temp",.tally,0)
 Q:('rc) rc
 s n="" f  s n=$o(temp(n),1,info) q:n=""  s array(n)=$p(info,"^",3)
 q 1
}
GetDirGlobalsCol(dir,&array) PUBLIC {
    New %
    Kill array
    If $e(dir)'="^",dir'["^" { Set dir="^^"_dir }
    Set rc=$$GetGlobalDirectoryInfo(dir,"%",.tally,0)
    Quit:('rc) rc
    Set n=""
    For {
        Set n=$o(%(n),1,info)
        Quit:n=""
        Set ptrblk=+$p(info,"^",3)
        Set:ptrblk array(n)=$LB(ptrblk,+$p(info,"^",5))
    }
    Quit 1
}
GetDirGlobalsINTEG(dir,&array,&errs,&numdirblks) PUBLIC {
	Kill array,errs 
	Set errs=0,numdirblks=0
	Set nsp="^^"_dir
	Set rc=$$GetDatabaseInfo(nsp,.dbinfo)
	Quit:('rc) rc
	Set $zt="err"
	Set gdblk=+$p(dbinfo,",",7)
	Quit:($Piece(dbinfo,",",2)=2048) $$Error^%apiOBJ(344)
	Open 63:nsp
	Set array=dir
	Do {
		If (gdblk\1'=gdblk)||(gdblk<1) {
			Set rc=$$Error^%apiOBJ(6075,gdblk)
			Quit
		}
		Set numdirblks=numdirblks+1
		Set prevblk=gdblk
		Try { View gdblk }
		Catch {
			Set rc=$$Error^%apiOBJ(257,gdblk)
			Set readerr=1
		}
		Quit:$get(readerr)
		If $v($Zutil(40,32,1),0,1)'=9 {
			Set rc=$$Error^%apiOBJ(270,gdblk,$v($Zutil(40,32,1),0,1))
			Quit
		}
		Set linkblk=$v($Zutil(40,32,4),0,4)
		If $v($zu(40,32,0),0,4) {
			Kill names,values,num
			Set rc=$$ParseRepairViewBuf^|"%SYS"|DMREPAIR(dir,,.names,,.values,,,,,,,.num)
			If ('rc) {
				Set errs=errs+1
				Set errs(errs)=$$EmbedStatus^%apiOBJ($$Error^%apiOBJ(280,gdblk),rc)
				Set rc=1
			}
			Open 63:nsp ; Reopen view buffer (ParseRepairViewBuf closes it for some reason!)
			For i=1:1:num {
				Set name=names(i),ptrblk=$p(values(i),",")
				If '$zname(name,3) {
					Set errs=errs+1,errs(errs)=$$Error^%apiOBJ(258,name,i,gdblk)
				} Else {
					Set:ptrblk array(name)=$LB(ptrblk,+$p(values(i),",",3))
				}
			}
		}
		Set gdarr(gdblk)=""
		Set gdblk=linkblk
		If $d(gdarr(gdblk)) {
			Set rc=$$Error^%apiOBJ(269,prevblk,gdblk)
			Quit
		}
	} While gdblk
	Close 63
	Quit:(''rc) 1
	Quit:'$d(gdarr) rc
	Set errs=errs+1
	Set errs(errs)=rc    
	Quit 1
err
	Set $Ztrap=""
	Close 63
	Quit:$Zerror["<NOTOPEN>" $$Error^%apiOBJ(184)
	Quit $$Error^%apiOBJ(5002,$Zerror)
}
SetVars(dir) [dir] PUBLIC
{
 s dirinfo=$zu(49,dir) i (+dirinfo)<0 Quit $$Error^%apiOBJ(184)
 s %blksize=$p(dirinfo,",",2)
 s %uic=$p(dirinfo,",",3)
 s %filesize=$p(dirinfo,",",4)
 s %maxblks=$p(dirinfo,",",6)
 s %gdirblk=$p(dirinfo,",",7)
 s %gpblk=$p(dirinfo,",",8)
 s %ggblk=$p(dirinfo,",",11)
 s %totvol=$p(dirinfo,",",15)
 s %isbigdb=$p(dirinfo,",",21)
 s %curblks=$p(dirinfo,",",22)
 s %blkspermap=$p(dirinfo,",",23)
 s %curmaps=$p(dirinfo,",",24)
 s %freeze=$p(dirinfo,",",12)
 Quit 1
}
setMessage(msgname,msgcode,msgtext)
 New locale Set locale="ENU"
 Set global="^%Messages"
 Set @global@(msgcode,"name")=msgname
 Set @global@(msgcode,"text",locale)=msgtext
 Quit  
DecomposeStatus(sc,msglist,flag,locale) [] PUBLIC
{
 s $zt="errDecompose"
 Set ans=$SYSTEM.Status.DecomposeStatus(sc,.msglist,$Case($g(flag),1:"d",:""),$Get(locale))
 i '$d(msglist) s msglist=0 q ans
 f i=1:1:msglist s msglist(i)=$e(msglist(i),$f(msglist(i),":"),$l(msglist(i)))
 Quit ans
errDecompose
 Quit ""
}
getEnvironment()
 Quit $zcvt($e($Get(^|"^^"_$zu(12)|%SYS("LOCALE","CURRENT"),"ENU"),1,3),"U")
Status(err,code,message1,message2,message3,message4)
 q err_" "_$lb($lb(code,message1,message2,message3,message4))
AppendStatus(sc1,sc2) ;
 Set $Ztrap="appendErr"
 q (+sc1&+sc2)_" "_$e(sc1,3,$l(sc1))_$e(sc2,3,$l(sc2))
appendErr
 Set $Ztrap="" 
 I '$Get(errorLogged) i $zu(9,"","Error occurred while appending messages: "_$ze) Set errorLogged=1
 s errorreturn="abortdir"
 Quit sc1 
ErrorGlobal(errorcode) ;
 q "^%Messages"
 ;  
Import(filename,unicode) ;
 n (filename,unicode)
 ;
 s unicode=+$g(unicode)
 s mode=$s(unicode:"RK\UnicodeLittle\",1:"R")
 ;
 s $zt="ImportEOF"
 o filename:mode:2 e  w "Can not open file to read: "_filename,! q
 ;
 i unicode u filename r header#1
 ;
 s locale="ENU"
 ;
 f  u filename r line d
 . i $$parseerrorline(line,.errorname,.errortext,.errorcode,.locale)=0 q
 . s global=$$ErrorGlobal(errorcode)
 . s @global@(errorcode,"name")=errorname
 . s @global@(errorcode,"text",locale)=errortext
 . s @global@("name",errorname)=errorcode
 ;
ImportEOF ;
 c filename
 i $p($ze,">",1)'="<ENDOFFILE" w $ZE,!
 ;
 q
 ;
parseerrorline(line,name,text,code,locale) ;
 n i,j,l,quote
 s line=$tr(line,$c(9)," ")
 i $tr(line,$c(32))="" q 0
 i $e($tr(line,$c(32)),1,2)="#;" q 0
 ;
 i $e($tr(line,$c(32)),1,8)="#;locale" s locale=$e($tr(line,$c(32)),8,*),locale=$p(locale,"""",2) q 0
 ;
 s l=$l(line)+1
 ;
 s i=0 f j=i+1:1:l q:$e(line,j)'=" "
 s i=j f j=i+1:1:l q:$e(line,j)=" "
 s name=$e(line,i,j-1)
 ;
 s i=j f j=i+1:1:l q:$e(line,j)'=" "
 s i=j f j=i+1:1:l q:$e(line,j)=" "
 s code=+$e(line,i,j-1)
 ;
 s i=j f j=i+1:1:l q:$e(line,j)=""""
 s i=j f j=i+1:1:l i $e(line,j)="""" q:$e(line,j+1)'=""""  s:$e(line,j+1)="""" j=j+1
 ;
 s quote=$e(line,i,j)
 x "set text="_quote
 ;
 q 1
GetFreeCount(dir,free,datafree) [] PUBLIC
{
 Set $Ztrap="errGetFreeCount"
 n $namespace Do $zu(5,"%SYS")
 i $g(dir)']"" s dir=$zu(12,"")
 Set db=##class(SYS.Database).%OpenId(dir)
 s free=0
 Set sc=db.GetFreeSpace(dir,,.free)
 Set datafree=free
 Kill db
 Quit sc
errGetFreeCount
 Set $Ztrap="" Kill db Quit $$Error^%apiOBJ(5002,$Zerror)
}
CheckFreeCount(dir,freecount) [] PUBLIC
{
	Set $Ztrap="errCheckFreeCount"
	If $g(dir)']"" { s dir=$zu(12,"") }
	Set sc=1
	Set info=$zu(49,dir)
	If (+info)<-1 { Quit $$Error^%apiOBJ(184) }
	Set blksiz=$Piece(info,",",2)
	If blksiz=2048 { Quit $$Error^%apiOBJ(90) }
	Set bigval=$Piece(info,",",21)
	Set nummap=$Piece(info,",",24)
	Set mapsiz=$Piece(info,",",23)
	Set freecount=0
	Open 63:"^^"_dir
	Set curblks=$Piece(info,",",22)
	Set size=blksiz\4096
	Set off=$Zutil(40,0,51)+(size*4)
	Set mapdataoff=off+(((size*32)-size-1)*4) ;macroize this
	Set numbytes=mapsiz\8
	For map=0:1:nummap-1 {
		Set mapblock=$$findMapBlock(map,bigval)
		If (mapblock\1'=mapblock)||(mapblock<1) {
			Set sc=$$Error^%apiOBJ(6075,mapblock)
			Quit
		}
		View mapblock
		Set bitcount=0
		set bytesread=0
		while bytesread<numbytes {
		    Set viewstrsiz=numbytes-bytesread
		    Set:viewstrsiz>32700 viewstrsiz=32700
		    Set bits=$View(mapdataoff+bytesread,0,-(viewstrsiz))
		    Set bytesread=bytesread+viewstrsiz
		    Set bitcount=bitcount+$Zbitcount($c(0)_bits)
		}
		Set freecount=freecount+$View($zu(40,32,10),0,4)
		If bitcount'=$View($zu(40,32,10),0,4) Set sc=$select(+sc:$$Error^%apiOBJ(204,mapblock,$View($zu(40,32,10),0,4),bitcount),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(204,mapblock,$View($zu(40,32,10),0,4),bitcount)))
	}
	Close 63
	Quit sc  
errCheckFreeCount
	Close 63
	Set $Ztrap="" i $ze["<NOTOPEN>" q $$Error^%apiOBJ(184)
	Quit $$Error^%apiOBJ(5002,$Zerror)
}
findSATMapBlock(map,bigval) [] PUBLIC
{
 Quit $Case(map,0:(5+5),:$Case(bigval,1:(30*32*32)		/* 4kb */+(15*(5+1))+2,2:((31+30)*32*32)	/* 8kb */+(7*(5+1))+2,3:0,4:0,5:0)+map-1)
}
findMapBlock(map,bigval) [] PUBLIC
{
 If 'bigval Quit map*$Case(bigval,0:400,1:30720,2:62464,3:125952,4:252928,5:506880)+$Case(bigval,0:1,:2)
 Else  If 'map Quit $Case(bigval,0:1,:2)
 Set mapsiz=$Case(bigval,0:400,1:30720,2:62464,3:125952,4:252928,5:506880)
 Set contigcount=$Case(bigval,0:0,1:16,2:8,3:4,4:2,5:1)
 If map<contigcount {
    Quit mapsiz+map+1
 }
 Else {
    Set modval=map#contigcount
    Quit ((map-modval)*mapsiz)+modval+2
 }
}
CheckMaps(dir) [] PUBLIC
{
	Set sc=1
	Try {
		Set info=$zu(49,dir)
		If +info<-1 { Set sc=$$Error^%apiOBJ(184) Quit }
		Set bigval=$Piece(info,",",21)
		If 'bigval { Set sc=$$Error^%apiOBJ(344) Quit }
		Set nummap=$Piece(info,",",24)
		Set mapsiz=$Case(bigval,0:400,1:30720,2:62464,3:125952,4:252928,5:506880)
		Do GetBitmaps(nummap,bigval,.bitmapsm,.bitmapss,.bitmapsi,.bitmapsI)
		Open 63:"^^"_dir
		// get gfcreatedatelow/high from gfstruct in the label block
		View 1
		Set datelow=$v(1128,0,4)
		Set datehigh=$v(1128+4,0,4)
		// Check Map blocks
		Set i=""
		For {
			Set i=$o(bitmapsm(i)) Quit:i=""
			Do chkmap(bitmapsm(i),"m",i)
		}
		// Check SATMAP blocks
		For {
			Set i=$o(bitmapss(i)) Quit:i=""
			Do chkmap(bitmapss(i),"s",datelow,datehigh)
		}
		// Check Incremental Bitmap blocks
		For {
			Set i=$o(bitmapsi(i)) Quit:i=""
			For j=0:1:5-1 {
				Do chkmap(bitmapsi(i,j),"i",i,j)
			}
		}
		// Check Secondary Incremental Bitmap blocks
		For {
			Set i=$o(bitmapsI(i)) Quit:i=""
			For j=0:1:5-1 {
				Do chkmap(bitmapsI(i,j),"I",,j)
			}
		}
		// Check Volume Information Blocks
		Set block=$p(info,",",30),multivol=$p(info,",",15)-1
		Set sfn=+$zu(49,dir) ; fetch info again to get SFN now that we know it's mounted 
		Set i=0,nonce=0
		While block {
			If i=multivol { Set nextblock=0 }
			Else { Set nextblock=$list($system.DB.GetVolInfo(sfn,i+1),2) }
			View block
			If $v($Zutil(40,32,1),0,1)'=18 {
				Set sc=$select(+sc:$$Error^%apiOBJ(292,block,i,$v($Zutil(40,32,1),0,1)),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(292,block,i,$v($Zutil(40,32,1),0,1))))
			} Else {
				Set:($view(36,0,4)'=i) sc=$select(+sc:$$Error^%apiOBJ(293,block,i),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(293,block,i)))
				Set:($view(48,0,4)'=datelow)||($view(52,0,4)'=datehigh) sc=$select(+sc:$$Error^%apiOBJ(294,block,i),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(294,block,i)))
				Set:($view(56,0,8)'=$select(i:block,1:1)) sc=$select(+sc:$$Error^%apiOBJ(296,block,i),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(296,block,i)))
				Set:($view(64,0,8)'=nextblock) sc=$select(+sc:$$Error^%apiOBJ(297,block,i,$view(64,0,8)),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(297,block,i,$view(64,0,8))))
				If nonce=0 { 
					Set nonce=$view(40,0,4) 
				} ElseIf nonce'=$view(40,0,4) { 
					Set sc=$select(+sc:$$Error^%apiOBJ(295,block,i),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(295,block,i)))
				}
			}
			d chkalloc(block,18)
			Set i=i+1,block=nextblock
		}
	} Catch {
		Set sc=$select(+sc:$s($ze["<NOTOPEN>":$$Error^%apiOBJ(184),1:$$Error^%apiOBJ(5002,$Zerror)),1:$$AppendStatus^%occSystem(sc,$s($ze["<NOTOPEN>":$$Error^%apiOBJ(184),1:$$Error^%apiOBJ(5002,$Zerror))))
	}
	Close 63
	Quit sc
chkmap(block,type,mapnum,filenum)
	; uses other variables from above "constants" 
	If (block\1'=block)||(block<1) {
		Set sc=$select(+sc:$$Error^%apiOBJ(6075,block),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(6075,block)))
		Quit
	}
	View block
	If $v(4,0,1)'=16 {
		Set sc=$select(+sc:$$Error^%apiOBJ(260,$case(type,"m":"Map","s":"SATMAP","i":"Incremental Bitmap","I":"Secondary Incremental Bitmap"),block),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(260,$case(type,"m":"Map","s":"SATMAP","i":"Incremental Bitmap","I":"Secondary Incremental Bitmap"),block)))
	}
	If $v((28+4),0,-9)'=("CacheMap"_type) {
		Set sc=$select(+sc:$$Error^%apiOBJ(261,$case(type,"m":"Map","s":"SATMAP","i":"Incremental Bitmap","I":"Secondary Incremental Bitmap"),block),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(261,$case(type,"m":"Map","s":"SATMAP","i":"Incremental Bitmap","I":"Secondary Incremental Bitmap"),block)))
	}
	If ((type="m")||(type="i")),($v((28+16),0,4)'=mapnum) {
		Set sc=$select(+sc:$$Error^%apiOBJ(262,$case(type,"m":"Map","s":"SATMAP","i":"Incremental Bitmap","I":"Secondary Incremental Bitmap"),block),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(262,$case(type,"m":"Map","s":"SATMAP","i":"Incremental Bitmap","I":"Secondary Incremental Bitmap"),block)))
	}
	If ((type="i")||(type="I")),($v((28+13),0,1)'=filenum) {
		Set sc=$select(+sc:$$Error^%apiOBJ(263,$case(type,"m":"Map","s":"SATMAP","i":"Incremental Bitmap","I":"Secondary Incremental Bitmap"),block),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(263,$case(type,"m":"Map","s":"SATMAP","i":"Incremental Bitmap","I":"Secondary Incremental Bitmap"),block)))
	}
	If (($v((28+24),0,4)'=datelow) ||
	    ($v((28+28),0,4)'=datehigh)) {
		Set sc=$select(+sc:$$Error^%apiOBJ(264,$case(type,"m":"Map","s":"SATMAP","i":"Incremental Bitmap","I":"Secondary Incremental Bitmap"),block),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(264,$case(type,"m":"Map","s":"SATMAP","i":"Incremental Bitmap","I":"Secondary Incremental Bitmap"),block)))
	}
	If $v((28+14),0,1) {
		Set sc=$select(+sc:$$Error^%apiOBJ(265,$case(type,"m":"Map","s":"SATMAP","i":"Incremental Bitmap","I":"Secondary Incremental Bitmap"),block),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(265,$case(type,"m":"Map","s":"SATMAP","i":"Incremental Bitmap","I":"Secondary Incremental Bitmap"),block)))
	}
	If '$zu(196) {
		Set sc=$select(+sc:$$Error^%apiOBJ(259,$case(type,"m":"Map","s":"SATMAP","i":"Incremental Bitmap","I":"Secondary Incremental Bitmap"),block),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(259,$case(type,"m":"Map","s":"SATMAP","i":"Incremental Bitmap","I":"Secondary Incremental Bitmap"),block)))
	}
	Do chkalloc(block,type)
	Quit
chkalloc(block,type)
	Kill mapblknum ; must be unset on input to $$IsBlockAllocated
	Set allocsc=$$IsBlockAllocated^|"%SYS"|DMREPAIR(dir,block,.result,.mapblknum)
	If ('allocsc) {
		Set sc=$select(+sc:allocsc,1:$$AppendStatus^%occSystem(sc,allocsc))
	} ElseIf 'result {
		Set sc=$select(+sc:$$Error^%apiOBJ(284,$select(type=18:"Volume Info",1:$case(type,"m":"Map","s":"SATMAP","i":"Incremental Bitmap","I":"Secondary Incremental Bitmap")),block,mapblknum),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(284,$select(type=18:"Volume Info",1:$case(type,"m":"Map","s":"SATMAP","i":"Incremental Bitmap","I":"Secondary Incremental Bitmap")),block,mapblknum)))
	}
	Open 63:"^^"_dir
	Quit
}
GetBitmaps(curmaps,bigval,&bitmapsm,&bitmapss,&bitmapsi,&bitmapsI) PUBLIC {
    Set contigmaps=$case(bigval,1:16,2:8,3:4,4:2,5:1)
    Set maxsatblks=$case(bigval,1:5,2:2,3:1,4:1,5:1)
    Set mapsiz=$case(bigval,1:(30*32*32)		/* 4kb */,2:((31+30)*32*32)	/* 8kb */,3:((31*3+30)*32*32)	/* 16kb */,4:((31*7+30)*32*32)	/* 32kb */,5:((31*15+30)*32*32)	/* 64kb */)
    If (curmaps=1) {
        Set lastmap=0
    } ElseIf (curmaps<contigmaps) {
        Set lastmap=contigmaps-1
    } Else {
	set lastmap=((curmaps\contigmaps+''(curmaps#contigmaps))*contigmaps)-1
    }
    ; handle first map special case
    Set bitmapsm(0)=2 ; first map block is block two
    For file=0:1:5-1 {
        Set bitmapsi(0,file)=5+file ; first incrbk is block five
    }
    Set bitmapss(0)=bitmapsi(0,0)+5 ; first sat map after incrbks
    For file=0:1:5-1 {
        Set bitmapsI(0,file)=bitmapss(0)+1+file
    }
    ; second map in first map region special case
    Quit:'lastmap
    For i=1:1:maxsatblks-1 {
        Set bitmapss(i)=mapsiz+2+(i-1)+((contigmaps-1)*(5+1))
    }
    Set ms=maxsatblks-1,bitss=bitmapss(ms)+1
    For i=1:1:maxsatblks-1 {
        For file=0:1:5-1 {
	    Set bitmapsI(i,file)=bitss+(file*ms)
	}
    }
    For i=1:1:(contigmaps-1) {
        Set bitmapsm(i)=mapsiz+i+1
	For file=0:1:5-1 {
	    Set bitmapsi(i,file)=mapsiz+2+(i-1)+((file+1)*(contigmaps-1))
	}
    }
    ; done with special first map region, the rest is the general case
    For i=contigmaps:1:lastmap {
        Set bitmapsm(i)=(i#contigmaps)+2+(mapsiz*contigmaps*(i\contigmaps))
	For file=0:1:5-1 {
	    Set bitmapsi(i,file)=bitmapsm(i)+((file+1)*contigmaps)
	}
    }
}
CheckMIB(dir) [] PUBLIC {
	Set sc=1
	Try {
		Set info=$zu(49,dir)
		If +info<0 { 
			Set sc=$$Error^%apiOBJ(184) 
			Quit
		}
		Set block=+$system.Mirror.DBGetInfo(1,+info)
		Quit:'block
		Kill mapblknum ; must be unset on input to $$IsBlockAllocated
		Set sc=$$IsBlockAllocated^|"%SYS"|DMREPAIR(dir,block,.result,.mapblknum)
		Quit:('sc)
		Set:'result sc=$select(+sc:$$Error^%apiOBJ(284,"Mirror Information",block,mapblknum),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(284,"Mirror Information",block,mapblknum)))
		Open 63:"^^"_dir
		View block
		Set:($v($Zutil(40,32,1),0,1)'=17) sc=$select(+sc:$$Error^%apiOBJ(260,"Mirror Information",block),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(260,"Mirror Information",block)))
	} Catch {
		Set sc=$select(+sc:$s($ze["<NOTOPEN>":$$Error^%apiOBJ(184),1:$$Error^%apiOBJ(5002,$Zerror)),1:$$AppendStatus^%occSystem(sc,$s($ze["<NOTOPEN>":$$Error^%apiOBJ(184),1:$$Error^%apiOBJ(5002,$Zerror))))
	}
	Close 63
	Quit sc
}
IsMaxDBMounted() [] PUBLIC
{
 Set maxdb=$System.License.MaxDB() if maxdb=0 Quit 0
 Set ndb=0 f i=0:1:($v($zu(40,2,176),-2,4)-1) s t=$zu(49,i,3) i +t>-1 s gfstatus=$p(t,"^",7) i '$zb(+gfstatus,$ZU(40,8,4)+$zu(40,8,10),1) s ndb=ndb+1
 Quit ndb>=maxdb
}
GetGlobalPointers(dir,global,top,firstdata,nodata) [] PUBLIC
{
    Set $Ztrap="errGetPointers"
    Set:$g(dir)']"" dir=$zu(12,"")
    Set:$Extract(global)="^" global=$Extract(global,2,*)
    Set gloref="^|"_"""^^"_dir_"""|"_global
    Set nodata='($Data(@gloref))
    Set gvec=$zu(208),top=$li(gvec,5),firstdata=+$lg(gvec,24)
    Quit 1
errGetPointers
    Quit $$Error^%apiOBJ(5002,$Zerror)
}
CreateGlobal(ns,glo,collation,protect,journal,keep,ptrblk,growthblk) [] PUBLIC {
 Set $Ztrap="errCreateGlobal"
 If ns="" Set ns="^^"_$zu(12,"")
 If $Extract(ns,1,2)'="^^" {
   Set $Ztrap="errNs" 
   Set index=$zu(90,3,1,$zcvt(ns,"U"))
   If 'index s ns="^^"_ns
 }
afterNs
 Set sc=1
 if $e(glo)="^" s glo=$e(glo,2,$l(glo))
 Set rc=$Zutil(178,ns,glo,$Case($Data(collation),1:collation,:-1),$Case($Data(protect),1:protect,:-1),-1,$Case($Data(keep),1:keep,:-1),$Case($Data(ptrblk),1:ptrblk,:-1),$Case($Data(growthblk),1:growthblk,:-1))
 If rc=1 Quit 1
 If ('rc) Quit $$Error^%apiOBJ(334,glo)
 If rc=-1 Quit $$Error^%apiOBJ(333,glo)
 If rc=-2 Quit $$Error^%apiOBJ(335,glo)
errNs
 Set $zt="errCreateGlobal",$ze=""
 Goto afterNs
errCreateGlobal 
 Set $Ztrap=""
 Quit $select(+sc:$$Error^%apiOBJ(5002,$Zerror),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(5002,$Zerror)))
}
SystemDatabaseList(dblist) [] PUBLIC {
	;Returns a list of all directories containing primary
	;(CACHE.DAT) and secondary (CACHE.EXT) files for the
	;entire system
	;
	;Results returned in dblist, passed by reference
	;
	;dblist is killed on entry
	;
	;results are:
	;  dblist(<dir>)=<# of secondary volumes>
	;  dblist(<dir>,1)=<secondary volume #1>
	;  dblist(<dir>,2)=<secondary volume #2>
	;  .
	;  .
	;  .
	;  dblist(<dir>,n)=<secondary volume #n>
	k dblist
	f sfn=0:1:$ZU(40,0,41)-1 {
	   s dbinfo=$ZU(49,+sfn,3)     ; Returns -2 for deleted database
	   if '+dbinfo {  ;local database
	      s dbname=$P(dbinfo,"^",2)
                  do getvolinfo(.dblist,dbname)
	   }
	}
}
GetGloInt() [] Public {
    Quit $li($zu(208),14)_$c(0)
}
%FREECOUNT(Type="") PUBLIC {
 s $zt="Error"
 i '($e($roles,1,$l("%All"))="%All") { n $ET,$roles s $ET="",$roles=$roles_","_"%All"} ; verified 9/26/16 STC
 Set dir=$zu(12,"")
 n $namespace d $zu(5,"%SYS")
 i Type="" {
	Do FREECOUNT^DATABASE($Case(dir=$zu(12),0:dir,:""))
 } else {
	Do FREECOUNT^DATABASE(Type)
 }
 q
Error s $zt=""
 w !,"Error: "_$ze
 q
}
NSPDatabaseList(NSP,dblist) PUBLIC {
	;Returns a list of all directories containing primary
	;(CACHE.DAT) and secondary (CACHE.EXT) files which are
	;involved in the specified namespace.
	;
	;Results returned in dblist, passed by reference
	;
	;dblist is killed on entry
	;
	;results are:
	;  dblist(<dir>)=<# of secondary volumes>
	;  dblist(<dir>,1)=<secondary volume #1>
	;  dblist(<dir>,2)=<secondary volume #2>
	;  .
	;  .
	;  .
	;  dblist(<dir>,n)=<secondary volume #n>
	s NSP=$ZCVT(NSP,"u")
	new %data  ;must be % variable so %GXLINFO can see it
	k dblist
	s trans=$name(%data)
	do 
	. n (%data)
	. do TRANSNSP^%SYS.GXLINFO(trans,NSP)
	s d=$O(@trans@(NSP,"("))
	f  {
		q:"(["'[$E(d_"X")
		s dir=@trans@(NSP,d,"I")
		q:$E(dir,3,4)'="^^"  ; not a local database  
		s db=$E(dir,5,$L(dir)-2)
		s dblist(db)=""
		s d=$O(@trans@(NSP,d))
	}
	s:'$L(@trans@(NSP,"defsys")) dblist(@trans@(NSP,"defdir"))=""
	s:'$L(@trans@(NSP,"syssys")) dblist(@trans@(NSP,"sysdir"))=""
	s n=@trans@(NSP,"#")
	f i=1:1:n {
		s ent=$O(@trans@(NSP,"#",i,"slm",0,""))
		while ($L(ent)) {
		   s targid=@trans@(NSP,"#",i,"slm",0,ent,"implid")
		   ; if its local, record the db name
		   if targid,'$ZU(90,6,targid) s dblist($ZU(90,7,targid))=""
		   s ent=$O(@trans@(NSP,"#",i,"slm",0,ent))
		}
	}
	k @trans
	; dblist() is a list of databases, mapped by this namespace,
	; now check for 2ndary volumes
	s d=""
	f  s d=$O(dblist(d)) q:d=""  do getvolinfo(.dblist,d)
}
getvolinfo(dblist,dbname) {
	; Subroutine which takes a database name and generates a
	; dblist() entry with that name, the # of 2ndary volumes
	; and the list of directories containing the 2ndary volumes
	; (if there are any).
	; 
	s dbinfo2=$ZU(49,dbname)
	s volcnt=$P(dbinfo2,",",15)
	s volcnt=volcnt-1
	s dblist(dbname)=volcnt
	if (volcnt) {
	   if +$P(dbinfo2,",",2)'=2048 {
	      // New format database
	      for i=1:1:volcnt {
		     s dblist(dbname,i)=$ZU(36,dbname,0,i)
	      }
	   } else {
		  // Old format 2KB database
		  s nextvol=$ZU(36,dbname,0,1)
		  for i=1:1:volcnt {
		     s dblist(dbname,i)=nextvol
			 s nextvol=$ZU(36,nextvol,1,1)
	      }
       } 	   
    }
}
decodeReference(iref,colrule)
 New i,len,ref,start
 Set len=$Length(iref)
 Set (i,start)=1
 Set ref=""
 Set $Ztrap="errdecodeRef"
 For i=start:1:len Quit:'$Ascii(iref,i)
 Set ref=$Extract(iref,start,i-1)_"("""
 Set start=i+1
 While (i<len) {
    For i=start:1:len Quit:'$Ascii(iref,i)  
    If i=len Set ref=ref_$Zutil(70,3,$Extract(iref,start,i),colrule)_""")"
    Else  Set ref=ref_$Zutil(70,3,$Extract(iref,start,i-1),colrule)_""","
    Set start=i+1
 }
 Quit ref
errdecodeRef Set $Zerror="" Quit ref_"..."
CreateMessagesInc
 w !,"This routine will create the MESSAGES.INC file from MESSAGES.TXT"
 w !!,"Add debug messages? No=> " r yn:5 s yn=$zcvt(yn,"U")
 i yn="Y" s debug=1 
 e  s debug=0
 s f="messages.txt",LINES=0,SIZE=0
 s $zt="EOF"
 o f u f f  r x d
 . s LINES=LINES+1
 . i ($e(x,1,2)="#;")!($tr($tr(x,$c(9)," ")," ","")="") s ^rINC("MESSAGES",0,LINES)=x,SIZE=SIZE+$l(x) q
 . s x="#define "_$p(x,"""",1) i debug s x=x_"/*"_$p(x,"""",2)_"*/"
 . s ^rINC("MESSAGES",0,LINES)=x,SIZE=SIZE+$l(x)
 q
EOF s $zt=""
 c f
 i $ze'["ENDOFFILE" w !,"Error creating MESSAGES.INC - "_$ZE h 10 q
 s ^rINC("MESSAGES",0,0)=LINES
 s ^rINC("MESSAGES","SIZE")=SIZE
 s ^rINC("MESSAGES",0)=$H
 q
effectChange(global,dir,typeoff) ;
 Do  If $Zutil(154)
 . Set $zt="erreffectChange" If $Get(@("^|""^^"_dir_"""|"_global))
 Quit
erreffectChange ;
 Quit
RemJob() Public { s $zt="errRemJob"
 d $zu(5,"%SYS")
 s gn=$G(^%SYS("TempResultGlobalName"),"CacheTempUtil")
 s:$e(gn)="^" gn=$e(gn,2,*)
 s save=$name(@("^"_gn_"(""REMOTEDIRS"")"))
 Set Rset = ##class(%Library.ResultSet).%New("Config.Databases:List")
 d Rset.Execute(,,1)
 While (Rset.Next()) {
	s dir=Rset.Get("Directory")
	If $e(dir,$l(dir))=$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"") Set dir=$e(dir,1,$l(dir)-1)
	s Obj=##Class(SYS.Database).%OpenId(dir)
	i Obj="" {
		s @save@("Directory",dir)=""
	} else {
		s @save@("Directory",dir)=Obj.GetStatus()
	}
	k Obj			
	k DBList
	Set rc=##class(Config.Databases).DatabasesByDirectory("",dir,.DBList)
	i +rc,DBList'="" s @save@("Directory",dir,$li(DBList))=""
	e  s @save@("Directory",dir,"unknown")=""
 }
 s @save=""
errRemJob
 s $zt=""
 s @save=""
 Quit ;$$$ERROR($$$ObjectScriptError,$Zerror)
}
RemJobM() Public { s $zt="errRemJobM"
 d $zu(5,"%SYS")
 s gn=$G(^%SYS("TempResultGlobalName"),"CacheTempUtil")
 s:$e(gn)="^" gn=$e(gn,2,*)
 s save=$name(@("^"_gn_"(""REMOTEDIRS"")"))
 s mirname=##class(Config.Mirrors).GetMirrorName()
 s ds=$$GetNextDatabaseByName^%SYS.CONFIG("")
 s mirrorbit=+$ZU(40,8,28)
 while ds'="" {
	s dbinfo=$$DatabaseByName^%SYS.CONFIG(ds)
	 if $p(dbinfo,"^",2)="" {
		 s info=$ZU(49,$p(dbinfo,"^",3,999))
		 if +info<-1 {
			 s ds=$$GetNextDatabaseByName^%SYS.CONFIG(ds)
			 continue
		 }
		 s dbattrib=+$p(info,",",17)  ;even when not mounted, $ZU(49) data is returned
		 if $zb(+dbattrib,+mirrorbit,1)&&(mirname'="") {
			 s info=$SYSTEM.Mirror.DBGetInfoByName(0,$p(dbinfo,"^",3,999))
			 if info="DOWN" {
				 s ds=$$GetNextDatabaseByName^%SYS.CONFIG(ds)
				 continue
			 }
			 if ((info="") || (mirname'=$P(info,"^",8))) {
				 s ds=$$GetNextDatabaseByName^%SYS.CONFIG(ds)
				 continue
			 }
			 s dir=":mirror:"_mirname_":"_$P(info,"^",2)
		 } else {
			 s dir=":ds:"_ds
		 }
		 s Obj=##Class(SYS.Database).%OpenId($p(dbinfo,"^",3,999))
		 i Obj="" {
    		s @save@("Directory",dir)=""
		 } else {
    		s @save@("Directory",dir)=Obj.GetStatus()
		 }
		 k Obj			
		 s @save@("Directory",dir,ds)=""
	 }
	 s ds=$$GetNextDatabaseByName^%SYS.CONFIG(ds)
 }
errRemJobM
 s $zt=""
 s @save=""
 Quit ;$$$ERROR($$$ObjectScriptError,$Zerror)
}
RemJobGblLst() Public { s $zt="errRemJobGblLst"
 d $zu(5,"%SYS")
 s save=$name(^IRIS.TempUtil("REMOTEGBLS"))
 s dir=@save@(0) k @save@(0)
 d GetDirGlobals(dir,.array)
 m @save=array
errRemJobGblLst
 s $zt=""
 s @save=""
 Quit ;$$$ERROR($$$ObjectScriptError,$Zerror)
}
YESNO(default)
 n a,b,x,v
 s x=$x
 s a=$s(default=0:$s($e("%CHUI.YesNo")="%":$g(^%qMsg("%CHUI.YesNo",$s($mvv(58)="":"en",1:$mvv(58)),"NO"),$g(^%qMsg("%CHUI.YesNo","en","NO"),"No message found. Domain: "_"%CHUI.YesNo"_" Id: "_"NO")),1:$g(^IRIS.Msg("%CHUI.YesNo",$s($mvv(58)="":"en",1:$mvv(58)),"NO"),$g(^IRIS.Msg("%CHUI.YesNo","en","NO"),"No message found. Domain: "_"%CHUI.YesNo"_" Id: "_"NO"))),1:$s($e("%CHUI.YesNo")="%":$g(^%qMsg("%CHUI.YesNo",$s($mvv(58)="":"en",1:$mvv(58)),"YES"),$g(^%qMsg("%CHUI.YesNo","en","YES"),"No message found. Domain: "_"%CHUI.YesNo"_" Id: "_"YES")),1:$g(^IRIS.Msg("%CHUI.YesNo",$s($mvv(58)="":"en",1:$mvv(58)),"YES"),$g(^IRIS.Msg("%CHUI.YesNo","en","YES"),"No message found. Domain: "_"%CHUI.YesNo"_" Id: "_"YES"))))
 F  DO  Q:$D(v)
 . W *-1," "_a_" => " R b I b="" S b=a
 . S b=$zcvt($e(b),"U") 
 . i b=$s($e("%CHUI.YesNo")="%":$g(^%qMsg("%CHUI.YesNo",$s($mvv(58)="":"en",1:$mvv(58)),"NOAbbreviated"),$g(^%qMsg("%CHUI.YesNo","en","NOAbbreviated"),"No message found. Domain: "_"%CHUI.YesNo"_" Id: "_"NOAbbreviated")),1:$g(^IRIS.Msg("%CHUI.YesNo",$s($mvv(58)="":"en",1:$mvv(58)),"NOAbbreviated"),$g(^IRIS.Msg("%CHUI.YesNo","en","NOAbbreviated"),"No message found. Domain: "_"%CHUI.YesNo"_" Id: "_"NOAbbreviated"))) s v=0 q
 . i b=$s($e("%CHUI.YesNo")="%":$g(^%qMsg("%CHUI.YesNo",$s($mvv(58)="":"en",1:$mvv(58)),"YESAbbreviated"),$g(^%qMsg("%CHUI.YesNo","en","YESAbbreviated"),"No message found. Domain: "_"%CHUI.YesNo"_" Id: "_"YESAbbreviated")),1:$g(^IRIS.Msg("%CHUI.YesNo",$s($mvv(58)="":"en",1:$mvv(58)),"YESAbbreviated"),$g(^IRIS.Msg("%CHUI.YesNo","en","YESAbbreviated"),"No message found. Domain: "_"%CHUI.YesNo"_" Id: "_"YESAbbreviated"))) s v=1 q
 . W *7," "_$s($e("%CHUI.YesNo")="%":$g(^%qMsg("%CHUI.YesNo",$s($mvv(58)="":"en",1:$mvv(58)),"YESNOAnswer"),$g(^%qMsg("%CHUI.YesNo","en","YESNOAnswer"),"No message found. Domain: "_"%CHUI.YesNo"_" Id: "_"YESNOAnswer")),1:$g(^IRIS.Msg("%CHUI.YesNo",$s($mvv(58)="":"en",1:$mvv(58)),"YESNOAnswer"),$g(^IRIS.Msg("%CHUI.YesNo","en","YESNOAnswer"),"No message found. Domain: "_"%CHUI.YesNo"_" Id: "_"YESNOAnswer"))),!,?x
 Q v

%SYS.DOCDB^INT^1^67214,47330
%SYSDOCDB ;Security APIs ; $Change: 2818542 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	; Revision: $Id: //iris/latest/databases/sys/rtn/sysconfig/_sys.docdb.mac#1 $
q
CheckAccess(Name,Namespace="",PermRequired="U") Public {
 S $zt="Error"
 i Namespace="" s Namespace=$namespace
 s Namespace=$zcvt(Namespace,"U")
 s Status=$$CheckServiceStatus(Name,Namespace)
 i '(''Status) q Status
 i '($d(^|"^^"_$zu(12)|SYS("Security","DocDBsD",$zcvt(Name,"L"),$zcvt(Namespace,"L")),DocDBRecord)#10=1) {
	s Status=$$Error^%apiOBJ(793,Name,Namespace)
	g Fail
 }
 i '$li(DocDBRecord,3) {
	s Status=$$Error^%apiOBJ(792,Name,Namespace)
	g Fail
 }
 s Resource=$li(DocDBRecord,6)
 i Resource'="" {
	i '$SYSTEM.Security.Check(Resource,PermRequired) {
		s Status=$$Error^%apiOBJ(791,$username,Name,Namespace)
		g Fail
	}
 }
 q 1
Fail
 s EventData=$SYSTEM.Status.GetErrorText(Status)
 s EventData=EventData_$c(13)_$c(10)_"Name:      "_$g(Name)
 s EventData=EventData_$c(13)_$c(10)_"Namespace: "_$g(Namespace)
 s EventData=EventData_$c(13)_$c(10)_"Resource:  "_$g(Resource)_":"_$g(PermRequired)
 d $SYSTEM.Security.Audit("%System","%Security","Protect",EventData,"Doc DB Access")
 q Status
Error Set $zt=""
 s Status=$$Error^%apiOBJ(5002,$ze)
 g Fail
}
CheckAdmin(Name="", Namespace="") Public {
 s $zt="Error"
 i '$SYSTEM.Security.Check("%DocDB_Admin","USE") {
	i '$SYSTEM.Security.Check("%Admin_Secure","USE") {
		s Status=$$Error^%apiOBJ(790,"%Admin_Secure"_":"_"USE","%DocDB_Admin"_":"_"USE")
		g Fail
	}
 }
 s Status=$$CheckServiceStatus(Name,Namespace)
 i '(''Status) q Status
 q 1
Fail
 s EventData=$SYSTEM.Status.GetErrorText(Status)
 s EventData=EventData_$c(13)_$c(10)_"Name:      "_$g(Name)
 s EventData=EventData_$c(13)_$c(10)_"Namespace: "_$g(Namespace)
 s EventData=EventData_$c(13)_$c(10)_"Resource:  "_"%DocDB_Admin"_":USE"
 d $SYSTEM.Security.Audit("%System","%Security","Protect",EventData,"Doc DB Access")
 q Status
Error Set $zt=""
 s Status=$$Error^%apiOBJ(5002,$ze)
 g Fail
}
CheckServiceStatus(Name="",Namespace="") Public {
 S $zt="Error"
 i '($d(^|"^^"_$zu(12)|SYS("Security","ServicesD",$zcvt("%Service_DocDB","L")),ServiceRecord)#10=1) {
	s Status=$$Error^%apiOBJ(809,"%Service_DocDB")
 	g Fail
 }
 i '$li(ServiceRecord,8) {
	s Status=$$Error^%apiOBJ(800,"%Service_DocDB")
	g Fail
 }
 i '$SYSTEM.Security.Check("%Service_DocDB","U") {
	s Status=$$Error^%apiOBJ(921,"%Service_DocDB"_":U")
	g Fail
 }
 q 1
Fail
 s EventData=$SYSTEM.Status.GetErrorText(Status)
 s EventData=EventData_$c(13)_$c(10)_"Name:      "_$g(Name)
 s EventData=EventData_$c(13)_$c(10)_"Namespace: "_$g(Namespace)
 s EventData=EventData_$c(13)_$c(10)_"Resource:  %Service_DocDB:USE"
 d $SYSTEM.Security.Audit("%System","%Security","Protect",EventData,"Doc DB Access")
 q Status
Error Set $zt=""
 s Status=$$Error^%apiOBJ(5002,$ze)
 g Fail
}
Create(Name,Namespace,Properties) Public {
 s $zt="Error"
 i '($e($roles,1,$l("%All"))="%All") { n $ET,$roles s $ET="",$roles=$roles_","_"%All"} ; verified 7/31/17 STC
 n $namespace
 s $namespace="%SYS"
 s Status=##Class(Security.DocDBs).Create(Name,Namespace,.Properties)
 q Status
Error Set $zt=""
 Quit $$Error^%apiOBJ(5002,$ze)
}
Delete(Name,Namespace) Public {
 s $zt="Error"
 i '($e($roles,1,$l("%All"))="%All") { n $ET,$roles s $ET="",$roles=$roles_","_"%All"} ; verified 7/31/17 STC
 n $namespace
 s $namespace="%SYS"
 s Status=##Class(Security.DocDBs).Delete(Name,Namespace)
 q Status
Error Set $zt=""
 Quit $$Error^%apiOBJ(5002,$ze)
}

%SYS.Debug^INT^1^67214,47330
%SYSDebug ; Debugger interface
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ;
 q                               ; Only through entry points
OPEN(pid,sid) public {
 If '$System.Security.Check("%Development","USE")  q 0_$c(22,35,1)_"4098"
 s $ZT="OPENERR"
 i $d(^rOBJ("%ZDEBUG")) D SENDOPEN^%ZDEBUG
 s x=$ZU(25,pid,0)
 q x
OPENERR ;
 s $ZT=""
 q 0_$c(22,35,1)_$ZE
}
CLOSE(pid) public {
 s $ZT="CLOSEERR"
 If '$System.Security.Check("%Development","USE")  q 0_$c(22,35,1)_"4095"
 s x=$ZU(25,pid,2)
 q x
CLOSEERR ;
 s $ZT=""
 i $ze["NOJOB" q 0_$c(22,35,1)_"4095"    ; Job no longer exists
 s err="ERROR SENDING DEBUG CLOSE"
 d BACK^%ETN
 q 0_$c(22,35,1)_$ZE
}
BREAK(pid) public {
 s $ZT="BREAKERR"
 If '$System.Security.Check("%Development","USE")  q 0_$c(22,35,1)_"4098"
 ; Now break the process
 s x=$ZU(25,pid,1)
 q x
BREAKERR s $ZT=""
 i $ze["NOJOB" q 0_$c(22,35,1)_"4095"    ; Job no longer exists
 s err="ERROR SENDING DEBUG BREAK"
 d BACK^%ETN
 q 0_$c(22,35,1)_$ZE
}
 ;----------------------------------------------------------------------
 ; Open a debugger device
 ;----------------------------------------------------------------------
DBGDEV(sid) public {
 s $ZT="OpenPrincipalDeviceE"
 ; Open a tcp port
 s port = $$DPORT^%SYS.Wcdu()
 f i=1:1:100 {
	s dev="|TCP|"_port               ; Get the debug TCP/IP port
	o dev:(/ACCEPT:/CRLF:/ESCAPE:/PAD:/SENDIMMEDIATE):5
	q:$t
	s port=port+69
 }
OpenPrincipalDeviceE
 Set $ZT = "DbgdevErr"
 i '$t s port=0
 ; signal the debugger we are ready
 s rc = $system.Event.Signal(sid,port)
 q:rc'=1
 i port {
	; read for accept
	u dev r x
	zb /DEBUG:dev                   ; Redirect debugger
 }
DbgdevErr
 q
}
 ;----------------------------------------------------------------------
 ; Get variables / values at stack level n
 ; The maximum size of the Event message is 32K bytes, so we must apply
 ; some limits to the loop, and to individual values.
 ;----------------------------------------------------------------------
STKVAR(sid,lev,start) public {
	s $zt="STKVARE"
	zb - ; disable all breakpoints and watchpoints
	s vlist="",len=0
	if start '= "" {
		s vref = start
		if $e(vref,1)="~" goto private
		s i=1
		goto public
	}
	s vref="~"
private
	f i=1:1:50 {
		s start=vref, vref=$ZU(42,lev,vref)
		q:vref=""
		s val=$ZU(43,lev,vref)
		s:$L(vref)+$L(val)>16000 val=$E(val,1,16000-$L(vref))
		q:len+$L(vref)+$L(val)>16000
		s vlist = vlist_$lb(vref,val)
		s len=$L(vlist)
	}
	if vref'="" s:i=50 start=vref goto exit
	s vref=""
public
	f i=i:1:50  {
		s:vref'="" start=vref
		s vref=$ZU(42,lev,vref)
		q:vref=""
		s val=$ZU(43,lev,vref)
		s:$L(vref)+$L(val)>16000 val=$E(val,1,16000-$L(vref))
		q:len+$L(vref)+$L(val)>16000
		s vlist = vlist_$lb(vref,val)
		s len=$L(vlist)
	}
	if vref="" { s start="" }
	elseif i=50 { s start=vref }
exit
	s vlist = vlist_$lb(start)
	d $system.Event.Signal(sid,vlist)
	zb + ; enable all breakpoints and watchpoints
	q
STKVARE
	s $zt=""
	try {
		d $system.Event.Signal(sid,$ZE)
	} catch {
		try { d $system.Event.Signal(sid) } catch {}
	}
	zb + ; enable all breakpoints and watchpoints
	q 
}
 ;----------------------------------------------------------------------
 ; Get properties / values for an oref
 ;----------------------------------------------------------------------
OREF(sid,var) public {
 s $zt="OREFE"
 zb - ; disable all breakpoints and watchpoints
 s vararray=""
 s prop=var
 Set rspec = ##class(%Library.ResultSet).%New("%Studio.General:DumpObject")
 Do rspec.Execute(var)
 While rspec.Next(.sc) {
	If '$SYSTEM.Status.IsOK(sc) q
	Set prop= rspec.GetData(1) q:prop=""
	Set val= rspec.GetData(2)
	s vararray = vararray_$lb(prop,val)
	q:$length(vararray)>30000
   }
exit
	s $zt="OREFFATAL"
	zb + ; enable all breakpoints and watchpoints
	d $system.Event.Signal(sid,vararray)
	q
OREFE
	s $zt=""
	s vararray = vararray_$lb(prop,$p($ze,">",1)_">")
	goto exit
OREFFATAL
	s $zt=""
	q
}
 ;----------------------------------------------------------------------
 ; Get properties / values for an oref
 ;----------------------------------------------------------------------
ATELIERv5OREFLEVEL(var,maxdepth,currentdepth,retobj) public {
	Set sc=1
	Try {
		If '$ISOBJECT(var) Set var = $ZOBJREF(var)
		Set retobj = {}, retobj.classname = $CLASSNAME(var), retobj.children = {}
		If (retobj.classname = "%Library.DynamicArray") || (retobj.classname = "%Library.DynamicObject") {
			Set variter = var.%GetIterator()
			While variter.%GetNext(.varkey,.varval) {
				If $ISOBJECT(varval), currentdepth < maxdepth {
					Set sc = $$ATELIERv5OREFLEVEL(varval,maxdepth,currentdepth+1,.varvalobj)
					If '$SYSTEM.Status.IsOK(sc) Quit
					Do retobj.children.%Set(varkey,varvalobj)
				}
				Else {
					Do retobj.children.%Set(varkey,varval,"string")
				}
			}
		}
		ElseIf (
			($EXTRACT(retobj.classname,1,16) = "%Collection.List") ||
			($EXTRACT(retobj.classname,1,16) = "%Library.ListOfD") ||
			($EXTRACT(retobj.classname,1,16) = "%Library.ListOfO") ||
			(retobj.classname = "%Library.RelationshipObject")
		) {
			For idx=1:1:var.Count() {
				Set val = var.GetAt(idx)
				If $ISOBJECT(val) {
					If currentdepth < maxdepth {
						Set sc = $$ATELIERv5OREFLEVEL(val,maxdepth,currentdepth+1,.valobj)
						If '$SYSTEM.Status.IsOK(sc) Quit
						Do retobj.children.%Set(idx,valobj)
					}
					Else {
						Do retobj.children.%Set(idx,val,"string")
					}
					Set sc = var.%UnSwizzleAt(idx)
					If '$SYSTEM.Status.IsOK(sc) Quit
				}
				Else {
					Do retobj.children.%Set(idx,val,"string")
				}
			}
		}
		ElseIf ($EXTRACT(retobj.classname,1,17) = "%Collection.Array") || ($EXTRACT(retobj.classname,1,14) = "%Library.Array") {
			Set key = ""
			While 1 {
				Set val = var.GetNext(.key)
				If key = "" Quit
				If $ISOBJECT(val) {
					If currentdepth < maxdepth {
						Set sc = $$ATELIERv5OREFLEVEL(val,maxdepth,currentdepth+1,.valobj)
						If '$SYSTEM.Status.IsOK(sc) Quit
						Do retobj.children.%Set(key,valobj)
					}
					Else {
						Do retobj.children.%Set(key,val,"string")
					}
					Set sc = var.%UnSwizzleAt(key)
					If '$SYSTEM.Status.IsOK(sc) Quit
				}
				Else {
					Do retobj.children.%Set(key,val,"string")
				}
			}
		}
		ElseIf ($EXTRACT(retobj.classname,1,8) = "%Stream.") {
			Set sc = var.Rewind()
			If '$SYSTEM.Status.IsOK(sc) Quit
			Set content = var.Read(1000,.sc)
			If '$SYSTEM.Status.IsOK(sc) Quit
			If content?.E1.C.E Set content = $$Quote^%qcr(content)
			Do retobj.children.%Set("Contents",content,"string")
			Set sc = var.Rewind()
		}
		Else {
			Set rset = ##class(%SQL.Statement).%ExecDirect(,"SELECT * FROM %Studio.General_AnalyzeObjectProperties(?) ORDER BY UPPER(Name)",var)
			While rset.%Next(.sc) {
				If '$SYSTEM.Status.IsOK(sc) Quit
				Set prop = rset.%GetData(1), val = rset.%GetData(2), data = rset.%GetData(3)
				Set isobj = rset.%GetData(4), clsname = rset.%GetData(5), calculated = rset.%GetData(6)
				If data\10 {
					Do retobj.children.%Set(prop,{"classname":"MultiDimensional","children":{}})
				}
				ElseIf calculated {
					Do retobj.children.%Set(prop,{"classname":"Calculated","children":{}})
				}
				ElseIf isobj, clsname '= "", currentdepth < maxdepth {
					Set sc = $$ATELIERv5OREFLEVEL(val,maxdepth,currentdepth+1,.valobj)
					If '$SYSTEM.Status.IsOK(sc) Quit
					Do retobj.children.%Set(prop,valobj)
				}
				Else {
					Do retobj.children.%Set(prop,val,"string")
				}
			}
		}
	} Catch (e) {
		Set sc = e.AsStatus()
	}
	Quit sc
}
 ;----------------------------------------------------------------------
 ; Get properties / values for an oref and any of its child objects, up to maxdepth
 ;----------------------------------------------------------------------
ATELIERv5OREF(sid,var,maxdepth) public {
	ZBreak - 
	Set sc = 1, vararray = ""
	If '$ISOBJECT(var) {
		Try {
			Set var = $ZOBJREF(var)
		}
		Catch (e) {
			Set sc = e.AsStatus()
		}
	}
	If '$SYSTEM.Status.IsOK(sc) {
		Set vararray = $LISTBUILD(sc,"")
	}
	Else {
		Set sc = $$ATELIERv5OREFLEVEL(var,maxdepth,1,.retobj)
		If '$SYSTEM.Status.IsOK(sc) {
			Set vararray = $LISTBUILD(sc,"")
		}
		Else {
			Set vararray = $LISTBUILD(sc,retobj.%ToJSON())
		}
	}
	ZBreak + 
	Do $SYSTEM.Event.Signal(sid,vararray)
	Quit
}
 ;----------------------------------------------------------------------
 ; The following are auxiliary functions
 ;----------------------------------------------------------------------
SESSION(pid) public {
 ; This function returns back a generated session id number to use when
 ; connecting to the process to debug.
 ; If the pid is passed in, it is the job number.
 ; Otherwise, it is the current process job number.
 s session="ISCSYSDEBUG"
 i $g(pid)'="" q session_$zu(67,3,pid)            
 q session_$zu(67,3,$j)            
}

%SYS.FILE^INT^1^67214,47330
%SYSFILE ;
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ;SETUP DIRNAM, DEND, NUMMAP, GD, RD
 ; EXIT: if DIRNAM="" then the user specified NO directory
DEFAULT ; Enter here to automatically select the process' default directory
 D DEF S %A=DIRNAM n big s big=$zbitget($zversion(0),21) G GET
INT ; ENTER HERE TO FORCE FEED A DIRECTORY NAME TO THIS ROUTINE IN DIRNAM
 S %A=DIRNAM n big s big=$zbitget($zversion(0),21) G GET
ASK ; Enter here to select any directory
 n big s big=$zbitget($zversion(0),21)
 s DIRNAM=$zu(12,"")
 New quit S %A=$$GetDir("Directory: ",DIRNAM,,.quit)
 If $Get(quit) S DIRNAM="" Q
 G GET:%A=""
 I %A["?" W !,"Enter valid directory name, or ^ to exit" G ASK
 S %A=$$ChkDirOrSpecEXISTS(%A) I %A="" W *7," invalid directory" G ASK
 I $$ZU49(%A)<-1 W *7," no such "_"IRIS"_".DAT" G ASK
 S $ZT="ERR",DIRNAM=%A D Touch(DIRNAM)
GET if $g(big) {
   n info 
   s info=$zu(49,DIRNAM)
   s DEND=$p(info,",",22),GD=$p(info,",",7)
 }
 else {
    N DIRINFO S DIRINFO=$$ZU49(DIRNAM)
    S NUMMAP=$P(DIRINFO,",",4),DEND=NUMMAP*400
    S GD=$P(DIRINFO,",",7),RD=$P(DIRINFO,",",9)
 }
 Q
ZU49(d) S $ZT="ZU49E" Q $ZU(49,d)
ZU49E Q -2 ;as if there were no CACHE.DAT
DEF S DIRNAM=$ZU(12,"") Q
ERR i ($zversion(1)=2) W *7," ??? Use Format DRIVE:\dir\subdir" 
 i ($zversion(1)=3) W *7," ??? Use Format /dir/subdir"
 g ASK
STOP(x) S x=$zconvert($E(x,1,4),"U") Q (x["EXIT")!(x["STOP")!(x["QUIT")!(x["HALT")!($E(x)="^")
GetDir(prompt,defdir,exists,quit) ;ask for a directory, allow defaults
GetDirLoop ; Loop until we get something valid or exit
 s $zt="GetDirE"
 n exist,dir,x
 s exist=+$g(exists,1) ; default is to check if exists
 w !,prompt_": "_$s($g(defdir)'="":$g(defdir)_" => ",1:"") r dir s:dir="" dir=$g(defdir)
 i $$STOP(dir) Set quit=1 Q ""
 i $E(dir)="?" Q dir ;pass-on request for elaboration
 q:exist<0 dir ;exist<0 means don't check valid or exists
 s x=$S(exist:$$ChkDirOrSpecEXISTS(dir),1:$$ChkDirVALID(dir)) 
 i x="" W *7,"  "_$s(exist:"Directory '"_dir_"' does not exist",1:"Invalid directory specification '"_dir_"'") G:exist GetDirLoop d  g:x="N" GetDirLoop
 . s x=$$YN("Use this directory anyway","N")
 i x="^" s quit=1 Quit ""
 q dir
GetDirE S $ZT=""
 i $ze["<INTERRUPT>" q ""
 w !,"Error: "_$ZE
 zquit 1 i $ZT'="" G @$ZT
 q ""
Touch(D)
 q
ChkDirVALID(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,1)
ChkDirEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkDirOrSpecEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,3)
ChkDir(R) N N S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkBad S $ZT="" W !,"<"_$P($P($ZE,"<",2),">")_"> error -- invalid directory"
 Q ""
YN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YN"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"yn","YN") I "^YN"'[R W "  enter Yes or No, please"
 S POP=(R="^") W $E($S(R="N":"No",R="Y":"Yes",1:""),$L(X)+1,3) Q R

%SYS.GCREATE^INT^1^67214,47330
%SYSGCREATE ;(KSO,PK) CREATE A GLOBAL AT A SPECIFIED LOCATION
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ; GXLATE.INC
 i $$isrem^%SYS.GLO w !,*7,"Can't create: global directory is on a remote system" q
NEW ; Enter here to test out $ZU(178)
 New dir,keep,protection,rc,val,BLOCK,COL,COLNAME,GG,GLO,GP
 New POP,found,r,%objlasterror,zu5
 W !,"Use this utility to create a global and specify custom values for"
 W !,"collation and protection, where its pointer blocks and data blocks"
 W !,"should grow, and whether this global should be marked as ""kept""."
 W !
getGLO R !,"Global ^",GLO Q:GLO=""  I GLO'?1"^".E S GLO="^"_GLO
 s $zt="errgetGLO"
 s val=$$ChkName(GLO)
 i val'=1 w val,! g getGLO
 s val=$$ChkDup(GLO)
 i val'=1 w val,! g getGLO
 ; If there is an entry for the global in the global translation table
 ;  and a translation exists, don't allow the global to be created.
 s val=$$ChkTran(GLO)
 i val'=1 w val,! g getGLO
 N COL,NEWCOL,OLDCOL,COLNAME,COLLST,DEL1,DEL2,PCOL,STA,ICOL
 S DEL1=$$del1^%Wprim,DEL2=$$del2^%Wprim
 s $zt="errCOLLATION"
 s zu5=$namespace zn "%SYS"
 S OLDCOL=$zu(23,0),COLNAME=$$NAME^COLLATE(OLDCOL)
 s r=##class(%Library.ResultSet).%New("%Library.Collate.CollationList")
 F  D  Q:COL'<0
 . W !,"Enter desired type of collation: (",COLNAME,") =>"
 . R NEWCOL I NEWCOL="" S COL=OLDCOL Q
 . d r.Execute()
 . S COL=+NEWCOL s found=0
 . f  q:'r.Next()  i r.GetDataByName("Number")=NEWCOL D  Q
 . . s found=1,COLNAME=r.GetDataByName("Name") W " ",COLNAME Q
 . Quit:found
 . S COL=-1 I $E(NEWCOL)'="?" W *7,"  Invalid option"
 . d r.Execute()
 . While (r.Next()) { w !,?5,r.GetDataByName("Number")," - ",r.GetDataByName("Name")," (",r.GetDataByName("Status")," )" }
 zn zu5
 s keep=0
 i $$YN("Do you want to mark this global to be ""kept""","N")="Y" Set keep=1
 If POP Quit  
 s rc=$ZUTIL(90,21,"",GLO)
 i +rc=1 {
   s dir=$p(rc,",",2,99999)
   i $e(dir,1,2)'="^^" {
     w !,"Cannot use %SYS.GCREATE for remote globals."
     w !,"Global "_GLO_" is mapped to location"_dir
     q
   }
   s dir=$e(dir,3,$l(dir))
 }
 i +rc=2 {
   w !,"This global "_GLO_" in namespace "_$namespace_" is Subscript-Level Mapped."
   w !,"You cannot use %SYS.GCREATE for this global.",!
   q
 }
 s rc=$$SetDatabaseVariables^%SYS.DATABASE(dir,,,,,,,.GP,.GG)
 If ('+rc) Do ShowMessage(rc,0) Goto getGLO
 q:$g(%UI)="GUI"
 W !,"The directory default for new pointer blocks is "_GP
 I $$YN("Do you want to specify a different location","N")="N" G getGrowth
 If POP Quit  
 W !
 Read !,"Start pointer blocks at: ",BLOCK G getGLO:'BLOCK S GP=BLOCK
getGrowth W !!,"The directory default for new data blocks is "_GG
 I $$YN("Do you want to specify a different location","N")="Y" d  ;q  
 . Read !,"Start data blocks at: ",BLOCK G getGLO:'BLOCK S GG=BLOCK
 . I 'BLOCK W !,"[no action]",! G getGLO
 If POP Quit  
checkGLO W !!,"*** Final check:"
 W !?15,"Collating Sequence = ",COLNAME," (",COL,")"
 w !?15,"Global "_GLO_" will "_$case(keep,1:"",:"not")_" be marked as ""kept""."
 W !?15,"Pointer blocks start at "_GP
 W !?15,"Data blocks start at "_GG
 I $$YN("Is this correct","N")="N" W !,"[No change]",! G getGLO
 If POP Quit  
 I $D(@GLO) W !,"[Already defined -- no action]" G A
 s zu5=$namespace zn "%SYS"
 Set rc=$$CreateGlobal^%SYS.DATABASE(dir,GLO,COL,,,keep,GP,GG)
 zn zu5
 If ('+rc) Do ShowMessage(rc,0) Goto getGLO
 Else  W !,"Done.",! G getGLO
GCREATEOLD
 W !,"Use this utility to create a global and specify where its"
 W !,"pointer blocks and its data blocks should grow."
 W !,"You can also specify the global's collating sequence."
 w !,"You can also specify whether to mark this global to be ""kept"""
 n %ST,dir,BLKSIZ,GD,GP,GG,BLOCK,A,UIC,RD,RG,MAPSIZ,FILSIZ,EXP,MAX,rc,FREEZE
 n GLO,OGP,OGG
 W !
A R !,"Global ^",GLO Q:GLO=""  I GLO'?1"^".E S GLO="^"_GLO
 s val=$$ChkName(GLO)
 i val'=1 w val,! g A
 s val=$$ChkDup(GLO)
 i val'=1 w val,! g A
 ; If there is an entry for the global in the global translation table
 ;  and a translation exists, don't allow the global to be created.
 s val=$$ChkTran(GLO)
 i val'=1 w val,! g A
 N COL,NEWCOL,OLDCOL,COLNAME,COLLST,DEL1,DEL2,PCOL,STA,ICOL
 S DEL1=$$del1^%Wprim,DEL2=$$del2^%Wprim
 S OLDCOL=$zu(23,0),COLNAME=$$NAME^COLLATE(OLDCOL)
 S COLLST=$$GetStdList^COLLATE(DEL2) #;PWC921
 F  D  Q:COL'<0
 . W !,"Enter desired type of collation: (",COLNAME,") =>"
 . R NEWCOL I NEWCOL="" S COL=OLDCOL Q
 . S COL=+NEWCOL I COL>0,COL'>$L(COLLST,DEL2) D  Q
 . . S PCOL=$P(COLLST,DEL2,COL),COL=$P(PCOL,DEL1,2)
 . . S COLNAME=$$NAME^COLLATE(COL) W " (",COLNAME,")" Q
 . S COL=-1 I $E(NEWCOL)'="?" W *7,"  Invalid option"
 . F ICOL=1:1 S PCOL=$P(COLLST,DEL2,ICOL),STA=+PCOL Q:PCOL=""  D
 . . W !?5,$J(ICOL,2)," - ",$P(PCOL,DEL1,3)," (",$S(STA=0:"not loaded",STA=1:"builtin",1:"available"),")"
 If $Get(%UI)'="GUI" Goto getvars
GP O 63 V 1 D GFS^|"%SYS"|ST
 S UIC=$V(%ST("gfuic")+%ST("GFOFFSET"),0,%ST("szuic"))
 S NUMMAP=$V(%ST("gfmaps")+%ST("GFOFFSET"),0,%ST("szmaps"))
 S EXP=$V(%ST("gfexp")+%ST("GFOFFSET"),0,%ST("szexp"))
 S MAX=$V(%ST("gfmax")+%ST("GFOFFSET"),0,%ST("szmax"))
 S GD=$V(%ST("gfdir")+%ST("GFOFFSET"),0,%ST("szdir"))
 S GP=$V(%ST("gfgptr")+%ST("GFOFFSET"),0,%ST("szgptr"))
 S RD=$V(%ST("gfrdir")+%ST("GFOFFSET"),0,%ST("szrdir"))
 S RG=$V(%ST("gfrgrw")+%ST("GFOFFSET"),0,%ST("szrgrw"))
 S GG=$V(%ST("gfggrw")+%ST("GFOFFSET"),0,%ST("szggrw"))
 S MAPSIZ=$V(%ST("gfmsz")+%ST("GFOFFSET"),0,%ST("szmsz"))
 N zu49 S zu49=$zu(49,"."),NUMBLKS=$p(zu49,",",4)*1024*1024\$p(zu49,",",2)
 S OGP=GP,OGG=GG C 63
 g guiquit
getvars ;
 s dir=$zu(12,"")
 s rc=$$SetDatabaseVariables^%SYS.DATABASE(dir,.BLKSIZ,.UIC,.FILSIZ,.EXP,.MAX,.GD,.GP,.GG,.RD,.RG,0,0,0,.MAPSIZ,0,.FREEZE)
 S OGP=GP,OGG=GG
 ;
guiquit ;
 q:$g(%UI)="GUI"
 W !,"The directory default for new pointer blocks is "_GP
 I $$YN("Do you want to specify a different location","N")'="Y" G GG
 W !
B W !,"Start pointer blocks at: " D BLOCK G A:'BLOCK S GP=BLOCK
GG W !!,"The directory default for new data blocks is "_GG
 I $$YN("Do you want to specify a different location","N")'="Y" d  q  
 . i $zbitget($zversion(0),21) g askkeep
 . e  G CHECK
 W !
C R !,"Start data blocks at: " D BLOCK S GG=BLOCK
 I 'BLOCK W !,"[no action]",! G A
askkeep
 s keep=0
 i $$YN("Do you want to mark this global to be ""kept""","N")="Y" Set keep=1
CHECK W !!,"*** Final check:"
 W !?15,"Collating Sequence = ",COLNAME," (",COL,")"
 w !?15,"Global "_GLO_" will "_$case(keep,1:"",:"not")_" be marked as ""kept""."
 W !?15,"Pointer blocks start at "_GP
 W !?15,"Data blocks start at    "_GG
 I $$YN("Is this correct","N")="N" W !,"[No change]",! G A
 I $D(@GLO) W !,"[Already defined -- no action]" G A
 S $ZT="RESET2"
guiCreate       ; Control Panel entry point called from gCreate.
 i $zbitget($zversion(0),21) d  d setkeep g done  
 . s rc=$$ModifyDatabase^%SYS.DATABASE(dir,UIC,FILSIZ,EXP,MAX,GD,GP,GG,FREEZE)
 . i ('rc) d ShowMessage(rc,0) g A
 . s rc=$$GetDatabaseStatus^%SYS.DATABASE(dir,.exists,1)
 . i ('rc) d ShowMessage(rc,0)
 . ;Continue even if mount fails
 . s $zt="RESET3"
 . N PREVCOL,%
 . S PREVCOL=$zu(23,1,COL),$ZT="RESET3"
 . S @GLO@(1)="" K ^(1)
 . S %=$zu(23,1,PREVCOL) D RESET S $ZT=""
 . S @GLO@(1)="" K ^(1)
 . g RESET  
done
 q:$G(%UI)="GUI"
 W !,"Done.",! G A
 ;
BLOCK S BLOCK=0
 i $zbitget($zversion(0),21) g justblock 
MAP R !?13,"Map: ",MAP Q:MAP=""  I MAP<0!(MAP'<NUMMAP) W " ???",! G MAP
BLK W ?25," Block offset inside map (1-",MAPSIZ-1,"): " R A Q:A=""
 I A<2!(A>(MAPSIZ-1)) W " ???",! G BLK
 S BLOCK=MAP*MAPSIZ+A W "    ("_BLOCK_")"
 Q
justblock r ?25,"Block :",A q:A=""
 s BLOCK=A W "    ("_BLOCK_")" q  
setkeep i 'keep q  
 s rc=$$SetKeepType^%SYS.DATABASE(dir,GLO,1)
 i ('rc) d ShowMessage(rc,0)
 q  
RESET S $ZT="RESET2" H 2 
p ;
 i $zbitget($zversion(0),21) d  q    
 . s rc=$$ModifyDatabase^%SYS.DATABASE(dir,UIC,FILSIZ,EXP,MAX,GD,OGP,OGG,FREEZE)
 . i ('rc) w !,"Error resetting pointers:" d ShowMessage(rc,0)
 . s rc=$$GetDatabaseStatus^%SYS.DATABASE(dir,.exists,1)
 . i ('rc) d ShowMessage(rc,0)
RESET2 S $ZT="" W *7,!,"Unable to modify global directory" G A
RESET3 S $ZT="",%=$zu(23,1,PREVCOL)
 W *7,!,$P($ZE,">"),"> error attempting to create global"
 D RESET G A
 ;
errCOLLATION s $zt="" w *7,!,"Error getting Collation list" zn:$d(zu5) zu5 G getGLO
errgetGLO s $zt="" w *7,!,"Unable to create global" zn:$d(zu5) zu5 G getGLO
UC(x) q $zcvt(x,"u")
YN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YN"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"yn","YN") I "^YN"'[R W "  enter Yes or No, please"
 S POP=(R="^") W $E($S(R="N":"No",R="Y":"Yes",1:""),$L(X)+1,3) Q R
Strip(x) Q $$StrHead($$StrTail(.x)) ;strip both leading and trailing spaces
StrHead(x) ;return 'x' without any leading spaces
 Q $E(x,$F(x,$E($TR(x," ")))-1,$L(x))
StrTail(x) ;return 'x' without any trailing spaces
 Q $P(x_$J("",$L(x)),$J("",$L(x)))
StrQuote(x) ; return 'x' without 1 layer of quotes
 I ($E(x)'="""")!($E(x,$L(x))'="""") Q x
 S x="S x="_x X x Q x
 ;
 ;------------------------------------------------------------------------
 ; The following three check functions are used by CHUI (in this program)
 ; and GUI (called from VB, Control Panel). If validation fails,
 ; an error message will be returned. If succeeds, one will be returend.
 ;------------------------------------------------------------------------
ChkName(GLO)    ;validate global name
 I '$zname($e(GLO,2,$l(GLO)),3) Q " Invalid format for a global name."
 Q 1
ChkDup(GLO)     ;validate duplicate
 I $D(@GLO) Q " Global already defined." 
 Q 1
ChkTran(GLO)    ;validate translation
 ; If there is an entry for the global in the global translation table
 ; and a translation exists, don't allow the global to be created. 
 ; Otherwise, kill it anyway.
 S $ZT="OK2KILL"
 I ($S($ZU(90,1,"",$E(GLO,2,$L(GLO)))>0:$ZU(90,2,3,$ZU(90,1,"",$E(GLO,2,$L(GLO)))),$ZU(90,1,"",$E(GLO,2,$L(GLO)))<0:$ZU(90,2,6,-$ZU(90,1,"",$E(GLO,2,$L(GLO)))),1:0)'=0) D  q return
 . s return=" Global "_GLO_" : Translation in effect."
 . s $ZT="",$ZE=""
 Q 1
OK2KILL s $ZT="",$ZE=""
 n x s x=$zu(68,28,0) K @GLO s x=$zu(68,28,x)
 Q 1
gGP() ; Get global defaults for Control Panel
 s %UI="GUI"
 d GP
 q UIC_","_NUMMAP_","_EXP_","_MAX_","_GD_","_GP_","_RD_","_RG_","_GG_","_MAPSIZ_","_NUMBLKS
 ;
gCreate(GLO,COL,data)   ;GUI Control Panel entry point for creating global
 ;Input:  data from GP and maybe updated from GUI
 ;        GLO = global name with "^"
 ;        COL = collation sequence number
 ;Output: none
 ;Return: 0_del1_errmsg if errored
 ;        1 if success 
 n (GLO,COL,data)
 s %UI="GUI"
 s $ze="",$zt="gCreateErr^%SYS.GCREATE"
 s errmsg=""
 s GP=$p(data,",",6)
 s GG=$p(data,",",9)
 s protection=$Case($Ascii(GLO,2)="%",1:215,:195)
 s rc=$$CreateGlobal^%SYS.DATABASE("",GLO,COL,protection,0,0,GP,GG)
 i ('+rc) d  g gCreateErr
 . n msg,i s rc=$$DecomposeStatus^%SYS.DATABASE(rc,.msg,0)
 . f i=1:1:msg s errmsg=errmsg_msg(i)_$C(13,10)
 q 1
gCreateErr      ;
 q 0_$$del1^%Wprim_"Unable to create global. "_$s($g(errmsg)'="":$c(13,10)_errmsg,1:"")
ShowMessage(sc,device) [] PRIVATE {
    Do DecomposeStatus^%SYS.DATABASE(sc,.msglist,0,"")
    Do wrtmsg($C(13,10),device)
    For i=1:1:msglist {	Do wrtmsg(msglist(i)_$C(13,10),device) }
}
wrtmsg(msg,device) [] PRIVATE {
    Quit:'$L(msg)  ; Avoid argumentless writes...
    If device=-1 { Do $zu(9,"",msg,0,0) Quit }
    If $g(%UI,"CHUI")="CHUI" { Use device Write msg Quit }
    Do:$$IjcMsg^%Wprima("DI"_msg)="CANCEL"  ; Return value could be cancel message 
    . i $$IjcMsg^%Wprima("DI"_$C(13,10)_"Abort received!"_$C(13,10))
    . zt "Abort"
}

%SYS.GD^INT^1^67214,47330
%SYSGD ; List namespace global directories ;$Change: 7440104 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	; Revision: $Id: //iris/2024.1.3/databases/sys/rtn/global/_sys.gd.mac#1 $
 New %zu68
 Do %GDPROC
 If $g(%zu68) If $zu(68,7,%zu68)
 Quit  
%GDPROC() PUBLIC {
 s $zt="ERROR"
 if $ZBITGET($ZVERSION(0),46) {
	 do OLD
	 quit
 }
 Set %zu68=$zu(68,7) If %zu68 If $zu(68,7,0) 
 s Mask="*"
MASK
 s Status=##Class(%Library.Prompt).GetString("Which globals?",.Mask,,,,8)
 q:(Status=0)||(Status=2)
 s Single='##class(%SYS.GlobalQuery).Wildcards(Mask)
SYSTEM
 s SystemGlobals=0
 i Single s SystemGlobals=1 G MAPPINGS
 s Status=##Class(%Library.Prompt).GetYesNo("Include system globals?",.SystemGlobals,,8)
 q:Status=0  g:Status=2 MASK
MAPPINGS
 s Mappings=0
 s Status=##Class(%Library.Prompt).GetYesNo("Show global mappings?",.Mappings,,8)
 q:Status=0  
 i Status=2 {
	i Single g MASK
	g SYSTEM
 }
ATTRIBUTES
 s Attributes=0
 i Mappings {
	s Status=##Class(%Library.Prompt).GetYesNo("Show global attributes?",.Attributes,,8)
	q:Status=0  g:Status=2 MAPPINGS
 }
DEVICE
 s IOMS=$System.Device.GetRightMargin()
 s Status=##class(%Library.Device).Get("Device:",.IO,,8,,4,.IOSL,.IOM,.IOF)
 q:Status=0
 i (Status=2) {
	 i Mappings g ATTRIBUTES
	 g SYSTEM
 }
 n $namespace s NameSpace=$namespace
 u IO
 s Status=$$QUERY(NameSpace,Mappings,Attributes,SystemGlobals,Mask,IO,IOSL,IOM,IOF)
 U:IO=$P IO:/MAR=IOMS
 c:IO'=$P IO
 q
ERROR s $zt=""
 u 0 i $ze'["<INTERRUPT" w !,"ERROR: "_$ze
 i $d(IO) c:IO'=$P IO U:IO=$P&&($D(IOMS)=1) IO:/MAR=IOMS
 q
} 
INT(NameSpace) PUBLIC {
 s $zt="INTE"
 s NameSpace=$g(NameSpace,$namespace)
 i $e(NameSpace)'="^" s NameSpace=$zcvt(NameSpace,"U")
 s IOMS=$System.Device.GetRightMargin()
 d ##class(%Library.Device).GetCurrent(.IO,.IOSL,.IOM,.IOF)
 s IO=$I
 s Mappings=0
 s Attributes=0
 s SystemGlobals=0
 s Mask="*"
 s Status=$$QUERY(NameSpace,Mappings,Attributes,SystemGlobals,Mask,IO,IOSL,IOM,IOF)
 U IO:/MAR=IOMS
 q
INTE s $zt=""
 i $ze'["<INTERRUPT" {
	 w !,"ERROR: "_$ze
 } else {
	 w !,"<INTERRUPT>"
 }
 q
} 
ALL() PUBLIC {
 s $ZT="ALLE"
 s IOMS=$System.Device.GetRightMargin()
 d ##class(%Library.Device).GetCurrent(.IO,.IOSL,.IOM,.IOF)
 s Mappings=0
 s Attributes=0
 s SystemGlobals=0
 s Mask="*"
 s i=0, dir=$zu(49,i,3)
 While ((+dir) '< 0) {
	if +dir=0 {  ;Only display local databases
		s NameSpace="^^"_$p(dir,"^",2)
		s Status=$$QUERY(NameSpace,Mappings,Attributes,SystemGlobals,Mask,IO,IOSL,IOM,IOF)
		i Status'=1 q
		s Status=##Class(%Library.Prompt).GetMore()
		q:(Status=2)||(Status=0)||(Status=3)
	}
    s i=i+1, dir=$zu(49,i,3) 
 }
 U IO:/MAR=IOMS
 q
ALLE s $zt=""
 I $d(IO) U IO:/MAR=IOMS
 i $ze'["<INTERRUPT" {
	 w !,"ERROR: "_$ze
 } else {
	 w !,"<INTERRUPT>"
 }
 q
} 
QUERY(NameSpace,Mappings,Attributes,SystemGlobals,Mask,IO,IOSL,IOM,IOF) PRIVATE  {
 s $ZT="QUERYE"
 s CurrentNameSpace=$namespace
 Set Rset = ##class(%Library.ResultSet).%New("%SYS.GlobalQuery:NameSpaceListChui")
 Do
 . i '($e($roles,1,$l("%All"))="%All") { n $ET,$roles s $ET="",$roles=$roles_","_"%All"} ; verified 9/26/16 STC
 . s Status=Rset.Execute(NameSpace,Mask,SystemGlobals,.UnavailableDatabases)
 i ('Status) {
	 s Status=$SYSTEM.Status.DecomposeStatus(Status,.Err,"d")
	 g EXIT
 }
 i Attributes {
	 s SaveLines=5
 } else {
	 s SaveLines=3
 }
 s DisplayLock=0
 s IndexTab=2
 s LocationTab=27
 s KeepTab=60
 s JrnTab=65
 s PntTab=70
 s GrowthTab=76
 d HEADER
 s PrevGlobal="",Empty=1,Count=0
 While (Rset.Next()) {
	s GlobalSpec=Rset.Get("Name")
	s Global=$p($p(GlobalSpec,"(",1)," ",1)
	i Mappings {
		i (Global=PrevGlobal) {
			i (DisplayLock=1),(Attributes=1) {
				w !,?(LocationTab-$l(Rset.GetColumnName(12))-2),Rset.GetColumnName(12)_": ",?LocationTab,Rset.Get("LockLocation")
				s DisplayLock=0
			}
		} else {
			i Attributes w !
		}
		s Status=$$PROMPT(SaveLines,IOSL)
		q:(Status=2)||(Status=0)||(Status=3)
		i GlobalSpec["Replicated" {
			w !
			s ReplicatedString="Replicated to:"
			i $$BooleanYNDisplayToLogical(Rset.Get("Empty"))=1 s ReplicatedString=" Empty,Replicated to:"
			w ?(LocationTab-$l(ReplicatedString)-1),ReplicatedString
		} Else {
			i (Global=PrevGlobal) {
				w !,?IndexTab,"("_$p(GlobalSpec,"(",2,999)
			} else {
				w !,GlobalSpec
			}
			i $$BooleanYNDisplayToLogical(Rset.Get("Empty"))=1 w ?LocationTab-7," Empty"
		}
		w:$x>LocationTab !
		w ?LocationTab,Rset.Get("Location")
		w:$x>KeepTab !
		w ?KeepTab,Rset.Get("Keep")
		w:$x>JrnTab !
		w ?JrnTab,Rset.Get("Jrn")
		w:$x>PntTab !
		w ?PntTab,Rset.Get("Ptr")
		w:$x>GrowthTab !
		w ?GrowthTab,Rset.Get("Grth")
		i Attributes {
			w !,?(LocationTab-$l(Rset.GetColumnName(7))-2),Rset.GetColumnName(7)_": ",?LocationTab,Rset.Get("Collation")
			w !,?(LocationTab-$l(Rset.GetColumnName(3))-2),Rset.GetColumnName(3)_": ",?LocationTab,Rset.Get("ResourceName")_":"_Rset.Get("Permission")
		}
		i Global'=PrevGlobal {
			s Count=Count+1
			s PrevGlobal=Global
			s DisplayLock=1
		}
	} else {
		i Global'=PrevGlobal {
			s Status=$$DISPLAY(Global,Empty,IOM)
 			q:(Status=2)||(Status=0)||(Status=3)
			i $$BooleanYNDisplayToLogical(Rset.Get("Empty"))=1 {
				s Empty=1
			} else {
				s Empty=0
			}
			s PrevGlobal=Global
			s Count=Count+1
		} else {
			i $$BooleanYNDisplayToLogical(Rset.Get("Empty"))=0 s Empty=0
		}			
	}
 }
 i 'Mappings s Status=$$DISPLAY("",Empty,IOM)
 q:(Status=2)||(Status=0)||(Status=3) Status
 i $d(UnavailableDatabases) {
	w !!,"The following databases were unavailable:"
	s Database=$o(UnavailableDatabases(""),1,Status1)
	while (Database'="") {
		w !,Database,"  "
		d $SYSTEM.Status.DecomposeStatus(Status1,.Error)
	 	w Error(1)
	 	s Database=$o(UnavailableDatabases(Database),1,Status1)
	}
 }
 w !!,Count," global" w:Count-1 "s" w " listed"
 i IO'=$I w @IOF 
EXIT s $zt=""
 q Status
QUERYE s $zt=""
 i $d(CurrentNameSpace) d $ZU(5,CurrentNameSpace)
 i $ze["<NAMESPACE" {
    w !,"Using old ^%GD",!
    d OLD^%SYS.GD
 } elseif $ze'["<INTERRUPT" {
	 w !,"ERROR: "_$ze
 } else {
	 w !,"<INTERRUPT>"
 }
 q 0
HEADER
 S H="Global Directory Display of "_NameSpace
 U IO W @IOF W $J(H,$L(H)+80\2)
 D INT^%T,INT^%D S H=%TIM_"  "_%DAT W !,$J(H,$L(H)+80\2)
 w !
 i Mappings {
	w !,Rset.GetColumnName(1)
	w ?LocationTab,Rset.GetColumnName(2)
	w ?KeepTab,Rset.GetColumnName(6)
	w ?JrnTab,Rset.GetColumnName(11)
 	w ?PntTab,Rset.GetColumnName(8)
 	w ?GrowthTab,Rset.GetColumnName(9)
 }
 q
PROMPT(SaveLines,IOSL) 
 s $ZT="PROMPTE"
 If '$g(IOSL) q 1
 Else  i $Y+$g(SaveLines)<IOSL q 1
 i IO=$p {
	s Status=##Class(%Library.Prompt).GetMore(,,8+4)
 	q:(Status=2)||(Status=0)||(Status=3) 0
 }
 w !
 d HEADER 
 q Status
PROMPTE s $zt=""
 q Status
DISPLAY(Global,Empty,IOM)
 i $x'=0,Empty w "-"
 i $x+19\20*20+$l(Global)>IOM {
	 w ! 
	 s Status=$$PROMPT()
 	 q:(Status=2)||(Status=0)||(Status=3) Status
 }
 w ?$x+19\20*20,Global
 q Status
} ; End QUERY
RemJobSys() Public {
 d RemJob1(1)
}
RemJob() Public {
 d RemJob1(0)
}
RemJob1(SystemGlobals) Public {
 s $zt="RemJobE"
 s oldval=$zu(68,7,0) 
 s Directory="^^"_$zu(12,"")
 s gn=$G(^%SYS("TempResultGlobalName"),"CacheTempUtil")
 s:$e(gn)="^" gn=$e(gn,2,*)
 s save=$name(@("^"_gn_"(""GD"")"))
 d $zu(68,7,oldval)
 ; i $e($namespace)="^" d $zu(5,"%SYS")
 d $zu(5,"%SYS")
 if SystemGlobals {
	 d GetDir(Directory,save)
	s @save=$s($d(errlog):$ze,1:"")
 	q
 }
 Set Rset = ##class(%Library.ResultSet).%New("%SYS.GlobalQuery:DirectoryList")
 d Rset.Execute(Directory,,,SystemGlobals)
 While (Rset.Next()) {
	s Flags=0
	s Flags=$case($$BooleanYNDisplayToLogical(Rset.Get("Keep")),0:$zb(Flags,$zu(40,0,57),2),:$zb(Flags,$zu(40,0,57),7))
	s Flags=$case($$BooleanYNDisplayToLogical(Rset.Get("Journal")),0:$zb(Flags,$zu(40,0,56),2),:$zb(Flags,$zu(40,0,56),7))
	s @save@($p(Rset.Get("Name"),"(",1))="255^"_Rset.Get("PointerBlock")_"^"_Rset.Get("GrowthBlock")_"^"_Flags_"^"_##Class(%Library.Collate).DisplayToLogical(Rset.Get("Collation"))_"^"_Rset.Get("ResourceName")
  }
 s @save=""
 q
RemJobE s $zt="" 
 s @save=$ze
 q
}
OLD
main ; Main entry for CHUI interface -- select output device
 n SELF,POP,IO,IOM,IOSL,IOF,lng
 New P3show,vacancies
 G main4
main3 ; entry for performing multiple %GD's to same device
 ; n SELF,POP,IO,IOM,IOSL,IOF,lng must be performed by caller
 i 'firstime g main5
 s firstime=0
main4 d OUT^%IS q:POP  s SELF=IO=$I
 s detail=$$YN("Show detail","N")="Y"
main5 i POP c:'SELF IO q  
 i 'SELF u IO w @IOF
main2 s %UI="CHUI"
 k ^IRIS.TempJ($j)
 i '$$Fetch("*",1,0) d  q
 . w !,"Unable to fetch globals!"
 . i $ze'="" w !,$ze
 i '$$Show(detail,0) w !,"Error: ",$ze
 i 'SELF w @IOF c IO
 QUIT
 ;
maskincl(mask,item,ext) New e,i,include,m,m1,m2
 Set include=0,ext=$ZCVT($g(ext,""),"U")
 For i=1:1 Set m=$p(mask,";",i),e="" Quit:m=""  Do:m'["'"  Quit:include
 . Set:m["." m=$$ParseRoutineName^%R(m,.e),e=$s(e="*":"",e="SRC":".INC.MAC.INT.BAS",e="":"",1:"."_e)
 . If m["*" Do  Quit
 . . Set m=$p(m,"*")
 . . If m=$e(item,1,$l(m)),(e=""!(e[ext)) Set include=1 Quit
 . If m[":" Do  Quit
 . . Set m1=$p(m,":"),m2=$p(m,":",2)
 . . If m1=$e(item,1,$l(m1))!(item]m1) Do
 . . . If m2=$e(item,1,$l(m2))!(m2]item) Do
 . . . . Set:e=""!(e[ext) include=1
 . If m=item,(e=""!(e[ext)) Set include=1 Quit
 If include,mask["'" For i=1:1 Set m=$p(mask,";",i),e="" Quit:m=""  Do:m["'"  Quit:'include
 . Set m=$e(m,2,*)
 . Set:m["." m=$$ParseRoutineName^%R(m,.e),e=$s(e="*":"",e="SRC":".INC.MAC.INT.BAS",e="":"",1:"."_e)
 . If m["*" Do  Quit
 . . Set m=$p(m,"*")
 . . If m=$e(item,1,$l(m)),e=""!(e[ext) Set include=0
 . If m[":" Do  Quit
 . . Set m1=$p(m,":"),m2=$p(m,":",2)
 . . If m1=$e(item,1,$l(m1))!(item]m1) Do
 . . . If m2=$e(item,1,$l(m2))!(m2]item) Do
 . . . . Set:e=""!(e[ext) include=0 ; SJ bug fix
 . If m=item,(e=""!(e[ext)) Set include=0 Quit
 Quit include
 ;
guiFetch(pars) ; entry point for GUI utility call
 n netHard,return,%UI
 s %UI="CSP",netHard=$zu(68,27,0)
 s return=$$Fetch($p(pars,$c(22,35,1),1),$p(pars,$c(22,35,1),2),1)
 i $g(netHard) d $zu(68,27,1)
 q return
 ;
guiShow(detail) ; entry point from gui to show directory report
 s %UI="CSP"
 q $$Show(detail,1)
 ;        
Fetch(mask,silent,gui) ;fetch directory info
 ; Input parameters:
 ;       mask = global selection mask
 ;       silent = silent, no status posting (0/1)
 ;       gui = gui flag (0=chui/1=gui)
 ; Return:
 ;       #globals_del1_unreachable datasets
 quit $$FetchNSP($namespace,mask,silent,gui)
 q
FetchNSP(nsp,mask,silent,gui) ;fetch directory info for specified namespace
 ; Input parameters:
 ;       nsp = Namespace to fetch global directory from
 ;       mask = global selection mask
 ;       silent = silent, no status posting (0/1)
 ;       gui = gui flag (0=chui/1=gui)
 ; Return:
 ;       #globals_del1_unreachable datasets
 n node,info,glob,mynsp,name,output,badset,errlog,i,j,erlist
 n dset,xlat,map,xref,defdset,sysdset,str
 n POP,cnt,P1,P2,P3,P4,ret
 s $zt="FErr",$ze=""
 k %UI("CANCEL")
 s (erlist,errlog,POP,cnt,P4,ret)=0,(name,str,P2,P3)=""
 ;set up ^mtemp
 s node=$name(^mtemp($$%msub()))
 s output=$name(@node@("GLO")) ; output global list put here
 s info=$name(@node@("INFO")) ; namespace mappings put here
 s glob=$name(@node@("DIR")) ; global directories put here
 s mynsp=nsp i $e(mynsp)="^" d
 . d GetDir(mynsp,glob) ; implied namespace -> do only its directory
 . s name="" f  s name=$o(@glob@(name)) q:name=""  d
 . . s @output@(name,0)=@glob@(name)_mynsp_mynsp
 . k badset ; N/A for implieds
 . s defdset="",sysdset=""
 e  d Explicit
 ;set up ^IRIS.TempJ
 s name=""
 f  s name=$o(@output@(name)) q:name=""  i $$maskincl(mask,name) d  q:POP
 . i '$d(@output@(name,0)) q
 . s cnt=cnt+1,P1=cnt#5=0,P3="^"_name
 . i 'silent s P2=P3,P4=cnt
 . s ^IRIS.TempJ($j,P3)=@output@(name,0)
 i POP q
 ;save unreachable datasets for global directory report
 i $d(badset) s %="" d
 . f  s %=$o(badset(%)) q:%=""  d
 . . s badset=$g(badset)_$c(13,10)_"Dataset "_%_" is currently unreachable."
 s ^IRIS.TempJ($j)=$g(badset)
 s ret=cnt_$select($g(badset)="":"",1:$c(22,35,1)_badset)
 i POP s ret=0
FExit i $d(node) k @node ; eliminate our work node
 q ret
FErr s $zt="",ret=0_$c(22,35,1)_"Can not fetch global information!"_$s($ze="":"",1:$c(13,10)_$ze)
 g FExit
 ;
Show(detail,gui) ;show report
 ; Input parameters:
 ;       detail = show detail report (0/1)
 ;       gui = gui flag (0=chui/1=gui)
 ; Return:
 ;       #globals_del1_unreachable datasets
 s $zt="SErr",$ze=""
 n cnt,POP,line,name,str,P1,P2,P3,P4
 s (cnt,POP,line)=0,(name,str,P1,P2,P3,P4)=""
 s PROT(0)="N",PROT(1)="R",PROT(2)="RW",PROT(3)="RWD"
 i 'gui d  ;chui heading
 . S H="Global Directory Display of "_$namespace
 . U IO W @IOF W !,$J(H,$L(H)+IOM\2)
 . D INT^%T,INT^%D S H=%TIM_"  "_%DAT W !,$J(H,$L(H)+IOM\2)
 . w !!
 . w:detail !,"Global",?15,"Vacant",?25,"Own",?29,"Grp",?33,"Wld",?37,"Net"
 . w:detail ?42,"Growth",?52,"1st PB",?62,"Jrn  Keep",!
 f  s name=$o(^IRIS.TempJ($j,name)) q:name=""  d  q:POP
 . s cnt=cnt+1,P1=cnt#5=0,P3=name
 . s P2=P3,P4=cnt
 . i detail d
 . . s info=$g(^IRIS.TempJ($j,name))
 . . i info="" q
 . . ;vacant global flag
 . . i $d(@name) s P3=P3_$c(19,94,1)_0
 . . e  s P3=P3_$c(19,94,1)_1
 . . ;protection - owner, group, world, network
 . . s p=$P(info,"^",1)
 . . s P3=P3_$c(19,94,1)_PROT(p#4)_$c(19,94,1)_PROT(p\4#4)_$c(19,94,1)_PROT(p\16#4)_$c(19,94,1)_PROT(p\64#4)
 . . ;growth area
 . . s P3=P3_$c(19,94,1)_$p(info,"^",2)
 . . ;first pointer block
 . . s P3=P3_$c(19,94,1)_$p(info,"^",3)
 . . ;journal
 . . s P3=P3_$c(19,94,1)_$p(info,"^",4)
 . . ;collate
 . . s P3=P3_$c(19,94,1)_$$NAME^COLLATE($p(info,"^",5))
 . . ;data location
 . . s P3=P3_$c(19,94,1)_$$dset($p(info,"^",6,7))
 . . ;lock location
 . . s P3=P3_$c(19,94,1)_$$dset($p(info,"^",8,9))
 . . ;replication locations
 . . f i=10:2 s rep=$p(info,"^",i,i+1) q:rep=""  s P3=P3_$c(19,94,1)_$$dset(rep)
 . i 'gui d  ;show chui report
 . . i detail d
 . . . d fmt(P3)
 . . e  d
 . . . i $x+18\19*19+$l(P3)+8>IOM w ! d:SELF more(1) q:POP
 . . . If $Data(@P3) Set P3show=P3
 . . . Else  Set P3show=P3_"-",vacancies=1
 . . . w ?$x+18\19*19+4,P3show
 i 'gui d  ;show chui footing
 . w !!,cnt," global" w:cnt-1 "s" w " listed.",!,^IRIS.TempJ($j)
 . If $Get(vacancies) Write "Globals listed with a trailing ""-"" have a directory entry but no data",!!
 q cnt_$c(22,35,1)_$g(^IRIS.TempJ($j))
SErr q 0_$c(22,35,1)_"Can not fetch global information!"_$s($ze="":"",1:$c(13,10)_$ze)
 ;        
fmt(data) ; format/print a line
 w !,$p(data,$c(19,94,1),1) ;glboal name
 w ?15,$s($P(data,$c(19,94,1),2)=1:"Y",1:"") ;vacant flag
 w ?25,$P(data,$c(19,94,1),3) ;protection - owner
 w ?29,$P(data,$c(19,94,1),4) ;protection - group
 w ?33,$P(data,$c(19,94,1),5) ;protection - world
 w ?37,$P(data,$c(19,94,1),6) ;protection - net
 w ?42,$p(data,$c(19,94,1),7) ;growth area
 w ?52,$p(data,$c(19,94,1),8) ;first pointer block
 New typeval,jrnval,keepval
 Set typeval=$P(data,$c(19,94,1),9)
 Set jrnval=$Case($Zboolean(+typeval,4,1),4:1,:0)
 Set keepval=$Case($Zboolean(+typeval,1,1),1:1,:0)
 w ?62,$s(jrnval:"Y",1:"N") ;journal flag
 w ?67,$s(keepval:"Y",1:"N") ;keep flag
 w !?5,"Data Location:",?25,$P(data,$c(19,94,1),11) ;data location dataset
 w !?5,"Lock Location:",?25,$P(data,$c(19,94,1),12) ;lock location dataset
 w !?5,"Replications:" ;replication datasets
 f i=13:1 d  i rep="" w:i=13 ! q
 . s rep=$P(data,$c(19,94,1),i)
 . i rep'="" w ?25,rep,!
 w ?5,"Collation:",?25,$P(data,$c(19,94,1),10),! ;collation
 q
 ;
dset(s) ;format a dataset name
 i $p(s,"^",1)="" s s=$p(s,"^",2)
 q s
 ;
Explicit ; The current namespace is explicit
 ; Work through datasets and check global mappings
 d TRANSNSP^%SYS.GXLINFO(info,mynsp) ;get mappings for namespace "mynsp"
 s xlat=$name(@info@(mynsp)) ; pull out those for this namespace
 ; Decode mappings for all implicited datasets in our namespace
 s @xlat@("#")=+$g(@xlat@("#"))
 f i=1:1:@xlat@("#") s map=@xlat@("#",i) d
 . s @xlat@(map,"test")=$$decode(map)
 . i $d(@xlat@(map,"I")) d  ; implicits
 . . s xref=$p($p(@xlat@(map,"I"),"|""",2),"""|")
 . . s @xlat@(map,"impl")=xref,dset(xref)=""
 . i $d(@xlat@(map,"L")) d  ; lock target
 . . s @xlat@(map,"lock")=$p($p(@xlat@(map,"L"),"|""",2),"""|")
 . i $d(@xlat@(map,"R")) d  ; replication targets
 . . s @xlat@(map,"repl")="",xref=""
 . . f  s xref=$o(@xlat@(map,"R",xref)) q:xref=""  d
 . . . s @xlat@(map,"repl")=@xlat@(map,"repl")_$p($p(xref,"|""",2),"""|")
 ; The system data set is the default for %-globals
 s sysdset="^"_@xlat@("syssys")_"^"_@xlat@("sysdir")
 ; Get the global directory for the default dataset
 s defdset="^"_@xlat@("defsys")_"^"_@xlat@("defdir")
 d GetDir(defdset,$name(@glob@(defdset)))
 q:'$d(@glob@(defdset))
 ; Get the global directories for the other datasets
 s xref="" k dset(defdset)
 f  s xref=$o(dset(xref)) q:xref=""  d GetDir(xref,$name(@glob@(xref))) q:'$d(@glob@(xref))
 q:xref'=""
 ; Scan all directories and see if globals are "visible".
 f  s xref=$o(dset(xref)) q:xref=""  d Visible(xref)
 d Visible(defdset)
 D VisSLM(mynsp)  ; HYY066
 q
 ;
decode(map) ; Converts a global mapping descriptor to an IF @argument
 n ans,len,pos,ref1,ref2
 s pos=$f(map,":"),len=$l(map)
 i $e(map)="(" d  q ans ; exclusive form
 . i pos s ref1=$e(map,2,pos-2),ref2=$e(map,pos,len-1) d  q
 . . i $e(map,len)=")" d  q
 . . . i ref1="" s ans=""""_ref2_"""]name" q
 . . . i ref2="" s ans="name]"""_ref1_"""" q
 . . . s ans="name]"""_ref1_""","""_ref2_"""]name" q
 . . i $e(map,len)="]" d  q
 . . . i ref1="" s ans="name']"""_ref2_"""" q
 . . . i ref2="" s ans="name]"""_ref1_"""" q
 . . . s ans="name]"""_ref1_""",name']"""_ref2_"""" q
 . . s ans=0 q
 . s ref1=$e(map,2,len-1)
 . i $e(map,len)=")" s ans="name'="""_ref1_"""" q
 . i $e(map,len)="]" s ans="name'="""_ref1_"""" q
 . s ans=0 q
 i $e(map)="[" d  q ans ; inclusive form
 . i pos s ref1=$e(map,2,pos-2),ref2=$e(map,pos,len-1) d  q
 . . i $e(map,len)=")" d  q
 . . . i ref1="" s ans=""""_ref2_"""]name" q
 . . . i ref2="" s ans=""""_ref1_"""']name" q
 . . . s ans=""""_ref1_"""']name,"""_ref2_"""]name" q
 . . i $e(map,len)="]" d  q
 . . . i ref1="" s ans="name']"""_ref2_"""" q
 . . . i ref2="" s ans=""""_ref1_"""']name" q
 . . . s ans=""""_ref1_"""']name,name']"""_ref2_"""" q
 . . s ans=0 q
 . s ref1=$e(map,2,len-1)
 . i $e(map,len)=")" s ans="name="""_ref1_"""" q
 . i $e(map,len)="]" s ans="name="""_ref1_"""" q
 . s ans=0 q
 q 0
 ;
Visible(xref) ; Sees if globals in dataset are visible to our namespace
 n %
 s %=$s(xref'=sysdset:"",defdset=sysdset:"",1:"A") ; show %-globals?
 s name="" f  s name=$o(@glob@(xref,name)) q:name=""  d
 . f i=1:1:@xlat@("#") s map=@xlat@("#",i) i @@xlat@(map,"test") d  q
 . . i $g(@xlat@(map,"impl"),defdset)=xref  d
 . . . s:%']name @output@(name,0)=@glob@(xref,name)_xref_$g(@xlat@(map,"lock"),defdset)_$g(@xlat@(map,"repl"))
 . . e  i xref=defdset  d  ; record "hidden" global
 . . . s @output@(name,1)=@glob@(xref,name)_xref_$g(@xlat@(map,"lock"),defdset)_$g(@xlat@(map,"repl"))
 q
 ;
more(n) s line=line+n q:line+1<IOSL  s line=n,$zt="more2"
 w "--more--",*-1 r %ANS#1 s:$f("Qq",%ANS)>1 POP=1
more1 w $c(13),?9,$c(13)
 q
more2 s $zt="",POP=1 g more1
 ;
GetDirNSP(NSP,save) public { ; gets global directory for a namespace
 Kill ^IRIS.TempJ($j)
 If $E(save)="^" {
	Set rc=$$CheckOutputGlobal(save,1)
 }
 Set ng=$$FetchNSP(NSP,"*",1,1),g=""
 For  Set g=$o(^IRIS.TempJ($j,g)) Quit:g=""  Set @save@($e(g,2,$l(g)))=^(g)
 If $piece(ng,$c(22,35,1),2)'="" Set @save=$piece(ng,$c(22,35,1),2)
 Kill ^IRIS.TempJ($j)
}
 // Check if user has permission to write to a global
CheckOutputGlobal(Global,err=0) public {
	if $D(@Global)
	set subs=$F(Global,"(")
	if subs {
		set gname=$E(Global,2,subs-2),subs="("_$E(Global,subs,*)
	} else {
		if $V($V($ZU(40,1,11),-1,"P")+$ZU(40,3,21),-3,2) {
			if err do $ZUTIL(96,3,206,1,"subscript mapped global is not allowed")
			quit 1
		}
		set gname=$E(Global,2,*),subs=""
	}
	set perms=$$GetGlobalPermission^%SYS.SECURITY($namespace,gname,subs,0)
	if perms'["WRITE" {
		if err do $ZUTIL(96,3,206,1,Global)
		quit 2
	}
	quit 0
}
GetDir(NSP,save) [errlog,badset] Public { ; gets global directory for a dataset (implied namespace)
 If $E(save)="^" {
	Set rc=$$CheckOutputGlobal(save,1)
 }
 s rc=$$GetGlobalDirectoryInfo^%SYS.DATABASE(NSP,save)
 If ('rc) {
    d DecomposeStatus^%SYS.DATABASE(rc,.msglist,0,"")
    set er="" f i=1:1:msglist set er=er_msglist(i)_$c(13,10)
    Set $ze=er Set erlist=1 Goto errdir
 }
 i '$d(@save) s @save=""
 q
errdir s $zt="",errlog=$g(errlog)+1,errlog(errlog)=$Case($g(erlist),1:$ze,:$p($ze,">")_">"_NSP)
 s badset(NSP)=""
 q
}
 ;
ColAbbr(c) ; Return collation code abbreviation
 s cabbr=$$ABBREV^COLLATE(c)
 i cabbr'="" s c=cabbr
 q c
 ;
RemJobOLD() Public { ; Remote job to get a global directory
 s oldval=$zu(68,7,0) ;set RefInKind to return full reference
 s NSP="^^"_$zu(12,""),locnode=$name(^UTILITY("%GD")),errlog=0
 s dummy=$zu(68,7,oldval) ;set RefInKind back to what it was
 d GetDir(NSP,locnode)
 s @locnode=$s(errlog:$ze,1:"") ; lets caller know it is ready
 q
}
 ;
ErrorLog ; Print logged error messages
 n i f i=1:1:errlog d:SELF more(1) q:POP  d
 . w $p(errlog(i),"^")_$Case(erlist,1:"",:" error referencing ^"_$p(errlog(i),"^",2,3)),!
 d:SELF more(1) w !
 q
 ;
%msub() New x Set x=$I(^mtemp) Kill ^mtemp(x) Quit x
YN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YN"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"yn","YN") I "^YN"'[R W "  enter Yes or No, please"
 S POP=(R="^") W $E($S(R="N":"No",R="Y":"Yes",1:""),$L(X)+1,3) Q R
 ; input: xlat from Explicit^%GD
 ;        defdset
 ; input/output: @output@(...)
VisSLM(nsp) ;
 N i,j,xref,name,map,locdir,rng,slmrep
 F i=1:1:@xlat@("#") D:$D(@xlat@("#",i,"slm"))  ; this has an SLM global
 . S $ZT="etVisSLM"
 . ; retrieve SLM global "XX" from map pattern "[XX]" or "[XX:YY)"
 . S map=@xlat@("#",i),rng=map
 . S name=$P($P($P($E(map,2,$L(map)),":"),"]"),")") 
 . Q:'$D(@("^"_name))!((defdset'=sysdset)&("A"]name)) 
 . S map=$name(@xlat@("#",i,"slm",0))
 . S locdir=$G(@xlat@(rng,"lock"),defdset),repdir=$G(@xlat@(rng,"repl"))
 . S j="" F  S j=$O(@map@(j)) Q:j=""  D
 . . S $ZT="etVisSLM"
 . . S xref=$G(^|"%SYS"|SYS("GREDIR","GINDTAB",@map@(j,"implid")),defdset)
 . . S $P(xref,"^")="" ; e.g., remove 5 from string 5^...^...
 . . Q:'$D(@("^|"""_xref_"""|"_name))
 . . S slmrep=$G(^|"%SYS"|SYS("GREDIR","GINDTAB",@map@(j,"replid"))),$P(slmrep,"^")=""
 . . S:repdir_"^"'[(slmrep_"^") repdir=repdir_slmrep
 . . I '$D(@glob@(xref)) D GetDir(xref,$name(@glob@(xref))) ;HYY072
 . . S @output@(name,0,j)=@glob@(xref,name)_xref_locdir_slmrep ;future use
 . S @output@(name,0)=$P(@output@(name,0,$O(@output@(name,0,""))),"^",1,7)_locdir_repdir
 Q
etVisSLM ;
 i $ZE["<INTERRUPT" ZT $ZE
 S $ZT=""
 Q
ALLOLD ; routine to perform a %GD on each mounted database
 n curdir,origdir,firstime,multi,temp
 s origdir=$namespace,firstime=1,multi=1
 n SELF,PEP,IO,IOM,IOSL,IOF,lng
 s curdir=$$GetNextDatabaseByUCI^%SYS.CONFIG(1) i curdir="" g done
 w !,"Display globals for ",curdir d main3
loop s curdir=$$GetNextDatabaseByUCI^%SYS.CONFIG(curdir) i curdir="" g done
 i SELF W !,"Next, display globals for ",curdir d prompt
 i 'SELF W !,"Display globals for ",curdir
 s temp=$ZU(5,"^^"_curdir) d main3 s temp=$ZU(5,origdir) g loop
done s temp=$ZU(5,origdir)
 q
prompt ; ask for prompt when pagination in effect
 r !!,"Strike return to continue, any other key to quit. ",ans#1:20
 i ans="" q
 ZQ
BooleanYNLogicalToDisplay(val)
 q $case(val,1:$g(^%qMsg("%SYSTEM.Library",$s($mvv(58)="":"en",1:$mvv(58)),"Yes"),$g(^%qMsg("%SYSTEM.Library","en","Yes"),"No message found. Domain: "_"%SYSTEM.Library"_" Id: "_"Yes")),0:$g(^%qMsg("%SYSTEM.Library",$s($mvv(58)="":"en",1:$mvv(58)),"No"),$g(^%qMsg("%SYSTEM.Library","en","No"),"No message found. Domain: "_"%SYSTEM.Library"_" Id: "_"No")),:val)
BooleanYNDisplayToLogical(val)
  q $case($zcvt(val,"U"),$g(^%qMsg("%SYSTEM.Library",$s($mvv(58)="":"en",1:$mvv(58)),"YES"),$g(^%qMsg("%SYSTEM.Library","en","YES"),"No message found. Domain: "_"%SYSTEM.Library"_" Id: "_"YES")):1,$g(^%qMsg("%SYSTEM.Library",$s($mvv(58)="":"en",1:$mvv(58)),"NO"),$g(^%qMsg("%SYSTEM.Library","en","NO"),"No message found. Domain: "_"%SYSTEM.Library"_" Id: "_"NO")):0,:0)
ShowMessage(sc,device) [] PRIVATE {
    Do DecomposeStatus^%SYS.DATABASE(sc,.msglist,0,"")
    Do wrtmsg($C(13,10),device)
    For i=1:1:msglist {	Do wrtmsg(msglist(i)_$C(13,10),device) }
}
wrtmsg(msg,device) [] PRIVATE {
    Quit:'$L(msg)  ; Avoid argumentless writes...
    If device=-1 { Do $zu(9,"",msg,0,0) Quit }
    If $g(%UI,"CHUI")="CHUI" { Use device Write msg Quit }
    Do:$$IjcMsg^%Wprima("DI"_msg)="CANCEL"  ; Return value could be cancel message 
    . i $$IjcMsg^%Wprima("DI"_$C(13,10)_"Abort received!"_$C(13,10))
    . zt "Abort"
}

%SYS.GIFMSM^INT^1^67214,47330
%SYSGIFMSM ; Quick input of MSM globals from %FGS FILE
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ;*** THIS ASSUMES A FILE OUTPUT BY MSM'S %FGS UTILITY
 ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 ;
 ; opsys,block_size,link_address,type,bit8,blkoff,swapflg
OSS ;;1
 ;;MSM-UNIX3,1024,1012,4,0,1022,1
 ;
START N %DIR,BACKUP,BIT8,BLKOFF,BLKSIZ,BLOCK,DATABN,ENDIAN,ERR,GLO,GLONAM
 N GLOVEC,GVECA,GVLAST,GVPNT,HOWFULL,IO,IOPAR,IOSZ,IOT,LEN,LINKA,LNKSIZ
 N MTB,NBLKS,NEXTBN,NG,OFF,OS,PNTRBN,POP,RESTART,STOP,SWAPFLG,SYS,T,TAPE,vol,ZA
 N TIM2,TM,TYPE,X,Y
 N offset
 ;
 S $ZT="EXIT^"_$ZN,$ZE=""
 D INIT Q:STOP
 D MT I STOP G EXIT
 ;
CMMNT D OPSYS,HEADER Q:STOP
 D FILL
 D GLOBALS
 ;
EXIT S $ZT=""
 I $ZE]"" U 0 W !!,$ZE
 C:0'[IO&(IO'=$P) IO C 63
 LOCK
 Q
 ; End of main line.
 ;
 ;===================================================================
INIT W !,"Load globals from a FILE/TAPE written by MSM'S %FGS UTILITY."
 N df
 L %GIQ:0 E  W !,"[Another copy of %GIQ is running now.]" S STOP=1 Q
 i $$CURRENT^%SYS.NOJRN w !,"Journaling is currently enabled for this process.",!,"All imported data may be journaled.",!
 e  w !,"Journaling is currently disabled for this process.",!,"No imported data will be journaled.",!
 K  S IO="",$ZE="",$ZT="EXIT" D INT^%DIR
 ;
 S MTB=$ZU(40,1,20),SYS="INTERSYSTEMS IRIS"
 S ENDIAN=$ZU(40,0,0)
 S GVLAST=$ZU(40,3,13)+ENDIAN
 S GVPNT=$ZU(40,3,12)+ENDIAN
 S (STOP,RESTART,BACKUP)=0
 S IO("DF","RMS","FM")="RU"
 f df="MT","BT" d
 . s IO("DF",df,"FM")="AUF",IO("DF",df,"RL")=256
 . s IO("DF",df,"BL")=1024,IO("DF",df,"RW")="Y"
 s vol=1
 ;-------------------------------------------------------------------
 ;
 o 63
 Q
 ;
 ;-------------------------------------------------------------------
MT D INPUT^%IO U 0 I POP S STOP=1 Q
 I IOT="TRM" W *7,!,"Cannot use TERMINAL devices.",! Q 0
 I (IOT="MT")!(IOT="BT")!(IOT="RMS")
 E  W *7,!,"Cannot use '"_IOT_" type devices yet.",! G MT
 S TAPE=((IOT="MT")!(IOT="BT"))
 Q
 ;---------------------------------------------------------------------
HEADER ; Read Header Record
 ; FORMAT OF %FGS BINARY HEADER RECORD:
 ; FIELD #   LENGTH   VALUE      MEANING
 ; -------   ------   -----      -------
 ;    1        1       91H       BEGINNING OF %FGS FLAG
 ;    2        1      1 or 0     REVERSE BYTE ORDERING FLAG
 ;    3        1      number     SEQUENCE #
 ;    4        1      number     LENGTH OF DATE-TIME RECORD
 ;    5       VAR     string     DATE-TIME RECORD
 ;    6        1      number     LENGTH OF COMMENT RECORD
 ;    7       VAR     string     COMMENT RECORD
 ; --------------- repeating record for global list -------------------
 ;    8        3      string     VOLUME GROUP ID
 ;    9        3      string     UCI ID
 ;   10        8      string     GLOBAL (right padded with $C(0)'S)
 ; --------------------------------------------------------------------
 ;
 ; FORMAT OF %FGS TRAILER RECORD:
 ;    1        1       89H       END OF %FGS FLAG 
 ;                   -- or --
 ;                     90H       FILE OR TAPE CONTINUATION FLAG 
 ;    2        2      number     TOTAL BLOCK COUNT (AT OFFSET 512)
 ; --------------------------------------------------------------------
 U 0 W !
 U IO R BLOCK#BLKSIZ I $A(BLOCK)'=$ZH("91") U 0 W !,"THIS IS NOT A PROPER %FGS FORMAT - QUITTING RESTORE" S STOP=1 Q
 n srcendian s srcendian=($a(BLOCK,2)=0) s SWAPFLG=$s(srcendian'=ENDIAN:1,1:0)
 i SWAPFLG U 0 W !,"THIS FAST GLOBAL SAVE WAS DONE ON A MACHINE WITH THE OPPOSITE BYTE ORDERING"
 S LEN=$A(BLOCK,4),OFF=5 U 0 W !,"THIS FAST GLOBAL SAVE DONE ON "_$E(BLOCK,OFF,OFF+LEN-1)
 S OFF=OFF+LEN,LEN=$A(BLOCK,OFF) W !,"SAVED WITH COMMENT: ",$E(BLOCK,OFF+1,OFF+LEN)
 S OFF=OFF+LEN+1 W !!,"GLOBALS SAVED",!,"-------------"
 F OFF=OFF:14 Q:$A(BLOCK,OFF)=0  d
 . W !,"^|""^"_$E(BLOCK,OFF+3,OFF+5)_"^"_$E(BLOCK,OFF,OFF+2)_"""|"_$P($E(BLOCK,OFF+6,OFF+13),$C(0))
 ;
 ; FORMAT OF ADDITIONAL %FGS BINARY HEADER RECORD:
 ; FIELD #   LENGTH   VALUE      MEANING
 ; -------   ------   -----      -------
 ;    1        1       91H       BEGINNING OF %FGS FLAG
 ; --------------- repeating record for global list -------------------
 ;    8        3      string     VOLUME GROUP ID
 ;    9        3      string     UCI ID
 ;   10        8      string     GLOBAL (right padded with $C(0)'S)
 ; --------------------------------------------------------------------
 s PASSREAD=1
 F  U IO R BLOCK#BLKSIZ Q:$A(BLOCK)'=$ZH("91")  D
 . U 0 
 . S OFF=2 
 . F OFF=OFF:14 Q:$A(BLOCK,OFF)=0  d
 . . W !,"^|""^"_$E(BLOCK,OFF+3,OFF+5)_"^"_$E(BLOCK,OFF,OFF+2)_"""|"_$P($E(BLOCK,OFF+6,OFF+13),$C(0))
 U 0 W ! Q
 ;
OPSYS S X=$P($T(OSS+1)," ;;",2),LNKSIZ=4
 S OS=$p(X,",")
 S BLKSIZ=$P(X,",",2),LINKA=$P(X,",",3),TYPE=$P(X,",",4)
 S BIT8=$P(X,",",5),BLKOFF=$P(X,",",6)
 K OSS
 Q
 ;-------------------------------------------------------------------
FILL W !,"How full shall the ",SYS," global blocks become before splitting"
 R !,"(85% - 100%)? 95% => ",X S:X="" X=95
 I X["?" W ! DO  W ! G FILL
 . W !,"  100% gives the best packing but the first few days of"
 . W !,"  changes to the database will generate a lot of disk"
 . W !,"  activity due to block splitting."
 . W !
 . W !,"  85% leaves room for some growth before splitting but gives"
 . W !,"  lower packing efficiency."
 S X=X/100 I X'<.85,X'>1 S HOWFULL=X*2036\1 Q
 W *7,"  ???" G FILL
 ;--------------------------------------------------------------------
GLOBALS U 0 W !!,"Do you want to proceed, skipping those globals that are "
 W "already present?",!
 I $$YN("Proceed","Y")'="Y" S STOP=1 Q
 ;
COPY s TIM2=$H ;jsc-
 S (ERR,NG,TM)=0 F  D GLO Q:(ERR!TM)
 I ERR S STOP=1 Q
 ;
 I TM=99 W !,"Restore aborted",!
 U 0 W !,$J(NG,4)_" globals restored in "_$J($P($H,",",2)-$P(TIM2,",",2)/60,"",1)_" minutes."
 Q
 ;---------------------------------------------------------------------
GLO ; Read next global's name.
 ; FORMAT OF %FGS GLOBAL HEADER:
 ; FIELD #   LENGTH   VALUE      MEANING
 ; -------   ------   -----      -------
 ;    1        1       88H       BEGINNING OF GLOBAL
 ;    2        1      number     VOLUME GROUP INDEX
 ;    3        1      number     UCI INDEX
 ;    4        3      string     VOLUME GROUP ID
 ;    5        3      string     UCI ID
 ;    6        8      string     GLOBAL (right padded with $C(0)'S)
 ;    7        8      string     GLOBAL ATTRIBUTE/PROTECTION MASK
 ;    8        2      number     TOTAL BLOCK CNT - PREVIOUS GLOBAL
 ;                               (AT OFFSET 512)
 ; --------------------------------------------------------------------
 N CTR
 S $ZT="ERRNEW"
 I '$d(PASSREAD) U IO R BLOCK#BLKSIZ ;load in next buffer
 K PASSREAD ;Delete flag preventing blockread after first global
 V 0:0:-BLKSIZ:BLOCK ; COPY BLOCK TO VIEW BUFFER 
 I $V(0,0,1)=$ZH("88") ; NORMAL HEADER FOR NEW GLOBAL
 E  I $V(0,0,1)=$ZH("89") S TM=1 Q  ; TRAILER REC - NORMAL END OF %FGS
 E  I $V(0,0,1)=$ZH("90") D:TAPE MOUNT D:'TAPE NEXTFILE Q:TM  ; TRAILER REC - CONTINUATION FLAG
 E  S ERR=1 U 0 W !,"NEXT BLOCK DOESN'T HAVE PROPER GLOBAL HEADER" Q
 ;
 ; build the global name from the global header record
 S GLO=$P($V(9,0,-8),$C(0))
 I GLO="" S POP=1 U 0 Q  ;end of stuff!
 ;
 S GLONAM=$S($E(GLO)="^":GLO,1:"^"_GLO)
 U 0 W !,$E(GLONAM_"...               ",1,13) I '$D(@GLONAM) G GLO3
 ;
 W "is already present.  Skipping it on ",$S(TAPE:"tape",1:"file"),"."
 S $ZT="ERR2"
GLO2 F  U IO R BLOCK#BLKSIZ D  Q:(NEXTBN=0)!TM
 . D ZEROVIEW
 . V 0:0:-BLKSIZ:BLOCK
 . I $V(0,0,1)=$ZH("90") D:TAPE MOUNT D:'TAPE NEXTFILE Q:TM  D ZEROVIEW V 0:0:-BLKSIZ:BLOCK  ; TRAILER REC - CONTINUATION FLAG
 . S NEXTBN=$V(LINKA,0,LNKSIZ)
 Q
 ;
GLO3 U IO R BLOCK#BLKSIZ ; read in first block for global
 D ZEROVIEW ; zero out view buffer
 V 0:0:-BLKSIZ:BLOCK S NBLKS=1 ; copy 1st block to VIEW BUFFER
 S @GLONAM@(1)="" K ^(1) S CTR=0 ; RLL PATCH
 S NEXTBN=0,NBLKS=1
 S $ZT="ERR3A"
GLO3A S NEXTBN=$V(LINKA,0,LNKSIZ)
 D SWAP:SWAPFLG
 s X=$zu(93,6,%DIR,$p(GLONAM,"^",2),4,0,$zu(23,0))  ; use system default collation
 s X=$zu(93,7,BLOCK)
 S $ZT="ERR3B"
 ;
GLO3B F NBLKS=NBLKS:1 Q:NEXTBN=0  D BLOX Q:TM
 S $ZT="",NG=NG+1
 U 0 W $J($FN(NBLKS,","),10)," ","MSM"," blocks restored."
 Q
 ;-------------------------------------------------------------
BLOX U IO R BLOCK#BLKSIZ ;load in another block
 D ZEROVIEW V 0:0:-BLKSIZ:BLOCK ; copy to view buffer
 I $V(0,0,1)=$ZH("90") D:TAPE MOUNT D:'TAPE NEXTFILE Q:TM  D ZEROVIEW V 0:0:-BLKSIZ:BLOCK  ; TRAILER REC - CONTINUATION FLAG
 S NEXTBN=$V(LINKA,0,LNKSIZ) D SWAP:SWAPFLG
 s X=$zu(93,7,BLOCK)
 Q
 ;-------------------------------------------------------------
SWAP S X=$V(BLKOFF,0),Y=$V(BLKOFF+1,0) V BLKOFF:0:1:Y,BLKOFF+1:0:1:X
 s BLOCK=$v(0,0,-BLKSIZ)  ; Restore BLOCK for call to ZU(93,7,BLOCK)
 Q
 ;-------------------------------------------------------------
 ; Handle multi-volume tape/file called in continuation mark found
 ; or it <MAGTAPE> error.
 ;-------------------------------------------------------------
MOUNT ;
 S $ZT="ERRNEW" U 0
 W !,"End of tape encountered for tape volume number ",vol,"."
 W !,"Mount the next tape after this tape rewinds.",!
 S vol=vol+1
MT0 U IO W *-5 U 0
MT1 W !,"Press <RETURN> when tape volume number ",vol R " is ready: ",X
 I X="?" D  G MT1
 . W !,"Mount tape volume number ",vol," and press <RETURN> when it is ready."
 . W !,"Or enter '^' to abort the restore.",!
 I X["^" S TM=99 Q
 I X'="" W *7 G MT1
 D INPUT^%IO
 I IO="" S TM=99 Q
 U IO S ZA=$ZA U 0
 I ZA\64#2=0 W !,"Tape unit OFFLINE." G MOUNT
 I ZA\32#2=0 D      ;not fatal
 . W !,"Tape unit not at BEGINNING OF TAPE."
 . W !,"Do you want to rewind the tape? " S Y=$$YN("Rewind","Y")
 . I $E($$UC(Y))="Y" U IO W *-5 U 0
 I ZA\32768#2=1 W !,"Tape unit reports NOT READY." G MOUNT
 U IO R BLOCK#BLKSIZ
 I $A(BLOCK)'=$ZH("91") U 0 W !,"THIS IS NOT A PROPER %FGS FORMAT - Load the correct tape." G MT0
 I $A(BLOCK,2)'=SWAPFLG U 0 W !,"THIS FAST GLOBAL SAVE WAS DONE ON A MACHINE WITH THE OPPOSITE BYTE ORDERING"
 S X=$A(BLOCK,3)
COMMNXT I X=vol G HDRSKP
 U 0 W !!,"The ",$S(TAPE:"tape",1:"file")," currently loaded is the wrong volume."
 W !,"This is volume number ",+X,", not volume number ",vol
MT2 W !,"Do you want to proceed with number ",+X," instead of number ",vol,"?" S Y=$$YN("Proceed","N")
 I Y["^" S TM=99 Q
 I $E($$UC(Y))="N" G:TAPE MT0 G NF1
 I $E($$UC(Y))'="Y" W *7 G MT2
HDRSKP U IO R BLOCK#BLKSIZ G:$A(BLOCK)=$ZH("91") HDRSKP
 I GLO="" D:$A(BLOCK)=0  S vol=+X Q
 . F  R BLOCK#BLKSIZ Q:$A(BLOCK)
 I $A(BLOCK)=0,GLO'=$P($E(BLOCK,3,1+$A(BLOCK,2)),$C(0)) D  G:TAPE MT1 G NF1
 . U 0 W !,"Global doesn't match previous ",$S(TAPE:"tape",1:"file"),", please correct"
 Q
NEXTFILE ;
 U 0 W !,"Volume #",vol," restored",!
 W !,"If using removeable media, please put volume #",(vol+1)," into the drive and"
 S vol=vol+1
NF1 R !,"Press <RETURN> when ready",X
 I X?1"?".E W !!,"Press <RETURN> to continue restoring from volume #",vol,!,"or abort the restore by entering '^'" G NF1
 I X="^" S TM=99 Q
 I X'="" W *7 G NF1
 C IO
 D INPUT^%IO
 I IO="" S TM=99 Q
 U IO R BLOCK#BLKSIZ
 I $A(BLOCK)'=$ZH("91") U 0 W !,"THIS IS NOT A PROPER %FGS FORMAT - Load the correct file." G NF1
 I $A(BLOCK,2)'=SWAPFLG U 0 W !,"THIS FAST GLOBAL SAVE WAS DONE ON A MACHINE WITH THE OPPOSITE BYTE ORDERING"
 S X=$A(BLOCK,3)
 G COMMNXT
 ;-------------------------------------------------------------
 ; Error handling.
 ;-------------------------------------------------------------
ERRNEW ;error when starting a new global
ERR2 D ERR("skipping a global.") Q
ERR3A D ERR("reading first global data block.") Q
ERR3B D ERR("reading subsequent data block.") Q
ERR(msg) I $ZE["<MAGTAP" G MOUNT
 S $ZT="",ERR=1 U 0 W !,"Error "_msg_" "_"INTERSYSTEMS IRIS"_" ERROR = "_$ZE
 I $ZE?1"<DATAB".E D DBDGD ;database degrade!
 Q
 ;--------------------------------------------------------------------
YN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YN"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"yn","YN") I "^YN"'[R W "  enter Yes or No, please"
 S POP=(R="^") W $E($S(R="N":"No",R="Y":"Yes",1:""),$L(X)+1,3) Q R
STOP(x) S x=$$UC($E(x,1,4)) Q (x["EXIT")!(x["STOP")!(x["QUIT")!(x["HALT")!($E(x)="^")
UC(x) q $zcvt(x,"u")
 ;
ZEROVIEW ; Zero out view buffer
 N I
 F I=0:1:511 V I*4:0:4:0
 Q
 ;---------------------------------------------------------------------
DBDGD W !,"The original ",OS," block number was ",NEXTBN,"."
 I '((OS="M/11+")!(OS="M/VX")) Q
 W !,"The contents are:"
 F I=1:2 S X=$V(I,-5) Q:X=""  W !,X,"=",$V(I+1,-5)
 Q
 ;---------------------------------------------------------------------

%SYS.GLO^INT^1^67214,47330
%SYSGLO ; Save global directory information
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
    Do ^|"%SYS"|%GLO Quit
BEG   Do BEG^|"%SYS"|%GLO Quit
INT   Do INT^|"%SYS"|%GLO Quit
isrem() Quit $$isrem^|"%SYS"|%GLO
RemJob Do RemJob^|"%SYS"|%GLO Quit
defdir(ns) PUBLIC { Quit $$defdir^|"%SYS"|%GLO(ns) }
defsys(ns) PUBLIC { Quit $$defsys^|"%SYS"|%GLO(ns) }

%SYS.GXLINF1^INT^1^67214,47330
%SYSGXLINF1   ; Convenience subroutines for global translation
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ; GXLATE.INC
dheader(D) ;Subheader for a directory
 W !,$$DC("-",79),!,D Q
footer W !,$$DC("=",79)
 i $d(repstat) d
 . w !!,?10,"[<global>] shows redirection scheme for one global;"
 . w !,?10,"[<global1>:<global2>] shows redirection scheme for a"
 . w !,?15,"range between 2 globals; a square bracket [] means that"
 . w !,?15,"left or right margin is inclusive, while a parenthesis"
 . w !,?15,"means that the margin is exclusive."
 . w !,?15,"An empty parenthesis before or after ':', that is "
 . w !,?15,"(: or :) , means that the redirection scheme is "
 . w !,?15,"effective from the start of alphabet space, or till"
 . w !,?15,"its end, respectively"
 . w !
 . w !,?15,"A subscript mapping is missing if it is the same as "
 . w !,?15,"the default mapping of the global. The default mapping"
 . w !,?15,"of a global is missing if it is the same as the default"
 . w !,?15,"global dataset."
 . w !
 W:$D(repstat("->")) !,?10,"->","  implicit"
 W:$D(repstat("+>")) !,?10,"+>","  replicated"
 W:$D(repstat("*>")) !,?10,"*>","  lock target"
 I $D(repstat("P")) D
 . W !,?10,"*U  unreachable -- at least one destination for this "
 . w "pattern is not"
 . w !,?29,"defined in the current MNET configuration."
 . W !,?29,"Any reference to this pattern will generate a"
 . W !,?29,"<NOSYS> error.",!
 I $D(repstat("R")) D
 . W !,?10,"*R  at least one replication destination for this "
 . w "pattern is not"
 . w !,?29,"defined in the current MNET configuration."
 . W !,?29,"Any reference to this pattern will generate"
 . w !,?29,"a <NOSYS> error. However replication will have"
 . w !,?29,"taken place to destinations that precede the "
 . w !,?29,"unreachable destination when the error is"
 . w !,?29,"returned."
 Q  
 ;
SLMDUMP() PUBLIC {
 ; This entry point dumps the SLM keys for one global in raw
 ; form as opposed to ^%SYS.GXLINFO which formats the data. This is
 ; not a supported entry point as it may not work in the future.
 ;
 s $ZT="SLMDERR"
read r !,"Namespace (return to exit)? ",nsname
 q:nsname=""
 i nsname'["@" s nsname=$zcvt(nsname,"U")
 r !,"Global (*=object code)? ^",globnam
 i globnam="*" s globnam="rOBJ"
 s nspinfo=$zu(90,28,2,nsname)
 if nspinfo=""||(globnam="") w !,"no mapping found for ^",globnam," in ",nsname g read
 k gxlatinfo
 do getgxlatarray^%SYS.GXLINFO(.nspinfo,globnam,.gxlatinfo,2)
 i '$d(gxlatinfo) w !,"no mapping found for ^",globnam," in ",nsname g read
 i $list(gxlatinfo,3)="" w !,"^",globnam," is not slmapped in ",nsname g read
 s defdir=$p($list(gxlatinfo,2),"|",3)
 i 'defdir s defdir=$p(nspinfo,"|",2)
 s slm=$list(gxlatinfo,3)
 s info=$list(slm,1)
 s nument=+$P(info,"|",1)
 s colseq=+$P(info,"|",2)
 w !,"There are ",nument," entries, the collation sequence is ",colseq
 w !,"Default directory for non % globals: ",$$showgind(defdir)
 w !,"Entry",?7,"Subscr pattern",?30,"Impl dest",?70,"Repl pat"
 f i=0:1:nument-1 d
 . s subscr=$list(slm,i*2+2)
 . i $L(subscr)=0 s subscr="<nullstr>"
 . s dstinfo=$list(slm,i*2+3)
 . s impldst=+$P(dstinfo,"|",1)
 . i impldst=0 s impldst=defdir
 . s reppat=+$P(dstinfo,"|",2)
 . w !,i,?7
 . f j=1:1:$L(subscr) s ch=$A($E(subscr,j)) d
 . . i ch>32,ch<127 w $C(ch) q
 . . w "<$C(",ch,")>"
 . w ?30,impldst," ",$$showgind(impldst)
 . w ?75,reppat," ",$$showgind(reppat)
 w !
 g read
SLMDERR ;
 s $ZT=""
 w !,"Error: ",$ZE," encountered - exiting"
 q
}
 ;
showgind(gind) public {
 Q:gind=0 ""
 s sys=$ZU(90,6,gind)
 s dir=$ZU(90,7,gind)
 i sys'=0 { s dest=$ZU(63,4,sys) } else { set dest="" }
 Q "^"_dest_"^"_dir
}
showslm(d,i,rmap) ;
 q:'$d(@tran@(d,"#",i,"slm"))
 ;
 s:'$d(rmap) rmap=""
 n p,first s p=@tran@(d,"#",i),first=1
 n ent,imp,n,rep,replst,sub
 ;loop through slm entries
 s ent=""
 s rep=@tran@(d,"#",i,"slm",0,0,"replid")
 s imp=@tran@(d,"#",i,"slm",0,0,"implid")
 w !
 f  s ent=$o(@tran@(d,"#",i,"slm",0,ent)) q:ent=""  d  q:ent=""
 . ;get first subscript that does not have last default mapping
 . s sub(1)=@tran@(d,"#",i,"slm",0,ent,"subscript")
 . if $e(sub(1),*-2,*)=",""""" s $e(sub(1),*-1,*)="BEGIN"
 . s imp(1)=@tran@(d,"#",i,"slm",0,ent,"implid")
 . s rep(1)=@tran@(d,"#",i,"slm",0,ent,"replid")
 . q:'imp(1)&'rep(1)  ;commented out until range symbols are fixed
 . ;check to see if range set up
 . s ent=$o(@tran@(d,"#",i,"slm",0,ent))
 . if sub(1)="" s sub(1)="BEGIN"
 . i ent="" s (rep(2),imp(2))="",sub(2)="END"
 . e  d
 . . s sub(2)=@tran@(d,"#",i,"slm",0,ent,"subscript")
 . . if $e(sub(2),*)=$C(1),$e(sub(2),1,*-1)'=sub(1) s $e(sub(2),*)=",END"
 . . s imp(2)=@tran@(d,"#",i,"slm",0,ent,"implid")
 . . s rep(2)=@tran@(d,"#",i,"slm",0,ent,"replid")
 . . ;i sub(2)[$c(1)!(sub(2)=sub(1)) s (sub(2),rep(2),imp(2))="" ;HYY079
 . . s ent=$o(@tran@(d,"#",i,"slm",0,ent),-1)
 .  ;display entry as close to possible as entered in by user
 . i $l(rmap) d
 . . w:$x>1 ! w "   ["_$tr(sub(1),"""") w:sub(2)'="" ":"_$tr(sub(2),"""") w ")"
 . . w:$x>23 !
 . . d:imp(1) 
 . . . w ?26,rmap
 . . . s SYSNO=$ZU(90,6,imp(1))
 . . . i SYSNO d
 . . . . S SYSNAME=""
 . . . . F  S SYSNAME=$ZU(63,2,SYSNAME) Q:(SYSNAME="")  Q:$ZU(63,0,SYSNAME)=SYSNO
 . . . . w ?36,SYSNAME
 . . . w ?56,$ZU(90,7,imp(1))
 . e  d
 . . i first,$O(@$NAME(@tran@(d,p,"R"))@(""))="",$G(@tran@(d,p,"L"))="" W "   "_$tr($p(p,":"),"[("),!
 . . s first=0
 . . W ?7,$S(sub(1)[$C(1):"(",1:"[")_"("_$P(sub(1),$C(1),1)_")"
 . . W ":"
 . . W "("_$P(sub(2),$C(1),1)_")"_$S(sub(2)[$C(1):"]",1:")")
 . . ;display data location
 . . w:$x>23 !
 . . i imp(1) d
 . . . w ?23,"->"
 . . . s SYSNO=$ZU(90,6,imp(1))
 . . . i SYSNO d
 . . . . S SYSNAME=""
 . . . . F  S SYSNAME=$ZU(63,2,SYSNAME) Q:(SYSNAME="")  Q:$ZU(63,0,SYSNAME)=SYSNO
 . . . . w ?26,SYSNAME
 . . . w ?36,$ZU(90,7,imp(1))
 . . ;get and display replication stuff
 . . i rep(1) d
 . . . k replst d repset^%SYS.GXLINFO(rep(1),"replst")
 . . . s n="" f  s n=$o(replst(n)) q:n=""  s PP="" d showpat0^%SYS.GXLINFO("+>",n)
 . . w !
 ;
 q
 ;getsubmap(nsp) returns a list of global mapping patterns, delimited
 ;  by ",", for namespace nsp.
 ;getsubmap(nsp,glo) returns a list of SLM patterns in $LIST format
 ;  for global glo in namespace nsp
getsubmap(nsp,glo) public {
	try {
		return:$g(nsp)="" ""
		s nspinfo=$zu(90,28,2,nsp)
		if nspinfo="" return ""
		k gxlatinfo
		do getgxlatarray^%SYS.GXLINFO(.nspinfo,$g(glo),.gxlatinfo,$s($g(glo)="":1,1:0)+2)
		if '$d(gxlatinfo) return ""
		i $g(glo)="" {
			s glo="",ent=""
			f  s ent=$o(gxlatinfo(ent),1,data) q:ent=""  s glo=glo_$list(data,1)_","
			return glo
		}
		s data=$list(gxlatinfo,3) return:data="" ""     
		s ent=+$list(data,1)
		s glo="" f i=0:1:(ent-1) s $li(glo,i+1)=$list(data,i*2+2)
		return glo
	} catch {
		return ""
	}
}
 ;return value is in the form of system^directory
 ;getdest(nsp) returns the default global location for namespace nsp
 ;getdest(nsp,glo) returns the location for ^[nsp]glo
 ;getdest(nsp,glo,sub) returns the location for ^[nsp]glo(sub)    
getdest(nsp,glo,sub) public {
	try {
		return:$g(nsp)="" ""
		i $e(nsp)'="^" {
			s nsp=$zcvt(nsp,"u")
		} else {
			s nsp=$tr(nsp,"^","@")
		}
		s nspinfo=$zu(90,28,2,nsp)
		if nspinfo="" return ""
		if $e($g(glo))="^" s glo=$e(glo,2,*)
		s dest=0 i $g(glo)="",$g(sub)="" g exit
		return:$g(glo)="" ""
		k gxlatinfo
		do getgxlatarray^%SYS.GXLINFO(.nspinfo,glo,.gxlatinfo,0)
		if '$d(gxlatinfo) {
			if nspinfo="" return ""
			g exit
		}
		if +$p($list(gxlatinfo,2),"|")<0 s sub="" ;no slm for * match
		s slmdata=$list(gxlatinfo,3)
		i $g(sub)'=""&&(slmdata'="") {
			s nument=+$list(slmdata)
			i $e(sub)="(",$e(sub,$l(sub))=")" s sub=$e(sub,2,$l(sub)-1)
			s encrule=$zu(70,1,$p($list(slmdata),"|",2)),encsub=$$encodesub(sub,encrule)
			f i=0:1 {
				q:i=nument
				s pat=$list(slmdata,i*2+2)
				q:pat=sub
				i pat]"" {
					i $e(pat,$l(pat))'=$c(1) {
						q:$$encodesub(pat,encrule)]encsub
						continue
					}
					s epat=$$encodesub($e(pat,1,*-1),encrule)
					i epat]encsub||(epat=$e(encsub,1,$l(epat))) q
				}
			}
			i pat'=sub s i=i-1
			s dest=$p($list(slmdata,i*2+3),"|")
			i 'dest s dest=$p($list(gxlatinfo,2),"|",3)
		}
		i 'dest s dest=$s($list(gxlatinfo)=glo:$p($list(gxlatinfo,2),"|",3),1:$p($list(gxlatinfo,2),"|",6))
exit 	i 'dest s dest=$p(nspinfo,"|",2)
		s sys=$ZU(90,6,dest)
		i sys=0 return "^"_$ZU(90,7,dest)
		s sys=$zu(63,4,sys)
		i sys="" ZT "NOSYS"
		return sys_"^"_$ZU(90,7,dest)
	} catch {
		return ""
	}
}
getalldest(nsp,glo,stsub,endsub,collate) public {
	try {
		return:$g(nsp)="" ""
		i $e(nsp)'="^" {
			s nsp=$zcvt(nsp,"u")
		} else {
			return $LB(1,$LB($e(nsp,2,*)))
		}
		s nspinfo=$zu(90,28,2,nsp)
		if nspinfo="" return $LB(0,"Namespace "_nsp_" does not exist")
		if $e($g(glo))="^" s glo=$e(glo,2,*)
		s dest=""
		return:$g(glo)="" $LB(0,"Global is not specified")
		k gxlatinfo
		do getgxlatarray^%SYS.GXLINFO(.nspinfo,glo,.gxlatinfo,0)
		if '$d(gxlatinfo) {
			if nspinfo="" return $LB(0,"Namespace "_nsp_" is not active")
			s dest=0
			g onedb
		}
		if +$p($list(gxlatinfo,2),"|")<0 { ;no slm for * match
			s dest=$s($list(gxlatinfo)=glo:$p($list(gxlatinfo,2),"|",3),1:$p($list(gxlatinfo,2),"|",6))
			g onedb
		}
		s slmdata=$list(gxlatinfo,3)
		i slmdata'="" {
			s nument=+$list(slmdata)
			s collate=+$p($list(slmdata),"|",2)
			s encrule=$zu(70,1,collate)
			s stsubchecked=0
			s dest="",n=0
			f i=0:1 {
				q:i=nument
				s pat=$list(slmdata,i*2+2),epat=""
				if 'stsubchecked {
					if stsub="" {
						s stsubchecked=1
					} elseif pat="" {
						continue
					} else {
						i $e(pat,$l(pat))'=$c(1) {
							s epat=$$encodesub(pat,encrule)
							if epat'=stsub,epat']stsub continue
						} else {
							s epat=$$encodesub($e(pat,1,*-1),encrule)
							i epat']stsub&&(epat'=$e(stsub,1,$l(epat))) continue
							s epat=epat_$c(1)
						}
						s stsubchecked=1
					}
				}
				s entry=i
				if epat]"" {
					if stsub'=epat {
						s entry=i-1
						s pat=$list(slmdata,entry*2+2)
						s epat=$s(pat="":"",1:$s($e(pat,$l(pat))'=$c(1):$$encodesub(pat,encrule),1:$$encodesub($e(pat,1,*-1),encrule)_$c(1)))
					}
				} elseif pat]"" {
					i $e(pat,$l(pat))'=$c(1) {
						s epat=$$encodesub(pat,encrule)
						q:epat]endsub
					} else {
						s epat=$$encodesub($e(pat,1,*-1),encrule)
						i epat]endsub||(epat=$e(endsub,1,$l(epat))) q
						s epat=epat_$c(1)
					}
				}
				s dd=+$p($list(slmdata,entry*2+3),"|")
				i 'dd s dd=$s($list(gxlatinfo)=glo:$p($list(gxlatinfo,2),"|",3),1:$p($list(gxlatinfo,2),"|",6))
				i 'dd s dd=$p(nspinfo,"|",2)
				if $d(prevdd),prevdd=dd continue
				s prevdd=dd
				s sys=$ZU(90,6,dd)
				s sys=$s(sys:$zu(63,4,sys),1:"")
				s dbref=sys_"^"_$ZU(90,7,dd)
				s dest=dest_$LB($LB(sys_"^"_$ZU(90,7,dd),epat))
				s n=n+1
			}
			if 'n s dest=$s($list(gxlatinfo)=glo:$p($list(gxlatinfo,2),"|",3),1:$p($list(gxlatinfo,2),"|",6)) goto onedb
			return $LB(n)_dest
		} else {
			s dest=$s($list(gxlatinfo)=glo:$p($list(gxlatinfo,2),"|",3),1:$p($list(gxlatinfo,2),"|",6)) 
		}
onedb 	i 'dest s dest=$p(nspinfo,"|",2)
		s sys=$ZU(90,6,dest)
		i sys=0 return $LB(1,$LB("^"_$ZU(90,7,dest)))
		s sys=$zu(63,4,sys)
		i sys="" ZT "NOSYS"
		return $LB(1,$LB(sys_"^"_$ZU(90,7,dest)))
	} catch {
		return $LB(0,"Caught error, $ZE="_$ZE)
	}
}
encodesub(sub,rule) ;encode subscripts like "d",9,"foobar" by the given rule
 n encsub,len,x,vnam,i
 s encsub="",vnam="x("_sub_")",len=$ql(vnam)
 f i=1:1:len s encsub=encsub_$zu(70,2,$qs(vnam,i),rule)_$c(0)
 q encsub
DC(c,n) Q $TR($J("",n)," ",$E(c_" "))

%SYS.GXLINFO^INT^1^67214,47330
%SYSGXLINFO   ; Convenience subroutines for global translation
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ; GXLATE.INC
BEG n IO,POP
 N IOMS s IOMS=$System.Device.GetRightMargin()
 d OUT^%IS
 Q:POP
 u IO
 g SHOW
 ;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
NOSYS(sysnam) ; 1 if sysnam doesn't exist/isn't valid or 0 if it is good
 n n
 s n=$ZU(63,0,sysnam)
 i n=255!(n=-1) q 1
 q 0
ISIMP(G,D)  S $ZT="NOIMP" Q ($S($ZU(90,1,$G(D),G)>0:$ZU(90,2,3,$ZU(90,1,$G(D),G)),$ZU(90,1,$G(D),G)<0:$ZU(90,2,6,-$ZU(90,1,$G(D),G)),1:0)'=0)
ISREP(G,D)  S $ZT="NOREP" Q ($S($ZU(90,1,$G(D),G)>0:$ZU(90,2,2,$ZU(90,1,$G(D),G)),$ZU(90,1,$G(D),G)<0:$ZU(90,2,5,-$ZU(90,1,$G(D),G)),1:0)'=0)
ISLCK(G,D)  S $ZT="NOLCK" Q ($S($ZU(90,1,$G(D),G)>0:$ZU(90,2,4,$ZU(90,1,$G(D),G)),$ZU(90,1,$G(D),G)<0:$ZU(90,2,7,-$ZU(90,1,$G(D),G)),1:0)'=0)
ISTRAN(G,D) S $ZT="NOTRAN" Q $ZU(90,1,D,G)'=0
NOIMP S $ZT="",$ZE="" Q 0
NOREP S $ZT="",$ZE="" Q 0
NOLCK S $ZT="",$ZE="" Q 0
NOTRAN S $ZT="",$ZE="" Q 0
IMP(G,D) n entry,intdir
 s entry=$ZU(90,1,D,G)
 q:'entry ""
 s intdir=$s(entry>0:$ZU(90,2,3,entry),entry<0:$ZU(90,2,6,-entry))
 q $$ENV(intdir)
REPNO(G,D) ;
 n entry
 s entry=$ZU(90,1,D,G)
 q $s('entry:0,entry>0:$ZU(90,2,2,entry),1:$ZU(90,2,5,-entry)) 
REPSET(G,D,NODE) D repset($$REPNO(G,$G(D)),NODE) Q
REP(G,D) N I,R,TEMP S I=0,R="" D REPSET(G,$G(D),"TEMP")
 S T="" F  S T=$O(TEMP(T)) Q:T=""  D  ;
 . S I=I+1,$P(R," ",I)=T
 Q R
LCK(G,D) n entry,intdir
 s entry=$ZU(90,1,D,G)
 q:'entry ""
 s intdir=$s(entry>0:$ZU(90,2,4,entry),entry<0:$ZU(90,2,7,-entry))
 q $$ENV(intdir)
 ; Returns path information from system
ENVN() Q $ZU(90,5)
ENV(ENT) ; Get environment for entry #ENT from ^SYS("GREDIR","GINDTAB",ENT)
 N info,SYSNAME,DIRNAME
 Q:$G(ENT)="" ""  Q:ENT<1 ""  Q:$$ENVN<ENT ""
 n mgrnsp s mgrnsp="^^"_$zu(12)
 s info=$G(^|mgrnsp|SYS("GREDIR","GINDTAB",ENT))
 q:info="" ""  ; This should not really happen
 s SYSNAME=$P(info,"^",2)
 s DIRNAME=$E(info,$l($P(info,"^",1,2))+2,$L(info))
 Q $$ENVJOIN(SYSNAME,DIRNAME)
repsetb(i) ;repsetb(i)=i-th replication set returned as bits
 N %32Bits,addr
 S %32Bits=4294967296
 s addr=i*8+$V($ZU(40,2,11)+($ZU(40,0,4)*5),-2,"S")
 q $V(addr,-3,4)+($v(addr+4,-3,4)*%32Bits)
REPSETA() ; $$REPSETN = next available replication set number, 0 if table full
 N I,N S N=0 F I=1:1:15 Q:$$repsetb(I)=0  S N=I
 s N=N+1
 i N>15 s N=0
 Q N
REPN() ;Number of replication sets in table.  
 n r s r=$$REPSETA q:r=0 15  q r-1
repset(I,NODE) ; D repset(I,"X") sets X(path) for all replication paths
 N BITNO,BITVAL,S,SET
 K @NODE
 Q:I>$$REPN  Q:I<1  ;Silently return nothing for bad I values
 S SET=$$repsetb(I),S=SET
 S $ZT="repset0"
 F BITNO=0:1 Q:S=0  S:S#2 @NODE@($$ENV(BITNO))="" S S=S\2 
 Q
repset0 d $zu(9,"","Error in "_$ZN_": "_$ZE_": BITNO="_BITNO_" S="_$ZH(S)_" ENV="_$$ENV(BITNO),(1>0),1)
 Q
defnode(n) s:$g(n)="" n=$name(^IRIS.TempUtil("%GXLINFO")) q
TRANS(node) ;
 ; for each directory, create arrays with nodes
 ; based on ranges or individual globals, whatever
 ; is appropriate
 ; effectively, we convert internal representation
 ; of "this - fromnowon" into real ranges
 n nsversion,nsplist,nspinfo,lastp,startidx,array,ns,i
 d defnode(.node) k @node
 s nsversion=$zu(90,20,1)
 s nsplist=$zu(90,28,1,0,nsversion)
 s lastp=$p(nsplist,",",$l(nsplist,","))
 s startidx=$s(nsplist]"":$s(lastp?1N.N:+lastp,1:0),1:0)
 while (nsplist=-1 || startidx) {
	 if nsplist=-1 {
		 s startidx=0,nsversion=$zu(90,20,1)
		 k array
	 } else {
		 f i=1:1:$l(nsplist,",") s nspinfo=$p(nsplist,",",i),array($p(nspinfo,"|",1))=nspinfo
	 }
	 s nsplist=$zu(90,28,0,startidx,nsversion)
	 s lastp=$p(nsplist,",",$l(nsplist,","))
	 s startidx=$s(nsplist]"":$s(lastp?1N.N:+lastp,1:0),1:0)
 }
 i nsplist]"" f i=1:1:$l(nsplist,",") s nspinfo=$p(nsplist,",",i),array($p(nspinfo,"|",1))=nspinfo
 s ns=$o(array(""))
 while (ns'="") {
	 do onedir(array(ns),node)
	 s ns=$o(array(ns))
 }
 q   ; from TRANS
TRANSNSP(node,dirname) 
 n nspinfo
 d defnode(.node) k @node
 s nspinfo=$zu(90,28,2,dirname)
 if nspinfo="" q
 d onedir(nspinfo,node)
 q
onedir(nspinfo,node) ;
 n dirname,dirdef,sysdef,num,gxlatarray,previncl,endidx
 s dirname=$p(nspinfo,"|",1)
 k @node@(dirname)
 do getgxlatarray(.nspinfo,"",.gxlatarray,0)
 if $d(gxlatarray) {
	 s dirdef=$p(nspinfo,"|",2)
	 s sysdef=$p(nspinfo,"|",3)
	 s @node@(dirname,"defdir")=$$ENVDIR($$ENV(dirdef))
	 s @node@(dirname,"defsys")=$$ENVDSET($$ENV(dirdef))
	 s @node@(dirname,"sysdir")=$$ENVDIR($$ENV(sysdef))
	 s @node@(dirname,"syssys")=$$ENVDSET($$ENV(sysdef))
	 s num=$o(gxlatarray("")),endidx=$o(gxlatarray(""),-1)
	 while (num'="") {
		 d analgbl(node,dirname,gxlatarray(num),$s(num<endidx:gxlatarray(num+1),1:""),.previncl)
		 s num=$o(gxlatarray(num))
	 }
 }
 q   ; from onedir 
analgbl(node,dirname,nspinfo,nextnspinfo,previncl)
 n namerng,samespec,samenext,thisname,nextname,locnum,slm,info,nextinfo
 s previncl=+$g(previncl)
 s (samespec,samenext)=0
 s thisname=$list(nspinfo,1)
 s slm=$list(nspinfo,3)
 if (nextnspinfo'="") {
	 s nextname=$list(nextnspinfo,1)
	 s nextinfo=$list(nextnspinfo,2)
 } else {
	 s nextname=""
 }
 s info=$list(nspinfo,2)
 i $p(info,"|",2)=$p(info,"|",5),$p(info,"|",3)=$p(info,"|",6),$p(info,"|",4)=$p(info,"|",7) s samespec=1
 i nextnspinfo'="",$p(info,"|",5)=$p(nextinfo,"|",2),$p(info,"|",6)=$p(nextinfo,"|",3),$p(info,"|",7)=$p(nextinfo,"|",4) s samenext=1
 i thisname="%" s thisname="",previncl=1
 i nextname="{" s nextname=""
 i 'previncl,'samespec {
	 s namerng="["_thisname_"]"
	 d entry(node,info,dirname,namerng,1)
	 s locnum=$g(@node@(dirname,"#"))+1
	 s @node@(dirname,"#")=locnum 
	 s @node@(dirname,"#",locnum)=namerng
	 d:slm'="" slm(node,dirname,locnum,slm)
	 s previncl=samenext   ; let the next entry know whether we have inclusive right margin here
 }
 s namerng=$s(('previncl)&samespec:"[",1:"(")_thisname_":"_nextname_$s(samenext:"]",1:")")
 d entry(node,info,dirname,namerng,2)
 s locnum=$g(@node@(dirname,"#"))+1
 s @node@(dirname,"#")=locnum
 s @node@(dirname,"#",locnum)=namerng
 d:slm'="" slm(node,dirname,locnum,slm)
 s previncl=samenext   ; let the next entry know whether we have inclusive right margin here
 q   ; from analgbl
slm(node,dirname,locnum,data)       ;
 n nent,lent,sub2,k,replid,implid
 quit:data=""
 s nent=+$list(data,1)-1
 f k=0:1:nent {
	 s lent=k*2+2
	 s sub2=$list(data,lent)
	 s replid=$p($list(data,lent+1),"|",2)
	 s implid=$p($list(data,lent+1),"|",1)
	 s @node@(dirname,"#",locnum,"slm",0,k,"subscript")=sub2
	 s @node@(dirname,"#",locnum,"slm",0,k,"replid")=replid
	 s @node@(dirname,"#",locnum,"slm",0,k,"implid")=implid
 }
 q
entry(node,info,dirname,namerng,match) ; Put translation entry #i into node
 ; info - index|exactname.repindex|exactname.impdest|exactname.lckdest|fromnow.repindex|fromnow.impdest|fromnow.lckdest
 ; node - has a subscript of global name or range
 ; match 1 or 2 - indicates whether to take "this" or "after"
 n imp,lck
 k @node@(dirname,namerng)
 i match=1 d
 . s imp=$$ENV($p(info,"|",3))
 . s lck=$$ENV($p(info,"|",4))
 . i imp'="" s @node@(dirname,namerng,"I")=imp
 . i lck'="" s @node@(dirname,namerng,"L")=lck
 . d repset($p(info,"|",2),$name(@node@(dirname,namerng,"R")))
 i match=2 d
 . s imp=$$ENV($p(info,"|",6))
 . s lck=$$ENV($p(info,"|",7))
 . i imp'="" s @node@(dirname,namerng,"I")=imp
 . i lck'="" s @node@(dirname,namerng,"L")=lck
 . d repset($p(info,"|",5),$name(@node@(dirname,namerng,"R")))
 q
getgxlatarray(nspinfo,global,gxlatarray,Flags) PUBLIC {
 do {
	 s dirname=$p(nspinfo,"|",1)
	 s startidx=$p(nspinfo,"|",4)
	 s endidx=startidx+$p(nspinfo,"|",5)-1
	 s nsgennum=$p(nspinfo,"|",6)
	 s curindex=startidx-1
	 s startslm=0
	 do {
		 if (startslm) {
		 	s gxlatinfo=$zu(90,29,dirname,global,curindex+1,endidx,nsgennum,Flags,startslm)
		 } else {
		 	s gxlatinfo=$zu(90,29,dirname,global,curindex+1,endidx,nsgennum,Flags)
		 }
		 if (gxlatinfo=-1) {
			 s nspinfo=$zu(90,28,2,dirname)
			 k gxlatarray
			 if nspinfo="" s gxlatinfo=""
			 quit
		 }
		 if (gxlatinfo=-2) s nspinfo="" k gxlatarray quit
		 if (gxlatinfo="") k gxlatarray quit
		 if global'="" s gxlatarray=gxlatinfo quit
		 if startslm {
			 if $listlength(gxlatinfo)'=3 {
				 d $zu(9,"","getgxlatarray: bad return for getting partial SLM entries, return list length = "_$listlength(gxlatinfo),1 /* broadcast and log message*/,2  /* Severe error */)
				 k gxlatarray quit
			 }
			 s slm=$list(gxlatinfo,3)
			 s accslm=accslm_$list(slm,2,$listlength(slm))
			 s curindex=+$list(gxlatinfo,2)
			 if +$list(slm)'=($listlength(accslm)-1/2) {
				 s curindex=curindex-1  ; get back to the same gxlate entry.
				 s startslm = $listlength(accslm)-1/2
			 } else {
				 s startslm = 0
				 s gxlatarray(curindex)=$list(gxlatinfo,1,2)_$LB(accslm)
			 }
			 continue
		 }
		 for num=1:3:$listlength(gxlatinfo) {
			 s curindex=+$list(gxlatinfo,num+1)
			 s slm=$list(gxlatinfo,num+2)
			 if slm'="",+$list(slm)'=($listlength(slm)-1/2) {
				 s curindex=curindex-1  ; get back to the same gxlate entry.
				 s startslm = $listlength(slm)-1/2
				 s accslm=slm
				 quit
			 }
			 s gxlatarray(curindex)=$list(gxlatinfo,num,num+2)
		 }
	 } while(curindex<endidx)
 } while (gxlatinfo=-1)
}
ONFILE n mgrnsp s mgrnsp="^^"_$zu(12)
 d LIST($name(^|mgrnsp|SYS("GREDIR","STU"))) q
LIST(tran,DIR) ;for use by GREDIR, list specs in tran for DIR
 n repstat
 d:'$d(DIR) show d:$d(DIR) showdir(DIR) d footer^%SYS.GXLINF1 q
SHOW  
 S $ZT="etSHOW"
 N tran,repstat s tran=$name(^mtemp($$%msub())) D TRANS(tran)
 D show,footer^%SYS.GXLINF1 K @tran u:IO=$P&&$D(IOMS) IO:/MAR=IOMS c:IO'=$P IO u 0 
 q
etSHOW ;
 S $ZT=""
 K @($G(tran))
 Q
SHOWNSP(D) ; show translations for namespace D
 S $ZT="etSHOW"
 i $e(D,1,2)="^^" s D=$tr(D,"^","@")
 N tran,repstat s tran=$name(^mtemp($$%msub())) D TRANS(tran)
 I $D(@tran@(D)) D showdir(D),footer^%SYS.GXLINF1 K @tran  Q
 K @tran
 W !,"No translations defined for namespace ",D
 u 0
 Q
 ; Internal routines, use @tran@ and repstat (via REPORT)
showpat(D,P) ;show information for pattern P in directory D
 N PP,R,RNODE S PP=P  ;PP is "first-time" flag
 D showpat0("->",$G(@tran@(D,P,"I")))
 S RNODE=$NAME(@tran@(D,P,"R")) S R="" F  S R=$O(@RNODE@(R)) Q:R=""  D  ;
 . D showpat0("+>",R)
 D showpat0("*>",$G(@tran@(D,P,"L")))
 Q
showrou(d,i)    ;
 s type=$tr($p(@tran@(d,"#",i),":",1),"[]()")
 d showslm^%SYS.GXLINF1(d,i,$s(type="rOBJ":"OBJ",type["rMAC":"MAC",type["rINC":"INC",type="ROUTINE":"INT"))
 q
showpat0(symbol,val) 
 Q:val=""
 I $$ENVDSET(val)'="" S repstat("DSET")=""
 i PP="" s PP="   "_PP
 e  d  ; Figure out whether the repl/implicit destinations are ok
 . n impdest,repdest,tmp
 . s impdest=$P($G(@tran@(D,P,"I")),"^",2)
 . i impdest'="",$$NOSYS(impdest) s PP="*U "_PP,repstat("P")=""
 . ; If the implicit is ok, then check for replication problems
 . i $E(PP,1)'="*" s repdest=$O(@tran@(D,P,"R","")) f  q:repdest=""  d
 . . s tmp=$P(repdest,"^",2) 
 . . i tmp'="",$$NOSYS(tmp) d  q  ; repdest is now null 
 . . . s PP="*R "_PP,repstat("R")="",repdest=""
 . . s repdest=$O(@tran@(D,P,"R",repdest))
 . i $E(PP,1)'="*" s PP="   "_PP
 w:$x>19 ! w PP,?23,symbol,?26,$$ENVDSET(val),?36,$$ENVDIR(val)
 S repstat(symbol)=""
 S PP="" ;Suppress pattern and entry number on subsequent
 Q
showdir(D) ;show information for all patterns in namespace D
 w !,$$DC("*",79)
 w !,"Namespace: " 
 i $e(D)="@" {
	 w $replace(D,"@","^")
 } else {
	 w D
 }
 w !,"Default globals location:  directory "_@tran@(D,"defdir")_$s(@tran@(D,"defsys")="":" (local) ",1:" on system "_@tran@(D,"defsys"))
 w !,"Default % routines location: directory "_@tran@(D,"sysdir")_$s(@tran@(D,"syssys")="":" (local) ",1:" on system "_@tran@(D,"syssys"))
 w !,$$DC("*",79)
 d header
 N I,P,ROU S ROU="" F I=1:1:$G(@tran@(D,"#")) D
 . S P=@tran@(D,"#",I) 
 . D showpat(D,P) 
 . S PP=0 F X="rMACSAVE","rINCSAVE","ROUTINE","rOBJ","rMAC","rINC" I $TR($P(P,":",1),"()[]:")[X S PP=1 Q:(X="rMAC")!(X="rINC")  S ROU=ROU_I_","
 . Q:PP
 . D showslm^%SYS.GXLINF1(D,I)
 I $L(ROU) d rouhdr F I=1:1:$L(ROU,",")-1 d showrou(D,$P(ROU,",",I))
 Q
show ; show information for all patterns in all directories
 N D S D="" F  S D=$O(@tran@(D)) Q:D=""  D  ;
 . D showdir(D)
 q
header w !,"Global name/Range",?26,"Dirset",?36,"Target directory"
 w !,$$DC("-",79)
 Q
rouhdr ;
 w !,"Routine name/Range",?26,"Type",?36,"Dirset",?56,"Target directory"
 w !,$$DC("-",79)
 q
ENVNORM(S,BRACKET) ;Accepts "", directory, or environment in either format
 N DIR,DSET S DIR=$G(S),DSET=""
 I $$isbar(S)!$$isbrack(S) S DIR=$$ENVDIR(S),DSET=$$ENVDSET(S)
 S DIR=$$DIRFULL(DIR)
 Q $$ENVJOIN(DSET,DIR,.BRACKET)
ENVJOIN(DSET,DIR,BRACKET) ;Environment spec from directory set and directory
 I '$D(BRACKET) S BRACKET=$G(%BRACKET)  ;Backward compatibility
 I 'BRACKET Q "|""^"_DSET_"^"_DIR_"""|"
 n NSP s NSP="^^"_DIR
 I DSET="" Q "["""_NSP_"""]" ;If no DSET, don't put it in spec
 Q "["""_DIR_""","""_DSET_"""]"         
ENVDIR(P) ;Extract directory from an extended global reference
 Q $$envpiece(3,P)
ENVDSET(P) ;Extract directory set from an extended global reference
 Q $$envpiece(2,P)
ISLOCAL(REF)  Q ENVDSET(REF)=""
ISREMOTE(REF) Q ENVDSET(REF)'=""
isbrack(s) 
 q s["[" ;Return true if s is bracket-style reference
isbar(s)    q s["|" ;Return true if s is bar-style reference
envpiece(p,ref) ;Internal, p=2 returns dir set, p=3 returns dir
 i $$isbar(ref) q $$barpiece(p,ref)
 i $$isbrack(ref) q $$brkpiece(4-p,ref)
 q ""
brkpiece(p,ref) ;Implements envpiece for bracket-style environment specs
 n dirsys,item,val
 s dirsys=$p($p(ref,"]"),"[",2)
 s item=$p(dirsys,",",p) i item="" q ""
 q $$EVAL(item)
barpiece(p,ref) ;Implements envpiece for bar-style environment specs
 n dirsys s dirsys=$p(ref,"|",2) q $p($$EVAL(dirsys),"^",p)
EVAL(expr) n s,v s s="v="_expr,$zt="eval0",@s q v
eval0 q ""
SLMDUMP ;
 ; This entry point dumps the SLM keys for one global in raw
 ; form as opposed to ^%SYS.GXLINFO which formats the data. This is
 ; not a supported entry point as it may not work in the future.
 ;
 D SLMDUMP^%SYS.GXLINF1 
DC(c,n) Q $TR($J("",n)," ",$E(c_" "))
DIRFULL(dir) Q $ZU(12,dir)
%msub() New x Set x=$I(^mtemp) Kill ^mtemp(x) Quit x

%SYS.NLS^INT^1^67214,47330
%SYSNLS ;national language applications interface functions
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ;%ShmObj.INC ; JLC1084 11/07/07
Set(type,tabnam) PUBLIC {
 Quit:type="I" $$SetIO(tabnam)    ;Select I/O xlate tbl for cur device
 Quit:type="J" $$SetPIO(tabnam)   ;Select I/O xlate tbl for process
 Quit:type="X" $$SetXY(tabnam)    ;Select $X/$Y action tbl for cur device
 Quit:type="P" $$SetPM(tabnam)    ;Select Pattern Match tbl for process
 Quit:type="E" $$SetIdent(tabnam) ;Select Identifier tbl for process
 Quit:type="U" $$SetUpper(tabnam) ;Select Upper Case tbl for process
 Quit:type="L" $$SetLower(tabnam) ;Select Lower Case tbl for process
 Quit:type="T" $$SetTitle(tabnam) ;Select Title Case tbl for process
 Quit:type="C" $$SetCOL(tabnam)   ;Select Collation tbl for process
 Quit $ZUTIL(96,0,78) ;unknown table type
}
SetIO(tabnam) PUBLIC { Quit $zu(96,18,2,tabnam) }
SetPIO(tabnam) PUBLIC {
 Set handle=$zu(125,3,tabnam) ;Create a modifiable handle
 Quit:'handle $ZUTIL(96,0,78) If $zu(125,4,0) ;Delete old handle, if present
 Quit $zu(125,0,handle)
}
SetXY(tabnam) PUBLIC { Quit $zu(96,19,2,tabnam) }
SetPM(tabnam) PUBLIC { Quit $$SetTabName(0,"Pattern",tabnam) }
SetIdent(tabnam) PUBLIC { Quit $$SetTabName(1,"Ident",tabnam) }
SetUpper(tabnam) PUBLIC { Quit $$SetTabName(2,"UpperCase",tabnam) }
SetLower(tabnam) PUBLIC { Quit $$SetTabName(3,"LowerCase",tabnam) }
SetTitle(tabnam) PUBLIC { Quit $$SetTabName(4,"TitleCase",tabnam) }
SetTabName(param,ttyp,tabnam) PUBLIC {
 Quit:tabnam="" $zu(96,20,param,$V((param)*$ZU(40,0,25)+($ZU(40,2,104)),-2,$ZU(40,0,25)))
 Set charset=$$GetCharset()
 Set oid=$O(^|"%SYS"|SYS("shm","Src",1,"%nls",ttyp,charset,tabnam,""),-1) ;Object ID
 If oid Set off=$G(^|"%SYS"|SYS("shm","Off",0,oid)) Quit:off $zu(96,20,param,off)
 If ttyp["Case",((tabnam="Built-in")||(tabnam="Unicode")||(tabnam="Latin1")) Quit $zu(96,20,param,$V((param)*$ZU(40,0,25)+($ZU(40,2,166)),-2,$ZU(40,0,25)))
 Quit $ZUTIL(96,0,78) ;unknown table name
}
SetCOL(tabnam) PUBLIC {
 Quit:tabnam="" $zu(23,1,$zu(23,0))
 If tabnam?1.n {
 	If tabnam<256,'($p($zu(23,2,tabnam),"^",1,2)="255^255") Set ret=$zu(23,1,tabnam)
 	Else  Set ret=$ZUTIL(96,0,78) ;invalid collation type
 	Quit ret
 }
 Set col=$$GetColNum($$GetCharset(),tabnam)
 Quit:col<0 $ZUTIL(96,0,78) Quit $zu(23,1,col)
}
GetColNum(chs,nam) PUBLIC {
	Set ref=$Name(^|"^^"_$zu(12)|SYS("NLS","TablesD")),num=-1
	If $D(@ref@("COL",chs,nam),rec) Set col=$LG(rec,14),num=$List(col,1)
	Quit num
}
StatIO() PUBLIC { Quit $$getstate("",0)!$$getstate("",1) }
OnIO() PUBLIC { Quit $$setstate("",0,1)!$$setstate("",1,1) }
OffIO() PUBLIC { Quit $$setstate("",0,0)!$$setstate("",1,0) }
StatPIO() PUBLIC { Quit $$getstate(0,0)!$$getstate(0,1) }
OnPIO() PUBLIC { Quit $$setstate(0,0,1)!$$setstate(0,1,1) }
OffPIO() PUBLIC { Quit $$setstate(0,0,0)!$$setstate(0,1,0) }
getstate(han,dir) {
	Set $ZT="errstate" Quit $zu(125,6,han,dir,3)
errstate Quit 0
}
setstate(han,dir,val) {
	Set $ZT="errstate" Quit $zu(125,6,han,dir,3,val)
errstate Quit 0
}
SetCursorFlag(val) PUBLIC { Quit $zu(96,22,val) }
GetCursorFlag() PUBLIC { Quit $zu(96,22) }
SetInpMode(nbr) PUBLIC { Quit:($zu(96,18,0)]"") $zu(125,6,"",0,2,nbr) Quit 0 }
SetOutMode(nbr) PUBLIC { Quit:($zu(96,18,1)]"") $zu(125,6,"",1,2,nbr) Quit 0 }
GetInpMode() PUBLIC { Quit:($zu(96,18,0)]"") $zu(125,6,"",0,2) Quit 0 }
GetOutMode() PUBLIC { Quit:($zu(96,18,1)]"") $zu(125,6,"",1,2) Quit 0 }
SetPInpMode(nbr) PUBLIC { Quit $zu(125,6,0,0,2,nbr) }
SetPOutMode(nbr) PUBLIC { Quit $zu(125,6,0,1,2,nbr) }
GetPInpMode() PUBLIC { Quit $zu(125,6,0,0,2) }
GetPOutMode() PUBLIC{ Quit $zu(125,6,0,1,2) }
SetInpModeStr(nbr,val) PUBLIC { Quit:($zu(96,18,0)]"") $zu(125,7,"",0,nbr,val) Quit "" }
SetOutModeStr(nbr,val) PUBLIC { Quit:($zu(96,18,1)]"") $zu(125,7,"",1,nbr,val) Quit "" }
GetInpModeStr(nbr) PUBLIC { Quit:($zu(96,18,0)]"") $zu(125,7,"",0,nbr) Quit "" }
GetOutModeStr(nbr) PUBLIC { Quit:($zu(96,18,1)]"") $zu(125,7,"",1,nbr) Quit "" }
SetPInpModeStr(nbr,val) PUBLIC { Quit $zu(125,7,0,0,nbr,val) }
SetPOutModeStr(nbr,val) PUBLIC { Quit $zu(125,7,0,1,nbr,val) }
GetPInpModeStr(nbr) PUBLIC { Quit $zu(125,7,0,0,nbr) }
GetPOutModeStr(nbr) PUBLIC { Quit $zu(125,7,0,1,nbr) }
SetInpReplType(typ) PUBLIC { Quit:($zu(96,18,0)]"") $zu(125,6,"",0,0,typ) Quit 0 }
SetOutReplType(typ) PUBLIC { Quit:($zu(96,18,1)]"") $zu(125,6,"",1,0,typ) Quit 0 }
GetInpReplType() PUBLIC { Quit:($zu(96,18,0)]"") $zu(125,6,"",0,0) Quit 0 }
GetOutReplType() PUBLIC { Quit:($zu(96,18,1)]"") $zu(125,6,"",1,0) Quit 0 }
SetInpReplVal(val) PUBLIC { Quit:($zu(96,18,0)]"") $zu(125,6,"",0,1,val) Quit "" }
SetOutReplVal(val) PUBLIC { Quit:($zu(96,18,1)]"") $zu(125,6,"",1,1,val) Quit "" }
GetInpReplVal() PUBLIC { Quit:($zu(96,18,0)]"") $zu(125,6,"",0,1) Quit "" }
GetOutReplVal() PUBLIC { Quit:($zu(96,18,1)]"") $zu(125,6,"",1,1) Quit "" }
SetInpReplStat(flg) PUBLIC { Quit:($zu(96,18,0)]"") $zu(125,6,"",0,6,flg) Quit 0 }
SetOutReplStat(flg) PUBLIC { Quit:($zu(96,18,1)]"") $zu(125,6,"",1,6,flg) Quit 0 }
GetInpReplStat() PUBLIC { Quit:($zu(96,18,0)]"") $zu(125,6,"",0,6) Quit 0 }
GetOutReplStat() PUBLIC { Quit:($zu(96,18,1)]"") $zu(125,6,"",1,6) Quit 0 }
SetPInpReplType(typ) PUBLIC { Quit $zu(125,6,0,0,0,typ) }
SetPOutReplType(typ) PUBLIC { Quit $zu(125,6,0,1,0,typ) }
GetPInpReplType() PUBLIC { Quit $zu(125,6,0,0,0) }
GetPOutReplType() PUBLIC { Quit $zu(125,6,0,1,0) }
SetPInpReplVal(val) PUBLIC { Quit $zu(125,6,0,0,1,val) }
SetPOutReplVal(val) PUBLIC { Quit $zu(125,6,0,1,1,val) }
GetPInpReplVal() PUBLIC { Quit $zu(125,6,0,0,1) }
GetPOutReplVal() PUBLIC { Quit $zu(125,6,0,1,1) }
SetPInpReplStat(flg) PUBLIC { Quit $zu(125,6,0,0,6,flg) }
SetPOutReplStat(flg) PUBLIC { Quit $zu(125,6,0,1,6,flg) }
GetPInpReplStat() PUBLIC { Quit $zu(125,6,0,0,6) }
GetPOutReplStat() PUBLIC { Quit $zu(125,6,0,1,6) }
Get(type) PUBLIC {
 Quit:type="I" $$GetIO    ;Return I/O xlate tbl name for cur device
 Quit:type="J" $$GetPIO   ;Return I/O xlate tbl name for process
 Quit:type="X" $$GetXY    ;Return $X/$Y action tbl name for cur device
 Quit:type="P" $$GetPM    ;Return Pattern Match tbl name for process
 Quit:type="E" $$GetIdent ;Return Identifier tbl name for process
 Quit:type="U" $$GetUpper ;Return Upper Case tbl name for process
 Quit:type="L" $$GetLower ;Return Lower Case tbl name for process
 Quit:type="T" $$GetTitle ;Return Title Case tbl name for process
 Quit:type="C" $$GetCOL   ;Return Collation tbl name for process
 Quit $ZUTIL(96,0,78) ;unknown table type
}
GetIO() PUBLIC { Quit $zu(96,18,0) }
GetPIO() PUBLIC { Set handle=$zu(125,0) Quit:handle $zu(125,5,handle) Quit "" }
GetXY() PUBLIC { Quit $zu(96,19,0) }
GetPM() PUBLIC { Quit $$GetTabName($zu(96,20,0)) }
GetIdent() PUBLIC { Quit $$GetTabName($zu(96,20,1)) }
GetUpper() PUBLIC { Quit $$GetCase(2) }
GetLower() PUBLIC { Quit $$GetCase(3) }
GetTitle() PUBLIC { Quit $$GetCase(4) }
GetCase(tab) {
	Set name=$$GetTabName($zu(96,20,tab))
	If name="",$zu(96,20,tab)=$V((tab)*$ZU(40,0,25)+($ZU(40,2,166)),-2,$ZU(40,0,25)) Set name="Built-in"
	Quit name
}
GetCOL() PUBLIC { Quit $$getcolname($zu(23,1)) }
getcolname(byte) {
 Set nbr=$p($zu(23,2,byte),"^",3) Quit:nbr $$GetTabName($p($zu(83,nbr),",")) Quit byte
}
GetTabName(off) PUBLIC {
 Set oid=+$O(^|"%SYS"|SYS("shm","Off",1,off,"")) Quit:'oid ""
 Set nam=$q(^|"%SYS"|SYS("shm","Src",0,oid)) Quit:$QS(nam,3)'=0 "" Quit:$QS(nam,4)'=oid ""
 Quit $QS(nam,$QL(nam)) ;Return last subscript
}
Def(type,class) PUBLIC {
 Quit:type="I" $$DefIO(.class)       ;Return sys def I/O xlate tbl name
 Quit:type="X"&'$d(class) $$DefXY    ;Return sys def $X/$Y action tbl name
 Quit:type="P"&'$d(class) $$DefPM    ;Return sys def Pattern Match tbl name
 Quit:type="E"&'$d(class) $$DefIdent ;Return sys def Identifier tbl name
 Quit:type="U"&'$d(class) $$DefUpper ;Return sys def Upper Case tbl name
 Quit:type="L"&'$d(class) $$DefLower ;Return sys def Lower Case tbl name
 Quit:type="T"&'$d(class) $$DefTitle ;Return sys def Title Case tbl name
 Quit:type="C"&'$d(class) $$DefCOL   ;Return sys def Collation tbl name
 Quit $ZUTIL(96,0,78) ;unknown table type
}
DefIO(class) PUBLIC {
 Set:'$D(class) class=1 q:class<0!(class>9) $ZUTIL(96,0,78)
 Set namoff=$V((class)*$ZU(40,0,25)+($ZU(40,2,105)),-2,$ZU(40,0,25))
 Quit:namoff $ZU(126,5,namoff)
 Quit ""
}
DefXY() PUBLIC {
 Set namoff=$V((0)*$ZU(40,0,25)+($ZU(40,2,106)),-2,$ZU(40,0,25))
 Quit:namoff $ZU(126,5,namoff)
 Quit ""
}
DefPM() PUBLIC { Quit $$GetTabName($V((0)*$ZU(40,0,25)+($ZU(40,2,104)),-2,$ZU(40,0,25))) }
DefIdent() PUBLIC { Quit $$GetTabName($V((1)*$ZU(40,0,25)+($ZU(40,2,104)),-2,$ZU(40,0,25))) }
DefUpper() PUBLIC { Quit $$GetTabName($V((2)*$ZU(40,0,25)+($ZU(40,2,104)),-2,$ZU(40,0,25))) }
DefLower() PUBLIC { Quit $$GetTabName($V((3)*$ZU(40,0,25)+($ZU(40,2,104)),-2,$ZU(40,0,25))) }
DefTitle() PUBLIC { Quit $$GetTabName($V((4)*$ZU(40,0,25)+($ZU(40,2,104)),-2,$ZU(40,0,25))) }
DefCOL() PUBLIC { Quit $$getcolname($zu(23,0)) }
SetPDef(type,tabnam,class) PUBLIC {
 Quit:type="I" $$SetPDefIO(tabnam,.class)     ;Select proc def I/O xlate tbl
 Quit:type="X"&'$D(class) $$SetPDefXY(tabnam) ;Select proc def $X/$Y action tbl
 Quit $ZUTIL(96,0,78) ;unknown table type
}
SetPDefIO(tabnam,class) PUBLIC {
 Set:'$D(class) class=1 Quit:class<0!(class>9) $ZUTIL(96,0,78)
 Set namoff=$ZU(127,1,$V((0)*$ZU(40,0,25)+($ZU(40,2,103)),-2,$ZU(40,0,25)),tabnam,0) Quit:'namoff $ZUTIL(96,0,78)
 V (class)*$ZU(40,0,25)+($ZU(40,1,27)):-1:$ZU(40,0,25):namoff Quit tabnam
}
SetPDefXY(tabnam) PUBLIC {
 Set namoff=$ZU(127,1,$V((1)*$ZU(40,0,25)+($ZU(40,2,103)),-2,$ZU(40,0,25)),tabnam,0) Quit:'namoff $ZUTIL(96,0,78)
 V (0)*$ZU(40,0,25)+($ZU(40,1,28)):-1:$ZU(40,0,25):namoff Quit tabnam
}
GetPDef(type,class) PUBLIC {
 Quit:type="I" $$GetPDefIO(.class)    ;Return proc def I/O xlate tbl name
 Quit:type="X"&'$D(class) $$GetPDefXY ;Return proc def $X/$Y action tbl name
 Quit $ZUTIL(96,0,78) ;unknown table type
}
GetPDefIO(class) PUBLIC {
 Set:'$D(class) class=1 Quit:class<0!(class>9) $ZUTIL(96,0,78)
 Set namoff=$V((class)*$ZU(40,0,25)+($ZU(40,1,27)),-1,$ZU(40,0,25))
 Quit:namoff $ZU(126,5,namoff)
 Quit ""
}
GetPDefXY() PUBLIC {
 Set namoff=$V((0)*$ZU(40,0,25)+($ZU(40,1,28)),-1,$ZU(40,0,25))
 Quit:namoff $ZU(126,5,namoff)
 Quit ""
}
SetPitch(pitch) PUBLIC { Quit $zu(96,17,2,pitch*4\1)/4 }
GetPitch() PUBLIC { Quit $zu(96,17,0)/4 }
DefDCLocale() PUBLIC { Quit "DEFAULT" }
SetDCLocale(tabnam) PUBLIC {
 Set $ZT="DCFtrap"
 Quit:($ZCVT(tabnam,"U")="DEFAULT") $S($ZU(122,0,0)<0:"PRIVATE",1:"DEFAULT")
DCFtrap Quit -101
}
GetDCLocale(tabnam) PUBLIC {
 Set $ZT="DCFtrap"
 Quit $S($ZU(122,0)<0:"PRIVATE",1:"DEFAULT")
DCFtrap Quit -101
}
GetDCFormat(item) PUBLIC {
 Set $ZT="DCFtrap"
 Set ndx=$$GetDCIndex(item) 
 If ndx<0 Quit -100
 Quit $ZU(122,ndx)
DCFtrap Quit -101
}
SetDCFormat(item,val) PUBLIC {
 Set $ZT="DCFtrap"
 Set ndx=$$GetDCIndex(item) 
 If ndx<0 Quit -100
 Quit $ZU(122,ndx,val)
DCFtrap Quit -101
}
GetDCIndex(item) PUBLIC {
 Set i=$ZCVT(item,"U")
 Quit $S(i="DATEFORMAT":1,i="YEAROPTION":2,i="TIMEFORMAT":3,i="TIMEPRECISION":4,i="NUMERICGROUPSIZE":5,i="DECIMALSEPARATOR":6,i="NUMERICGROUPSEPARATOR":7,i="DATESEPARATOR":8,i="TIMESEPARATOR":9,i="PLUSSIGN":10,i="MINUSSIGN":11,i="AM":12,i="PM":13,i="NOON":14,i="MIDNIGHT":15,i="MONTHABBR":16,i="MONTHNAME":17,i="WEEKDAYABBR":18,i="WEEKDAYNAME":19,i="DATEMINIMUM":20,i="DATEMAXIMUM":21,1:-1)
}
MapCharset(ext,set) PUBLIC {
 Set rchs=$Name(^%SYS("NLS","Chs")),low=$ZCVT(ext,"L")
 Set int=$G(@rchs@("Int-Int",low),$G(@rchs@("Ext-Int",low)))
 If int'="",int'="Unicode" {
    Set loc=$G(^|"^^"_$zu(12)|%SYS("LOCALE","CURRENT"))
    If loc'="" {
       Set rloc=$Name(^|"^^"_$zu(12)|SYS("NLS","LocalesD")),rloc=$Name(@rloc@(loc)),lrec=$G(@rloc)
       If lrec'="" Set lchs=$LG(lrec,2)
       Else  Set lchs=$G(^%nls("Loc",loc,0))
       If lchs=int Set int="RAW"
    }
 }
 If int'="",$G(set) Set $ZT="MapChsError" Do SetIO(int)
 Quit int
MapChsError Quit ""
}
MapExtCharset(int) PUBLIC {
 Quit $G(^%SYS("NLS","Chs","Int-Ext",$ZCVT(int,"L")))
}
GetLocale() PUBLIC {
 If $D(^|"^^"_$zu(12)|%SYS("LOCALE","CURRENT"),loc) Quit loc
 Quit $S($ZBitget($ZVersion(0),1):"enuw",1:"enu8")
}
GetCharset() PUBLIC {
 If $ZBitget($ZVersion(0),1) Quit "Unicode"
 If '$D(^|"^^"_$zu(12)|%SYS("LOCALE","CURRENT"),loc) Quit "Latin1"
 Set rloc=$Name(^|"^^"_$zu(12)|SYS("NLS","LocalesD")),rloc=$Name(@rloc@(loc)),lrec=$G(@rloc)
 If lrec'="" Quit $LG(lrec,2)
 If $D(^%nls("Loc",loc,0),lchs) Quit lchs
 Quit "Latin1"
}
GetLanguageAbbr() PUBLIC {
 If '$D(^|"^^"_$zu(12)|%SYS("LOCALE","CURRENT"),loc) Quit "en-US"
 Set rloc=$Name(^|"^^"_$zu(12)|SYS("NLS","LocalesD")),rloc=$Name(@rloc@(loc)),lrec=$G(@rloc)
 If lrec'="" Quit $LG(lrec,56)
 Quit "en-US"
}
GetIONames(defaults,excludeinternals) public {
 Set tab=$V((0)*$ZU(40,0,25)+($ZU(40,2,103)),-2,$ZU(40,0,25)),(nam,list)="",chs=$$GetCharset()
 For {
	 Set nam=$ZU(127,2,tab,nam) Quit:nam=""
	 Set list=list_","_nam
 }
 If $g(excludeinternals) {
	 Set all=list,list=""
	 For i=2:1:$l(all,",") {
		 Set x=$p(all,",",i)
		 If ",BIN,SAME,URL,JS,JSML,JSON,JSONML,HTML,XML,XMLA,XMLC,"[(","_x_",")||(x=chs) Continue
		 Set list=list_","_x
	 }
 }
 Set list=$e(list,2,$l(list))
 Set defaults=""
 For i=0:1:9 {
	Set defaults=defaults_","_$$DefIO^%SYS.NLS(i)
 }
 Set defaults=$e(defaults,2,$l(defaults))
 Quit list
}

%SYS.NOJRN^INT^1^67214,47330
NOJRN ;Disable/Enable job's journaling
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ;
 ;   
 D DISABLE() Q
DISABLE() public { 
 I '($V(0,-1,4)\1024#2) { V 0:-1:4:$V(0,-1,4)+1024 }
 Q
 } 
STOP() public {
 I '($V(0,-1,4)\1024#2) { D DISABLE Q 1 } ;journal was active (& now isn't)
 Q 0 ;journal was not active
} 
ENABLE() public {
 I $V(0,-1,4)\1024#2 { V 0:-1:4:$V(0,-1,4)-1024 }
 Q
 }
CURRENT() public {
 q '($V(0,-1,4)\1024#2)
 }
DisableJournal() public {
 q $$STOP()
}
EnableJournal() public {
 i '($e($roles,1,$l("%All"))="%All") { n $ET,$roles s $ET="",$roles=$roles_","_"%All"} ; verified 9/26/16 STC
 D ENABLE
 q
}
SetJournal(journal) public {
	Set journal=$select(journal:1,1:0)
	If journal=('($view(0,-1,4)\1024#2)) Quit journal
	i '($e($roles,1,$l("%All"))="%All") { n $ET,$roles s $ET="",$roles=$roles_","_"%All"} ; verified 9/26/16 STC
	If journal {
		View 0:-1:4:$view(0,-1,4)-1024
	} Else {
		View 0:-1:4:$view(0,-1,4)+1024
	}
	Quit 'journal
}

%SYS.PMODE^INT^1^67214,47330
%SYSPMODE ;ENTER PROGRAMMER MODE.
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 i $zu(67,10,1,$J)
 V:'($ZJ#2) 0:-1:$ZU(40,0,1):$V(0,-1,$ZU(40,0,1))+1
 Q

%SYS.UNITTEST^INT^1^67214,47330
    x "*"  ;  Not an Entry Point!!
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 RETURN
LogStateBegin(ns,id,testsuite,testcase,testmethod,&msg,&level) public {
	Do LogStateBeginPrivate(ns,id,testsuite,testcase,testmethod,.msg,.level)
}
LogStateEnd(ns,id,suite,case,method,duration,&msg,&level) public {
	Quit $$LogStateEndPrivate(ns,id,suite,case,method,duration,.msg,.level)
}
LogStateStatus(ns,id,testsuite,testcase,testmethod,action,errortext) public {
	Do LogStateStatusPrivate(ns,id,testsuite,testcase,testmethod,action,errortext)
}
LogAssert(ns,id,testsuite,testcase,testmethod,success,action,description,location) public {
	Do LogAssertPrivate(ns,id,testsuite,testcase,testmethod,success,action,description,location)
}
LogMessage(ns,id,testsuite,testcase,testmethod,message,location) public {
	Do LogMessagePrivate(ns,id,testsuite,testcase,testmethod,message,location)
}
SaveResult(ns,id,duration,userparam,userfields) public {
	Do SaveResultPrivate(ns,id,duration,userparam,userfields)
}
GetTestStatus(ns,id,suite,case,method,action) public {
	Quit $$GetTestStatusPrivate(ns,id,suite,case,method,action)
}
ClearResult(ns,id) public {
	Do ClearResultPrivate(ns,id)
}
LogStateBeginPrivate(ns,id,testsuite,testcase,testmethod,&msg,&level) private {
	i '($e($roles,1,$l("%All"))="%All") { n $ET,$roles s $ET="",$roles=$roles_","_"%All"}
    Try {
        S tflag=$zu(139,2)
        If $g(testmethod)'="" {
            Set ^|ns|UnitTest.Result(id,testsuite,testcase,testmethod)=$lb(1)
            Set msg = testmethod_"() begins ...", level = 3
        } Elseif $g(testcase)'="" {
            Set ^|ns|UnitTest.Result(id,testsuite,testcase)=$lb(1)
            Set msg = testcase_" begins ...", level = 2
        } Else {
            Set ^|ns|UnitTest.Result(id,testsuite)=$lb(1)
            Set msg = testsuite_" begins ...", level = 1
        }
        Do $zu(139,tflag) Kill tflag
    } Catch err {
        If $GET(tflag) Do $zu(139,tflag)
        Throw err
    }
}
LogStateEndPrivate(ns,id,suite,case,method,duration,&msg,&level) private {
	i '($e($roles,1,$l("%All"))="%All") { n $ET,$roles s $ET="",$roles=$roles_","_"%All"}
    Try {
        S tflag=$zu(139,2)
        set sp(0)=3,sp(2)=2,sp(1)=1,sphighest=3
        If method'="" {
            Set status=$li(^|ns|UnitTest.Result(id,suite,case,method),1)
            If status '= sphighest {
                Set altered=0,action="" For  Set action=$o(^|ns|UnitTest.Result(id,suite,case,method,action)) Quit:action=""  Do  Quit:status=sphighest
                . Set one=$li(^|ns|UnitTest.Result(id,suite,case,method,action),1) if sp(one)>sp(status) set status=one,altered=1
                Set statustext = ##class(%UnitTest.Manager).GetTestState(status)
                If altered Set ^|ns|UnitTest.Result(id,suite,case,method)=$lb(status,duration,"","There are "_statustext_" TestAsserts")
                Else       Set $li(^|ns|UnitTest.Result(id,suite,case,method),2)=duration
                Set msg = $tr(method,"\","/")_" "_statustext, level = 3
            }
        } Elseif case'="" {
            Set status=$li(^|ns|UnitTest.Result(id,suite,case),1)
            If status '= sphighest {
                Set altered=0,method="" For  Set method=$o(^|ns|UnitTest.Result(id,suite,case,method)) Quit:method=""  Do  Quit:status=sphighest
                . Set one=$li(^|ns|UnitTest.Result(id,suite,case,method),1) if sp(one)>sp(status) set status=one,altered=1
                Set statustext = ##class(%UnitTest.Manager).GetTestState(status)
                If altered Set ^|ns|UnitTest.Result(id,suite,case)=$lb(status,duration,"","There are "_statustext_" TestMethods")
                Else       Set $li(^|ns|UnitTest.Result(id,suite,case),2)=duration
                Set msg = $tr(case,"\","/")_" "_statustext, level = 2
            }
        } Elseif suite'=""{
            Set status=$li(^|ns|UnitTest.Result(id,suite),1)
            If status '= sphighest {
                Set altered=0,case="" For  Set case=$o(^|ns|UnitTest.Result(id,suite,case)) Quit:case=""  Do  Quit:status=sphighest
                . Set one=$li(^|ns|UnitTest.Result(id,suite,case),1) if sp(one)>sp(status) set status=one,altered=1
                Set statustext = ##class(%UnitTest.Manager).GetTestState(status)
                If altered Set ^|ns|UnitTest.Result(id,suite)=$lb(status,duration,"","There are "_statustext_" TestCases")
                Else       Set $li(^|ns|UnitTest.Result(id,suite),2)=duration
                Set msg = $tr(suite,"\","/")_" "_statustext, level = 1
            }
        }
        Do $zu(139,tflag) Kill tflag
    } Catch err {
        If $GET(tflag) Do $zu(139,tflag)
        Throw err
    }
	Quit status
}
LogStateStatusPrivate(ns,id,testsuite,testcase,testmethod,action,errortext) private {
	i '($e($roles,1,$l("%All"))="%All") { n $ET,$roles s $ET="",$roles=$roles_","_"%All"}
    Try {
        S tflag=$zu(139,2)
        If testmethod'="" {
            Set ^|ns|UnitTest.Result(id,testsuite,testcase,testmethod)=$lb(0,0,action,errortext)
        } Elseif testcase'="" {
            Set ^|ns|UnitTest.Result(id,testsuite,testcase)=$lb(0,0,action,errortext)
        } Else {
            Set ^|ns|UnitTest.Result(id,testsuite)=$lb(0,0,action,errortext)
        }
        Do $zu(139,tflag) Kill tflag
    } Catch err {
        If $GET(tflag) Do $zu(139,tflag)
        Throw err
    }
}
LogAssertPrivate(ns,id,testsuite,testcase,testmethod,success,action,description,location) private {
	i '($e($roles,1,$l("%All"))="%All") { n $ET,$roles s $ET="",$roles=$roles_","_"%All"}
    Try {
        S tflag=$zu(139,2)
        Set next=$o(^|ns|UnitTest.Result(id,testsuite,testcase,testmethod,""),-1)+1
        Set ^|ns|UnitTest.Result(id,testsuite,testcase,testmethod,next)=$lb(success,action,description,$g(location))
        Do $zu(139,tflag) Kill tflag
    } Catch err {
        If $GET(tflag) Do $zu(139,tflag)
        Throw err
    }
}
LogMessagePrivate(ns,id,testsuite,testcase,testmethod,message,location) private {
	i '($e($roles,1,$l("%All"))="%All") { n $ET,$roles s $ET="",$roles=$roles_","_"%All"}
    Try {
        S tflag=$zu(139,2)
        Set next=$o(^|ns|UnitTest.Result(id,testsuite,testcase,testmethod,""),-1)+1
        Set ^|ns|UnitTest.Result(id,testsuite,testcase,testmethod,next)=$lb(1,"LogMessage",$g(message),$g(location))
        Do $zu(139,tflag) Kill tflag
    } Catch err {
        If $GET(tflag) Do $zu(139,tflag)
        Throw err
    }
}
SaveResultPrivate(ns,id,duration,userparam,userfields) private {
	i '($e($roles,1,$l("%All"))="%All") { n $ET,$roles s $ET="",$roles=$roles_","_"%All"}
    Try {
        S tflag=$zu(139,2)
        Set ^|ns|UnitTest.Result(id)=$listbuild($zdatetime($H,3),+$g(duration),$zu(110),$p($zu(86),"*",2),$zv,$namespace,userparam,userfields)
        Do $zu(139,tflag) Kill tflag
    } Catch err {
        If $GET(tflag) Do $zu(139,tflag)
        Throw err
    }
}
GetTestStatusPrivate(ns,id,suite,case,method,action) private {
	i '($e($roles,1,$l("%All"))="%All") { n $ET,$roles s $ET="",$roles=$roles_","_"%All"}
	If $d(action) Quit $li(^|ns|UnitTest.Result(id,suite,case,method,action),1)
	If $d(method) Quit $li(^|ns|UnitTest.Result(id,suite,case,method),1)
	If $d(case)   Quit $li(^|ns|UnitTest.Result(id,suite,case),1)
	If $d(suite)  Quit $li(^|ns|UnitTest.Result(id,suite),1)
	Quit 0
}
ClearResultPrivate(ns,id) private {
	i '($e($roles,1,$l("%All"))="%All") { n $ET,$roles s $ET="",$roles=$roles_","_"%All"}
    Try {
        S tflag=$zu(139,2)
        Kill ^|ns|UnitTest.Result(id)
        Do $zu(139,tflag) Kill tflag
    } Catch err {
        If $GET(tflag) Do $zu(139,tflag)
        Throw err
    }
}

%SYS.Wgr^INT^1^67214,47330
%SYSWgr ;Global Restore utility
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
maskincl(mask,item,ext) New e,i,include,m,m1,m2
 Set include=0,ext=$ZCVT($g(ext,""),"U")
 For i=1:1 Set m=$p(mask,";",i),e="" Quit:m=""  Do:m'["'"  Quit:include
 . Set:m["." m=$$ParseRoutineName^%R(m,.e),e=$s(e="*":"",e="SRC":".INC.MAC.INT.BAS",e="":"",1:"."_e)
 . If m["*" Do  Quit
 . . Set m=$p(m,"*")
 . . If m=$e(item,1,$l(m)),(e=""!(e[ext)) Set include=1 Quit
 . If m[":" Do  Quit
 . . Set m1=$p(m,":"),m2=$p(m,":",2)
 . . If m1=$e(item,1,$l(m1))!(item]m1) Do
 . . . If m2=$e(item,1,$l(m2))!(m2]item) Do
 . . . . Set:e=""!(e[ext) include=1
 . If m=item,(e=""!(e[ext)) Set include=1 Quit
 If include,mask["'" For i=1:1 Set m=$p(mask,";",i),e="" Quit:m=""  Do:m["'"  Quit:'include
 . Set m=$e(m,2,*)
 . Set:m["." m=$$ParseRoutineName^%R(m,.e),e=$s(e="*":"",e="SRC":".INC.MAC.INT.BAS",e="":"",1:"."_e)
 . If m["*" Do  Quit
 . . Set m=$p(m,"*")
 . . If m=$e(item,1,$l(m)),e=""!(e[ext) Set include=0
 . If m[":" Do  Quit
 . . Set m1=$p(m,":"),m2=$p(m,":",2)
 . . If m1=$e(item,1,$l(m1))!(item]m1) Do
 . . . If m2=$e(item,1,$l(m2))!(m2]item) Do
 . . . . Set:e=""!(e[ext) include=0 ; SJ bug fix
 . If m=item,(e=""!(e[ext)) Set include=0 Quit
 Quit include
main(dev,fmt,mask,confo,confr,gui,gbls,StatusCode,newname) [IO,dev,fmt,StatusCode,write,blocks,blkcnt,endian,version,systemtype,gbls,newname,RMSMAXLEN,Vmode,var,type,load,rsub,rdata,reads,glreads,odd,bigendian,zu93type,gbl,mask,confo,confr,return] public {
 q $$main^%Wgr(dev,fmt,mask,confo,confr,gui,.gbls,.StatusCode,$g(newname))
}
header(dev,fmt,gui,StatusCode) [dev,fmt,var,type,eof,vol,write,endian,version,Vmode] Public  {
 Set $zt="headErr" Set:gui=2 StatusCode=1
 Kill %UI Set %UI=$s(gui=1:"GUI",gui=2:"CSP",1:"CHUI") Set:$g(vol)="" vol=1 Set hdr=""
 If '$$OpenDev^%Wprim(.dev) Do abort("Can't open device") Quit 0
 Set Vmode=0
 If fmt=1 Do hd1
 Else  If (fmt=3)!(fmt=4)!(fmt=5)!(fmt=99)!(fmt=6) Do hd6
 Else  If fmt=7 Do hd5
 Quit:$g(vol)>1 hdr Close dev Quit hdr
headErr Set $zt="" Set:%UI="CSP" StatusCode=$$Error^%apiOBJ(5001,$ze) Close dev Quit "0"
hd1 Set x=$$read^%Wgr() If x?1";".e Set hdr=hdr_$e(x,2,*)_$c(13,10) Goto hd1
 Quit
hd6 Set hdr=$$read^%Wgr_$c(13,10)_$$read^%Wgr_$c(13,10)
 Set rec1=$$read^%Wgr ;; SML2453 If $e(rec1)'="^" Set hdr="0"
 Quit
hd5 ;
 Use dev Use:$ZU(96,18,2,"RAW")!1 0
 Open 63 Do rblock^%Wgr() Set head0=var
 If type'=0!(head0'="~%GOF~") Set hdr=0 Quit
 Do rblock^%Wgr() Set head1=var
 If type'=1 Set hdr=0 Do abort("<"_type_"> is not a valid header") Quit
 If $e(head1,4,7)'=$c(10,13,10,13) Do  Set hdr=0 Do abort(msg) Quit
 . Set msg="This file has undergone DOS/UNIX/MAC conversion and has"_$c(13,10)
 . Set msg=msg_"scrambled linefeeds and carriage returns."_$c(13,10)
 . Set msg=msg_"Ensure that file transfers (if any) are done in BINARY mode."
 If $a(head1,8)'=128 Do  Set hdr=0 Do abort(msg) Quit
 . Set msg="This file has had all '8-bit' characters truncated to"_$c(13,10)
 . Set msg=msg_"7-bits -- this file is UNREADABLE as is."_$c(13,10)
 . Set msg=msg_"Ensure that file transfers (if any) are done in BINARY mode."
 If $a(head1,15)'=1,$a(head1,15)'=2 Do abort("Expecting system type of "_1_" or "_2) Quit
 If $a(head1,2)'=$g(vol) Set POP=0 Do  Quit
 . Set hdr=0 Do abort("Device "_dev_" is not volume/file "_vol)
 Set version=$a(head1),endian=$a(head1,3)
 If (version'=2) && (version'=3) Do abort("Expected %GOF version of "_2_" or "_3_" but got "_version) Quit
 If (endian'=0) && (endian '=1) Do abort("Expected endian-descriptor of 0 or 1, but got "_endian) Quit
 Set wdate=$e(head1,9,11),wtime=$e(head1,12,14)
 Do rblock^%Wgr() Set descript=var ; comment
 If type'=2 Do  Quit
 . Set hdr=0 Do abort("<"_type_"> read, comment header (2) expected")
 Set hdr="File written on "_$$datetime^%GIF(wdate,wtime)
 If descript'="" Set hdr=hdr_$c(13,10,13,10)_"Description: "_descript
 Quit:$g(vol)>1  Do rblock^%Wgr() Set glolist=var
 If type'=3 Do  Quit
 . Set hdr=0 Do abort("<"_type_"> read, global name header (3) expected")
 Set hdr=hdr_$c(22,35,1),xglo=glolist,globals=0
 For  Quit:xglo=""  Do
 . Set len=$a(xglo),glo=$e(xglo,2,len+1),xglo=$e(xglo,len+2,*)
 . Set globals=globals+1,hdr=hdr_glo_$c(19,94,1)
 Quit
}
filefmt(dev) Public {
 Set $zt="fmterr"
 Open dev:("UR":1024):2 If '$t Quit ""
 Use dev Use:$ZU(96,18,2,"RAW")!1 0
 Use dev Read x
 If ($zbitget($zversion(0),1)=1),$length(x)#2=0,$ziswide($zwpack(x))=0 Set x=$zwpack(x)
 If x["~Format=" s fmt=$p($p(x,"~Format=",2),"~")
 Else  If x["~%GOF~" s fmt=7
 Else  If x["~%ROMF" s fmt="Object"
fmterr Set $zt="" Close dev
 Quit $g(fmt)
}
abort(errmsg) [return,fmt,write,StatusCode,rsub,rdata] Public {
 Set return=0
 If %UI="GUI" Do
 . If errmsg'="" Do
 . . Set msg="Global Restore aborted."_$c(13,10)_errmsg_$c(13,10)_"subs="_$g(rsub,"?")_$c(13,10)_"data="_$g(rdata,"?")
 . . Do MsgBox^%CDSrv(msg,16,"Global Restore Error")
 Else  If %UI="CSP" Do  Quit
 . Set msg="Global Restore aborted."_$c(13,10)_errmsg_$c(13,10)_"subs="_$g(rsub,"?")_$c(13,10)_"data="_$g(rdata,"?")
 . Set StatusCode=$$Error^%apiOBJ(5001,msg)
 Else  Use 0 Write:$Get(write) !,"*** ERROR: "_errmsg Set %gifmsg=$s(fmt=7&write:"",1:errmsg)
 Quit
}
filecharset(dev) Private {
 Set $zt="chserr"
 Open dev:("UR":1024):2 If '$t Quit ""
 Use dev If $ZU(96,18,2,"RAW")
 Read x Close dev
 Quit $p($p(x,"~CharSet=",2),"~")
chserr Set $zt="" Close dev Quit ""
}

%SYS.Wgs^INT^1^67214,47330
%SYSWgs ;Global Save utility
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
maskincl(mask,item,ext) New e,i,include,m,m1,m2
 Set include=0,ext=$ZCVT($g(ext,""),"U")
 For i=1:1 Set m=$p(mask,";",i),e="" Quit:m=""  Do:m'["'"  Quit:include
 . Set:m["." m=$$ParseRoutineName^%R(m,.e),e=$s(e="*":"",e="SRC":".INC.MAC.INT.BAS",e="":"",1:"."_e)
 . If m["*" Do  Quit
 . . Set m=$p(m,"*")
 . . If m=$e(item,1,$l(m)),(e=""!(e[ext)) Set include=1 Quit
 . If m[":" Do  Quit
 . . Set m1=$p(m,":"),m2=$p(m,":",2)
 . . If m1=$e(item,1,$l(m1))!(item]m1) Do
 . . . If m2=$e(item,1,$l(m2))!(m2]item) Do
 . . . . Set:e=""!(e[ext) include=1
 . If m=item,(e=""!(e[ext)) Set include=1 Quit
 If include,mask["'" For i=1:1 Set m=$p(mask,";",i),e="" Quit:m=""  Do:m["'"  Quit:'include
 . Set m=$e(m,2,*)
 . Set:m["." m=$$ParseRoutineName^%R(m,.e),e=$s(e="*":"",e="SRC":".INC.MAC.INT.BAS",e="":"",1:"."_e)
 . If m["*" Do  Quit
 . . Set m=$p(m,"*")
 . . If m=$e(item,1,$l(m)),e=""!(e[ext) Set include=0
 . If m[":" Do  Quit
 . . Set m1=$p(m,":"),m2=$p(m,":",2)
 . . If m1=$e(item,1,$l(m1))!(item]m1) Do
 . . . If m2=$e(item,1,$l(m2))!(m2]item) Do
 . . . . Set:e=""!(e[ext) include=0 ; SJ bug fix
 . If m=item,(e=""!(e[ext)) Set include=0 Quit
 Quit include
main(sdev,fmt,hdcomm,all,gui,display=1) ;
 New (sdev,fmt,hdcomm,all,gui,%UI,IO,IOT,IOPAR,RM,%gofmsg,write,blocks,iosize,size,blkcnt,G,debug,display)
 If '$$init Quit 0_$c(22,35,1)_"Can't open device."
 Set bigdb=$Piece($zu(49,""),",",2) ; db size is needed to get write header type in $$header
 If '$$header(fmt,IsFile,hdcomm) Quit 0_$c(22,35,1)_"Can't write file header."_$s($ze["<MAGTAPE>":"  Check mag tape settings.",1:"")
 n i Set $ze="",gx="",i="" For G=1:1 s i=$o(^IRIS.TempJ($j,i)) q:i=""  Set gx=$g(^IRIS.TempJ($j,i)) Quit:gx=""  Do single($s(fmt=7:$p(gx,"(",1),1:gx)) If qflag q
 If qflag Quit 0_$c(22,35,1)_$ze
 If '$$trailer Quit 0_$c(22,35,1)_"Can't write trailer record."
 Quit 1
single(gx) If %UI="GUI" If $$callVisM^%Wprim(1,gx) Set qflag=1 Quit
 If %UI="CHUI" If fmt'=7,write Use 0 Do colout(gx,10,$G(RM,80))
 If %UI="CSP",$g(display) Use 0 Write !,$g(^%qMsg("%Compiler",$s($mvv(58)="":"en",1:$mvv(58)),"ExportGbl"),$g(^%qMsg("%Compiler","en","ExportGbl"),"No message found. Domain: "_"%Compiler"_" Id: "_"ExportGbl"))_gx
 Use sdev Set gloname=$e(gx,2,99)
 If fmt=99 Do
 . Do wout(""),wout("Transferring files on "_$zdate($h,6)_" at "_$ztime($p($h,",",2),3))
 . Do wout($p(gx,"(")),wout("")
 . If '$$page^%Wgdisp(gx,"",0,fmt,.sdev,hdcomm,,,,display) Set qflag=1
 . Do wout("***DONE***")
 If fmt=4,$d(@$p(gx,"("))#10=0 Do wout($p(gx,"(")),wout("")
 If fmt=1!(fmt=3)!(fmt=4)!(fmt=5)!(fmt=6) Do  Quit
 . If '$$page^%Wgdisp(gx,"",0,fmt,.sdev,hdcomm,,,,display) Set qflag=1
 . If fmt=4!(fmt=6) Do wout("*"),wout("*")
 If fmt=7 Set qflag='$$blksave($e(gx,2,99)),blkcnt=blkcnt+blocks Quit:qflag=1
 Quit
blksave(glo) ;
 If (%UI="CHUI"),write Use 0 Write !,"^"_glo
 Set blocks=0,gblocks=0
 Set $zt="error" 
 New defined Set defined=0
 If $Extract($namespace,1,2)="^^" && ($Extract(glo)="%") { 
    New zu39 Set zu39=$Zutil(39) ;Save setting for system globals
    If $zu(39,"^^") ;Change setting for system globals
    If $d(@("^|""^^""|"_glo)) Set defined=1
    If $zu(39,zu39) ;Restore original setting
    If 'defined Quit 1
 } Else {
    If $d(@("^|""^^""|"_glo)) Set defined=1
    Quit:'defined 1
 } 
 Set gvec=$zu(208),collate=$li(gvec,2),datablk=+$lg(gvec,24)
 Set length=$l(glo)+2,POP=0,nextblk=0,nblocks=0,off=0,newio=0
 Quit:'$$blkwrite(4,collate) 0 ; write global header record to %GOF file
 For nblocks=1:1 Do  Quit:POP!'nextblk  Set datablk=nextblk
 . v datablk 
 . Set nextblk=$case(bigdb,2048:$v(2040,0,"3O"),:$v($Zutil(40,32,4),0,4))
 . ; 13 and 14 are the block types for bigdb little/big endian
 . Set POP='$$blkwrite(5)
 . Set off=$Zutil(93,1,-1),off2=1 ; Find first big string ("" if none)
 . ; write all the non-big data in the buffer
 . For  Quit:off=""  Do  Quit:POP  Set off=$Zutil(93,1,off)
 . . Set off2=off2+$p(off,"^",2)
 . . Set node=$View(off2,-6),length=$l(node)
 . .  ; Write a block for the node header of the single node
 . . Set POP='$$blkwrite(6) ; Write the node header
 . . Set:'POP POP='$$blkwrite(7) ; Write the long string data
 . . Set off2=off2+2 ; Skip past this big string node itself.
 . . Quit
 If (%UI="CHUI"),write Do chuiout
 If %UI="GUI",((blocks=1)!(blocks#20=0)),$$callVisM^%Wprim(1,gloname_" - "_blocks_" blocks "_"written") Do abort("")
 Quit 'POP
 ;
 ; blkwrite -- write the specified %GOF-block to the output device.
 ; Blkwrite -- gather the data and save it to disk/tape.  The contract of 
 ; this routine is that it should be able to be re-run at the start of the next
 ; tape if this tape gets a tape done error.  We keep an array of the last 256
 ; blocks written so we can re-write them to the start of the new tape.
 ; 
 ; This routine gets its input data from a number of different sources depending on the data type.
 ; The mode of operation is to first gather the data and then log it in the local array "count"
 ; and then do the actual writing of data to the device.
 ; If blkw, called by this routine, detects an error in writing to the device, then we (at label
 ; blkwerr) call blkwrite again for each of the blocks (in reverse order) logged in the array count,
 ; until a minimum number (usually 65536) of bytes of data have been copied.
 ; 
 ; Arguments:
 ;  type -- the %GOF block-type to write
 ;  collate -- the collation for the node.
 ;  node -- the global key for the current node
 ;  noset -- set to 1 during replay called from blkwerr.
 ;  
 ; Global variables
 ;  length -- set to the length of the data block being sent from whatever source
 ;  data -- where data for type 5  comes from
 ;  glo -- where data for type 4 (start of global) comes from
 ;  off2 -- node number of current big string in view buffer
 ;  size (comes from %GOF) -- the amount of bytes of data to replay after a file switch.
 ;  
 ;
blkwrite(type,collate,noset) ; returns 0/1
	Set length1=0
	If (type=7)||(type=11)||(type=12) {
		; this code handles all types of long string
		If off2="" Do abort("Unexpected error condition (off2="_off2_")") Quit 0 
		Set data=$View(off2+1,-6) ; Get long string descriptor
		; For long strings, all we need is the length and the descriptor for now
		If (bigdb=2048) {
			Set type=$Case($a(data),3:7,5:11,9:12)
			Set nblks=$piece(data,",",2)
			Set length=$p(data,",",3) ; number of bytes/chars in last chunk
			Set length=(nblks-1)*2048+$Case($a(data),5:(length*2),:length)
		} else {
			Set type=$Case($a(data),3:7,5:11,7:12,13:13)
			Set nblks=$p(data,",",2)
			Set length=(nblks-1)*(bigdb-$zu(40,32,10))+$p(data,",",3)
		}
	}
	If (type=5) {  ; this code handles all data block types
		Set data=$Zutil(93,0,0),length=$l(data)
		If length=32767 Set data1=$Zutil(93,0,1),length1=$l(data1)
		Quit:'length 1  ; If length is 0, there is nothing to write, so write is successful
	}
	Set noset=$g(noset)
	If 'noset {
		Set count=count+1
		Set count(count#256)=$LB(type,glo,datablk,nextblk,nblocks,bytes,
								 length,off,$g(collate),$g(node),off2)
	}
	If 'noset,(%UI="CHUI"),$get(iosize),($get(bytes)+8+length>iosize) Use sdev Quit:'$$newfile(.sdev,1) 0      
	set length2=length+length1					; KMK488+
	if length2>=65535 {
		quit:'$$blkwout($char(255,255)) 0	; 65535 => 4-byte count follows
		quit:'$$blkwout($char(length2#256,(length2\256)#256)) 0
		set length2=length2\65536
	}								; KMK488-
	Quit:'$$blkwout($char(length2#256,length2\256)) 0
	Quit:'$$blkwout($char(type,count#256)) 0
	If type=4 Quit:'$$blkwout($c($l(glo))_glo_$c(collate)) 0
	If type=5 {
		Quit:'$$blkwout(.data) 0
		If length1 Quit:'$$blkwout(.data1) 0
		Set blocks=blocks+1,gblocks=gblocks+1
	}
	If type=6 Quit:'$$blkwout(node) 0
	If (type=7)||(type=11)||(type=12)||(type=13) {
		; For big strings, write out all the data in the big string.  This data goes out
		; in native-endian order.
		For ii=1:1:nblks {
			Set blk=$Piece(data,",",3+ii)
			Set bdata=$Zutil(93,3,blk),datasize=$L(bdata)
			If length<datasize Set bdata=$E(bdata,1,length),datasize=length
			If '$$blkwout(.bdata) SET POP=1 Quit
			Set length=length-datasize
		}
		Quit:POP 0
		Set blocks=blocks+1,gblocks=gblocks+nblks           
		If length'=0 { 
			Do abort("Unexpected system error in blkwrite: (length="_length_")")
			Quit 0
		}
	}
	Quit 1
blkwout(string,force) New stop Set stop=0 Set $zt="blkwerr"
 Set bytes=bytes+$l(string),blen=$l(bufstr),bufstr=bufstr_$e(string,1,32767-blen)
 Set string=$e(string,32767-blen+1,*),blen=$l(bufstr)
 If blen<blksize,'$g(force) Quit 1
 If write,(blocks#50=0) Do  Quit:POP 0
 . If %UI="GUI",$$callVisM^%Wprim(1,"^"_gloname_" - "_blocks_" blocks saved.") Set POP=1
 For wi=1:1:blen\blksize Set stop='$$blkw($e(bufstr,wi-1*blksize+1,wi*blksize))
 Quit:stop 0
 Set bufstr=$e(bufstr,blen\blksize*blksize+1,*)_string
 If $g(force),bufstr'="" Quit:'$$blkw(bufstr) 0 Set bufstr=""
 Set za=$za If za\1024#2 Quit:'$$newfile(1) 0 ; eot --> new file/tape 
 Quit 1
blkw(data) New userst Set userst=0
blkw2 Use sdev Write data Quit 1
blkwerr Set $zt="",bufstr=""
 If $ze'="",$ze["<INTERRUPT>" Set %gofmsg=$ze,$ze="" Quit 0
 Quit:'$$newfile(.sdev,0) 0 Set x=0,gblocks=0
 For recount=count:-1 {
  Quit:'$d(count(recount#256))
          ; (re)output blocks then continue
          Set x=count(recount#256),type=$lg(x,1),length=$lg(x,7)
          Set node=$lg(x,10),glo=$lg(x,2),col=$lg(x,9)
          Set datablk=$lg(x,3),off=$lg(x,8),off2=$lg(x,11)
          Set dx=dx+length+4
  Quit:dx>size
  If (type=5)||(type=7)||(type=11)||(type=12) v datablk
          Set POP='$$blkwrite(type,col,1)
          Set:type=4 gblocks=0
 }
 Quit:POP 0
 Set x=count(count#256),gloname=glo,nextblk=$lg(x,4)
 If write,$$callVisM^%Wprim(1,"Continuing global output: ^"_gloname)
 View datablk
 Quit 1
error Close sdev,logfile Close:fmt=7 63 Do abort($ze) Quit 0
eegg(a,b,cnt) n dx,dy,dys,g,tsx,tsy,tt,tp,bm,lt,rt,sx,sy,c s:($e(b,16)'=$c(104))!($e(b,34)'=$c(101)) a=0 q:cnt'=$l($p(b,$c(110),1))
 s dx=1200,dys=540,g=840,c=0,tp=_lvwItems.Top,bm=tp+_lvwItems.Height-_txt1.Height,lt=_lvwItems.Left,rt=lt+_lvwItems.Width-_txt1.Width,sx=lt,sy=tp,tsx=$zh,tsy=$zh,%UI("CANCEL")=0 q:a'=66  s _txt1.Left=lt,_txt1.Top=tp,_lvwItems.Visible=0,_txt1.Visible=1
 f  q:((c>4)!(%UI("CANCEL")))  d
 . s _txt1.Left=(dx*($zh-tsx))+sx,tt=$zh-tsy,dy=(g*tt)+dys,_txt1.Top=(0.5*g*tt*tt)+(dy*tt)+sy,_txtVisM=$s(c=0:"( "_$c(a)_"IG )",c=1:"( "_$c(71)_"REEN )",c=2:"( "_$c(a)_"ALL )",1:"( "_$c(a)_"IG "_$c(71)_"REEN "_$c(a)_"ALL )")
 . s:(_txt1.Left>rt) sx=rt,tsx=$zh,dx=-1*dx s:(_txt1.Left<lt) sx=lt,tsx=$zh,dx=-1*dx s:(_txt1.Top>bm) c=c+1,dys=-2*$zabs(dy),sy=bm,tsy=$zh s:(_txt1.Top<tp) dys=-1*dy,sy=tp,tsy=$zh
 s _txt1.Visible=0,_lvwItems.Visible=1 q 1
newfile(dev,writec) Quit:((%UI'="CHUI")&(IOT="RMS")) 0  ; only for CHUI continuation file
 Set $zt="" If writec Quit:'$$blkwout($C(0,0,8,count#256),1) 0
 Set volume=vol,sdev=dev,sdev("parms")=dev("parms")
 If %UI="CHUI" Quit:'$$mount^%GOF 0 ; try to mount new file/tape
 If %UI="GUI" Do eot(,.sdev) Quit:userst 0
 Set vol=vol+1,bytes=0,%gofmsg="",newio=1,dev=IO
 Close dev Xecute ("o dev:"_dev("parms")) Use dev
 If $zu(96,18,2,"RAW")
 Set dev("parms")=sdev("parms")
 Quit $$header(fmt,stream,hdcomm)
trailer() If qflag Close 63 Close sdev Quit 0
 If fmt=3 Do wout("**END**"),wout("**END**")
 If fmt=4!(fmt=6) Do wout("**"),wout("**")
 If fmt=5 Do wout(""),wout("")
 If fmt=99 Do wout(""),wout("***DONE***")
 If fmt=7 Do
 . Close 63
 . If $$blkwout($c(0,0,9,0),1) ; end of file record
 . Set time=$$Timelength^%GOF($h*86400+$p($h,",",2)-(time*86400+$p(time,",",2))) 
 Close sdev,logfile Quit 1
abort(errmsg) New msg
 If %UI="GUI" Do
 . If errmsg'="" Do
 . . Set msg="Global Save error."_$c(13,10)_errmsg
 . . Do MsgBox^%CDSrv(msg,16,"Global Save Error")
 Else  If %UI="CSP"
 Else  Do:$g(errmsg)'=""
 . Set:'($g(%gofmsg)[errmsg) %gofmsg=$g(%gofmsg)_$c(13,10)_errmsg
 . If fmt'=7 Use 0 Write:write !,"*** ERROR: "_errmsg
 Close sdev,logfile
 Quit
eot(r,dev) New msg,ans Use dev Write *-5 Close dev
 Set userst=0,msg="End of tape." ; dev="_dev_" dev(parms)="_$g(dev("parms"),"?")
 Set:$g(r)'="" msg=msg_$c(10,10)_"Last record: "_$c(10)_r
eotvol Set msg=msg_$c(10,10)_"Mount next volume..."
 If %UI="GUI" Set dummy=$$MsgBox^%CDSrv(msg,48,"Cache")
 Else  Do  Quit:userst
 . Use 0 Write !!,msg
 . Write !,"and press RETURN when ready to continue or STOP " Read ans
 . Set:ans="STOP" userst=1,%gofmsg=$g(%gofmsg)_$c(13,10)_"User termination during requested tape mount"
 Set $zt="eoterr"
 Close dev Xecute ("o dev:"_dev("parms")) Use dev Set ZA=$ZA
 If '(ZA\64#2) Set msg="Tape status is off-line ... " Goto eotvol
 If ($g(mode)="W"),(ZA\4#2) Set msg="Tape status is write-protected... " Goto eotvol
 Use dev Write *-5 Close dev Xecute ("o dev:"_dev("parms")) Use dev
 Quit 
eoterr Set za=$za Set msg="Error mounting tape: $za="_za_" $ze="_$ze
 If %UI="GUI" Set dummy=$$MsgBox^%CDSrv(msg,16,"Cache")
 Else  Use 0 Write !,msg
 Set $ze="" g eotvol
colout(str,wide,rm) Use 0
 Set:$e(str)="^" str=$p(str,"^",2)
 If '$X Write str Quit
 If ($X\wide*wide+wide+$L(str))>rm Write !,str Quit
 Write ?($X\wide*wide+wide),str Quit
chuiout Use 0 Write:$x>39 ! Write:'$Get(defined) ?40,"not present"
 Write ?40,$j($fn(gblocks,","),10)," data block" Write $e("s",gblocks'=1)," written"
 Quit
wlog(glo,msg) New (glo,msg,logfile,logflag) Do:'logflag
 . Set dummy=$$OpenDev^%Wprim(.logfile)
 . Use logfile 
 . Set logflag=1
 . Write !,"GLOBAL SAVE ERROR LIST",!!
 . Write !,"===================================Descriptions================================="
 . Write !,"Control characters - global has control characters in data or node reference" 
 . Write !,"                     Restore of this file may fail."
 . Write !,"                     Use Cache block format or %GOF to save it.",!
 . Write !,"Mapping            - global is mapped to other namespace. DO NOT SAVE !!!"
 . Write !,"                     Use Cache format or %GO to save it",!
 . Write !,"Data length        - Data length for global greater than block size" 
 . Write !,"                     Use Cache-block format or %GOF to save this data"
 . Write !,"                     Only for Tape"
 . Write !,"================================================================================"
 . Write !!
 . Write !,"=====================================Messages==================================="
 Use logfile 
 Write !,glo,?15,msg 
 Quit
chkone(glo,node) New g,g0,g1,g2,br1,br2,return,flag
 Set return=0,flag=0,current=$namespace,curdir="^^"_$zu(12,""),g="#"
 For  Set g=$o(@node@(current,g)) Quit:(g="")!(flag=1)  Do
 . Quit:'$d(@node@(current,g,"I"))
 . Set g0=$e(g,2,$l(g)-1),g1=$p(g0,":"),g2=$p(g0,":",2),br1=$e(g,1),br2=$e(g,$l(g))
 . Quit:'(((glo=g1)&(br1="["))!((glo]g1)&(g2]glo))!((glo=g2)&(br2="]")))
 . Set dir=@node@(current,g,"I")
 . If (dir'=curdir)!(dir'="|""^^""|") Set flag=1,return=1 Quit  ; Mapped
 Quit:return 1
 Quit $$submap(current,glo,node)
submap(nsp,glo,tran) Quit:'$d(@tran@(nsp,"#")) 0 New return,flag,i,imp,imp1,x,br
 Set return=0,flag=0,i=0
 For  Set i=$o(@tran@(nsp,"#",i)) Quit:(i="")!(flag)  Do
 . Set x=$p(@tran@(nsp,"#",i),":"),br=$e(x) Quit:(br="[")
 . Set x=$e(x,2,$l(x)) Quit:x'=glo
 . If '$d(@tran@(nsp,"#",i,"slm")) Set return=0,flag=1 Quit
 . Set ent="",imp=@tran@(nsp,"#",i,"slm",0,0,"implid")
 . For  Set ent=$o(@tran@(nsp,"#",i,"slm",0,ent)) Quit:(ent="")!(flag)  Do
 . . Set imp1=$g(@tran@(nsp,"#",i,"slm",0,ent,"implid"))
 . . If (imp1'=imp) Set return=1,flag=1 Quit
 Quit return
init() Kill %UI Set %UI=$s(gui=1:"GUI",gui=2:"CSP",1:"CHUI")
 Set logflag=0,logfile="glosave.log:(""WNS"")"
 Set:$g(write)="" write=1 Set blkcnt=0,qflag=0,return=1,vol=1,bytes=0
 Set x=$h,date=+x,time=$p(x,",",2),count=0,IsFile=$$IsFile^%Wprim(sdev)
 If all Kill ^IRIS.TempJ($j) Set dummy=$$guiFetch^%SYS.GD("*"_$c(22,35,1)_"1")
 If fmt=7 Do
 . Set SYS="M/UX",bufstr=""
 . Set return=$$OpenDev^%Wprim(.sdev) Quit:'return
 . Use sdev Use:$ZU(96,18,2,"RAW")!1 0
 . Do mapchk ; it temporary, while $V do not work with mapped globals
 Else  Set return=$$OpenDev^%Wprim(.sdev)
 If return Do
 . Set blksize=$s('IsFile:$p($p(sdev("parms"),":",3),")"),1:2048)
 . Set:%UI'="CHUI" IOT=$s(IsFile:"RMS",1:"MT")
 . Do INT^%DIR
 . Set stream=$$IsStream^%Wprim(sdev)
 . Set Vmode=0 
 . New zm,p,tbl,i,all,xlt
 . Use sdev Set zm=$zm,p=$f(zm,"k\") Set:'p p=$f(zm,"K\")
 . If p Set tbl=$p($e(zm,p,$l(zm)),"\")
 . Else  Set tbl=$$GetIO^%SYS.NLS
 . Use 0 Set all="" For i=0:1:255 Set all=all_$C(i)
 . Set xlt=$zcvt($zcvt(all,"O",tbl),"I",tbl)
 . Set TblBad=xlt'=all
 . Set controls=$C(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,127)
 Quit return
header(fmt,IsFile,hdcomm) New G,parms Set blocks=1,qflag=0
 Set $zt="headErr",stream=$$IsStream^%Wprim(sdev)
 Set parms="~Format="_fmt_"."_$s($g(sdev("parms"))["V":"V",1:"S")_"~" ;file and output formats
 If fmt=5 Do  Do:0 charset Quit 1
 . Do INT^%T
 . Do wout(hdcomm_parms),wout($ZDATE($h,2)_"  "_%TIM_"   IRIS")
 If fmt=6 Do  Quit 1
 . Do INT^%T
 . Do wout(%TIM_"  "_$tr($ZDATE($h,2)," ","-")_parms)
 . Do wout(hdcomm)
 If fmt=99 Quit 1
 If fmt=7 Do  Quit 'qflag
 . Set header(0)=$c(6,0,0,0)_"~%GOF~"
 . ;PWC559 introduced "system code" 2 for bigdb %GOF files
 . Set header(1)=$char(15,0,1,0,$case(bigdb,2048:2,:3),vol,$Zutil(40,0,0),10,13,10,13,128,date#256,date\256#256,date\65536#256,time#256,time\256#256,time\65536#256,$Case(bigdb,2048:1,:2))
 . Set header(2)=$c($l(hdcomm)#256,$l(hdcomm)\256,2,0)_hdcomm
 . Open 63 ; Make sure we own the view buffer
 . Set bytes=$l(header(0))+$l(header(1))+$l(header(2))
 . If '$$blkwout(header(0)) Set qflag=1 Quit
 . If '$$blkwout(header(1)) Set qflag=1 Quit
 . If '$$blkwout(header(2)) Set qflag=1 Quit
 . ; Output global names
 . Quit:(vol>1)  ; Only first volume keep globals name
 . n ord s glolen=0,glo="",ord="" For G=1:1 s ord=$o(^IRIS.TempJ($j,ord)) q:ord=""  s glo=$g(^IRIS.TempJ($j,ord)) q:glo=""  Do  Quit:qflag
 . . Set glolen=glolen+$l(glo)
 . . If glolen>32767 Set qflag=1 Do abort("Too many globals to output!") Quit
 . If '$$blkwout($c(glolen#256,glolen\256,3,0)) Set qflag=1 Quit
 . s ord="" For G=1:1 Set ord=$o(^IRIS.TempJ($j,ord)) q:ord=""  s glo=$g(^IRIS.TempJ($j,ord)) Quit:glo=""  Do  Quit:qflag
 . . Set glonm=$e(glo,2,99) If '$$blkwout($c($l(glonm))_glonm) Set qflag=1 Quit
 Do INT^%T
 Do wout(";Global Save - "_%TIM_" "_$ZDATE($h,2)_" ("_$zv_")"_parms)
 Do wout(";Saved From "_%DIR_": "_hdcomm)
 Quit 1
headErr Quit 0  
charset Use sdev Quit:$zu(96,18,2,sdev("charset"))!1
mapchk New (%UI,logfile,logflag,sdev,write,mapwarn) New G Set current=$namespace Set curdir="^^"_$zu(12,"")
 Set flag=0
 If %UI="CHUI",write Use 0 Do  Use sdev
 . Write !!,"All globals that are mapped to another namespace will not be saved."
 . Write !,"Use %GO or GUI Cache format to save this data.",!
 s node="IRISTempUtil(""%GXLINFO"")"
 Do TRANS^%SYS.GXLINFO(.node)
 Set gx="" f G=1:1 Set gx=$g(^IRIS.TempJ($j,G)) Quit:gx=""  Do
 . Set gxl=$e(gx,2,*)
 . If $$chkone(gxl,node) Kill ^IRIS.TempJ($j,G) Do
 . . Set msg="Global "_gx_" is mapped to other namespace and will be skipped."
 . . If %UI="GUI",$g(mapwarn,6)=6 Do
 . . . Set msg=msg_$c(10)_"Use Cache format to save this data.  See file  "_logfile_"  for details."
 . . . Set msg=msg_$c(10,10)_"Do you wish to see future warnings global mapping warnings?."
 . . . Set mapwarn=$$MsgBox^%CDSrv(msg,48+4,"Cache")
 Quit
wout(r) If Vmode Use sdev Write $zwchar($l(r))_r
 Else  Use sdev Write r Write:stream !
 Quit

%SYS.ikcheck^INT^1^67214,47330
%SYSIKCHECK ; 
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	Quit
globals(domid) public {
	new %glob, %domid, %error, %sortfield
	set %error=0
	set %domid=domid
	set %glob="^IRIS.Temp.ISC.IK.IKCheckReport"
	set %sortfield=^ISC.IK.Sys.Params(%domid,"SortField")
	k @%glob@($j)
	do entities
	do showreport
	do literals
	do showreport
	do crcs
	do showreport
	quit 1
entities
	set %error=0
	do addmessage(0,"Entities","","")
	set uniCnt=0
	set occCnt=0
	set uniId=""
	for {
		set uniId=$o(^ISC.IK.EntUniId(%domid,uniId),1,uni)
		q:uniId=""
		set uniCnt=uniCnt+1
		// EntUni and EntUniHash
		if ($l(uni) > 150) {
			set hash=$zcrc(uni,7)
			do:'$d(^ISC.IK.EntUniHash(%domid,hash,uniId)) adderror(2,"No entry for entity: "_uniId,"","^ISC.IK.EntUniHash")
		} else {
			set ref=$g(^ISC.IK.EntUni(%domid," "_uni))
			if (ref="") {
				do adderror(2,"No entry for entity: "_uniId,"","^ISC.IK.EntUni")
			} elseif (ref'=uniId) {
				do adderror(2,"Invalid entry for entity: "_uniId,"","^ISC.IK.EntUni")
			}
		}
		// Frequency and spread indices
		set details=$g(^ISC.IK.EntUniDetails(%domid,uniId))
		do:details="" adderror(2,"No details for entity: "_uniId,"","^ISC.IK.EntUniDetails")
		set cfreq=$list(details), rfreq=$list(details,2)
		set spread=$list(details,3), cspread=$list(details,4), rspread=$list(details,5)
		if (cfreq'=0) do:'$d(^ISC.IK.EntUniIdFreq(%domid,0,-cfreq,uniId)) adderror(2,"Frequency mismatch for concept: "_uniId,"","^ISC.IK.EntUniIdFreq")
		if (rfreq'=0) do:'$d(^ISC.IK.EntUniIdFreq(%domid,1,-rfreq,uniId)) adderror(2,"Frequency mismatch for relation: "_uniId,"","^ISC.IK.EntUniIdFreq")
		if (cspread'=0) do:'$d(^ISC.IK.EntUniIdSpread(%domid,0,-cspread,uniId)) adderror(2,"Spread mismatch for concept: "_uniId,"","^ISC.IK.EntUniIdSpread")
		if (rspread'=0) do:'$d(^ISC.IK.EntUniIdSpread(%domid,1,-rspread,uniId)) adderror(2,"Spread mismatch for relation: "_uniId,"","^ISC.IK.EntUniIdSpread")
		// Entity parts
		set sort=-$s(%sortfield=0:(cfreq+rfreq),1:spread)
		Set start=1
        Do {
	        Set part=$E(uni,start,*)
	        continue:part=""
	        Continue:$E(part)=" "
	        set bucket=" "_$e(part_"  ",1,3)
	        do:'$d(^ISC.IK.EntParts(%domid,bucket,sort,uniId,start)) adderror(2,"Entity part """_part_""" not found for entity: "_uniId,"","^ISC.IK.EntParts")
	        Set start=$F(uni," ",start)
        } While start
        // Ngrams
        if ($s($get(^IRIS.IK.Sys.Params(+%domid,"EnableNgrams"))'="":^("EnableNgrams"),1:$get(^IRIS.IK.Sys.NSParams("EnableNgrams")))) {
	       For p=1:1:$length(uni)-2 {
                Set ngram=" "_$extract(uni,p,p+2)
                do:'$d(^ISC.IK.EntNgrams(%domid,ngram,sort,uniId)) adderror(2,"Ngram """_ngram_""" not found for entity: "_uniId,"","^ISC.IK.EntNgrams")
            }
        }
		// Occurences
		do:'$d(^ISC.IK.EntUniToOccBit(%domid,uniId)) adderror(2,"No entry for entity: "_uniId,"","^ISC.IK.EntUniToOccBit")
		set cnt=0,ccnt=0,rcnt=0,cocccnt=0,rocccnt=0
		set offset=""
		for {
			set offset=$o(^ISC.IK.EntUniToOccBit(%domid,uniId,offset),1,bitstring)
			q:offset=""
			set cnt=cnt+$bitcount(bitstring,1)
			set rmask=$g(^ISC.IK.EntTypeToOccBit(%domid,0,offset))
			set rmask=$bitlogic(rmask,$bitcount(bitstring))
			set cmask=$bitlogic(~rmask)
			set cbitstring=$bitlogic(bitstring&cmask)
			set rbitstring=$bitlogic(bitstring&rmask)
			set ccnt=ccnt+$bitcount(cbitstring,1)
			set rcnt=rcnt+$bitcount(rbitstring,1)
			set pos=0
			for {
				set pos=$bitfind(bitstring,1,pos+1)
				q:pos=0
				set occId=""
				Set occId=((offset-1)*64000)+pos-1
				set occDetails=$g(^ISC.IK.EntOccId(%domid,occId))
				do:occDetails="" adderror(2,"Occurrence "_occId_" not found for entity: "_uniId,"","^ISC.IK.EntOccId")
				set occUniId=$list(occDetails)
				set occType=$list(occDetails,2)
				set:occType=0 cocccnt=cocccnt+1
				set:occType=1 rocccnt=rocccnt+1
				do:occUniId'=uniId adderror(2,"Occurrence "_occId_" references entity: "_occUniId_", should be: "_uniId,"","^ISC.IK.EntOccId")
			}
			set occCnt=occCnt+cnt
		}
		do:cnt'=(cfreq+rfreq) adderror(2,"Frequency mismatch with occurrences for entity: "_uniId,"","^ISC.IK.EntUniToOccBit")
		do:ccnt'=cfreq adderror(2,"Frequency mismatch with concept occurrences for entity: "_uniId,"","^ISC.IK.EntUniToOccBit | ^ISC.IK.EntTypeToOccBit")
		do:rcnt'=rfreq adderror(2,"Frequency mismatch with relation occurrences for entity: "_uniId,"","^ISC.IK.EntUniToOccBit | ^ISC.IK.EntTypeToOccBit")
		do:cocccnt'=cfreq adderror(2,"Frequency mismatch with concept occurrences for entity: "_uniId,"","^ISC.IK.EntOccId")
		do:rocccnt'=rfreq adderror(2,"Frequency mismatch with relation occurrences for entity: "_uniId,"","^ISC.IK.EntOccId")
	}
	do addmessage(2,"Total unique entities:",uniCnt,"")
	do addmessage(2,"Total entity occurrences:",occCnt,"")
	if ('%error) {
		do addmessage(0,"No errors found for entities","","")
	} else {
		do addmessage(0,"Errors found for entities","","")
	}
	do addmessage(0,"","","")
	quit
literals
	set %error=0
	do addmessage(0,"Literals","","")
	set litCnt=0
	set litId=""
	for {
		set litId=$o(^ISC.IK.LitUniId(%domid,litId),1,lit)
		q:litId=""
		set litCnt=litCnt+1
		// LitUni and LitUniHash
		if ($l(lit) > 150) {
			set hash=$zcrc(lit,7)
			do:'$d(^ISC.IK.LitUniHash(%domid,hash,litId)) adderror(2,"No entry for literal: "_litId,"","^ISC.IK.LitUniHash")
		} else {
			do:$g(^ISC.IK.LitUni(%domid," "_lit))'=litId adderror(2,"No entry for literal: "_litId,"","^ISC.IK.LitUni")
		}
		set uniId=$g(^ISC.IK.LitEntUniMap(%domid,litId))
		do:uniId="" adderror(2,"No entry for literal: "_litId,lit,"^ISC.IK.LitEntUniMap")
		do:uniId=0 adderror(2,"Invalid entry for literal: "_litId,lit,"^ISC.IK.LitEntUniMap")
	}
	do addmessage(2,"Total literals:",litCnt,"")
	if ('%error) {
		do addmessage(0,"No errors found for literals","","")
	} else {
		do addmessage(0,"Errors found for literals",%error,"")
	}
	do addmessage(0,"","","")
	quit
crcs
	set %error=0
	do addmessage(0,"CRCs and CCs","","")
	set crcCnt=0
	set occCnt=0
	set uniId=""
	for {
		set uniId=$o(^ISC.IK.CrcUniId(%domid,uniId),1,crcData)
		q:uniId=""
		set crcCnt=crcCnt+1
		set uniM=$list(crcData), uniR=$list(crcData,2), uniS=$list(crcData,3)
		set ref=$g(^ISC.IK.CrcUni(%domid,uniM,uniR,uniS))
		if (ref="") {
			do adderror(2,"No entry for crc: "_uniId,uniM_"|"_uniR_"|"_uniS,"^ISC.IK.CrcUni")
		} elseif (ref'=uniId) {
			do adderror(2,"Invalid entry for crc: "_uniId,uniM_"|"_uniR_"|"_uniS,"^ISC.IK.CrcUni")
		}
		if (uniM'=0) {
			do:'$d(^ISC.IK.EntUniId(%domid,uniM)) adderror(2,"Master entity not found for crc: "_uniId,uniM,"^ISC.IK.EntUniId")
		}
		do:'$d(^ISC.IK.EntUniId(%domid,uniR)) adderror(2,"Relation entity not found for crc: "_uniId,uniR,"^ISC.IK.EntUniId")
		if (uniS'=0) {
			do:'$d(^ISC.IK.EntUniId(%domid,uniS)) adderror(2,"Slave entity not found for crc: "_uniId,uniS,"^ISC.IK.EntUniId")
		}
		set crcDetails=$g(^ISC.IK.CrcUniDetails(%domid,uniId))
		do:crcDetails="" adderror(2,"No details for crc: "_uniId,"","^ISC.IK.CrcUniDetails")
		set freq=$list(crcDetails), spread=$list(crcDetails,2)
		do:'$d(^ISC.IK.CrcUniIdFreq(%domid,-freq,uniId)) adderror(2,"Frequency mismatch for crc: "_uniId,"","^ISC.IK.CrcUniIdFreq")
		do:'$d(^ISC.IK.CrcUniIdSpread(%domid,-spread,uniId)) adderror(2,"Spread mismatch for crc: "_uniId,"","^ISC.IK.CrcUniIdSpread")
		if (uniM'=0) {
			set fbit=$g(^ISC.IK.CrcEntUniFreq(%domid,uniM,-freq,uniId))
			set sbit=$g(^ISC.IK.CrcEntUniSpread(%domid,uniM,-spread,uniId))
			if (fbit'=1)&&(fbit'=3)&&(fbit'=5)&&(fbit'=7) {
				do adderror(2,"Invalid master bit indication for crc: "_uniId,"","^ISC.IK.CrcEntUniFreq")
			}
			if (sbit'=1)&&(fbit'=3)&&(fbit'=5)&&(fbit'=7) {
				do adderror(2,"Invalid master bit indication for crc: "_uniId,"","^ISC.IK.CrcEntUniSpread")
			}
		}
		set fbit=$g(^ISC.IK.CrcEntUniFreq(%domid,uniR,-freq,uniId))
		set sbit=$g(^ISC.IK.CrcEntUniSpread(%domid,uniR,-spread,uniId))
		if (fbit'=2)&&(fbit'=3)&&(fbit'=6)&&(fbit'=7) {
			do adderror(2,"Invalid relation bit indication for crc: "_uniId,"","^ISC.IK.CrcEntUniFreq")
		}
		if (sbit'=2)&&(fbit'=3)&&(fbit'=6)&&(fbit'=7) {
			do adderror(2,"Invalid relation bit indication for crc: "_uniId,"","^ISC.IK.CrcEntUniSpread")
		}
		if (uniS'=0) {
			set fbit=$g(^ISC.IK.CrcEntUniFreq(%domid,uniS,-freq,uniId))
			set sbit=$g(^ISC.IK.CrcEntUniSpread(%domid,uniS,-spread,uniId))
			if (fbit'=4)&&(fbit'=6)&&(fbit'=5)&&(fbit'=7) {
				do adderror(2,"Invalid slave bit indication for crc: "_uniId,"","^ISC.IK.CrcEntUniFreq")
			}
			if (sbit'=4)&&(fbit'=6)&&(fbit'=5)&&(fbit'=7) {
				do adderror(2,"Invalid slave bit indication for crc: "_uniId,"","^ISC.IK.CrcEntUniSpread")
			}
		}
		set uniOff=0
		set uniPos=0
		Set uniOff=(uniId\64000)+1,uniPos=(uniId#64000)+1
		if (uniM'=0) {
			set bitstring=$g(^ISC.IK.EntUniMToCrcUniBit(%domid,uniM,uniOff))
			do:$bit(bitstring,uniPos)'=1 adderror(2,"Invalid bit in master bitstring for crc: "_uniId,"","^ISC.IK.EntUniMToCrcUniBit")
		}
		set bitstring=$g(^ISC.IK.EntUniRToCrcUniBit(%domid,uniR,uniOff))
		do:$bit(bitstring,uniPos)'=1 adderror(2,"Invalid bit in relation bitstring for crc: "_uniId,"","^ISC.IK.EntUniRToCrcUniBit")
		if (uniS'=0) {
			set bitstring=$g(^ISC.IK.EntUniSToCrcUniBit(%domid,uniS,uniOff))
			do:$bit(bitstring,uniPos)'=1 adderror(2,"Invalid bit in slave bitstring for crc: "_uniId,"","^ISC.IK.EntUniSToCrcUniBit")
		}
		// Occurrences
		set cnt=0
		do:'$d(^ISC.IK.CrcUniToOccBit(%domid,uniId)) adderror(2,"No entry for crc: "_uniId,"","^ISC.IK.CrcUniToOccBit")
		set offset=""
		for {
			set offset=$o(^ISC.IK.CrcUniToOccBit(%domid,uniId,offset),1,bitstring)
			q:offset=""
			set cnt=cnt+$bitcount(bitstring,1)
			set pos=0
			for {
				set pos=$bitfind(bitstring,1,pos+1)
				q:pos=0
				set occId=""
				Set occId=((offset-1)*64000)+pos-1
				set occDetails=$g(^ISC.IK.CrcOccId(%domid,occId))
				do:occDetails="" adderror(2,"Occurrence "_occId_" not found for crc: "_uniId,"","^ISC.IK.CrcOccId")
				set ref=$list(occDetails), occM=$list(occDetails,2), occR=$list(occDetails,3), occS=$list(occDetails,4)
				do:ref'=uniId adderror(2,"Invalid reference to crc for occurrence "_occId_" of crc: "_uniId,"","^ISC.IK.CrcOccId")
				if (occM'=0) {
					do:'$d(^ISC.IK.EntOccId(%domid,occM)) adderror(2,"Master occurrence not found for crc: "_uniId,occId_"|"_occM,"^ISC.IK.CrcOccId")
					set refM=$lg(^ISC.IK.EntOccId(%domid,occM))
					do:refM'=uniM adderror(2,"Master occurrence not corresponding with master entity for crc: "_uniId,"","^ISC.IK.CrcOccId")
				}
				do:'$d(^ISC.IK.EntOccId(%domid,occR)) adderror(2,"Relation occurrence not found for crc: "_uniId,occId_"|"_occR,"^ISC.IK.CrcOccId")
				set refR=$lg(^ISC.IK.EntOccId(%domid,occR))
				do:refR'=uniR adderror(2,"Relation occurrence not corresponding with relation entity for crc: "_uniId,"","^ISC.IK.CrcOccId")
				if (occS'=0) {
					do:'$d(^ISC.IK.EntOccId(%domid,occS)) adderror(2,"Slave occurrence not found for crc: "_uniId,occId_"|"_occS,"^ISC.IK.CrcOccId")
					set refS=$lg(^ISC.IK.EntOccId(%domid,occS))
					do:refS'=uniS adderror(2,"Slave occurrence not corresponding with slave entity for crc: "_uniId,"","^ISC.IK.CrcOccId")
				}				
			}
		}
		set occCnt=occCnt+cnt
		// CCs
		if (uniM'=0) && (uniS'=0) {
			set ccDetails=$g(^ISC.IK.CcUniDetails(%domid,uniM,uniS))
			d:ccDetails="" adderror(2,"No CC entry for crc: "_uniId,uniM_"|"_uniS,"^ISC.IK.CcUniDetails")
			set low=$s(uniM<uniS:uniM,1:uniS)
			set high=$s(uniM>uniS:uniM,1:uniS)
			set combiDetails=$g(^ISC.IK.CcCombiDetails(%domid,low,high))
			d:combiDetails="" adderror(2,"No CC combi entry for crc: "_uniId,low_"|"_high,"^ISC.IK.CcCombiDetails")
			set:ccDetails'="" ccFreq=$list(ccDetails), ccSpread=$list(ccDetails,2)
			set:combiDetails'="" combiFreq=$list(combiDetails), combiSpread=$list(combiDetails,2)
			if (combiDetails'="") {
				do:'$d(^ISC.IK.CcCombiFreq(%domid,uniM,-combiFreq,uniS)) adderror(2,"Frequency mismatch for CC: "_uniM_", "_uniS,"","^ISC.IK.CcCombiFreq")
				do:'$d(^ISC.IK.CcCombiFreq(%domid,uniS,-combiFreq,uniM)) adderror(2,"Frequency mismatch for CC: "_uniS_", "_uniM,"","^ISC.IK.CcCombiFreq")
				do:'$d(^ISC.IK.CcCombiSpread(%domid,uniM,-combiSpread,uniS)) adderror(2,"Spread mismatch for CC: "_uniM_", "_uniS,"","^ISC.IK.CcCombiSpread")
				do:'$d(^ISC.IK.CcCombiSpread(%domid,uniS,-combiSpread,uniM)) adderror(2,"Spread mismatch for CC: "_uniS_", "_uniM,"","^ISC.IK.CcCombiSpread")
			}
		}
	}
	// CC frequencies and spread
	set uniM=""
	for {
		set uniM=$o(^ISC.IK.CcUniDetails(%domid,uniM))
		q:uniM=""
		set moff=""
		set mpos=""
		Set moff=(uniM\64000)+1,mpos=(uniM#64000)+1
		set uniS=""
		for {
			set uniS=$o(^ISC.IK.CcUniDetails(%domid,uniM,uniS),1,ccDetails)
			q:uniS=""
			set soff=""
			set spos=""
			Set soff=(uniS\64000)+1,spos=(uniS#64000)+1
			do:'$bit(^ISC.IK.EntUniMToEntUniSBit(%domid,uniM,soff),spos)=1 adderror(2,"No link from master to slave for cc: "_uniM_"|"_uniS,"","^ISC.IK.EntUniMToEntUniSBit")
			do:'$bit(^ISC.IK.EntUniSToEntUniMBit(%domid,uniS,moff),mpos)=1 adderror(2,"No link from slave to master for cc: "_uniM_"|"_uniS,"","^ISC.IK.EntUniSToEntUniMBit")
			set freq=$list(ccDetails), spread=$list(ccDetails,2)
			set crcFreq=0
			set crcSpread=0
			set uniR=""
			for {
				set uniR=$o(^ISC.IK.CrcUni(%domid,uniM,uniR))
				q:uniR=""
				set crcId=$g(^ISC.IK.CrcUni(%domid,uniM,uniR,uniS))
				if (crcId'="") {
					set crcFreq=crcFreq+$list(^ISC.IK.CrcUniDetails(%domid,crcId))
					set offset=""
					for {
						set offset=$o(^ISC.IK.CrcUniToSrcBit(%domid,crcId,offset),1,bitstring)
						q:offset=""
						set crcSpread=crcSpread+$bitcount(bitstring,1)
					}
				}
			}
			do:freq'=crcFreq adderror(2,"Frequency mismatch between crcs and cc: "_uniM_", "_uniS,freq_"|"_crcFreq,"^ISC.IK.CcUniDetails")
			do:spread'=crcSpread adderror(2,"Spread mismatch between crcs and cc: "_uniM_", "_uniS,spread_"|"_crcSprea,"^ISC.IK.CrcUniDetails")
		}
	}
	// CC combi frequencies and spread
	set low=""
	for {
		set low=$o(^ISC.IK.CcCombiDetails(%domid,low))
		q:low=""
		set high=""
		for {
			set high=$o(^ISC.IK.CcCombiDetails(%domid,low,high),1,combiDetails)
			q:high=""
			set freq=$list(combiDetails), spread=$list(combiDetails,2)
			set crcFreq=0
			set crcSpread=0
			k bitstrings
			set uniR=""
			for {
				set uniR=$o(^ISC.IK.CrcUni(%domid,low,uniR))
				q:uniR=""
				set crcId=$g(^ISC.IK.CrcUni(%domid,low,uniR,high))
				if (crcId'="") {
					set crcFreq=crcFreq+$list(^ISC.IK.CrcUniDetails(%domid,crcId))
					set offset=""
					for {
						set offset=$o(^ISC.IK.CrcUniToSrcBit(%domid,crcId,offset),1,bitstring)
						q:offset=""
						set ref=$g(bitstrings(offset))
						set bitstrings(offset)=$bitlogic(ref|bitstring)
					}
				}
			}
			if (low'=high) {
				set uniR=""
				for {
					set uniR=$o(^ISC.IK.CrcUni(%domid,high,uniR))
					q:uniR=""
					set crcId=$g(^ISC.IK.CrcUni(%domid,high,uniR,low))
					if (crcId'="") {
						set crcFreq=crcFreq+$list(^ISC.IK.CrcUniDetails(%domid,crcId))
						set offset=""
						for {
							set offset=$o(^ISC.IK.CrcUniToSrcBit(%domid,crcId,offset),1,bitstring)
							q:offset=""
							set ref=$g(bitstrings(offset))
							set bitstrings(offset)=$bitlogic(ref|bitstring)
						}
					}
				}
			}
			do:freq'=crcFreq adderror(2,"Frequency mismatch between crcs and cc combi: "_low_", "_high,freq_"|"_crcFreq,"^ISC.IK.CcCombiDetails")
			set offset=""
			for {
				set offset=$o(bitstrings(offset),1,bitstring)
				q:offset=""
				set crcSpread=crcSpread+$bitcount(bitstring,1)
			}
			k bitstrings
			do:spread'=crcSpread adderror(2,"Spread mismatch between crcs and cc combi: "_low_", "_high,spread_"|"_crcSprea,"^ISC.IK.CrcUniDetails")
		}
	}
	do addmessage(2,"Total unique crcs:",crcCnt,"")
	do addmessage(2,"Total crc occurrences:",occCnt,"")
	if ('%error) {
		do addmessage(0,"No errors found for crcs and ccs","","")
	} else {
		do addmessage(0,"Errors found for crcs and ccs",%error,"")
	}
	do addmessage(0,"","","")
	quit
addmessage(offset,message,value,glob)
	set @%glob@($j,$i(@%glob@($j)))=$lb(offset,message,value,glob)
	quit
adderror(offset,message,value,glob)
	set %error=%error+1
	do addmessage(offset,"ERROR: "_message,value,glob)
	quit 	
showreport
	set i=""
	for {
		set i=$o(@%glob@($j,i),1,data)
		q:i=""
		set offset=$list(data)
		set message=$list(data,2)
		set value=$list(data,3)
		set glob=$list(data,4)
		w !,?(offset),message,?(70),value
		w:glob'="" !,?(20),glob
	}
	k @%glob@($j)
	quit
}

ARCHIVE^INT^1^67214,47330
ARCHIVE ; routine to manage archive
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 n rc
 d MENU()
 q
MENU() {
 s List(1)="Copy a file to an archive target"
 s List(2)="Retrieve an archived file"
 s List(3)="Delete an archived file"
 s List(4)="Manage archive targets"
 ;
 s help(1)="This utility allows you to archive a file"
 s help(2)="or to retrieve or delete an archived file"
 s help(3)="or to manage archive targets."
 ;
 s flags=8+128+4
 f  {
   s Value=""
   s Status=##Class(%Library.Prompt).GetMenu("Option?",.Value,.List,.help,flags)
   i (Status=0)||(Status=2)||(Value="") q
   i Value=1 d ArchiveFile() Continue
   i Value=2 d RetrieveFile() Continue
   i Value=3 d DeleteFile() Continue
   i Value=4 d ManageArchives() Continue
 }
 q Status
ERROR s $zt=""
 i $ze["<INTERRUPT>" q 0
 ztrap $ze
}
ArchiveFile() [] {
 s $ZT="ERROR"
 i '$SYSTEM.Security.Check("%Admin_Operate","USE") {
   w !,"Operation requires %Admin_Operate:Use privilege" 
   q
 } 
 s ArchiveName=""
 s Flag=8+64+512
 s Help(1)=$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2672183014"),"Select a predefined archive name as the destination of the operation.")
 s Status=##class(%Library.Prompt).GetArray("Archive Target: ",.ArchiveName,$LB("Config.Archives:List"),,,.Help)
 i (+Status=0)||(Status=2)||(ArchiveName="") q
 s Flag=8+512
 s FilePath=""
 s Help(1)=$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2087929234"),"Enter the path of a file to copy.")
 s Status=##Class(%Library.Prompt).GetString("File: ",.FilePath,,,.Help,,Flag)
 i (+Status=0)||(Status=2)||(FilePath="") q
 s Status=##class(SYS.ArchiveManager).PutFile(FilePath,ArchiveName,.ArchiveSpec)
 i ('Status) d $System.Status.DisplayError(Status) q
 w !!,FilePath," copied to ",$p(ArchiveSpec,",",2)
 q
ERROR s $zt=""
 i $ze["<INTERRUPT>" q 0
 ztrap $ze
}
DeleteFile() [] {
 s $ZT="ERROR"
 i '$SYSTEM.Security.Check("%Admin_Operate","USE") {
   w !,"Operation requires %Admin_Operate:Use privilege" 
   q
 } 
 s Flag=8+512
 s FileName=""
 s Help(1)=$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3057389437"),"Enter the name of the file to delete.")
 s Status=##Class(%Library.Prompt).GetString("File: ",.FileName,,,.Help,,Flag)
 i (+Status=0)||(Status=2)||(FileName="") q
 s Flag=8+512
 s ArchiveType=""
 s Help(1)=$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3533842598"),"Enter the type of the archive target.")
 s Status=##Class(%Library.Prompt).GetString("Archive type: ",.ArchiveType,,,.Help,,Flag)
 i (+Status=0)||(Status=2)||(ArchiveType="") q
 s ArchiveLocation=""
 i ArchiveType="s3" {
   s sample="s3://myBucket/"
 } elseif ($zversion(1)=2) {
   s sample="\\server\dir\"
 } else {
   s sample="host:/dir/"
 }
 s Help(1)=$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2304140539"),"Enter the location of the archived file, e.g., ")_sample
 s Status=##Class(%Library.Prompt).GetString("Archive location: ",.ArchiveLocation,,,.Help,,Flag)
 i (+Status=0)||(Status=2)||(ArchiveLocation="") q
 s Status=##class(SYS.ArchiveManager).DeleteFile(FileName,ArchiveType_","_ArchiveLocation)
 i ('Status) d $System.Status.DisplayError(Status) q
 w !!,FileName," deleted from ",ArchiveLocation
 q
ERROR s $zt=""
 i $ze["<INTERRUPT>" q 0
 ztrap $ze
}
RetrieveFile() [] {
 s $ZT="ERROR"
 i '$SYSTEM.Security.Check("%Admin_Operate","USE") {
   w !,"Operation requires %Admin_Operate:Use privilege" 
   q
 } 
 s Flag=8+512
 s FilePath=""
 s Help(1)=$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1906232609"),"Enter the path of the destination file.")
 s Status=##Class(%Library.Prompt).GetString("Retrieve file to: ",.FilePath,,,.Help,,Flag)
 i (+Status=0)||(Status=2)||(FilePath="") q
 s Flag=8+512
 s ArchiveType=""
 s Help(1)=$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2948354887"),"Enter the type of the archive source.")
 s Status=##Class(%Library.Prompt).GetString("Archive type: ",.ArchiveType,,,.Help,,Flag)
 i (+Status=0)||(Status=2)||(ArchiveType="") q
 s ArchiveLocation=""
 i ArchiveType="s3" {
   s sample="s3://myBucket/"
 } elseif ($zversion(1)=2) {
   s sample="\\server\dir\"
 } else {
   s sample="host:/dir/"
 }
 s Help(1)=$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3984769405"),"Enter the location of the archive source, e.g., ")_sample
 s Status=##Class(%Library.Prompt).GetString("Archive location: ",.ArchiveLocation,,,.Help,,Flag)
 i (+Status=0)||(Status=2)||(ArchiveLocation="") q
 s Status=##class(SYS.ArchiveManager).GetFile(FilePath,ArchiveType_","_ArchiveLocation)
 i ('Status) d $System.Status.DisplayError(Status) q
 w !!,FilePath," retrieved from ",ArchiveLocation
 q
ERROR s $zt=""
 i $ze["<INTERRUPT>" q 0
 ztrap $ze
}
ManageArchives() {
 s $ZT="ERROR"
 s List(1)="Add a new archive target"
 s List(2)="Remove an existing archive target"
 s List(3)="List existing archive targets"
 s flags=8+128+4
 f  {
   s Value=""
   s Status=##Class(%Library.Prompt).GetMenu("Option?",.Value,.List,,flags)
   i (Status=0)||(Status=2)||(Value="") q
   i Value=1 d AddArchiveTarget() Continue
   i Value=2 d DeleteArchiveTarget() Continue
   i Value=3 d ListArchiveTargets() Continue
 }
 q
ERROR s $zt=""
 i $ze["<INTERRUPT>" q
 ztrap $ze
}
AddArchiveTarget() [] {
 s $ZT=""
 i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
 s ArchiveName=""
 s Flag=8+512
 s Help(1)=$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"4123444314"),"Enter the name of the new archive target.") ;RJW1321
 s Status=##Class(%Library.Prompt).GetString("Archive Target Name: ",.ArchiveName,,,.Help,,Flag)
 i (+Status=0)||(Status=2)||(ArchiveName="") q 
 i ##Class(Config.Archives).Exists(ArchiveName) {
   d $System.Status.DisplayError($$Error^%apiOBJ(484,ArchiveName))
   q
 }
 s Help(1)=$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"632229681"),"Enter the type of the new archive target.") ;RJW1321
 s Types(1)="AWS S3"
 s Types(2)="rsync"
 s Types(3)="noop" ;for testing purpose only
 s Value=""
 s Status=##Class(%Library.Prompt).GetMenu("Type: ",.Value,.Types,,Flag)
 i (+Status=0)||(Status=2)||(Value="") q
 s ArchiveType=$s(Value=1:"s3",1:Types(Value))
 s Help(1)=$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"471645707"),"Enter the location of the new archive target.") ;RJW1321
 s Status=##Class(%Library.Prompt).GetString("Archive Location: ",.ArchiveLocation,,,.Help,,Flag)
 i (+Status=0)||(Status=2)||(ArchiveLocation="") q
 s Properties("Type")=ArchiveType
 s Properties("Location")=ArchiveLocation
 s Status=##Class(Config.Archives).Create(ArchiveName,.Properties)
 i ('Status) d $System.Status.DisplayError(Status) q
 q
ERROR s $zt=""
 i $ze["<INTERRUPT>" q
 ztrap $ze
}
DeleteArchiveTarget() [] {
 s $ZT="ERROR"
 i '$SYSTEM.Security.Check("%Admin_Operate","USE") {
   w !,"Operation requires %Admin_Operate:Use privilege" 
   q
 } 
 s ArchiveName=""
 s Flag=8+64+512
 s Help(1)=$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1748029630"),"Select the name of the archive target to delete.")
 s Status=##class(%Library.Prompt).GetArray("Archive Target: ",.ArchiveName,$LB("Config.Archives:List"),,,.Help)
 i (+Status=0)||(Status=2)||(ArchiveName="") q
 s Status=##Class(Config.Archives).Delete(ArchiveName)
 i ('Status) d $System.Status.DisplayError(Status) q
 q
ERROR s $zt=""
 i $ze["<INTERRUPT>" q
 ztrap $ze
}
ListArchiveTargets() [] {
 s $ZT="ERROR"
 s rs=##class(%Library.ResultSet).%New("Config.Archives:List")
 s rc=rs.Execute() i ('rc) d $System.Status.DisplayError(rc) q
 w !,$j("Name",16),$j("Type",6),"  Location"
 w !,$j("----",16) f i=1:1:16 {w "-"} w !
 f  q:'rs.Next()  w $j(rs.Data("Name"),16),$j(rs.Data("Type"),6),"  ",rs.Data("Location"),!
 q
ERROR s $zt=""
 i $ze["<INTERRUPT>" q
 ztrap $ze
}
YN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YN"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"yn","YN") I "^YN"'[R W "  enter Yes or No, please"
 S POP=(R="^") W $E($S(R="N":"No",R="Y":"Yes",1:""),$L(X)+1,3) Q R

BACKUP^INT^1^67214,47330
BACKUP ; routine to call the backup menu
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 n rc
 d MENU()
 q
MENU() {
 	s List(1)="Backup"
 	s List(2)="Restore ALL"
 	s List(3)="Restore Selected or Renamed Directories"
 	s List(4)="Edit/Display List of Directories for Backups"
 	s List(5)="Abort Backup"
	s List(6)="Display Backup volume information"
	s List(7)="Monitor progress of backup or restore"
 	;
 	s help(1)="This utility allows you to backup the databases "
 	s help(2)="or to restore an already created backup. If a list of"
 	s help(3)="databases has not been created then all databases will be"
 	s help(4)="included in the backup. If a list is created that list will"
 	s help(5)="apply to all aspects of the backup system including calls"
 	s help(6)="to LISTDIRS^DBACK and CLRINC^DBACK for scripted backups."
 	;
 	s flags=8+128+4
	f  {
 	   s Value=""
	   s Status=##Class(%Library.Prompt).GetMenu("Option?",.Value,.List,.help,flags)
 	   i (Status=0)||(Status=2)||(Value="") q
 	   i Value=1 d RunBackup() Continue
 	   i Value=2 d ALL^DBREST Continue
 	   i Value=3 d SELECT^DBREST Continue
 	   i Value=4 d EditBackupList() Continue
 	   i Value=5 d AbortBackup() Continue
 	   i Value=6 d VOLUMEINFO^DBREST Continue
 	   i Value=7 d STATUS Continue
    }
    q Status
ERROR s $zt=""
    i $ze["<INTERRUPT>" q 0
    ztrap $ze
}
RunBackup() [bkpmount] {
	s $ZT="ERROR"
 	i '$SYSTEM.Security.Check("%Admin_Operate","USE") w !,"Operation requires %Admin_Operate:Use privilege" q
	n bkpmount
 	d ^DBACK
 	s dir="" f  s dir=$o(bkpmount(dir)) q:dir=""  i $zu(3,dir)
 	q 1
ERROR s $zt=""
    i $ze["<INTERRUPT>" q 0
    ztrap $ze
}
EditBackupList() {
	s $ZT="ERROR"
	s List(1)="Add a database to the backup"
 	s List(2)="Remove a database from the backup"
 	s List(3)="Show current list of databases included in backups"
 	s List(4)="Show list of available databases"
 	s List(5)="Display last full backup information"
 	;
 	s flags=8+128+4
 	f  {
 		s Value=""
		s Status=##Class(%Library.Prompt).GetMenu("Option?",.Value,.List,,flags)
 		i (Status=0)||(Status=2)||(Value="") q
 		i Value=1 d DBAdd() Continue
 		i Value=2 d DBRemove() Continue
 		i Value=3 d ShowBackupDBList() Continue
 		i Value=4 d ShowAllDBList() Continue
 		i Value=5 d ShowLastFullBackup() Continue
 	}
 	q Status
ERROR s $zt=""
 	i $ze["<INTERRUPT>" q 0
 	ztrap $ze
}
DBAdd() {
	s $ZT=""
 	i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
	s del1=$$del1^%Wprim,del2=$$del2^%Wprim
	d getListOfAllDBs(.dblist)
 	s rc=$$DbList^Wsback(.list)
 	if '+rc w !,"Error building list of databases: ",$P(rc,del1,2) q -1 
 	s cnt=$L(list,del1)
 	f i=1:1:cnt {
		s db=$P(list,del1,i)
		s dbname=$P(db,del2,1)
		q:dbname="" 
		s dbdir=$P(db,del2,2)
		s backuplist(dbname)=dbdir
		s backuplist(dbname,0)=+$p(db,del2,3)  ;read only flag
		k dblist(dbname)
 	}
 	if '$D(dblist) {
	   w !,"All databases are currently part of the backup"
	   r !,"Press <Enter> to continue",i
	   q
	}	 	
 	s help(1)="Choose one of the following databases to include"
 	s help(2)="in subsequent backups. You will be asked to confirm changes"
 	s help(3)="before exiting. Databases added here will also be included in"
 	s help(4)="backups initiated via the GUI or BACKUP^DBACK interfaces"
 	s help(5)="Note that the 1st backup after a new database has been added"
 	s help(6)="to the list must be a full backup. This is enforced when the"
 	s help(7)="backup is started, not at this point when the database is"
 	s help(8)="added. Press ^ to back up to the prior menu."
 	s help(9)="List of databases not already included in the backup"
 	s help(10)="     Database          Directory"
 	s dbname=""
 	s pad="                 "
 	s helpbase=$O(help(""),-1)+1
 	f i=helpbase:1 {
	   s dbname=$O(dblist(dbname)) 
	   q:dbname=""  
	   s dbnamex=dbname_$s(dblist(dbname,0):" (Read Only)",1:"")
	   s help(i)="     "_dbnamex_$E(pad,$L(dbnamex),$L(pad))_dblist(dbname) 
 	}
 	s flag=8+16
	s prompt="Enter database to add? "
 	s newdb=""
	s rc=##Class(%Library.Prompt).GetString(prompt,.newdb,0,45,.help,flag)
	while ((rc=1) && $L(newdb)) {
		s newdb=$ZCVT(newdb,"U")
		if $D(dblist(newdb)) {
			s addlist(newdb)=""
			s backuplist(newdb)=dblist(newdb)
			s backuplist(newdb,0)=$g(dblist(newdb,0),0)  ; Get read only flag.
			k dblist(newdb)
			k help(i-1)
 		    f i=helpbase:1 {
	   		   s dbname=$O(dblist(dbname)) 
	   		   q:dbname=""  
			   s dbnamex=dbname_$s(dblist(dbname,0):" (Read Only)",1:"")
	   		   s help(i)="     "_dbnamex_$E("        ",$L(dbnamex),8)_dblist(dbname) 
		 	}
		} elseif '$D(backuplist(newdb)) {
			w !,"Invalid database name, press ? for help or ^ to back up"
		}
 	    s newdb=""
	    s rc=##Class(%Library.Prompt).GetString(prompt,.newdb,0,45,.help,flag)
	} 	
	if ($D(addlist) && ((rc=1) || (rc=2) || (rc = 3))) {
		s dbname=$O(addlist(""))
		s db=$O(addlist(dbname))
		if db="" {
			w !,"You've selected "_dbname_" to be added to the backups"
		} else {
			w !,"You've selected the following databases to be added to the backups"
			w !,?5,dbname
			w !,?5,db
			f  s db=$O(addlist(db)) q:db=""  w !,?5,db
		}
		k resp  ;no default
		s Status=##Class(%Library.Prompt).GetYesNo("Are you sure you want to do this (yes/no)?",.resp,,8)
	    if ((Status=1) && (resp=1)) {
		    s db=""
		    f  s db=$O(addlist(db)) q:db=""  s ^SYS("BACKUPDB",db)=""
		    w !,"Completed."
	    } else {
		    w !,"Aborted"
	    }
	}
} 
DBRemove() {
	s $ZT=""
 	i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
	s del1=$$del1^%Wprim,del2=$$del2^%Wprim
 	s rc=$$DbList^Wsback(.list)
 	if '+rc w !,"Error building list of databases: ",$P(rc,del1,2) q -1 
 	s cnt=$L(list,del1)-1
 	f i=1:1:cnt {
	   s db=$P(list,del1,i)
	   s dbname=$P(db,del2,1)
	   q:dbname=""  
	   s dbdir=$P(db,del2,2)
	   s backuplist(dbname)=dbdir
	   s backuplist(dbname,0)=+$p(db,del2,3)  ;read only flag
 	}
 	s help(1)="Choose one of the following databases to delete from the"
 	s help(2)="list of databases included in a backup. You will be asked to"
 	s help(3)="confirm your changes. Changes here also affect backups initiated"
 	s help(4)="via the GUI or BACKUP^DBACK interfaces. If you remove all of the"
 	s help(5)="listed databases then all databases on the system will be included"
 	s help(6)="included in the backup."
 	s help(7)="Press ^ to back up to the prior menu"
 	s help(8)="     Database          Directory"
 	s dbname=""
 	s helpbase=$O(help(""),-1)+1
 	s pad="                 "
 	f i=helpbase:1 {
	 	s dbname=$O(backuplist(dbname)) 
	 	q:dbname=""
		s dbnamex=dbname_$s(backuplist(dbname,0):" (Read Only)",1:"")
	 	s help(i)="     "_dbnamex_$E(pad,$L(dbnamex),$L(pad))_backuplist(dbname) 
 	}
 	s flag=8+16
 	s newdb=""
	s prompt="Enter database to remove (^ when done)? "
	s rc=##Class(%Library.Prompt).GetString(prompt,.deldb,0,45,.help,flag)
	while ((rc=1) && $L(deldb)) {
		s deldb=$ZCVT(deldb,"U")
		if $D(backuplist(deldb)) {
			s remlist(deldb)=""
			k backuplist(deldb)
		    k help(i-1)
		    s dbname=""
	   	    f i=helpbase:1 {
	 		   s dbname=$O(backuplist(dbname)) 
	 		   q:dbname=""  
			   s dbnamex=dbname_$s(backuplist(dbname,0):" (Read Only)",1:"")
	 		   s help(i)="     "_dbnamex_$E(pad,$L(dbnamex),$l(pad))_backuplist(dbname) 
 	 		}
 	 		q:'$D(backuplist)
		} else {
			w !,"Invalid database name, press ? for help"
		}
		s deldb=""
		s rc=##Class(%Library.Prompt).GetString(prompt,.deldb,0,45,.help,flag)
	} 	
	if ($D(remlist) && ((rc=1) || (rc=2) || (rc = 3))) {
		s dbname=$O(remlist(""))
		s db=$O(remlist(dbname))
		if '$d(backuplist) {
			w !,"You've deleted all databases on the backup list."
			w !,"This means that a backup will include all databases on the"
			w !,"system."
		} elseif db="" {
			w !,"You've removed "_dbname_" from the backups"
		} else {
			w !,"You've removed the following databases from the backups"
			w !,?5,dbname
			w !,?5,db
			f  s db=$O(remlist(db)) q:db=""  w !,?5,db
		}
		k Value ; no default
		s Status=##Class(%Library.Prompt).GetYesNo("Are you sure you want to do this?",.Value,,8)
	    if ((Status=1) && (Value=1)) {
		    s db=""
		    f  s db=$O(remlist(db)) q:db=""  k ^SYS("BACKUPDB",db)
		    w !,"Completed."
	    } else {
		    w !,"Aborted."
	    }
	}
} 
ShowBackupDBList() {
	s $ZT=""
	s del1=$$del1^%Wprim,del2=$$del2^%Wprim
 	s rc=$$DbList^Wsback(.list)
 	if '+rc w !,"Error building list of databases: ",$P(rc,del1,2) q -1 
 	s cnt=$L(list,del1)-1
 	w !,"The following ",cnt," databases are included in backups"
 	f i=1:1:cnt {
		s db=$P(list,del1,i)
		s dbname=$P(db,del2,1)
		q:dbname=""  
		s dbdir=$P(db,del2,2)
		s dbname=dbname_$s(+$p(db,del2,3):" (Read Only)",1:"")
		w !,?5,dbname,?30,dbdir
 	}
	q 1
}
ShowAllDBList() {
	s $ZT=""
	s del1=$$del1^%Wprim,del2=$$del2^%Wprim
	d getListOfAllDBs(.dblist)
 	s rc=$$DbList^Wsback(.list)
 	if '+rc w !,"Error building list of databases: ",$P(rc,del1,2) q -1 
 	s cnt=$L(list,del1)-1
 	f i=1:1:cnt {
		s db=$P(list,del1,i)
		s dbname=$P(db,del2,1)
		q:dbname=""  
		s dbdir=$P(db,del2,2)
		s backuplist(dbname)=dbdir
		s backuplist(dbname,0)=+$p(db,del2,3)  ;read only flag
 	}
 	w !,"The following is a list of all databases in the configuration."
 	w !,"Databases which are part of the backup are marked with (*)"
 	s dbname=""
 	f  s dbname=$O(dblist(dbname)) q:dbname=""  do
 	. w !,?5,$S($D(backuplist(dbname)):"(*) ",1:"    ")
 	. w dbname_$s(dblist(dbname,0):" (Read Only)",1:""),?30,dblist(dbname)
 	q 1
}
ShowLastFullBackup() {
 i '$d(^SYS("BACKUP","LASTFULL")) {
	 w !,"No information recorded about a full backup"
 } else {
    w !!,"=====Last Full Backup Information=====",!
    w !,"Date: ",$zd(^SYS("BACKUP","LASTFULL","DATE"),2)
    w !,"Description: ",^SYS("BACKUP","LASTFULL","DESC")
    w !,"Device: ",$g(^SYS("BACKUP","LASTFULL","DEVICE"))
 }
 quit 1
}
getListOfAllDBs(dblist) public {
	s $ZT="ERROR"
 	s del1=$$del1^%Wprim,del2=$$del2^%Wprim
	s context="",list=""
 	f  s done=$$List^Wsdba(.list,.context) d  q:done=0 
 	. s cnt=$L(list,del1)
 	. f i=1:1:cnt d
 	. . s db=$p(list,del1,i)
 	. . s dbname=$p(db,del2)
 	. . q:dbname=""
	. . s dbdir=$p(db,del2,2)
 	. . q:+$p(db,del2,4)=$ZU(173)  ; don't include cachetemp
 	. . s dblist(dbname)=dbdir
 	. . s dblist(dbname,0)=+$p(db,del2,3) ; set read only flag.
ERROR ;
 	q
} 	
AbortBackup() {
 	i '$SYSTEM.Security.Check("%Admin_Operate","USE") w !,"Operation requires %Admin_Operate:Use privilege" q
 	W !,"Are you sure you want to abort the backup operation ? <No> " r ans
 	s ans=$zcvt(ans,"U") i ans'="Y" && (ans'="YES") q
 	s ans=##class(Backup.General).AbortBackup()
 	i ans=0 w !,"Backup abortion succeed." q
 	i ans=1 w !,"No Backup operation is currently running." q
 	i ans=2 w !,"Backup already aborted." q
 	q
}
STATUS
 n
 s %1Pid=0
 s %1Status=1
 s %1StatusLine=4
 Set prevspace="^"_$zu(96,12)
 u 0::"^%X364"	; Set mnemonic space
 s RM=80
 s Rate=15,Blank=$j("",RM)
 d CLEAR(1,24)
 w /cup(1,1),$$CENTER("Backup/Restore Status",RM)
 w /cup(2,1),$$CENTER("---------------------",RM)
 f  {
 	s %1Status=$$GetBackupPid(.%1Pid)
 	i '(''%1Status) {
	 	i %1Status=0 {
			d Status("Switch 10 is set, unable to report status")
			d CLEAR(5,24)
	 	} else {
		 	d Status($System.Status.GetErrorText(%1Status))
	 	}
	 	g Prompt
 	}
 	i %1Pid=0 {
	 	d Status("Backup or Restore is not running")
	 	g Prompt
 	}
 	s %1Status=$$Display()
 	i %1Status=0 {
	 	d Status("Switch 10 is set, unable to report status")
		d CLEAR(5,24)
	 	g Prompt
 	}
 	i '(''%1Status) {
		d Status($System.Status.GetErrorText(%1Status))
		g Prompt
 	}
 	i '$d(BEGTIME) {
		d Status("Preparing to start backup or restore")
		d CLEAR(5,24)
	 	g Prompt
 	}
	w /cup(1,1),$$CENTER("Backup/Restore Status",RM)
	w /cup(2,1),$$CENTER("---------------------",RM)
Prompt
	s Key=$$GetKey("(Q)uit => ",1)
 	i (Key=81)!(Key=113) q
 }
 u 0::prevspace
 q 
Display()
 n (%1Pid,RM)
 s %1Status=$$GetVars(%1Pid)
 i '(''%1Status) q %1Status
 i '$d(BEGTIME)&&($g(StartVolume,0)=0) q 1
 s FirstLoop=1
 i $d(BEGTIME) g BackupDisplay
 g RestoreDisplay
RestoreDisplay
 w /cup(1,1),$$CENTER("Restore Status",RM),$j("",80-$x)
 w /cup(2,1),$$CENTER("--------------",RM),$j("",80-$x)
 i DEV="" s DEV=$g(INCDEV)
 i $$IsTape(DEV) q $$Error^%apiOBJ(5001,"Status not available on tape device "_DEV)
 s %1StartTime=$g(StartTime,$h)
 k %1FinishTime
 s %1RestoreFileSize=$fn(##class(%Library.File).GetFileSize(DEV)/(1024*1024),"",0)
 s %1PrevDEV=DEV
 f  {
	d RestoreInfo
	i ($g(%1PercentCompleted)>=90)||(FirstLoop=1)||($g(%1Seconds,0)<120) {
		s Rate=5
		s FirstLoop=0
	} else {
		s Rate=15
	}
	i %1PercentCompleted=100 s Rate=1
	s Key=$$GetKey("(Q)uit => ",Rate)
 	i (Key=81)!(Key=113) {
	 	s %1Status=1
	 	q
 	}
 	s %1PrevPid=%1Pid
	s %1Status=$$GetBackupPid(.%1Pid)
	i '(''%1Status) q
	i %1Pid=0 continue
	i (%1PrevPid=0),(%1Pid'=0) {
		s %1Status=1
		q
	}
	s %1PrevStartVolume=+$g(StartVolume)
	s %1Status=$$GetVars(%1Pid)
	i '(''%1Status) q
	i (%1PrevStartVolume'=$g(StartVolume))&&(StartVolume=1) q
  }
  i $d(%1PrevStartVolume)=0 q %1Status
  i (%1PrevStartVolume'=$g(StartVolume))&&(StartVolume=1) g RestoreDisplay
  q %1Status
RestoreInfo
 q:%1Pid=0
 s %1rinbpoff=$zu(40,2,78) ;mcom offset of rinbp 
 s %1rinbp=$v(%1rinbpoff,-2,"P") ;virtual memory address rinbp in the DBREST job
 q:%1rinbp=0
 Try {
	s %1rinxtblkoff=$zu(40,39,0) ; Offset to counter
 } catch {
  	s %1rinxtblkoff=256 ; MAY NEED TO CHANGE THIS IF PORTED WITHOUT SYSTEM CODE
 }
 s %1rinxtblk=$fn($v(%1rinbp+%1rinxtblkoff,%1Pid,8)/(1024*1024),"",0) ;pid of DBREST job 
 s %1PrevRestoredSize=$g(%1RestoredSize,0)
 s %1RestoredSize=%1rinxtblk
 i '$d(%1PrevPercentCompleted) s %1PrevPercentCompleted=0
 s %1PrevBackupZH=$g(%1BackupZH,$zh)
 s %1BackupZH=$zh
 s %1Seconds=$fn(%1BackupZH-%1PrevBackupZH,"",0)
 i %1RestoredSize>%1RestoreFileSize {
	s %1RestoredSize=%1RestoreFileSize
 	i %1PrevRestoredSize>%1RestoredSize s %1PrevRestoredSize=%1RestoredSize
 }
 s %1MBDone=%1RestoredSize-%1PrevRestoredSize
 i %1Seconds=0 {
	s %1RestoreRate=0
 } else {
	s %1RestoreRate=$fn(%1MBDone/%1Seconds,"",0)
 }
 s %1MBToGo=%1RestoreFileSize-%1RestoredSize
 i %1MBToGo<0 s %1MBToGo=0
 i %1RestoreRate=0 {
	s %1SecondsToGo="N/A"
 } else {
	s %1SecondsToGo=$fn(%1MBToGo/%1RestoreRate,"",0)
 }
 i %1SecondsToGo<0 s %1SecondsToGo=0 
 i +%1SecondsToGo'=0 {
	s %1FinishTime=(+$h*86400+$p($h,",",2)+%1SecondsToGo)
 	s %1FinishTime=(%1FinishTime\86400)_","_(%1FinishTime#86400)
 } else {
	 s %1FinishTime=$g(%1FinishTime,$h)
 }
 i %1RestoreFileSize=0 {
	 s %1PercentCompleted=100
 } else {
	s %1PercentCompleted=$fn(%1RestoredSize/%1RestoreFileSize*100,"",0)
 }
 i %1PercentCompleted>100 s %1PercentCompleted=99
 i %1Pid=0 s %1PercentCompleted=100
 i %1PercentCompleted=100 {
	 s %1TotalTime=(+%1FinishTime*86400+$p(%1FinishTime,",",2))-(+%1StartTime*86400+$p(%1StartTime,",",2))
 } else {
	 s %1TotalTime=(+$h*86400+$p($h,",",2))-(+%1StartTime*86400+$p(%1StartTime,",",2))
 }
 i %1TotalTime=0 s %1TotalTime=1
 s %1TotalRate=$fn(%1RestoreFileSize/%1TotalTime,"",0)
 s %1Line=4
 d Status($s(%1Pid=0:"Completed",DEV="":"Completed",DEV'=%1PrevDEV:"Completed",1:"Running")_$s($d(ze):" - Error: "_ze,1:""))
 w /cup($i(%1Line),1),"Restore process pid:",?30,$s(%1Pid=0:"",1:%1Pid),$j("",80-$x)
 w /cup($i(%1Line),1),"Restore file:",?30,$g(%1PrevDEV,"UNKNOWN"),$j("",80-$x)
 w /cup($i(%1Line),1),"Description:",?30,$g(DESCRIPTION,"UNKNOWN"),$j("",80-$x)
 w /cup($i(%1Line),1),"Type:",?30,$g(BACKTYPE,"UNKNOWN"),$j("",80-$x)
 w /cup($i(%1Line),1),"Start time:",?30,$zdatetime(%1StartTime,3),$j("",80-$x)
 i %1PercentCompleted=100 {
	w /cup($i(%1Line),1),"Finish time:",?30,$zdatetime(%1FinishTime,3),$j("",80-$x)
 } else {
	w /cup($i(%1Line),1),"Estimated finish time:",?30,$zdatetime(%1FinishTime,3),$j("",80-$x)
 }
 w /cup($i(%1Line),1),"Total time (hh:mm:ss):",?30,$ztime(%1TotalTime,9),$j("",80-$x)
 w /cup($i(%1Line),1),"Time remaining (hh:mm:ss):",?30,$ztime(%1SecondsToGo,9),$j("",80-$x)
 w /cup($i(%1Line),1),"Restore file size:",?30,$$memfmt(%1RestoreFileSize),$j("",80-$x)
 w /cup($i(%1Line),1),"Restore size completed:",?30,$$memfmt(%1RestoredSize),$j("",80-$x)
 i %1PercentCompleted=100 {
	w /cup($i(%1Line),1),"Restore rate:",?30,$$memfmt(%1TotalRate),"/sec",$j("",80-$x)
 } else {
	w /cup($i(%1Line),1),"Current restore rate:",?30,$$memfmt(%1RestoreRate),"/sec",$j("",80-$x)
 }
 w /cup($i(%1Line),1),"% Completed",?30,%1PercentCompleted,$j("",80-$x)
 q 
BackupDisplay
 w /cup(1,1),$$CENTER("Backup Status",RM),$j("",80-$x)
 w /cup(2,1),$$CENTER("-------------",RM),$j("",80-$x)
 i $$IsTape(DEV) q $$Error^%apiOBJ(5001,"Status not available on tape devices")
 s %1Status=$$GetTotalDBSize(.%1TotalDBSizeMin)
 i '(''%1Status) q
 s PREVBACKHDATE=BACKHDATE
 k %1FinishTime
 s %1StartTime=$h
 f  {
	d BackupInfo
	i ($g(%1PercentCompleted)>=90)||(FirstLoop=1)||($g(%1Seconds,0)<120) {
		s FirstLoop=0
		s Rate=5
	} else {
		s Rate=15
	}
 	i $e(%1PercentCompleted)'=$e(%1PrevPercentCompleted) ||
 	  ((%1PercentCompleted>96)&&(%1PercentCompleted'=%1PrevPercentCompleted)) {
	 	s StartCalcTime=$zh
	 	s %1Status=$$GetTotalDBSize(.%1TotalDBSizeMin)
		s %1PrevPercentCompleted=%1PercentCompleted
		i '(''%1Status) q
		s CalcTime=$zh-StartCalcTime
		d Status("Running")
		i CalcTime<Rate s Key=$$GetKey("(Q)uit => ",Rate-CalcTime)
		u 0:(:"F") ;May take a while, flush input skip prompt
 		Continue
 	}
	i %1PercentCompleted=100 s Rate=1
	s Key=$$GetKey("(Q)uit => ",Rate)
 	i (Key=81)!(Key=113) {
	 	s %1Status=1
	 	q
 	}
 	s %1PrevPid=%1Pid
	s %1Status=$$GetBackupPid(.%1Pid)
	i '(''%1Status) q
	i %1Pid=0 continue
	i (%1PrevPid=0),(%1Pid'=0) {
		s %1Status=1
		q
	}
	s %1Status=$$GetVars(%1Pid)
	i '(''%1Status) q
	i BACKHDATE'=PREVBACKHDATE {
		s %1Status=$$Error^%apiOBJ(5001,"Backup has restarted")
		s PREVBACKHDATE=BACKHDATE
  		q
	}
  }
  q %1Status
BackupInfo
 i '$d(%1PrevPercentCompleted) s %1PrevPercentCompleted=0
 s %1PrevBackupSize=$g(%1BackupSize,0)
 s %1PrevBackupZH=$g(%1BackupZH,$zh)
 s %1BackupSize=$$GetBackupSize(DEV)
 s %1BackupZH=$zh
 i %1PrevBackupSize=0 s %1PrevBackupSize=%1BackupSize
 s %1Seconds=$fn(%1BackupZH-%1PrevBackupZH,"",0)
 s %1MBDone=%1BackupSize-%1PrevBackupSize
 i %1Seconds=0 {
	s %1BackupRate=0
 } else {
	s %1BackupRate=$fn(%1MBDone/%1Seconds,"",0)
 }
 s %1MBToGo=%1TotalDBSizeMin-%1BackupSize
 i %1MBToGo<0 s %1MBToGo=0
 i %1BackupRate=0 {
	s %1SecondsToGo="N/A"
 } else {
	s %1SecondsToGo=$fn(%1MBToGo/%1BackupRate,"",0)
 }
 i +%1SecondsToGo'=0 {
	s %1FinishTime=(+$h*86400+$p($h,",",2)+%1SecondsToGo)
 	s %1FinishTime=(%1FinishTime\86400)_","_(%1FinishTime#86400)
 } else {
	 s %1FinishTime=$g(%1FinishTime,$h)
 }
 s %1PercentCompleted=$fn(%1BackupSize/%1TotalDBSizeMin*100,"",0)
 i %1PercentCompleted>100 s %1PercentCompleted=99
 i %1Pid=0 s %1PercentCompleted=100
 i %1PercentCompleted=100 {
	 s %1TotalTime=(+%1FinishTime*86400+$p(%1FinishTime,",",2))-(+%1StartTime*86400+$p(%1StartTime,",",2))
 } else {
	 s %1TotalTime=(+$h*86400+$p($h,",",2))-(+%1StartTime*86400+$p(%1StartTime,",",2))
 }
 i %1TotalTime=0 s %1TotalTime=1
 s %1TotalRate=$fn(%1BackupSize/%1TotalTime,"",0)
 s %1Line=4
 d Status($s(%1Pid=0:"Completed",1:"Running")_$s($d(ze):" - Error: "_ze,1:""))
 w /cup($i(%1Line),1),"Backup process pid:",?30,$s(%1Pid=0:"",1:%1Pid),$j("",80-$x)
 w /cup($i(%1Line),1),"Backup file:",?30,$g(DEV,"UNKNOWN"),$j("",80-$x)
 w /cup($i(%1Line),1),"Description:",?30,$g(DESCRIPTION,"UNKNOWN"),$j("",80-$x)
 w /cup($i(%1Line),1),"Log file:",?30,$g(logfile,"UNKNOWN"),$j("",80-$x)
 w /cup($i(%1Line),1),"Type:",?30,$g(TYPE,"UNKNOWN"),$j("",80-$x)
 w /cup($i(%1Line),1),"Start time:",?30,$zdatetime(%1StartTime,3),$j("",80-$x)
 i %1PercentCompleted=100 {
 	w /cup($i(%1Line),1),"Finish time:",?30,$zdatetime(%1FinishTime,3),$j("",80-$x)
 } else {
	w /cup($i(%1Line),1),"Estimated finish time:",?30,$s($g(TYPE)="Full":$zdatetime(%1FinishTime,3),1:"N/A"),$j("",80-$x)
 }
 w /cup($i(%1Line),1),"Total time (hh:mm:ss):",?30,$ztime(%1TotalTime,9),$j("",80-$x)
 w /cup($i(%1Line),1),"Time remaining (hh:mm:ss):",?30,$s($g(TYPE)="Full":$ztime(%1SecondsToGo,9),1:"N/A"),$j("",80-$x)
 w /cup($i(%1Line),1),"Estimated backup size:",?30,$s($g(TYPE)="Full":$$memfmt(%1TotalDBSizeMin),1:"N/A"),$j("",80-$x)
 w /cup($i(%1Line),1),"Current backup size:",?30,$$memfmt(%1BackupSize),$j("",80-$x)
 i %1PercentCompleted=100 {
	w /cup($i(%1Line),1),"Backup rate:",?30,$$memfmt(%1TotalRate),"/sec",$j("",80-$x)
	w /cup($i(%1Line),1),"% Completed",?30,%1PercentCompleted,$j("",80-$x)
 } else {
	w /cup($i(%1Line),1),"Current Backup rate:",?30,$$memfmt(%1BackupRate),"/sec",$j("",80-$x)
	w /cup($i(%1Line),1),"% Completed",?30,$s($g(TYPE)="Full":%1PercentCompleted,1:"N/A"),$j("",80-$x)
 }
 q
IsTape(DEV) {
 I DEV?2N,$G(^%IS(DEV,0))="Magnetic tape" q 1
 q 0
}
memfmt(mem)
 q:(mem<=0) 0
 if (mem>1048576) {
    s unit="TB",mem=mem/10485764
 } elseif (mem>1024) {
    s unit="GB",mem=mem/1024
 } else {
    s unit="MB"
 }
 q $normalize($fn($e(mem,1,6),"",2),10)_unit	; Remove trailing zeroes and trailing period
GetBackupPid(Pid) {
 s $zt="Error"
 i $SYSTEM.Util.GetSwitch(10) q 0
 s Pid=0
 Set Rset=##class(%Library.ResultSet).%New("%SYS.LockQuery:List")
 s Status=Rset.Execute("")
 i '(''Status) q Status
 While Rset.Next() {
 	s Lock=Rset.Data("LockString")
 	i Lock="^DBACK" {
	 	s Pid=Rset.Data("Owner")
	 	q
 	}
 }
 q 1
Error s $zt=""
 q $$Error^%apiOBJ(5002,$ze)
}
GetVars(Pid) {
 s $zt="Error"
 i $SYSTEM.Util.GetSwitch(10) q 0
 q:Pid=0 1
 Set Rset=##class(%Library.ResultSet).%New("%SYS.ProcessQuery:VariableByPid")
 s Status=Rset.Execute(Pid,"")
 i '(''Status) q Status
 While Rset.Next() {
 	Try {
	 	s Var=$e(Rset.Data("Name"),1,7)
	 	i Var="%ST" continue
	 	i Var="dbrtext" continue
 		s @Rset.Data("Name")=Rset.Data("Value")
 	} catch {
	}
 }
 q 1
Error s $zt=""
 q $$Error^%apiOBJ(5002,$ze)
 }
GetTotalDBSize(%1TotalDBSizeMin)
 s $zt="Error"
 s (%1TotalDBSizeMin)=0
 s %1Dir=""
 s %1Size=0
 s %1Status=1
 d Status($s(%1Pid=0:"Completed",1:"Running")_" (Calculating)")
 f  {
	s %1Dir=$o(DIRNAM(%1Dir)) q:%1Dir=""
	s %1DBObj=##class(SYS.Database).%OpenId(%1Dir)
	s %1Status=%1DBObj.GetFreeSpace(%1Dir,.%1Free)
	s %1Size=%1Size+(%1DBObj.Size-%1Free)
 }
 s %1TotalDBSizeMin=$fn(%1Size*1.03125,"",0) ; 3% overhead
 q 1
Error s $zt=""
 q $$Error^%apiOBJ(5002,$ze)
GetBackupSize(DEV) Public {
 s $zt="Error"
 s Size=$fn(##class(%Library.File).GetFileSize(DEV)/(1024*1024),"",0)
 q Size
Error s $zt=""
 i $d(File) d ##class(%Library.File).Delete(File)
 q 0
Directories
 s %1Dir=""
 w !,"Directory"
 w !,"---------"
 f  {
	s %1Dir=$o(DIRNAM(%1Dir)) q:%1Dir=""
 	w !,%1Dir
 }
 q
}
CENTER(str,rm) {
 Q $J(str,$L(str)+rm\2)
}
CLEAR(first,last)
 w /cup(first,1)
 f i=first:1:last w /cup(i,1),Blank 
 w /cup(1,1)
 q
GetKey(Prompt,Rate) w /cup(23,1)
 u 0:(:"+S")
 w Prompt
 r *Key:Rate
 u 0:(:"-S")
 q Key 
Status(Msg)
 w /cup(4,1),"Status:",?30,Msg,$j("",80-$x)
 q 
YN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YN"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"yn","YN") I "^YN"'[R W "  enter Yes or No, please"
 S POP=(R="^") W $E($S(R="N":"No",R="Y":"Yes",1:""),$L(X)+1,3) Q R

BITMAPSCAN^INT^1^67214,47330
BITMAPSCAN ; scan bitmaps
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	n db,blk,dirinfo,curblks,blksize
	r !,"Database? ",db
	if $E(db,1,2)="^^" s db=$E(db,3,$L(db))
	r !,"Enter bitmap block to dump? ",blk
    Do INT(db,blk)
	Quit
INT(db,blk) [] PUBLIC
{
	r !,"Display bitmap detail? <N> ",detail
	if "Yy"[$E(detail_"X") {
	   s detail=1
	} else {
	   s detail=0
	}
	do dump(db,blk,detail)
	q 1
}
dump(db,block,detail) {	
    s dirinfo=$zu(49,db)
	s blksize=$p(dirinfo,",",2),curblks=$p(dirinfo,",",22)
	if blksize=2048 w ! d $SYSTEM.Status.DisplayError($$Error^%apiOBJ(344)) quit
	if block'=+block || (block < 1) w ! d $SYSTEM.Status.DisplayError($$Error^%apiOBJ(6075,block)) quit
	if block > curblks w ! d $SYSTEM.Status.DisplayError($$Error^%apiOBJ(341,block)) quit
	s i=blksize/4096
	s masteroff=$ZU(40,0,51)
	s mastercnt=i
	s j=$ZU(40,0,51)+(i*4)
	s secoff=j
	s dataoff=(((i * 32) - i - 1) * 4) + j
	s datacnt = (blksize-dataoff)/4
	s seccnt = (dataoff - secoff)/4
	o 63:"^^"_db
	v block
	if $V(32,0,-8)'="CacheMap" w ! d $SYSTEM.Status.DisplayError($$Error^%apiOBJ(6076)) c 63 quit
	s type=$V(40,0,-1)
	if detail w !,"Master bitmap:"
	do load(detail,masteroff,seccnt,.mlist)
	if detail w !!,"Secondary bitmap: "
	do load(detail,secoff,datacnt,.seclist)
	if detail w !!,"Data bitmap: "
	do load(detail,dataoff,datacnt*32,.datalist)
	s mapcnt=$v(28,0,4)
	if detail w !!,"Map summary count = ",mapcnt
	c 63
	w !!,"Analyzing bitmaps in block #",block,", type=",type
	do compare("Master",.mlist,"Secondary",.seclist)
	do compare("Secondary",.seclist,"Tertiary",.datalist)
	s bitcnt=0
	s d=""
	f  s d=$O(datalist("bits",d)) q:d=""  s bitcnt=bitcnt+1
	if bitcnt=mapcnt {
		w !,"Summary count is ok"
	} else {
		w !,"Summary count of ",mapcnt," doesn't match actual count of ",bitcnt
	}
	q	
}
compare(parname,parlist,childname,childlist) {
	merge parent=parlist("bits")
	merge child=childlist("words")
	s d=$O(parent(""))
	while d'="" {
		if '$D(child(d)) s missing(d)=""
		k child(d)
		s d=$O(parent(d))
	}
	if '$D(child),'$D(missing) w !,parname,"/",childname," ok" q
	if $D(child) {
		w !,"The following words are marked in ",childname," but not in ",parname
		s d=$O(child(""))
		w !,?5
		while d'="" {
			w:$X>70 !,?5
			w d," "
			s d=$O(child(d))
		}
	}
	if $D(missing) {
		w !,"The following words are marked in ",parname," but not in ",childname
		s d=$O(missing(""))
		w !,?5
		while d'="" {
			w:$X>70 !,?5
			w d," "
			s d=$O(missing(d))
		}
	}
}
load(detail,startoff,bitcnt,list) {
	; startoff = byte offset of this bitmap
	; bitcnt = # of bits to check
	s base=0
	s i=startoff
	while (bitcnt>0) {
		s v=$V(i,0,4)
		if bitcnt<32 {
			s bits=bitcnt
			s k=0  ; k = (2^bits)-1
			do {
				s k=(k*2)+1
				s bits=bits-1
			} while (bits)
			s v=$zboolean(v,k,1)  ; v = v & k;
		}
		if (v) {
		    s list("words",base/32)=""
			if detail w !,?5,"[",base/32,"] ",?15
			for j=0:1:31 {
			   if v#2 {
			      if detail w:$X>70 !,?15 w base+j," " 
				  s list("bits",base+j)=""
			   }
			   s v=v\2
			   quit:'v
			}
		}
		s base=base+32
		s bitcnt=bitcnt-32
		s i=i+4
	}
}

BLKCHANG^INT^1^67214,47330
BLKCHANG ;Octal block edit.
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ;
 S $ZT="EXIT^"_$ZN,$ZE=""
 n DIRNAM,blksiz,dirinfo,BLK,LOC,DEND,EDIT,DEC,NEW,OLD,max,POP,%A,mtemp1,GD
 D ASK^%SYS.FILE Q:DIRNAM=""  S $ZE="" O 63:"^^"_DIRNAM
 if $zbitget($zversion(0),21) {
    n blksiz,dirinfo
    s dirinfo=$zu(49,DIRNAM)
    if dirinfo<0 {u 0 w !,"Directory ",DIRNAM," is not mounted" q  }
    else {
       s blksiz=$p(dirinfo,",",2)
    }
	s mirrorDB=$zb(+$p(dirinfo,",",17),+$ZU(40,8,28),1)
 } else {
    s blksiz=2048
 }
 s max=blksiz-2
BLOCK R !,"Block: ",BLK,! G EXIT:BLK=""
 I BLK["?" W ! DO  W ! G BLOCK
 . W !?4,"Enter a block number to examine; this should be a number"
 . W !?4,"between 1 and "_DEND_"."
 I BLK<1 W *7," no negative block numbers, please.",! G BLOCK
 I BLK>DEND W *7,"  block number too large.",! G BLOCK
 S EDIT=0
 V BLK
LOC R !,"Location: ",LOC S LOC=$$UC(LOC) G END:LOC=""
 I LOC["?" W ! DO  W ! G LOC
 . W !?4,"Enter a location within this block to examine/change."
 . W !?4,"Enter a location either as a decimal number (with a"
 . W !?4,"trailing '.'), or as a hexadecimal number.  Valid location"
 . W !?4,"values are even numbers between 0 and "_max_" inclusive."
 ;
 I LOC["." S DEC=LOC,LOC=$$Hex(+LOC) ;DEC is decimal, LOC is hex
 E  S DEC=$$Dec(LOC) ;convert hex to dec
 ;
 I DEC="" W " invalid number" G LOC ;not a good hex number
 I LOC="" W " invalid number" G LOC ;not a good dec number
 ;
 I DEC#2 W " ???  even locations only, please" G LOC
 I LOC<0 W " ???  no negative locations" G LOC
 I DEC>max W " ???  maximum location is "_max G LOC
 W ?20,LOC,?26,"/" S OLD=$V(DEC,0,2) W $$Hex(OLD),?38,"("_OLD_".)"
 R ?50," => ",NEW S NEW=$$UC(NEW) G LOC:NEW=""
 ;
 I NEW["?" W ! DO  W ! G LOC
 . W !?4,"Enter a new value for this location.  Enter as either a"
 . W !?4,"decimal number (with a trailing '.'), or as a hexidecimal"
 . W !?4,"number.  Valid values are in the range 0 to 65535 inclusive"
 ;
 I NEW'["." S NEW=$$Dec(NEW) I 1  ;convert to dec
 E  S NEW=$$Dec($$Hex(+NEW)) ;convert to hex + back -- make sure!
 ;
 I NEW="" W "  invalid value" G LOC ;not a good hex/dec number
 I NEW<0 W "  negative numbers are not allowed" G LOC
 I NEW>65535 W "  value too large" G LOC
 ;
 V DEC:0:2:NEW W " *set" S EDIT=1 G LOC
END I 'EDIT W !,"(no changes to this block)",! G BLOCK
 if $G(mirrorDB) w "Change will not be reflected on other mirror members.",!
 I $$YN("Write block to disk","N")'="Y" W "  Not written.",! G BLOCK
 I BLK'=0 d WriteBlock^DMREPAIR(BLK) W "  Written.",! G BLOCK
 W " ??? non-positive block number???",! G BLOCK
EXIT S $ZT="" C 63 I $ZE]"" W !,$ZE
 Q
Hex(x) ;return hex value of 'x'
 I (x="")!(x'?1.N) Q "" ;not a valid decimal
 N b,z S b=x,z="" F  S z=$E("0123456789ABCDEF",b#16+1)_z,b=b\16 Q:'b
 Q z
Dec(x) ;return the decimal value of hex 'x'
 S x=$TR(x,"abcdef","ABCDEF") ;make sure it is uppercase hex digits
 I (x="")!($TR(x,"ABCDEF")'?.N) Q "" ;not a valid hex
 N b,z,f,c S z="",b=x F  S c=$E(b),b=$E(b,2,$L(b)) Q:c=""  DO  Q:'f
 . S f=$F("0123456789ABCDEF",c) I f S z=z*16+(f-2#16)
 Q z
YN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YN"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"yn","YN") I "^YN"'[R W "  enter Yes or No, please"
 S POP=(R="^") W $E($S(R="N":"No",R="Y":"Yes",1:""),$L(X)+1,3) Q R
UC(x) q $zcvt(x,"u")

BLKCOL^INT^1^67214,47330
BLKCOL	; Sample and analyze block collisions
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ;
 s $ztrap="ERR^BLKCOL"
 l +^SYS("BLKCOL"):5 e  w !!,"Unable to Lock ^SYS(""BLKCOL""), only one process may run BLKCOL.",!! q
 n array,sec,wait,io,details,nblocks,file,format
 s io=$io
 w !,"Block Collision Analysis",!
 w !,"How many seconds should we sample: <10> " r sec s:sec="" sec=10
 g:sec=0 exit
 w !,"How long to wait (ms) between each sample: <10> " r wait s:wait="" wait=10
 w !,"Collect routine details? <Y> " r details s details=$s(details="":1,"Yy"[details:1,1:0)
 s format="D",nblocks=0
fmt	; ask for format
 i details {
	 w !,"Format for 'T'op counts, 'D'isplay all, 'S'orted CSV, 'H'ot spot, or 'R'aw CSV: <T> "
	 r format s:format="" format="T" s format=$zcvt(format,"U")
	 i "TDSRH"'[format {
		 w !,"Enter 'T', 'D', 'S', or 'R' to select output format."
		 w !?5,"'T' display the blocks (and globals/routines) with the most collisions."
		 w !?5,"'D' is a simple, readable format with details for each block."
		 w !?5,"'S' sorts and counts by block number and routines, and uses CSV format."
		 w !?5,"'R' records each collision in CSV format."
		 w !?5,"'H' display hot spots in routines."
		 g fmt
	 }
	 if format="T"||(format="H") {
		 w !,"Number of blocks to display: <10> "
		 r nblocks s nblocks=+nblocks s:nblocks=0 nblocks=10
		 s details=$select(format="T":2,1:3)
	 }
 }
file	;
 w !,"Output to file: <0> " r file s:file="" file=0
 i file'=0 {
	 o file:"NW":2 e  w !!,"Unable to open file ",file,! g file
	 u file
	 w:format="D" !,"Block collisions - sampled ",sec," seconds with ",wait," ms. wait at ",$zdt($h),!!
 }
 u io w !!,"Sampling ... (enter key to interrupt)",! i file'=0 u file
 d RUN(sec,wait,details,format,nblocks,1)
 i file'=0 c file u io
exit
 l -^SYS("BLKCOL")
 q
 ;
 ; Non-interactive entry point, can be called to re-direct output
 ; 'sec' = second to collect, 'wait' = ms to wait for each sample
 ; 'details' = 1/0 to do new routine details collection
 ;
RUN(sec,wait,details,format,nblocks,interactive=0) PUBLIC {
	s $ztrap="RUNERR"
 	l +^SYS("BLKCOL"):5 e  w !!,"Unable to Lock ^SYS(""BLKCOL""), only one process may run BLKCOL.",!! q
	i "TDH"'[format d CSV(format,sec,wait) l -^SYS("BLKCOL") q
	s array=""
    if interactive {
	    for  read tmp:0 quit:'$test
    }
	d COLLECT(sec,wait,details,.array,interactive,.blkcol)
	i format="D" d DISPLAY(.array,details,.blkcol)
	i format="T" d TOP(.array,nblocks,.blkcol)
	i format="H" d HotSpot(.array,nblocks,.blkcol)
	l -^SYS("BLKCOL")
	q
RUNERR	; Trap errors and CTRL-C
	s $ztrap=""
	l -^SYS("BLKCOL")
	i $ze]"",$ze'["<INTERRUPT>" w !!,"Unexpected error - ",$ze,!!
	q	
}
 ;	
COLLECT(sec,wait,details,array,interactive,blkcol) PUBLIC {
	s col=0,to=$zh+sec
	f cnt=1:1 {
		; 1.job_id, 2.bufnum, 3.block, 4.glo_sfn, 5.rou_sfn, 6.routine, 7.line, 
		; 8.owner, 9.owner rou_sfn, 10.owner routine
		set info=$zu(190,17)
		if info]"" {
			s blk=$p(info,",",3),sfn=$p(info,",",4)
			s wrou=$p(info,",",5)_"_"_$p(info,",",6),line=$p(info,",",7)
			; don't sort by owner for 'Top' display
			if details=2 {
				s orou=0
			} else {
				s orou=$p(info,",",9)_"_"_$p(info,",",10)
			}
			if details=3 {
				if $p(info,",",5)'=-1 {
					if $i(blkcol(0,wrou)),$i(blkcol(0,wrou,line))
				}
				if $p(info,",",9)'=-1 {
					if $i(blkcol(1,orou)),$i(blkcol(1,orou,wrou)),$i(blkcol(1,orou,wrou,line))
				}
			} else {
				if $i(blkcol(blk,orou,wrou,line)),$i(array(sfn,blk))
			}
			s col=col+1
			if interactive,col#100=0 w "#"
		}
		if interactive {
			r tmp:0 i $t q
		}
		h wait/1000
		q:to<$zh
	}
	s array=cnt_","_col
	q
}
 ;
DISPLAY(array,details,%blkcol) {
	w !!,$p(array,",",2)," block collisions in ",$p(array,",",1)," samples."
	s (sfn,blk)=""
	f  {
	     s sfn=$o(array(sfn)) q:sfn=""
	     try {
		     s dir=$zu(49,sfn,3)
	     } catch verr {
		     if verr.Name="<FUNCTION>" {
			     w !!,"Error accessing SFN "_sfn,!!
			     continue
		     } else {
			     throw verr
		     }
	     }
	     i +dir'=0 w !,"Remote directory"
	     e  w !!,"Database: ",$p(dir,"^",2)
	     w !,"   Block # and (collison counts)"
	     f  {
		     s blk=$o(array(sfn,blk)) q:blk=""
		     s num=array(sfn,blk)
		     w !,?3,blk,?10,"(",num,")",?15," "
		     f i=1:1:num w "*"
	     }
	     ; print glo refs
	     i +dir=0,$p(array,",",2) {
	         w !!,"   Global references (first - last in block)"
	         o 63:"#"_sfn
	         f  {
		         s blk=$o(array(sfn,blk)) q:blk=""
		         ; trap BLOCKNUMBER error, possible SFN/blk# mismatch?
		         try {v blk}
		         catch verr {
			         if verr.Name="<BLOCKNUMBER>" {
				         w !,?3,blk,?10,"()",?20,"Error VIEWing block, possible SFN/BLOCK# mismatch."
				         continue
				     } else {
					     throw verr
				     }
		         }
		         s (if,fnode,lnode)=""
		         s rc=$$GetNodeReferences^DMREPAIR(0,.if,.fnode)
		         i rc=1 s rc=$$GetNodeReferences^DMREPAIR(-1,.if,.lnode)
		         w !,?3,blk,?10,"("
		         s type=$v($zu(40,32,1),0,1)
	             w $case(type,2:"Ptr",6:"BotPtr",8:"Data",9:"GloDir",24:"BigData",66:"TopPtr",70:"T/BPtr",16:"Map",13:"Security",:type),") "
	             i rc=1 w ?20,fnode," - ",lnode
		         else  w ?20,"Error = ",rc
	         }
	         c 63
	     }
	}
	i details,$p(array,",",2) {
		w !!,"   Routines involved in collisions (SFN in parentheses)"
		s node="%blkcol",lastblk=""
		;%blkcol(blk,orou,wrou,line)=cnt
		f  {
			s node=$q(@node) q:node=""
			i lastblk'=$qs(node,1) w !,"   Block ",$qs(node,1) s lastblk=$qs(node,1)
			s own=$qs(node,2),wait=$qs(node,3),line=$qs(node,4)
			w !,"      ",@node," at ^",$p(wait,"_",2),"+",line,"(",$p(wait,"_",1),")"
			w ", owner in ^",$p(own,"_",2),"(",$p(own,"_",1),")"
		}
	}
	q
}
TOP(array,nblocks,%blkcol) {
	w !!,$p(array,",",2)," block collisions in ",$p(array,",",1)," samples.",!
	q:'$p(array,",",2)
	; sort by collision count
	s (sfn,blk)=""
	f  {
	     s sfn=$o(array(sfn)) q:sfn=""
	     f  {
		     s blk=$o(array(sfn,blk)) q:blk=""
		     s num=array(sfn,blk)
		     s sort(-num,blk)=sfn
	     }
	}
	s (sfn,blk,num)=""
	w !,"Block # (count) - Global refs (first - last in block) - Routine refs (SFN)"
	f  {
	     s num=$o(sort(num)) q:num=""  q:nblocks<1
	     f  {
		     q:nblocks<1
		     s blk=$o(sort(num,blk)) q:blk=""
		     s nblocks=nblocks-1,sfn=sort(num,blk)
		     w !!,blk,?10,"(",-num,")",?15," "
		     try {
			     s dir=$zu(49,sfn,3)
		     } catch verr {
			     if verr.Name="<FUNCTION>" {
				     w !!,"Error accessing SFN "_sfn,!!
				     continue
			     } else {
				     throw verr
			     }
		     }
		     i +dir'=0 w " (remote directory)"
		     e  w "in ",$p(dir,"^",2)
		     ; print glo refs
		     i +dir=0 {
			     o 63:"#"_sfn
		         ; trap BLOCKNUMBER error, possible SFN/blk# mismatch?
		         try {v blk}
		         catch verr {
			         if verr.Name="<BLOCKNUMBER>" {
				         w !,?3,blk,?10,"()",?20,"Error VIEWing block, possible SFN/BLOCK# mismatch."
				         continue
				     } else {
					     throw verr
				     }
		         }
		         s (if,fnode,lnode)=""
		         s rc=$$GetNodeReferences^DMREPAIR(0,.if,.fnode)
		         i rc=1 s rc=$$GetNodeReferences^DMREPAIR(-1,.if,.lnode)
	             if rc=1 {
		             w !,?2,fnode," - ",lnode," ("
			         s type=$v($zu(40,32,1),0,1)
		             w $case(type,2:"Ptr",6:"BotPtr",8:"Data",9:"GloDir",24:"BigData",66:"TopPtr",70:"T/BPtr",16:"Map",13:"Security",:type),") "
	             }
		         else {
			         w !,?2,"Error getting global, error = ",rc
		         }
		         c 63
		     }
			; sort routines for this block ; %blkcol(blk,orou,wrou,line)=cnt
			s node="%blkcol("_blk_")" k rsort
			f  {
				s node=$q(@node) q:node=""  q:blk'=$qs(node,1) 
				s own=$qs(node,2),wait=$qs(node,3),line=$qs(node,4),cnt=@node
				s rsort(-cnt,wait,line)=blk
			}
			s (cnt,wait,line)=""
			f  {
				s cnt=$o(rsort(cnt)) q:cnt=""
				f  {
					s wait=$o(rsort(cnt,wait)) q:wait=""
					f  {
						s line=$o(rsort(cnt,wait,line)) q:line=""
						w !,?4,-cnt," at ^",$p(wait,"_",2),"+",line,"(",$p(wait,"_",1),")"
					}
				}
			}
	     }
	}
	q
}
CSV(format,sec,wait) PUBLIC {
	; collect detail routine block collision data to a CSV file
	k ^||BLKCOL
	i format="S" w "SFN,Block,WaitRoutine,WaitSFN,OwnRoutine,OwnSFN,Count,Global,GloRef1,GloRef2,BlkType"
	e  w "Global,WaitJob,BuffNum,Block,SFN,WaitSFN,WaitRoutine,WaitLine,OwnerJob,OwnerSFN,OwnerRoutine"
	s cnt=0,col=0,to=$zh+sec
	f  {
		; job_id,bufnum,block,glo_sfn,rou_sfn,routine,line,owner,rou_sfn,routine
		s info=$zu(190,17),len=$l(info,",")
		i info]"" {
			if format="R" {
				s bn=$p(info,",",2) w !,$p($zu(190,16,bn),",",4),",",info
			} else {
				s bn=$p(info,",",2),blk=$p(info,",",3),sfn=$p(info,",",4)
				s wsfn=$p(info,",",5),wrou=$p(info,",",6),line=$p(info,",",7)
				s osfn=$p(info,",",9),orou=$p(info,",",10)
				s:wrou="" wrou="_Unknown_" s:orou="" orou="_Unknown_"
				s wrou=wrou_"+"_line
				s ^||BLKCOL(sfn,blk,wrou,wsfn,orou,osfn)=$g(^||BLKCOL(sfn,blk,wrou,wsfn,orou,osfn))+1
			}
		}
		h wait/1000
		q:to<$zh
	}
	q:format="R"
	; get global refs for each block
	s sfn="",blk=""
	f  {
		s sfn=$o(^||BLKCOL(sfn)) q:sfn=""
		i sfn'=-1 o 63:"#"_sfn
        f  {
	        s blk=$o(^||BLKCOL(sfn,blk)) q:blk=""
	        i sfn=-1 s ^||BLKCOL(sfn,blk)="Unknown;;;" continue
	        try {v blk}
	        catch verr {
		        s ^||BLKCOL(sfn,blk)=verr.Name_";;;"
		        continue
	        }
	        s (if,fnode,lnode)=""
	        s rc=$$GetNodeReferences^DMREPAIR(0,.if,.fnode)
	        i rc=1 s rc=$$GetNodeReferences^DMREPAIR(-1,.if,.lnode)
	        s t=$v($zu(40,32,1),0,1)
            s type=$case(t,2:"Ptr",6:"BotPtr",8:"Data",9:"GloDir",24:"BigData",66:"TopPtr",70:"T/BPtr",16:"Map",13:"Security",:t)
            i rc=1 s ^||BLKCOL(sfn,blk)=$p($p(fnode,"^",2),"(")_";"_fnode_";"_lnode_";"_type
	        e  s ^||BLKCOL(sfn,blk)=rc_";;;"
        }
        c 63
	}
	; write sorted counts and info
	s glo="^||BLKCOL"
	f  {
		s glo=$q(@glo) q:glo=""
		s len=$ql(glo) i len=2 continue
		s sfn=$qs(glo,1),blk=$qs(glo,2)
		w ! f sub=1:1:len w $qs(glo,sub),","
		w @glo
		f p=1:1:4 w ",","""",$p(^||BLKCOL(sfn,blk),";",p),""""
	}
	q
}
ERR	; Trap errors and CTRL-C
	s $ztrap=""
	l -^SYS("BLKCOL")
	i $ze]"",$ze'["<INTERRUPT>" w !!,"Unexpected error - ",$ze,!!
	q
HotSpot(array,top=10,%blkcol) public {
	w !!,$p(array,",",2)," block collisions in ",$p(array,",",1)," samples.",!!
	q:'$p(array,",",2)
	For i=0,1 {
		Set a=""
		For {
			Set a=$order(%blkcol(i,a),1,c1) Quit:a=""
			Set blkcol(i,-c1,a)=""
			Set b=""
			For {
				Set b=$order(%blkcol(i,a,b),1,c2) Quit:b=""
				Set blkcol(i,-c1,a,-c2,b)=""
			}
		}
	}
	For i=0,1 {
		Set title=$select(i=0:"Sorted by routine/line that waits for block ownership",1:"Sorted by routine that owns the block")
		Write !,title,!,$translate($justify("",$length(title))," ","_"),!!
		Set c1="",x=0
		For {
			Set c1=$order(blkcol(i,c1)) Quit:c1=""
			Set a=""
			For {
				Set a=$order(blkcol(i,c1,a)) Quit:a=""
				If $increment(x)>top Quit
				Write "(",-c1,") ",$piece(a,"_",2),!
				Set c2="",y=0
				For {
					Set c2=$order(blkcol(i,c1,a,c2)) Quit:c2=""
					Set b=""
					For {
						Set b=$order(blkcol(i,c1,a,c2,b)) Quit:b=""
						If $increment(y)>(top\2) Quit
						If i=0 {
							Set sfn=$piece(a,"_",1)
							If '$data(db(sfn)) {
								Try {
									Set dbinfo=$zu(49,+sfn,3)
									If $piece(dbinfo,"^")=0 {
										Set db(sfn)=$piece(dbinfo,"^",2)
									} Else {
										Set db(sfn)=""
									}
								} Catch {
									Set db(sfn)=""
								}
							}
							Write "    (",-c2,") +",b,"^",$piece(a,"_",2)
							If db(sfn)'="",$piece(a,"_",2)'="" {
								Try {
									Set line=$get(^|"^^"_db(sfn)|ROUTINE($piece(a,"_",2),0,b))
									If line'="" Write " : ",line
								} Catch {
								} 
							}
							Write !					
						} Else {
							Write "    (",-c2,") +",$piece(b,"_",2),!
						}
					}
					If y>(top\2) Quit
				}
			}
			If x>top Quit
		}
	}
}

BLKDUMP^INT^1^67214,47330
BLKDUMP ;Display Block Contents;  $Change: 7440104 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	; Revision: $Id: //iris/2024.1.3/databases/sys/rtn/diagnostic/blkdump.mac#1 $
    New DIR,BLK,DIRNAM,GD,IO,OI,IOBS,IOF,IOM,IOPAR,IOSL,IOST,IOT,%A,%ANS,
	DEND,POP,RMSDF,MSYS,mtemp1,IOMS
    Set IOMS=$System.Device.GetRightMargin()
    Set OI=$I,POP=0
    Do OUT^%IS
    Quit:POP
    Set $ZT="EXIT",$ZE=""
    Do ASK^%SYS.FILE
    Set DIR=DIRNAM
    Goto:DIRNAM="" EXIT2 ;JFP063
    O 63:"^^"_DIR
BLK For {
	Use 0
	Write !,"Block number :"
	Read BLK
	Goto EXIT2:BLK=""
	If BLK>0,BLK\1=BLK {
	    View BLK
	    Do SHOW
	} Else {
	    Write *7," Only positive integer block numbers, please.",!
	}
    }
INT(DIR,BLK) ;
    New IO,OI
    Set (IO,OI)=$I
    O 63:"^^"_DIR
    If BLK>0,BLK\1=BLK {
        View BLK
	Do SHOW
    } Else {
	Write !,"Bad Block number"
    }
    Quit
EXIT ;
    Set $ZT=""
    If $P($ZE,">",2)="BLK^BLKDUMP",$P($ZE,">")'="<INTERRUPT" {
	Write !,"Invalid block number.",!
	Set $ZT="EXIT"
	Goto BLK     ; JCS009
    }
    If $ZE]"" {
	Use 0 Write !,$ZE,!
    }
EXIT2 ;
    Close 63
    Use:IO=OI IO:/MAR=IOMS
    Close:IO'=OI IO
    Quit
SHOW ;
    New dirinfo,blksiz,bytes,ans,chunk
    Set bytes=0,chunk=256
    Set dirinfo=$zu(49,DIR)
    If dirinfo<0 {
	Use IO
	Write:IO'=OI @IOF,!,"Directory ",DIR," is not mounted"
    } Else {
	Use IO
	Write:IO'=OI @IOF,!,"Directory ",DIR,!,"Block ",BLK
	Set blksiz=$p(dirinfo,",",2)
	If IO'=OI {zzdump $v(0,0,-blksiz)}
	Else {
          Do {
             Do zzdumpmore($v(bytes,0,-chunk),bytes)
             Set bytes=bytes+chunk
             If bytes<blksiz { Read !,"--more--",ans }
             Quit:$zcvt(ans,"U")="Q"
          } While bytes<blksiz
       }
    }
    Quit  
zzdumpmore(x,start) n c,d,i,j,n,s,ze
 s ze=""
 ZT:'$d(x) ZZDerr
 ; c is number of characters per line
 ; d is number of hexadecimal digits per character code
 S:$ZISWIDE(x) c=8,d=4 ;   Display Unicode characters
 S:'$ZISWIDE(x) c=16,d=2 ; Display Unicode characters
 F i=0:c:$L(x)-1 S s=$E(x,i+1,i+c) S n=$L(s) D
 .W !,$TR($J($ZHEX(start+i),4)," ","0")_": "
 .F j=1:1:n W $TR($J($ZHEX($A(s,j)),d)," ","0")_" " S:$E(s,j)?1C $E(s,j)="."
 .W ?62 I '$ZISWIDE(s) W s Q
 .S j=0,ze=$ZE,$ZT="ZZDerr"
ZZDnext .S j=j+1 W $E(s,j) G:j<n ZZDnext Q
 q  
ZZDerr i $ze'["<WIDE CHAR>" g EXIT
 S $ZE=ze,$ZT="ZZDerr" W "." G:j<n ZZDnext Q
 Q

BROADCAS^INT^1^67214,47330
BROADCAS ;Message to possibly busy terminals.
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 i ($zversion(1)=2) g PIDBCAST
 ;HYY016+: decide how to broadcast
 R !,"Broadcasting via (T)erminal Device or (P)rocess ID?",MESS#1,!
 Q:MESS=""!("TPtp"'[MESS)
 I "Pp"[MESS D PIDBCAST Q  
 ;HYY016-: below we broadcast via terminal device
 N MESS,TERM,TLIST,TT,I,%D
 W !,"Send a message to other terminals"
MESSAGE R !!,"Message => ",MESS Q:MESS=""
 S MESS=$C(7,13,10)_"***"_MESS_"***"_$C(13,10)
 ;
 K TLIST D GETRM,BRDCAS:$D(TLIST) G MESSAGE
GETRM R !,"Terminal => ",TERM Q:TERM=""
 i ($zversion(1)=3) I TERM["?" W !,"Enter a terminal name such as '/dev/tty02'." G GETRM
 ; If terminal is a numeric mnemonic change to device. RWR014.
 I TERM?1N.N S TERM=$P($G(^%IS(TERM,1)),"^")  ; get actual device.
 E  i ($zversion(1)=3) S:$E(TERM)'="/" TERM="/"_TERM
 I TERM="" w !,"Bad or undefined device mnemonic" G GETRM
 I $P($G(^%IS(TERM,1)),"^",2)="TRM" S TLIST(TERM)="" G GETRM
 I $D(^%IS(TERM)) W !,"Device ",TERM," is not a terminal" G GETRM
 W *7,"  device '"_TERM_"' is not in the %IS tables."
 I $$YN("Use device '"_TERM_"' anyway","N")="Y" S TLIST(TERM)=""
 G GETRM
BRDCAS S TT="" F  S TT=$O(TLIST(TT)) Q:TT=""  S %D=$ZU(9,TT,MESS) DO:%D>1
 . D INT^%DX W !,$$LJ(TT,10)_" Broadcast error #"_%X
 Q
LJ(x,n) Q ($E(x_$J("",n),1,n)_$E(x,n+1,$L(x))) ;left justify text to n chars
YN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YN"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"yn","YN") I "^YN"'[R W "  enter Yes or No, please"
 S POP=(R="^") W $E($S(R="N":"No",R="Y":"Yes",1:""),$L(X)+1,3) Q R
PIDBCAST ;HYY016: broadcast via process IDs (only label added) 
 N
 W !,"Send a message to other users"
MESSAG2 R !!,"Message => ",MESS Q:MESS=""  ;HYY016: only label changed
GETPID R !,"Process ID (*=ALL) => ",PID Q:PID=""
 I PID["?" D ALL^SS G GETPID
 I PID="*" S RESULT=$$ALL^BROADCAS(MESS,0) G MESSAG2 ;HYY016
 S PID=+PID I PID=0 w !,"Invalid process ID, please re-enter" g GETPID
 W $$PID^BROADCAS(PID,MESS)
 G GETPID
 ;#endif   ;YJH001 ;HYY016: moved to right before PIDBCAST
PID(PID,MESS) 
 N (PID,MESS)
 S MESS=$C(7,13,10)_"***"_MESS_"***"_$C(13,10)
 S $ZT="PIDE"
 I PID=+$J q " Cannot broadcast to yourself"
 I $P($V(-1,PID),"^",10)'="" q " Cannot broadcast to a system job" 
 ; $P($V(-1,+PID),"^",16) (aka. pjbstat) = high,low
 ; where the bit 7 of high means jobs started via M (application mode)
 ; and bit 0 of low means jobs started in programmer mode
 ; we broadcast to either jobs
 S jbstat=$P($V(-1,+PID),"^",16)
 I +jbstat\128#2!($P(jbstat,",",2)#2) D  Q MSG
 . I $ZU(94,+PID,MESS,2) S MSG=" Message sent"
 . E  S MSG=" Message NOT sent"
 q " Can only send to a user's foreground process"
PIDE  
 Q " No such job"
ALL(MESS,QUIET) 
 N (MESS,QUIET)
 S MESS=$C(7,13,10)_"***"_MESS_"***"_$C(13,10)
 S $ZT="ALLE"
 S BASE=$v($zu(40,2,47),-2,"S")
 S MAXPID=$v($zu(40,2,118),-2,4)
 S NOSEND=""
 I 'QUIET W !,"Message sent to: "
 F I=1:1:MAXPID S PID=$View($View($ZU(40,2,47)+((I\$zu(40,0,102))*$zu(40,0,25)),-2,$zu(40,0,25))+((I#$zu(40,0,102))*$s($ZBITGET($ZVERSION(0),40):$zu(40,28,79)*2,1:4)),-2,4) I PID D
 . Q:PID=+$J
 . D GETINFO
 . Q:JOBINFO=""
 . Q:$P(JOBINFO,"^",10)'=""
 . S jbstat=$P($V(-1,+PID),"^",16)
 . Q:'(+jbstat\128#2!($P(jbstat,",",2)#2))
 . S RESULT=$ZU(94,+PID,MESS,2)
 . Q:QUIET
 . I $X>72 w !
 . I RESULT W PID_" "
 . E  s NOSEND=NOSEND_PID_" " 
 I NOSEND'="" W !,"Mesage NOT sent to: "_NOSEND
 Q 1
ALLE  
 Q 1
GETINFO s $ZT="GETINFOE"
 s JOBINFO=$v(-1,PID)
 q
GETINFOE s JOBINFO=""
 q      
SHUT ;
 s MSG="System shutting down, please log off"
 s x=$zu(12)
 w !!,"Broadcasting shutdown message to all terminals"
 o x_"BRD.LOG"::2 i $t u x_"BRD.LOG" r MSG c x_"BRD.LOG"
 u 0
 s x=$$ALL(MSG,0)
 h 3
 q

COLLATE^INT^1^67214,47330
COLLATE ; Useful subroutines for Foreign Collation ;$Change: 7440104 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	; Revision: $Id: //iris/2024.1.3/databases/sys/rtn/user/collate.mac#1 $
List ;
LIST ;
 Do ListCols()
 Quit
ListCols() PUBLIC {
 Set oldc=$ZU(23,1,5)
 Do MakeArray(.array)
 Set tab1=0,tab2=13,tab3=22,tab4=31
 Write !,?tab1,"Status",?tab2,"Number",?tab3,"Abbrev",?tab4,"Name"
 Write !,?tab1,"----------",?tab2,"------",?tab3,"------",?tab4,"----------------------",!
 Set num=$O(array(""))
 While (num'="") {
 	Set sta=+array(num),nam=$P(array(num),";",3),abr=$$ABBREV(num,nam)
 	Write ?tab1,$S(sta=0:"Not loaded",sta=1:"Built-in",1:"Available")
 	Write ?tab2,$J(num,4),?tab3,abr,?tab4,nam,!
 	Set num=$O(array(num))
 }
 Set oldc=$zu(23,1,oldc)
}
GetName(num) PUBLIC {
 Quit $$NAME(num)
}
NAME(num) PUBLIC {
 Do MakeArray(.array) Quit $P($G(array(num)),";",3)
}
GetNum(nam) PUBLIC {
 Do MakeArray(.array)
 Set i="",num=-1
 For  Set i=$O(array(i)) Quit:i=""  If $P(array(i),";",3)=nam Set num=i Quit
 Quit num
}
GetList() PUBLIC {
 Do MakeArray(.cols)
 Quit $$MakeList(.cols)
}
MakeArray(array) PUBLIC {
 if $ZBITGET($ZVERSION(0),46) {
    Do GetNLSCollations^%SYS.Access(.array,0,1,0)
 } else {
    Do ##class(%Library.Collate).MakeArray(.array,0,1,0)
 }
}
MakeList(array) PUBLIC {
 Set list="",i=""
 For  Set i=$O(array(i)) Quit:i=""  Set list=list_"^"_array(i)
 Quit $E(list,2,*)
}
ABBREV(num,nam) PUBLIC {
 If num<0!(num>255) Quit ""
 If num<10 Quit $P("OANS,ANSI,COBR,DTMC,CBR2,UNIC",",",num+1)
 If num#128<10 Quit $P("OSTR,NSTR,,,,USTR",",",num#128+1)
 If num>128 Quit $$ABBREV(num-128)_"S"
 If '$D(nam) Set nam=$$NAME(num)
 Quit $ZCVT($E(nam,1,3)_$E(nam,$l(nam)),"U")
}
INDEX(abbrev,default) PUBLIC {
 Do MakeArray(.array)
 Set i="" For  Set i=$O(array(i)) Quit:i=""!($$ABBREV(i)=abbrev)
 Quit $S(i="":$G(default),1:i)
}
GetStdList(del3) PUBLIC {
 Do ##class(%Library.Collate).MakeArray(.array,0,1,0)
 Set num=##class(%Library.Collate).GetSystemDefaultNumber()
 Set del1=$$del1^%Wprim,del2=$$del2^%Wprim,lst1="",lst2="",lst3="",def=5
 If num'=5,$D(array(num),col) {
  	Set load=$P($ZU(23,2,num),"^",1,2)'="255^255"*2
 	Set lst1=load_del1_num_del1_$P(col,";",3),def=num
 }
 Set:lst1'="" lst1=lst1_del2
 Set lst1=lst1_1_del1_5_del1_"IRIS standard"_del2_1_del1_133_del1_"IRIS standard string"
 Set lst2=1_del1_0_del1_"ISM Pre-6.2"_del2_1_del1_1_del1_"ISM 6.2->6.4"
 Set lst2=lst2_del2_1_del1_128_del1_"ISM Pre-6.2 string"_del2_1_del1_129_del1_"ISM 6.2->6.4 string"
 Set lst2=lst2_del2_1_del1_2_del1_"Ipsum/Cobra"_del2_1_del1_4_del1_"Ipsum/Cobra-2"
 Set lst2=lst2_del2_1_del1_3_del1_"DTM-compatible"  ; DAS294
 Set num=$O(array(9))
 While (num'="") {
	If num'=def,num#128>9 {
 		Set:lst3'="" lst3=lst3_del2
 		Set col=array(num)
 		Set lst3=lst3_$P(col,";",1)_del1_$P(col,";",2)_del1_$P(col,";",3)
	}
 	Set num=$O(array(num))
 }
 Quit lst1_del3_lst2_del3_lst3
}
StdList() PUBLIC {
 Set del1=$$del1^%Wprim,del2=$$del2^%Wprim,lst=$$GetStdList(del2)
 Set tab1=0,tab2=8,tab3=20
 Write !,?tab1,"Number",?tab2,"Status",?tab3,"Name"
 Write !,?tab1,"------",?tab2,"----------",?tab3,"------------------------",!
 For i=1:1 {
	Set col=$P(lst,del2,i) Quit:col=""
 	Set sta=+col,num=$P(col,del1,2),nam=$P(col,del1,3)
 	Write ?tab1,$J(num,4),?tab2,$S(sta=0:"Not loaded",sta=1:"Built-in",1:"Available"),?tab3,nam,!
 }
}

COMMCTRL^INT^1^67214,47330
COMMCTRL ; COMM port control.
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ;
 q
 ;
report(x,show) ;report (error, warning, informational, or debug) message to $P.
 i $g(show) w !,x h 0
 q 1
START()
 i '($zversion(1)=2) q
 i $zu(67,10,29,$j) ; Set COMCTRL job type
 i $$iCONTROL()=0 d $zu(9,"","Could not become comm port server",1 /* broadcast and log message*/,2  /* Severe error */) q
 d INSTALL()
 f  d
 . s request=$$iWAIT(10) ;get request
 . i $$report("COMMCTRL Debug Info:  "_request,.debuglog) ;debug info
 . i request=-1001 q  ;timeout:  no work
 . i request>-1 d iLOGIN("COM"_request_":") ;Login request
 . i request=-1 d INSTALL q  ;perform re-install
 . i request=-2 d iPURGE q  ;purge all
 . i request=-3 d iPURGE h  ;exit request
 . i request=-20 s debuglog=1 q  ;turn debug log on
 . i request=-21 k debuglog q  ;turn debug log off
 . i request=-22 s infolog=1 q  ;turn info log on
 . i request=-23 k infolog q  ;turn info log off
 . i request=-1002 d $zu(9,"","COMCTRL woke for unknown reason",1 /* broadcast and log message*/,1  /* Warning */) q  ;unknown reason
 . i request<=(-200000) d iDISABLE(-request-200000) q
 . i request<=(-100000) d iENABLE(-request-100000) q
 . q
 q
 ;
INSTALL() Public {
 s ports=$zu(157,0,3)
 f i=1:1 s x=$p(ports,",",i) q:x=""  i '$d(^CONFIG("ComPorts",x)) d
 . s y=+$p(x,"COM",2) s y=$zu(157,2,y) i 'y d $zu(9,"","Error: "_"Could not remove com port "_x,1 /* broadcast and log message*/,2  /* Severe error */),BACK^%ETN q
 . s $p(ports,",",i)="" ;remove port from active list
 s port="" f  s port=$o(^CONFIG("ComPorts",port)) q:port=""  d
 . s n=+$E(port,4,99)
 . s c=$p(^CONFIG("ComPorts",port),",",1)
 . s b=$p(^CONFIG("ComPorts",port),",",2)
 . s x=$$iADD(n,c,+b)
 . i x=1 d $zu(9,"","Installed com port "_port,0,0  /* Informational message */)
 . i x'=1 d $zu(9,"","Error: "_"Could not install com port "_port_", reason = "_x,1 /* broadcast and log message*/,2  /* Severe error */),BACK^%ETN
 q
}
 ;
iLOGIN(port) ;(Internal) Perform remote login on a comm port.
 n t
 s $zt="iLOGINe" ;RJW946
 i $$report("COMMCTRL Info:  "_"Login requested on port "_port,.infolog)
 j DUMMYRTN^COMMCTRL:("%SYS":2:port:port):2 s t=$t
 q
iLOGINe	;
 d $zu(9,"","Error: "_$ze_" creating process on"_port,1 /* broadcast and log message*/,1  /* Warning */),BACK^%ETN
 q
 ;
DUMMYRTN	;
 Q
iPURGE() Private {
 s ports=$zu(157,0,3)
 f i=1:1 s x=$p(ports,",",i) q:x=""  i $$iREMOVE(+$e(x,4,99))
 q
}
iCONTROL() ;become comm port server.
 q $zu(157,5,$j)
 ;
iREMOVE(n) ;remove comm port n from the active comm port table.
 q $zu(157,2,n)
 ;
iDISABLE(p)	PRIVATE { ;Internal function to disable a configured port.
 s $zt="iDISABLEe"
 s x=$zu(157,7,p)
 I x=1 i $ZU(9,"","COM"_p_": disabled.")
 I x'=1 i $ZU(9,"","COM"_p_": disable failed.")
 q
iDISABLEe	;
 s $zt=""
 i $zu(9,"","COMMCTRL: error disabling COM"_p_": "_$ze)
 q
 }
 ;
iENABLE(p) PRIVATE { ;Internal function to enable a previously disabled port.
 i $$STATUS(p)'="0" q  ;status must be exactly disabled.  Use iADD to add a port.
 s x=$g(^CONFIG("ComPorts","COM"_p_":")) i x'="" d
 . s c=$p(x,";",1) ;parameters
 . s b=$p(x,";",2) ;baud rate
 . s rc=$$iADD(p,c,+b)
 . i rc i $zu(9,"","COM"_p_": enabled.")
 . i 'rc i $zu(9,"","COM"_p_": enable failed.")
 q
iENABLEe	;
 s $zt=""
 i $zu(9,"","COMMCTRL error enabling COM"_p_": "_$ze)
}
 ;
iADD(n,control,baud) Private {
 q $zu(157,1,n,$g(control),$g(baud))
} 
iWAIT(timeout) ;wait for something to do
 q $zu(157,3,timeout)
 ;
iTRACEon(n)     ;Set trace flags
 i $zu(157,6,n,1)
 q
 ;
iTRACEoff(n)    ;Reset trace flags
 i $zu(157,6,n,0)
 q
SENDMSG(msg) ;send a message to the comm port server.
 q $zu(157,4,msg)
shutdown ;Initiate com server shutdown.
 n x
 s x=$$SENDMSG(-3)
 i x w !,"Shutdown failed:  reason = ",x
 i 'x w "Shutdown succeeded."
 q
 ;
purge ;Purge all com table entries.
 n x
 s x=$$SENDMSG(-2)
 i x w !,"Purge failed:  reason = ",x
 i 'x w "Purge succeeded."
 q
 ;
update ;Update active table: remove deleted entries; install new entries; modify existing entries.
 n x
 s x=$$SENDMSG(-1)
 i x w !,"Update failed:  reason = ",x
 i 'x w "Update succeeded."
 q
 ;
logdbg ;Tell com control process to log debug messages to messages.log
 d iTRACEon(3)
 w $$SENDMSG(-20)
 q
 ;
nologdbg ;Tell com control process to stop logging debug messages to messages.log
 d iTRACEoff(3)
 w $$SENDMSG(-21)
 q
 ;
loginf ;Tell com control process to log informational messages to messages.log
 w $$SENDMSG(-22)
 q
 ;
nologinf ;Tell com control process to stop logging informational messages to messages.log
 w $$SENDMSG(-23)
 q
 ;
info ;Display com control table setup and state info.
 w !
 w !,"configured table size = ",$zu(157,0,1)
 w !,"entries in table = ",$zu(157,0,2)
 w !,"ports in table = ",$zu(157,0,3)
 w !,"controller PID = ",$zu(157,0,4)
 w !
 q
PORTLIST()	;Return list of configured ports.
 q $zu(157,0,3)
FORMATPORT(p) PUBLIC {	;Return port formated as COMnn:
 i '$d(p) q "" ;port must be defined
 i p?1"COM".E s p=+$e(p,4,99)
 i p?1"com".E s p=+$e(p,4,99)
 i p?1n.n s p="COM"_p_":"
 i p?1"COM"1N.N1":" q p
 q ""
}
STATUS(port) PUBLIC {	;Return status of port COMnn:
 s $zt="STATUSe"
 i '$d(port) q "0|Not configured"
 s p=$$FORMATPORT(port) i p="" q "0|Not configured"
 s ports=$$PORTLIST
 f i=1:1 s p1=$p(ports,",",i) i p1=""!(p1=p) q
 i p1="" q "0|Not configured"
 q $zu(157,8,+$e(p,4,99))
STATUSe	;
 s $zt=""
 i $zu(9,"",$ze)
}
DISABLE(port) PUBLIC {	;Disable port
 s $zt="DISABLEe"
 i '$d(port) q "0|Not configured"
 s rc=$$STATUS(port)
 i rc="0" q 1 ;already disabled
 i $e(rc,1)="0" q rc ;Not configured
 s p=$$FORMATPORT(port)
 i p'?1"COM"1N.N1":" q "0|Not configured"
 s p=+$e(p,4,99)
 s rc=$$SENDMSG(-200000-p) ;disable
 i rc q "0|Could not send disable message to COM control process."
 h .2
 i '$$STATUS(port) q 1
 h 2
 i $$STATUS(port) q 0
 q 1
DISABLEe	; 
 s $zt=""
 i $zu(9,"",$ze)
}
ENABLE(port) PUBLIC {	;
 s $ZT="ENABLEe"
 i '$d(port) q "0|Not configured"
 s rc=$$STATUS(port)
 i rc="1" q 1 ;already enabled
 i $l(rc)>1 q rc ;Not configured
 s port=$$FORMATPORT(port)
 i port'?1"COM"1N.N1":" q "0|Not configured"
 s p=+$e(port,4,99)
 s rc=$$SENDMSG(-100000-p) ;enable
 i rc q 0
 h .2 s x=$$STATUS(port) i x q 1
 h 1 s x=$$STATUS(port) i x q 1
 h 1 q $$STATUS(port)
ENABLEe	; 
 s $zt=""
 i $zu(9,"",$ze)
}

CSPButtons^INT^1^67214,47330
CSPButtons ;;;Collect CSP and CSP-Gateway Informations, Diagnostics and Logs;created:BM 2015-03-24;last changed:BM 2019-03-26
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 // CSPButtons initial version by Tomas Vaverka (tomas.vaverka@intersystems.com) in 2013
 // picked up by Tomas and Bernd Mueller (bernd.mueller@intersystems.com) in 2015
 // special thanks to Ernesto Fischer (ernesto.fischer@intersystems.com), author of 2009 zCSP.Util.Buttons
 // Change-Notes:
 // 2015-03-24 - BM - initial separated CSPButtons.mac (removed from CSPGWMGR.mac)
 // 2015-03-27 - BM - add generation of LogDirectory and Main-LogFile creation in it and finally compress all the files in LogDirectory.
 // 2015-03-27 - BM - removed some unused code, restructured and modernized some code
 // 2015-03-31 - BM - added Security- and Audit-Log/Information Sections 
 // 2015-04-03 - TV - added prompt & functionality to export of %cspSession and ^%ISCLOG globals
 // 2015-04-08 - BM - added CSP-Applications Section
 // 2015-04-08 - BM - added CSP Error Log Section
 // 2015-04-08 - BM - minor bug fixes
 // 2015-04-09 - BM - change file compressing under unix/linux to not include whole-directory-path in the tar-archive
 // 2015-04-09 - BM - added *PWS* on the CSPGateway if it is the Private Webserver
 // 2015-04-24 - BM - added processes and cconsole.log
 // 2015-04-26 - BM - added SysLog
 // 2015-04-27 - BM - added LockTab
 // 2015-04-27 - BM - added httpd.conf and error.log from Apache Private Webserver (PWS)
 // 2015-04-29 - TV - correct typo for LockTab query
 // 2015-04-29 - BM - fix bug in CSPButtons version-check
 // 2015-04-30 - BM - use NullDev to suppress output from CompressFiles OS commands.
 // 2015-05-01 - BM - fix unicode chars
 // 2015-05-01 - BM - some minor fixes and cosmetic enhancements
 // 2015-11-19 - BM - fix file compressing bug under AIX, AIX does not support z flag
 // 2016-10-26 - BM - added general CSPGWINFO entry to get CSP-Gateway Infos via http get generaly.
 // 2016-10-26 - BM - fix bug in CSPGWINFO and added CSPSYS argument/support to get other CSPGW-page infos as well.
 // 2017-06-21 - BM - changed get CSP.log to only fetch last 10000 event-entrys in reverse order instead of everything. Run GETCSPLOGS^CSPButtons entry-point to get full ones.
 // 2017-09-21 - BM - fix bug in CSPGWINFO to get System-Status-Overview (CSPSYS=1) correctly. MAK4828
 // 2017-10-26 - STC2675 - Security.Domains database no longer used (in IRIS)
 // 2018-03-05 - JO3030 - cconsole.log/iris.log -> messages.log
 // 2018-03-14 - MAK4918 - Update ^CacheTemp* names to ^IRIS.Temp* names
 // 2018-04-30 - RFD1984 - Change checks for Multi Server type for license key sharing
 // 2019-03-15 - BM - add IRIS support and adjustments on previous changes to achieve backwards compatibility.
 // -----------------------------------------------------------------------------
 //RFD1984 - EVALKEY is also defined in %LMF.inc but only in IRIS 2018.2+ versions. It is defined here as well for backward compatibility reason.
 //----------------------------------------------------------
 Do Start(1)
 Quit
Start(display) //
 New (display)
 Set display=+$get(display)
 If +$System.Version.GetNumber()<2012.2 {
   Write:display !,"*** You are running on "_$system.Version.GetProduct()_" "_$System.Version.GetNumber()_" and "_"Web/CSP-Gateway Diagnostic Report and Evidence Logging Tool"_" is only for v2012.2 and later ***"
   Quit
 }
 If '($roles["%All") {
   Write:display !,"*** You need %All privileges to run "_"Web/CSP-Gateway Diagnostic Report and Evidence Logging Tool"_" ***"
   Quit
 }
ReadLogType
 Write:display !!,"Web/CSP-Gateway Diagnostic Report and Evidence Logging Tool",", ","v1.0"
 Write:display !!,"This reporting tool provides the information required for InterSystems"
 Write:display !,"Technical Support to analyze CSP issues. "
 Write:display !!,"This process will take some time to complete. Please be patient."
 Write:display !
 Set GlobalExport=1
 If 'display goto Confirmed
GlobalExportConfirm
 Write !,"Export %cspSession and ISCLOG log globals (Y)? " Read LogType
 Set LogType=$ZCONVERT(LogType,"U")
 If LogType="NO"!(LogType="N") set GlobalExport=0 Goto ReadLogTypeConfirm
 If LogType'=""&(LogType'="Y")&(LogType'="YES") Write !!,"<Please enter Y or N>" Goto GlobalExportConfirm
ReadLogTypeConfirm	Write !,"Continue (Y)? " Read LogType
 Set LogType=$ZCONVERT(LogType,"U")
 If LogType="NO"!(LogType="N")!(LogType="Q")!(LogType="QUIT") Quit
 If LogType'=""&(LogType'="Y")&(LogType'="YES") Write !!,"<Please enter Y or N>" Goto ReadLogTypeConfirm
Confirmed
 Set PDev=$Principal
 do GetDirs
 Set DirName="CSP_"_$Piece($Piece($ZUtil(86),"*",2)," ",1)_$zd($h,8)_$tr($zt($p($h,",",2),2),":","")
 Set LogDirectory=##class(%SYS.System).TempDirectory()_DirDelim_DirName
 If '##class(%Library.File).CreateNewDir(##class(%SYS.System).TempDirectory(),DirName) {
   Write:display !,"Failed to create LogDirectory "_LogDirectory_"."
   Quit
 }
 Set LogFilePrefix=$Piece($s($System.License.KeyCustomerName()'?1a.e:"Unknown",1:$System.License.KeyCustomerName())," ",1)
 If LogFilePrefix'="",LogFilePrefix?1a.an,$Length(LogFilePrefix)<20
 Else  Set LogFilePrefix=$Piece($system.Version.GetProduct()," ")
 Set LogFile=$$NewFile(LogFilePrefix,"html")
 If GlobalExport Set GlobalExportFile=$$NewFile(LogFilePrefix,"xml")
 if LogFile="" {
   Write:display !,"Failed to create LogFile."
   Quit
 }
 //create report
 Do LogReportHead Write:display "."
 Do LogHeadGateways Write:display "."
 Do LogMain() Write:display "."  //this is where main data is fetched and processed into report
 Do LogReportTrailer Write:display "."
 Close LogFile
 Use PDev Write:display "." Write:display !,"Log file saved to: ",LogFile_", "_$FNumber($ZUtil(140,1,LogFile),",")_" bytes.",!
 do CompressFiles(LogDirectory,MgrDir,DirName,DirName,1,display)  //SourcePath, CabPath, CabName, CabDir, deleteSourcePath, display
 Kill LogFile
 Quit
LogReportHead	//
	Use LogFile
	Write !,"<html>"
	Write !,"<head>"
	Write !,"<title>"
	Write !,"CSPButtons Diagnostic Report, Log-Filename: ",LogFile
	Write !,"</title>"
	Write !,"<meta http-equiv=""Content-Type"" content=""text/html; charset=UTF-8"">"
	Write !,"</head>"
	Write !,"<body bgcolor=""#FFFFFF"" text=""#000000"">"
	Write !,"<table align=""center"" width=""100%"" border=""1"" bordercolor=""#999999"">"
	Write !,"  <tr bgcolor=""#FFFFFF"" bordercolor=""#CCCCCC"">"
	Write !,"    <td colspan=12 height=""40"" align=""center"">"
	Write !,"      <a name=""top""></a><font face=""Arial, Helvetica, sans-serif"" size=""5"" color="_"CadetBlue"_"><b>"_"Web/CSP-Gateway Diagnostic Report and Evidence Logging Tool"_", "_"v1.0"_"</b></font>"
	Write !,"    </td>"
	Write !,"  </tr>"
	Write !,"  <tr><td colspan=""12"" nowrap align=""center""><i>Log created by User: &quot;"_$username_"&quot; on "_$zdatetime($horolog)_"</i></td></tr>"
	Write !,"  <tr bgcolor=""#FFFFFF"" bordercolor=""#CCCCCC"">"
	Do LogHeaderTagBasic("general","System-General")
	Do LogHeaderTagBasic("key",$s($system.Version.GetProduct()["IRIS":"IRIS",1:"Cach&eacute;")_" Key")
	Do LogHeaderTagBasic("dumplic","Dump License")
	Do LogHeaderTagBasic("security","Security")
	Do LogHeaderTagBasic("audit","Audit")
	Do LogHeaderTagBasic("processes","Processes")
	Do LogHeaderTagBasic("locktab","LockTab")
	Do LogHeaderTagBasic("cspapps","Web/CSP-Applications")
	Do LogHeaderTagBasic("cspsesdump","Dump Web/CSP Sessions")
	Do LogHeaderTagBasic("csperrorlog","CSP Error Log")
	Do LogHeaderTagBasic("cconsole",$s($system.Version.GetProduct()["IRIS":"messages.log",1:"cconsole.log"))
	Do LogHeaderTagBasic("syslog","SysLog")
	Write !,"  </tr>"
	Write !,"</table>"
	Write !,"<p></p>"
	Use PDev Write:display "."
	Quit
LogHeadGateways //
	// CSP Gateways
	Use LogFile
	Write !,"<table align=""center"" width=""100%"" border=""1"" bordercolor=""#999999"" bgcolor=""#CCCCCC"">"
	Write !,"  <tr bgcolor=""#FFFFFF"" bordercolor=""#CCCCCC"">"
	Write !,"    <td colspan=""10"" height=""40"" align=""center"">"
	Write !,"      <font face=""Arial, Helvetica, sans-serif"" size=""5"" color="_"SteelBlue"_"><b>Web/CSP-Gateway Servers</b></font>"
	Write !,"    </td>"
	Write !,"  </tr>"
	Set CSPRegs=$system.CSP.GetGatewayRegistry()
	Set CSPMgrs=CSPRegs.GetGatewayMgrs()
	Set webserverport=$$GetConfigWebServerPort() 
	For mgrid=1:1:CSPMgrs.Count() 
	{
		set CSPMgr=CSPMgrs.GetAt(mgrid)
		Write !,"  <tr bgcolor=""#FFFFFF"" bordercolor=""#CCCCCC"">"
		Do LogHeaderTagAdvanced("cspserver"_mgrid,"Web/CSP-Gateway on "_CSPMgr.Server_" : "_CSPMgr.Port_$s(CSPMgr.Port=webserverport:" *PWS*",1:""))
		if CSPMgr.Port=webserverport {
			Do LogHeaderTagBasic("httpdconfpws","httpd.conf")
			Do LogHeaderTagBasic("errorlogpws","error.log")
		}
		else  {
			Do LogHeaderTagBasic("","")
			Do LogHeaderTagBasic("","")	
		}
		Do LogHeaderTagBasic("cspinfo"_mgrid,"Info")
		Do LogHeaderTagBasic("cspini"_mgrid,"CSP.ini")
		Do LogHeaderTagBasic("cspdefparams"_mgrid,"Default Params")
		Do LogHeaderTagBasic("cspserversparams"_mgrid,"Servers Params")
		Do LogHeaderTagBasic("cspapppathsparams"_mgrid,"Application Paths Params")
		Do LogHeaderTagBasic("cspstatus"_mgrid,"Status")
		Do LogHeaderTagBasic("csplog"_mgrid,"CSP.log")
		Write !,"  </tr>"
	}
	Write !,"</table>"
	Use PDev Write:display "."
	Quit
LogMain(syslog=1,gwheader=1,gwinfo=1,gwini=1,gwdefparams=1,gwserversparams=1,gwapppathsparams=1,gwstatus=1,gwcsplog=1)	//
 Set PDev=$Principal
 //SYS Logs
 if syslog=1 {
 	do LogSYSGeneral(LogFile)
 	do LogSYSKey
 	do DumpLicense
 	do Security
 	do Audit
 	do Processes
 	do LockTab
 	do CSPapps
 	do DumpCSPSessions(LogFile)
 	do CSPErrorLog
 	do Cconsole
 	do SysLog
 }
 //Logs for every GW
 Set CSPRegs=$system.CSP.GetGatewayRegistry()
 Set CSPMgrs=CSPRegs.GetGatewayMgrs()
 For mgrid=1:1:CSPMgrs.Count() 
 {
	 set CSPMgr=CSPMgrs.GetAt(mgrid)
	 Do:gwheader LogGWHeader
	 if gwheader,CSPMgr.Port=$g(webserverport) do HttpdConfPWS do ErrorLogPWS
	 Do:gwinfo LogGWInfo
	 Do:gwini LogGWIni
	 Do:gwdefparams LogGWDefParams
	 Do:gwserversparams LogGWServersParams
	 Do:gwapppathsparams LogGWAppPathsParams
	 Do:gwstatus LogGWStatus
	 Do:gwcsplog LogGWCSPLog
 }
 Quit
LogSYSGeneral(LogFile) //
	Use LogFile
 	Write !,"<hr size=""2"" noshade>"
 	Write !,"<table border=0 width=""100%""><tr>"
 	Write !,"<td><b><font color=""#0000FF"" face=""Arial, Helvetica, sans-serif"" size=""4""><a name=""general""></a>System-General</font></b></td>"
 	Write !,"<td align=right><a href=""#top"">top</a></td>"
 	Write !,"</tr></table>"
	Write !,"<table border=0 style='font-size: 14px; font-family: Arial, Helvetica, sans-serif;' cellpadding=2 cellspacing=0>"
	Write !,"<tr><td nowrap> Configuration Name:</td><td nowrap>&nbsp;"_$Piece($ZUtil(86),"*",2),"</td></tr>"
	Write !,"<tr><td nowrap> Customer Name:</td><td nowrap>&nbsp;",$s($System.License.KeyCustomerName()'?1a.e:"Unknown",1:$System.License.KeyCustomerName()),"</td></tr>"
	Write !,"<tr><td nowrap> Host Name:</td><td nowrap>&nbsp;",$Piece($ZUtil(54,13,$ZUtil(54,0)),",",2),"</td></tr>"
	Write !,"<tr><td nowrap> IP Address:</td><td>&nbsp;",$Piece($ZUtil(54,13,$ZUtil(54,0)),",",1),"</td></tr>"
	Write !,"<tr><td nowrap> "_$s($system.Version.GetProduct()["IRIS":"IRIS",1:"Cach&eacute;")_" Version String:</td><td nowrap>&nbsp;",$ZVERSION_"</td></tr>"
	Write !,"<tr><td nowrap> Operating System Version:</td><td nowrap>&nbsp;",$zconvert($System.Version.GetBuildOS(),"U"),"</td></tr>"
	Set oNLS=##class(%SYS.NLS.Locale).%New()
	Write !,"<tr><td nowrap> Current Locale:</td><td nowrap>&nbsp;"_oNLS.Name_" - "_oNLS.Description_"</td></tr>"
	Set oNLS=""
	Write !,"<tr><td nowrap> Log created by User:</td><td nowrap>&nbsp;&quot;"_$username_"&quot; on "_$zdatetime($horolog)_"</td></tr>"
	Write !,"</table>"
	Use PDev Write:display "."
	Quit
LogSYSKey //
	Use LogFile
	Write !,"<hr size=""2"" noshade>"
 	Write !,"<table border=""0"" width=""100%""><tr>"
 	Write !,"<td><b><font color=""#0000FF"" face=""Arial, Helvetica, sans-serif"" size=""4""><a name=""key""></a>"_$s($system.Version.GetProduct()["IRIS":"IRIS",1:"Cach&eacute;")_" Key</font></b></td>"
 	Write !,"<td align=right><a href=""#top"">top</a></td>"
 	Write !,"</tr></table>"
	Write !,"<pre>"
	Do $System.License.CKEY()
	Write !,"</pre>"
	Write !,"<br>"
	Write !,"<pre>",!!,$s($system.Version.GetProduct()["IRIS":"IRIS",1:"Cach&eacute;")_" License Usage:"
	Do counts^%LICENSE
	//If $System.License.KeyServer()["Multi" Do ShowSummary^%LICENSE
	If '($e($system.License.KeyAuthorizationKey(),1,2)="00") Do ShowSummary^%LICENSE
	Write !,"</pre>" 
	Write !,"<br>"
	Use PDev Write:display "."
	Quit
DumpLicense
	Set $ZTrap="DumpLicenseErr"
	New DumpFile,IO,x
	Use LogFile
	Write !,"<hr size=""2"" noshade>"
 	Write !,"<table border=""0"" width=""100%""><tr>"
 	Write !,"<td><b><font color=""#0000FF"" face=""Arial, Helvetica, sans-serif"" size=""4""><a name=""dumplic""></a>Dump License</font></b></td>"
 	Write !,"<td align=right><a href=""#top"">top</a></td>"
 	Write !,"</tr></table>"
	Write !,"<pre>"
	Use PDev Write:display "."
	Set IO=$IO
	If display {
	  Open NullDev::0
	  If $Test Use NullDev
	}
	If display Use PDev Write:display "."
	Use LogFile Do LicenseKeys(),LicenseInUse()
	Use LogFile Write !,"</pre>" 
	Use PDev Write:display "."
	Quit
DumpLicenseErr
	Set $ZTrap=""
	Do WriteLog("Error: "_$ZError)
	Quit 
LicenseKeys() PUBLIC {
	Do $System.License.ShowSummary() Write !
	; write keys in use
	Set rset=##class(%Library.ResultSet).%New("%SYSTEM.License:LicenseServerKeyList")
	If rset="" Write !,"Query failed" Do $System.Status.DisplayError(%objlasterror) Quit
	Set status=rset.Execute()
	If ('status) Write !,"Execute Query failed" Do $System.Status.DisplayError(.status) Quit
	Set colcnt=rset.GetColumnCount()
	For i=1:1:colcnt {
	  Set colname(i)=rset.GetColumnName(i)
	}
	Set n=0
	WHILE rset.Next() {
	  Set n=n+1
	  Write !,"License key number ",n
	  For i=1:1:colcnt Write !,?2,colname(i),":",?20,rset.GetData(i)
	}
	; write key connections
	Set rset=##class(%Library.ResultSet).%New("%SYSTEM.License:AllKeyConnectionList")
	If rset="" Write !,"Create Query failed" Do $System.Status.DisplayError(%objlasterror) Quit
	Set status=rset.Execute()
	If ('status) Write !,"Execute Query failed" Do $System.Status.DisplayError(.status) Quit
	Set colcnt=rset.GetColumnCount()
	Set widths="15,6,6,15,15,10",colhead="UserId,LU,Connect,ServerIP,Instance,OrderNum"
	Write !!,?4 For i=1:1:colcnt Write $Justify($Piece(colhead,",",i),$Piece(widths,",",i))," "
	Set n=0
	WHILE rset.Next() {
	  Set n=n+1,c=4
	  Write !,n," ",?4 For i=1:1:colcnt Write $Justify(rset.GetData(i),$Piece(widths,",",i))," " Set c=c+$Piece(widths,",",i)+1 If i=1,$X>c Write !,?c
	}
	Quit
 }
LicenseInUse() PUBLIC {
	Write !!,"License usage summary: "
	; write current license users
	Set Rset=##class(%Library.ResultSet).%New("%SYSTEM.License.UserList")
	if 'Rset Write !,"Could not form query %SYSTEM.License.UserList" Quit
	Set r=Rset.Execute()
	if r {
		Set ncol=Rset.GetColumnCount()
		For i=1:1:ncol Set hd(i)=Rset.GetColumnName(i)
		Set cw=80\ncol
		Write !!
		For i=1:1:ncol Write hd(i) If i<ncol Write ?(cw*i)+1
		Write !
		Set nrec=0
		WHILE (Rset.Next()) {
			Set nrec=nrec+1
			Write !
			Set ncol=Rset.GetColumnCount()
			For i=1:1:ncol Write Rset.GetData(i) If i<ncol Write:$X>(cw*i) ! Write ?((cw*i)+1)
		}
		Do Rset.Close()
	}
	If 'r Write !,"Could not execute query %SYSTEM.License.UserList",!
 }
DumpCSPSessions(LogFile) 
	Set $ZTrap="DumpCSPSessionsErr"
	Use LogFile
	Write !,"<hr size=""2"" noshade>"
 	Write !,"<table border=""0"" width=""100%""><tr>"
 	Write !,"<td><b><font color=""#0000FF"" face=""Arial, Helvetica, sans-serif"" size=""4""><a name=""cspsesdump""></a>Web/CSP-Sessions</font></b></td>"
 	Write !,"<td align=right><a href=""#top"">top</a></td>"
 	Write !,"</tr></table>"
	Write !,"<pre>"
	/* Get session info 
	   ID, Username, Preserve, Application, Timeout, LicenseId, SesProcessId, AllowEndSession
	*/
	set tStatement = ##class(%SQL.Statement).%New()
	If ##class(%Dictionary.CompiledQuery).%ExistsId("%ZCSPGTW.Session||CSPButtonsInfo") {
		set tSQL = 1,tSQL(1)="CALL %ZCSPGTW.Session_CSPButtonsInfo()"
	}
	Else {
		set tSQL = 1,tSQL(1)="CALL %CSP.Session_SessionInfo()"
	}	
	set tStatus = tStatement.%Prepare(.tSQL)
	set tResult = tStatement.%Execute()
	if 'tResult.%SQLCODE {
		set tMeta= tResult.%GetMetadata()
		Set ncol=tMeta.columns.Count()
		For i=1:1:ncol Set hd(i)=tMeta.columns.GetAt(i).colName
		Set cw=200\(ncol)
		Write !!
		For i=1:1:(ncol) Write hd(i) If i<ncol Write ?(cw*i)
		Write !!
		Set nrec=0
		WHILE tResult.%Next() {
			Set nrec=nrec+1
			Set ncol=tResult.%ResultColumnCount
			For i=1:1:(ncol) Write tResult.%GetData(i) If i<ncol Write:$X>(cw*i) ! Write ?((cw*i))
	 		write !
	 	}
	}
	kill tResult,tStatement
	Use LogFile Write !,"</pre>" 
	Use PDev Write:display "."
	/// Export %cspSession and ^%ISCLOG globals to file
	If GlobalExport {
		M ^zcspSession=^%cspSession
		Do $system.OBJ.Export("zcspSession.GBL,"_$s($system.Version.GetProduct()["IRIS":"ISCLOG.GBL",1:"%ISCLOG.GBL"),GlobalExportFile,$s('display:"-d",1:""))
		k ^zcspSession
	}
	Quit
DumpCSPSessionsErr
	Set $ZTrap=""
	kill tResult,tStatement
	Do WriteLog("Error: "_$ZError)
	Use PDev Write:display "."
	Quit
	/// CSP server side error logs in manager namespace and all local namespaces.
CSPErrorLog
	Use LogFile
	Write !,"<hr size=""2"" noshade>"
 	Write !,"<table border=""0"" width=""100%""><tr>"
 	Write !,"<td><b><font color=""#0000FF"" face=""Arial, Helvetica, sans-serif"" size=""4""><a name=""csperrorlog""></a>CSP Error Log (Server side)</font></b></td>"
 	Write !,"<td align=right><a href=""#top"">top</a></td>"
 	Write !,"</tr></table>"
 	Set currNsp=$namespace
	Try {
		Set LN=0
		//%SYS log
		If $Data(^%cspServer("LOG")) {
			Write !,"<p><b style='color: #0000FF; font-size: 12px; line-height: 14px; font-family: Arial, Helvetica, sans-serif;'>Namespace: "_$namespace_"</b></p>"
			Write "<table style='font-family: Arial, Helvetica, sans-serif;font-size: 12px;' class=sortable border id=syserr cellpadding=2 cellspacing=0>",!
			Write "<tr title='Click to sort'><th>#</th><th>Date</th><th>Namespace</th><th>Error</th></tr>",!
			Set N="" 
			For id=1:1 {
				Set N=$Order(^%cspServer("LOG",N)) Quit:N=""  
				Set LN=LN+1,HEAD=$Get(^%cspServer("LOG",N,0)),TEXT=$Get(^%cspServer("LOG",N,1)) 
				//Do DispLine(id,HEAD,TEXT)
				Write "<tr><td>",id,"</td><td>",$Piece(HEAD,"~"),"</td><td>",$Piece(HEAD,"~",2),"</td><td>",$ZCvt(TEXT,"O","HTML"),"</td></tr>",!
			}
			Write "</table>",!
		}
		//each namespace log 
		Write !
		Set rsNsp=##class(%Library.ResultSet).%New("%SYS.Namespace:List")
		Do rsNsp.Execute()
		While rsNsp.Next() {
			Set Nsp=rsNsp.Data("Nsp")
			If Nsp["DOCBOOK" Continue
			Try {
				ZNspace Nsp
			}
			Catch {
				ZNspace currNsp
				Continue
			}
			If $Data(^cspServer("LOG")) {
				Write !,"<p><b style='color: #0000FF; font-size: 12px; line-height: 14px; font-family: Arial, Helvetica, sans-serif;'>Namespace: "_Nsp_"</b></p>"
				Write "<table style='font-family: Arial, Helvetica, sans-serif;font-size: 12px;' class=sortable border id=localerr cellpadding=2 cellspacing=0>",!
				Write "<tr title='Click to sort'><th>#</th><th>Date</th><th>Namespace</th><th>Error</th><th>Line</th></tr>",!
				Set N="" 
				For id=1:1 {
					Set N=$Order(^cspServer("LOG",N)) Quit:N=""  
					Set LN=LN+1,HEAD=$Get(^cspServer("LOG",N,0)),TEXT=$Get(^cspServer("LOG",N,1)) 
					//Do DispLine(id,HEAD,TEXT)
					Write "<tr><td>",id,"</td><td>",$Piece(HEAD,"~"),"</td><td>",$Piece(HEAD,"~",2),"</td><td>",$ZCvt(TEXT,"O","HTML"),"</td></tr>",!
				}
				Write "</table><hr>",!
			}
		}
		If 'LN { Write !,"<p><span style='font-size: 12px; line-height: 14px; font-family: Arial, Helvetica, sans-serif;'>The CSP Error Log (Server side) is empty</span></p>",! }
		Write !,"<br>"
	}
	Catch {
		Use PDev
		Write !,"ERROR: ",$ZCvt($ZError,"O","HTML"),!
		Use LogFile
	}
	ZNspace currNsp
	Use PDev Write:display "."
	Quit
	/// CSP apps and definitions
CSPapps	
	Use LogFile
 	Write !,"<hr size=""2"" noshade>"
 	Write !,"<table border=""0"" width=""100%""><tr>"
 	Write !,"<td><b><font color=""#0000FF"" face=""Arial, Helvetica, sans-serif"" size=""4""><a name=""cspapps""></a>Web/CSP-Applications</font></b></td>"
 	Write !,"<td align=right><a href=""#top"">top</a></td>"
 	Write !,"</tr></table>"
	Try {
		Write !,"<br><b style='color: #0000FF; font-size: 12px; line-height: 14px; font-family: Arial, Helvetica, sans-serif;'>Web/CSP Global Configuration parameters</b>"
		Write !,"<table style='font-family: Arial, Helvetica, sans-serif; font-size: 11px; line-height: 14px; width: 45%' id='cspglobalparams' border cellpadding=2 cellspacing=0>"
		Write "<tr><td>DebugErrorPage</td><td>",##class(%SYSTEM.CSP).GetConfig("DebugErrorPage"),"&nbsp;</td></tr>",!
		Write "<tr><td>DefaultErrorPage</td><td>",##class(%SYSTEM.CSP).GetConfig("DefaultErrorPage"),"&nbsp;</td></tr>",!
		Write "<tr><td>ClearSessionsOnRestart</td><td>",##class(%SYSTEM.CSP).GetConfig("ClearSessionsOnRestart"),"&nbsp;</td></tr>",!
		Write "<tr><td>SessionLockTimeout</td><td>",##class(%SYSTEM.CSP).GetConfig("SessionLockTimeout"),"&nbsp;</td></tr>",!
		Write "<tr><td>Expire</td><td>",##class(%SYSTEM.CSP).GetConfig("Expire"),"&nbsp;</td></tr>",!
		Write "<tr><td>DefaultServerName</td><td>",##class(%SYSTEM.CSP).GetConfig("DefaultServerName"),"&nbsp;</td></tr>",!
		Write "<tr><td>CSPConfigName</td><td>",##class(%SYSTEM.CSP).GetConfig("CSPConfigName"),"&nbsp;</td></tr>",!
		Write "<tr><td>DefaultLoginPage</td><td>",##class(%SYSTEM.CSP).GetConfig("DefaultLoginPage"),"&nbsp;</td></tr>",!
		Write "<tr><td>DefaultPasswordChangePage</td><td>",##class(%SYSTEM.CSP).GetConfig("DefaultPasswordChangePage"),"&nbsp;</td></tr>",!
		Write "<tr><td>OptionalBrokerJS</td><td>",##class(%SYSTEM.CSP).GetConfig("OptionalBrokerJS"),"&nbsp;</td></tr>",!
		Write "<tr><td>FileServerPage</td><td>",##class(%SYSTEM.CSP).GetConfig("FileServerPage"),"&nbsp;</td></tr>",!
		Write "<tr><td>8BitLocaleCharset</td><td>",##class(%SYSTEM.CSP).GetConfig("8BitLocaleCharset"),"&nbsp;</td></tr>",!
		Write "<tr><td>ProtectSessionCallback</td><td>",##class(%SYSTEM.CSP).GetConfig("ProtectSessionCallback"),"&nbsp;</td></tr>",!
		Write "<tr><td>DisableGatewayCacheClear</td><td>",##class(%SYSTEM.CSP).GetConfig("DisableGatewayCacheClear"),"&nbsp;</td></tr>",!
		Write "<tr><td>UseLegacySessionSharing</td><td>",##class(%SYSTEM.CSP).GetConfig("UseLegacySessionSharing"),"&nbsp;</td></tr>",!
		Write "<tr><td>GatewayPingHTTPSConfig</td><td>",##class(%SYSTEM.CSP).GetConfig("GatewayPingHTTPSConfig"),"&nbsp;</td></tr>",!
		Write "<tr><td>GatewayPingHTTPSPort</td><td>",##class(%SYSTEM.CSP).GetConfig("GatewayPingHTTPSPort"),"&nbsp;</td></tr>",!
		Write "</table>",!
		Write !,"<br>" 
		Write !,"<hr size=""2"" noshade>"
		Set rs=##class(%Library.ResultSet).%New("Security.Applications:Detail")  //Detail all Application records
		Set sc=rs.Execute("*",2)  //"*" = All, 2 = Bit 1 = CSP Applications
		If '(sc) Do $System.Status.DisplayError(sc) Quit
		Write !,"<br>"
		Write !,"<b style='color: #0000FF; font-size: 12px; line-height: 14px; font-family: Arial, Helvetica, sans-serif;'>Applications</b>"
		Write !,"<table style='font-family: Arial, Helvetica, sans-serif; font-size: 11px; line-height: 14px;width: 100%;' class=sortable id='cspapp' border cellpadding=2 cellspacing=0>"
		Write !,"<tr title='Click to sort'>"
		For col=1:1:rs.GetColumnCount() Write !,"<th align='center'><b>",rs.GetColumnName(col),"</b></th>"
		Write !,"</tr>"
		While rs.Next() {
			Write !,"<tr valign=""top"">"
			For col=1:1:rs.GetColumnCount() Write !,"<td nowrap>",$ZConvert(rs.GetData(col),"O","HTML"),"&nbsp;</td>"
			Write !,"</tr>"
		}
		Write !,"</table>"
		Write !,"<br><br>"
	}
	Catch {
		Use PDev
		Write !,"ERROR: ",$ZCvt($ZError,"O","HTML"),!
		Use LogFile
	}
	Set rs=""
	Use PDev Write:display "."
	Quit
	/// Security related informations. 
Security //
	Use LogFile
 	Write !,"<hr size=""2"" noshade>"
 	Write !,"<table border=""0"" width=""100%""><tr>"
 	Write !,"<td><b><font color=""#0000FF"" face=""Arial, Helvetica, sans-serif"" size=""4""><a name=""security""></a>Security</font></b></td>"
 	Write !,"<td align=right><a href=""#top"">top</a></td>"
 	Write !,"</tr></table>"
	Try {
		Use LogFile
		Write !,"<br><b style='color: #0000FF; font-size: 12px; line-height: 14px; font-family: Arial, Helvetica, sans-serif;'>Security Parameters</b>"
		Set rs = ##class(%Library.ResultSet).%New("Security.System:List")
		If 'rs Do $System.Status.DisplayError(%objlasterror) Quit
		Set rs.RuntimeMode=1
		Do rs.Execute()
		Write !,"<table style='font-family: Arial, Helvetica, sans-serif; font-size: 12px;' id='secparams' border cellpadding=2 cellspacing=0>"
		While rs.Next() {
			Write !
			For i=1:1:rs.GetColumnCount() Write "<tr><td>",rs.GetColumnName(i),"</td><td class='sortable_nosort'>",rs.GetData(i),"&nbsp;</td></tr>",!
		}
		Write "</table>",!
		Write !,"<br>" 
	}
	Catch {
		Use PDev
		Write !,"ERROR: ",$ZCvt($ZError,"O","HTML"),!
		Use LogFile
	}
	//Security Services 
	Try {
		Write !,"<hr size=""2"" noshade>"
		Write !,"<b style='color: #0000FF; font-size: 12px; line-height: 14px; font-family: Arial, Helvetica, sans-serif;'>Services</b>"
		Set rs = ##class(%Library.ResultSet).%New("Security.Services:Detail")
		If 'rs Do $System.Status.DisplayError(%objlasterror) Quit
		Do rs.Execute("*")
		Write !,"<br>"
		Write !,"<table class=sortable id='secservice' border style='font-size: 12px; font-family: Arial, Helvetica, sans-serif; width: 100%' cellpadding=2 cellspacing=0>"
		Write !,"<tr>"
		For col=1:1:rs.GetColumnCount() Write !,"<th align='center' title='Click to sort'><b>",(rs.GetColumnName(col)),"</b></th>"
		Write !,"</tr>"
		While rs.Next() {
			Write !,"<tr valign=""top"">"
			For col=1:1:rs.GetColumnCount() Write !,"<td>",($ZConvert(rs.GetData(col),"O","HTML")),"&nbsp;</td>"
			Write !,"</tr>"
		}
		Write !,"</table>"
		Write !,"<br>"
	}
	Catch {
		Use PDev
		Write !,"ERROR: ",$ZCvt($ZError,"O","HTML"),!
		Use LogFile
	}
	//Security Resources
	Try {
		Write !,"<hr size=2 noshade>"
		Write !,"<b style='color: #0000FF; font-size: 12px; line-height: 14px; font-family: Arial, Helvetica, sans-serif;'>Resources</b>"
		Set rs = ##class(%Library.ResultSet).%New("Security.Resources:List")
		If 'rs Do $System.Status.DisplayError(%objlasterror) Quit
		Do rs.Execute()
		Write !,"<br>"
		Write !,"<table class=sortable id='secresource' border style='font-size: 12px; font-family: Arial, Helvetica, sans-serif; width: 100%' cellpadding=2 cellspacing=0>"
		Write !,"<tr>"
		For col=1:1:rs.GetColumnCount() Write !,"<th align='center' title='Click to sort'><b>",(rs.GetColumnName(col)),"</b></th>"
		Write !,"</tr>"
		While rs.Next() {
			Write !,"<tr valign=""top"">"
			For col=1:1:rs.GetColumnCount() Write !,"<td>",($ZConvert(rs.GetData(col),"O","HTML")),"&nbsp;</td>"
			Write !,"</tr>"
		}
		Write !,"</table>"
		Write !,"<br>"
	}
	Catch {
		Use PDev
		Write !,"ERROR: ",$ZCvt($ZError,"O","HTML"),!
		Use LogFile
	}
	//Security Roles
	Try {
		Write !,"<hr size=2 noshade>"
		Write !,"<b style='color: #0000FF; font-size: 12px; line-height: 14px; font-family: Arial, Helvetica, sans-serif;'>Roles</b>"
		Set rs = ##class(%Library.ResultSet).%New("Security.Roles:Detail")
		If 'rs Do $System.Status.DisplayError(%objlasterror) Quit
		Do rs.Execute("*")
		Write !,"<br>"
		Write !,"<table class=sortable id='secroles' border style='font-size: 12px; font-family: Arial, Helvetica, sans-serif; width: 100%' cellpadding=2 cellspacing=0>"
		Write !,"<tr>"
		For col=1:1:rs.GetColumnCount() Write !,"<th align='center' title='Click to sort'><b>",rs.GetColumnName(col),"</b></th>"
		Write !,"</tr>"
		Set sc=rs.Next()
		While sc {
			Set Role=rs.Data("Name")
			Write !,"<tr><td valign=top>",rs.Data("Name"),"</td>",!
			Write "<td valign=top>",$ZConvert(rs.Data("Description"),"O","HTML"),"&nbsp;</td>",!
			If rs.Data("GrantedRoles")'="" {
				Write "<td valign=top>",rs.Data("GrantedRoles"),"</td>",!
			} Else {
				Write "<td>&nbsp;</td>",!
			}
			Set res=rs.Data("Resources")
			If res'="" {
				Write "<td valign=top>",$Piece(res,":",1)," : ",$Piece(res,":",2),"<br>",!
				Set sc=rs.Next()
				While (sc) && (rs.Data("Name")=Role) {
					Set res=rs.Data("Resources")
					Write $Piece(res,":",1)," : ",$Piece(res,":",2),"<br>",!
					Set sc=rs.Next()
				}
				Write "</td>",!
			} Else {
				Set sc=rs.Next()
				Write "<td>&nbsp;</td>",!
			}
			Write "</tr>",!
		}
		Write !,"</table>"
		Write !,"<br>"
	}
	Catch {
		Use PDev
		Write !,"ERROR: ",$ZCvt($ZError,"O","HTML"),!
		Use LogFile
	}
	//Security Databases
	Try {
		Write !,"<hr size=2 noshade>"
		Write !,"<b style='color: #0000FF; font-size: 12px; line-height: 14px; font-family: Arial, Helvetica, sans-serif;'>Databases</b>"
		If $System.Version.GetNumber()="2008.2" {
			Set rs = ##class(%Library.ResultSet).%New("Config.DataStorage:LocalDatabaseList")
		}
		Else  {
			Set rs = ##class(%Library.ResultSet).%New("Config.Databases:List")
		}
		If 'rs Do $System.Status.DisplayError(%objlasterror) Quit
		Do rs.Execute()
		Write !,"<br>"
		Write !,"<table class=sortable id='databases' border style='font-size: 12px; font-family: Arial, Helvetica, sans-serif; width: 100%' cellpadding=2 cellspacing=0>"
		Write !,"<tr>"
		For col=1:1:rs.GetColumnCount() Write !,"<th align='center' title='Click to sort'><b>",(rs.GetColumnName(col)),"</b></th>"
		Write !,"</tr>"
		While rs.Next() {
			Write !,"<tr valign=""top"">"
			For col=1:1:rs.GetColumnCount() Write !,"<td>",($ZConvert(rs.GetData(col),"O","HTML")),"&nbsp;</td>"
			Write !,"</tr>"
		}
		Write !,"</table>"
		Write !,"<br>"
	}
	Catch {
		Use PDev
		Write !,"ERROR: ",$ZCvt($ZError,"O","HTML"),!
		Use LogFile
	}
	//Security Users
	Try {
		Write !,"<hr size=2 noshade>"
		Write !,"<b style='color: #0000FF; font-size: 12px; line-height: 14px; font-family: Arial, Helvetica, sans-serif;'>System Users</b>"
		Set rs = ##class(%Library.ResultSet).%New("Security.Users:Detail")
		If 'rs Do $System.Status.DisplayError(%objlasterror) Quit
		Do rs.Execute("*","*")
		Write !,"<br>"
		Write !,"<table class=sortable id='secloginfail' border style='font-size: 12px; font-family: Arial, Helvetica, sans-serif; width: 100%' cellpadding=2 cellspacing=0>"
		Write !,"<tr>"
		For col=1:1:rs.GetColumnCount() Write !,"<th align='center' title='Click to sort'><b>",(rs.GetColumnName(col)),"</b></th>"
		Write !,"</tr>"
		While rs.Next() {
			Write !,"<tr valign=""top"">"
			For col=1:1:rs.GetColumnCount() Write !,"<td>",($ZConvert(rs.GetData(col),"O","HTML")),"&nbsp;</td>"
			Write !,"</tr>"
		}
		Write !,"</table>"
		Write !,"<br>"
	}
	Catch {
		Use PDev
		Write !,"ERROR: ",$ZCvt($ZError,"O","HTML"),!
		Use LogFile
	}
	//Security SSL Configurations
	Try {
		Write !,"<hr size=2 noshade>"
		Write !,"<b style='color: #0000FF; font-size: 12px; line-height: 14px; font-family: Arial, Helvetica, sans-serif;'>SSL Configurations</b>"
		Set rs = ##class(%Library.ResultSet).%New("Security.SSLConfigs:Detail")
		If 'rs Do $System.Status.DisplayError(%objlasterror) Quit
		Do rs.Execute()
		Write !,"<br>"
		Write !,"<table class=sortable id='secusers' border style='font-size: 12px; font-family: Arial, Helvetica, sans-serif; width: 100%' cellpadding=2 cellspacing=0>"
		Write !,"<tr>"
		For col=1:1:rs.GetColumnCount() Write !,"<th align='center' title='Click to sort'><b>",(rs.GetColumnName(col)),"</b></th>"
		Write !,"</tr>"
		While rs.Next() {
			Write !,"<tr valign=""top"">"
			For col=1:1:rs.GetColumnCount() Write !,"<td>",($ZConvert(rs.GetData(col),"O","HTML")),"&nbsp;</td>"
			Write !,"</tr>"
		}
		Write !,"</table>"
		Write !,"<br>"
	}
	Catch {
		Use PDev
		Write !,"ERROR: ",$ZCvt($ZError,"O","HTML"),!
		Use LogFile
	}
	if '($system.Version.GetProduct()["IRIS") {  //STC2675
	//Security Domains  
	  Try {
		Write !,"<hr size=2 noshade>","<br>"
		Write !,"<b style='color: #0000FF; font-size: 12px; line-height: 14px; font-family: Arial, Helvetica, sans-serif;'>Domains</b>"
		Set rs = ##class(%Library.ResultSet).%New("Security.Domains:List")
		If 'rs Do $System.Status.DisplayError(%objlasterror) Quit
		Do rs.Execute("*")
		Write !,"<br>"
		Write !,"<table class=sortable id='secdomains' border style='font-size: 12px; font-family: Arial, Helvetica, sans-serif; width: 100%' cellpadding=2 cellspacing=0>"
		Write !,"<tr>"
		For col=1:1:rs.GetColumnCount() Write !,"<th align='center' title='Click to sort'><b>",(rs.GetColumnName(col)),"</b></th>"
		Write !,"</tr>"
		While rs.Next() {
			Write !,"<tr valign=""top"">"
			For col=1:1:rs.GetColumnCount() Write !,"<td>",($ZConvert(rs.GetData(col),"O","HTML")),"&nbsp;</td>"
			Write !,"</tr>"
		}
		Write !,"</table>"
		Write !,"<br>"
	  }
	  Catch {
		Use PDev
		Write !,"ERROR: ",$ZCvt($ZError,"O","HTML"),!
		Use LogFile
	  }
	}
	Set rs=""
	Use PDev Write:display "."
	Quit
 /// Audit related informations.
Audit  //
	//Audit-Events
	Use LogFile
 	Write !,"<hr size=""2"" noshade>"
 	Write !,"<table border=""0"" width=""100%""><tr>"
 	Write !,"<td><b><font color=""#0000FF"" face=""Arial, Helvetica, sans-serif"" size=""4""><a name=""audit""></a>Audit</font></b></td>"
 	Write !,"<td align=right><a href=""#top"">top</a></td>"
 	Write !,"</tr></table>"
	Try {
		Write !,"<br><b style='color: #0000FF; font-size: 12px; line-height: 14px; font-family: Arial, Helvetica, sans-serif;'>Audit Events</b>"
		Set rs = ##class(%Library.ResultSet).%New("Security.Events:ListAll")
		If 'rs Do $System.Status.DisplayError(%objlasterror) Quit
		Do rs.Execute("*","*","*")
		Write !,"<br>"
		Write !,"<table class=sortable id='secevents' border style='font-size: 12px; font-family: Arial, Helvetica, sans-serif; width: 100%' cellpadding=2 cellspacing=0>"
		Write !,"<tr>"
		For col=1:1:rs.GetColumnCount()-2 Write !,"<th align='center' title='Click to sort'><b>",(rs.GetColumnName(col)),"</b></th>"
		Write !,"</tr>"
		While rs.Next() {
			Write !,"<tr valign=""top"">"
			For col=1:1:rs.GetColumnCount()-2 Write !,"<td>",($ZConvert(rs.GetData(col),"O","HTML")),"&nbsp;</td>"
			Write !,"</tr>"
		}
		Write !,"</table>"
		Write !,"<br>"
	}
	Catch {
		Use PDev
		Write !,"ERROR: ",$ZCvt($ZError,"O","HTML"),!
		Use LogFile
	}
	//Audit-Log
	Try {
		Write !,"<hr size=2 noshade>"
		Write !,"<b style='color: #0000FF; font-size: 12px; line-height: 14px; font-family: Arial, Helvetica, sans-serif;'>Audit Log ("_2_" days, last "_2000_" entries) </b>"
		Set rs = ##class(%Library.ResultSet).%New("%SYS.Audit:List")
		If 'rs Do $System.Status.DisplayError(%objlasterror) Quit
		Set beginDate=$ZDateTime($Horolog-2+1_",0",3)
		Do rs.Execute(beginDate)
		Write !,"<br>"
		Write !,"<table class=sortable id='secauditlog' border style='font-size: 12px; font-family: Arial, Helvetica, sans-serif; width: 100%' cellpadding=2 cellspacing=0>"
		Write !,"<tr>"
		For col=2:1:10 Write !,"<th align='center' title='Click to sort'><b>",(rs.GetColumnName(col)),"</b></th>"
		Write !,"<th align='center' title='Click to sort'><b>EventData</b></th>"
		Write !,"</tr>"
		Set count=0
		While rs.Next() {
			If $Increment(count)>2000 Quit
			Write !,"<tr valign=""top"">"
			For col=2:1:10 Write !,"<td>",($ZConvert(rs.GetData(col),"O","HTML")),"&nbsp;</td>"
			Set eventData=##class(%SYS.Audit).%OpenId(rs.GetData(11)_"||"_rs.GetData(1)_"||"_rs.GetData(2)).EventData
			Write !,"<td class=audit>",($ZConvert(eventData,"O","HTML")),"</td>"
			Write !,"</tr>"
		}
		Write !,"</table>"
		Write !,"<br><br>"
	}
	Catch {
		Use PDev
		Write !,"ERROR: ",$ZCvt($ZError,"O","HTML"),!
		Use LogFile
	}
	Set rs=""
	Use PDev Write:display "."
	Quit
Processes //
	Use LogFile
 	Write !,"<hr size=""2"" noshade>"
 	Write !,"<table border=""0"" width=""100%""><tr>"
 	Write !,"<td><b><font color=""#0000FF"" face=""Arial, Helvetica, sans-serif"" size=""4""><a name=""processes""></a>Processes</font></b></td>"
 	Write !,"<td align=right><a href=""#top"">top</a></td>"
 	Write !,"</tr></table>"
 	Write !,"<br>"
	Try {
		Set rs = ##class(%Library.ResultSet).%New()
		If 'rs Do $System.Status.DisplayError(%objlasterror) Quit
		If 'rs.Prepare("select * from %SYS.ProcessQuery") Do $System.Status.DisplayError(%objlasterror) Quit
		Do rs.Execute()
		Write !,"<table class=sortable id='procs' border style='font-size: 12px; font-family: Arial, Helvetica, sans-serif; width: 100%' cellpadding=2 cellspacing=0>"
		Write !,"<tr>"
		For col=1:1:rs.GetColumnCount() Write !,"<th align='center' title='Click to sort'><b>",(rs.GetColumnName(col)),"</b></th>"
		Write !,"</tr>"
		While rs.Next() {
			Write !,"<tr valign=""top"">"
			For col=1:1:rs.GetColumnCount() Write !,"<td>",($ZConvert(rs.GetData(col),"O","HTML")),"&nbsp;</td>"
			Write !,"</tr>"
		}
		Write !,"</table>"
		Write !,"<br>"
	}
	Catch {
		Use PDev
		Write !,"ERROR: ",$ZCvt($ZError,"O","HTML"),!
		Use LogFile
	}
	Set rs=""
	Use PDev Write:display "."
	Quit
LockTab //
	Use LogFile
	Write !,"<hr size=""2"" noshade>"
 	Write !,"<table border=""0"" width=""100%""><tr>"
 	Write !,"<td><b><font color=""#0000FF"" face=""Arial, Helvetica, sans-serif"" size=""4""><a name=""locktab""></a>LockTab</font></b></td>"
 	Write !,"<td align=right><a href=""#top"">top</a></td>"
 	Write !,"</tr></table>"
 	Write !,"<br>"
 	Try {
 		Set rs = ##class(%Library.ResultSet).%New("%SYS.LockQuery:Detail")
		If 'rs Do $System.Status.DisplayError(%objlasterror) Quit
		Do rs.Execute("")
		Write !,"<table class=sortable id='procs' border style='font-size: 12px; font-family: Arial, Helvetica, sans-serif; width: 100%' cellpadding=2 cellspacing=0>"
		Write !,"<tr>"
		For col=1:1:rs.GetColumnCount() Write:rs.GetColumnName(col)'="DelKey" !,"<th align='center' title='Click to sort'><b>",(rs.GetColumnName(col)),"</b></th>"
		Write !,"</tr>"
		While rs.Next() {
			Write !,"<tr valign=""top"">"
			For col=1:1:rs.GetColumnCount() Write:rs.GetColumnName(col)'="DelKey" !,"<td>",($ZConvert(rs.GetData(col),"O","HTML")),"&nbsp;</td>"
			Write !,"</tr>"
		}
		Write !,"</table>"
		Write !,"<br>"
 	}
 	Catch {
		Use PDev
		Write !,"ERROR: ",$ZCvt($ZError,"O","HTML"),!
		Use LogFile
	}
 	Use PDev Write:display "."
 	Quit
SysLog //
	New detail,%ST
	Use LogFile
	Write !,"<hr size=""2"" noshade>"
 	Write !,"<table border=""0"" width=""100%""><tr>"
 	Write !,"<td><b><font color=""#0000FF"" face=""Arial, Helvetica, sans-serif"" size=""4""><a name=""syslog""></a>SysLog</font></b></td>"
 	Write !,"<td align=right><a href=""#top"">top</a></td>"
 	Write !,"</tr></table>"
 	Write !,"<pre>"
 	Try {
 		Set detail=1
		Do INT^SYSLOG
 	}
 	Catch {
		Use PDev
		Write !,"ERROR: ",$ZCvt($ZError,"O","HTML"),!
		Use LogFile
	}
	Write !,"</pre>"
 	Use PDev Write:display "."
 	Quit
Cconsole //or message.log (IRIS)
	New cconsoleFile,cconsoleSize,MaxCconsoleSize,x,SkipSize
	Use LogFile
	Write !,"<hr size=""2"" noshade>"
 	Write !,"<table border=""0"" width=""100%""><tr>"
 	Write !,"<td><b><font color=""#0000FF"" face=""Arial, Helvetica, sans-serif"" size=""4""><a name=""cconsole""></a>"_$s($system.Version.GetProduct()["IRIS":"messages.log",1:"cconsole.log")_"</font></b></td>"
 	Write !,"<td align=right><a href=""#endcconsole"">end of "_$s($system.Version.GetProduct()["IRIS":"messages.log",1:"cconsole.log")_"</a>&nbsp;&nbsp;<a href=""#top"">top</a></td>"
 	Write !,"</tr></table>"
	Try {
		If $zconvert($System.Version.GetBuildOS(),"U")?1"WIN".e!($zconvert($System.Version.GetBuildOS(),"U")["UNIX") {
			Set cconsoleFile=MgrDir_DirDelim_$s($system.Version.GetProduct()["IRIS":"messages.log",1:"cconsole.log")
		}
		Else  {
			If $zconvert($System.Version.GetBuildOS(),"U")["VMS" Set cconsoleFile=MgrDir_$s($system.Version.GetProduct()["IRIS":"MESSAGES.LOG",1:"CCONSOLE.LOG")  //IRIS for VMS is not supported
		}
		Set cconsoleSize=$ZUtil(140,1,cconsoleFile)
		If 'cconsoleSize {
	  		Use LogFile Write !,"<pre>File "_cconsoleFile_" is zero bytes long.</pre>"
	  		Use PDev
	  		Quit
		}
		//Only put the last x mb in the file
		Set MaxCconsoleSize=8388608 //8mb
		If (cconsoleSize>MaxCconsoleSize) {
		    s SkipSize=cconsoleSize-MaxCconsoleSize
			Use LogFile Write !,"<pre>File "_cconsoleFile_" is "_cconsoleSize_" bytes. This is too large, skipping first "_SkipSize_" bytes.</pre>"
		}
		Else {
			s SkipSize=0
		}
		Use LogFile Write !,"<pre>"
		Do CopyToLog(cconsoleFile,SkipSize)
		Use LogFile Write !,"</pre>"
	}
	Catch {
		Use PDev
		Write !,"ERROR: ",$ZCvt($ZError,"O","HTML"),!
		Use LogFile
	}
	Write !,"<span><a name=""endcconsole""></a></span>"
	Use PDev Write:display "."
	Quit
CopyToLog(InputFile,SkipSize=0)
	; Appends a file to LogFile
	; SkipSize - Skip the first x number of bytes in the file to reduce size. Used by cconsole/messages.log to keep it a reasonable size
	New x,Size,ZEOF
	Set $ZTrap="CopyToLogErr"
	Open InputFile:"R":5
	If '$Test Use LogFile Write !,"<pre>File "_InputFile_" does not exist</pre>" Use PDev Quit
	; Read timeout added to prevent the case where neither <ENDOFFILE> error nor $ZEOF terminate the loop
	s Size=0
	For  Use InputFile Read x:30 Set ZEOF=$ZEof Use PDev Quit:'$Test!(ZEOF)  s Size=Size+$l(x) continue:SkipSize>Size  Use LogFile Write $zconvert(x,"O","HTML"),$Char(13,10) Use PDev
	Close InputFile
	Quit
CopyToLogErr
	Set $ZTrap=""
	Close InputFile
	Use LogFile Write ! Use PDev
	Set $ZError=""
	Quit
HttpdConfPWS //Displays httpd.conf of PWS
	New file,line,HttpdConfPWS,idir
	Use LogFile
	Write !,"<hr size=""2"" noshade>"
 	Write !,"<table border=""0"" width=""100%""><tr>"
 	Write !,"<td><b><font color=""#0000FF"" face=""Arial, Helvetica, sans-serif"" size=""4""><a name=""httpdconfpws""></a>Apache PWS Configuration File</font></b></td>"
 	Write !,"<td align=right><a href=""#top"">top</a></td>"
 	Write !,"</tr></table>"
 	Try {
   		Set idir=$system.Util.DataDirectory() //$system.Util.InstallDirectory() //c:\intersystems\iris20191\
 	}
 	Catch {
   		Set idir=$p($zu(12),"mgr",1)
 	}
	Try {
		Set HttpdConfPWS=##class(%Library.File).NormalizeFilename(idir_"httpd/conf/httpd.conf")
		Write !,"<p style='color: #0000FF; font-size: 12px; line-height: 14px; font-family: Verdana, sans-serif;'><b>"_HttpdConfPWS_"</b></p>"
		Write !,"<pre>"
		Set file=##class(%Library.FileCharacterStream).%New()
		Set file.Filename=HttpdConfPWS
		While 'file.AtEnd {
			Set line=file.ReadLine(20000)
			Write $ZConvert(line,"O","HTML"),!
		}
		kill file
		Write !,"</pre>"
	}
	Catch {
		Use PDev
		Write !,"ERROR: ",$ZCvt($ZError,"O","HTML"),!
		Use LogFile
	}
	kill file
	Use PDev Write:display "."
	Quit
ErrorLogPWS  //Displays error.log of PWS
	New file,line,ErrorLogPWS,entry,first,last,i,NumberErrorLogsPWS,idir
	Set NumberErrorLogsPWS=1000
	Use LogFile
	Write !,"<hr size=""2"" noshade>"
 	Write !,"<table border=""0"" width=""100%""><tr>"
 	Write !,"<td><b><font color=""#0000FF"" face=""Arial, Helvetica, sans-serif"" size=""4""><a name=""errorlogpws""></a>Apache PWS Error Log</font></b></td>"
 	Write !,"<td align=right><a href=""#top"">top</a></td>"
 	Write !,"</tr></table>"
 	Try {
   		Set idir=$system.Util.DataDirectory() //$system.Util.InstallDirectory() //c:\intersystems\iris20191\
 	}
 	Catch {
   		Set idir=$p($zu(12),"mgr",1)
 	}
	Try {
		Set ErrorLogPWS=##class(%Library.File).NormalizeFilename(idir_"httpd/logs/error.log")
		Write !,"<p style='color: #0000FF; font-size: 12px; line-height: 14px; font-family: Verdana, sans-serif;'><b>"_ErrorLogPWS_"</b> <i>(max. last 1000 entries)</i></p>"
		Write !,"<pre>"
		if $system.Version.GetProduct()["IRIS" { Kill ^||CacheTemp("error.log") } else  { Kill ^||IRIS.Temp("error.log") }
		Set file=##class(%Library.FileCharacterStream).%New()
		Set file.Filename=ErrorLogPWS
		While 'file.AtEnd {
			Set line=file.ReadLine(20000)
			if $system.Version.GetProduct()["IRIS" {
				Set entry=$Increment(^||IRIS.Temp("error.log"))
				Set ^||IRIS.Temp("error.log",entry)=line
			}
			else  {
				Set entry=$Increment(^||CacheTemp("error.log"))
				Set ^||CacheTemp("error.log",entry)=line
			}			
		}
		Set last=$s($system.Version.GetProduct()["IRIS":$Get(^||IRIS.Temp("error.log")),1:$Get(^||CacheTemp("error.log")))
		Set first=last-NumberErrorLogsPWS+1 If first<1 Set first=1
		For i=first:1:last {
			Write $ZConvert($s($system.Version.GetProduct()["IRIS":^||IRIS.Temp("error.log",i),1:^||CacheTemp("error.log",i)),"O","HTML"),!
		}
		Kill file
		Write !,"</pre>"
	}
	Catch {
		Use PDev
		Write !,"ERROR: ",$ZCvt($ZError,"O","HTML"),!
		Use LogFile
	}
	Kill file
	if $system.Version.GetProduct()["IRIS" { Kill ^||CacheTemp("error.log") } else  { Kill ^||IRIS.Temp("error.log") }
	Use PDev Write:display "."
	Quit
LogGWHeader	//
	Use LogFile
	Write !,"<hr noshade size=""4"">"
	Write !,"<br>"
	Write !,"<b><font face=""Arial, Helvetica, sans-serif"" style=""font-weight:bold;font-size:24px;color:"_"SteelBlue"_";""><a name=""cspserver"_mgrid_"""></a>Web/CSP-Gateway on "_CSPMgr.Server_" : "_CSPMgr.Port_$s(CSPMgr.Port=$g(webserverport):" *PWS*",1:"")_"</font></b><br>"
	Use PDev Write:display "."
	Quit
LogGWInfo // About CSP Gateway
 	Set sc=CSPMgr.GetInfo(.info)
 	Quit:'sc
 	Use LogFile
 	Write !,"<hr size=""2"" noshade>"
 	Write !,"<table border=""0"" width=""100%""><tr>"
 	Write !,"<td><b><font color=""#0000FF"" face=""Arial, Helvetica, sans-serif"" size=""4""><a name=""cspinfo"_mgrid_"""></a>Web/CSP-Gateway Info for "_CSPMgr.Server_" : "_CSPMgr.Port_"</font></b></td>"
 	Write !,"<td align=right><a href=""#top"">top</a></td>"
 	Write !,"</tr></table>"
 	Write "",!
	Write "	<table border=""0"">",!
	Write "	<tr>",!
	Write "	<td nowrap valign=""top""><font color=""#0000FF"" face=""Arial, Helvetica, sans-serif"">Webserver (IP):</font></td>",!
	Write "	<td><font color=""#000000"" face=""Arial, Helvetica, sans-serif""> "_(CSPMgr.Server)_"</font></td>",!
	Write "	</tr>",!
	Write "	<tr>",!
	Write "	<td nowrap valign=""top""><font color=""#0000FF"" face=""Arial, Helvetica, sans-serif"">Webserver Port:</font></td>",!
	Write "	<td><font color=""#000000"" face=""Arial, Helvetica, sans-serif""> "_(CSPMgr.Port)_"</font></td>",!
	Write "	</tr>",!
	Write "	<tr>",!
	Write "	<td nowrap valign=""top""><font color=""#0000FF"" face=""Arial, Helvetica, sans-serif"" >Version:</font></td>",!
	Write "	<td><font color=""#000000"" face=""Arial, Helvetica, sans-serif""> "_(info.Version)_"</font></td>",!
	Write "	</tr>",!
	Write "	<tr>",!
	Write "	<td nowrap valign=""top""> <font color=""#0000FF"" face=""Arial, Helvetica, sans-serif"">Gateway Build:</font></td>",!
	Write "	<td><font color=""#000000"" face=""Arial, Helvetica, sans-serif""> "_(info.Build)_"</font></td>",!
	Write "	</tr>",!
	Write "	<tr>",!
	Write "	<td nowrap valign=""top""><font color=""#0000FF"" face=""Arial, Helvetica, sans-serif"">Web Server Name:</font></td>",!
	Write "	<td><font color=""#000000"" face=""Arial, Helvetica, sans-serif""> "_(info.WebServerName)_"</font> ",!
	Write "	</td>",!
	Write "	</tr>",!
	Write "	<tr>",!
	Write "	<td nowrap valign=""top""><font color=""#0000FF"" face=""Arial, Helvetica, sans-serif"">Web Server Type:</font></td>",!
	Write "	<td><font color=""#000000"" face=""Arial, Helvetica, sans-serif""> "_(info.WebServerSoftware)_"</font>",!
	Write "	</td>",!
	Write "	</tr>",!
	Write "	<tr>",!
	Write "	<td nowrap valign=""top""><font color=""#0000FF"" face=""Arial, Helvetica, sans-serif"">Active Interface:</font></td>",!
	Write "	<td><font color=""#000000"" face=""Arial, Helvetica, sans-serif""> "_(info.ActiveInterface)_"</font>",!
	Write "	</td>",!
	Write "	</tr>",! 
	if +$System.Version.GetNumber()>=2015.1 {  //CMT1293 2015.1+
		Write "",!
	Write "		<tr>",!
	Write "		<td nowrap valign=""top""><font color=""#0000FF"" face=""Arial, Helvetica, sans-serif"">Configuration:</font></td>",!
	Write "		<td><font color=""#000000"" face=""Arial, Helvetica, sans-serif""> "_(info.Configuration)_"</font>",!
	Write "		</td>",!
	Write "		</tr>",!
	Write "		",! 
	}
	Write "",!
	Write "	</table>",!
	Write " 	",! 
	Use PDev Write:display "."
 	Quit
LogGWIni // Get CSP.INI
	Set sc=CSPMgr.GetCSPIni(.ini,"stream")
	Quit:'sc
	Use LogFile
	Write !,"<hr size=""2"" noshade>"
	Write !,"<table border=""0"" width=""100%""><tr>"
	Write !,"<td><b><font color=""#0000FF"" face=""Arial, Helvetica, sans-serif"" size=""4""><a name=""cspini"_mgrid_"""></a>CSP.INI for Web/CSP-Gateway "_CSPMgr.Server_" : "_CSPMgr.Port_"</font></b></td>"
	Write !,"<td align=right><a href=""#top"">top</a></td>"
    Write !,"</tr></table>"
	Write "<pre>",! 
	do ini.OutputToDevice()  //while 'ini.AtEnd { Write ini.Read() }
	Write "</pre>",! 
	Use PDev Write:display "."
	Quit
LogGWDefParams // Gateway Default Params
	New config, item
	Set sc=CSPMgr.GetDefaultParams(.config)
	Quit:'sc
	Use LogFile
	Write !,"<hr size=""2"" noshade>"
	Write !,"<table border=""0"" width=""100%""><tr>"
	Write !,"<td><b><font color=""#0000FF"" face=""Arial, Helvetica, sans-serif"" size=""4""><a name=""cspdefparams"_mgrid_"""></a>Default Params for Web/CSP-Gateway "_CSPMgr.Server_" : "_CSPMgr.Port_"</font></b></td>"
	Write !,"<td align=right><a href=""#top"">top</a></td>"
    Write !,"</tr></table>"
	Write "<pre>",! 
	Set item="" for  set item=$order(config(item)) quit:item=""  write item,?32,": ",config(item),!
	Write "</pre>",! 
	Use PDev Write:display "."
	Quit
LogGWServersParams // Servers and Server Params
	New serverList, srvname, srvconfig, item
	Set sc=CSPMgr.GetServers(.serverList)
	Quit:'sc
	Use LogFile
	Write !,"<hr size=""2"" noshade>"
	Write !,"<table border=""0"" width=""100%""><tr>"
	Write !,"<td><b><font color=""#0000FF"" face=""Arial, Helvetica, sans-serif"" size=""4""><a name=""cspserversparams"_mgrid_"""></a>Servers Params for Web/CSP-Gateway "_CSPMgr.Server_" : "_CSPMgr.Port_"</font></b></td>"
	Write !,"<td align=right><a href=""#top"">top</a></td>"
    Write !,"</tr></table>"
	Write !,"<pre>"
	For i=1:1:$LISTLENGTH(serverList) {
		Set srvname=$piece($listget(serverList,i),"=",1)
		Write !!,"[",srvname,"] = ",$piece($listget(serverList,i),"=",2),!
		Kill srvconfig
		Set sc=CSPMgr.GetServerParams(srvname,.srvconfig)
		Quit:'sc
		SET item=""
		for  {set item=$order(srvconfig(item)) quit:item=""  write item,?32,": ",srvconfig(item),!}
	}
	Write !,"</pre>"
	Use PDev Write:display "."	
	Quit
LogGWAppPathsParams // Application Paths and Path Params
	New appPaths, appPath, appconfig, item
	Set sc=CSPMgr.GetApplicationPaths(.appPaths)
	Quit:'sc
	Use LogFile
	Write !,"<hr size=""2"" noshade>"
	Write !,"<table border=""0"" width=""100%""><tr>"
	Write !,"<td><b><font color=""#0000FF"" face=""Arial, Helvetica, sans-serif"" size=""4""><a name=""cspapppathsparams"_mgrid_"""></a>Application Paths Params for Web/CSP-Gateway "_CSPMgr.Server_" : "_CSPMgr.Port_"</font></b></td>"
	Write !,"<td align=right><a href=""#top"">top</a></td>"
    Write !,"</tr></table>"
	Write !,"<pre>"
	For i=1:1:$LISTLENGTH(appPaths) {
		Set appPath=$piece($listget(appPaths,i),"=",1)
		Write !!,"[",appPath,"] = ",$piece($listget(appPaths,i),"=",2),!
		Kill appconfig
		Set sc=CSPMgr.GetApplicationParams(appPath,.appconfig)
		Quit:'sc
		SET item=""
		for  {set item=$order(appconfig(item)) quit:item=""  write item,?32,": ",appconfig(item),!}		
	}
	Write !,"</pre>"	
	Use PDev Write:display "."
	Quit
LogGWStatus // Gateway System-Status Overview
	Set sc=CSPMgr.GetSystemStatus(.status)
	Quit:'sc
	Use LogFile
	Write !,"<hr size=""2"" noshade>"
	Write !,"<table border=""0"" width=""100%""><tr>"
	Write !,"<td><b><font color=""#0000FF"" face=""Arial, Helvetica, sans-serif"" size=""4""><a name=""cspstatus"_mgrid_"""></a>"_"Web/CSP-Gateway System Status for "_CSPMgr.Server_" : "_CSPMgr.Port_"</font></b><br></td>"
	Write !,"<td align=right><a href=""#top"">top</a></td>"
    Write !,"</tr></table>"
	Write "",!
	Write "	<font size=""+1"" face=""Verdana, Arial, Helvetica, sans-serif"">System Status <font size=""-1"" face=""Verdana, Arial, Helvetica, sans-serif""><I>("_($zdatetime($horolog,5))_")</I></font></font><br>",!
	Write "	<table bgcolor=#000088 border=1 cellspacing=""1"" cellpadding=""1"">",!
	Write "	<tr bgcolor=""#CCCCCC"">",!
	Write "	<th align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000"">Connection<br>Number</font></th>",!
	Write "	<th align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000"">Gateway<br>PID</font></th>",!
	Write "	<th align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000"">Server<br>Name</font></th>",!
	Write "	<th align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000"">IP<br>Address</font></th>",!
	Write "	<th align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000"">TCP<br>Port</font></th>",!
	Write "	<th align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000"">"_($s($system.Version.GetProduct()["IRIS":"IRIS",1:"Cach"))_"<br>PID</font></th>",!
	Write "	<th align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000"">Status</font></th>",!
	Write "	<th align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000"">Idle time<br>/ Timeout</font></th>",!
	Write "	<th align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000"">Activity</font></th>",!
	Write "	</tr>",! 
	set cnid=""
	for  {
		 set conn=status.Connections.GetNext(.cnid)
		 QUIT:cnid=""
		Write "",!
	Write "		<tr bgcolor=""#FFFFFF"">",!
	Write "		<td align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"">"_(cnid)_"</font></td>",!
	Write "		<td align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"">"_(conn.WebServerPID)_"</font></td>",!
	Write "		<td align=""CENTER""><font color=""#000000"" face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"">"_(conn.CacheServerName)_"</font></td>",!
	Write "		<td><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"">"_(conn.IPAddress)_"</font></td>",!
	Write "		<td align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"">"_(conn.TCPPort)_"</font></td>",!
	Write "		<td align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"">"_(conn.CacheServerPID)_"</font></td>",!
	Write "		<td><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"">"_(conn.Status)_"</font></td>",!
	Write "		<td align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"">"_(conn.IdleTime)_"</font></td>",!
	Write "		<td align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"">"_(conn.Activity)_"</font></td>",!
	Write "		</tr>",!
	Write "		",! 
	}
	Write "",!
	Write "	</table>",!
	Write "	<br>",!
	Write "	<p>",!
	Write "	<table bgcolor=#000088 border=1 cellspacing=""1"" cellpadding=""1"">",!
	Write "	<tr bgcolor=""#CCCCCC"">",!
	Write "	<th align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000"">Server<br>Number</font></th>",!
	Write "	<th align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000"">Server<br>Name</font></th>",!
	Write "	<th align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000"">IP<br>Address</font></th>",!
	Write "	<th align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000"">TCP<br>Port</font></th>",!
	Write "	<th align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000"">Total<br>Connections</font></th>",!
	Write "	<th align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000"">Connections<br>In-Use</font></th>",!
	Write "	<th align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000"">Private<br>Connections</font></th>",!
	Write "	<th align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000"">Total<br>Activity</font></th>",!
	Write "	<th align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000"">Queued<br>Requests</font></th>",!
	Write "	</tr>",!
	Write "	",! 
	set srvid=""
	for  {
		set srv=status.CacheServers.GetNext(.srvid)
		QUIT:srvid=""
		Write "",!
	Write "		<tr bgcolor=""#FFFFFF"">",!
	Write "		<td align=""CENTER""><font color=""#000000"" face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"">"_(srvid)_"</font></td>",!
	Write "		<td align=""CENTER""><font color=""#000000"" face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"">"_(srv.CacheServerName)_"</font></td>",!
	Write "		<td><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"">"_(srv.IPAddress)_"</font></td>",!
	Write "		<td align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"">"_(srv.TCPPort)_"</font></td>",!
	Write "		<td align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"">"_(srv.TotalConnections)_"</font></td>",!
	Write "		<td align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"">"_(srv.ConnectionsInUse)_"</font></td>",!
	Write "		<td align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"">"_(srv.PrivateConnections)_"</font></td>",!
	Write "		<td align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"">"_(srv.Activity)_"</font></td>",!
	Write "		<td align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"">"_(srv.QueuedRequests)_"</font></td>",!
	Write "		</tr>",!
	Write "		",! 
	}
	Write "",!
	Write "		</table>",!
	Write "		<br>",!
	Write "		<p>",!
	Write "		<table bgcolor=#000088 border=1 cellspacing=""1"" cellpadding=""1"">",!
	Write "		<tr bgcolor=""#CCCCCC"">",!
	Write "		<th align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000"">Path<br>Number</font></th>",!
	Write "		<th align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000"">Path</font></th>",!
	Write "		<th align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000"">Server<br>Number</font></th>",!
	Write "		<th align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000"">Server<br>Name</font></th>",!
	Write "		<th align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000"">Activity</font></th>",!
	Write "		<th align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000"">Status</font></th>",!
	Write "		<th align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000"">Action</font></th>",!
	Write "		",! 
	set appid=""
	for  {
		set app=status.ApplicationPaths.GetNext(.appid)
		QUIT:appid=""
		set appsid=""
		for  {
			set apps=app.AlternativeServer.GetNext(.appsid)
			QUIT:appsid=""
			Write "",!
	Write "			<tr bgcolor=""#FFFFFF"">",!
	Write "			<td align=""CENTER""><font color=""#000000"" face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1""> "_(appid)_"</font></td>",!
	Write "			<td align=""LEFT""><font color=""#000000"" face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1""> "_(app.Path)_"</font></td>",!
	Write "			<td align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1""> "_(appsid)_"</font></td>",!
	Write "			<td align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1""> "_(apps.CacheServerName)_"</font></td>",!
	Write "			<td align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1""> "_(apps.Activity)_"</font></td>",!
	Write "			<td align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1""> "_(apps.Status)_"</font></td>",!
	Write "			<td bgcolor=""#CCCCCC"" align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#CCCCCC""><b><br></b></font></td>",!
	Write "			</tr>",!
	Write "			",! 
		}
	}	
	Write "",!
	Write "	</table>",!
	Write "	<br>",!
	Write "	<p>",!
	Write "	<table bgcolor=#000088 border=1 cellspacing=""1"" cellpadding=""1"">",!
	Write "	<tr bgcolor=""#CCCCCC"">",!
	Write "	<th align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000"">Cached<br>Forms</font></th>",!
	Write "	<th align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000"">Cached Data<br>(Bytes)</font></th>",!
	Write "	<th align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000"">Cached Form<br>Activity</font></th>",!
	Write "	</tr>",!
	Write "	",! 
	set cache=status.CachedForms
	Write "	",!
	Write "		<tr bgcolor=""#FFFFFF"">",!
	Write "		<td align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1""> "_(cache.FormsInCache)_"</font></td>",!
	Write "		<td align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1""> "_(cache.CachedData)_"</font></td>",!
	Write "		<td align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1""> "_(cache.CacheActivity)_"</font></td>",!
	Write "		</tr>",!
	Write "		<tr bgcolor=""#CCCCCC"">",!
	Write "		<td align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000""><b>Form</b></font></td>",!
	Write "		<td align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000""><b>Size</b></font></td>",!
	Write "		<td align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1"" color=""#000000""><b>Activity</b></font></td>",!
	Write "		</tr>",!
	Write "	",! 
	set formid=""
	for  {
		set form=cache.Form.GetNext(.formid)
		QUIT:formid=""
		Write "",!
	Write "		<tr bgcolor=""#FFFFFF"">",!
	Write "		<td align=""LEFT""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1""> "_(formid)_"</font></td>",!
	Write "		<td align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1""> "_(form.Size)_"</font></td>",!
	Write "		<td align=""CENTER""><font face=""Verdana, Arial, Helvetica, sans-serif"" size=""-1""> "_(form.Activity)_"</font></td>",!
	Write "		</tr>",!
	Write "		",! 
	}
	Write "",!
	Write "	</table>",!
	Write "	<br>",!
	Write "	",! 
	Use PDev Write:display "."
	Quit
LogGWCSPLog // Get CSP.log
 	Use LogFile
	Write !,"<hr size=""2"" noshade>"
	Write !,"<table border=""0"" width=""100%""><tr>"
	Write !,"<td><b><font color=""#0000FF"" face=""Arial, Helvetica, sans-serif"" size=""4""><a name=""csplog"_mgrid_"""></a>CSP.log for "_CSPMgr.Server_" : "_CSPMgr.Port_"</font></b>" //<i>(Last "_$$$LastLogEvents_" entries in reverse order)</i></td>"
	Write !,"<td align=right><a href=""#endcsplog"_mgrid_""">end of csp.log</a>&nbsp;&nbsp;<a href=""#top"">top</a></td>"
    Write !,"</tr></table>"
	Set sc=CSPMgr.GetCSPLog(.log,"now",-1,10000) //last 10000 events from time=now backwards
	//Set startDate = $$$FormatCSPLogDate(0)  //all events from the very begining, forwards
 	//Set sc=CSPMgr.GetCSPLog(.log,startDate,1,9999999) //all
 	If 'sc do $system.Status.DecomposeStatus(sc,.err) do WriteLog(err(err)) Quit
	Write "<pre>",! 
	do log.Rewind()
	//do log.OutputToDevice()
	while 'log.AtEnd { Write $zconvert(log.Read(),"O","HTML") }
	Write "</pre>",! 
	Write !,"<span><a name=""endcsplog"_mgrid_"""></a></span>"
	Use PDev Write:display "."
	Quit
WriteLog(Record)
	If Record?1"***".e Quit
	Use LogFile
	Write $zconvert(Record,"O","HTML"),$Char(13,10)
	Use PDev Write:display "."
	Quit
LogHeaderTag(HTMLtag,HTMLcaption,HTMLcolor,PadLen) ;
	New Padding
	Set Padding=$Justify(" ",+$Get(PadLen,4))
	Write !,Padding,"<td align=""center"">"
	Write !,Padding,"  <font size=""2"" face=""Arial, Helvetica, sans-serif"" color=""",HTMLcolor,"""><b><a href=""#",HTMLtag,""">",HTMLcaption,"</a></b></font>"
	Write !,Padding,"</td>"
	Quit
LogHeaderTagBasic(HTMLtag,HTMLcaption)
	Do LogHeaderTag(HTMLtag,HTMLcaption,"#0000FF")
	Quit
LogHeaderTagAdvanced(HTMLtag,HTMLcaption)
	Do LogHeaderTag(HTMLtag,HTMLcaption,"SteelBlue")
	Quit
LogReportTrailer  //
	Use LogFile
	Write !,"<hr size=""4"" noshade>"
	Write !,"<p><font face=""Arial, Helvetica, sans-serif"" style=""font-weight:bold;font-size:16px;color:blue;"" size=""4""><b>End of CSPButtons Diagnostic Report</b></font>"
	Write !,"&nbsp;&nbsp;<a href=""#top"">top</a>"
	Write !,"</p>"
	Write !,"</body>"
	Write !,"</html>"
	Use PDev Write:display "."
	Quit
GetConfigWebServerPort() ;
	New webserverport,currNsp,CPFProperties,Properties
	Set currNsp=$namespace 
	Try {
		if currNsp'="%SYS" ZNspace "%SYS"
		Set CPFProperties = ##class(Config.Startup).Get(.Properties)
		Set webserverport=$g(Properties("WebServerPort"))
	}
 	Catch { }
 	if $namespace'=currNsp ZNspace currNsp
 	Quit $g(webserverport)
	//Creates a new file with Date and Time added to the filename and opens it for Reading and Writing
NewFile(LogFilePrefix,LogFileSuffix) 
	//New Date,Dir,NewFile,Time
	If LogFileSuffix="" Set LogFileSuffix="html"
	Set Date=$zd($h,8),Time=$tr($zt($p($h,",",2),2),":","")
	If $zconvert($System.Version.GetBuildOS(),"U")?1"WIN".e Set LogFileSuffix=$ZConvert(LogFileSuffix,"l")
	Else  If $zconvert($System.Version.GetBuildOS(),"U")["UNIX" Set LogFileSuffix=$ZConvert(LogFileSuffix,"l")
	Else  If $zconvert($System.Version.GetBuildOS(),"U")["VMS" Set LogFileSuffix=$ZConvert(LogFileSuffix,"U")
	Set Dir=MgrDir
	Set LogDirectory=$Get(LogDirectory,"")
	If LogDirectory'="" Set Dir=LogDirectory
	If $zconvert($System.Version.GetBuildOS(),"U")?1"WIN".e Set NewFile=Dir_DirDelim_LogFilePrefix_Date_Time_"."_LogFileSuffix
	Else  If $zconvert($System.Version.GetBuildOS(),"U")["UNIX" Set NewFile=Dir_DirDelim_$ZConvert(LogFilePrefix,"l")_Date_Time_"."_LogFileSuffix
	Else  If $zconvert($System.Version.GetBuildOS(),"U")["VMS" Set NewFile=Dir_$ZConvert(LogFilePrefix,"U")_Date_Time_"."_LogFileSuffix_";"
	Set $ZTrap="NewFileErr"
	Open NewFile:"RWNSK\UTF8\":5
	If '$Test Quit ""
	Quit NewFile
NewFileErr
	Set $ZTrap="",$ZError=""
	Quit ""
GetDirs
	Set MgrDir=$System.Util.ManagerDirectory()
	Set CurDir=$ZUtil(12,"")
	Set CurNsp=$namespace
	Set:$zconvert($System.Version.GetBuildOS(),"U")?1"WIN".e DirDelim="\",NullDev="//./nul"
	Set:$zconvert($System.Version.GetBuildOS(),"U")["UNIX" DirDelim="/",NullDev="/dev/null/"
	Set:$zconvert($System.Version.GetBuildOS(),"U")["VMS" DirDelim=".",NullDev="NL:"
	If $zconvert($System.Version.GetBuildOS(),"U")?1"WIN".e!($zconvert($System.Version.GetBuildOS(),"U")["UNIX") {  //Remove trailing \ or /
	  If $Extract(MgrDir,$Length(MgrDir))=DirDelim Set MgrDir=$Extract(MgrDir,1,$Length(MgrDir)-1)
	  If $Extract(CurDir,$Length(CurDir))=DirDelim Set CurDir=$Extract(CurDir,1,$Length(CurDir)-1)
	}
	If $zconvert($System.Version.GetBuildOS(),"U")["VMS" {
	  Set MgrDir=$$VMSCanonize(MgrDir)
	  Set CurDir=$$VMSCanonize(CurDir)
	}
	Quit
VMSCanonize(Dir)
	New (Dir)
	Set Dev=$Piece(Dir,":",1),Dir=$Piece(Dir,":",2,999999999)
	Set Dir=$Translate(Dir,"<","[") ; Replace < by [
	Set Dir=$Translate(Dir,">","]") ; Replace > by ]
	Set i=$Length(Dir,"[")-1
	If i>1 {  ; Directory format is [DIR.][SUBDIR]...
	  If $Extract(Dir,1)="[" Set Dir=$Extract(Dir,2,*)
	  If $Extract(Dir,$Length(Dir))="]" Set Dir=$Extract(Dir,1,$Length(Dir)-1)
	  For  Quit:$Piece(Dir,"[",2)=""  Set Dir=$Piece(Dir,"[",1)_$Piece(Dir,"[",2,999999999)
	  For  Quit:$Piece(Dir,"]",2)=""  Set Dir=$Piece(Dir,"]",1)_$Piece(Dir,"]",2,999999999)
	  Set Dir="["_Dir_"]"
	}
	Set Dir=Dev_":"_Dir
	Quit Dir
TestCompress  //
    Set PDev=$Principal
    s cabname="CSP_"_$Piece($Piece($ZUtil(86),"*",2)," ",1) //_$$$CurDate_$$$CurTime
    s cabdir=cabname
    s sourcepath=##class(%SYS.System).TempDirectory()_"\"_cabdir
    s cabpath=$System.Util.ManagerDirectory()_dirname  //"C:\temp\testcomp"
    w !,"sourcepath:",sourcepath
    w !,"cabpath:",cabpath
    w !,"cabname:",cabname
    w !,"cabdir:",cabdir
    s deletesourcepath=0
    w !,"deletesourcepath:",deletesourcepath
    do CompressFiles(sourcepath,cabpath,cabname,cabdir,deletesourcepath,1)
	Quit
CompressFiles(SourcePath, CabPath, CabName, CabDir, deleteSourcePath, display)
	Set EOF=$ZUtil(68,40)
	If $ZUtil(68,40,1) ; Enable setting of $ZEOF and disable <ENDOFFILE> error
	Try {
		Write:display !,"Compressing files",!
		If $zconvert($System.Version.GetBuildOS(),"U")?1"WIN".e {
			Set DirName=$p(CabPath,"\",$l(CabPath,"\"))
			//with makecab.exe we cannot include multiple files directly. To do that, we have to create a directive file called a Diamond Directive File(DDF) and include instructions in it.
			Set ddfFile=CabPath_"\"_CabName_".ddf"
			Open ddfFile:("WNS"):10
			Use ddfFile
			Write ".Set DiskDirectory1=",!
			Write ".Set CabinetName1="""_CabPath_"\"_CabName_".cab"_"""",!
			Write ".Set MaxCabinetSize=999999999",!
			Write ".Set SourceDir=""",SourcePath,"""",!
			Write ".Set DestinationDir=",CabDir,!  //inside cab
			Write ".Set CompressionType=""MSZIP""",!
			Write ".Set Cabinet=""ON""",!
			Write ".Set Compress=""ON""",!
			Write ".Set InfFileName="""_CabPath_"\"_CabName_"_.inf""",!
			Write ".Set RptFileName="""_CabPath_"\"_CabName_"_.rpt""",!
			Set rs=##class(%Library.ResultSet).%New("%Library.File:FileSet")
			Set sc=rs.Execute(SourcePath,"*.*")
			If '(sc) Use PDev Do DisplayError^%apiOBJ(sc) Quit
			While rs.Next(.sc) {
				If '(sc) Quit
				Write rs.Data("ItemName"),!
			}
			If '(sc) Use PDev Do DisplayError^%apiOBJ(sc) Quit
			Close ddfFile
			//w !,"***" r a
			//BM 2015-04-30 use NullDev to suppress output from makecab.exe since /V0 is not working!
			Do ExtCmdPipe("makecab.exe /V0 /f "_ddfFile,$s('display:NullDev,1:PDev))   //V[n] - Verbosity level (1..3)  1=default, 3=Verbose. 0=none -> not working :(
			//we can use expand.exe to extract a cab archive. (expand /?)
			// To extract all files in an archive : expand -F:* [filename] [\destination]
			Use PDev
			if deleteSourcePath=1 {
				Write:display !,"Deleting source directory "_SourcePath
				Do ExtCmdPipe("rmdir /s /q "_SourcePath,PDev)
			}
			Do ExtCmdPipe("del /q "_ddfFile,PDev)
			Do ExtCmdPipe("del /q "_CabPath_"\"_CabName_"_.*",PDev)
			Write:display !!,"Files in "_SourcePath_" were compressed and saved to: ",!,CabPath_"\"_CabName_".cab",!!
		}
		ElseIf $zconvert($System.Version.GetBuildOS(),"U")["UNIX" {
			Set OneUpDir=$p(SourcePath,"/",1,$l(SourcePath,"/")-1)  //same as $$$TempDir but it is better to get it from the SourcePath
			//tar switches: c - Creates a new .tar archive file. v - Verbosely show the .tar file progress. f - File name type of the archive file. z = gzip (.tgz = .tar.gz)
			//tar -cvzf output_filename.tgz /home/username/dir1/dir2/selecteddir
			//Do ExtCmdPipe("tar -cvzf "_CabPath_"/"_CabName_".tgz "_SourcePath,PDev)  //this will create the whole directory-path into the tar :(
			//tar -cvzf output_filename.tgz -C /home/username/dir1/dir2 selecteddir    //this will only create selecteddir directory into the tar :)
			if $zconvert($system.Version.GetPlatform(),"U")["AIX" {
			  //AIX does not support z flag
			  Do ExtCmdPipe("tar -c"_$s(display:"v",1:"")_"f "_CabPath_"/"_CabName_".tar -C "_OneUpDir_" "_CabName,$s('display:NullDev,1:PDev))
			  //compress and zip the tar file : gzip mytest.tar -> .tar.gz
			  Do ExtCmdPipe("gzip "_CabPath_"/"_CabName_".tar",$s('display:NullDev,1:PDev))
			}
			else  {
			  Do ExtCmdPipe("tar -c"_$s(display:"v",1:"")_"zf "_CabPath_"/"_CabName_".tgz -C "_OneUpDir_" "_CabName,$s('display:NullDev,1:PDev))
			}
			//You can extract a gzipped tar archive with x (extract) option : $ tar xvfz archive_name.tar.gz
			Use PDev
			if deleteSourcePath=1 {
			  Write:display !,"Deleting source directory "_SourcePath
			  Do ExtCmdPipe("rm -fr "_SourcePath,PDev)
			}
			Write:display !!,"Files in "_SourcePath_" were compressed and saved to: ",!,CabPath_"/"_CabName_$s($zconvert($system.Version.GetPlatform(),"U")["AIX":".tar.gz",1:".tgz"),!!
		}
	}
	Catch {
		Use PDev
		Write !,"ERROR: ",$ZCvt($ZError,"O","HTML")
	}
	If $ZUtil(68,40,EOF) ; Reset $ZEOF to the original setting
	Quit
ExtCmdPipe(Command, Device)  //Execute an OS command through a pipe.
	Try {
		Open Command:("RQ"):10
		If '$Test Quit
		; Read timeout added to prevent the case where neither <ENDOFFILE> error nor $ZEOF terminate the loop
		For  Use Command Read x:60 Set ZEOF=$ZEof Quit:'$Test!(ZEOF)  If x'="" Use Device Write x,!
	}
	Catch {
		Use Device
		Write !,"ERROR: ",$ZCvt($ZError,"O","HTML"),!
	}
	Use Device
	Close Command
	Quit
	//--------------------------------------------------------------------
	//External-Entry:
	//Job-Start for ^CSPButtons frequently over a dedicated time frame.
	//Example set ups:
	//>Job CSPButtonsJob^CSPButtons(1,"06:00",30,48) - Starts today+1 (tomorrow) at 6am, running every half hour (30 min.) with 48 interations => 24 hour = whole day long. => Will end next day at 8am
	//
CSPButtonsJob(startDateDayOffset = "", startTimeDisplay = "", intervalMin = 30, iterations = 1)
	Set startDate=+$horolog+startDateDayOffset
	Set startTime=$ztimeh(startTimeDisplay)  //08:00 = 28800
	Kill ^CSPButtons("CSPButtonsJob",$job)
	Set ^CSPButtons("CSPButtonsJob",$job,$increment(^CSPButtons("CSPButtonsJob",$job)))=$zdatetime($horolog)_";START;"_$zdate(startDate)_" "_$ztime(startTime)_";"_intervalMin_" min.;"_iterations_"X"
	//Wait Phase before Start
	Set Go=0
	For {
	  if +$horolog>=startDate,$piece($horolog,",",2)>=startTime Set Go=1 Quit
	  if $data(^CSPButtons("CSPButtonsJob",$job,"STOP")) Set Go=0 Kill ^CSPButtons("CSPButtonsJob",$job) Quit  //STOP switch
	  Hang 60
	}
	Quit:'Go
	//Start Phase of Jobs/Iterations
	For i=1:1:iterations {
		if $data(^CSPButtons("CSPButtonsJob",$job,"STOP")) Kill ^CSPButtons("CSPButtonsJob",$job,"STOP") Quit  //STOP switch
	  	Set display=0
	  	Job Start^CSPButtons(display)::5
	  	Set ^CSPButtons("CSPButtonsJob",$job,$increment(^CSPButtons("CSPButtonsJob",$job)))=$zdatetime($horolog)_";Job Start^CSPButtons #"_i_"/"_iterations_" every "_intervalMin_" min.;Job Started:"_$Test_" - Jobno.:"_$ZChild
	  	Quit:(i>=iterations)
	  	Hang (intervalMin*60)
	}
	Set ^CSPButtons("CSPButtonsJob",$job,$increment(^CSPButtons("CSPButtonsJob",$job)))=$zdatetime($horolog)_";END"
	Quit
	//Get CSP-Gateway System-Status Overview via http get.
	//This can/must be used if no CSP Gateway-Registry is available (pre 2012.2)
CSPGWSTATUSINFO(server="127.0.0.1",port="80",USERNAME="CSPSystem",PASSWORD="SYS",Dir="",Debug=0)
	do CSPGWINFO(server,port,1,USERNAME,PASSWORD,Dir,Debug)
	Quit
	//Get CSP-Gateway Infos via http get. (general)
CSPGWINFO(server="127.0.0.1",port="80",CSPSYS=1,USERNAME="CSPSystem",PASSWORD="SYS",Dir="",Debug=0)	//
	Set:$get(Dir)="" Dir=$System.Util.ManagerDirectory() ;"C:\temp\CSPButtons\"
	Set stream=##class(%Stream.FileCharacter).%New()
	Set filename="cspgw_"_$s(CSPSYS=1:"status",CSPSYS=17:"about",1:CSPSYS)_"_info"_$translate($zdatetime($horolog,3)," -:","_")_".html"
	Set sc=stream.LinkToFile(Dir_filename)
	Set page="/csp/bin/"_$s(CSPSYS=1:"RunTime",1:"Systems")_"/Module.cxw" //2017-09-21 - BM
    Set urlFile="http://"_server_page
    Set urlParams="CSPSYS="_CSPSYS_"&CSPUNM="_USERNAME_"&CSPPWD="_PASSWORD
    Set httpreq=##class(%Net.HttpRequest).%New()
    Set httpreq.Server=server
    if port'="",'(port=80) Set httpreq.Port=port
    Set httpreq.Timeout=5
    if urlParams'="" {
      For i=1:1  {
       Set ParamNameValue=$piece(urlParams,"&",i)
       Quit:ParamNameValue=""
       Set ParamName=$piece(ParamNameValue,"=",1)
       Set ParamValue=$piece(ParamNameValue,"=",2)
       Do httpreq.SetParam(ParamName,ParamValue)
       write:Debug !,"HttpRequest - Param: "_ParamName_"="_ParamValue
      }
    }
    Set sc=httpreq.Get(page)
    if sc=1 {
      Set httpres=httpreq.HttpResponse.StatusLine
      write:Debug !,"HttpResponse:",httpres,!
      write:Debug !,"-ContentInfo:",httpreq.HttpResponse.ContentInfo
      write:Debug !,"-ContentType:",httpreq.HttpResponse.ContentType
      Set CT=$piece(httpreq.HttpResponse.ContentType,";",1)
      write:Debug " -> CT=",CT
      write:Debug !,"-ContentLength:",httpreq.HttpResponse.ContentLength
      write:Debug !
      if httpres["200",httpres["OK" {
          //Read Byte/Chunks
          set stop=0
          while ('httpreq.HttpResponse.Data.AtEnd && 'stop) {
            set readLen = 30000
            set requestedLen = readLen
            set chunk = httpreq.HttpResponse.Data.Read(.readLen)
            set:(requestedLen > readLen) stop = 1
            do stream.Write(chunk)
          }
      }
    }
    else  {
      write:Debug !,"Error:",$system.Status.GetOneErrorText(sc)
      Set Result="0~"_$system.Status.GetOneErrorText(sc)
    }
    kill httpreq
    write:Debug !,urlFile," created!"
    write:Debug !,"Size:",stream.SizeGet()
    write:Debug !
    Set sc=stream.%Save()
    if 'sc Set Result="0~"_$system.Status.GetOneErrorText(sc)
    else  Set Result=1
    write:Debug !,"Saved! ",stream.Filename
	Quit
	//External-Entry:
	//Job-Start for Get CSP-Gatway System-Status Overview (see above) frequently over a dedicated time frame.
	//Example set ups:
	//>Job CSPGWSTATUSJOB^CSPButtons("","10:15",5,3) - Starts Today at 10:15am, running every 5 Min. doing 3 interations
	//>Job CSPGWSTATUSJOB^CSPButtons(1,"17:00",60,24,"127.0.0.1",80,"CSPSystem","ars123") - Starts tomorrow at 5pm, running every hour with 24 interations => whole day long. Will end next day at 5pm
CSPGWSTATUSJOB(startDateDayOffset = "", startTimeDisplay = "", intervalMin = 30, iterations = 1, server="127.0.0.1",port="80",USERNAME="CSPSystem",PASSWORD="SYS",Dir="") //
	Set startDate=+$horolog+startDateDayOffset
	Set startTime=$ztimeh(startTimeDisplay)  //08:00 = 28800
	Kill ^CSPButtons("CSPGWSTATUSJOB",$job)
	Set ^CSPButtons("CSPGWSTATUSJOB",$job,$increment(^CSPButtons("CSPGWSTATUSJOB",$job)))=$zdatetime($horolog)_";START;"_$zdate(startDate)_" "_$ztime(startTime)_";"_intervalMin_" min.;"_iterations_"X"_";"_server_":"_port_";"_USERNAME_";"_PASSWORD_";"_Dir
	//Wait Phase before Start
	Set Go=0
	For {
	  if +$horolog>=startDate,$piece($horolog,",",2)>=startTime Set Go=1 Quit
	  if $data(^CSPButtons("CSPGWSTATUSJOB",$job,"STOP")) Set Go=0 Kill ^CSPButtons("CSPGWSTATUSJOB",$job) Quit  //STOP switch
	  Hang 60
	}
	Quit:'Go
	//Start Phase of Jobs/Iterations
	For i=1:1:iterations {
		if $data(^CSPButtons("CSPGWSTATUSJOB",$job,"STOP")) Kill ^CSPButtons("CSPGWSTATUSJOB",$job,"STOP") Quit  //STOP switch
	  	Job CSPGWSTATUSINFO^CSPButtons(server,port,USERNAME,PASSWORD,Dir)::5
	  	Set ^CSPButtons("CSPGWSTATUSJOB",$job,$increment(^CSPButtons("CSPGWSTATUSJOB",$job)))=$zdatetime($horolog)_";Job Start #"_i_"/"_iterations_" every "_intervalMin_" min.;Job Started:"_$Test_" - Jobno.:"_$ZChild
	  	Quit:(i>=iterations)
	  	Hang (intervalMin*60)
	}
	Set ^CSPButtons("CSPGWSTATUSJOB",$job,$increment(^CSPButtons("CSPGWSTATUSJOB",$job)))=$zdatetime($horolog)_";END"
	Quit
	//External-Entry:
	//Get full CSP.log
GETCSPLOGS() // 
 New
 Do GetDirs
 //Logs for every GW
 Set CSPRegs=$system.CSP.GetGatewayRegistry()
 Set CSPMgrs=CSPRegs.GetGatewayMgrs()
 For mgrid=1:1:CSPMgrs.Count()  {
 	Set CSPMgr=CSPMgrs.GetAt(mgrid)
	Set fileprefix="CSP_"_CSPMgr.Server_"_"_CSPMgr.Port_"_"
	Set filesuffix="log"
	Set LogFile=$$NewFile(fileprefix,filesuffix)
	Set startDate = $zdate(0,11)_", "_$zdate(0,2)_" "_$ztime($piece(0,",",2),1)_" GMT"
	Set sc=CSPMgr.GetCSPLog(.log,startDate,1,999999) 
 	IF 'sc Do $system.OBJ.DisplayError(sc) CONTINUE
 	Do log.Rewind()
	Use LogFile do log.OutputToDevice()
	Close LogFile
	Write !,"Log file saved to: ",LogFile_", "_$FNumber($ZUtil(140,1,LogFile),",")_" bytes",!
 }
 Quit

CSPGWMGR^INT^1^67214,47330
CSPGWMGR;;;CSP Gateway Manager Utility;created:BM 2015-03-04;last changed:BM 2019-03-26
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 // CSPGWMGR initial version by Bernd Mueller (bernd.mueller@intersystems.com) in 2015-03
 // CSPButtons initial version by Tomas Vaverka (tomas.vaverka@intersystems.com) in 2013
 // Change-Notes:
 // 2015-03-09 - BM - fix leaking variables.
 // 2015-03-09 - BM - added more Params to change Application Path settings.
 // 2015-03-13 - BM - handle case if there is currently no Gateway connected/registered in Manage CSPGateways, Select Gateway. Add note to clarify that case.
 // 2015-03-15 - BM - add/integrate CSPButtons.mac (CSP Gateway Diagnostic Report)
 // 2015-03-16 - BM - Get CSP.log, add option to directly import fetched CSP.log from the Gateway into %ZCSPGTW.CSPLogEvent class/table if available
 // 2015-03-16 - BM - Get CSP.log, add option to specify startDate for fetching the events
 // 2015-03-17 - BM - fixes some bugs in input function $$OPTION()
 // 2015-03-18 - BM - added "Show cspServer-Error-Log" server side error log - ^%cspServer("LOG") and ^cspServer("LOG")
 // 2015-03-20 - BM - added *PWS* on the CSPGateway in the list of gateways if it is the Private Webserver
 // 2015-03-24 - BM - removed CSPButtons into separated CSPButtons.mac
 // 2015-03-27 - BM - replacements of $zutil's
 // 2015-03-30 - BM - select namespace to enable/disable SOAPLog
 // 2015-03-30 - BM - added change/modify Gateway Default-Params
 // 2015-03-31 - BM - removed/converted .. code syntax
 // 2015-04-01 - BM - change %ZCSPGTW.CSPLogEvent to %CSP.Util.CSPLogEvent to reflect classname change, added Response_Size_Notification_Always to application-access, Web_Server_ID_Cookie to default-params
 // 2015-04-04 - BM - extend change/modify Default-,System-,Application-Params
 // 2015-04-08 - BM - fix leaking variables.
 // 2015-04-08 - BM - some minor changes.
 // 2015-06-03 - BM - add ability to modify ^%ISCLOG MaxLogEntries and ErrorDetail
 // 2015-07-01 - BM - add MXT1829 - headers only option (v2015.3) - support in setting ^ISCSOAP ("h" can be used together with "i" and/or "o")
 // 2015-07-01 - BM - add MAK4344 - Fix UNDEFINED in gateway management CHUI
 // 2015-10-02 - BM - trying to self init/register PWS if there is no Gateway connected/registered.
 // 2015-10-03 - BM - add entrys StopPWS, StartPWS and RestartPWS
 // 2015-10-08 - BM - correct issue with the self init/register PWS on older versions
 // 2016-10-31 - BM - add Event Log path and file name for the Gateway Event Log to be shown in About CSP Gateway.
 // 2017-06-13 - BM - webserver port for PWS Start could now be passed/specified with the StartPWS and RestartPWS entrys.
 // 2017-06-13 - BM - the ^ISCSOAP log can now be enabled with v=verbose flag as well.
 // 2017-06-21 - BM - add possibility to change the servers SSLCC_Cipher_Suites parameter. (updating via registry did not work before CMT1591, v2018.1+)
 // 2017-09-20 - CMT1630 - Ensure that the 'Start Private Web Server' function ($$StartPWS^CSPGWMGR) will work for cases where a TCP Port other than the default is specified.
 // 2017-10-17 - CMT1642 - Secure access to the PWS management functions (Start/Stop/Restart) provided by the CSPGWMGR routine.
 // 2017-12-28 - CMT1657 - Rework the PWS/Gateway Management routine (CSPGWMGR) to comply with the latest security standards (specifically in relation to 'command injection' vulnerabilities).
 // 2018-01-29 - CMT1664 - Further refine the PWS/Gateway Management routine (CSPGWMGR) so that the /SHELL switch is not used when invoking the $ZF(-100, ...) function to start the Web Server.
 // 2019-03-07 - BM - add Get/Set Server Status (offline/online) functions.
 // 2019-03-15 - BM - add IRIS support and adjustments on previous changes to achieve backwards compatibility. (among others: MAK4779 - Change ^%ISCLOG log global to ^ISCLOG global in %SYS namespace)
 // -----------------------------------------------------------------------------
 // -----------------------------------------------------------------------------
 If +$System.Version.GetNumber()<2012.1 {
   Write !,"*** You are running on "_$system.Version.GetProduct()_" "_$System.Version.GetNumber()_" and "_"Web/CSP-Gateway Manager Utility"_" is only for v2012.2 and later ***"
   Quit
 }
 If '($roles["%All") {
   Write !,"*** You need %All privileges to run "_"Web/CSP-Gateway Manager Utility"_" ***"
   Quit
 }
 New reppws,pwsreg
MAIN s $zt="MAINERR"
 New GW,gwid,GWAPPS,appnum,GWSRVS,srvnum
 New Option,sc
 New CSPMgr,CSPMgrs
 k GW
 d ##class(%Library.MessageDictionary).SetSessionLanguage("en")
 if $g(regpws)=1 d MANAGE g MAIN
 w !!,"Web/CSP-Gateway Manager Utility",", ","v1.0"
 w !,"================================="
 w !,"1) Manage Web/CSP-Gateways"
 w !,"2) Create CSPButtons Report"
 w !,"---------------------"
 w !,"3) Enable ^%ISCLOG ("_$$ISCLOGSTATE()_")"
 w !,"4) Disable ^%ISCLOG"
 w !,"5) Export ISCLOG"
 w !,"6) Enable SOAP-Log - ^ISCSOAP ("
 w $$ISCSOAPSTATES()
 w ")"
 w !,"7) Disable SOAP-Log"
 w !,"8) Show cspServer-Error-Log"
 w !,"9) Exit"
 s Option=$$OPTION("Option?",9,9)
 if Option=1 d MANAGE g MAIN
 if Option=2 d CSPButtons g MAIN
 if Option=3 d ENAISCLOG g MAIN
 if Option=4 d DISISCLOG g MAIN
 if Option=5 d EXPISCLOG g MAIN
 if Option=6 d ENAISCSOAP g MAIN
 if Option=7 d DISISCSOAP g MAIN
 if Option=8 d CSPSERVERLOG g MAIN
 q
MAINERR s $zt=""
 if $ze'["<INTERRUPT>" w !,"ERROR: "_$ZE
 q
MANAGE s $zt="MAINERR"
 New mgrid,x,i,count
 if '$g(regpws) w !!,"List of registered Web/CSP-Gateways:"
 else  w " *** trying to init PWS and register, please wait ..." Hang 5
 s:'$d(GW) count=$$GetGWS(.GW)
 s mgrid=""
 For x=1:1  {
   s mgrid=$Order(GW(mgrid))
   q:mgrid=""
   s i=GW(mgrid)
   w !!,mgrid," - ",$p(i,"~",1)_$s($p(i,"~",6)=1:" *PWS*",1:"")_" ("_$p(i,"~",2)_") "_$p(i,"~",3)
   w:(($tr($p(i,"~",4),$c(0),"")'="")!($tr($p(i,"~",5),$c(0),"")'="")) !,?4,$p(i,"~",4)_" "_$p($p(i,"~",5),"Cache_Server_Pages",1)
   w:$p(i,"~",7)'="" !,?4,$p(i,"~",7)
 }
 if $d(GW)<10 {
   if $g(pwsreg)<1,$increment(pwsreg) s regpws=$$RegPWS() Q:regpws=1  
   w !!,"Currently there is no Gateway connected/registered.",!,"Gateways will be initially connect when the first request is made to this server!" 
   s Option=$$OPTION("<CR> to continue","","")
   q
 }
 k pwsreg,regpws
 s gwid=$$OPTION("Select Gateway? (1-"_$o(GW(""),-1)_")","",$o(GW(""),-1))
 if +gwid>0 d MANAGEGW g MANAGE
 q
MANAGEGW s $zt="MAINERR"
 w !
 w !,"1)  System Status"
 w !,"2)  Close Connections"
 w !,"3)  Clear Cache"
 w !,"4)  Set Username/Password to access Web/CSP-Gateway-Management Forms"
 w !,"5)  Get CSP.ini"
 w !,"6)  Activate CSP.ini"
 w !,"7)  Get System Metrics"
 w !,"8)  Get/Set Server Status"
 w !,"----------------------"
 w !,"9)  Get/Export CSP.log"
 w !,"10) Clear CSP.log"
 w !,"11) Set CSP.log Event Log Level"
 w !,"----------------------"
 w !,"12) Default Parameters"
 w !,"13) Server Access"
 w !,"14) Application Access"
 w !,"15) About CSP Gateway"
 w !,"----------------------"
 w !,"16) Exit"
 s Option=$$OPTION("Option?","",16)
 if Option=1 d GETSYSSTATUS g MANAGEGW
 if Option=2 d CLOSECONN g MANAGEGW
 if Option=3 d CLEARCACHE g MANAGEGW
 if Option=4 d SETACCESSGWM g MANAGEGW
 if Option=5 d GETCSPINI g MANAGEGW
 if Option=6 d ACTIVATECSPINI g MANAGEGW
 if Option=7 d GETSYSMETRICS g MANAGEGW
 if Option=8 d GETSETSRVSTATUS g MANAGEGW
 if Option=9 d GETEXPCSPLOG g MANAGEGW
 if Option=10 d CLEARCSPLOG g MANAGEGW
 if Option=11 d SETLOGLEVEL g MANAGEGW
 if Option=12 d GETDEFPARAMS g MANAGEGW
 if Option=13 d GETSRVACCESS g MANAGEGW
 if Option=14 d GETAPPACCESS g MANAGEGW
 if Option=15 d GETINFO g MANAGEGW
 q
GETSETSRVSTATUS s $zt="MAINERR"
 q:CSPMgr=""
 New statusAry,k,ld,SN,P
 Set sc=CSPMgr.GetServerStatus("*","*",.statusAry)  //Get all
 if ('sc) w !,$system.Status.GetOneErrorText(sc) q
 w !!,"Server Status:"
 w !!,"Path                    S#  Srv                   Status"
 if 0 w !,"***",! zw statusAry w "***",!
 s k="statusAry"
 k SN,P
 For {
	 s k=$q(@k)
	 q:k=""	 
	 s ld=@k,SN($lg(ld,1))=$qs(k,2),P($qs(k,1))=""
	 w !,$qs(k,1),?24,$qs(k,2),?28,$lg(ld,1),?50,$s($lg(ld,2)=1:"online",1:"offline")
 }
 w !
 if $$YN("Modify Server Status","N")="Y" d SETSRVSTATUS g GETSETSRVSTATUS
 q
SETSRVSTATUS s $zt="MAINERR"
 q:CSPMgr=""
 New path,servername,newstatus
 W !!,"Set Server Status:"
SETSRVSTATUSP ;
 s path=$$OPTION("Path (or * for all)","*",,1)
 q:path<0
 if path'="*",'$d(P(path)) w !,"please enter a valid Path or * for all." g SETSRVSTATUSP
SETSRVSTATUSS ;
 s servername=$$OPTION("Server Name (or * for all)","*",,1)
 q:servername<0
 if servername'="*",'$d(SN(servername)) w !,"please enter a valid Server Name or * for all. Do not enter the Server number!" g SETSRVSTATUSS
 w !,"(0=offline, 1=online)"
 s newstatus=$$OPTION("new Status",1,1,1,0)
 q:newstatus<0
 if $$YN("Apply Changes","Y")="Y" {
   Set sc=CSPMgr.SetServerStatus(path,servername,newstatus)
   if ('sc) w !,$system.Status.GetOneErrorText(sc) q
   w !,"Updated!"
 }
 s Option=$$OPTION("<CR> to continue","","")
 q
GETSYSSTATUS s $zt="MAINERR"
 q:CSPMgr=""
 New status,conn,srv,app,apps,cache,form,cnid,srvid,appid,appsid,formid
 Set sc=CSPMgr.GetSystemStatus(.status)
 if ('sc) w !,$system.Status.GetOneErrorText(sc) q
 w !,"System Status:"
 s cnid=""
 w !!,"C# GW-PID Srv             IP              Port  Srv-PID Status   It/To   Act"
 For  {
   s conn=status.Connections.GetNext(.cnid)
   q:cnid=""
   w !,cnid,?3,conn.WebServerPID,?10,conn.CacheServerName,?26,conn.IPAddress,?42,conn.TCPPort,?48,conn.CacheServerPID,?56,conn.Status,?65,conn.IdleTime,?73,conn.Activity
 }  
 set srvid=""
 w !!,"S# Srv             IP              Port  Con  InUse Priv  Act    Qd"
 For  {
   s srv=status.CacheServers.GetNext(.srvid)
   q:srvid=""
   w !,srvid,?3,srv.CacheServerName,?19,srv.IPAddress,?35,srv.TCPPort,?41,srv.TotalConnections,?46,srv.ConnectionsInUse,?52,srv.PrivateConnections,?58,srv.Activity,?65,srv.QueuedRequests
 }
 set appid=""
 w !!,"Path# Path                S# Srv             Act    Status"
 For  {
   s app=status.ApplicationPaths.GetNext(.appid)
   q:appid=""
   s appsid=""
   For  {
     s apps=app.AlternativeServer.GetNext(.appsid)
     q:appsid=""
     w !,appid,?6,app.Path,?26,appsid,?29,apps.CacheServerName,?45,apps.Activity,?52,apps.Status
   }
 }
 set cache=status.CachedForms
 w !!,"Cached Forms        Cached Data (Bytes)      Cached Form Actifity"
 w !,cache.FormsInCache,?20,cache.CachedData,?45,cache.CacheActivity
 set formid=""
 w !!,"Form",?50,"Size",?60,"Actifity"
 For  {
   s form=cache.Form.GetNext(.formid)
   q:formid=""
   w !,formid,?50,form.Size,?60,form.Activity
 }
 s Option=$$OPTION("<CR> to continue","","")
 q
GETSYSMETRICS s $zt="MAINERR"
 q:CSPMgr=""
 New metrics
 k metrics
 Set sc=CSPMgr.GetSystemMetrics(.metrics)
 if ('sc) w !,$system.Status.GetOneErrorText(sc) q
 w !!,"System Metrics:",!
 do ShowArray(.metrics)
 s Option=$$OPTION("<CR> to continue","","")
 q
GETCSPINI s $zt="MAINERR"
 q:CSPMgr=""
 New ini
 Set sc=CSPMgr.GetCSPIni(.ini, "stream") //format="array" or "stream"
 if ('sc) w !,$system.Status.GetOneErrorText(sc) q
 q:ini=""
 w !!,"CSP.ini:",!
 do ini.OutputToDevice()
 s Option=$$OPTION("<CR> to continue","","")
 q
GETINFO s $zt="MAINERR"
 q:CSPMgr=""
 New info
 Set sc=CSPMgr.GetInfo(.info)
 if ('sc) w !,$system.Status.GetOneErrorText(sc) q
 q:info=""
 w !!,"About Web/CSP Gateway: (broken in GW's before v2015.1/CMT1293)",!
 w !,"Version",?20," : ",info.Version
 w !,"Gateway Build",?20," : ",info.Build
 w !,"Web Server Name",?20," : ",info.WebServerName  //CMT1293
 w !,"Web Server Port",?20," : ",info.WebServerPort  //CMT1293
 w !,"Web Server Type",?20," : ",info.WebServerSoftware  //CMT1293
 w !,"Active Interface",?20," : ",info.ActiveInterface  //CMT1293
 if +$System.Version.GetNumber()>=2015.1 w !,"Configuration",?20," : ",info.Configuration  //new in CMT1293 2015.1+
 if +$System.Version.GetNumber()>=2016.2 w !,"Event Log",?20," : ",info.EventLog  //new in CMT1428 2016.2+
 s Option=$$OPTION("<CR> to continue","","")
 q
CLEARCACHE s $zt="MAINERR"
 q:CSPMgr=""
 Set sc=CSPMgr.ClearCache()
 if ('sc) w !,$system.Status.GetOneErrorText(sc) q
 w !,"Cache cleared!"
 s Option=$$OPTION("<CR> to continue","","")
 q
GETEXPCSPLOG s $zt="MAINERR"
 q:CSPMgr=""
 New events,LogFile,file,startDate,log,io,fd,ImportCSPLogEvent
 w !!,"How many event/entrys do you like to fetch? (* = all) <1000>: " r events
 s:events="" events=1000 s:events="*" events=9999999
 if $zconvert(events,"L")="e"!($zconvert(events,"L")="q") q
 w !,"From what Date? (* = all, t=today, t-1=yesterday, ...) <*>: " r fd
 s:fd=""!(fd="*") fd=0
 if $zconvert(events,"L")="e"!($zconvert(events,"L")="q") q
 if $zconvert($e(fd),"L")="t" s fd=+$h-$p($tr(fd," ",""),"-",2)
 Set ImportCSPLogEvent=0
 if ##class(%Dictionary.CompiledClass).%ExistsId("%CSP.Util.CSPLogEvent") {
   if $$YN("Do you want to import directly into %CSP.Util.CSPLogEvent","N")="Y" Set ImportCSPLogEvent=1	 
 }
 if ImportCSPLogEvent=0 {
   Set LogFile=$System.Util.ManagerDirectory()_CSPMgr.Server_"_"_CSPMgr.Port_"_CSP.log"
   w !!,"Export-Filename? <"_LogFile_"> : " r file
   s:file="" file=LogFile
   if $zconvert(file,"L")="e"!($zconvert(file,"L")="q") q
 }
 Set startDate = $zdate(fd,11)_", "_$zdate(fd,2)_" "_$ztime($piece(fd,",",2),1)_" GMT"  //0 = from the very begining,
 //Set sc=CSPMgr.GetCSPLog(.log,"now",-1,events) //last 1000 events from time="now" backwards=-1, to get all -> 999999
 Set sc=CSPMgr.GetCSPLog(.log,startDate,1,events)
 if ('sc) w !,$system.Status.GetOneErrorText(sc) q
 do log.Rewind()
 if $$YN("Fetch "_$s(events=9999999:"all",1:events)_" CSP.log events from "_$s(fd=0:"the begining",1:$zd(fd,3))_" and "_$s(ImportCSPLogEvent=1:"import",1:"export")_" now","Y")="Y" {
   if ImportCSPLogEvent=1 {
	 w !
	 Set result=##class(%CSP.Util.CSPLogEvent).Import(log, "", "", , 1, , 1, 0)
	 w !!,result,!   
   }
   else  {
     set io=$IO
     open file:"WNS":2
     if '$T w !,"Could not export! File could not be created. Please check path of given filename." q
     Use file do log.OutputToDevice()
     Close file
     Use io
     Write !!,"Log file saved to: ",file_", "_$FNumber($zutil(140,1,file),",")_" bytes",!
   }
 }
 s Option=$$OPTION("<CR> to continue","","")
 q
CLEARCSPLOG s $zt="MAINERR"
 q:CSPMgr=""
 Set sc=CSPMgr.ClearCSPLog()
 if ('sc) w !,$system.Status.GetOneErrorText(sc) q
 w !,"CSP.log cleared!"
 s Option=$$OPTION("<CR> to continue","","")
 q
SETLOGLEVEL s $zt="MAINERR"
 q:CSPMgr=""
 New loglevel,cU
 w !,"Log Level? (leave empty to clear) : " r loglevel
 k cU
 s cU("Env_Parameters")=loglevel
 Set sc=CSPMgr.SetDefaultParams(.cU)
 if ('sc) w !,$system.Status.GetOneErrorText(sc) q
 w !,"Event Log Level "_$s(loglevel="":"Cleared!",1:"set to "_loglevel)
 s Option=$$OPTION("<CR> to continue","","")
 q
SETACCESSGWM s $zt="MAINERR"
 q:CSPMgr=""
 New username,password,cU
 w !,"Username? : " r username
 w !,"Password? : " r password
 k cU
 s cU("Username")=username
 s cU("Password")=password
 Set sc=CSPMgr.SetDefaultParams(.cU)
 if ('sc) w !,$system.Status.GetOneErrorText(sc) q
 w !,"Username/Password to access Web/CSP-Gateway Management Forms set!"
 s Option=$$OPTION("<CR> to continue","","")
 q
CLOSECONN s $zt="MAINERR"
 q:CSPMgr=""
 Set sc=CSPMgr.CloseConnections("*") //All
 if ('sc) w !,$system.Status.GetOneErrorText(sc) q
 w !,"All Connections Closed!"
 s Option=$$OPTION("<CR> to continue","","")
 q
ACTIVATECSPINI s $zt="MAINERR"
 q:CSPMgr=""
 Set sc=CSPMgr.ActivateCSPIni()
 if ('sc) w !,$system.Status.GetOneErrorText(sc) q
 w !,"CSP.ini activated!"
 s Option=$$OPTION("<CR> to continue","","")
 q
GETDEFPARAMS s $zt="MAINERR"
 q:CSPMgr=""
 New config
 k config
 Set sc=CSPMgr.GetDefaultParams(.config)
 if ('sc) w !,$system.Status.GetOneErrorText(sc) q
 w !!,"Default Parameter:",!
 do ShowArray(.config)
 w !
 if $$YN("Modify","N")="Y" d MANAGEDEFPARAMS g GETDEFPARAMS
 q
MANAGEDEFPARAMS s $zt="MAINERR"
 q:CSPMgr=""
 New config,instancehostname,maxconnections,maxcachesize,smforms,smtimeout,sysmanager,sysmanagerunpwoverride,acceptxforwardedfor
 New customsmloginform,serverresponsetimeout,queuedrequesttimeout,noactivitytimeout,timeoutallconnections,envparameters,eventlogfile
 New eventlogrotationsize,retainalllogfiles,saexcludefiletypes,webserveridcookie,aspdocroot,aspdirectory,username,password,cconnectlibrarypath
 k config
 Set sc=CSPMgr.GetDefaultParams(.config)
 if ('sc) w !,$system.Status.GetOneErrorText(sc) q
 w !!,"(enter null or """" to specify empty-string/clear the value)",!
 s instancehostname=$$OPTION("Instance Host Name",$g(config("Instance_Host_Name"),""),,1)
 q:instancehostname<0
 s maxconnections=$$OPTION("Maximum Connections",$g(config("MAX_CONNECTIONS"),"1024"),,1)
 q:maxconnections<0
 s maxcachesize=$$OPTION("Maximum Cache Size",$g(config("MAX_CACHE_SIZE"),"256K"),,1)
 q:maxcachesize<0
 //Web_Server_ID_Cookie  ***NEW in 2015.1***
 s webserveridcookie=$$OPTION("Web Server ID Cookie",$g(config("Web_Server_ID_Cookie"),"Enabled"),,1)
 q:webserveridcookie<0
 //Security
 s smforms=$$OPTION("Access to these forms",$g(config("SM_Forms"),"Enabled"),,1)
 q:smforms<0
 s username=$$OPTION("Username accessing forms",$g(config("Username"),""),,1)
 q:username<0
 s password=$$OPTION("Password accessing forms",$g(config("Password"),""),,1)
 q:password<0
 s smtimeout=$$OPTION("Session Timeout",$g(config("SM_Timeout"),"300"),,1)
 q:smtimeout<0
 s sysmanager=$$OPTION("System Manager Machine/s",$g(config("System_Manager"),""),,1)
 q:sysmanager<0
 s sysmanagerunpwoverride=$$OPTION("Override Username and Password",$g(config("System_Manager_UNPW_Override"),"Disabled"),,1)
 q:sysmanagerunpwoverride<0
 s acceptxforwardedfor=$$OPTION("Accept client IP addresses forwarded by proxy servers",$g(config("Accept_X_Forwarded_For"),"Disabled"),,1)
 q:acceptxforwardedfor<0
 //Custom Login Form = Custom_SM_Login_Form
 s customsmloginform=$$OPTION("Custom Login Form",$g(config("Custom_SM_Login_Form"),""),,1)
 q:customsmloginform<0
 //Connections
 s serverresponsetimeout=$$OPTION("Server Response Timeout",$g(config("Server_Response_Timeout"),"60"),,1)
 q:serverresponsetimeout<0
 s queuedrequesttimeout=$$OPTION("Queued Request Timeout",$g(config("Queued_Request_Timeout"),"60"),,1)
 q:queuedrequesttimeout<0
 s noactivitytimeout=$$OPTION("No Activity Timeout",$g(config("No_Activity_Timeout"),"86400"),,1)
 q:noactivitytimeout<0
 s timeoutallconnections=$$OPTION("Apply timeout to all connections",$g(config("Timeout_All_Connections"),"Disabled"),,1)
 q:timeoutallconnections<0
 s envparameters=$$OPTION("Event Log Level",$g(config("Env_Parameters"),""),,1)
 q:envparameters<0
 s eventlogfile=$$OPTION("Event Log File",$g(config("Event_Log_File"),""),,1)
 q:eventlogfile<0
 s eventlogrotationsize=$$OPTION("Event Log Rotation Size",$g(config("Event_Log_Rotation_Size"),""),,1)
 q:eventlogrotationsize<0
 s retainalllogfiles=$$OPTION("Retain All Log Files",$g(config("Retain_All_Log_Files"),"Disabled"),,1)
 q:retainalllogfiles<0
 s cconnectlibrarypath=$$OPTION("SSL/TLS Library Path",$g(config("IRISCONNECT_LIBRARY_PATH"),$g(config("CCONNECT_LIBRARY_PATH"),"")),,1)
 q:cconnectlibrarypath<0
 //Preserve Mode Exclude File Types = SA_Exclude_File_Types
 s saexcludefiletypes=$$OPTION("Preserve Mode Exclude File Types",$g(config("SA_Exclude_File_Types"),""),,1)
 q:saexcludefiletypes<0
 //ASP Redirect
 s aspdocroot=$$OPTION("ASP Redirect - Web Document Root",$g(config("Document_Root"),""),,1)
 q:aspdocroot<0
 s aspdirectory=$$OPTION("ASP Redirect - Temp ASP Directory",$g(config("ASP_Directory"),""),,1)
 q:aspdirectory<0
 k cU
 //only update params which really changed
 s:$g(config("Instance_Host_Name"))'=instancehostname cU("Instance_Host_Name")=instancehostname
 s:$g(config("MAX_CONNECTIONS"))'=maxconnections cU("MAX_CONNECTIONS")=maxconnections
 s:$g(config("MAX_CACHE_SIZE"))'=maxcachesize cU("MAX_CACHE_SIZE")=maxcachesize
 s:$g(config("Web_Server_ID_Cookie"),"Enabled")'=webserveridcookie cU("Web_Server_ID_Cookie")=webserveridcookie
 s:$g(config("SM_Forms"))'=smforms cU("SM_Forms")=smforms
 s:$g(config("Username"))'=username cU("Username")=username
 s:$g(config("Password"))'=password cU("Password")=password
 s:$g(config("SM_Timeout"))'=smtimeout cU("SM_Timeout")=smtimeout
 s:$g(config("System_Manager"))'=sysmanager cU("System_Manager")=sysmanager
 s:$g(config("System_Manager_UNPW_Override"),"Disabled")'=sysmanagerunpwoverride cU("System_Manager_UNPW_Override")=sysmanagerunpwoverride
 s:$g(config("Accept_X_Forwarded_For"),"Disabled")'=acceptxforwardedfor cU("Accept_X_Forwarded_For")=acceptxforwardedfor
 s:$g(config("Custom_SM_Login_Form"))'=customsmloginform cU("Custom_SM_Login_Form")=customsmloginform
 s:$g(config("Server_Response_Timeout"))'=serverresponsetimeout cU("Server_Response_Timeout")=serverresponsetimeout
 s:$g(config("Queued_Request_Timeout"))'=queuedrequesttimeout cU("Queued_Request_Timeout")=queuedrequesttimeout
 s:$g(config("No_Activity_Timeout"))'=noactivitytimeout cU("No_Activity_Timeout")=noactivitytimeout
 s:$g(config("Timeout_All_Connections"),"Disabled")'=timeoutallconnections cU("Timeout_All_Connections")=timeoutallconnections
 s:$g(config("Env_Parameters"))'=envparameters cU("Env_Parameters")=envparameters
 s:$g(config("Event_Log_File"))'=eventlogfile cU("Event_Log_File")=eventlogfile
 s:$g(config("Event_Log_Rotation_Size"))'=eventlogrotationsize cU("Event_Log_Rotation_Size")=eventlogrotationsize
 s:$g(config("Retain_All_Log_Files"),"Disabled")'=retainalllogfiles cU("Retain_All_Log_Files")=retainalllogfiles
 s:$g(config("CCONNECT_LIBRARY_PATH"))'=cconnectlibrarypath cU("CCONNECT_LIBRARY_PATH")=cconnectlibrarypath
 s:$g(config("IRISCONNECT_LIBRARY_PATH"))'=cconnectlibrarypath cU("IRISCONNECT_LIBRARY_PATH")=cconnectlibrarypath
 s:$g(config("SA_Exclude_File_Types"))'=saexcludefiletypes cU("SA_Exclude_File_Types")=saexcludefiletypes
 s:$g(config("Document_Root"))'=aspdocroot cU("Document_Root")=aspdocroot
 s:$g(config("ASP_Directory"))'=aspdirectory cU("ASP_Directory")=aspdirectory
 w !
 if '$d(cU) w !,"No Changes!" s Option=$$OPTION("<CR> to continue","","") q
 if 0 w !,"***",! zw cU w "***",!
 if $$YN("Apply Changes","Y")="Y" {
   Set sc=CSPMgr.SetDefaultParams(.cU)
   if ('sc) w !,$system.Status.GetOneErrorText(sc) q
   w !,"Updated!"
 }
 s Option=$$OPTION("<CR> to continue","","")
 q
GETSRVACCESS s $zt="MAINERR"
 q:CSPMgr=""
 New serverList,i,srvName,srvStatus,srvconfig
 k serverList
 Set sc=CSPMgr.GetServers(.serverList)
 if ('sc) w !,$system.Status.GetOneErrorText(sc) q
 k GWSRVS,srvnum
 w !!,"Server Access:"
 For i=1:1:$LL(serverList) {
   s srvName=$p($LG(serverList,i),"=",1)
   s GWSRVS(i)=srvName
   s srvStatus=$p($LG(serverList,i),"=",2)
   w !!,i," - Server Name",?30," : ",srvName
   w !,"Service-Status",?30," : ",srvStatus
   k srvconfig
   Set sc=CSPMgr.GetServerParams(srvName,.srvconfig)
   if ('sc) w !,$system.Status.GetOneErrorText(sc) continue
   do ShowArray(.srvconfig,30)
 }
 q:i<1
 s srvnum=$$OPTION("Select Server? (1-"_i_")","",i)
 if +srvnum>0,$g(GWSRVS(srvnum))'="" d MANAGESRV g GETSRVACCESS
 q
MANAGESRV s $zt="MAINERR"
 q:CSPMgr=""
 New servicestatus,ipaddress,tcpport,mirroraware,conseclevel,username,password,product,spn
 New keytable,sslccprotocol,sslcckeytype,sslccverifypeer,sslccciphersuites,sslcccertificatefile,sslcccertificatekeyfile,sslcccacertificatefile,sslccprivatekeypassword
 New minsrvcons,maxsrvcons,maxconspersession,serverresponsetimeout,noactivitytimeout,timeoutallconnections,envparameters
 w !!,"Modify Server Access:",GWSRVS(srvnum),!
 w !,"(enter null or """" to specify empty-string/clear the value)",!
 k srvconfig
 Set sc=CSPMgr.GetServerParams(GWSRVS(srvnum),.srvconfig)
 if ('sc) w !,$system.Status.GetOneErrorText(sc) q
 s servicestatus=$$OPTION("Service Status",$g(srvconfig("Service_Status"),"Enabled"),,1)
 q:servicestatus<0
 s ipaddress=$$OPTION("IP Address",$g(srvconfig("Ip_Address"),"127.0.0.1"),,1)
 q:ipaddress<0
 s tcpport=$$OPTION("Superserver TCP Port",$g(srvconfig("TCP_Port"),"1972"),,1)
 q:tcpport<0
 s mirroraware=$$OPTION("Configuration is Mirror Aware ",$g(srvconfig("Mirror_Aware"),"Disabled"),,1)
 q:mirroraware<0
 //Connection Security
 //could not be updated by registry functions. fixed by CMT1592, v2018.1+
 w !,"(0=Password, 1=Kerberos ,2=Kerberos with Packet Integrity, 3=Kerberos with Encryption, 10 or 11=SSL/TLS)"
 s conseclevel=$$OPTION("Connection Security Level",$g(srvconfig("Connection_Security_Level"),"0"),,1)
 q:conseclevel<0
 s username=$$OPTION("Username accessing server",$g(srvconfig("Username"),""),,1)
 q:username<0
 s password=$$OPTION("Password accessing server",$g(srvconfig("Password"),""),,1)
 q:password<0
 w !,"(0=Cache, 1=Ensemble, 2=InterSystems IRIS)"
 s product=$$OPTION("Product",$g(srvconfig("product"),"0"),2,1,0)
 q:product<0
 s spn=$$OPTION("Service Principal Name",$g(srvconfig("Service_Principal_Name"),""),,1)
 q:spn<0
 s keytable=$$OPTION("Key Table",$g(srvconfig("Keytable"),""),,1)
 q:keytable<0
 w !,"(1=SSLv2, 2=SSLv3, 4=TLSv1.0 (default), 8=TLSv1.1, @=TLSv1.2)"
 w !,"(Concatenate values together. Example: to check TLSv1.0, v1.1 and v1.2 -> 48@)"
 s sslccprotocol=$$OPTION("SSL/TLS Protocol",$g(srvconfig("SSLCC_Protocol"),"4"),,1)
 q:sslccprotocol<0
 w !,"(1=DSA, 2=RSA (default))"
 s sslcckeytype=$$OPTION("SSL/TLS Key Type",$g(srvconfig("SSLCC_Key_Type"),"2"),,1)
 q:sslcckeytype<0
 s sslccverifypeer=$$OPTION("Require peer certificate verification",$g(srvconfig("SSLCC_Verify_Peer"),"Disabled"),,1)
 q:sslccverifypeer<0
 //added 2017-06-21 - could not be updated by registry functions before CMT1591, v2018.1+
 w !,"ALL:!aNULL:!eNULL:!EXP:!SSLv2 (default)"
 s sslccciphersuites=$$OPTION("SSL/TLS Cipher Suites",$g(srvconfig("SSLCC_Cipher_Suites"),"ALL:!aNULL:!eNULL:!EXP:!SSLv2"),,1)
 q:sslccciphersuites<0
 s sslcccertificatefile=$$OPTION("SSL/TLS Certificate File",$g(srvconfig("SSLCC_Certificate_File"),""),,1)
 q:sslcccertificatefile<0
 s sslcccertificatekeyfile=$$OPTION("SSL/TLS Private Key File",$g(srvconfig("SSLCC_Certificate_Key_File"),""),,1)
 q:sslcccertificatekeyfile<0
 s sslcccacertificatefile=$$OPTION("SSL/TLS CA Certificate File",$g(srvconfig("SSLCC_CA_Certificate_File"),""),,1)
 q:sslcccacertificatefile<0
 s sslccprivatekeypassword=$$OPTION("SSL/TLS Private Key Password",$g(srvconfig("SSLCC_Private_Key_Password"),""),,1)
 q:sslccprivatekeypassword<0
 //State-Less Parameters
 s minsrvcons=$$OPTION("Minimum Server Connections",$g(srvconfig("Minimum_Server_Connections"),"3"),,1)
 q:minsrvcons<0
 s maxsrvcons=$$OPTION("Maximum Server Connections",$g(srvconfig("Maximum_Server_Connections"),""),,1)
 q:maxsrvcons<0
 s maxconspersession=$$OPTION("Maximum Connections per Session",$g(srvconfig("Maximum_Session_Connections"),"3"),,1)
 q:maxconspersession<0
 //Optional Parameters - These parameters will be inherited from the CSP Gateway 'Default Parameters' if not specified here.
 s serverresponsetimeout=$$OPTION("Server Response Timeout",$g(srvconfig("Server_Response_Timeout"),""),,1)
 q:serverresponsetimeout<0
 s noactivitytimeout=$$OPTION("No Activity Timeout",$g(srvconfig("No_Activity_Timeout"),""),,1)
 q:noactivitytimeout<0
 s timeoutallconnections=$$OPTION("Apply timeout to all connections",$g(srvconfig("Timeout_All_Connections"),"Disabled"),,1)
 q:timeoutallconnections<0
 s envparameters=$$OPTION("Event Log Level",$g(srvconfig("Env_Parameters"),""),,1)
 q:envparameters<0
 k cU
 //only update params which really changed
 s:$g(srvconfig("Service_Status"),"Enabled")'=servicestatus cU("Service_Status")=servicestatus
 s:$g(srvconfig("Ip_Address"))'=ipaddress cU("Ip_Address")=ipaddress
 s:$g(srvconfig("TCP_Port"))'=tcpport cU("TCP_Port")=tcpport
 s:$g(srvconfig("Mirror_Aware"),"Disabled")'=mirroraware cU("Mirror_Aware")=mirroraware
 s:$g(srvconfig("Connection_Security_Level"))'=conseclevel cU("Connection_Security_Level")=conseclevel
 s:$g(srvconfig("Username"))'=username cU("Username")=username
 s:$g(srvconfig("Password"))'=password cU("Password")=password
 s:$g(srvconfig("product"),"0")'=product cU("product")=product
 s:$g(srvconfig("Service_Principal_Name"))'=spn cU("Service_Principal_Name")=spn
 s:$g(srvconfig("Keytable"))'=keytable cU("Keytable")=keytable
 s:$g(srvconfig("SSLCC_Protocol"))'=sslccprotocol cU("SSLCC_Protocol")=sslccprotocol
 s:$g(srvconfig("SSLCC_Key_Type"),"2")'=sslcckeytype cU("SSLCC_Key_Type")=sslcckeytype
 s:$g(srvconfig("SSLCC_Verify_Peer"),"Disabled")'=sslccverifypeer cU("SSLCC_Verify_Peer")=sslccverifypeer
 s:$g(srvconfig("SSLCC_Cipher_Suites"))'=sslccciphersuites cU("SSLCC_Cipher_Suites")=sslccciphersuites
 s:$g(srvconfig("SSLCC_Certificate_File"))'=sslcccertificatefile cU("SSLCC_Certificate_File")=sslcccertificatefile
 s:$g(srvconfig("SSLCC_Certificate_Key_File"))'=sslcccertificatekeyfile cU("SSLCC_Certificate_Key_File")=sslcccertificatekeyfile
 s:$g(srvconfig("SSLCC_CA_Certificate_File"))'=sslcccacertificatefile cU("SSLCC_CA_Certificate_File")=sslcccacertificatefile
 s:$g(srvconfig("SSLCC_Private_Key_Password"))'=sslccprivatekeypassword cU("SSLCC_Private_Key_Password")=sslccprivatekeypassword
 s:$g(srvconfig("Minimum_Server_Connections"))'=minsrvcons cU("Minimum_Server_Connections")=minsrvcons
 s:$g(srvconfig("Maximum_Server_Connections"))'=maxsrvcons cU("Maximum_Server_Connections")=maxsrvcons
 s:$g(srvconfig("Maximum_Session_Connections"))'=maxconspersession cU("Maximum_Session_Connections")=maxconspersession
 s:$g(srvconfig("Server_Response_Timeout"))'=serverresponsetimeout cU("Server_Response_Timeout")=serverresponsetimeout
 s:$g(srvconfig("No_Activity_Timeout"))'=noactivitytimeout cU("No_Activity_Timeout")=noactivitytimeout
 s:$g(srvconfig("Timeout_All_Connections"),"Disabled")'=timeoutallconnections cU("Timeout_All_Connections")=timeoutallconnections
 s:$g(srvconfig("Env_Parameters"))'=envparameters cU("Env_Parameters")=envparameters
 w !
 if '$d(cU) w !,"No Changes!" s Option=$$OPTION("<CR> to continue","","") q
 if 0 w !,"***",! zw cU w "***",!
 if $$YN("Apply Changes","Y")="Y" {
   Set sc=CSPMgr.SetServerParams(GWSRVS(srvnum),.cU)
   if ('sc) w !,$system.Status.GetOneErrorText(sc) q
   w !,"Updated!"
 }
 s Option=$$OPTION("<CR> to continue","","")
 q
SETACCESSSRV s $zt="MAINERR"
 q:CSPMgr=""
 New username,password,cU
 w !,"Username? : " r username
 w !,"Password? : " r password
 k cU
 s cU("Username")=username
 s cU("Password")=password
 Set sc=CSPMgr.SetServerParams(GWSRVS(srvnum), .cU)
 if ('sc) w !,$system.Status.GetOneErrorText(sc) q
 w !,"Username/Password set!"
 s Option=$$OPTION("<CR> to continue","","")
 q
GETAPPACCESS s $zt="MAINERR"
 q:CSPMgr=""
 New appPaths,i,appPath,appPathStatus,appconfig
 k appPaths
 Set sc=CSPMgr.GetApplicationPaths(.appPaths)
 if ('sc) w !,$system.Status.GetOneErrorText(sc) q
 k GWAPPS,appnum
 w !!,"Application Access:"
 For i=1:1:$LL(appPaths) {
   s appPath=$p($LG(appPaths,i),"=",1)
   q:appPath[":"  //server-side web/csp-App/Path (the blue readonly ones)
   s GWAPPS(i)=appPath
   s appPathStatus=$p($LG(appPaths,i),"=",2)
   w !!,i," - Application Path",?30," : ",appPath
   w !,"Service-Status",?30," : ",appPathStatus
   k appconfig
   Set sc=CSPMgr.GetApplicationParams(appPath,.appconfig)
   if ('sc) w !,$system.Status.GetOneErrorText(sc) continue
   do ShowArray(.appconfig,30)
 }
 q:i<1
 s appnum=$$OPTION("Select Application? (1-"_$O(GWAPPS(""),-1)_")","",i)
 if +appnum>0,$g(GWAPPS(appnum))'="" d MANAGEAPP g GETAPPACCESS
 s Option=$$OPTION("<CR> to continue","","")
 q
MANAGEAPP s $zt="MAINERR"
 q:CSPMgr=""
 New apppath,appconfig,gzip,gzipminsize,gzipexft,rsn,rsnalways,keepalive,nph,cU
 New appservicestatus,extracgi,procclass,altservers,server1,server1status,server2,server2status,server3,server3status,gzipdef
 s apppath=$g(GWAPPS(appnum))
 w !!,"Modify Application Path:",apppath,!
 w !,"(enter null or """" to specify empty-string/clear the value)",!
 k appconfig
 Set sc=CSPMgr.GetApplicationParams(apppath,.appconfig)
 if ('sc) w !,$system.Status.GetOneErrorText(sc) q
 s appservicestatus=$$OPTION("Service Status",$g(appconfig("Application_Status"),"Enabled"),,1)
 q:appservicestatus<0
 s extracgi=$$OPTION("Extra CGI Environment Variables",$g(appconfig("Extra_CGI_Env_Variables"),""),,1)
 q:extracgi<0
 s procclass=$$OPTION("Process with this class",$g(appconfig("Proc_Class"),""),,1)
 q:procclass<0
 //CMT1112 - Change the default setting for the 'GZIP Compression' parameter so that GZIP compression is 'Enabled' for all Application Paths. Build nnn.1353
 s gzipdef="Enabled" if +$g(gwid),$d(GW(gwid)) s gzipdef=$s(+$p($p($p(GW(gwid),"~",2),"b",2),".",2)>=1353:"Enabled",1:"Disabled")
 s gzip=$$OPTION("GZIP Compression",$g(appconfig("GZIP_Compression"),gzipdef),,1)
 q:gzip<0
 s gzipminsize=$$OPTION("GZIP Minimum File Size",$g(appconfig("GZIP_Minimum_File_Size"),500),,1)
 q:gzipminsize<0
 s gzipexft=$$OPTION("GZIP Exclude File Types",$g(appconfig("GZIP_Exclude_File_Types"),"jpeg gif ico png gz zip mp3 mp4"),,1)
 q:gzipexft<0
 w !,"(Chunked Transfer Encoding and Content Length (default),",!," Chunked Transfer Encoding,",!," Content Length)"
 s rsn=$$OPTION("Response Size Notification",$g(appconfig("Response_Size_Notification"),"Chunked Transfer Encoding and Content Length"),,1)
 q:rsn<0
 s rsnalways=$$OPTION("Generate a response size notification for all requests",$g(appconfig("Response_Size_Notification_Always"),"Disabled"),,1)
 q:rsnalways<0
 w !,"(No Action (default), Enabled, Disabled)"
 s keepalive=$$OPTION("KeepAlive",$g(appconfig("KeepAlive"),"No Action"),,1)
 q:keepalive<0
 s nph=$$OPTION("Non-Parsed Headers",$g(appconfig("Non_Parsed_Headers"),"Enabled"),,1)
 q:nph<0
 //"FailOver" = Fail-Over, "LoadBalancing" = Load-Balancing and Fail-Over
 s altservers=$$OPTION("Use Alternative Servers For",$g(appconfig("Alternative_Servers"),"FailOver"),,1)
 q:altservers<0
 s server1=$$OPTION("Server 1",$g(appconfig("Alternative_Server_0"),$get(appconfig("Default_Server"))),,1)
 q:server1<0
 s server1status=$$OPTION("Server 1 Status",$g(appconfig("Alternative_Server_0_Status"),"Enabled"),,1)
 q:server1status<0
 s server2=$$OPTION("Server 2",$g(appconfig("Alternative_Server_1"),""),,1)
 q:server2<0
 s server2status=$$OPTION("Server 2 Status",$g(appconfig("Alternative_Server_1_Status"),"Disabled"),,1)
 q:server2status<0
 s server3=$$OPTION("Server 3",$g(appconfig("Alternative_Server_2"),""),,1)
 q:server3<0
 s server3status=$$OPTION("Server 3 Status",$g(appconfig("Alternative_Server_2_Status"),"Disabled"),,1)
 q:server3status<0
 k cU
 //only update params which really changed
 s:$g(appconfig("Application_Status"),"Enabled")'=appservicestatus cU("Application_Status")=appservicestatus
 s:$g(appconfig("GZIP_Compression"))'=gzip cU("GZIP_Compression")=gzip
 s:$g(appconfig("GZIP_Minimum_File_Size"))'=gzipminsize cU("GZIP_Minimum_File_Size")=gzipminsize
 s:$g(appconfig("GZIP_Exclude_File_Types"))'=gzipexft cU("GZIP_Exclude_File_Types")=gzipexft
 s:$g(appconfig("Response_Size_Notification"))'=rsn cU("Response_Size_Notification")=rsn
 s:$g(appconfig("Response_Size_Notification_Always"),"Disabled")'=rsnalways cU("Response_Size_Notification_Always")=rsnalways
 s:$g(appconfig("KeepAlive"))'=keepalive cU("KeepAlive")=keepalive
 s:$g(appconfig("Non_Parsed_Headers"))'=nph cU("Non_Parsed_Headers")=nph
 s:$g(appconfig("Extra_CGI_Env_Variables"))'=extracgi cU("Extra_CGI_Env_Variables")=extracgi
 s:$g(appconfig("Proc_Class"))'=procclass cU("Proc_Class")=procclass
 s:$g(appconfig("Alternative_Servers"),"FailOver")'=altservers cU("Alternative_Servers")=altservers
 s:$g(appconfig("Alternative_Server_0"))'=server1 cU("Alternative_Server_0")=server1
 s:$g(appconfig("Alternative_Server_0_Status"),"Enabled")'=server1status cU("Alternative_Server_0_Status")=server1status
 s:$g(appconfig("Alternative_Server_1"))'=server2 cU("Alternative_Server_1")=server2
 s:$g(appconfig("Alternative_Server_1_Status"),"Disabled")'=server2status cU("Alternative_Server_1_Status")=server2status
 s:$g(appconfig("Alternative_Server_2"))'=server3 cU("Alternative_Server_2")=server3
 s:$g(appconfig("Alternative_Server_2_Status"),"Disabled")'=server2status cU("Alternative_Server_2_Status")=server3status
 w !
 if '$d(cU) w !,"No Changes!" s Option=$$OPTION("<CR> to continue","","") q
 //k cU("Alternative_Server_0_Status")
 if 0 w !,"***",! zw cU w "***",!
 if $$YN("Apply Changes","Y")="Y" {
   Set sc=CSPMgr.SetApplicationParams(apppath,.cU)
   if ('sc) w !,$system.Status.GetOneErrorText(sc) q
   w !,"Updated!"
 }
 s Option=$$OPTION("<CR> to continue","","")
 q
ShowArray(A,px) ;
 New k
 s k="" s:+$g(px)=0 px=35
 For  {
	Set k=$order(A(k))
	q:k=""
	w !,k,?px," : ",A(k)	 
 }
 q
GetSelectedGW() ;
 q:+$g(gwid)<1
 Set CSPMgr=CSPMgrs.GetAt(gwid)
 q:CSPMgr=""
 w "[GW "_gwid_" - "_CSPMgr.IPAddress_":"_CSPMgr.Port_"] " //_" "_$s(CSPMgr.State="i":"no ",1:"")_" live connection"_" "_$zd(CSPMgr.LastConnectTime,3)
 //selected server 
 q:+$g(srvnum)<1
 q:$g(GWSRVS(srvnum))=""
 w "[SRV "_srvnum_" - "_GWSRVS(srvnum)_"] "
 //selected application path
 q:+$g(appnum)<1
 q:$g(GWAPPS(appnum))=""
 w "[APP "_appnum_" - "_GWAPPS(appnum)_"] "
 q
GetGWS(GW) ;
 New info,CSPRegs,count,mgrid,webserverport
 //w !,"***GetGatewayMgrs from GatewayRegistry***",!
 Set webserverport=$$GetConfig("WebServerPort") 
 Set CSPRegs=$system.CSP.GetGatewayRegistry()
 Set CSPMgrs=CSPRegs.GetGatewayMgrs()
 Set count=CSPMgrs.Count()
 For mgrid=1:1:count {
	 set CSPMgr=CSPMgrs.GetAt(mgrid)
	 q:CSPMgr=""
	 set GW(mgrid)=CSPMgr.Server_":"_CSPMgr.Port
 	 Set sc=CSPMgr.GetInfo(.info)
 	 if sc {
	 	 Set GW(mgrid)=GW(mgrid)_"~v"_info.Version_" b"_$p(info.Build," ",1)_"~"_info.ActiveInterface_"~"_info.WebServerName_"~"_info.WebServerSoftware_"~"_$s(CSPMgr.Port=webserverport:1,1:0)
	 	 if +$System.Version.GetNumber()>=2015.1 {  //CMT1293 2015.1+
	 	   Set GW(mgrid)=GW(mgrid)_"~"_info.Configuration
	 	 }
 	 }
 }
 q count
GetConfig(name) ;
 New result,currNsp,CPFProperties,Properties
 s currNsp=$namespace
 Try {
   if currNsp'="%SYS" ZNspace "%SYS"
   set CPFProperties = ##class(Config.Startup).Get(.Properties)
   set result=$g(Properties(name))
 }
 Catch { }
 if $namespace'=currNsp ZNspace currNsp
 Quit $g(result)
ENAISCLOG s $zt="MAINERR"
 New loglevel,maxlogentries,errordetail,category
 w !!,"*** Attention: Enabling will delete all currently availabel log-data ***"
 s loglevel=$$OPTION("What loglevel? (1,2,3)",3,3)
 q:+loglevel<1
 s maxlogentries=$$OPTION("MaxLogEntries",1000000,9999999)
 q:+maxlogentries<1
 s errordetail=$$OPTION("ErrorDetail",1,2)
 q:+errordetail<1
 s category=$$OPTION("Category (leave empty for all)","")
 q:category<0
 do EnableISCLOG(loglevel,maxlogentries,errordetail,category)
 w !,"enabled!"
 s Option=$$OPTION("<CR> to continue","","")
 q
DISISCLOG s $zt="MAINERR"
 do DisableISCLOG()
 w !,"disabled!"
 s Option=$$OPTION("<CR> to continue","","")
 q
EXPISCLOG s $zt="MAINERR"
 New mode,file,ok
 s mode=$$OPTION("Export mode? (1 = xml, 2 = txt)",1,2)
 q:+mode<1
 w !!,"Filename? <"_$System.Util.ManagerDirectory()_"isclog."_$select(mode=2:"txt",1:"xml")_"> : " r file
 s:file="" file=$System.Util.ManagerDirectory()_"isclog."_$select(mode=2:"txt",1:"xml")
 if $zconvert(file,"L")="e"!($zconvert(file,"L")="q") q
 if $$YN("Export now","Y")="Y" {
	 Set ok=$$ExportISCLOG(file, $s(mode=2:1,1:""))
	 if 'ok w !,"Could not export! File could not be created. Please check path of given filename." q
	 w !,file," Exported!"
 	 s Option=$$OPTION("<CR> to continue","","")
 }
 q
EnableISCLOG(loglevel, maxlogentries, errordetail, category) //
	Set:$get(loglevel)="" loglevel=3
	Set:$get(maxlogentries)="" maxlogentries=1000000
	Set:$get(errordetail)="" errordetail=1
	if loglevel>0 k ^%ISCLOG k:$system.Version.GetProduct()["IRIS" ^|"%SYS"|ISCLOG
	Set ^%ISCLOG=loglevel
	if loglevel>0 {
		Set ^%ISCLOG("MaxLogEntries")=maxlogentries  //only the last 10000 by default, this is not enough :(
		Set ^%ISCLOG("ErrorDetail")=errordetail  //0 - Just log the message and the value of $ZE and $ZU(56,5), 1 (default) - Log the message, the value of $ZE and $ZU(56,5) and the call stack, 2 - Log the local symbol table $ZE, $ZU(56,5) and the call stack
		if $get(category)="" {
			k ^%ISCLOG("Category")
		}
		else  {
			Set ^%ISCLOG("Category",category)="" //if you want to make entries only for selected Categories, "CSPDispatch", "CSPRequest", etc.
		}
		//Set ^%ISCLOG("Job",job)="" //if you want to make entries only for selected CSP-Server processes
	}
	Quit
DisableISCLOG() //
	do EnableISCLOG(0)
	Quit
	// Export ^%ISCLOG (default xml mode)
ExportISCLOG(file, plaintext)
	//plaintext is often more convenient for analysing in editors
	New a,io
	if $get(file)="" Set file=$System.Util.ManagerDirectory()_"isclog."_$select(+$get(plaintext):"txt",1:"xml") Write "Export to Filename? <"_file_"> : " Read a Set:a'="" file=a
	if +$get(plaintext) {
	  new io
 	  set io=$IO
 	  open file:"WNS":2
 	  if '$T Quit 0
 	  use file
 	  if $system.Version.GetProduct()["IRIS" {
	 	  zw ^|"%SYS"|ISCLOG
 	  }
 	  else  {
	 	  zwrite ^%ISCLOG
 	  }
 	  close file
 	  use io
	}
	else  {	
	  do $System.OBJ.Export($s($system.Version.GetProduct()["IRIS":"ISCLOG.GBL",1:"%ISCLOG.GBL"),file)  //we are already always in %SYS anyway
	}
	Quit 1
ISCLOGSTATE() ;
 New x,res,xd,iscloggbl
 s x=+$g(^%ISCLOG)
 s res=$s(x=0:"disabled!",1:"enabled! ["_x_"]")
 s iscloggbl=$s($system.Version.GetProduct()["IRIS":"^|""%SYS""|ISCLOG(""Data"")",1:"^%ISCLOG(""Data"")")
 if $d(@iscloggbl)>1 s xd=+$g(@iscloggbl) s res=res_" Log Data available"_$s(xd>0:" ["_xd_" entrys]",1:"")
 q res
ENAISCSOAP s $zt="MAINERR"
 New what,logfile,Nsp,currNsp,NSPS
 k NSPS
ASKNSPE //
 s currNsp=$namespace
 do GetNSPS^CSPGWMGR(.NSPS,0)
 w !!,"Enable SOAPLog in Namespace? <"_currNsp_"> (? to list namespaces) : " r Nsp
 if Nsp="" s Nsp=currNsp
 if $zconvert(Nsp,"L")="e"!($zconvert(Nsp,"L")="q") q
 if Nsp="?" {
	 w !,"List of defined namespaces:"
	 s Nsp="" For  s Nsp=$o(NSPS(Nsp)) q:Nsp=""  w !,Nsp
	 g ASKNSPE
 }
 w !!,"log mode? (i,o,s,h,v) <ios> : " r what
 s what=$zconvert(what,"L")
 if what="" s what="ios"
 q:'(what["i")&&('(what["o"))&&('(what["s"))&&('(what["h"))&&('(what["v"))
 w !!,"logfile? <"_$g(^ISCSOAP("LogFile"),$System.Util.ManagerDirectory()_"iscsoap_"_$zconvert(Nsp,"L")_".txt")_"> : " r logfile
 s:logfile="" logfile=$g(^ISCSOAP("LogFile"),$System.Util.ManagerDirectory()_"iscsoap_"_$zconvert(Nsp,"L")_".txt")
 if $zconvert(logfile,"L")="e"!($zconvert(logfile,"L")="q") q
 Try {
   ZNspace Nsp
   do EnableSOAPLog(what, logfile)
 }
 Catch {
   //
 }
 ZNspace currNsp
 s Option=$$OPTION("<CR> to continue","","")
 q
DISISCSOAP s $zt="MAINERR"
 New currNsp,Nsp,NSPS
 k NSPS
ASKNSPD //
 s currNsp=$namespace
 do GetNSPS^CSPGWMGR(.NSPS,0)
 w !!,"Disable SOAPLog in Namespace? <"_currNsp_"> (? to list namespaces, * = All) : " r Nsp
 if Nsp="" s Nsp=currNsp
 if $zconvert(Nsp,"L")="e"!($zconvert(Nsp,"L")="q") q
 if Nsp="?" {
	 w !,"List of defined namespaces:"
	 s Nsp="" For  s Nsp=$o(NSPS(Nsp)) q:Nsp=""  w !,Nsp
	 g ASKNSPD
 }
 if Nsp="*",$d(NSPS) {
   s Nsp=""
   For  {
	 s Nsp=$o(NSPS(Nsp))
	 q:Nsp=""
	 Try {
       ZNspace Nsp
       do DisableSOAPLog()
       w !,"SOAPLog disabled in Nsp. "_$namespace_"!"
     }
     Catch {
       //
     }
   }   
 }
 else  { 
   Try {
     ZNspace Nsp
     do DisableSOAPLog()
     w !,"SOAPLog disabled in Nsp. "_$namespace_"!"
   }
   Catch {
     //
   }
 }
 ZNspace currNsp
 s Option=$$OPTION("<CR> to continue","","")
 q
EnableSOAPLog(what, logfile)
 s:$g(what)="" what="ios"
 s:$g(logfile)="" logfile=$System.Util.ManagerDirectory()_"iscsoap.txt"
 s ^ISCSOAP("Log")=what //i=Input, o=Output, s=security, v=verbose
 s ^ISCSOAP("LogFile")=logfile
 w !,"SOAPLog to "_logfile_" enabled in Nsp. "_$namespace_"!"
 Quit
DisableSOAPLog()
 k ^ISCSOAP("Log")
 k ^ISCSOAP("LogFile")
 Quit
ISCSOAPSTATES() ;
 New NSPS,Nsp
 k NSPS
 do GetNSPS(.NSPS,1)
 s Nsp=""
 For  {
   s Nsp=$O(NSPS(Nsp))
   Quit:Nsp=""
   w !,?3,Nsp," : ",NSPS(Nsp)  	 
 }
 Quit ""
ISCSOAPSTATE() ;
 New what,logfile
 s what=$g(^ISCSOAP("Log"))
 q:what="" "disabled!"
 s logfile=$g(^ISCSOAP("LogFile"))
 q "enabled! ["""_what_"""] "_logfile
GetNSPS(NSPS,iscsoapstate) ;
 New i,currNsp,rsNsp,Nsp
 Set currNsp=$namespace
 Set rsNsp=##class(%Library.ResultSet).%New("%SYS.Namespace:List")
 Do rsNsp.Execute()
 While rsNsp.Next() {
   Set Nsp=rsNsp.Data("Nsp")
   If Nsp["DOCBOOK" Continue
   Set NSPS(Nsp)=""
   if $g(iscsoapstate)=1 {
     Try {
       ZNspace Nsp
     }
     Catch {
       ZNspace currNsp
       Continue
     }
     Set NSPS(Nsp)=$$ISCSOAPSTATE()
   }
 }
 Do rsNsp.Close()
 ZNspace currNsp
 Quit
CSPSERVERLOG ;
 New LN,N,HEAD,TEXT,currNsp,rsNsp,Nsp
 Set LN=0
 If $data(^%cspServer("LOG")) {
   W !,"^%cspServer(""LOG"") - Namespace "_$namespace_":"
   Set N="" For  Set N=$O(^%cspServer("LOG",N)) Quit:N=""  Set LN=LN+1,HEAD=$get(^(N,0)),TEXT=$get(^(1)) Do DISPLIN(HEAD,TEXT)
 }
 Set currNsp=$namespace
 Set rsNsp=##class(%Library.ResultSet).%New("%SYS.Namespace:List")
 Do rsNsp.Execute()
 While rsNsp.Next() {
   Set Nsp=rsNsp.Data("Nsp")
   If Nsp["DOCBOOK" Continue
   Try {
     ZNspace Nsp
   }
   Catch {
     ZNspace currNsp
     Continue
   }
   If $data(^cspServer("LOG")) {
     Write !!,"^cspServer(""LOG"") - Namespace "_Nsp_":"
     Set N="" For  Set N=$order(^cspServer("LOG",N)) Quit:N=""  Set LN=LN+1,HEAD=$get(^(N,0)),TEXT=$get(^(1)) Do DISPLIN(HEAD,TEXT)
   }
 }
 Do rsNsp.Close()
 ZNspace currNsp
 If 'LN { Write !,"The cspServer-Error-Log is empty!",! }
 s Option=$$OPTION("<CR> to continue","","")
 Quit
DISPLIN(HEAD,TEXT) Write !!,">>> ",$piece(HEAD,"~"),", NameSpace: ",$piece(HEAD,"~",2),!,TEXT
 Quit
OPTION(prompt,default,max,nogw,min)
 New in
 s $zt="RERR"
OPTION1 ; 
 w !
 if +$g(nogw)=0 w ! do GetSelectedGW()
 w prompt w:default'="" " <"_default_">" w " : "
 r in if default'="",in="" q default
 q:in=""&(default="") ""
 if in=""""""!(in=" ")!($zconvert(in,"L")="null") q ""
 if $zconvert(in,"L")="e"!($zconvert(in,"L")="q") q -1
 if +$g(max)>0,'(in?1.2N)!(in<$g(min,1))!(in>max) w !!,"Please enter a number between "_$g(min,1)_" and "_max,! g OPTION1
 q in
YN(P,D,t)
 New R,X
 s $zt="RERR"
 s P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 s D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 For  {
   w !,P_"? "_D
   Read:t R:t
   Read:'t R
   s X=R,R=$TR($E(R_D_"?"),"ynqe","YNQE")
   if "^YNQE"'[R w "  enter Yes or No, please"
   e  q  ;timed or non-timed read
 }
 w $E($S(R="N":"No",R="Y":"Yes",1:""),$L(X)+1,3)
 q R
RERR s $zt=""
 if $ze'["<INTERRUPT>" w !,"ERROR: "_$ZE
 q 0
 //call CSPButtons
CSPButtons //
 s $zt="MAINERR"
 do ^CSPButtons
 Quit
RegPWS() ;
 //do a request to initialize and make the PWS Gateway registered if it is currently not.
 New sc
 s sc=$$CheckPWSState(0,0)
 Quit:'sc sc
 New page,httprequest,server 
 Set page="/csp/sys/%25CSP.Portal.Home.zen?"_$s($system.Version.GetProduct()["IRIS":"IRIS",1:"Cache")_"Logout=end"
 Set httprequest=##class(%Net.HttpRequest).%New()
 Set server=$$GetConfig("WebServerName")
 Set:server="" server="127.0.0.1"
 Set httprequest.Server=server
 Set httprequest.Port=$$GetConfig("WebServerPort")
 Set httprequest.Timeout=10
 Set sc=httprequest.Get(page)
 Quit:'sc sc
 if 0=1 {
   w !,"url/page:http://",server,":",httprequest.Port_page
   w !,"StatusCode:",httprequest.HttpResponse.StatusCode,!
   do httprequest.HttpResponse.Data.OutputToDevice()
 }
 if httprequest.HttpResponse.StatusCode=200 Quit 1
 Quit 0
CheckPWSState(delay,wsport) ;
 New sc
 s $zt="CheckPWSStateError"
 //this method is not available in Config.Startup for older versions. Signature changed with CMT1630 (wsport was added)
 Try {
   s sc=##Class(Config.Startup).CheckWebServerStatus(delay,wsport)  //-> http://localhost:<port>/csp/sys/gateway_status.cxw => SUCCESS
 }
 Catch {
   s sc=##Class(Config.Startup).CheckWebServerStatus()
 }
 Quit sc
CheckPWSStateError ;
 s $zt=""
 if 0=1 w !,"CheckPWSStateError:",$ZE
 Quit 1
StopPWS() public {
 Quit:$zconvert($System.Version.GetBuildOS(),"U")["VMS" 0
 Set method="StopPWS^CSPGWMGR", update=2, ret=0, quit=0 
 Try { 
   If '##class(%CSP.Mgr.GatewayMgrImpl).CheckPermissions(method,update) {
     Write !,"Insufficient privileges to invoke the '"_method_"' utility"
     Set quit=1 
   }
 } 
 Catch { 
   //CMT1642, MAK5058: exception silenced for backward compatibility
 } 
 Quit:quit ret
 Set sc=##Class(Config.Startup).StopWebServer(1)  //is doing a Hang 5
 if sc {
   s sc=$$CheckPWSState(0,0) //is doing a request with Timeout=10 sec.
   //if stopped => ERROR #6059: Can't open TCP/IP-Socket for Server 127.0.0.1:<port>
   if 'sc set sc=1  //OK!!!
 }
 Quit sc
}
StartPWS(wsport) public {
 Quit:$zconvert($System.Version.GetBuildOS(),"U")["VMS" 0
 Set method="StartPWS^CSPGWMGR", update=2, ret=0, quit=0 
 Try { 
   If '##class(%CSP.Mgr.GatewayMgrImpl).CheckPermissions(method,update) {
     Write !,"Insufficient privileges to invoke the '"_method_"' utility"
     Set quit=1 
   }
 } 
 Catch { 
   //CMT1642, MAK5058: exception silenced for backward compatibility
 }
 Quit:quit ret
 Set:$g(wsport)="" wsport=$$GetConfig("WebServerPort")
 Set wsaddress=$$GetConfig("WebServerName")
 Set address=$s(wsaddress="":wsport,1:wasaddress_":"_wsport)
 Try {
   Set idir=$system.Util.DataDirectory() //$system.Util.InstallDirectory() //c:\intersystems\iris20191\
 }
 Catch {
   Set idir=$p($zu(12),"mgr",1)
 }
 If $$isZF100() {
   //new secure callout. CTM1657->CMT1664
   Set dir=##class(%Library.File).SubDirectoryName(idir,"httpd") //C:\InterSystems\IRIS20191\httpd
   Set log=##class(%Library.File).SubDirectoryName(##class(%Library.File).SubDirectoryName(dir,"logs"),"httpderr") //C:\InterSystems\IRIS20191\httpd\logs\httpderr
   Set cmd=##class(%Library.File).SubDirectoryName(##class(%Library.File).SubDirectoryName(##class(%Library.File).SubDirectoryName(idir,"httpd"),"bin"),"httpd") //C:\InterSystems\IRIS20191\httpd\bin\httpd
   If $zconvert($System.Version.GetBuildOS(),"U")?1"WIN".e {
     Set args($I(args))="-k"
     Set args($I(args))="start"
     Set args($I(args))="-n"
     Set args($I(args))=$p($zu(86),"*",2)_"httpd"
     Set args($I(args))="-c"
     Set args($I(args))="Listen "_address
     Set x=$ZF(-100,"/STDOUT="""_log_"""/STDERR="""_log_"""",cmd,args(1),args(2),args(3),args(4),args(5),args(6))
   } ElseIf $zconvert($System.Version.GetBuildOS(),"U")["UNIX" {
       Set args($I(args))="-d"
       Set args($I(args))=dir
       Set args($I(args))="-c"
       Set args($I(args))="Listen "_address
       Set opts="/STDOUT="""_log_"""/STDERR="""_log_""""
       If (($system.Version.GetProduct()["IRIS") && ($System.Version.GetNumber()>=2020.4)) {
          Set opts="/KEEPLIB "_opts
       }
       Set x=$ZF(-100,opts,cmd,args(1),args(2),args(3),args(4))
   }
   //Set x=$ZF(-100,opts,cmd,.args)  //.args or args... unfortunately does not compile (is not valid syntax) pre v2018.1 -> args(1),args(2),...
 }
 else  {
   //old callout
   If $zconvert($System.Version.GetBuildOS(),"U")?1"WIN".e {
     Set cmd=$zu(147,idir_"httpd\bin\httpd.exe")_" -k start -n "_$p($zu(86),"*",2)_"httpd -c ""Listen "_address_""""
     //c:\intersystems\cache20161l\httpd\bin\httpd.exe -k start -n CACHE20161Lhttpd -c "Listen 57785"
   } 
   If $zconvert($System.Version.GetBuildOS(),"U")["UNIX" {
     Set cmd=$zu(147,idir_"httpd/bin/httpd")_" -d "_$zu(147,idir_"httpd")_" -c ""Listen "_address_""" >"_$zu(147,idir_"httpd/logs/httpderr")_" 2>&1 </dev/null"
   }
   Set x=$ZF(-2,cmd)
 }
 s sc=$$CheckPWSState(0,wsport)
 Quit sc
}
RestartPWS(wsport) public {
 Quit:$zconvert($System.Version.GetBuildOS(),"U")["VMS" 0
 Set method="RestartPWS^CSPGWMGR", update=2, ret=0, quit=0 
 Try { 
   If '##class(%CSP.Mgr.GatewayMgrImpl).CheckPermissions(method,update) {
     Write !,"Insufficient privileges to invoke the '"_method_"' utility"
     Set quit=1
   }
 } 
 Catch { 
   //CMT1642, MAK5058: exception silenced for backward compatibility
 }
 Quit:quit ret
 Set ok=$$StopPWS()
 if ok {
   set ok=$$StartPWS($g(wsport))
 }
 Quit ok
}
TestisZF100() ;
  Quit $$isZF100()
isZF100() ;
  New zf100,zf100x,zf100ex,opt
  If $zconvert($System.Version.GetBuildOS(),"U")?1"WIN".e Set opt="/STDOUT=""//./nul"""
  Else  Set opt="/STDOUT=""/dev/null"""
  set zf100=1 try { set zf100x=$ZF(-100,opt,"echo") } catch zf100ex { set:zf100ex.Name["<FUNCTION" zf100=0 }
  quit zf100

CryptoTest^INT^1^67214,47330
 d MENU()
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 q
MENU() PUBLIC { 
 s $zt="ERROR"
 s List(1)="NIST 800-38A AES-CBC tests"
 s List(2)="FIPS 180-2 SHA tests"
 s List(3)="RFC 2202/4231 HMAC-SHA tests"
 s List(4)="RFC 6070 PBKDF2 tests"
 s List(5)="RFC 3548 Base64 tests"
 s List(6)="RFC 3394 AES Key Wrap tests"
 f  {
 	s Value=""
 	s Status=##Class(%Library.Prompt).GetMenu("Select tests:",.Value,.List,,8+128+4)
 	i (Status=0)||(Status=2)||(Value="") q
 	i Value=1 d AESCBCtest() Continue
 	i Value=2 d SHAtest() Continue
 	i Value=3 d HMACSHAtest() Continue
 	i Value=4 d PBKDF2test() Continue
 	i Value=5 d Base64Test() Continue
 	i Value=6 d AESKeyWrapTest() Continue
 }
 q Status
ERROR s $zt=""
 i $ze["<INTERRUPT>" q 0
 ztrap $ze
}
AESCBCtest() PUBLIC {
 w !,"NIST 200-38A AES-CBC tests"
 s Keyi(1)="2b7e151628aed2a6abf7158809cf4f3c"
 s Keyi(2)="8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b"
 s Keyi(3)="603deb1015ca71be2b73aef0857d7781"
 s Keyi(3)=Keyi(3)_"1f352c073b6108d72d9810a30914dff4"
 s IVi="000102030405060708090a0b0c0d0e0f"
 s IV=""
 f i=2:2:$l(IVi) s IV=IV_$c($zh($e(IVi,i-1,i)))
 s Plaintexti=""
 s Plaintexti=Plaintexti_"6bc1bee22e409f96e93d7e117393172a"
 s Plaintexti=Plaintexti_"ae2d8a571e03ac9c9eb76fac45af8e51"
 s Plaintexti=Plaintexti_"30c81c46a35ce411e5fbc1191a0a52ef"
 s Plaintexti=Plaintexti_"f69f2445df4f9b17ad2b417be66c3710"
 s Plaintext=""
 f i=2:2:$l(Plaintexti) s Plaintext=Plaintext_$c($zh($e(Plaintexti,i-1,i)))
 s Ciphertexti(1)=""
 s Ciphertexti(1)=Ciphertexti(1)_"7649abac8119b246cee98e9b12e9197d"
 s Ciphertexti(1)=Ciphertexti(1)_"5086cb9b507219ee95db113a917678b2"
 s Ciphertexti(1)=Ciphertexti(1)_"73bed6b8e3c1743b7116e69e22229516"
 s Ciphertexti(1)=Ciphertexti(1)_"3ff1caa1681fac09120eca307586e1a7"
 s Ciphertexti(2)=""
 s Ciphertexti(2)=Ciphertexti(2)_"4f021db243bc633d7178183a9fa071e8"
 s Ciphertexti(2)=Ciphertexti(2)_"b4d9ada9ad7dedf4e5e738763f69145a"
 s Ciphertexti(2)=Ciphertexti(2)_"571b242012fb7ae07fa9baac3df102e0"
 s Ciphertexti(2)=Ciphertexti(2)_"08b0e27988598881d920a9e64f5615cd"
 s Ciphertexti(3)=""
 s Ciphertexti(3)=Ciphertexti(3)_"f58c4c04d6e5f1ba779eabfb5f7bfbd6"
 s Ciphertexti(3)=Ciphertexti(3)_"9cfc4e967edb808d679f777bc6702c7d"
 s Ciphertexti(3)=Ciphertexti(3)_"39f23369a9d9bacfa530e26304231461"
 s Ciphertexti(3)=Ciphertexti(3)_"b2eb05e2c39be9fcda6c19078c6a9d1b"
 w !,"Original plaintext:"
 zzdump Plaintext
 w !,"IV:"
 zzdump IV
 for j=1:1:3 {
 s Key=""
 f i=2:2:$l(Keyi(j)) s Key=Key_$c($zh($e(Keyi(j),i-1,i)))
 w !,!,$l(Key)," byte key:"
 zzdump Key
 s Ciphertext=""
 f i=2:2:$l(Ciphertexti(j)) s Ciphertext=Ciphertext_$c($zh($e(Ciphertexti(j),i-1,i)))
 s Ciphertext2=$SYSTEM.Encryption.AESCBCEncrypt(Plaintext,Key,IV)
 if $e(Ciphertext2,1,$l(Ciphertext))=Ciphertext w !,"Encrypted ciphertext matches expected ciphertext."
 else  w !,"Encryption error.",!,"Test failed!" q
 s Plaintext2=$SYSTEM.Encryption.AESCBCDecrypt(Ciphertext2,Key,IV)
 if Plaintext2=Plaintext w !,"Decrypted plaintext matches original plaintext."
 else  w !,"Decryption error.",!,"Test failed!" q
 w !,"Test passed."
 }
 q
}
AESKeyWrapTest() PUBLIC {
 w !,"RFC 3394 AES Key Wrap tests"
 s Keyi(1)="00112233445566778899AABBCCDDEEFF"
 s Keyi(2)="00112233445566778899AABBCCDDEEFF"
 s Keyi(3)="00112233445566778899AABBCCDDEEFF"
 s Keyi(4)="00112233445566778899AABBCCDDEEFF0001020304050607"
 s Keyi(5)="00112233445566778899AABBCCDDEEFF0001020304050607"
 s Keyi(6)="00112233445566778899AABBCCDDEEFF000102030405060708090A0B0C0D0E0F"
 s KEKi(1)="000102030405060708090A0B0C0D0E0F"
 s KEKi(2)="000102030405060708090A0B0C0D0E0F1011121314151617"
 s KEKi(3)="000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F"
 s KEKi(4)="000102030405060708090A0B0C0D0E0F1011121314151617"
 s KEKi(5)="000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F"
 s KEKi(6)="000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F"
 s Cipheri(1)="1FA68B0A8112B447AEF34BD8FB5A7B829D3E862371D2CFE5"
 s Cipheri(2)="96778B25AE6CA435F92B5B97C050AED2468AB8A17AD84E5D"
 s Cipheri(3)="64E8C3F9CE0F5BA263E9777905818A2A93C8191E7D6E8AE7"
 s Cipheri(4)="031D33264E15D33268F24EC260743EDCE1C6C7DDEE725A936BA814915C6762D2"
 s Cipheri(5)="A8F9BC1612C68B3FF6E6F4FBE30E71E4769C8B80A32CB8958CD5D17D6B254DA1"
 s Cipheri(6)="28C9F404C4B810F4CBCCB35CFB87F8263F5786E2D80ED326CBC7F0E71A99F43BFB988B9B7A02DD21"
 f j=1:1:6 {
 s Key=""
 f i=2:2:$l(Keyi(j)) s Key=Key_$c($zh($e(Keyi(j),i-1,i)))
 s KEK=""
 f i=2:2:$l(KEKi(j)) s KEK=KEK_$c($zh($e(KEKi(j),i-1,i)))
 s Cipher=""
 f i=2:2:$l(Cipheri(j)) s Cipher=Cipher_$c($zh($e(Cipheri(j),i-1,i)))
 w !,!,$l(Key)," byte key, ",$l(KEK)," byte KEK"
 s Cipher2=$SYSTEM.Encryption.AESKeyWrap(Key, KEK)
 i Cipher2=Cipher w !,"Encrypted ciphertext matches expected ciphertext."
 else  w !,"Encryption error.",!,"Test failed!" q
 s Key2=$SYSTEM.Encryption.AESKeyUnwrap(Cipher2, KEK)
 if Key2=Key w !,"Decrypted key matches original key."
 else  w !,"Decryption error.",!,"Test failed!" q
 w !,"Test passed."
 }
 q
}
Base64Test() {
 w !,"RFC 3548 Base64 tests"
 s Binaryi(1)="14fb9c03d97e"
 s Binaryi(2)="14fb9c03d9"
 s Binaryi(3)="14fb9c03"
 s ASCII(1)="FPucA9l+"
 s ASCII(2)="FPucA9k="
 s ASCII(3)="FPucAw=="
 for j=1:1:3 {
	 s Binary=""
	 f i=2:2:$l(Binaryi(j)) s Binary=Binary_$c($zh($e(Binaryi(j),i-1,i)))
	 w !,!,"Original binary data:"
	 zzdump Binary
	 s ASCII2=$SYSTEM.Encryption.Base64Encode(Binary)
	 if ASCII2=ASCII(j) w !,"ASCII encoding matches expected encoding.",!,"Test passed."
	 else  w !,"Encoding error.",!,"Test failed!" q
	 s Binary2=$SYSTEM.Encryption.Base64Decode(ASCII2)
	 if Binary2=Binary w !,"Decoded binary data matches original binary data.",!,"Test passed."
	 else  w !,"Decoding error.",!,"Test failed!" q
 }
 q
}
HMACMD5test() {
 w !,"RFC 2104 HMAC-MD5 tests"
 s Text(1)="Hi There"
 s Text(2)="what do ya want for nothing?"
 s Texti(3)="DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD"
 s Keyi(1)="0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"
 s Key(2)="Jefe"
 s Keyi(3)="AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
 s HMACi(1)="9294727a3638bb1c13f48ef8158bfc9d" 
 s HMACi(2)="750c783e6ab0b503eaa86e310a5db738"
 s HMACi(3)="56be34521d144c88dbb8c733f0e8b3f6"
 for j=1:1:3 {
 if j<3 s Text=Text(j)
 else  s Text="" f i=2:2:$l(Texti(j)) s Text=Text_$c($zh($e(Texti(j),i-1,i)))
 if j=2 s Key=Key(j)
 else  s Key="" f i=2:2:$l(Keyi(j)) s Key=Key_$c($zh($e(Keyi(j),i-1,i)))
 s HMAC=""
 f i=2:2:$l(HMACi(j)) s HMAC=HMAC_$c($zh($e(HMACi(j),i-1,i)))
 s HMAC2=$System.Encryption.HMACMD5(Text,Key)
 w !,!,"Text:  "
 if j<3 w Text
 else  zzdump Text
 w !,$l(Key)," byte key:  "
 if j=2 w Key
 else  zzdump Key
 if HMAC2=HMAC w !,"Generated HMAC matches expected HMAC.",!,"Test passed."
 else  w !,"HMAC error.",!,"Test failed!" q
 }
 q
}
HMACSHA1test() {
 w !,"FIPS 198 HMAC-SHA-1 tests"
 s Text(1)="Sample #1"
 s Text(2)="Sample #2"
 s Text(3)="Sample #3"
 s Text(4)="Sample #4"
 s Keyi(1)=""
 s Keyi(1)=Keyi(1)_"000102030405060708090a0b0c0d0e0f"
 s Keyi(1)=Keyi(1)_"101112131415161718191a1b1c1d1e1f"
 s Keyi(1)=Keyi(1)_"202122232425262728292a2b2c2d2e2f"
 s Keyi(1)=Keyi(1)_"303132333435363738393a3b3c3d3e3f"
 s Keyi(2)=""
 s Keyi(2)=Keyi(2)_"303132333435363738393a3b3c3d3e3f"
 s Keyi(2)=Keyi(2)_"40414243"
 s Keyi(3)=""
 s Keyi(3)=Keyi(3)_"505152535455565758595a5b5c5d5e5f"
 s Keyi(3)=Keyi(3)_"606162636465666768696a6b6c6d6e6f"
 s Keyi(3)=Keyi(3)_"707172737475767778797a7b7c7d7e7f"
 s Keyi(3)=Keyi(3)_"808182838485868788898a8b8c8d8e8f"
 s Keyi(3)=Keyi(3)_"909192939495969798999a9b9c9d9e9f"
 s Keyi(3)=Keyi(3)_"a0a1a2a3a4a5a6a7a8a9aaabacadaeaf"
 s Keyi(3)=Keyi(3)_"b0b1b2b3"
 s Keyi(4)=""
 s Keyi(4)=Keyi(4)_"707172737475767778797a7b7c7d7e7f"
 s Keyi(4)=Keyi(4)_"808182838485868788898a8b8c8d8e8f"
 s Keyi(4)=Keyi(4)_"909192939495969798999a9b9c9d9e9f"
 s Keyi(4)=Keyi(4)_"a0"
 s HMACi(1)="4f4ca3d5d68ba7cc0a1208c9c61e9c5da0403c0a" 
 s HMACi(2)="0922d3405faa3d194f82a45830737d5cc6c75d24"
 s HMACi(3)="bcf41eab8bb2d802f3d05caf7cb092ecf8d1a3aa"
 s HMACi(4)="9ea886efe268dbecce420c7524df32e0751a2a26"
 for j=1:1:4 {
 s Key=""
 f i=2:2:$l(Keyi(j)) s Key=Key_$c($zh($e(Keyi(j),i-1,i)))
 s HMAC=""
 f i=2:2:$l(HMACi(j)) s HMAC=HMAC_$c($zh($e(HMACi(j),i-1,i)))
 s HMAC2=$System.Encryption.HMACSHA1(Text(j),Key)
 w !,!,"Text:  ",Text(j)
 w !,$l(Key)," byte key:"
 zzdump Key
 if HMAC2=HMAC w !,"Generated HMAC matches expected HMAC.",!,"Test passed."
 else  w !,"HMAC error.",!,"Test failed!" q
 }
 q
}
HMACSHAtest() PUBLIC {
 w !,"RFC 2202/4231 HMAC-SHA tests"
 w !,"Available hash sizes (in bits):  160, 224, 256, 384, 512"
 w !,"Enter size: "
 r size
 s Text(1)="Hi There"
 s Text(2)="what do ya want for nothing?"
 s Texti(3)="dddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd"
 s Texti(4)="cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd"
 s Text(5)="Test With Truncation"
 s Text(6)="Test Using Larger Than Block-Size Key - Hash Key First"
 s Text(7)="This is a test using a larger than block-size key and a larger than block-size data. The key needs to be hashed before being used by the HMAC algorithm."
 s Keyi(1)="0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"
 s Key(2)="Jefe"
 s Keyi(3)="aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 s Keyi(4)="0102030405060708090a0b0c0d0e0f10111213141516171819"
 s Keyi(5)="0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c"
 s Keyi(6)=""
 s Keyi(6)=Keyi(6)_"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 s Keyi(6)=Keyi(6)_"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 s Keyi(6)=Keyi(6)_"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 s Keyi(6)=Keyi(6)_"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 s Keyi(6)=Keyi(6)_"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 s Keyi(6)=Keyi(6)_"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 s Keyi(6)=Keyi(6)_"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 s Keyi(6)=Keyi(6)_"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 s Keyi(6)=Keyi(6)_"aaaaaa"
 s Keyi(7)=Keyi(6)
 if (size=160) {
	s Text(7)="Test Using Larger Than Block-Size Key and Larger Than One Block-Size Data"
	s Keyi(6)=$e(Keyi(6),1,160)
	s Keyi(7)=$e(Keyi(7),1,160)
	s HMACi(1)="b617318655057264e28bc0b6fb378c8ef146be00"
	s HMACi(2)="effcdf6ae5eb2fa2d27416d5f184df9c259a7c79"
	s HMACi(3)="125d7342b9ac11cd91a39af48aa17b4f63f175d3"
	s HMACi(4)="4c9007f4026250c6bc8414f9bf50c86c2d7235da"
	s HMACi(5)="4c1a03424b55e07fe7f27be1d58bb932"
	s HMACi(6)="aa4ae5e15272d00e95705637ce8a3b55ed402112"
	s HMACi(7)="e8e99d0f45237d786d6bbaa7965c7808bbff1a91"
 } elseif (size=224) {
	s HMACi(1)="896fb1128abbdf196832107cd49df33f47b4b1169912ba4f53684b22"
	s HMACi(2)="a30e01098bc6dbbf45690f3a7e9e6d0f8bbea2a39e6148008fd05e44"
	s HMACi(3)="7fb3cb3588c6c1f6ffa9694d7d6ad2649365b0c1f65d69d1ec8333ea"
	s HMACi(4)="6c11506874013cac6a2abc1bb382627cec6a90d86efc012de7afec5a"
	s HMACi(5)="0e2aea68a90c8d37c988bcdb9fca6fa8"
	s HMACi(6)="95e9a0db962095adaebe9b2d6f0dbce2d499f112f2d2b7273fa6870e"
	s HMACi(7)="3a854166ac5d9f023f54d517d0b39dbd946770db9c2b95c9f6f565d1"
 } elseif (size=256) {
	s HMACi(1)="b0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7"
 	s HMACi(2)="5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843"
	s HMACi(3)="773ea91e36800e46854db8ebd09181a72959098b3ef8c122d9635514ced565fe"
	s HMACi(4)="82558a389a443c0ea4cc819899f2083a85f0faa3e578f8077a2e3ff46729665b"
	s HMACi(5)="a3b6167473100ee06e0c796c2955552b"
	s HMACi(6)="60e431591ee0b67f0d8a26aacbf5b77f8e0bc6213728c5140546040f0ee37f54"
	s HMACi(7)="9b09ffa71b942fcb27635fbcd5b0e944bfdc63644f0713938a7f51535c3a35e2"
 } elseif (size=384) {
	s HMACi(1)="afd03944d84895626b0825f4ab46907f15f9dadbe4101ec682aa034c7cebc59cfaea9ea9076ede7f4af152e8b2fa9cb6"
 	s HMACi(2)="af45d2e376484031617f78d2b58a6b1b9c7ef464f5a01b47e42ec3736322445e8e2240ca5e69e2c78b3239ecfab21649"
	s HMACi(3)="88062608d3e6ad8a0aa2ace014c8a86f0aa635d947ac9febe83ef4e55966144b2a5ab39dc13814b94e3ab6e101a34f27"
	s HMACi(4)="3e8a69b7783c25851933ab6290af6ca77a9981480850009cc5577c6e1f573b4e6801dd23c4a7d679ccf8a386c674cffb"
	s HMACi(5)="3abf34c3503b2a23a46efc619baef897"
	s HMACi(6)="4ece084485813e9088d2c63a041bc5b44f9ef1012a2b588f3cd11f05033ac4c60c2ef6ab4030fe8296248df163f44952"
	s HMACi(7)="6617178e941f020d351e2f254e8fd32c602420feb0b8fb9adccebb82461e99c5a678cc31e799176d3860e6110c46523e"
 } elseif (size=512) {
 	s HMACi(1)="87aa7cdea5ef619d4ff0b4241a1d6cb02379f4e2ce4ec2787ad0b30545e17cdedaa833b7d6b8a702038b274eaea3f4e4be9d914eeb61f1702e696c203a126854"
	s HMACi(2)="164b7a7bfcf819e2e395fbe73b56e0a387bd64222e831fd610270cd7ea2505549758bf75c05a994a6d034f65f8f0e6fdcaeab1a34d4a6b4b636e070a38bce737"
	s HMACi(3)="fa73b0089d56a284efb0f0756c890be9b1b5dbdd8ee81a3655f83e33b2279d39bf3e848279a722c806b485a47e67c807b946a337bee8942674278859e13292fb"
	s HMACi(4)="b0ba465637458c6990e5a8c5f61d4af7e576d97ff94b872de76f8050361ee3dba91ca5c11aa25eb4d679275cc5788063a5f19741120c4f2de2adebeb10a298dd"
	s HMACi(5)="415fad6271580a531d4179bc891d87a6"
	s HMACi(6)="80b24263c7c1a3ebb71493c1dd7be8b49b46d1f41b4aeec1121b013783f8f3526b56d037e05f2598bd0fd2215d6a1e5295e64f73f63f0aec8b915a985d786598"
	s HMACi(7)="e37b6a775dc87dbaa4dfa9f96e5e3ffddebd71f8867289865df5a32d20cdc944b6022cac3c4982b10d5eeb55c3e4de15134676fb6de0446065c97440fa8c6a58"
 } else {
	w !,"Not supported."
	q
 }
 for j=1:1:7 {
 if ((j<3)||(j>4)) s Text=Text(j)
 else  s Text="" f i=2:2:$l(Texti(j)) s Text=Text_$c($zh($e(Texti(j),i-1,i)))
 if j=2 s Key=Key(j)
 else  s Key="" f i=2:2:$l(Keyi(j)) s Key=Key_$c($zh($e(Keyi(j),i-1,i)))
 s HMAC=""
 f i=2:2:$l(HMACi(j)) s HMAC=HMAC_$c($zh($e(HMACi(j),i-1,i)))
 s HMAC2=$System.Encryption.HMACSHA(size,Text,Key)
 if j=5 s HMAC2=$e(HMAC2,1,16)
 w !,!,"Text:  "
 if ((j<3)||(j>4)) w Text
 else  zzdump Text
 w !,$l(Key)," byte key:  "
 if j=2 w Key
 else  zzdump Key
 if HMAC2=HMAC w !,"Generated HMAC matches expected HMAC.",!,"Test passed."
 else  w !,"HMAC error.",!,"Test failed!" q
 }
 q
}
MD5test() PUBLIC {
 w !,"RFC 1321 MD5 tests"
 s Text(1)=""
 s Text(2)="a"
 s Text(3)="abc"
 s Text(4)="message digest"
 s Text(5)="abcdefghijklmnopqrstuvwxyz"
 s Text(6)="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
 s Text(7)="12345678901234567890123456789012345678901234567890123456789012345678901234567890"
 s Hashi(1)="d41d8cd98f00b204e9800998ecf8427e"
 s Hashi(2)="0cc175b9c0f1b6a831c399e269772661"
 s Hashi(3)="900150983cd24fb0d6963f7d28e17f72"
 s Hashi(4)="f96b697d7cb7938d525a2f31aaf161d0"
 s Hashi(5)="c3fcd3d76192e4007dfb496cca67e13b"
 s Hashi(6)="d174ab98d277d9f5a5611c2c9f419d9f"
 s Hashi(7)="57edf4a22be3c955ac49da2e2107b67a"
 for j=1:1:7 {
 s Hash=""
 f i=2:2:$l(Hashi(j)) s Hash=Hash_$c($zh($e(Hashi(j),i-1,i)))
 s Hash2=$System.Encryption.MD5Hash(Text(j))
 w !,!,"Text:  ",Text(j)
 i Hash2=Hash w !,"Generated hash matches expected hash.",!,"Test passed."
 else  w !,"Hashing error.",!,"Test failed!" q
 }
 k str
 q
}
PBKDF2test() PUBLIC {
 w !,"RFC 6070 PBKDF2-HMAC-SHA tests"
 w !,"Available hash sizes (in bits):  160, 256, 512"
 w !,"Enter size: "
 r size
 s Passphrase(1)="password"
 s Passphrase(2)="password"
 s Passphrase(3)="password"
 s Passphrase(4)="password"
 s Passphrase(5)="passwordPASSWORDpassword"
 s Passphrase(6)="pass"_$c(0)_"word"
 s Salt(1)="salt"
 s Salt(2)="salt"
 s Salt(3)="salt"
 s Salt(4)="salt"
 s Salt(5)="saltSALTsaltSALTsaltSALTsaltSALTsalt"
 s Salt(6)="sa"_$c(0)_"lt"
 s Iterations(1)=1
 s Iterations(2)=2
 s Iterations(3)=4096
 s Iterations(4)=16777216
 s Iterations(5)=4096
 s Iterations(6)=4096
 if (size=160) {
	 s Keylen(1)=20
	 s Keylen(2)=20
	 s Keylen(3)=20
	 s Keylen(4)=0
	 s Keylen(5)=25
	 s Keylen(6)=16
	 s Keyi(1)="0c60c80f961f0e71f3a9b524af6012062fe037a6"
	 s Keyi(2)="ea6c014dc72d6f8ccd1ed92ace1d41f0d8de8957"
	 s Keyi(3)="4b007901b765489abead49d926f721d065a429c1"
	 s Keyi(4)="eefe3d61cd4da4e4e9945b3d6ba2158c2634e984"
	 s Keyi(5)="3d2eec4fe41c849b80c8d83662c0e44a8b291a964cf2f07038"
	 s Keyi(6)="56fa6aa75548099dcc37d7f03425e0c3"
 } elseif (size=256) {
	 s Keylen(1)=32
	 s Keylen(2)=32
	 s Keylen(3)=32
	 s Keylen(4)=0
	 s Keylen(5)=40
	 s Keylen(6)=16
	 s Keyi(1)="120fb6cffcf8b32c43e7225256c4f837a86548c92ccc35480805987cb70be17b"
	 s Keyi(2)="ae4d0c95af6b46d32d0adff928f06dd02a303f8ef3c251dfd6e2d85a95474c43"
	 s Keyi(3)="c5e478d59288c841aa530db6845c4c8d962893a001ce4e11a4963873aa98134a"
	 s Keyi(4)="cf81c66fe8cfc04d1f31ecb65dab4089f7f179e89b3b0bcb17ad10e3ac6eba46"
	 s Keyi(5)="348c89dbcbd32b2f32d814b8116e84cf2b17347ebc1800181c4e2a1fb8dd53e1c635518c7dac47e9"
	 s Keyi(6)="89b69d0516f829893c696226650a8687"
 } elseif (size=512) {
	 s Keylen(1)=64
	 s Keylen(2)=64
	 s Keylen(3)=64
	 s Keylen(4)=0
	 s Keylen(5)=64
	 s Keylen(6)=0
	 s Keyi(1)="867f70cf1ade02cff3752599a3a53dc4af34c7a669815ae5d513554e1c8cf252c02d470a285a0501bad999bfe943c08f050235d7d68b1da55e63f73b60a57fce"
	 s Keyi(2)="e1d9c16aa681708a45f5c7c4e215ceb66e011a2e9f0040713f18aefdb866d53cf76cab2868a39b9f7840edce4fef5a82be67335c77a6068e04112754f27ccf4e"
	 s Keyi(3)="d197b1b33db0143e018b12f3d1d1479e6cdebdcc97c5c0f87f6902e072f457b5143f30602641b3d55cd335988cb36b84376060ecd532e039b742a239434af2d5"
	 s Keyi(5)="8c0511f4c6e597c6ac6315d8f0362e225f3c501495ba23b868c005174dc4ee71115b59f9e60cd9532fa33e0f75aefe30225c583a186cd82bd4daea9724a3d3b8"
 } else {
 	w !,"Not supported."
 	q
 }
 for j=1:1:6 {
 i 'Keylen(j) continue
 s Key=""
 f i=2:2:$l(Keyi(j)) s Key=Key_$c($zh($e(Keyi(j),i-1,i)))
 w !,!,"Passphrase:  ",Passphrase(j)
 w !,"Iterations:  ",Iterations(j)
 w !,"Salt:  ", Salt(j)
 w !,"Key length:  ",Keylen(j)
 s Key2=$System.Encryption.PBKDF2(Passphrase(j),Iterations(j),Salt(j),Keylen(j),size)
 if Key2=Key w !,"Derived key matches expected key.",!,"Test passed."
 else  w !,"Key derivation error.",!,"Test failed!" q
 }
 q
}
SHA1test() PUBLIC {
 w !,"FIPS 180-2 SHA-1 tests"
 s Text(1)="abc"
 s Text(2)="abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"
 s line=$tr($j("",10000)," ","a")
 s str=##class(%Library.GlobalCharacterStream).%New()
 f i=1:1:100 d str.Write(line)
 s Hashi(1)="a9993e364706816aba3e25717850c26c9cd0d89d"
 s Hashi(2)="84983e441c3bd26ebaae4aa1f95129e5e54670f1"
 s Hashi(3)="34aa973cd4c4daa4f61eeb2bdbad27316534016f"
 for j=1:1:3 {
 s Hash=""
 f i=2:2:$l(Hashi(j)) s Hash=Hash_$c($zh($e(Hashi(j),i-1,i)))
 i j<3 s Hash2=$System.Encryption.SHA1Hash(Text(j))
 else  s Hash2=$System.Encryption.SHA1HashStream(str)
 i j<3 w !,!,"Text:  ",Text(j)
 else  w !,!,"Text is a string consisting of 1,000,000 repetitions of the character ""a""."
 i Hash2=Hash w !,"Generated hash matches expected hash.",!,"Test passed."
 else  w !,"Hashing error.",!,"Test failed!" q
 }
 k str
 q
}
SHAtest() PUBLIC {
 w !,"FIPS 180-2 SHA tests"
 w !,"Available hash sizes (in bits):  160, 224, 256, 384, 512"
 w !,"Enter size: "
 r size
 s Text(1)="abc"
 s line=$tr($j("",10000)," ","a")
 s str=##class(%Library.GlobalCharacterStream).%New()
 f i=1:1:100 d str.Write(line)
 if (size=160) {
	s Text(2)="abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"
	s Hashi(1)="a9993e364706816aba3e25717850c26c9cd0d89d"
	s Hashi(2)="84983e441c3bd26ebaae4aa1f95129e5e54670f1"
	s Hashi(3)="34aa973cd4c4daa4f61eeb2bdbad27316534016f"
 } elseif (size=224) {
	s Text(2)="abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"
	s Hashi(1)="23097d223405d8228642a477bda255b32aadbce4bda0b3f7e36c9da7"
	s Hashi(2)="75388b16512776cc5dba5da1fd890150b0c6455cb4f58b1952522525"
	s Hashi(3)="20794655980c91d8bbb4c1ea97618a4bf03f42581948b2ee4ee7ad67"
 } elseif (size=256) {
	s Text(2)="abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"
	s Hashi(1)="ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"
	s Hashi(2)="248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1"
	s Hashi(3)="cdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0"
 } elseif (size=384) {
	s Text(2)="abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn"
	s Text(2)=Text(2)_"hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu"
	s Hashi(1)="cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed"
	s Hashi(1)=Hashi(1)_"8086072ba1e7cc2358baeca134c825a7"
	s Hashi(2)="09330c33f71147e83d192fc782cd1b4753111b173b3b05d22fa08086e3b0f712"
	s Hashi(2)=Hashi(2)_"fcc7c71a557e2db966c3e9fa91746039"
	s Hashi(3)="9d0e1809716474cb086e834e310a4a1ced149e9c00f248527972cec5704c2a5b"
	s Hashi(3)=Hashi(3)_"07b8b3dc38ecc4ebae97ddd87f3d8985"
 } elseif (size=512) {
	s Text(2)="abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn"
	s Text(2)=Text(2)_"hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu"
	s Hashi(1)="ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a"
	s Hashi(1)=Hashi(1)_"2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f"
	s Hashi(2)="8e959b75dae313da8cf4f72814fc143f8f7779c6eb9f7fa17299aeadb6889018"
	s Hashi(2)=Hashi(2)_"501d289e4900f7e4331b99dec4b5433ac7d329eeb6dd26545e96e55b874be909"
	s Hashi(3)="e718483d0ce769644e2e42c7bc15b4638e1f98b13b2044285632a803afa973eb"
	s Hashi(3)=Hashi(3)_"de0ff244877ea60a4cb0432ce577c31beb009c5c2c49aa2e4eadb217ad8cc09b"
 } else {
	w !,"Not supported."
	q
 }
 for j=1:1:3 {
 s Hash=""
 f i=2:2:$l(Hashi(j)) s Hash=Hash_$c($zh($e(Hashi(j),i-1,i)))
 i j<3 s Hash2=$System.Encryption.SHAHash(size,Text(j))
 else  s Hash2=$System.Encryption.SHAHashStream(size,str)
 i j<3 w !,!,"Text:  ",Text(j)
 else  w !,!,"Text is a string consisting of 1,000,000 repetitions of the character ""a""."
 i Hash2=Hash w !,"Generated hash matches expected hash.",!,"Test passed."
 else  w !,"Hashing error.",!,"Test failed!" q
 }
 k str
 q
}

DATABASE^INT^1^67214,47330
DATABASE ; Manage databases ; ;$Change: 7440104 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	; Revision: $Id: //iris/2024.1.3/databases/sys/rtn/user/database.mac#1 $
 d MENU()
 q
EMSClient()	PRIVATE {
	q 0
	;q ##class(EMS.Instance).IsManaged("Config.Databases")
	;Q ##class(EMS.Clients).IsSubscribedTo($$$EMSDatabasesBit)
}
EMSEditText() PRIVATE {
	;i ##class(EMS.Instance).IsManaged("Config.Databases") q " (restricted)"
	;i ##class(EMS.Clients).IsSubscribedTo($$$EMSDatabasesBit) q " (restricted)"
	q ""
}
NotAvailableOnVMS() PRIVATE {
   quit ""
}
MENU() PUBLIC { 
 s $zt="ERROR"
 s List(1)="Create a database"_$$EMSEditText
 s List(2)="Edit a database"
 s List(3)="List databases"
 s List(4)="Delete a database"_$$EMSEditText
 s List(5)="Mount a database"
 s List(6)="Dismount a database"
 s List(7)="Compact globals in a database"
 s List(8)="Show free space for a database"
 s List(9)="Show details for a database"
 s List(10)="Recreate a database"
 s List(11)="Manage database encryption"
 s List(12)="Return unused space for a database"_$$NotAvailableOnVMS()
 s List(13)="Compact free space in a database"_$$NotAvailableOnVMS()
 s List(14)="Defragment a database"_$$NotAvailableOnVMS()
 s List(15)="Show background database tasks"
 s List(16)="Manage multi-volume database properties"
 f  {
 	s Value=""
	s Status=##Class(%Library.Prompt).GetMenu("Option?",.Value,.List,,8+128+4)
 	i (+Status=0)||(Status=2)||(Value="") q
 	i Value=1,'$$EMSClient d CREATE() Continue
 	i Value=2 d EDIT() Continue
 	i Value=3 d LIST() Continue
 	i Value=4,'$$EMSClient d DELETE() Continue
	i Value=5 d MOUNT() Continue
	i Value=6 d DISMOUNT() Continue
	i Value=7 d COMPACT() Continue
	i Value=8 d FREECOUNT() Continue
	i Value=9 d DETAIL() Continue
	i Value=10 d RECREATE() Continue
	i Value=11 d DBEncKey() Continue
	i Value=12 d DBTruncat() Continue
	i Value=13 d FileCompact() Continue
	i Value=14 d DEFRAG() Continue
	i Value=15 d BGLIST() Continue
	i Value=16 d MULTIVOL() Continue
 }
 q Status
ERROR s $zt=""
 i $ze["<INTERRUPT>" q 0
 ztrap $ze
}
CREATE() PUBLIC {
 s $zt="ERROR"
 i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q 1
 f  {
	s Value=""
	i $$IsMaxDBMounted^%SYS.DATABASE() w !,"The mounted database count exceeds license limit." S Status=0 q
	s Flag=8+16384+512+65536+131072
 	s Status=##class(SYS.Database).GetDirectory("Database directory?",.Value,.Obj,,,,.Flag)
 	s DBExist=($zb(Flag,65536,1)=0)
 	i (+Status=0)||(Status=2)||(Value="") q
	s OrigSize=Obj.Size
	f  {
 		s Value=0
 		s Status=##Class(%Library.Prompt).GetYesNo("Change default database properties?",.Value,,8)
 		i (Status=2)||(+Status=0) q
 		i Value=1 {
	 		if 'DBExist {
		 		s v=""
		 		d ##class(SYS.MirrorConfiguration).GetAndCheckMirrorSetName(.v)
		 		s Obj.MirrorSetName=v
	 		}
	 		s Status=##Class(%Library.Prompt).EditFields(.Obj,$s(DBExist:1,1:0))
 			i (+Status=0)||(Status=2) q
 			if OrigSize'=Obj.Size {
	 			s Status=##Class(%Library.File).GetDirectorySpace(Obj.Directory,.FreeSpace,.TotalSpace)
	 			if ('Status) {
		 			w !,"Failed to get available disk space for ",Obj.Directory
		 			s Status=2
		 			quit
	 			}
	 			if (Obj.Size-OrigSize)>=FreeSpace {
		 			w !,"Database is NOT created, size increase ",Obj.Size-OrigSize," MB is greater than total available disk space ",FreeSpace," MB."
		 			s Status=2
		 			quit
	 			}
	 			if (Obj.Size-OrigSize)>(FreeSpace*90/100) {
		 			w !,"Warning! The requested size increase ",Obj.Size-OrigSize," MB is greater than 90% of available disk space (",FreeSpace," MB)."
		 			w !,"Are you sure you want to create the database with ",Obj.Size," MB? <Y>"
		 			r resp
		 			if ("Nn"[$E(resp_"X")) {
			 			s Status=2
			 			quit
		 			}
	 			}
 			}
 		}
	 	f  {
	 		s DBName=""
			s Status=##Class(%Library.Prompt).GetString("Dataset name of this database in the configuration:",.DBName,0,32,,8)
			i (+Status=0)!(+Status=2)!(DBName="") q
			s DBName=$zcvt(DBName,"U")
			i ##Class(Config.Databases).Exists(DBName,.DBObj){
				i DBObj.Directory=Obj.Directory {
					s DBObjExists=1
				} else {
					 w !,"Dataset ",DBName_" already exists in the current configuration."
					 Continue
				}
			} else {
				s DBObjExists=0
			}
			s Status=1 q
		}
		k cfg
		i (Status=2)!(DBName="") q
		i (+Status=0) q
 		s MountRequired=0
 		s Status=##Class(%Library.Prompt).GetYesNo("Mount "_DBName_" Required At Startup?",.MountRequired,,8)
 		i (+Status=0)!(Status=2) q
 		s MountAtStartup=0
 		if $S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0)&&Obj.ClusterMountMode&&(MountRequired=0) {
 			s Status=##Class(%Library.Prompt).GetYesNo("Cluster Mount "_DBName_" At Startup?",.MountAtStartup,,8)
 			i (+Status=0)!(Status=2) q
 		}
 		s Value=1
 		s Status=##Class(%Library.Prompt).GetYesNo("Confirm creation of database in "_Obj.Directory_"?",.Value,,8)
		i (Status=2) Continue
 		i (+Status=0) q
 		i Value {
			s jrnenc=$$AskJrnEncOnNewDB(Obj)
			s RequestedSize=Obj.Size
 			W:'DBExist !,"Formatting..." Hang 0
			s Status=Obj.%Save()
			i ('Status) {
				w ! d $SYSTEM.Status.DisplayError(Status) w !
			} else {
				i jrnenc {
					s rc=##class(%SYS.Journal.System).ActivateEncryption()
					i ('rc) w ! d $SYSTEM.Status.DisplayError(rc) w !
				}
				w:'DBExist !,"Database in "_Obj.Directory_" created"
				s CreatedSize=$p($zu(49,Obj.Directory),",",4)
 				i CreatedSize < RequestedSize s display=$SYSTEM.Status.GetErrorText($$Error^%apiOBJ(353,Obj.Directory,CreatedSize,RequestedSize)) w !,$p(display,":",2,$l(display,":")),!
				s not="",sc=1
				i 'DBObjExists {
					s Prop("Directory")=Obj.Directory
					s Prop("MountAtStartup")=MountAtStartup
					s Prop("ClusterMountMode")=Obj.ClusterMountMode
					s Prop("MountRequired")=MountRequired
					s sc=##Class(Config.Databases).Create(DBName,.Prop)
					i ('sc) {
						s not=" NOT"
						s sc=$SYSTEM.Status.GetErrorText(sc),err=$p(sc,": "),sc=$p(sc,": ",2,99)
						s sc=$p(sc," ["),err=$p(err,"#",2)
						i err=646 s not=""
					}
				}
				w !,"Dataset ",DBName,not," added to the current configuration."
				i '(''sc) w !,sc
	 		}
 		}
		s Status=1
 		q
	}
	k Obj
 }
 q Status
ERROR s $zt=""
 i $ze["<INTERRUPT>" q 0
 ztrap $ZE
}
EDIT() PUBLIC {
 s $zt="ERROR"
 i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q 1
 f  {
	s Value=""
	s Flag=8+8192+512
 	s Status=##class(SYS.Database).GetDirectory("Database directory?",.Value,.Obj,,,,Flag)
 	i (+Status=0)||(Status=2)||(Value="") q
 	i Obj.Mounted=0 w !!,"Database is not mounted, please re-enter",! Continue
	s OriginalROnly=Obj.ReadOnly
	s OriginalSize=Obj.Size
	s oClusterMountMode=Obj.ClusterMountMode
	f  {
		s RequestedSize=0
 		s Status=##Class(%Library.Prompt).EditFields(.Obj,2)
		i Obj.Size>OriginalSize {
			s RequestedSize=Obj.Size
 			s Status=##Class(%Library.File).GetDirectorySpace(Obj.Directory,.FreeSpace,.TotalSpace)
 			if ('Status) {
	 			w !,"Failed to get available disk space for ",Obj.Directory
	 			s Status=0
	 			quit
 			}
	 		if (Obj.Size-OriginalSize)>=FreeSpace {
	 			w !,"Database is NOT modified, size increase ",Obj.Size-OriginalSize," MB is greater than total available disk space ",FreeSpace," MB."
	 			s Status=0
	 			quit
 			}
 			if (Obj.Size-OriginalSize)>(FreeSpace*90/100) {
	 			w !,"Warning! The requested size increase ",Obj.Size-OriginalSize," MB is greater than 90% of available disk space (",FreeSpace," MB)."
	 			w !,"Are you sure you want to modify the database with ",Obj.Size," MB? <Y>"
	 			r resp
	 			if ("Nn"[$E(resp_"X")) {
		 			s Status=0
		 			quit
	 			}
 			}
		}
		s ClusterMountMode=Obj.ClusterMountMode
		i (+Status=0)||(Status=2) q
 		s Value=1
		i Obj.%IsModified()=0 q  
 		s Status=##Class(%Library.Prompt).GetYesNo("Confirm update of database "_Obj.Directory_"?",.Value,,8)
		i (Status=2) Continue
 		i (+Status=0) q
 		i Value {
 			W !,"Updating..." Hang 0
			s Status=Obj.%Save()
			i ('Status) {
				w ! d $SYSTEM.Status.DisplayError(Status) w !
			} else {
				i '$$ModWait() {
					w !,"There was a problem expanding the database."
				} else {
					w !,"Database "_Obj.Directory_" updated"
				}
				i $g(RequestedSize,0) {
					s NewSize=$p($zu(49,Obj.Directory),",",4)
					i NewSize < RequestedSize w ! s display=$SYSTEM.Status.GetErrorText($$Error^%apiOBJ(394,Obj.Directory,NewSize,RequestedSize)) w $p(display,":",2,$l(display,":")) w !
				}
				if OriginalROnly,'Obj.ReadOnly,Obj.Mirrored {
					do AskResetMirroredDB^MIRROR(Obj)
				}
	 		}
 		}
 		s Status=1
 		q
	}
	i +Status=0 q
	s DBlist=""
	s Status=$$DatasetsByDirectory^%SYS.CONFIG("",Obj.Directory,.DBlist)
	i (''Status)&&(DBlist]"") {
 		s modified=(ClusterMountMode'=oClusterMountMode)
		for i=1:1:$listlength(DBlist) {
			s dbn=$li(DBlist,i)
			i '##Class(Config.Databases).Exists(dbn,.dobj) continue
			s MR=dobj.MountRequired
			i '$$EMSClient {
	 			s Status=##Class(%Library.Prompt).GetYesNo("Mount "_dbn_" Required At Startup?",.MR,,8)
	 			i (+Status=0)!(Status=2) q
	 			if MR'=dobj.MountRequired {
						s dobj.MountRequired=MR
						s modified=1
	 			}
			}
			if $S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0) {
				if ('ClusterMountMode)||MR {
					s MS=$s('ClusterMountMode:0,1:dobj.MountAtStartup)
				} else {
				s MS=dobj.MountAtStartup
 				s Status=##Class(%Library.Prompt).GetYesNo("Cluster Mount "_dbn_" At Startup?",.MS,,8)
 				i (+Status=0)!(Status=2) q
				}
 				if MS'=dobj.MountAtStartup {
					s dobj.MountAtStartup=MS
					s modified=1
 				}
				s dobj.ClusterMountMode=ClusterMountMode
			}
 			i modified {
	 			s sc=dobj.%Save()
	 			i '(''sc) w ! d $SYSTEM.Status.DisplayError(sc) w !
 			}
			k dobj
		}
	}
	k Obj
 }
 q Status
ERROR s $zt=""
 i $ze["<INTERRUPT>" q 0
 ztrap $ZE
}
ModWait() PUBLIC {
 ;wait while database is being modified 
 s $ZT="ModW2"
 s X=$ZU(40,2,46)
 f  s V=$V(X,-2,"1A") q:V'=1  h 1 ;continue until not 'running'
 i V=2 q 0
ModW2 s $ZT=""
 i $G(X) d
 . V X:-2:1:0 ;reset internal flag so others can use it
 . I $V(X,-2,1)=2 V X:-2:1:0
 q 1 ;having an error really doesn't mean anything
}
SilentModWait(Modified,NewName,DBName,Directory,Server,MountAtStartup,ClusterMountMode,MountRequired) PUBLIC {
 ;wait while database is being modified 
 if '$$ModWait() q 1 ; terminate if failed to expand the DB.
 s rc=1
 if Modified {
	 s Prop("Server")=Server
	 s Prop("MountAtStartup")=MountAtStartup
	 s Prop("ClusterMountMode")=ClusterMountMode
	 s Prop("MountRequired")=MountRequired
	 if (Directory'="") {
		 s Prop("Directory")=Directory
		 Set rc=##class(Config.Databases).Modify(DBName,.Prop)
	 } else {
		 Set rc=##class(Config.Databases).Modify(DBName,.Prop)
	 }
 }
 if '('rc),NewName'=DBName {
	 ;STCxxx^^^fix this to use logic from config.datastorage.RenameDatabaseEx
	 s rc=##Class(Config.Databases).Get(DBName,.Prop)
	 s rc=##Class(Config.Databases).Create(NewName,.Prop)
	 s rc=##Class(Config.Databases).Delete(DBName)
 }
 q rc
}
LIST() PUBLIC {
 s $zt="ERROR"
 f  {
	s Value=""
 	s Flag=8+512+1024+8192
 	s Status=##class(SYS.Database).GetDirectory("Database directories?",.Value,,,,,Flag)
 	q:(Value="")||(+Status=0)||(Status=2)
 	s IO=""
  	s Status=##class(%Library.Device).Get("Device:",.IO,,8,,4,.IOSL,.IOM,.IOF)
 	Continue:(Status=2)
 	q:(+Status=0)
	Set Rset = ##class(%Library.ResultSet).%New("SYS.Database:List")
	d Rset.Execute(Value,1)  ;1 means include volume info
 	u IO
 	w !!,Rset.GetColumnName(1),?40,Rset.GetColumnName(2),?51,Rset.GetColumnName(3),?62,Rset.GetColumnName(4)
 	While (Rset.Next()) {
		w !,Rset.Get("Directory")
		i $x>39 w !
		w ?40,Rset.Get("MaxSize")
		w ?51,Rset.Get("Size")
		w ?62,Rset.Get("Status")
 	}
 	w !
	c:IO'=$P IO
 }
 q
ERROR s $zt=""
 i $d(IO),(IO'="") c:IO'=$P IO
 i $ze["<INTERRUPT>" q 0
 ztrap $ZE
}
DELETE() PUBLIC {
 s $zt="ERROR"
 i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q 1
 f  {
	s Value=""
	s Flag=8+8192+512+32768
 	s Status=##class(SYS.Database).GetDirectory("Database directory?",.Value,.Obj,,,,Flag)
 	i (+Status=0)||(Status=2)||(Value="") q
	if Obj=0 {
		s Directory=Value
	} else {
		s Directory=Obj.Directory
		if ##class(SYS.Database).IsSystemDB(Directory) {
	 		w !!,*7,"Deleting System Database "_Directory_" is not allowed!",!
	 		k Obj
	 		Continue
		}
		if Obj.Mirrored {
	 		w !!,*7,"Deleting Mirror Database "_Directory_" is not allowed!",!
	 		k Obj
	 		Continue
		}
	}
	f  {
 		s rs=##class(%Library.ResultSet).%New("Config.Databases:List")
 		d rs.Execute()
 		s dblist="",nsplist="",ndir=##class(%Library.File).ComputeFullDBDir(Directory)
 		while (rs.Next()) {
	 		s d=##class(%Library.File).ComputeFullDBDir(rs.Data("Directory"))
	 		i ndir=d&&(rs.Data("Server")="") {
				s DBName=rs.Data("Name")
				k mappings s mappings=1
				s rc=##class(Config.Databases).SynonymDBs(DBName,.dblist)
				s rc=##class(Config.Namespaces).NamespacesByDB(DBName,.nsplist,1,.mappings)
				q
	 		}
 		}
 		i dblist]"" {
	 		w !,"Directory "_Directory_" is referenced in the configuration file by"
	 		w !,"  Dataset" w:$l(dblist,",")'=1 "s" w ": ",dblist
	 		i (nsplist]"") {
		 		w !,"  Namespace" w:$l(nsplist,",")'=1 "s" w ": ",nsplist
		 		w !!,"WARNING!  All associated namespaces will be deleted to delete this database."
		 		i $d(mappings)>1 {
			 		w !,"The following namespaces have mappings for this database.  If a namespace is"
			 		w !,"associated with the database only through mapping, you can go back and remove"
					w !,"the mappings rather than delete the namespace."
					w !,"  "
					s mapns=$o(mappings(""))  
					f  { w mapns s mapns=$o(mappings(mapns)) q:mapns=""  w "," }
		 		}
		 		s Value=0
		 		w !
 				s Value=0,Status=##Class(%Library.Prompt).GetYesNo("Delete namespace(s) "_nsplist_"?",.Value,,8)
		 		i (Status=2)||(+Status=0)||('Value) q
	 		}
 		}
 		s Value=0
 		s Status=##Class(%Library.Prompt).GetYesNo("Confirm deletion of database and "_"IRIS"_".DAT file in directory "_Directory_"?",.Value,,8)
		i (Status=2)||(+Status=0) q
 		i Value {
			if Obj=0 goto SkipDelete
			i 'Obj.Mounted {
				s Status=Obj.Mount()
				i (Status=2)||(+Status=0) q
			}
			s Status=Obj.Delete()
			i ('Status) {
				w ! d $SYSTEM.Status.DisplayError(Status) w !
			} else {
SkipDelete
				w !,"Database in "_Directory_" deleted"
 				f i=1:1:$l(nsplist,",") {
	 				s nsp=$p(nsplist,",",i) i nsp="" Continue
					s sc=##Class(Config.Namespaces).Delete(nsp)
					i ('sc) { w ! d $SYSTEM.Status.DisplayError(sc) w ! }
					else { w !,"Namespace ",nsp," removed from configuration." }
 				}
 				f i=1:1:$l(dblist,",") {
	 				s db=$p(dblist,",",i) i db="" Continue
					s sc=##Class(Config.Databases).Delete(db)
					i ('sc) { w ! d $SYSTEM.Status.DisplayError(sc) w ! }
					else { w !,"Dataset ",db," removed from configuration." }
 				}
	 		}
 		}
 		s Status=1
 		q
	}
	i +Status=0 q
	k Obj
 }
 q Status
ERROR s $zt=""
 i $ze["<INTERRUPT>" q 0
 ztrap $ZE
}
MOUNT() PUBLIC {
 s $zt="ERROR"
 i '$SYSTEM.Security.Check("%Admin_Operate","USE") w !,"Operation requires %Admin_Operate:Use privilege" q 1
 f  {
	s Value=""
	s Flag=8+8192+512+1024
 	s Status=##class(SYS.Database).GetDirectory("Database directory to mount?",.Value,,,,,Flag)
 	i (+Status=0)||(Status=2)||(Value="") q
	Set Rset = ##class(%Library.ResultSet).%New("SYS.Database:List")
	d Rset.Execute(Value,0)
	Write !!,"Databases Selected"
	Write !,"------------------"
	If Rset.Next() {
		Do {
			w !,Rset.Get("Directory")
		} While (Rset.Next())
	} Else {
		w !,$li(Value,1)
	}
	Set numdb=$ll(Value)
	s mirrormember=($SYSTEM.Mirror.GetInfo()[",DEFINED,")  ;true/false
	s mirrorcatchuprequired=0
	s startcatchup=1
    f i=1:1:numdb {
		Set dir=$li(Value,i)
		s Obj(i)=##Class(SYS.Database).%OpenId(dir,,.Status)
		i ('Status) {
			w ! d $SYSTEM.Status.DisplayError(Status) w !
			Continue
		}
		If Obj(i).Mounted=1 {
			If $S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0) {
				w !,"Database "_dir_" is already mounted",! 
				w !,"If you want to change the mount mode you must dismount the database first." 
				s Obj(i)="" continue
			}
			Else {
				w !,"Database "_dir_" is already mounted",!
				s Obj(i)="" continue
			}
		}
		If Obj(i).EncryptedDB {
			If '$$EncKeyIsActivated(Obj(i).EncryptionKeyID,1,dir) {
				s Obj(i)="" continue
			}
		}
		if (mirrormember) {
			if (Obj(i).Mirrored && 
				'Obj(i).MirrorActivationRequired && 
				'Obj(i).InActiveMirror) {
				s mirrorcatchuprequired=1
			}
		}
	}
	Set askconfirm=0 f i=1:1:numdb If Obj(i)]"" Set askconfirm=1 Quit  
	If askconfirm {
		s confirmed=1
		s Status=##Class(%Library.Prompt).GetYesNo("Confirm mount of databases?",.confirmed,,8)
		i (Status=2) || 'confirmed Continue
		i (+Status=0) q		
		s readonly=0
   		s Status=##Class(%Library.Prompt).GetYesNo("Mount Read Only?",.readonly,,8)
		i (Status=2) Continue
		i (+Status=0) q
		If $S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0) {
			s cluster=0
			s Status=##Class(%Library.Prompt).GetYesNo("Mount Clustered?",.cluster,,8)
			i (Status=2) Continue
			i (+Status=0) q
		} 		
		if (mirrorcatchuprequired) {
			s startcatchup=1
	   		s Status=##Class(%Library.Prompt).GetYesNo("Start mirror catchup?",.startcatchup,,8)
			i (Status=2) Continue
			i (+Status=0) q
		}
	    s catchupsfnlist=""
		f i=1:1:numdb {
			If Obj(i)]"" {			
				Set resource=$Piece($zu(49,Obj(i).Directory),",",25)
				If '##Class(Security.Resources).Exists(resource) {
					Write !!,"The resource "_resource_" is not in the system table.",!,"We must either add this resource",!,"or modify this database to use an existing resource."
					s List(1)="Add resource"
					s List(2)="Modify database"
					s List(3)="Do not mount this database"
					s Status=##Class(%Library.Prompt).GetArray("Your choice?",.ans,.List,,,,8+32+128)
					i (Status=2) Continue
					i (+Status=0) q
					If ans=List(1) {
						Do 
						.	i '($e($roles,1,$l("%All"))="%All") { n $ET,$roles s $ET="",$roles=$roles_","_"%All"} ; verified 9/26/16 STC
						.	s Status=##Class(Security.Resources).Create(resource,"Added by ^DATABASE",2)
						i ('Status) {
							w ! d $SYSTEM.Status.DisplayError(Status) w ! Continue
						}
						i (Status=2) Continue
						i (+Status=0) q
						w !,"Resource added"
					} ElseIf ans=List(2) {
						s oldrn=Obj(i).ResourceName
						Do  
						.	i '($e($roles,1,$l("%All"))="%All") { n $ET,$roles s $ET="",$roles=$roles_","_"%All"} ; verified 9/26/16 STC
						.	s db=Obj(i)
						.	s Status=##Class(SYS.Database).ResourceNamePrompt("Resource name?",.db)
						i (+Status=0) w ! d $SYSTEM.Status.DisplayError(Status) w ! Continue
						i oldrn'=Obj(i).ResourceName {
							s Status=Obj(i).%Save()
							i ('Status) {
								w ! d $SYSTEM.Status.DisplayError(Status) w ! Continue
							}
							d Obj(i).Dismount()
							w !,"New resource name "_Obj(i).ResourceNameLogicalToDisplay(Obj(i).ResourceName)_" is saved."
						}
					} ElseIf ans=List(3) {
						Write !,"Database not mounted."
						Continue  
					}
				} //resource not known
				Set Status=Obj(i).Mount(readonly,$g(cluster),0)
				i ('Status) {
					w ! d $SYSTEM.Status.DisplayError(Status) w !
				} else {
					k Obj(i)
					s Obj(i)=##Class(SYS.Database).%OpenId($li(Value,i),,.Status)
						if Obj(i).Mirrored&&('Obj(i).InActiveMirror)&&('Obj(i).MirrorActivationRequired) {
							if (startcatchup) {
								s catchupsfnlist=$G(catchupsfnlist)_$LB(Obj(i).SFN)
							}
							w !,"Mirrored database "_Obj(i).Directory_" mounted, required catchup."
						} elseif Obj(i).ReadOnlyMounted {
							w !,"Database "_Obj(i).Directory_" mounted read-only. See messages.log for details."
						} else {
							w !,"Database "_Obj(i).Directory_" mounted."
						}
				}
			} //if Obj(i)
		} //for
		if $G(catchupsfnlist)'="" {
			JOB ##class(SYS.Mirror).CatchupDB(catchupsfnlist)::5
			i '$T {
				w !,"Failed to start catchup job for mirrored database(s)"
			} else {
				if $LL(catchupsfnlist) > 1 {
					w !,"A background Catchup job is running for the mirrored databases"
					w !," You could check whether these databases are still mounted read-only later."
				} else {
					w !,"A background Catchup job is running for the mirrored database"
					w !," You could check whether this database is still mounted read-only later."
				}
			}
		}
	} //askconfirm
	Kill Obj
 }
 q Status
ERROR s $zt=""
 i $ze["<INTERRUPT>" q 0
 ztrap $ZE
}
EncKeyIsActivated(keyid,use,dir) {
 s $zt="EncKeyActErr"
 i keyid="" {
   q 0 ;should never happen
 } else {
   s keyslot=$System.Security.System.GetDBEncKeyslot(keyid)
   i keyslot>=0 q 1 ;keyid is activated
   w !!,"The database in ",dir," is encrypted",!,?4,"with key ID ",keyid
 }
 f  {
   w !,"Provide encryption key info below to activate the key"
   w !,"OR press CTRL-C to skip mounting the database."
   s status=$$ActivateInt^EncryptionKey(use)
   i (''status) {
     s keyslot=$System.Security.System.GetDBEncKeyslot(keyid)
     i keyslot>=0 q  ;keyid is activated -- we are done
     w !!,"Need to activate key ID ",keyid
   }
 }
 q status ;$$$OK from ActivateInt^EncryptionKey() call above
EncKeyActErr s $zt="" w ! i $ze'["INTERRUPT" w $ze,! d BACK^%ETN
 s $ze=""
 q 0
}
DISMOUNT() PUBLIC {
 s $zt="ERROR"
 i '$SYSTEM.Security.Check("%Admin_Operate","USE") w !,"Operation requires %Admin_Operate:Use privilege" q 1
 f  {
	s Value=""
	s Flag=8+8192+512+1024
 	s Status=##class(SYS.Database).GetDirectory("Database directory to dismount?",.Value,,,,,Flag)
 	i (+Status=0)||(Status=2)||(Value="") q
	Set Rset = ##class(%Library.ResultSet).%New("SYS.Database:List")
	d Rset.Execute(Value,0)
	Write !!,"Databases Selected"
	Write !,"------------------"
	If Rset.Next() {
		Do {
			w !,Rset.Get("Directory")
		} While (Rset.Next())
	} Else {
		w !,$li(Value,1)
	}
	Set numdb=$ll(Value)
        f i=1:1:numdb {
		Set dir=$li(Value,i)
		s Obj(i)=##Class(SYS.Database).%OpenId(dir,,.Status)
		i ('Status) {
			w ! d $SYSTEM.Status.DisplayError(Status) w !
			Continue
		}
		if ##class(SYS.Database).IsSystemDB(dir) w !,"Error!!!!! Database "_dir_" is not allowed to be dismounted.",! s Obj(i)="" continue
		If Obj(i).Mounted=0 w !,"Database "_dir_" is already dismounted",! s Obj(i)="" continue
	}
	Set askconfirm=0 f i=1:1:numdb If Obj(i)]"" Set askconfirm=1 Quit  
	If askconfirm {
		s confirmed=1
		s Status=##Class(%Library.Prompt).GetYesNo("Confirm dismount of databases?",.confirmed,,8)
		i (Status=2) || 'confirmed Continue
		i (+Status=0) q
		f i=1:1:numdb {
			If Obj(i)]"" {
				Set Status=Obj(i).Dismount()
				i ('Status) {
					w ! d $SYSTEM.Status.DisplayError(Status) w !
				} else {
					w !,"Database "_Obj(i).Directory_" dismounted"
				}
			}
		}
	}
	Kill Obj
 }
 q Status
ERROR s $zt=""
 i $ze["<INTERRUPT>" q 0
 ztrap $ZE
}
COMPACT() PUBLIC {
 s $zt="ERROR"
 i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q 1
 s IOMS=$system.Device.GetRightMargin()
 f  {
	s Value=""
	s Flag=8+8192+512+1024+524288+1048576
 	s Status=##class(SYS.Database).GetDirectory("Database directories to compact?",.Value,,,,,Flag)
 	q:(Value="")||(+Status=0)||(Status=2)
	Set Rset = ##class(%Library.ResultSet).%New("SYS.Database:List")
	d Rset.Execute(Value,0)
	Write !!,"Databases Selected"
	Write !,"------------------"
 	While (Rset.Next()) {
		w !,Rset.Get("Directory")
 	}
 	w !
	K GloSel
 	S GloSel=0
 	If $ListLength(Value)=1 {
	 	s Obj=##Class(SYS.Database).%OpenId($Li(Value),,.Status)
		If ('Status) {
			w ! d $SYSTEM.Status.DisplayError(Status) w !
			Continue
		}
		if 'Obj.Mounted||(Obj.MirrorNoWrite||Obj.ReadOnly||(Obj.ReadOnlyMounted&&($SYSTEM.Mirror.IsPrimary()||'Obj.Mirrored))) {
			w !,Obj.Directory," is a ",$s(Obj.ReadOnly||Obj.ReadOnlyMounted:"read-only ",1:""),$s('Obj.Mounted:"dismounted ",1:""),"database, skipped!",!
			continue
		}
	 	S GCFlag=1
		Do OPT^%GSET(,,,1,1,$LI(Value),,,.GCFlag,,1,.GloSel)
	 	Continue:'GCFlag
		Set GloSel=(GCFlag>0)				// SJ3040
 	}
	s Full=90
	s Status=##Class(%Library.Prompt).GetNumber("How full do you want the database blocks?",.Full,50,100,,8)
	i (+Status=0)||(Status=2) q
	s DisplayGlobals=GloSel
	s Status=##Class(%Library.Prompt).GetYesNo("Display compacted globals?",.DisplayGlobals,,8)
	i (Status=2) Continue
	i (+Status=0) q
 	s IO=""
  	s Status=##class(%Library.Device).Get("Device:",.IO,,8,,4,.IOSL,.IOM,.IOF)
 	Continue:(Status=2)
 	q:(+Status=0)
	s confirmed=1
	s Status=##Class(%Library.Prompt).GetYesNo("Confirm compaction of databases?",.confirmed,,8)
	i (Status=2) || 'confirmed Close IO Continue
	i (+Status=0) Close IO q
	d Rset.Execute(Value,0)
	Use IO
	Write !!,##Class(%Library.Utility).Center("Database Compaction",IOM)
	W !,##Class(%Library.Utility).Center(##Class(%Library.Utility).DateTime(),IOM)
	If 'DisplayGlobals {
		Write !,"Database",?25,"MB Processed",?40,"MB Compressed To",?60,"Completed"
		Write !,"--------",?25,"------------",?40,"----------------",?60,"---------"
	}
 	While (Rset.Next()) {
		s Obj=##Class(SYS.Database).%OpenId(Rset.Get("Directory"),,.Status)
		If ('Status) {
			w ! d $SYSTEM.Status.DisplayError(Status) w !
			Continue
		}
		If DisplayGlobals {
			Write !!,"Database ",Obj.Directory
		} Else {
			Write !!,Obj.Directory
		}
		if 'Obj.Mounted||(Obj.MirrorNoWrite||Obj.ReadOnly||(Obj.ReadOnlyMounted&&($SYSTEM.Mirror.IsPrimary()||'Obj.Mirrored))) {
			w " is a ",$s(Obj.ReadOnly||Obj.ReadOnlyMounted:"read-only ",1:""),$s('Obj.Mounted:"dismounted ",1:""),"database, skipped!",!
			continue
		}
		If GloSel {
			s Status=Obj.Compact(Full,.MbProcessed,.MbCompressed,DisplayGlobals,IO,.GloSel)
		} Else {
			s Status=Obj.Compact(Full,.MbProcessed,.MbCompressed,DisplayGlobals,IO)
		}
		If ('Status) {
			w ! d $SYSTEM.Status.DisplayError(Status) w !
			Continue
		}
		If 'DisplayGlobals {
			Write ?25,$j(MbProcessed,$l("MB Processed"))
			Write ?40,$j(MbCompressed,$l("MB Compressed To"))
			w ?60,$j(##Class(%Library.Utility).Time(),9)
		}
		k Obj
 	}
 	w !
	c:IO'=$P IO
 }
 If $D(IO),IO=$P U IO:/MAR=IOMS
 q Status
ERROR s $zt=""
 If $D(IO),IO=$P,$D(IOMS) U IO:/MAR=IOMS
 i $ze["<INTERRUPT>" q 0
 ztrap $ZE
}
DEFRAG() PUBLIC {
 s $zt="ERROR"
 i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q 1
getdb
 f  {
	s DB=""
	k Value
	s Flag=8+8192+512+524288+1048576
 	s Status=##class(SYS.Database).GetDirectory("Database directory?",.DB,.Obj,,,,Flag)
 	i (+Status=0)||(Status=2)||(DB="") q
 	i Obj.Mounted=0 w !!,"Database is not mounted, please re-enter",! Continue
	if (Obj.MirrorNoWrite||Obj.ReadOnly||(Obj.ReadOnlyMounted&&($SYSTEM.Mirror.IsPrimary()||'Obj.Mirrored))) w !!,"Database is read-only, please re-enter",! Continue
	s sc=##class(SYS.Database).DefragmentCheck(Obj.Directory,,.datasize,.endfree,.freespace,.expreq,.overmax)
	i ('sc) { do $System.Status.DisplayError(sc) continue }
	if datasize {
		w !!,"There are ",datasize,"MB of data to be processed."
	} else {
		w !!,"There is less than 1MB of data to be processed."
	}
	i expreq {
		w !!,"There are ",endfree,"MB of freespace at the end of the database, and"
		w !,"defragmentation requires an additional ",expreq,"MB to operate."
		i overmax {
			w !,"That amount would exceed the maximum size of the database."
		}
		if (freespace-endfree)>20 {
			w !!,"There is a total of ",freespace,"MB freespace in the database.  You can go"
			w !,"back and compact the freespace to make more usable for defragmentation."
			if overmax && ((freespace-endfree)>overmax) {
				w !,"However, that alone would not be enough."
			}
		}
		w !
		continue:overmax
		w !,"You can continue, in which case the database may expand to accomodate up to"
		w !,expreq,"MB of additional space needed for defragmentation to operate."
	}
	w !
	s Status=##Class(%Library.Prompt).GetYesNo("Ok to begin defragmentation?",.Value,,8)
	continue:(Status'=1)||'Value 
	s MaxExpand = -1
	goto defrag
defrag
	s utilobj=##class(SYS.Database.BackgroundDefragment).Start(Obj.Directory)
	i $isobject(utilobj) {
		d utilobj.CHUIMonitor()
	} else {
		d $system.Status.DisplayError(%objlasterror)
	}
	s Status=1
	q
 }
 i +Status=0 q
 q Status
DefragCalc
	s endtot = endfree + MaxExpand
	i datasize<=endtot {
		s Writes = 0
		q
	} elseif datasize<=(freespace+MaxExpand) {
		s Writes = $NORMALIZE(2 + ((datasize - endtot)/datasize),2)
	} else {
		s freein = (freespace-endfree)
		s remainder = datasize-endtot
		i remainder>freein s remainder = freein
		s work = freespace + MaxExpand
		s n = (1 / (work / datasize)), frac = $Normalize(n,-1) i n>frac s n=frac+1
		s Writes = $NORMALIZE((((n*2)-1)/n)  + (((n*(n+1))/2)/n),2)
		s Writes = $NORMALIZE(Writes + (remainder/datasize),2)
	}
	s Writes = $NORMALIZE((Writes/2),1)
	q
ERROR s $zt=""
 i $ze["<INTERRUPT>" q 0
 ztrap $ZE
 }
FREECOUNT(allflag) PUBLIC {
 s $zt="ERROR"
 Do {
	If $Get(allflag)']"" {
		s Value=""
		s Flag=8+8192+512+1024
		s Status=##class(SYS.Database).GetDirectory("Database directory to show free space for (*=All)?",.Value,,,,,Flag)
		q:(Value="")||(+Status=0)||(Status=2)
	} Else {
		If allflag="all" { Set Value="*" }
		Else { Set Value=$lb(allflag) }
	}
	Set Rset = ##class(%Library.ResultSet).%New("SYS.Database:List")
	d Rset.Execute(Value,0)
	Write !!,"Databases Selected"
	Write !,"------------------"
 	While (Rset.Next()) {
	 	if (Rset.Get("StateInt")["Dismounted") continue
		w !,Rset.Get("Directory")
 	}
 	s IO=""
  	s Status=##class(%Library.Device).Get("Device:",.IO,,8,,4,.IOSL,.IOM,.IOF)
 	Continue:(Status=2)
 	q:(+Status=0)
	Set Rset = ##class(%Library.ResultSet).%New("SYS.Database:FreeSpace")
	d Rset.Execute(Value,0)
	Use IO
	Write !!,##class(%Library.Utility).Center("Database Free Space",IOM)
	W !,##class(%Library.Utility).Center(##Class(%Library.Utility).DateTime(),IOM)
	w !,"Database",?35,"Max Size",?45,"Size",?53,"Available",?63,"%Free",?71,"Disk Free"
 	While (Rset.Next()) {
	 	if (Rset.Data("Available")["Dismounted") continue
	 	w !,Rset.Data("Directory")
	 	w:$x>35 ! w ?35,Rset.Data("MaxSize")
	 	w:$x>45 ! w ?45,Rset.Data("Size")
	 	w:$x>53 ! w ?53,Rset.Data("Available")
	 	w:$x>63 ! w ?63,Rset.Data("Free") i Rset.Data("Free")<5 w ?68,"<-",*7
	 	w:$x>71 ! w ?71,Rset.Data("DiskFreeSpace")
 	}
	w !
 	c:IO'=$P IO
 	q
 } While($Get(allflag)']"")
 q Status
ERROR s $zt=""
 i $ze["<INTERRUPT>" q 0
 ztrap $ZE
}
DETAIL() PUBLIC {
 s $zt="ERROR"
 f  {
	s Value=""
 	s Flag=8+512+1024+8192
 	s Status=##class(SYS.Database).GetDirectory("Database directories?",.Value,,,,,Flag)
 	q:(Value="")||(+Status=0)||(Status=2)
 	s IO=""
  	s Status=##class(%Library.Device).Get("Device:",.IO,,8,,4,.IOSL,.IOM,.IOF)
 	Continue:(Status=2)
 	q:(+Status=0)
	Set Rset = ##class(%Library.ResultSet).%New("SYS.Database:Detail")
	d Rset.Execute(Value)
 	u IO
	While Rset.Next() {
		w !,"------------------"
		s ro=0
		f i=1:1:Rset.GetColumnCount() {
			s cn=Rset.GetColumnName(i)
			if cn'["ReadOnlyReason" {
				w !,cn_":",?25,$S(cn["GlobalJournalState":##Class(%Library.JournalState).LogicalToDisplay(Rset.GetData(i)),1:Rset.GetData(i))
				if cn["MountedReadOnly"&&Rset.GetData(i) s ro=1
			} elseif ro {
				w ?28,"Reason: ",Rset.GetData(i)
			}
			if (cn="MultiVolume") && Rset.MultiVolume { d MULTIVOLlist(Rset.Directory,0) }
		}
		s DBlist=""
		s Status=$$DatasetsByDirectory^%SYS.CONFIG("",Rset.Data("Directory"),.DBlist)
		s cnt=0
		i (''Status)&&(DBlist]"") {
			for i=1:1:$listlength(DBlist) {
				s dbn=$li(DBlist,i)
				i '##Class(Config.Databases).Exists(dbn,.dobj) continue
				s MR=dobj.MountRequired
				w !,"Configured DB Name:",?25,dbn
				w !,"Mount Required At Startup: ",?25,$s(MR:"Yes",1:"No")
				if $S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0)&&Rset.Data("ClusterMountMode") {
					s MS=dobj.MountAtStartup
					w !,"Cluster Mount At Startup:",?25,$s(MS:"Yes",1:"No")
				}
				s cnt=cnt+1
			}
		}
		i 'cnt W !,"No DB Name Configured"
	}
 	w !
	c:IO'=$P IO
 }
 q
ERROR s $zt=""
 i $d(IO),(IO'="") c:IO'=$P IO
 i $ze["<INTERRUPT>" q 0
 ztrap $ZE
}
RECREATE() PUBLIC {
 s $zt="ERROR"
 i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q 1
 f  {
	s Value=""
	s Flag=8+8192+512
 	s Status=##class(SYS.Database).GetDirectory("Database directory?",.Value,.Obj,,,,Flag)
 	i (+Status=0)||(Status=2)||(Value="") q
 	i Obj.ReadOnly,'$SYSTEM.Mirror.IsMember()||('Obj.Mirrored)||$SYSTEM.Mirror.IsPrimary() {
	 	w !!,*7,"Recreate ReadOnly Database is not allowed!"
	 	w !,"If you really need to recreate it you need to change it to non-ReadOnly DB."
	 	k Obj
	 	q
 	}
 	S DBdir=$zconvert(Value,"U")
	if ##class(SYS.Database).IsSystemDB(DBdir) {
	 	w !!,*7,"Recreate System Database "_Value_" is not allowed!",!
	 	k Obj
	 	Continue
	}
	if $SYSTEM.Mirror.IsPrimary(),Obj.Mirrored,Obj.MirrorObsolete {
		w !!,*7,"This mirrored database is obsolete, recreating obsolete mirrored database"
		w !,"in primary is not allowed."
		k Obj
		Continue
	}
	s Status=##Class(%Library.File).GetDirectorySpace(Obj.Directory,.FreeSpace,.TotalSpace)
	if ('Status) {
		w !,"Failed to get available disk space for ",Obj.Directory
		s Status=2
		quit
	}
Size
	w !,"Current size is "_Obj.Size_" MB"
 	s Value=Obj.Size
	s Flag=8
 	s Status=##Class(%Library.Prompt).GetNumber("Specify a desired file size (in MB):",.Value,1,FreeSpace+Obj.Size,"Size must be less than "_(FreeSpace+Obj.Size)_"MB",Flag)
 	i (+Status=0) q
 	i (Status=2) continue
	if Value>Obj.Size {
		if (Value-Obj.Size)>=FreeSpace {
			w !,"Requested size is greater than available disk free space of "_FreeSpace_" MB."
		 	g Size
		}
		if (Value-Obj.Size)>(FreeSpace*90/100) {
			s Value1=0
			w !,"Warning! The requested size increase ",Value-Obj.Size," MB is greater than 90% of available disk space (",FreeSpace," MB)."
			s Status=##Class(%Library.Prompt).GetYesNo("Are you sure you want to create the database with "_Value_" MB?",.Value1,,8)
			i (+Status=0) q
			i (Status=2)||(Value1=0) g Size
		}
	}
	s NewSize=Value
	f  {
  		s Value=0
		if DBdir["IRISLIB" {
			W !!,*7,"WARNING!!! Recreating the system library database could make this system"
  			W !,"fail to work. It will delete all the system utility programs."
  			W !,"If this is really the system library DB it is recommended NOT to do this."
		} else {
			W !,"WARNING! Recreating the database will delete all the data in the database."
			if $SYSTEM.Mirror.IsPrimary(),Obj.Mirrored {
				w !,"This is mirrored database.  You need to recreate the database on all other"
				w !,"mirror members after this operation."
			}
		}
		s Status=##Class(%Library.Prompt).GetYesNo("Confirm recreation of database in "_Obj.Directory_"?",.Value,,8)
		i (Status=2) q
 		i (+Status=0) q
 		i Value {
	 		s MirrorName=Obj.MirrorSetName,MirrorDBName=Obj.MirrorDBName
	 		s Directory=Obj.Directory
	 		if MirrorDBName'="" {
		 		k Obj
		 		if '$SYSTEM.Mirror.IsPrimary() {
			 		s rc=##class(SYS.MirrorConfiguration).CheckNewMirroredDB(MirrorName,MirrorDBName,,,5)
			 		if '(''rc) {
				 		w !,"This mirrored database has not been recreated in primary. You need to recreate"
						w !,"it on the primary before you can recreate this database."
				 		w !,"Error=",$SYSTEM.Status.GetErrorText(rc)
				 		quit
			 		}
		 		}
		 		s rc=##class(SYS.Mirror).RemoveMirroredDatabase(Directory)
		 		if '(''rc) {
			 		w !,"Failed to remove mirrored database ",Directory, " Error=",$SYSTEM.Status.GetErrorText(rc)
			 		quit
		 		}
		 		s Obj=##Class(SYS.Database).%OpenId(Directory,,.rc)
		 		i '(''rc) {
			 		w !,"Failed to open database ",Directory, " Error=",$SYSTEM.Status.GetErrorText(rc)
			 		w !," after its mirror database attribute is removed."
			 		quit
		 		}
	 		}
 			w !,"Deleting..." Hang 0
			s Status=Obj.Delete()
			i ('Status) {
				w ! d $SYSTEM.Status.DisplayError(Status)
				if MirrorDBName'="" {
					w !,"WARNING!!! This database is no longer a mirrored database."
					w !,"  You may need to set it up again."
				}
				w !
			} else {
				w !,"Formatting..." Hang 0
				s Obj.MirrorSetName = MirrorName
				s Obj.MirrorDBName = MirrorDBName
				s RequestedSize=NewSize
				s Obj.Size = 1
				s Obj.ReCreate = 1
				s Status=Obj.%Save()
				i ('Status) {
					w ! d $SYSTEM.Status.DisplayError(Status)
					if MirrorDBName'="" {
						w !,"WARNING!!! This database no longer exists."
						w !,"  You may need to create it again."
					}
					w !
				} else {
					if Obj.RequestSize'=0&&(Obj.RequestSize>RequestedSize) s RequestedSize=Obj.RequestSize
					s Directory = Obj.Directory
					s Obj=""
					s expjob=0
					i RequestedSize>1 {
						j ##class(SYS.Database).ModifyDatabase(Directory,RequestedSize)::10
						if '$T {
							w !,"Database in "_Directory_" recreated with 1 MB"
							w !," but it failed to start background job to expand it to "_RequestedSize_" MBs"
						} else {
							s expjob=$zchild
						}
					}
					w !,"Database in "_Directory_" recreated."
					if expjob {
						w !,"A background process "_expjob_" is started to expand this database to "_$s(RequestedSize<=1024:RequestedSize_" MB.",1:(RequestedSize/1024)_" GB.")
					}
				}
			}
 		}
		s Status=1
 		q
	}
	k Obj
 }
 q Status
ERROR s $zt=""
 i $ze["<INTERRUPT>" q 0
 ztrap $ZE
}
DBEncKey() Public { ;Database Encryption Utility; 24-September-2004; CFL1152 11/17/04
	Do Main Quit
}
Main() public {
	For {
		Set opt=$$mainopt() Quit:opt=""
		If opt=1 {
			Do CreateInt^EncryptionKey()
		} ElseIf opt=2 {
			Do ActivateInt^EncryptionKey(1)
		} ElseIf opt=3 {
			Do ShowKeyInt^DATABASE1()
		} ElseIf opt=4 {
			Do DeleteKeyInt^DATABASE1()
		} ElseIf opt=5 {
			Do ManageInt^EncryptionKey()
		} ElseIf opt=6 {
			Do ConfigStartInt^DATABASE1()
		}
	}
}
mainopt() {
	Write !
op1	Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2972613625"),"1) Create new database encryption key and key file")
	Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3261635297"),"2) Activate database encryption keys")
	Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3288252095"),"3) Show activated database encryption key identifiers")
	Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"817734760"),"4) Deactivate database encryption key")
	Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2863853651"),"5) Manage database encryption key file")
	Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3864387081"),"6) Configure InterSystems IRIS startup options")
	Write !!,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1221568091"),"Enter option: ")
	Read opt Quit:opt="" ""
	If (opt<1)!(opt>6) Write $get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3677302715"),"Invalid option") Goto op1
	Quit opt
}
ConfigStart(mode,journal,cachetemp,keyfile) public {
	Quit $$ConfigStart^DATABASE1(mode,journal,cachetemp,keyfile)
}
Start() public {
	Quit $$Start^DATABASE1()
}
Enable(file,Username,Password) public {
	Quit $$Enable^DATABASE1(file,Username,Password)
}
DeleteKey() public {
	Quit $$DeleteKey^DATABASE1()
}
ReadFile(file,data) public {
	Quit $$ReadFile^DATABASE1(file,data)
}
WriteFile(file,data) public {
	Quit $$WriteFile^DATABASE1(file,data)
}
CreateFile(file,DBEncKeyID) public {
	Quit $$CreateFile^DATABASE1(file,DBEncKeyID)
}
DBTruncat() Public {
 s $zt="ERROR"
 i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q 1
 f  {
	s Value=""
	s Flag=8+8192+512+524288+1048576
 	s Status=##class(SYS.Database).GetDirectory("Database directory?",.Value,.Obj,,,,Flag)
 	i (+Status=0)||(Status=2)||(Value="") q
 	i Obj.Mounted=0 w !!,"Database is not mounted, please re-enter",! Continue
	if (Obj.MirrorNoWrite||Obj.ReadOnly||(Obj.ReadOnlyMounted&&($SYSTEM.Mirror.IsPrimary()||'Obj.Mirrored))) w !!,"Database is read-only, please re-enter",! Continue
	f  {
		s Value=0
		s Flag=8
		w !,"Current size "_Obj.Size_"MB",!
 		s Status=##Class(%Library.Prompt).GetNumber("Specify a desired file size (in MB), or 0 to return all:",.TargetSize,0,Obj.Size-1,"Size must be less than current size",Flag)
 		i (+Status=0)||(Status=2) q
		w !,"Returning space... " Hang 0
		s NewSize=""
		s Status = ##class(SYS.Database).ReturnUnusedSpace(Obj.Directory,TargetSize,.NewSize)
		i Status'=1 {
			do $System.Status.DisplayError(Status)
		} else {
			w !,"Database "_Obj.Directory_" file size is now "_NewSize_"MB"
		}
 		s Status=1
 		k TargetSize, NewSize, Obj
 		q
	}
	i +Status=0 q
 }
 q Status
ERROR s $zt=""
 i $ze["<INTERRUPT>" q 0
 ztrap $ZE
 }
FileCompact() Public {
 s $zt="ERROR"
 i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q 1
 f  {
	s Value=""
	s Flag=8+8192+512+524288+1048576
 	s Status=##class(SYS.Database).GetDirectory("Database directory?",.Value,.Obj,,,,Flag)
 	i (+Status=0)||(Status=2)||(Value="") q
 	i Obj.Mounted=0 w !!,"Database is not mounted, please re-enter",! Continue
	if (Obj.MirrorNoWrite||Obj.ReadOnly||(Obj.ReadOnlyMounted&&($SYSTEM.Mirror.IsPrimary()||'Obj.Mirrored))) w !!,"Database is read-only, please re-enter",! Continue
	s Status = Obj.GetFreeSpace(Obj.Directory,.FreeSpace)
	i '(''Status) w !,"Unexpected error: " do $System.Status.DisplayError(Status) q
	s FreeSpace=FreeSpace\1
	s Status = ##class(SYS.Database).FileCompact(Obj.Directory,0,.endfree)
	i ('Status) { do $System.Status.DisplayError(Status) quit }
	w !,"Current Size: ",Obj.Size," MB"
	w !,"Total freespace: ",FreeSpace," MB"
	w !,"Freespace at end of file: ",endfree," MB",!
	i 'FreeSpace { w !,"No freespace to compact",! continue }
	i FreeSpace'>endfree { w !,"All freespace is already compacted",! continue }
	f  {
		k TargetSize
		s Flag=8+512
 		s Status=##Class(%Library.Prompt).GetNumber("Target freespace at end of file, in MB ("_endfree_"-"_FreeSpace_"): ",.TargetSize,endfree,FreeSpace,,Flag)
 		i (+Status=0)||(Status=2)||('TargetSize) q
		s utilobj=##class(SYS.Database.BackgroundFileCompact).Start(Obj.Directory,TargetSize)
		i $isobject(utilobj) {
			d utilobj.CHUIMonitor()
		} else {
			d $system.Status.DisplayError(%objlasterror)
		}
 		s Status=1
 		q
	}
	i +Status=0 q
	w !
 }
 q Status
ERROR s $zt=""
 i $ze["<INTERRUPT>" q 0
 ztrap $ZE
 }
BGLIST() PUBLIC {
	try {
		set rs=##class(%Library.ResultSet).%New("%SYS.BackgroundTask:DatabaseList")
		Set sc=rs.%Execute() Throw:('sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc)
		set atend='rs.%Next(.sc)
		if ('sc) { Throw ##class(%Exception.StatusException).ThrowIfInterrupt(sc) }
		if atend {
			write !!,"No records to display"
			quit
		}		
		write !!,"ID",?8,"Type / Database",?40,"Start Time",?62,"State"
		do {
			write !,rs.ID,?8,rs.DisplayType,?40,rs.StartTime,?62,rs.RunningState
			set:rs.HasEnded askpurge=1
			set list(rs.ID)=rs.HasEnded
			write:rs.ProgressTotal " ("_(100*rs.ProgressCurrent\rs.ProgressTotal)_"%)"
			write !,?10,rs.Database
			set atend='rs.%Next(.sc)
			if ('sc) { Throw ##class(%Exception.StatusException).ThrowIfInterrupt(sc) }
		} while 'atend
		write !
		for  {
			set id=""
			set rc=##class(%Library.Prompt).GetNumber("Enter ID: ",.id,,,,512+8) 
			quit:(rc'=1)||(id="")
			quit:$data(list(id))
			write !,"Invalid ID"
		}
		if (id) {
			set obj=##class(%SYS.BackgroundTask).%OpenId(id,,.sc)
			if ('sc) { 
				do $system.Status.DisplayError(sc)
			} else {
				do obj.CHUIMonitor()
				if rs.HasEnded {
					set askpurge=1
					set list(rs)=1
				}
			}
		}
		if $get(askpurge) {
			write !
			set yn=0,rc=##class(%Library.Prompt).GetYesNo("Purge information about tasks that have ended? ",.yn,,8) 
			if yn {
				set id="" 
				for  {
					set id=$order(list(id))
					quit:id=""
					do:list(id) ##class(%SYS.BackgroundTask).%DeleteId(id)	
				}
			}
		}
	} catch err {
		write !,err.DisplayString()
	}
}
MULTIVOL() PUBLIC {
	try {
		i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
		f  {
			s Value="",Obj=""
			s Flag=8+8192+512
			s Status=##class(SYS.Database).GetDirectory("Database directory?",.Value,.Obj,,,,Flag)
			q:Status'=1||(Value="")
			i 'Obj.MultiVolume && (Obj.VolumeDirectoryList="") && ##class(SYS.Database).IsSystemDB(Obj.Directory) {
				w !,"Multi-volume features are not available for system databases."
				continue
			}
			s donedir=0
			d showinfo
			while 'donedir {
				s List(1)="List volumes by directory"
				i Obj.Mounted {
					s List(2)="Change threshold for automatic volume creation"
					s List(3)="Change directory for automatic volume creation"
					s List(4)="Expand into a new volume directory manually"
 				} else { 
					s List(2)="Change volume directory list"
				}
				s Sub="",Status=##Class(%Library.Prompt).GetMenu("Option?",.Sub,.List,,8+128+4)
				q:Status'=1||(Sub="")
				w !
				i 'Obj.Mounted {
					i Sub=1 { d dispvols }
					elseif Sub=2 { d updatedirlist }
					else { continue }
				} else {
					i Sub=1 { d dispvols } 
					elseif Sub=2 { d updatethreshold }
					elseif Sub=3 { d updatedirectory }
					elseif Sub=4 { d newvolnow }
					else { continue }
				}
				q:(Status'=1)&&(Status'=2)
				Set sc=Obj.%Reload() Throw:('sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc)
				d showinfo
			}
			q:Status'=1
		}
	} catch err {
		w !,err.DisplayString()
	}
	q
showinfo
	s c=28
	w !!,Obj.Directory
	w !,"-----------------------------------------------------"
	w !,"Database is ",$s(Obj.Mounted:"mounted.",1:"not mounted.")
	w !,"Number of volumes:",?c,Obj.MultiVolume+1
	w " (",$s(Obj.MultiVolume:"including",1:"only")," the ","IRIS.DAT",")"
	w !,"Total database size:",?c,Obj.Size," MB"
	i Obj.NewVolumeThreshold {
		w !,"New volume threshold size:",?c,$s('(Obj.NewVolumeThreshold):0,(Obj.NewVolumeThreshold)#(1024*1024)=0:(Obj.NewVolumeThreshold)\1024\1024_" TB ("_(+Obj.NewVolumeThreshold)_" MB)",(Obj.NewVolumeThreshold)#(1024)=0:(Obj.NewVolumeThreshold)\1024_" GB ("_(Obj.NewVolumeThreshold)_" MB)",1:(Obj.NewVolumeThreshold)_" MB")
		w !,"Directory for new volumes:",?c
		i Obj.NewVolumeDirectory=Obj.Directory { w "<primary directory>" }
		else { w Obj.NewVolumeDirectory }
	} else {
		w !,"New volume threshold size:",?28,"0 (no automatic volume creation)"
	}
	w !
	d dispdirs
	q:Obj.Mounted
	i 'Obj.MultiVolume && (Obj.VolumeDirectoryList="") { 
		w !!,"There is no action to take until the the database is mounted.",!
		s donedir=1
		q
	}
	i Obj.VolumeDirectoryList="" {
		w !!,"The volume directory list stored in this database is empty, so all volumes"
		w !,"files are expected in the primary directory.  If you moved any to another"
		w !,"directory, you must add that directory before the database can be mounted."
	} else {
		w !!,"If you moved the volume files to a different set of directories, you must"
		w !,"update this list before the database can be mounted."
	}
	w !!,"Otherwise, there is no action to take until the the database is mounted."
	q
dispdirs
	q:Obj.VolumeDirectoryList=""
	s sc=Obj.VolumeFilesGetArray(.volfiles,Obj.Directory,.ex)
	s:('sc) ex="e"
	w !,"Directories (primary plus volume directory list): "
	w $j("# Vols",57-$x)," ",$j("Total MB",68-$x)," ",$j("Disk Free",79-$x)
	f i=0:1:$listlength(Obj.VolumeDirectoryList) {
		i i { s vdir=$list(Obj.VolumeDirectoryList,i) }
		else { s vdir=Obj.Directory }
		i ex="" {
			s $listbuild(tmp,size,numvols,diskfree)=volfiles("d",i)
			zt:vdir'=tmp
		} else {
			s (size,numvols,diskfree)="?"
		}
		w !," ",vdir
		w:$x>50 !
		w $j(numvols,57-$x)," ",$j(size,68-$x)," ",$j(diskfree,79-$x)
	}
	i ex["e" { w !,"  ** An error occurred fetching volume size and count by directory" }
	elseif ex'="" { w !,"  ** The expected number of volume files were not found" }
	q
dispvols
	d MULTIVOLlist(Obj.Directory,1)
	w ! 
	s Status=##class(%Library.Prompt).GetMore("Press enter to return",,8)
	q
updatethreshold
	s Status=$$MULTIVOLpromptthreshold(Obj,'Obj.NewVolumeThreshold)
	q:Status'=1
	q:'Obj.%IsModified()
	s save=1,Status=##class(%Library.Prompt).GetYesNo("Confirm change?",.save,,8)
	q:Status'=1
	q:'save
	s rc=$system.DB.ModifyMultiVol(Obj.Directory,Obj.NewVolumeThreshold*(1048576\Obj.BlockSize))
	d:rc<0 errorsaving($$Error^%apiOBJ(-rc))
	q
updatedirectory
	i 'Obj.NewVolumeThreshold {
		w !,"New volume threshold size = 0, so new volumes will not be created automatically"
		q
	}
	s Status=$$MULTIVOLpromptnewvoldir("Directory for new volumes?",Obj)
	q:Status'=1
	s now=0
	i Obj.NewVolumeDirectory'=Obj.LastVolumeDirectory {
		w !!,"The directory for new volumes is different than the directory containing the"
		w !,"last volume.  A new volume will be created there when the last volume expands"
		w !,"to the new volume threshold size.  If you want to prevent the last volume from"
		w !,"expanding any further, you may create the new volume now."
		w !
		s Status=##Class(%Library.Prompt).GetYesNo("Expand into new volume now?",.now,,8)
 		q:(Status'=1)
		i now {
			s Status=$$MULTIVOLpromptinitialsize(Obj,.now)
			q:Status'=1
		}
	}
	q:'Obj.%IsModified()&&'now
	s save=1,Status=##class(%Library.Prompt).GetYesNo("Confirm change?",.save,,8)
	q:Status'=1
	q:'save
	i Obj.NewVolumeDirectory'=Obj.Directory {
		s sc=##class(SYS.Database).UseVolumeDirectory(Obj.Directory,Obj.NewVolumeDirectory,2,'$listfind(Obj.VolumeDirectoryList,Obj.NewVolumeDirectory))
		i ('sc) {
			d errorsaving(sc)
			q
		}
	}
	s rc=$system.DB.ModifyMultiVol(Obj.Directory,-1,Obj.NewVolumeDirectory,now*(1048576\Obj.BlockSize))
	d:rc<0 errorsaving($$Error^%apiOBJ(-rc))
	q
newvolnow
	w:'$$MULTIVOLBackupCheck(Obj) !!,*7,"WARNING: multi-volume databases cannot be backed up with IRIS Online Backup",!
	s Status=$$MULTIVOLpromptnewvoldir("Directory to create new volume?",Obj)
	q:Status'=1
	i (Obj.NewVolumeDirectory=Obj.LastVolumeDirectory) &&
	  '(Obj.NewVolumeThreshold && (Obj.LastVolumeSize>=Obj.NewVolumeThreshold)) {
		w *7
		i Obj.LastVolumeSize<(1024*1024) {
			w !!,"The last volume is ",Obj.LastVolumeSize," MB.  Since the new volume will be in the same"
			w !,"storage device, it is recommended to allow the last volume to grow to at least "
			w !,$s('((1024*1024)):0,((1024*1024))#(1024*1024)=0:((1024*1024))\1024\1024_" TB ("_(+(1024*1024))_" MB)",((1024*1024))#(1024)=0:((1024*1024))\1024_" GB ("_((1024*1024))_" MB)",1:((1024*1024))_" MB")," to avoid an excessive number of files."
			w !,"Each database is limited to "_200_" volumes."
			w !
			s yn=0,Status=##Class(%Library.Prompt).GetYesNo("Proceed, leaving the last volume at its current size?",.yn,,8)
			q:Status'=1
			q:'yn
		} else {
			w !!,"Note, the directory is the same as the directory containing the last volume so"
			w !,"expanding into a new volume doesn't change which storage device is used."
		}
		w !
	}
	s Status=$$MULTIVOLpromptinitialsize(Obj,.mb)
	q:Status'=1
	i Obj.NewVolumeThreshold && Obj.NewVolumeDirectoryIsModified() {
		w !!,"The selected directory will be used for any further volumes created"
		w !,"automatically at the new volume thresdhold size."
		w !
	}
	s save=1,Status=##class(%Library.Prompt).GetYesNo("Confirm expansion into a new volume?",.save,,8)
	q:Status'=1
	q:'save
	s sc=##class(SYS.Database).NewVolume(Obj.Directory,Obj.NewVolumeDirectory,mb)
	d:('sc) errorsaving(sc)
	q
updatedirlist
	s dirnum=1,dirlist="",newvolnum=0
	f  {
		s Value="",Status=##class(%Library.Prompt).GetString("Directory #"_dirnum_" (null=end)?",.Value,,,,8)
		q:(Status'=1)||(Value="")
		s Value=$zu(12,Value,1)
		i Value="" { w !!,"Invalid directory specification, please re-enter",! continue }
		i (Value=Obj.Directory) { w !!,"Directory matches primary directory, which is implicitly included.",! continue }
		s dup=$listfind(dirlist,Value)
		i dup { w !!,"Directory matches directory #",dup,! continue }
		s dirlist=dirlist_$lb(Value)
		s dirnum=dirnum+1
	}
	q:(Status'=1)
	i dirnum=1 {
		q:Obj.VolumeDirectoryList=""
		k save
		s Status=##class(%Library.Prompt).GetYesNo("Confirm saving null list (use only primary directory)?",.save,,8)
		q:(Status'=1)
	} else {
		w !
		f i=1:1:$ll(dirlist) w !,"Directory #",i,": ",$list(dirlist,i)
		w !
		k save 
		s Status=##class(%Library.Prompt).GetYesNo("Confirm saving list?",.save,,8)
		q:Status'=1
		q:'save
		i Obj.NewVolumeThreshold {
			s Status=##Class(%Library.Prompt).GetNumber("Directory # in which any future volumes be created (0=primary)?",.newvolnum,0,$ll(dirlist),,8)
			q:Status'=1
		}
	}
	q:'save
	s sc=##class(SYS.Database).ModifyVolumeDirectoryList(Obj.Directory,dirlist,newvolnum)
	d:('sc) errorsaving(sc)
	q
errorsaving(sc)
	w !,"Error saving changes:" 
	d $system.Status.DisplayError(sc)
	w !
	s Status=##class(%Library.Prompt).GetMore("Press enter to return",,8)
}
MULTIVOLpromptnewvoldir(prompt,Obj) PRIVATE {
	i Obj.NewVolumeThreshold {
		w:Obj.VolumeDirectoryList="" !,"New volumes are created in the same directory as the ","IRIS.DAT"," by default."
		w !,"If an additional storage device is needed for expansion, enter a directory"
		w !,"on that device where further volumes will be created."
	} else {
		w !,"If an additional storage device is needed for expansion, enter a directory"
		w !,"on that device."
	}
	i Obj.VolumeDirectoryList'="" {
		w !!,"If space is available on a storage device that already contains volumes of"
		w !,"this database, you may enter '?' to select from the current directory list."
		s voldirs(1)=Obj.Directory
		f i=1:1:$ll(Obj.VolumeDirectoryList) s voldirs(i+1)=$li(Obj.VolumeDirectoryList,i)
	}
nextvoldiragain
	w !
	s Value=Obj.NewVolumeDirectory
	s Status=##Class(%Library.Prompt).GetArray(prompt,.Value,.voldirs,,,,8)
	q:(Status'=1) Status
	q:(Value="") 2
 	s Value=$zu(12,Value,1)
 	i Value="" {
	 	w !!,"Invalid directory specification, please re-enter"
		g nextvoldiragain
 	}
	i 'Obj.CheckVolumeDirectoryMax(Value) {
		w !!,"The database already has the maximum of ",20," volume directories."
		w !,"You may only select a directory from the current volume directory list."
		g nextvoldiragain
	}
 	i $zu(12,Value,3)="" {
		s yn=0,Status=##Class(%Library.Prompt).GetYesNo("Directory does not exist, create it?",.yn,,8)
 		q:(Status'=1) Status
		g:'yn nextvoldiragain
		i '##Class(%Library.File).CreateDirectoryChain(Value) {
			w !!,"Error creating directory"
			g nextvoldiragain
		}
	}
	s Obj.NewVolumeDirectory=Value
	q 1
}
MULTIVOLpromptthreshold(Obj,showhelp=0) PUBLIC {
	s Help($i(h))="0 (default) disables automatic creation of new volumes."
	s Help($i(h))=""
	s Help($i(h))="If non-zero, when the "_"IRIS.DAT"_" would expand past this threshold, a new"
	s Help($i(h))="volume file called "_("IRIS-"_$extract("000"_+(1),*-3,*)_".VOL")_" will be created.  When expansion would"
	s Help($i(h))="grow that file past the threshold, "_("IRIS-"_$extract("000"_+(2),*-3,*)_".VOL")_" will be created, and so on."
	s (Help($i(h)),Warn(1))="For non-zero values, a minimum of "_$s('((1024*1024)):0,((1024*1024))#(1024*1024)=0:((1024*1024))\1024\1024_" TB ("_(+(1024*1024))_" MB)",((1024*1024))#(1024)=0:((1024*1024))\1024_" GB ("_((1024*1024))_" MB)",1:((1024*1024))_" MB")_" is recommended to avoid"
	s (Help($i(h)),Warn(2))="an excessive number of files.  Each database is limited to "_200_" volumes."
	s Help($i(h))=""
	s Help($i(h))="Append 'G' or 'T' for gigabytes or terabytes.  Otherwise MB is assumed."
	i showhelp {
		w ! 
		f i=1:1:+$o(Help(2147483647),-1) w !,$g(Help(i))
		w !
	}
again
	s Value=$s('(Obj.NewVolumeThreshold):0,(Obj.NewVolumeThreshold)#(1024*1024)=0:(Obj.NewVolumeThreshold)\1024\1024_" TB ("_(+Obj.NewVolumeThreshold)_" MB)",(Obj.NewVolumeThreshold)#(1024)=0:(Obj.NewVolumeThreshold)\1024_" GB ("_(Obj.NewVolumeThreshold)_" MB)",1:(Obj.NewVolumeThreshold)_" MB")
	s Status=##Class(%Library.Prompt).GetString("New volume threshold size (0 = none)?",.Value,,,.Help,8)
	q:Status'=1 Status
	i Value=0 { s Obj.NewVolumeThreshold=0 q Status	}
	s Value=($s($f(Value,"G"):(Value)*1024,$f(Value,"g"):(Value)*1024,$f(Value,"T"):(Value)*1024*1024,$f(Value,"t"):(Value)*1024*1024,1:(Value))\1)
	g:Value<=0 again
	i (Value < (1024*1024)) && (Value'=Obj.NewVolumeThreshold) {
		w !!,*7	f i=1:1:+$o(Warn(2147483647),-1) w !,$g(Warn(i)) 
		w !
		s yn=0,Status=##Class(%Library.Prompt).GetYesNo("Keep small new volume threshold size?",.yn,,8)
		q:Status'=1 Status
		g:'yn again
	}
	w:'Obj.NewVolumeThreshold&&'$$MULTIVOLBackupCheck(Obj) !!,*7,"WARNING: multi-volume databases cannot be backed up with IRIS Online Backup",!
	s Obj.NewVolumeThreshold=Value\1
	q Status
}
MULTIVOLpromptinitialsize(Obj,mb) PRIVATE {
again
	s mb=$select(Obj.ExpansionSize:Obj.ExpansionSize,1:1024)
	s:Obj.NewVolumeThreshold&&(mb>Obj.NewVolumeThreshold) mb=Obj.NewVolumeThreshold
	s mb=$s('(mb):0,(mb)#(1024*1024)=0:(mb)\1024\1024_" TB ("_(+mb)_" MB)",(mb)#(1024)=0:(mb)\1024_" GB ("_(mb)_" MB)",1:(mb)_" MB")
	s Help(1)="Append 'G' or 'T' for gigabytes or terabytes.  Otherwise MB is assumed."
	s Status=##Class(%Library.Prompt).GetString("Initial size of new volume?",.mb,,,.Help,8)
	q:Status'=1 Status
	q:mb=0 2
	s mb=($s($f(mb,"G"):(mb)*1024,$f(mb,"g"):(mb)*1024,$f(mb,"T"):(mb)*1024*1024,$f(mb,"t"):(mb)*1024*1024,1:(mb))\1)
	g:mb<=0 again
	i Obj.NewVolumeThreshold && (mb>Obj.NewVolumeThreshold) {
		w !,*7,"Value cannot exceed the new volume threshold (currently ",$s('(Obj.NewVolumeThreshold):0,(Obj.NewVolumeThreshold)#(1024*1024)=0:(Obj.NewVolumeThreshold)\1024\1024_" TB ("_(+Obj.NewVolumeThreshold)_" MB)",(Obj.NewVolumeThreshold)#(1024)=0:(Obj.NewVolumeThreshold)\1024_" GB ("_(Obj.NewVolumeThreshold)_" MB)",1:(Obj.NewVolumeThreshold)_" MB"),")"
		g again
	}
	q Status
}
MULTIVOLlist(Directory,byvoldir) PRIVATE {
	s rs=##class(%Library.ResultSet).%New("SYS.Database:VolumeFiles")
	s sc=rs.%Execute(Directory,+$g(byvoldir))
	i ('sc) { 
		w !,"Error getting list of volumes: "
		d $system.Status.DisplayError(sc)
		q
	}
	i 'byvoldir {
		while rs.%Next() {
			w !,$j(rs.VolumeNumber,5),": ",rs.VolumeDirectory
			w " ",$j(rs.File,65-$x)," ",$j(rs.Size,76-$x)," MB "
		}
		q
	}
	s dir=$c(0),count=0
	f  {
		s done='rs.%Next()
		i (dir'=rs.VolumeDirectory) && count {
			w:count>1 !,?21,"=Total= ",$j("="_tot,41-$x)," MB="
			w:df>=0 " (",df," MB disk free)"
		}
		q:done
		i dir'=rs.VolumeDirectory {
			s count=0,tot=rs.VolumeDirectoryTotalSize,df=rs.DiskFree
			s dir=rs.VolumeDirectory
			w !,dir
		}
		w !,$j(rs.File,28)," ",$j(rs.Size,41-$x)," MB "
		s count=count+1
	}
}
MULTIVOLBackupCheck(Obj) PUBLIC {
	return:Obj.MultiVolume 1
	s earliest=(+$h-365*1000000+$p($h-365,",",2))
	s date=""
	f  {
		s date=$o(^SYS("BUHISTORY",date),-1)
		q:(date="")||(date<earliest)
		s type=$G(^SYS("BUHISTORY",date,"TYPE"),"Unknown")
		return:type'["External" 0
	}
	return:'$zu(52,8,Obj.Directory) 0
	return 1
}
HEADER() PUBLIC {
 w !,"Block",?7,"# of",?12,"File"    ,?21,"Exp #",?28,"Max #",?34,"New gbl",?42,"New gbl",?50,"Col"
 w !,"size" ,?7,"vols",?12,"size(MB)",?21,"(MB)" ,?28,"(MB)" ,?34,"pntrs"  ,?42,"data"   ,?50,"type"
 q
}
ALL() PUBLIC {
 Set Rset = ##class(%Library.ResultSet).%New("SYS.Database:Detail")
 d Rset.Execute("*")
 While Rset.Next() {
	w !,Rset.Data("Directory")
	w !," "
	w Rset.Data("BlockSize")
	w ?7,1
	w ?12,Rset.Data("Size")
	w ?21,Rset.Data("ExpansionSize")
	w ?28,Rset.Data("MaxSize")
	w ?34,Rset.Data("NewGlobalPointerBlock")
	w ?42,Rset.Data("NewGlobalGrowthBlock")
	s Collation=##Class(%Library.Collate).DisplayToLogical(Rset.Data("NewGlobalCollation"))
	w ?50,Collation
	w !,Rset.Data("Status")
	w !
 }
 q
}
AskJrnEncOnNewDB(Obj) public {
	Quit $$AskJrnEncOnNewDB^DATABASE1(Obj)
}

DATACHECK^INT^1^67214,47330
DATACHECK() {  ; Management utility for DataCheck package
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	try {
		s oldselectmode=$zu(115,5,2),oldprivmode=$zu(115,8,0)
		i '$system.Security.Check("%Admin_Operate","USE") {
			w !,"Operation requires %Admin_Operate:Use privilege"
			q
		}
		s hasdbprivs=$$ScreenForDatabasePrivilege(.resourcename)
		i 'hasdbprivs {
			w !,"Operation requires "_resourcename_":Read privilege"
			q
		}
		s list(1)="Create New Configuration"
		s list(2)="Edit Configuration"
		s list(3)="View Details"
		s list(4)="Start"
		s list(5)="Stop"
		s list(6)="Delete Configuration"
		s list(7)="Incoming Connections to this System as a DataCheck Source"
		f  {
			s v="",rc=##class(%Library.Prompt).GetMenu("Option?",.v,.list,,128+8) q:rc'=1
			q:'v
			i $case(v,1:1,2:1,6:1,:0) && (hasdbprivs<2) {
				w !,"Operation requires "_resourcename_":Write privilege"
				continue
			}
			i v=1 d New() continue
			i v=2 d Setup() continue
			i v=3 d ViewInt() continue
			i v=4 d Start() continue
			i v=5 d Stop() continue
			i v=6 d Delete() continue
			i v=7 d Source() continue
		}
	} catch err {
		d $zu(115,8,oldprivmode),$zu(115,5,oldselectmode)
		w !!,"Unexpected error occurred: ",!,"  ",err.DisplayString()
	}
	d $zu(115,8,oldprivmode),$zu(115,5,oldselectmode)
}
	; Public subroutine for view menu
View() PUBLIC {
	try {
		s oldselectmode=$zu(115,5,2),oldprivmode=$zu(115,8,0)	
		i '$system.Security.Check("%Admin_Operate","USE") {
			w !,"Operation requires %Admin_Operate:Use privilege"
			q
		}
		i '$$ScreenForDatabasePrivilege(.resourcename) {
			w !,"Operation requires "_resourcename_":Read privilege"
			q
		}
		d ViewInt()
	} catch err {
		d $zu(115,8,oldprivmode),$zu(115,5,oldselectmode)
		w !!,"Unexpected error occurred: ",!,"  ",err.DisplayString()
	}
	d $zu(115,8,oldprivmode),$zu(115,5,oldselectmode)
}
	; Public subroutine to just display status summary loop
Status() PUBLIC {
	try {
		s oldselectmode=$zu(115,5,2),oldprivmode=$zu(115,8,0)	
		i '$system.Security.Check("%Admin_Operate","USE") {
			w !,"Operation requires %Admin_Operate:Use privilege"
			q
		}
		i '$$ScreenForDatabasePrivilege(.resourcename) {
			w !,"Operation requires "_resourcename_":Read privilege"
			q
		}
		s sys=$$GetSystem()
		q:'sys
		d ViewStatus(sys)
	} catch err {
		d $zu(115,8,oldprivmode),$zu(115,5,oldselectmode)
		w !!,"Unexpected error occurred: ",!,"  ",err.DisplayString()
	}
	d $zu(115,8,oldprivmode),$zu(115,5,oldselectmode)
}
Start() { 
	s sys=$$GetSystem() 
	q:'sys 
	s state=sys.GetState(.reason)
	i state'="Stopped" {
		w !,"Already started."
		q
	}
	s nextphasenum=sys.Workflow.NewPhaseNumber
	s:'nextphasenum nextphasenum=sys.Workflow.Phases.Next(sys.PhaseNumber)
	s:'nextphasenum nextphasenum=sys.Workflow.Phases.Next("")
	s timremain=sys.WorkflowTimeoutRemaining()
	w !!,"State:  ",state
	w:reason'=0 " due to "_##class(SYS.DataCheck.StateReason).LogicalToDisplay(reason)
	d ViewWorkflow(sys)
	i sys.Workflow.AbortCurrentPhase {
		w !,"DataCheck is set to abort the current phase and transition to phase #",nextphasenum,"."
		s offerrestart=(nextphasenum'=1)
	} elseif 'timremain {
		w !,"The workflow timeout has expired.  DataCheck will restart at phase #1."
		s offerrestart=0
	} elseif sys.Phase.%ClassName(1)="SYS.DataCheck.PhaseStop" {
		w !,"DataCheck will transition to phase #",nextphasenum,"."
		s offerrestart=(nextphasenum'=1)
	} else {
		w !,"DataCheck will resume processing where it left off."
		s offerrestart=1
	}
	i offerrestart {
		w !!,"You may enter RESTART to restart at phase #1"
		s askstring="Start Datacheck configuration '"_sys.Name_"'? (yes/no/restart)"
	} else {
		s askstring="Start Datacheck configuration '"_sys.Name_"'?"
	}
	f  {
		w !
		s yn="",rc=##class(%Library.Prompt).GetString(askstring,.yn,,,,8)
		q:(rc'=1)
		continue:yn=""
		s yn=$zcvt(yn,"U")
		i $e(yn,1,$l(yn))=$e("YES",1,$l(yn)) {
			Set sc=sys.Start(0) Throw:('sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc)
			w !,"Starting..."
			q
		}
		q:$e(yn,1,$l(yn))=$e("NO",1,$l(yn))
		i offerrestart && (yn="RESTART") { ; don't allow abbreviations of restart
			Set sc=sys.Start(1) Throw:('sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc)
			w !,"Restarting at phase #1..."
			q
		}
	}
}
Stop() { s sys=$$GetSystem() q:'sys  i $$GetStopped(sys)<0 { w !,"Already stopped." } }
New() {
	w !!,"You are creating a DataCheck destination configuration.  Each destination"
	w !,"configuration checks data on this system against one source system.  Multiple"
	w !,"configuration can be created to check against other sources, or to check a"
	w !,"different set of data on the same source.  Results of the check are stored here"
	w !,"on the destination.  You must enable the DataCheck service on the source."
	s mirrorname=""
	i $d(^SYS("MIRRORSET"))#2 {
		s failover='^SYS("MIRRORSET")
		s mirrorsets=$p(^SYS("MIRRORSET"),"^",2)
		i failover {
			s mirrorname=$p(mirrorsets,",")
			w !!,"This system is a failover member of mirror "_mirrorname_"."
			s yn=1,rc=##class(%Library.Prompt).GetYesNo("Are you configuring DataCheck to check this mirror?",.yn,,8)
			q:(rc'=1)
			i 'yn { s mirrorname="" }
		} else {
			f i=1:1:$l(mirrorsets,"^") { s list(i)=$p(mirrorsets,",",i) }
			i $d(list(2)) {
				w !!,"This system is an async member of multiple mirrors."
				s yn=1,rc=##class(%Library.Prompt).GetYesNo("Are you configuring DataCheck to check one of them?",.yn,,8)
				q:(rc'=1)
				i yn {
					s mirrorname="",rc=##class(%Library.Prompt).GetArray("Mirror:",.mirrorname,.list,,,,512+8+128+32)
					q:(rc'=1)||(mirrorname="")
				}
			} elseif $d(list) {
				s mirrorname=list(1)
				w !!,"This system is an async member of mirror "_mirrorname_"."
				s yn=1,rc=##class(%Library.Prompt).GetYesNo("Are you configuring DataCheck to check this mirror?",.yn,,8)
				q:(rc'=1)
				i 'yn { s mirrorname="" }
			}
		}
	}
	i mirrorname="" {
		; no mirror, or not checking mirror
		w !!,"When used to check the consistency of a shadowing system, this system"
		w !,"should also be the shadow destination system.",!
		while 1 {
			s name="",rc=##class(%Library.Prompt).GetString("Name of this DataCheck configuration:",.name,1,50,,8)
			q:(rc'=1)
			i ##class(SYS.DataCheck.System).NameIndexExists(name) {
				w !,"A configuration by that name already exists"
			} else { q }
		}
		q:(rc'=1)
		s sys=##class(SYS.DataCheck.Destination).%New(name,mirrorname)
		Set sc=sys.%Save() Throw:('sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc)
		d Setup(sys)
		q
	}
	; We are checking a mirror
	; get this member's name in the mirror
	Set sc=##class(Config.MirrorMember).Get(.info) Throw:('sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc)
	s thismembername=info("SystemName")
	; get list of mirror members
	s rs=##class(%Library.ResultSet).%New("Config.MapMirrors:List")
	Set sc=rs.%Execute(mirrorname) Throw:('sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc)
	f  {
		s atend='rs.%Next(.sc) i ('sc) { Throw ##class(%Exception.StatusException).ThrowIfInterrupt(sc) } q:atend
		continue:rs.%Get("Name")=thismembername
		s isfailover='rs.%Get("MemberType")
		s members('isfailover,$i(members('isfailover)))=rs.%Get("Name")
	}
	; Now, members(0) has the failover member names as second subscript
	;      members(1) is all the other members
	;      and this member is not in the array at all
	s sourcemember="",primarysourcerequirement=0
	i failover { ; I am a failover member
		i $d(members(0,1)) {
			s yn=1,rc=##class(%Library.Prompt).GetYesNo("Check against the other failover member, "_members(0,1)_"?",.yn,,8)
			q:(rc'=1)
			s:yn sourcemember=$lb(members(0,1))
		} else { 
			w !,"This is the only failover member"
		}
	} else { ; I am an async member 
		s yn=1
		s rc=##class(%Library.Prompt).GetYesNo("Do you want to check against the failover member(s)?",.yn,,8)
		q:(rc'=1)
		i yn {
			i $d(members(0,2)) {
				w !!,"You may create one (or more) DataCheck configurations for each of the failover"
				w !,"members, then choose to allow checking them concurrently, or restrict each"
				w !,"configuration to only check when that member is in the desired role."
				s yn=1,rc=##class(%Library.Prompt).GetYesNo("Create a DataCheck configuration for each failover member?",.yn,,8)
				q:(rc'=1)
				i yn {
					s sourcemember=$lb(members(0,1),members(0,2))
				} else {
					k list m list=members(0)
					s sourcemember="",rc=##class(%Library.Prompt).GetArray("Mirror member to check against:",.sourcemember,.list,,,,512+8+128+32)
					q:(rc'=1)
					q:sourcemember=""
					s sourcemember=$lb(sourcemember)
				}
			} elseif $d(members(0,1)) {
				s sourcemember=$lb(members(0,1))
			} else {
				w !,"No failover members found."
				q
			}
			s primarysourcerequirement=$$GetPrimarySourceRequirement()
			q:primarysourcerequirement=""
		}
	}
	i sourcemember="" { ; not checking against a failover member
		i '$d(members(1)) {
			w !!,"No other mirror members to check."
			q
		}
		i failover {
			w !!,"When checking between a failover member and an async member, it is"
			w !,"often better to use the async member as the DataCheck destination"
			w !,"instead; the results of the check would then be available on the"
			w !,"async member even if the source failover member is down."
			s yn=0,rc=##class(%Library.Prompt).GetYesNo("Continue?",.yn,,8)
			q:(rc'=1)||('yn)
		}
		k list m list=members(1)
		s sourcemember="",rc=##class(%Library.Prompt).GetArray("Mirror member to check against:",.sourcemember,.list,,,,512+8+128+32)
		q:(rc'=1)
		q:sourcemember=""
		s sourcemember=$lb(sourcemember)
		; since we're not checking the failover members, this shouldn't matter,
		; but if our source should happen to become the primary somehow, we
		; probably want to pause.
		s primarysourcerequirement=-1 
	}
	; Find an unused name of the form MIRRORNAME_SOURCEMEMBER_1 as a default choice of configuration name
	s ok=0,num=1
	while 'ok {
		s ok=1
		f i=1:1:$ll(sourcemember) {
			i ##class(SYS.DataCheck.System).NameIndexExists(mirrorname_"_"_$li(sourcemember,i)_"_"_num) { 
				s ok=0
				s num=num+1
				q
			}
		}
	}
	i $ll(sourcemember)>1 {
		; multiple DataCheck systems being created, display the list of names
		; and offer to change
		w !,"The following DataCheck configurations will be created"
		f i=1:1:$ll(sourcemember) { w !,"  "_mirrorname_"_"_$li(sourcemember,i)_"_"_num }
		s yn=0,rc=##class(%Library.Prompt).GetYesNo("Do you want to change the names?",.yn,,8)
		q:(rc'=1)
		i 'yn { 
			f i=1:1:$ll(sourcemember) { 
				s name=mirrorname_"_"_$li(sourcemember,i)_"_"_num
				s sys(i)=##class(SYS.DataCheck.Destination).%New(name,mirrorname)
			}
		} else {
			s i=1
			while (i<=$ll(sourcemember)) {
				s name="",rc=##class(%Library.Prompt).GetString("Name of DataCheck configuration for "_$li(sourcemember,i)_":",.name,1,50,,8)
				q:(rc'=1)
				i ##class(SYS.DataCheck.System).NameIndexExists(name) {
					w !,"A configuration by that name already exists"
					continue
				}
				s sys(i)=##class(SYS.DataCheck.Destination).%New(name,mirrorname)
				s i=i+1
			}
			q:(rc'=1)
		}
		f i=1:1:$ll(sourcemember) { 
			s sys(i).Configuration.SourceMirrorMember=$li(sourcemember,i)
			s sys(i).Configuration.PrimarySourceRequirement=primarysourcerequirement
			Set sc=sys(i).%Save() Throw:('sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc)
		}
	} else {
		; just one system, prompt for name with pre-selected default
		while 1 {
			s name=mirrorname_"_"_$li(sourcemember)_"_"_num
			s rc=##class(%Library.Prompt).GetString("Name of DataCheck configuration:",.name,1,50,,8)
			q:(rc'=1)
			i ##class(SYS.DataCheck.System).NameIndexExists(name) {
				w !,"A configuration by that name already exists"
			} else { q }
		}
		q:(rc'=1)
		s sys=##class(SYS.DataCheck.Destination).%New(name,mirrorname)
		s sys.Configuration.SourceMirrorMember=$li(sourcemember,i)
		s sys.Configuration.PrimarySourceRequirement=primarysourcerequirement
		Set sc=sys.%Save() Throw:('sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc)
		d Setup(sys)
	}
}	
Delete() {
	s sys=$$GetSystem() q:'sys
	q:'$$GetStopped(sys,1)
	s yn=0,rc=##class(%Library.Prompt).GetYesNo("Delete?",.yn,,8) 
	q:('yn)||(rc'=1)
	Set sc=sys.%DeleteId(sys.%Id()) Throw:('sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc)
}
Setup(sys) {
	i '$g(sys) { s sys=$$GetSystem() q:'sys }
	i sys.MirrorName="" {
		s list(1)="Import Settings from a Shadow"
		s list(2)="Connection Settings"
		s list(3)="Database Mappings"
		s list(4)="Globals to Check"
		s list(5)="Performance Settings"
		s list(6)="Manage Workflow"
		f  {
			s v="",rc=##class(%Library.Prompt).GetMenu("Option?",.v,.list,,128+8) q:rc'=1
			q:'v
			d Reload(sys)
			i v=1 d SetupShadowImport(sys) continue
			i v=2 d SetupConnection(sys) continue
			i v=3 d SetupDBXMap(sys) continue
			i v=4 d SetupGlobals(sys) continue
			i v=5 d SetupPerformance(sys) continue
			i v=6 d SetupWorkflow(sys) continue
		}
	} else {
		s list(1)="Globals to Check"
		s list(2)="Performance Settings"
		s list(3)="Manage Workflow"
		s list(4)="Change Mirror Settings (Advanced)"
		f  {
			s v="",rc=##class(%Library.Prompt).GetMenu("Option?",.v,.list,,128+8) q:rc'=1
			q:'v
			d Reload(sys)
			i v=1 d SetupGlobals(sys) continue
			i v=2 d SetupPerformance(sys) continue
			i v=3 d SetupWorkflow(sys) continue
			i v=4 d SetupMirror(sys) continue
		}
	}
}
SetupShadowImport(sys) {
	q:'$$GetStopped(sys,1)
	s shadowname="",rc=##class(%Library.Prompt).GetArray("Shadow name to import from:",.shadowname,$lb("SYS.Shadowing.Shadow:List"),,,,512+8+128)
	q:(shadowname="")||(rc'=1) 0 
	Set sc=sys.Configuration.ImportFromShadowDestination(shadowname) Throw:('sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc)
	d GetSaved(sys.Configuration)
}
SetupConnection(sys) {
	q:'$$GetStopped(sys,1)
	s host=sys.Configuration.Host
	s rc=##class(%Library.Prompt).GetString("IP or host name of source:",.host,,,,8)
	q:(host="")||(rc'=1) 0
	s sys.Configuration.Host=host
	s port=sys.Configuration.Port
	s rc=##class(%Library.Prompt).GetString("Port number of source:",.port,,,,8)
	q:(port="")||(rc'=1) 0
	s sys.Configuration.Port=port
	s yn=''$l(sys.Configuration.SSLConfig)
	s rc=##class(%Library.Prompt).GetYesNo("Use SSL?",.yn,,8) q:(rc'=1)
	i yn { ; use SSL
		s ssl=sys.Configuration.SSLConfig
		s rc=##class(%Library.Prompt).GetString("Name of SSL configuration to use:",.ssl,,,,8)
		q:(ssl="")||(rc'=1) 0
		s sys.Configuration.SSLConfig=ssl
	} else { ; no SSL
		s sys.Configuration.SSLConfig=""
	}
	d GetSaved(sys.Configuration)
}
SetupMirror(sys) {
	q:'$$GetStopped(sys,1)
	q:sys.MirrorName=""
	w !!,"The default mirror settings are selected when the DataCheck configuration"
	w !,"is created, and typically do not need to be changed."
	w !!,"Source Mirror Member: ",sys.Configuration.SourceMirrorMember
	s psr=$$GetPrimarySourceRequirement(sys.Configuration.PrimarySourceRequirement)
	q:psr=""
	s sys.Configuration.PrimarySourceRequirement=psr
	s yn=sys.Configuration.PauseCheckingBackupWhenNotActive
	w !!,"If the source or destination is the backup failover member and it is not"
	w !,"marked active, DataCheck can pause and wait for it to become active."
	s rc=##class(%Library.Prompt).GetYesNo("Pause?",.yn,,8) 
	q:(rc'=1)
	s sys.Configuration.PauseCheckingBackupWhenNotActive=yn
	d GetSaved(sys.Configuration)
}
SetupDBXMap(sys) {
	q:'$$GetStopped(sys,1)
	s list(1)="Add an entry"
	s list(2)="Delete an entry"
	s list(3)="List all entries"
	f  {
		s v="",rc=##class(%Library.Prompt).GetMenu("Option?",.v,.list,,128+8) q:rc'=1
		q:'v
		i v=1 d SetupDBXMapAdd(sys) continue
		i v=2 d SetupDBXMapDelete(sys) continue
		i v=3 d ViewDBXMap(sys) continue
	}
	d GetSaved(sys.Configuration)
}
SetupDBXMapAdd(sys) {
	s rs=##class(%Library.ResultSet).%New("SYS.DataCheck.Destination:SourceDatabases")
	s sc=rs.%Execute(sys.Name)
	i (''sc) {
		f i=1:1 {
			s atend='rs.%Next(.sc) i ('sc) { Throw ##class(%Exception.StatusException).ThrowIfInterrupt(sc) } q:atend
			s sourcelist(i)=rs.Directory
		}
	} else {
		s help(1)="Source database list unavailable due to error: "
		s help(2)=$system.Status.GetOneErrorText(sc)
	}
	f  {
		w !
		i $d(sourcelist) {
			s sourcedb="",rc=##class(%Library.Prompt).GetArray("Source Database (other system):",.sourcedb,.sourcelist,,,8)
		} else { 
			s sourcedb="",rc=##class(%Library.Prompt).GetString("Source Database (other system):",.sourcedb,,,.help,8)
		}
		q:((rc'=1)||(sourcedb=""))
		s destdb="",rc=##class(%Library.Prompt).GetArray("Destination Database (this system):",.destdb,$lb("SYS.Database:List","*"),,,8)
		q:((rc'=1)||(destdb=""))
		s destdb=##class(SYS.DataCheck.LocalDatabase).Normalize(destdb)
		i destdb="" {
			w !!,"Destination database specification is invalid"
			continue
		}
		i sys.Configuration.DBXMap.IsDefined(sourcedb) {
			w !!,"Source database "_sourcedb_" already has a mapping."
			w !,"This entry will not be added!"
			continue
		} 
		s found=0,key=""
		f  {
			s db=sys.Configuration.DBXMap.GetNext(.key)
			q:key=""
			i db=destdb {
				s found=1
				q
			}
		}
		i found {
			w !!,"Destination database "_destdb_" already has a mapping."
			w !,"This entry will not be added!"
			continue
		}
		d sys.Configuration.DBXMap.SetAt(destdb,sourcedb)
	}
}
SetupDBXMapDelete(sys) {
	f  {
		k array
		s sourcedb=""
		f i=1:1 {
			s destdb=sys.Configuration.DBXMap.GetNext(.sourcedb) q:sourcedb=""
			s array(i)=sourcedb_" -> "_destdb
		}
		s v="",rc=##class(%Library.Prompt).GetArray("Entry to delete:",.v,.array,,,,512+8+128)
		q:((rc'=1)||(v=""))
		d sys.Configuration.DBXMap.RemoveAt($p(v," -> ")) 
	}
}
SetupGlobals(sys) {
	; If global selection masks aren't enabled then there's nothing
	; to do except present the user with the option to enable them.
	d:'sys.RunParameters.UseGlobalSelectionMask SetupGlobalSelectionType(sys)
	; As long as they are enabled, present all the relevant options
	while sys.RunParameters.UseGlobalSelectionMask {
		k list
		s list(1)="Options for selecting globals to check"
		s list(2)="Set default include/exclude mask for databases with no mask defined"
		s list(3)="Add or remove include/exclude mask for databases"
		s list(4)="View include/exclude masks"
		i sys.RunParameters.UseGlobalSelectionRangeLists {
			s list(5)="Add/Edit Subscript Ranges for a Global"
			s list(6)="Delete All Subscript Ranges for a Global"
			s list(7)="Delete All Subscript Ranges"
			s list(8)="View Defined Subscript Ranges"
		}
		s v="",rc=##class(%Library.Prompt).GetMenu("Option?",.v,.list,,128+8) q:rc'=1
		q:'v
		i v=1 d SetupGlobalSelectionType(sys) continue
		i v=2 d SetupGlobalSelectionMaskDefault(sys) continue
		i v=3 d SetupGlobalSelectionMasks(sys) continue
		i v=4 d ViewGlobalSelectionMasks(sys) continue
		i sys.RunParameters.UseGlobalSelectionRangeLists {
			i v=5 d SetupGSRLAddEdit(sys) continue
			i v=6 d SetupGSRLDelete(sys) continue
			i v=7 d SetupGSRLDeleteAll(sys) continue
			i v=8 d ViewGSRL(sys) continue
		}
	}
}
SetupGlobalSelectionType(sys) {
	s list(1)="Check All Globals in All "_$s($l(sys.MirrorName):"Mirrored Databases",1:"Mapped Databases")
	s list(2)="Include/Exclude Some Globals/Databases"
	s list(3)="Include/Exclude Some Globals/Databases and Subscript Ranges"
	s (old,v)=$s(sys.RunParameters.UseGlobalSelectionRangeLists:3,sys.RunParameters.UseGlobalSelectionMask:2,1:1)
	s rc=##class(%Library.Prompt).GetMenu("Option?",.v,.list,,128+8) q:rc'=1
	s sys.RunParameters.UseGlobalSelectionMask=(v>1)
	s sys.RunParameters.UseGlobalSelectionRangeLists=(v=3)
	i (v>1) && (old=1) && (sys.RunParameters.GlobalSelectionMask.Count() || (sys.RunParameters.DefaultGlobalSelectionMask'="*")) {
		s keep=1
		s rc=##class(%Library.Prompt).GetYesNo("Some Include/Exclude Masks were previously defined.  Keep them?",.keep,,8)
		q:(rc'=1)
		i 'keep {
			Set sc=sys.RunParameters.GlobalSelectionMask.Clear() Throw:('sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc)
			set sys.RunParameters.DefaultGlobalSelectionMask="*"
		}
	}
	i (v=3) && (old<3) && $d(^SYS.DataCheck.RangeListD(sys.Name,"%GS")) {
		s keepgsrl=1
		s rc=##class(%Library.Prompt).GetYesNo("Some Include/Exclude Subscript Ranges were previously defined.  Keep them?",.keepgsrl,,8)
		q:(rc'=1)
		if 'keepgsrl {
			s rs=##class(%SQL.Statement).%ExecDirect(.sql,"SELECT ID FROM SYS_DataCheck.RangeList WHERE (SystemName = ?) AND (ListSet = ?)",sys.Name,"%GS")
			if (rs.%SQLCODE)<0 { Throw ##class(%Exception.StatusException).ThrowIfInterrupt($$Error^%apiOBJ(5521,rs.%SQLCODE,rs.%Message)) }
			f  {
				s atend='rs.%Next(.sc) i ('sc) { Throw ##class(%Exception.StatusException).ThrowIfInterrupt(sc) } q:atend
				Set sc=##class(SYS.DataCheck.RangeList).%DeleteId(rs.%Get("ID")) Throw:('sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc)
			}
		}
	}
	d GetSaved(sys.RunParameters) 	
}
SetupGlobalSelectionMaskDefault(sys) {
	s mask=sys.RunParameters.DefaultGlobalSelectionMask
	s:mask="" mask="*"
	s m=$$GetGlobalSelectionMask(mask,0)
	q:m=""
	s sys.RunParameters.DefaultGlobalSelectionMask=m
	d GetSaved(sys.RunParameters)
}
SetupGlobalSelectionMasks(sys) {
	s rs=##class(%Library.ResultSet).%New("SYS.DataCheck.Destination:DatabasesToCheck")
	f  {
		Set sc=rs.%Execute(sys.Name) Throw:('sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc)
		k list
		f i=1:1 {
			s atend='rs.%Next(.sc) i ('sc) { Throw ##class(%Exception.StatusException).ThrowIfInterrupt(sc) } q:atend
			s db=rs.%Get("Database")
			i rs.%Get("HasMaskDefined") {
				s defmask(db)=rs.%Get("Mask") ; if the mask is defined, it will be the default at the prompt to change (default to no change
			} else { s defmask(db)="" }       ; otherwise, don't specify a default (there's no reasonable guess we can make)
			s list(i)=db
			i $l(defmask(db)) {
				s list(i,0)=" ["_defmask(db)_"]"
			} else {
				s list(i,0)=" [no mask defined, use default]"
			}
		}
		i '$d(list) {
			w !,"No "_$s($l(sys.MirrorName):"Mirrored Databases",1:"Mapped Databases")
			q
		}
		s db="",rc=##class(%Library.Prompt).GetArray("Database (multiple selections allowed):",.db,.list,,,,512+8+128+64+1024)
		q:(rc'=1)
		q:db=""
		s m=$$GetGlobalSelectionMask($s($ll(db)>1:"",1:$g(defmask($li(db)))))
		continue:m=""
		f i=1:1:$ll(db) { 
			i m="!" {
				d sys.RunParameters.GlobalSelectionMask.RemoveAt($li(db,i))
			} else {
				d sys.RunParameters.GlobalSelectionMask.SetAt(m,$li(db,i))
			}
		}
	}
	d GetSaved(sys.RunParameters)
}
SetupGSRLAddEdit(sys) {
	s db=$$GetDatabase(sys) q:db=""
	s gn=$$GetGlobalName() q:gn=""
	i ##class(SYS.DataCheck.RangeList).MainIndexExists(sys.Name,"%GS",db,gn,.id) {
		s rl=##class(SYS.DataCheck.RangeList).%OpenId(id)
	} else {
		s rl=##class(SYS.DataCheck.RangeList).%New(sys.Name,"%GS",db,gn)
		w !,"There are no subscript ranges defined for this global."
		w !,"You may start by including all or excluding all subscripts."
		k include
		s rc=##class(%Library.Prompt).GetYesNo("Answer YES to include, NO to exclude:",.include,,8) 
		q:((rc'=1)||(include=""))
		d rl.Init($s(include:3,1:2))
		d rl.SetCollation()
	}
	s cachetoken=""
loop
	f  {
		w ! d rl.Output()
		s from=$$GetGlobalReference(gn,"From (inclusive): ") q:((from="")||(from=-1))
		s to=$$GetGlobalReference(gn,"To (exclusive): ") q:to=-1
		k include
		s rc=##class(%Library.Prompt).GetYesNo("Answer YES to include, NO to exclude:",.include,,8)
		q:((rc'=1)||(include=""))
		s cachetoken=rl.Insert(from,to,$s(include:3,1:2),cachetoken,.sc)
		i ('sc) { d $system.Status.DisplayError(sc) q }
	}
	s yn=1,rc=##class(%Library.Prompt).GetYesNo("Continue editing subscript ranges for this global?",.yn,,8)
	q:(rc'=1)
	g:yn loop
	w ! d rl.Output()
	d GetSaved(rl)
}
SetupGSRLDelete(sys) {
	s db=$$GetDatabase(sys) q:db=""
	s gn=$$GetGlobalName() q:gn=""
	i ##class(SYS.DataCheck.RangeList).MainIndexExists(sys.Name,"%GS",db,gn,.id) {
		Set sc=##class(SYS.DataCheck.RangeList).%DeleteId(id) Throw:('sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc)
	}
}
SetupGSRLDeleteAll(sys) {
	s yn=0,rc=##class(%Library.Prompt).GetYesNo("Are you sure you want to delete ALL global subscript ranges?",.yn,,8) 
	q:(rc'=1)
	i yn { 
		s rs=##class(%SQL.Statement).%ExecDirect(.sql,"SELECT ID FROM SYS_DataCheck.RangeList WHERE (SystemName = ?) AND (ListSet = ?)",sys.Name,"%GS")
		if (rs.%SQLCODE)<0 { Throw ##class(%Exception.StatusException).ThrowIfInterrupt($$Error^%apiOBJ(5521,rs.%SQLCODE,rs.%Message)) }
		f  {
			s atend='rs.%Next(.sc) i ('sc) { Throw ##class(%Exception.StatusException).ThrowIfInterrupt(sc) } q:atend
			Set sc=##class(SYS.DataCheck.RangeList).%DeleteId(rs.%Get("ID")) Throw:('sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc)
		}
	}
}
SetupPerformance(sys) {
	s ans=sys.RunParameters.Throttle
	s help(1)="Enter an integer between 1 and 10 to control how much of the system"
	s help(2)="resources (CPU, disk I/O, database cache) the DataCheck system may use."
	s help(3)="A value of 1 sets the system to use only a small amount of system"
	s help(4)="resources (only one process using significant CPU and disk I/O)."
	s help(5)="Higher values typically allow the system to perform checks faster"
	s help(6)="while being more detrimental to the performance of other jobs.  A" 
	s help(7)="value of 10 sets the DataCheck system to use as much of the system"
	s help(8)="resources as possible."
	s rc=##class(%Library.Prompt).GetNumber("Throttle (1-10):",.ans,1,10,.help,8)
	q:(ans="")||(rc'=1) 0
	s sys.RunParameters.Throttle=ans
	s ans=sys.RunParameters.MinimumQuerySize
	k help
	s help(1)="The granularity, in number of global nodes, with which the system will"
	s help(2)="isolate discrepant global subscript ranges.  A value of 1 means"
	s help(3)="discrepancies will be isolated to a single global node.  Higher values"
	s help(4)="allow much better performance through discrepant ranges.  It is "
	s help(5)="recommended to set this to a number of global nodes that can be"
	s help(6)="visually inspected with relative ease (if the discrepancy proves to "
	s help(7)="not be transient after recheck attempts)." 
	s rc=##class(%Library.Prompt).GetNumber("Minimum Query Size:",.ans,1,,.help,8)
	q:(rc'=1) 0
	s sys.RunParameters.MinimumQuerySize=ans
	d GetSaved(sys.RunParameters)
}
SetupWorkflow(sys) {
	d ViewWorkflow(sys)
	s yn=0,rc=##class(%Library.Prompt).GetYesNo("Modify workflow phases?",.yn,,8) 
	q:(rc'=1)
	i yn {
		s rs=##class(%Library.ResultSet).%New("%Dictionary.ClassDefinitionQuery:SubclassOf")
		Set sc=rs.%Execute("SYS.DataCheck.Phase") Throw:('sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc)
		f i=1:1 {
			s atend='rs.%Next(.sc) i ('sc) { Throw ##class(%Exception.StatusException).ThrowIfInterrupt(sc) } q:atend
			s list(i)=$s(($e(rs.%Get("Name"),1,$l("SYS.DataCheck.Phase"))="SYS.DataCheck.Phase"):$e(rs.%Get("Name"),$l("SYS.DataCheck.Phase")+1,*),1:rs.%Get("Name"))
			s list(i,0)=" - "_$classmethod(rs.%Get("Name"),"%GetParameter","SHORTDESCRIPTION")
		}
		Set sc=sys.Workflow.Phases.Clear() Throw:('sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc)
		s flags=128+8
		f i=1:1 {
			s v="",rc=##class(%Library.Prompt).GetArray("Phase "_i_":",.v,.list,,,,flags) 
			q:(v="")||(rc'=1)
			s phase=$classmethod($s(v[".":v,1:"SYS.DataCheck.Phase"_v),"%New")
			s properties=phase.#SETUPPROPERTIES
			f j=1:1 {
				s p=$p(properties,",",j) q:p=""
				s pv=$property(phase,p)
				s rc=##class(%Library.Prompt).GetString("  "_p_":",.pv,,,,8) 
				q:rc'=1
				s $property(phase,p)=pv
			}
			Set sc=sys.Workflow.Phases.Insert(phase) Throw:('sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc)
			s flags=8+512
		}
		q:'sys.Workflow.Phases.Count()
	}
	; If the user modified the workflow phases, we always want
	; them to specify a new next phase, otherwise ask
	i 'yn {
		s yn=0,rc=##class(%Library.Prompt).GetYesNo("Specify new phase number to start?",.yn,,8) 
		q:(rc'=1)
	}
	i yn {
		s rc=##class(%Library.Prompt).GetNumber("New phase number (after current phase):",.ans,1,sys.Workflow.Phases.Count(),,8) 
		q:(rc'=1)
		s sys.Workflow.NewPhaseNumber=ans
	}
	s abort=0,rc=##class(%Library.Prompt).GetYesNo("Abort current phase?",.abort,,8) 
	q:(rc'=1)
	s sys.Workflow.AbortCurrentPhase=abort
	k help
    s help(1)="If DataCheck becomes stopped, disconnected, or paused (waiting for"
	s help(2)="mirroring) in the middle of the check, then upon returning to the running"
	s help(3)="state, it would normally resume the current phase from where it left off."
	s help(4)="If the system returns to the running state only after an extended period"
	s help(5)="it may be more desireable to restart from the first phase."
	s help(7)=""
	s help(8)="Enter the time, in seconds, within which DataCheck may resume a partially"
	s help(9)="completed phase.  If this timeout is exceeded, it will restart from phase"
	s help(10)="number one.  Enter 0 to always resume, never restart.  Default of five"
	s help(11)="days (432000) assumes that this configuration will check a large amount"
	s help(12)="of data and may take hours or days to complete normally.  A smaller value"
	s help(13)="may be desired for configurations that complete more quickly."
	s ans=+sys.Workflow.Timeout,rc=##class(%Library.Prompt).GetNumber("Workflow Timeout:",.ans,0,,.help,8)
	q:(rc'=1)
	s sys.Workflow.Timeout=ans
	w !
	d ViewWorkflow(sys)	
	try {
		d GetSaved(sys.Workflow)
	} catch err {
		i err.Code=5800 {
			w !,"Save failed because workflow was modified by the system - please retry"
		} else { throw err }
	}	
}
ViewInt(sys) {
	s sys=$$GetSystem()
	q:'sys
	s list(1)="View Status"
	s list(2)="View Results"
	s list(3)="View Queries"
	s list(4)="View Log"
	f  {
		s v="",rc=##class(%Library.Prompt).GetMenu("Option?",.v,.list,,128+8)
		q:(v="")||(rc'=1)
		d Reload(sys)
		i v=1 d ViewStatus(sys) continue
		i v=2 d { d ViewResults(sys,.again) } while (again) continue
		i v=3 d ViewQueries(sys) continue
		i v=4 d ViewLog(sys) continue
	}
}
ViewStatus(sys) {
	s (lastdstm,lastsrcm,err)=""
	s refresh=$s(5>10:5,1:10)
	try {
		f  {
			d Reload(sys)
			w !!, "--- Status of Configuration '",sys.Name,"' on "_$zdt($h)," ---",!
			i $l(sys.MirrorName) { 
				w !,"Mirror: ",sys.MirrorName,"  Source Member: ",sys.Configuration.SourceMirrorMember
			} else { 
				w !,"Source: ",sys.Configuration.Host,":",sys.Configuration.Port
				i $l(sys.Configuration.SSLConfig) w !,"Using SSL Config: ",sys.Configuration.SSLConfig
			}
			s queries=sys.Stats.PhaseQueries-sys.Stats.PhaseQueriesDeleted+sys.Stats.PhaseQueriesSplit
			s state=sys.GetState(.reason)
			w !,"State:  ",state
			w:reason'=0 " due to "_##class(SYS.DataCheck.StateReason).LogicalToDisplay(reason)
			w !
			d ViewWorkflow(sys)
			w !,"Throttle: ",sys.RunParameters.Throttle
			i state="Running" {
				s srcm=sys.GetSourceWorkerMetrics(1,.device)
				s dstm=sys.GetWorkerMetrics()
				s zh=$zh
				i $l(lastdstm) && $l(lastsrcm) && $l(dstm) && $l(srcm) {
					w !,"Worker job metrics over current refresh interval:"
					s dt=zh-lastzh
					f i=2:1:4 { 
						s $li(lastsrcm,i)=$li(srcm,i)-$li(lastsrcm,i)/dt
						i $li(lastsrcm,i)<0 s $li(lastsrcm,i)=0
						s $li(lastdstm,i)=$li(dstm,i)-$li(lastdstm,i)/dt
						i $li(lastdstm,i)<0 s $li(lastdstm,i)=0
					}
					w !,"               #Jobs   global nodes/s   #CPUs utlzd   phys rds/s"
					w !,"       source ",$j($li(lastsrcm,1),6),$j($li(lastsrcm,3),17,0),$j($li(lastsrcm,2),14,2),$j($li(lastsrcm,4),13,2)
					w !,"  destination ",$j($li(lastdstm,1),6),$j($li(lastdstm,3),17,0),$j($li(lastdstm,2),14,2),$j($li(lastdstm,4),13,2)
				} else {
					w !,"Worker job metrics will be displayed on refresh"
				}			
				s lastdstm=dstm,lastsrcm=srcm,lastzh=zh
			} else { s (lastdstm,lastsrcm)="" }
			w !
			i sys.Stats.HasPhaseCounts() {
				w !,"Queries Completed This Phase: ",sys.Stats.PhaseQueriesCompleted,"/",queries
				w:queries " (",sys.Stats.PhaseQueriesCompleted/queries*100\1,"%)"
				w !,"Discrepancies Recorded This Phase: ",sys.Stats.PhaseDiscrepanciesRecorded
			}
			w !,"Answers Rcvd (since check started): ",sys.Stats.QueriesMatched," Matched, ",sys.Stats.QueriesUnmatched, " Unmatched"
			try {
				w !!,"Press RETURN to refresh, Q to quit, or specify refresh interval <",refresh,"> "
				s intv=0
				r intv:refresh
			} catch { s intv="q" }
			s:+intv refresh=intv
			q:($e(intv)="q")||($e(intv)="Q")
			w !
		}
	} catch err {}
	if $g(device)'="" { close device }
	throw:$isobject(err) err
}
ViewResults(sys,restart) {
	s restart=0
	s set=##class(SYS.DataCheck.RangeList).GetActiveResultsListSet(sys.Name)
	i ##class(SYS.DataCheck.RangeList).GetListSetStartTime(sys.Name,set)="" {
		w !!,"No results exist yet"
		q
	}
	s list(1)="Active Results"
	s list(1)=list(1)_"  ("_$zdt(##class(SYS.DataCheck.RangeList).GetListSetStartTime(sys.Name,set),3)_" - "_$s(##class(SYS.DataCheck.RangeList).GetListSetEndTime(sys.Name,set):$zdt(##class(SYS.DataCheck.RangeList).GetListSetEndTime(sys.Name,set),3),1:"present")_")"
	i ##class(SYS.DataCheck.RangeList).GetListSetStartTime(sys.Name,set-1)'="" {
		s list(2)="Last Completed Results"
		s list(2)=list(2)_"  ("_$zdt(##class(SYS.DataCheck.RangeList).GetListSetStartTime(sys.Name,set-1),3)_" - "_$s(##class(SYS.DataCheck.RangeList).GetListSetEndTime(sys.Name,set-1):$zdt(##class(SYS.DataCheck.RangeList).GetListSetEndTime(sys.Name,set-1),3),1:"present")_")"
	}
	s v="",rc=##class(%Library.Prompt).GetMenu("Which set would you like to view?",.v,.list,,128+8) 
	q:((rc'=1)||(v=""))
	s listset=$case(v,1:set,2:set-1)
	s discrepancies=0,rc=##class(%Library.Prompt).GetYesNo("Skip globals that matched between source and destination?",.discrepancies,,8) 
	q:(rc'=1)
	s details=1,rc=##class(%Library.Prompt).GetYesNo("View detailed subscript ranges?",.details,,8) 
	q:(rc'=1)
	s device="",rc=##class(%Library.Device).Get("Device:",.device,,8+4,,4)
	q:rc'=1
	try {
		s starth=##class(SYS.DataCheck.RangeList).GetListSetStartTime(sys.Name,listset)
		s endh=##class(SYS.DataCheck.RangeList).GetListSetEndTime(sys.Name,listset)
		i starth="" {
			w !!,"The results for that time period have been purged."
			w !,"Please select again."
			s restart=1
			q
		}
		u device
			w !,"DataCheck Destination System: ",sys.Name
			w !,"Results for check started: ",$zdt(starth,3)
		i endh {
			w !,"                    ended: ",$zdt(endh,3)
		} else {
			w !,"         unfinished as of: ",$zdt($h,3)
		}
		w !!
		i details {
			s q="SELECT ID"
		} else {
			s q="SELECT Database,GlobalName,AggregateState"
		}
		s q=q_" FROM SYS_DataCheck.RangeList WHERE (SystemName = ?) AND (ListSet = ?)"
		s:discrepancies q=q_" AND (AggregateState <> '"_##class(SYS.DataCheck.RangeState).LogicalToDisplay(1)_"')" 
		s q=q_" ORDER BY Database, GlobalName"
		s rs=##class(%SQL.Statement).%ExecDirect(.sql,q,sys.Name,listset)
		if (rs.%SQLCODE)<0 { Throw ##class(%Exception.StatusException).ThrowIfInterrupt($$Error^%apiOBJ(5521,rs.%SQLCODE,rs.%Message)) }
		i details {
			s detailcount=0
			f  {
				s atend='rs.%Next(.sc) i ('sc) { Throw ##class(%Exception.StatusException).ThrowIfInterrupt(sc) } q:atend
				s detailcount=detailcount+1
				d ##class(SYS.DataCheck.RangeList).%OpenId(rs.ID).Output()
			}
			w !,detailcount," Globals Reported" 
		} else {
			d rs.%Display()
		}
		i ##class(SYS.DataCheck.RangeList).GetListSetStartTime(sys.Name,listset)="" {
			w !,"*** WARNING: The results were purged while this report was running."
			w !,"             This report is unreliable and should be regenerated."
			i $i'=$p {
				u 0
				w !!,"*** WARNING: The results were purged while this report was running."
				w !,"             This report is unreliable and should be run again."
			}	
			s restart=1
		}
	} catch err {
		c device
		throw err
	}
	c device
}
ViewLog(sys) {
	s ans=100,rc=##class(%Library.Prompt).GetNumber("Number of most recent log entries to display",.ans,1,,,8)
	q:(rc'=1) 0
	s rs=##class(%SQL.Statement).%ExecDirect(.sql,"SELECT LogDate,LogTime,Pid,JobType,LogType,Message FROM SYS_DataCheck.LogEntry WHERE SystemName = ? AND Number > ? ORDER BY Number",sys.Name,$g(^SYS.DataCheck(sys.Name,"EventCount"))-ans)
	if (rs.%SQLCODE)<0 { Throw ##class(%Exception.StatusException).ThrowIfInterrupt($$Error^%apiOBJ(5521,rs.%SQLCODE,rs.%Message)) }
	w !! d rs.%Display()	
}
ViewQueries(sys) {
	s yn=0,rc=##class(%Library.Prompt).GetYesNo("Display active queries only?",.yn,,8) 
	q:rc'=1
	i yn {
		s q="SELECT Database,InitialRef,TargetRef,Num FROM SYS_DataCheck.Query WHERE (SystemName = ?) AND (Active = 1) ORDER BY ID"
	} else {
		s q="SELECT Database,InitialRef,TargetRef,Num,Active FROM SYS_DataCheck.Query WHERE (SystemName = ?) ORDER BY ID"
	}
	s rs=##class(%SQL.Statement).%ExecDirect(.sql,q,sys.Name)
	if (rs.%SQLCODE)<0 { Throw ##class(%Exception.StatusException).ThrowIfInterrupt($$Error^%apiOBJ(5521,rs.%SQLCODE,rs.%Message)) }
	w !! d rs.%Display()
}
ViewDBXMap(sys) {
	w !,"Database Mappings"
	w !,"  Source Database (other system) -> Destination Database (this system)"
	s sourcedb=""
	f i=1:1 {
		s destdb=sys.Configuration.DBXMap.GetNext(.sourcedb) q:sourcedb=""
		s str="  "_sourcedb_" -> "_destdb
		w !,str
	}
}
ViewWorkflow(sys) {
	w !,"Current Phase: ",sys.PhaseNumber," - ",sys.Phase.%GetInfoString(1)
	w !,"Workflow Phases:"
	s wf=sys.Workflow,key=""
	f  {
		s phase=wf.Phases.GetNext(.key) q:key=""
		w !,"  ",key," - ",phase.%GetInfoString(0)
	}
	w !,"  (restart)"
	s remaining=sys.WorkflowTimeoutRemaining()
	w !,"Workflow Timeout: ",wf.Timeout,$s(remaining<0:"",'remaining:" (expired)",1:" ("_remaining_" seconds remaining)")
	w:wf.NewPhaseNumber !,"New Phase Requested: ",wf.NewPhaseNumber
	w:wf.AbortCurrentPhase !,"Abort Current Phase Requested"
	w !
}
ViewGSRL(sys) {
	s device="",rc=##class(%Library.Device).Get("Device:",.device,,8+4,,4)
	q:rc'=1
	try {
		u device
		w !,"DataCheck Destination System: ",sys.Name
		w !,"Global Selection Subscript Ranges"
		w !!
		s q="SELECT ID FROM SYS_DataCheck.RangeList WHERE (SystemName = ?) AND (ListSet = ?) ORDER BY Database, GlobalName"
		s rs=##class(%SQL.Statement).%ExecDirect(.sql,q,sys.Name,"%GS")
		if (rs.%SQLCODE)<0 { Throw ##class(%Exception.StatusException).ThrowIfInterrupt($$Error^%apiOBJ(5521,rs.%SQLCODE,rs.%Message)) }
		f  {
			s atend='rs.%Next(.sc) i ('sc) { Throw ##class(%Exception.StatusException).ThrowIfInterrupt(sc) } q:atend
			d ##class(SYS.DataCheck.RangeList).%OpenId(rs.ID).Output()
		}
		c device
	} catch err {
		c device
		throw err
	}
}
ViewGlobalSelectionMasks(sys) {
	s rs=##class(%Library.ResultSet).%New("SYS.DataCheck.Destination:DatabasesToCheck")
	Set sc=rs.%Execute(sys.Name) Throw:('sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc)
	w !,"The default include/exclude mask is: "
	w !,"    ",sys.RunParameters.DefaultGlobalSelectionMask,!
	w !,"The following databases are using non-default global selection criteria",!
	f  {
		s atend='rs.%Next(.sc) i ('sc) { Throw ##class(%Exception.StatusException).ThrowIfInterrupt(sc) } q:atend
		i ('rs.%Get("HasMaskDefined")) && ('rs.%Get("HasSubscriptRanges")) {
			continue
		} 
		w !,"  "_rs.%Get("Database")
		i 'rs.%Get("HasMaskDefined") {
			w !,"    Default mask, but has global subscript ranges to include/exclude"
			w !,"    that apply regardless of whether they are included in this mask."
		} elseif rs.%Get("HasSubscriptRanges") {
			w !,"    Has global subscript ranges to include/exclude that apply"
			w !,"    regardless of whether those globals are included in this mask."
		}
		i rs.%Get("Directory")="" {
			i sys.MirrorName="" {
				w !,"   !! Database has global selection criteria defined but does not have a"
				w !,"      DataCheck mapping configured.  This database will be skipped."
			} else {
				w !,"   !! Database has global selection criteria defined but is not found in"
				w !,"      the mirror; will be skipped if not found during a check."
			}
		}
		w !,"    ",rs.%Get("Mask")
	}
}
Source() {
	s list(1)="List Source Systems"
	s list(2)="View Log"
	f  {
		s v="",rc=##class(%Library.Prompt).GetMenu("Option?",.v,.list,,128+8) q:rc'=1
		q:'v
		s rs=##class(%SQL.Statement).%ExecDirect(.sql,"SELECT Name,DestinationHost,DestinationName,SYS_DataCheck.System_GetStateBySystem(Name) as State FROM SYS_DataCheck.Source")
		if (rs.%SQLCODE)<0 { Throw ##class(%Exception.StatusException).ThrowIfInterrupt($$Error^%apiOBJ(5521,rs.%SQLCODE,rs.%Message)) }
		i v=1 {
			w !!
			d rs.%Display()
			continue
		}
		k array
		s cnt=0
		f  {
			s atend='rs.%Next(.sc) i ('sc) { Throw ##class(%Exception.StatusException).ThrowIfInterrupt(sc) } q:atend
			s array($i(cnt))=rs.Name
			s array(cnt,0)=" ("_rs.DestinationHost_"/"_rs.DestinationName_"/"_rs.State_")"
		}
		i 'cnt {
			w !!,"No source systems found"
			continue
		} elseif cnt=1 { ; auto-select 
			s name=array(1)
			w !!,"Source System: "_name
		} else { ; prompt
			s name="",rc=##class(%Library.Prompt).GetArray("Source System:",.name,.array,,,,512+8+128)
		    i (rc'=1) || (name="") continue
		}
		s sys=##class(SYS.DataCheck.Source).%OpenId(name)
		i v=2 d ViewLog(sys) continue
	}
}
	; Prompts for a system name and returns an oref to it or null if none selected
GetSystem() {
	s cnt=0
	s rs=##class(%SQL.Statement).%ExecDirect(.sql,"SELECT Name FROM SYS_DataCheck.Destination")
	if (rs.%SQLCODE)<0 { Throw ##class(%Exception.StatusException).ThrowIfInterrupt($$Error^%apiOBJ(5521,rs.%SQLCODE,rs.%Message)) }
	f  {
		s atend='rs.%Next(.sc) i ('sc) { Throw ##class(%Exception.StatusException).ThrowIfInterrupt(sc) } q:atend
		s array($i(cnt))=rs.%Get("Name") 
	}
	i 'cnt { 
		w !!,"No destination configuration defined"
		s name="" 
	} elseif cnt=1 { ; auto-select the only system defined
		s name=array(1) 
		w !!,"Configuration Name: "_name
	} else { ; prompt
		s name="",rc=##class(%Library.Prompt).GetArray("Configuration Name:",.name,.array,,,,512+8+128)
		s:(rc'=1) name=""
	}
	i $l(name) {
		s sys=##class(SYS.DataCheck.Destination).%OpenId(name)
		d Reload(sys)
		q sys
	}
	q ""
}
	; Takes as argument an oref for a destination system
	; Checks that the system is stopped and offers the user to stop it if not.
	; Returns true if stopped (-1 if already stopped), false otherwise.
	; Errors are thrown to the caller.
GetStopped(sys,required=0) {
	i sys.GetState()'="Stopped" {
		w:required !,"This action cannot be performed while the configuration is running"
		s yn=0,rc=##class(%Library.Prompt).GetYesNo("Stop DataCheck configuration '"_sys.Name_"'?",.yn,,8) 
		q:('yn)||(rc'=1) 0 
		w !,"Stopping DataCheck.  This may take several seconds..."
		Set sc=sys.Stop() Throw:('sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc)
		f i=1:1:30 { q:sys.GetState()="Stopped"  h 1 }
		i sys.GetState()'="Stopped" {	w !,"The configuration has not responded to stop request" q 0 }
		s ret=1
		d Reload(sys)
	} else { s ret=-1 }
	q ret
}
	; Takes as argument an oref, and if modified asks the user to save it
	; Returns -1 if not modified, 1 if modified and saved, or 0 if the user
	; chose not to save.
	; Errors are thrown to the caller
GetSaved(obj) {
	i obj.%IsModified() {
		s yn=1,rc=##class(%Library.Prompt).GetYesNo("Save changes?",.yn,,8)
		i ('yn)||(rc'=1) {
			i obj.%Id()'="" { Set sc=obj.%Reload() Throw:('sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc) }
			q 0	
		}
		Set sc=obj.%Save() Throw:('sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc)
		q 1
	}
	q -1
}
	; Prompts for a local database from the list of databases to check
GetDatabase(sys) {
	s rs=##class(%Library.ResultSet).%New("SYS.DataCheck.Destination:DatabasesToCheck")
	Set sc=rs.%Execute(sys.Name) Throw:('sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc)
	f i=1:1 {
		s atend='rs.%Next(.sc) i ('sc) { Throw ##class(%Exception.StatusException).ThrowIfInterrupt(sc) } q:atend
		s list(i)=rs.%Get("Database")
	}
	i '$d(list) {
		w !,"No "_$s($l(sys.MirrorName):"Mirrored Databases",1:"Mapped Databases")
		q ""
	}
	s db="",rc=##class(%Library.Prompt).GetArray("Database:",.db,.list,,,,512+8+128+64)
	q:(rc'=1) ""
	q db
}
	; Prompts for a global name and returns it normalized or null on error
GetGlobalName() {
	s name="",rc=##class(%Library.Prompt).GetString("Global Name:",.name,,,,8)
	q:(name="")||(rc'=1) ""
	s sc=##class(SYS.DataCheck.GlobalReference).IsValid(name,.norm)
	i 'sc { 
		w !,"Error: Invalid global name"
		q ""
	}
	q ##class(SYS.DataCheck.GlobalReference).GlobalName(norm)
}
	; Prompts for a global reference for a given global name and returns it normalized or -1 on error.
GetGlobalReference(globalname,text="Global Reference:") {
	s help(1)="Enter a global reference with or without subscripts or null for end."
	s help(2)="The leading ^ may be omitted.  For subscripted references the entire"
	s help(3)="global name may be omitted and simply begin with open parentheses"
	s globalname=##class(SYS.DataCheck.GlobalReference).GlobalName(globalname)
	s gloref="",rc=##class(%Library.Prompt).GetString(text,.gloref,,,.help,8)
	q:(rc'=1) -1
	q:gloref="" ""
	s:$e(gloref)="(" gloref=globalname_gloref
	s sc=##class(SYS.DataCheck.GlobalReference).IsValid(gloref,.norm)
	i 'sc { 
		w !,"Error: Invalid global reference" 
		q -1
	}
	i ##class(SYS.DataCheck.GlobalReference).GlobalName(norm)'=globalname {
		w !,"Error: Global name does not match"
		q -1	
	}
	q norm
}
GetGlobalSelectionMask(default="*",allowdelete=1) {
	s maskhelp( 1)="A mask, or comma-separated list of masks, to select global names."
	s maskhelp( 2)="Subscripts are not allowed.  * is all globals, '* no globals."
	s maskhelp( 3)="The * wildcard as the last character means all globals starting"
	s maskhelp( 4)="with the preceding characters.  The ' character before a mask"
	s maskhelp( 5)="indicates globals to be excluded."
	s maskhelp( 6)=""
	s maskhelp( 7)="Examples:"
	s maskhelp( 8)="  * - All globals"
	s maskhelp( 9)="  '* - No globals"
	s maskhelp( 8)="  ABC* - All global names starting with ABC"
	s maskhelp( 9)="  A:D - All global names between A and D"
	s maskhelp(10)="  A:D,Y* - All global names between A and D, and starting with Y"
	s maskhelp(11)="  *,'C*,'D* - All globals except those starting with C or D"
	s m=default
tryagain
	w !,"Enter a mask string, * to include all, '* to exclude all, ? for help"
	w:allowdelete !,"                     ! to delete this mask and revert to default"
	s rc=##class(%Library.Prompt).GetString("Mask:",.m,,,.maskhelp,8)
	i (rc'=1) { q "" }
	i allowdelete && (m="!") {
		q m
	}
	i (m["(") || (m[")") || (m["!") {
		w !,"Invalid Mask"
		g tryagain
	}
	q m
}
GetPrimarySourceRequirement(default=0) {
	s list(1)="Check primary only (pause until DataCheck source is primary)"
	s list(2)="Do not check primary (pause when DataCheck source is primary)"
	s list(3)="No restriction"
	s v=$case(default,"":"",1:1,-1:2,0:3)
	s rc=##class(%Library.Prompt).GetMenu("Option?",.v,.list,,128+8) 
	q:rc'=1 ""
	q $case(v,"":"",1:1,2:-1,3:0)
}
	; Reload the destination system and all referenced objects.
	; Each reference object must be loaded explicitly in case there
	; is another oref held by the caller of ^DATACHECK.
Reload(sys) {
	Set sc=sys.%Reload() Throw:('sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc)
	Set sc=sys.Workflow.%Reload() Throw:('sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc)
	Set sc=sys.RunParameters.%Reload() Throw:('sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc)
	Set sc=sys.Configuration.%Reload() Throw:('sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc)
	Set sc=sys.Stats.%Reload() Throw:('sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc)
}
	; Performs some incomplete screening to check whether this user seems
	; to have access to the database containing the ^SYS.DataCheck* globals.
	; Returns 0 for no access, 1 for read access and 2 for write access.
	; Upon returning 0, the 'resourcename' parameter, if passed by reference,
	; will be set to the database resource name that requires permission. 
	; The return value does not guarantee anything about the user's access
	; to all of ^SYS.DataCheck* global nodes that may be required to use this
	; utility because global mappings may be arbitrarily complex.  This 
	; screening is used only to display a message when access is limited
	; rather than simply letting the utility fail with <PROTECT> errors
ScreenForDatabasePrivilege(resourcename) PUBLIC {
	s db=##class(%SYS.Namespace).GetGlobalDest(,"^SYS.DataCheck.SystemD")
	i $p(db,"^")'="" q 2
	s resourcename=##class(SYS.Database).%OpenId($p(db,"^",2)).ResourceName
	q:$system.Security.Check(resourcename,"WRITE") 2
	q:$system.Security.Check(resourcename,"READ") 1
	q 0
}

DATAMOVE^INT^1^67214,47330
DATAMOVE
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 n
MENU s $zt="MENUE"
 s Status=##Class(DataMove.Data).CheckDMStorageDir()
 i '(''Status) {
	w !,$System.Status.DisplayError(Status)	 
	q
 }
 w !
 w !,"1) Monitor DataMove"
 w !,"2) Edit settings"
 w !,"3) Exit"
 w !
 s Option=$$OPTION("Option? ",3,3)
 i Option=1 d MONITOR1 g MENU
 i Option=2 d SETTINGS g MENU
 q
MENUE s $zt=""
 i $ze'["<INTERRUPT>" w !,"ERROR: "_$ZE
 q
SETTINGS() {
 s $zt="Error"
 s DM=##Class(DataMove.Defaults).Open()
 w !
 w !,"Setting the maximum number of MB DataMove is allowed to copy per minute"
 w !,"to 0 means that DataMove will copy the data as fast as it can. Changing this"
 w !,"setting will apply the new value to future DataMoves, and optionally any"
 w !,"currently running DataMoves. You can also change this setting through"
 w !,"the 'Metrics' display screen for a running DataMove without changing"
 w !,"the system default."
 w !
 s ApplyToDM=0
 s MaxMBPerMin=DM.MaxMBPerMin
 s DM.MaxMBPerMin=$$NUMOPTION("Maximum number of MB to copy per minute",DM.MaxMBPerMin,0,1000000000)
 i MaxMBPerMin'=DM.MaxMBPerMin {
 	i $$YN("Do you want to apply this change to existing DataMoves","Y")="Y" {
	 	s ApplyToDM=1
 	} else {
		s ApplyToDM=0
 	}
 }
 w !
 w !,"Setting the maximum number of MB DataMove DataCheck is allowed to check per"
 w !,"minute to 0 means that DataMove DataCheck will ccheck the data as fast as it"
 w !,"can. Changing this setting will apply the new value to future DataMoves, and"
 w !,"optionally any currently running DataMoves. You can also change this setting"
 w !,"through the 'Metrics' display screen for a running DataMove DataCheck without"
 w !,"changing the system default."
 w !
 s ApplyCheckToDM=0
 s MaxMBCheckPerMin=DM.MaxMBCheckPerMin
 s DM.MaxMBCheckPerMin=$$NUMOPTION("Maximum number of MB to check per minute",DM.MaxMBCheckPerMin,0,1000000000)
 i MaxMBCheckPerMin'=DM.MaxMBCheckPerMin {
 	i $$YN("Do you want to apply this change to existing DataMoves","Y")="Y" {
	 	s ApplyCheckToDM=1
 	} else {
		s ApplyCheckToDM=0
 	}
 }
Save
 i $$YN("Confirm changes","Y")="N" q
 s Status=DM.%Save()
 i '(''Status) {
	d $SYSTEM.Status.DisplayError(Status)
 } else {
	i ApplyToDM {
		k Properties
		s Properties("MaxMBPerMin")=DM.MaxMBPerMin
 		Set Rset = ##class(%Library.ResultSet).%New("DataMove.API:ListDMs")
 		s Status=Rset.Execute("*",0)
		While Rset.Next() {
			i Rset.Data("State")<7 /*CopyDone*/ d ##Class(DataMove.API).Modify(Rset.Data("Name"),.Properties)
		}
	} 
	i ApplyCheckToDM {
		s Properties("MaxMBCheckPerMin")=DM.MaxMBCheckPerMin
 		Set Rset = ##class(%Library.ResultSet).%New("DataMove.API:ListDMs")
 		s Status=Rset.Execute("*",0)
		While Rset.Next() {
			d ##Class(DataMove.API).Modify(Rset.Data("Name"),.Properties)
		}
	} 
	w !,"DataMove settings updated"
 }	 
 q
Error s $zt=""
 i $ze'["<INTERRUPT>" w !,"ERROR: "_$ZE
 q
}
MONITOR1
 f i=1:1:24 w !
 d MONITOR("*")
 q
MONITOR(Names) Public {
 s $zt="Error"
 i Names'="*"  f i=1:1:24 w !
 n %Blank,%RM,%Rate,%ResynchRate
 s %Blank=$j("",160),%RM=80,%Rate=5,%ResynchRate=5
 Set prevspace="^"_$zu(96,12)
 u 0::"^%X364"	; Set mnemonic space
 d RunDMDisplay(Names)
Exit
 w /cup(23,1)
 u 0::prevspace
 q
Error s $zt=""
 i $ze'["<INTER"  w /cup(23,1),$ze_%Blank
 g Exit
}
RunDMDisplay(Names) {
 d CLEAR(1,24)
 f  {
 	i $$DMDisplay(Names,.FirstDisplayed,.LastDisplayed,.PageSize,.DMNames)
	d CLEAR(23,23)
	w /cup(23,1)
	u 0:(:"+S")
	s Prompt=""
	i DMNames>0 {
		i DMNames>PageSize s Prompt=Prompt_"(N)ext,(P)rev,"
		s Prompt=Prompt_"(E)xamine,"
		i DMNames=1 {
			i ##Class(DataMove.API).IsRunning(DMNames(1),.DMState) {
				s Prompt=Prompt_"(H)alt,"
				i DMState=10 /*Ready */ {
					s Prompt=Prompt_"(A)ctivate,"
				}
			} else {
				i (DMState>1  /*Create*/)&&(DMState<=11 /*NSPActivating*/) {
					s Prompt=Prompt_"(S)tart,"
				}
			}
		} 
	}
	s Prompt=Prompt_"(Q)uit => "
	w Prompt
	r *Key:%Rate s ZB=$zb
	u 0:(:"-S")
	i (Key=-1)||(Key=13) continue
	i (Key>=49),(Key<=57) {
		w $c(Key)
		s Key=$$GetKeyNum(Key)
		i (Key=0)||'$d(DMNames(Key)) {
			d MESSAGE24("Invalid number, please re-enter",2)
			continue
		}
		s Action="Ranges"
		while ("Ranges,Jobs,Metrics,Stats"[Action) {
			i Action="Ranges" s Action=$$RunRangeDisplay(DMNames(Key),"*","*","*")
			i Action="Jobs" s Action=$$RunJobDisplay(DMNames(Key),"*","*","*")
			i Action="Metrics" s Action=$$RunMetricsDisplay(DMNames(Key))
			i Action="Stats" s Action=$$RunDMDisplayDetail(DMNames(Key))
			i Action="DataCheck" s Action=$$RunCheckRangeDisplay(DMNames(Key),"*","*","*")
		}
 		d CLEAR(1,24)
 		continue
	}
	i (Key=27),($a($e(ZB,2))=91),($a($e(ZB,3))=65) s FirstDisplayed=FirstDisplayed-1 s:FirstDisplayed<0 FirstDisplayed=1 continue
	i (Key=27),($a($e(ZB,2))=91),($a($e(ZB,3))=66) q:LastDisplayed=DMNames  s FirstDisplayed=FirstDisplayed+1 continue
	i (Key=78)!(Key=110) continue:LastDisplayed=DMNames  s FirstDisplayed=LastDisplayed continue
	i (Key=80)!(Key=112) s FirstDisplayed=FirstDisplayed-PageSize-1 s:FirstDisplayed<0 FirstDisplayed=1 continue
	i (Key=81)!(Key=113) s Action="Quit" q
	s Action=""
	i ((Key=69)!(Key=101)) {
		i DMNames=1 {
			s Action="Ranges"
			while ("Ranges,Jobs,Metrics,Stats"[Action) {
				i Action="Ranges" s Action=$$RunRangeDisplay(DMNames(1),"*","*","*")
				i Action="Jobs" s Action=$$RunJobDisplay(DMNames(1),"*","*","*")
				i Action="Metrics" s Action=$$RunMetricsDisplay(DMNames(1))
				i Action="Stats" s Action=$$RunDMDisplayDetail(DMNames(1))
				i Action="DataCheck" s Action=$$RunCheckRangeDisplay(DMNames(1),"*","*","*")
			}
 			d CLEAR(1,24)
 			continue
	 	}
		s Action="Examine"
	}
	i (Key=72)!(Key=104) {
		s Action="Halt"
		i DMNames=1 {
			i ##Class(DataMove.API).IsRunning(DMNames(1),.DMState) {
				d DMACTION(DMNames(1),Action)		
			}
		}
		continue
	}
	i (Key=83)!(Key=115) {
		s Action="Start"
		i DMNames=1 {
			i '##Class(DataMove.API).IsRunning(DMNames(1),.DMState) {
				i (DMState>1  /*Create*/)&&(DMState<=11 /*NSPActivating*/) {
					d DMACTION(DMNames(1),Action)		
				}
			}
		}
		continue
	}
	i (Key=65)!(Key=97) {
		s Action="Activate"
		i DMNames=1 {
			i ##Class(DataMove.API).IsRunning(DMNames(1),.DMState) {
				i DMState=10 /*Ready */ {
					d DMACTION(DMNames(1),Action)		
				}
			}
		}
		continue
	}
	continue:Action=""
GetDMAction 
	w /cup(24,1)
	u 0:(:"+S")
	w Action_": Enter DataMove #: "
	r *Num
	u 0:(:"-S")
	i Num=13 {
		w /cup(23,1),%Blank
		d MESSAGE24("",0)
		continue
	}
	i (Num>=49),(Num<=57) {
		w $c(Num)
		s Num=$$GetKeyNum(Num)
		continue:Num=0
	}  
	i '$d(DMNames(Num)) {
		d MESSAGE24("Invalid number, please re-enter",2)
 		g GetDMAction
	}
	i Action="Examine" {
		s Action="Ranges"
		while ("Ranges,Jobs,Metrics,Stats,DataCheck"[Action) {
			i Action="Ranges" s Action=$$RunRangeDisplay(DMNames(Num),"*","*","*")
			i Action="Jobs" s Action=$$RunJobDisplay(DMNames(Num),"*","*","*")
			i Action="Metrics" s Action=$$RunMetricsDisplay(DMNames(Num))
			i Action="Stats" s Action=$$RunDMDisplayDetail(DMNames(Num))
			i Action="DataCheck" s Action=$$RunCheckRangeDisplay(DMNames(Num),"*","*","*")
		}
 		d CLEAR(1,24)
 		continue
	}
	d DMACTION(DMNames(Num),Action)
	continue
 }
}
RunDMDisplayDetail(Name) {
 d CLEAR(1,24)
 s Action="Quit"
 f  {
 	i '$$DMDisplayDetail(Name) q
	d CLEAR(23,23)
	w /cup(23,1)
	u 0:(:"+S")
	s Prompt="(R)anges,(J)obs,(M)etrics,(D)ataCheck,"
	i ##Class(DataMove.API).IsRunning(Name,.DMState) {
		s Prompt=Prompt_"(H)alt,"
		i DMState=10 /*Ready */ s Prompt=Prompt_"(A)ctivate,"
	} else {
		i (DMState>1  /*Create*/)&&(DMState<=11 /*NSPActivating*/) {
			s Prompt=Prompt_"(S)tart,"
		}
	}
	s Prompt=Prompt_"(Q)uit => "
	w Prompt
	r *Key:%Rate s ZB=$zb
	u 0:(:"-S")
	i (Key=-1)||(Key=13) continue
	i (Key=81)!(Key=113) q
	s Action=""
	i ##Class(DataMove.API).IsRunning(Name) {
		i (Key=72)!(Key=104) s Action="Halt"
		i DMState=10 /*Ready */ {
			i (Key=65)!(Key=97) s Action="Activate"
		}
	} else {
		i (Key=83)!(Key=115) {
			i (DMState>1  /*Create*/)&&(DMState<=11 /*NSPActivating*/) {
				s Action="Start"
			}
		}
	}
	i (Key=82)!(Key=114) s Action="Ranges" q
	i (Key=74)!(Key=106) s Action="Jobs" q 
	i (Key=77)!(Key=109) s Action="Metrics" q
	i (Key=68)!(Key=100) s Action="DataCheck" q
	continue:Action=""
GetDMAction
	d DMACTION(Name,Action)
	continue
 }
 q Action
}
DMDisplayDetail(Name) {
 w /cup(1,1),$J("DataMove Monitor",$L("DataMove Monitor")+%RM\2),/el(0)
 w /cup(2,1)
 w " #",?3,"Name",?18,"MBToCopy",?28,"Copied",?35,"Pct",?39,"Checked",?47,"Pct",?51,"JrnMB",?57,"State",/el(0)
 Set Rset = ##class(%Library.ResultSet).%New("DataMove.API:ListDMs")
 s Status=Rset.Execute(Name,1)
 i '(''Status) {
	s Status="Status: Error running query ListDMs "_$System.Status.GetErrorText(Status)
 	w /cup(4,1),$e(Status_$e(%Blank,1,160-$l(Status)),1,159) h 5
	q 0
 }
 i 'Rset.Next() q 0
 w /cup(3,1)
 w $j(Rset.RowCount,2)
 w ?3,$e(Rset.Name,1,15)
 w ?18,$j(Rset.MBToCopy,8)
 w ?26,$j(Rset.MBCopied,8)
 w ?35,$j(Rset.PctCopied,3)
 w ?38,$j(Rset.MBChecked,8)
 w ?47,$j(Rset.PctChecked,3)
 w ?51,$j(Rset.JRNMBToApply,5)
 w ?57,Rset.ExpandedState w /el(0)
 s Status="Status: "_Rset.Status
 w /cup(4,1),$e(Status_$e(%Blank,1,160-$l(Status)),1,159)
 s Row=5
 w /cup($i(Row),1),"Last Updated:    ",Rset.UpdateTime,/el(0)
 w /cup($i(Row),1),"Est Finish Time: ",Rset.EstFinishTime,/el(0)
 w /cup($i(Row),1),"Jrn Cycle Time:  ",$j(Rset.JRNCycleTime,23),/el(0)
 w /cup($i(Row),1),"Jrn Cycle End:   ",Rset.JRNCycleEnd,/el(0)
 w /cup($i(Row),1),"Jrn Cycle Start: ",Rset.JRNCycleStart,/el(0)
 w /cup($i(Row),1),"DataCheck Time:  ",$j(Rset.DataCheckTime,23),/el(0)
 w /cup($i(Row),1),"DataCheck End:   ",Rset.DataCheckEnd,/el(0)
 w /cup($i(Row),1),"DataCheck Start: ",Rset.DataCheckStart,/el(0)
 w /cup($i(Row),1),"CopyTime:        ",$j(Rset.CopyTime,23),/el(0)
 w /cup($i(Row),1),"End Copy:        ",Rset.CopyEnd,/el(0)
 w /cup($i(Row),1),"Start Copy:      ",Rset.CopyStart,/el(0)
 w /cup($i(Row),1),"Size Time:       ",$j(Rset.SizeTime,23),/el(0)
 w /cup($i(Row),1),"End Size:        ",Rset.SizeEnd,/el(0)
 w /cup($i(Row),1),"Start Size:      ",Rset.SizeStart,/el(0)
 w /cup(5,52),"Done/Avoid/Copy"
 s Row1=6
 w /cup(Row1,42),      "Sets:     ",$j(Rset.JRNSets,7)_"/"_Rset.JRNSetsAvoided_"/"_Rset.JRNSetsCopy
 w /cup($i(Row1),42),  "Kills:    ",$j(Rset.JRNKills,7)_"/"_Rset.JRNKillsAvoided_"/"_Rset.JRNKillsCopy
 w /cup($i(Row1),42),  "BitSets:  ",$j(Rset.JRNBitSets,7)_"/"_Rset.JRNBitSetsAvoided_"/"_Rset.JRNBitSetsCopy
 w /cup($i(Row1),42),  "ZKILLS:   ",$j(Rset.JRNZKills,7)_"/"_Rset.JRNZKillsAvoided_"/"_Rset.JRNZKillsCopy
 w /cup($i(Row1),42),  "Max MB/Min:    ",$j(Rset.MaxMBPerMin,10)
 w /cup($i(Row1),42),  "MB/Min:        ",($j(Rset.MBRate,10))
 w /cup($i(Row1),42),  "Blks copied:   "_$j(Rset.BlocksCopied,10)
 w /cup($i(Row1),42),  "Nodes Checked: "_$j(Rset.NodesChecked,10)
 w /cup($i(Row1),42),  "JRN Count/Size: ",Rset.JRNCount_"/"_Rset.JRNSize
 w /cup($i(Row1),42),  "Pid Mov/Jrn:    ",Rset.PidMoveGlobals_"/"_Rset.PidApplyJournals
 w /cup($i(Row1),42),  "Pid Copy/Chk:   ",Rset.PidCopy_"/"_Rset.PidCheck
 s JournalString=$p(Rset.JRNFirst,",",2)_$j($p(Rset.JRNFirst,",",1),11)
 s JournalString=$e(JournalString,$l(JournalString)-63+1,*)
 w /cup($i(Row),1),  "Journal Start:   ",JournalString
 s JournalString=$p(Rset.JRNCUR,",",2)_$j($p(Rset.JRNCUR,",",1),11)
 s JournalString=$e(JournalString,$l(JournalString)-63+1,*)
 w /cup($i(Row),1),  "Journal Current: ",JournalString
 k Rset
 q 1
}
DMDisplay(Names,FirstDisplayed,LastDisplayed,PageSize,DMNames,ClearBottom=1) Private {
 w /cup(1,1),$J("DataMove Monitor",$L("DataMove Monitor")+%RM\2),/el(0)
 w /cup(2,1)
 w " #",?3,"Name",?18,"MBToCopy",?28,"Copied",?35,"Pct",?39,"Checked",?47,"Pct",?51,"JrnMB",?57,"State",/el(0)
Redo
 Set Rset = ##class(%Library.ResultSet).%New("DataMove.API:ListDMs")
 s Status=Rset.Execute(Names,0)
 i '(''Status) {
	s Status="Status: Error running query ListDMs "_$System.Status.GetErrorText(Status)
 	w /cup(4,1),$e(Status_$e(%Blank,1,160-$l(Status)),1,159) h 5
	q 0
 }
 k DMNames
 k DMNamesCount
 s RowCount=1
 s PageSize=20
 i '$d(FirstDisplayed) s FirstDisplayed=1
 s LastDisplayed=FirstDisplayed+PageSize
 s NumDisplayed=0
 While Rset.Next() {
	s DMNames($i(DMNamesCount))=Rset.Data("Name")
	i (DMNamesCount>=FirstDisplayed),(DMNamesCount<=LastDisplayed) {
		s NumDisplayed=NumDisplayed+1
		w /cup(RowCount+2,1)
  		w $j(Rset.Data("RowCount"),2)
  		w ?3,$e(Rset.Data("Name"),1,15)
		w ?18,$j(Rset.MBToCopy,8)
 		w ?26,$j(Rset.MBCopied,8)
 		w ?35,$j(Rset.PctCopied,3)
 		w ?38,$j(Rset.MBChecked,8)
 		w ?47,$j(Rset.PctChecked,3)
 		w ?51,$j(Rset.JRNMBToApply,5)
 		w ?57,Rset.ExpandedState w /el(0)
	}
	s RowCount=RowCount+1
 }
 d Rset.Close()
 k Rset
 i LastDisplayed>$g(DMNamesCount,0) s LastDisplayed=$g(DMNamesCount,1)
 i (NumDisplayed=0),$d(DMNamesCount) {
 	d CLEAR(3,24)
	s FirstDisplayed=1 
	g Redo
 }
 s DMNames=$g(DMNamesCount,0)
 i (NumDisplayed=0),'$d(DMNamesCount) q 0
 i ClearBottom d CLEAR(RowCount+2,22)
 q 1
}
RangeDisplay(Name,SrcDBs,DstDBs,Ranges,FirstDisplayed,LastDisplayed,PageSize,RetRanges,ClearEnd=1) Private {
 w /cup(4,1)
 s Status=##Class(DataMove.API).GetProperties(Name,.Properties)
 i '(''Status) {
	s Status="Status: Error running GetProperties()"_$System.Status.GetErrorText(Status)
 	w /cup(4,1),$e(Status_$e(%Blank,1,160-$l(Status)),1,159) h 5
	q 0
 }
 s Status="Status: "_$case(Properties("Status"),1:"OK",:$System.Status.GetErrorText(Properties("Status")))
 w $e(Status_$e(%Blank,1,160-$l(Status)),1,159)
Redo
 Set Rset = ##class(%Library.ResultSet).%New("DataMove.API:ListRanges")
 s Status=Rset.Execute(Name,SrcDBs,DstDBs,Ranges)
 i '(''Status) {
	s Status="Status: Error running query ListRanges "_$System.Status.GetErrorText(Status)
 	w /cup(4,1),$e(Status_$e(%Blank,1,160-$l(Status)),1,159) h 5
	q 0
 }
 k RetRanges
 k RangesCount
 s RowCount=1
 s PageSize=7
 i '$d(FirstDisplayed) s FirstDisplayed=1
 s LastDisplayed=FirstDisplayed+PageSize
 s NumDisplayed=0
 s MaxRangeLen=14
 While Rset.Next() {
	s RetRanges($i(RangesCount))=$lb(Name,Rset.Data("SrcDB"),Rset.Data("DstDB"),Rset.Data("Range"))
	i (RangesCount>=FirstDisplayed),(RangesCount<=LastDisplayed) {
		s NumDisplayed=NumDisplayed+1
		w /cup(RowCount*2-2+6+1,1)
  		w $j(Rset.Data("RowCount"),3)
  		s Displayed(NumDisplayed,1)=Rset.Data("SrcDB")_"->"_Rset.Data("DstDB")
  		s Displayed(NumDisplayed,2)=Rset.Data("Range")
  		i $l(Displayed(NumDisplayed,1))>MaxRangeLen s MaxRangeLen=$l(Displayed(NumDisplayed,1))
 		s Displayed(NumDisplayed,3)=Rset.Data("State")
 		;w /el(0)
 		w /cup(RowCount*2-2+6+2,1)
 		s Displayed(NumDisplayed,4)=Rset.Data("MBToCopy")
 		s Displayed(NumDisplayed,5)=Rset.Data("MBCopied")
 		s Displayed(NumDisplayed,6)=Rset.Data("PctCopied")
 		s Displayed(NumDisplayed,7)=Rset.Data("MBChecked")
 		s Displayed(NumDisplayed,8)=Rset.Data("PctChecked")
 		s Displayed(NumDisplayed,9)=Rset.Data("JRNMBToApply") 		
		s RowCount=RowCount+1
	}
 }
 d Rset.Close()
 k Rset
 w /cup(6,1)
 w "  ",?4,"SrcDB->DstDB",?MaxRangeLen+5,"Range" w /el(0)
 f i=1:1:NumDisplayed {
	w /cup(i*2-2+6+1,5)
	w Displayed(i,1),?MaxRangeLen+5,Displayed(i,2)
  	w /cup(i*2-2+6+1,58),Displayed(i,3)
  	w /el(0)
  	w /cup(i*2-2+6+2,1)
 	w ?18,$j(Displayed(i,4),8)
 	w ?26,$j(Displayed(i,5),8)
 	w ?35,$j(Displayed(i,6),3)
 	w ?38,$j(Displayed(i,7),8)
  	w ?47,$j(Displayed(i,8),3)
  	w ?51,$j(Displayed(i,9),5)
 	w /el(0)
 }
 i LastDisplayed>$g(RangesCount,0) s LastDisplayed=$g(RangesCount,1)
 i (NumDisplayed=0),$d(RangesCount) {
 	d CLEAR(7,24)
	s FirstDisplayed=1 
	g Redo
 }
 s RetRanges=$g(RangesCount,0)
 i ClearEnd d CLEAR(RowCount*2+5,22) 
 q 1
}
RunRangeDisplay(Name,SrcDBs,DstDBs,Ranges){
 s $zt="Error"
 i '$$DMDisplay(Name) q 0
 s Action="Quit"
 s Header=1
 f  {
  	i '$d(Header) {
	  	i '$$DMDisplay(Name,,,,,0) q
  	}
  	k Header
	i '$$RangeDisplay(Name,"*","*","*",.FirstDisplayed,.LastDisplayed,.PageSize,.RetRanges) s Action="Quit" q
	d CLEAR(23,23)
	w /cup(23,1)
	u 0:(:"+S")
	s Prompt=""
	i RetRanges>0 {
		i RetRanges>PageSize s Prompt=Prompt_"(N)ext,(P)rev,"
		s Prompt=Prompt_"(E)xamine,(J)obs,(M)etrics,s(T)ats,(D)ataCheck,"
		i ##Class(DataMove.API).IsRunning(Name,.DMState) {
			s Prompt=Prompt_"(H)alt,"
		} else {
			i (DMState>1  /*Create*/)&&(DMState<=11 /*NSPActivating*/) s Prompt=Prompt_"(S)tart,"
		}
	}
	w Prompt_"(Q)uit => " 
	r *Key:%Rate s ZB=$ZB
	u 0:(:"-S")
	i (Key=-1)||(Key=13) continue
	i (Key>=49),(Key<=57) {
		w $c(Key)
		s Key=$$GetKeyNum(Key)
		i Key<=0 s Key=1
		i (Key>0),('$d(RetRanges(Key))) s Key=$o(RetRanges(Key),-1)
		i (Key=0)||'$d(RetRanges(Key)) {
			d MESSAGE24("Invalid number, please re-enter",1)
			continue	
		}
		d RunRangeDisplayDetail(.Key,.RetRanges)
		s FirstDisplayed=Key
		continue
	}
	i (Key=27),($a($e(ZB,2))=91),($a($e(ZB,3))=65) s FirstDisplayed=FirstDisplayed-1 s:FirstDisplayed<=0 FirstDisplayed=1 continue
	i (Key=27),($a($e(ZB,2))=91),($a($e(ZB,3))=66) continue:LastDisplayed=RetRanges  s FirstDisplayed=FirstDisplayed+1 continue
	i (Key=78)!(Key=110) continue:LastDisplayed=RetRanges  s FirstDisplayed=LastDisplayed+1 d CLEAR(7,22) continue
	i (Key=80)!(Key=112) s FirstDisplayed=FirstDisplayed-PageSize-1 s:FirstDisplayed<=0 FirstDisplayed=1 d CLEAR(7,22) continue
	i (Key=81)!(Key=113) s Action="Quit" q
	s Action=""
	i ((Key=69)!(Key=101)) {
		s Action="Examine"
		i RetRanges=1 {
			d RunRangeDisplayDetail(1,.RetRanges)
			continue	
		}
	}
	i (Key=74)!(Key=106) s Action="Jobs" q
	i (Key=77)!(Key=109) s Action="Metrics" q
	i (Key=84)!(Key=116) s Action="Stats" q
	i (Key=68)!(Key=100) s Action="DataCheck" q
	i ##Class(DataMove.API).IsRunning(Name) {
		i (Key=72)!(Key=104) s Action="Halt"
	} else {
		i (DMState>1  /*Create*/)&&(DMState<=11 /*NSPActivating*/) {
			i (Key=83)!(Key=115) s Action="Start"
		}
	}
	continue:Action=""
RangeAction 
	i Action="Examine" {
		w /cup(24,1)
 		u 0:(:"+S")
		w Action_": Enter Range #: "
		r *Num
		u 0:(:"-S")
 		i Num=13 {
			w /cup(23,1),%Blank
			d MESSAGE24("",0)
			continue
	 	}
 		i (Num>=49),(Num<=57) {
			w $c(Num)
			s Num=$$GetKeyNum(Num)
			continue:Num=0
 		}  
 		i '$d(RetRanges(Num)) {
			d MESSAGE24("Invalid number, please re-enter",1)
 			g RangeAction
 		}
		d MESSAGE24("",0)
	  	d RunRangeDisplayDetail(Num,.RetRanges)
  		continue
	}
 	d DMACTION(Name,Action)
 	continue
 }
Exit
 q Action
Error s $zt=""
 i $ze'["<INTER"  w /cup(23,1),$ze_%Blank h 10
 s Action="Quit"
 g Exit
} 
RunJobDisplay(Name,SrcDBs,DstDBs,Ranges){
 s $zt="Error"
 i '$$DMDisplay(Name) q 0
 s Action="Quit"
 s Header=1
 f  {
   	i '$d(Header) {
	  	i '$$DMDisplay(Name,,,,,0) q
  	}
  	k Header
	i '$$JobDisplay(Name,"*","*","*",.FirstDisplayed,.LastDisplayed,.PageSize,.RetJobs) s Action="Quit" q
	d CLEAR(23,23)
	w /cup(23,1)
	u 0:(:"+S")
	s Prompt=""
	i RetJobs>0 {
		i RetJobs>PageSize s Prompt=Prompt_"(N)ext,(P)rev,"
	}
	s Prompt=Prompt_"(R)anges,(M)etrics,(D)ataCheck,"
	i ##Class(DataMove.API).IsRunning(Name,.DMState) {
		s Prompt=Prompt_"(H)alt,"
	} else {
		i (DMState>1  /*Create*/)&&(DMState<=11 /*NSPActivating*/) s Prompt=Prompt_"(S)tart,"
	}
	s Prompt=Prompt_"(Q)uit => " 
	w Prompt
	r *Key:%Rate s ZB=$ZB
	u 0:(:"-S")
	i (Key=27),($a($e(ZB,2))=91),($a($e(ZB,3))=65) s FirstDisplayed=FirstDisplayed-1 s:FirstDisplayed<=0 FirstDisplayed=1 continue
	i (Key=27),($a($e(ZB,2))=91),($a($e(ZB,3))=66) continue:LastDisplayed=RetJobs  s FirstDisplayed=FirstDisplayed+1 continue
	i (Key=78)!(Key=110) continue:LastDisplayed=RetJobs  s FirstDisplayed=LastDisplayed+1 continue
	i (Key=80)!(Key=112) s FirstDisplayed=FirstDisplayed-PageSize-1 s:FirstDisplayed<=0 FirstDisplayed=1 continue
	i (Key=81)!(Key=113) s Action="Quit" q
	s Action=""
	i ##Class(DataMove.API).IsRunning(Name,.DMState) {
		i (Key=72)!(Key=104) s Action="Halt"
	} else {
		i (DMState>1  /*Create*/)&&(DMState<=11 /*NSPActivating*/) {
			i (Key=83)!(Key=115) s Action="Start"
		}
	}
	i (Key=82)!(Key=114) s Action="Ranges" q
	i (Key=77)!(Key=109) s Action="Metrics" q
	i (Key=68)!(Key=100) s Action="DataCheck" q
	continue:Action=""
 	d DMACTION(Name,Action)
 	continue
 }
Exit
 q Action
Error s $zt=""
 i $ze'["<INTER"  w /cup(23,1),$ze_%Blank h 10
 s Action="Quit"
 g Exit
}
RunMetricsDisplay(Name){
 s $zt="Error"
 i '$$DMDisplay(Name) q 0
 s Header=1
 s Action="Quit"
 w /cup(6,31),$j("Total",11),/cup(6,44),$j("DataMove",11),/cup(6,56),$j("DM %",5)
 w /cup(7,1),"Global references/Sec:" 
 w /cup(8,1),"Global update references/Sec:"
 w /cup(9,1),"Physical reads/Sec:"
 w /cup(10,1),"Journal Entries/Sec:"
 w /cup(11,1),"MB Copied/Min  Allowed/Current:"
 w /cup(12,1),"MB Checked/Min Allowed/Current:"
 s MirrorName=##Class(Config.Mirrors).GetMirrorName()
 if MirrorName'="" {
		w /cup(14,1),"Mirror Member Name",/cup(14,30),"Member Type",/cup(14,48),"Status",/cup(14,58),"Dejournaling"
 }
 s Status=##Class(DataMove.API).GetProperties(Name)
 i '(''Status) {
	s Status="Status: Error running GetProperties()"_$System.Status.GetErrorText(Status)
 	w /cup(4,1),$e(Status_$e(%Blank,1,160-$l(Status)),1,159) h 5
	q 0
 }
 s Interval=1
 n %DMStorageDir
 s Status=##Class(DataMove.Data).GetDMStorageDir(Name,.DMRecord)
 i '(''Status) {
	s Status="Status: Error running GetDMStorageDir()"_$System.Status.GetErrorText(Status)
	w /cup(4,1),$e(Status_$e(%Blank,1,160-$l(Status)),1,159) h 5
	q
 } 
 d GetMetrics
 h Interval
 f  {
  	i '$d(Header) {
	  	i '$$DMDisplay(Name,,,,,0) q
  	}
  	k Header
	w /cup(4,1)
	s Status=##Class(DataMove.API).GetProperties(Name,.Properties)
	i '(''Status) {
		s Status="Status: Error running GetProperties()"_$System.Status.GetErrorText(Status)
 		w /cup(4,1),$e(Status_$e(%Blank,1,160-$l(Status)),1,159) h 5
		q
 	}
	s Status="Status: "_$case(Properties("Status"),1:"OK",:$System.Status.GetErrorText(Properties("Status")))
	w $e(Status_$e(%Blank,1,160-$l(Status)),1,159)
	s DMRecord=^|"^^"_%DMStorageDir|IRIS.DataMoveD(Name)
	d GetMetrics
	w /cup(7,31),$j(SYS("Diff","GLOREF"),11),/cup(7,44),$j(DMGLOREF,11),/cup(7,56),$s(SYS("Diff","GLOREF")=0:$j("0",5),1:$j($fn(DMGLOREF/SYS("Diff","GLOREF")*100,"",0),5))
	w /cup(8,31),$j(SYS("Diff","GLOSET"),11),/cup(8,44),$j(DMGLOSET,11),/cup(8,56),$s(SYS("Diff","GLOSET")=0:$j("0",5),1:$j($fn(DMGLOSET/SYS("Diff","GLOSET")*100,"",0),5))
	w /cup(9,31),$j(SYS("Diff","PHYRD"),11),/cup(9,44),$j(DMPHYRD,11),/cup(9,56),$s(SYS("Diff","PHYRD")=0:$j("0",5),1:$j($fn(DMPHYRD/SYS("Diff","PHYRD")*100,"",0),5))
	w /cup(10,31),$j(SYS("Diff","JRNENT"),11),/cup(10,44),$j(DMJRNENT,11),/cup(10,56),$s(SYS("Diff","JRNENT")=0:$j("0",5),1:$j($fn(DMJRNENT/SYS("Diff","JRNENT")*100,"",0),5))
	w /cup(11,31),$s(DMMaxMBPerMin=0:$j("Unlimited",11),1:$j(DMMaxMBPerMin,11)),/cup(11,44),$j(MBCopiedPerMin,11)
	w /cup(12,31),$s(DMMaxMBCheckPerMin=0:$j("Unlimited",11),1:$j(DMMaxMBCheckPerMin,11)),/cup(12,44),$j(MBCheckedPerMin,11)
	s Row=14
 	i MirrorName'="" {
		s Mirror=""
		s Count=0
		f  {
			s Mirror=$o(Mirrors(Mirror)) q:Mirror=""
			s Row=Row+1
			w /cup(Row,1),$e(Mirrors(Mirror,"MemberName"),$l(Mirrors(Mirror,"MemberName"))-29+1,*),/cup(Row,30),Mirrors(Mirror,"CurrentRole")_$e($j("",11),1,11-$l(Mirrors(Mirror,"CurrentRole"))),/cup(Row,48),Mirrors(Mirror,"CurrentStatus")_$e($j("",9),1,9-$l(Mirrors(Mirror,"CurrentStatus"))),/el(0),/cup(Row,58),Mirrors(Mirror,"DatabaseTimeLatency"),/el(0)
		}
	}		
	d CLEAR(Row+1,23)
	w /cup(23,1)
	u 0:(:"+S")
	s Prompt=""
	s Prompt=Prompt_"(R)anges,(J)obs,(D)ataCheck,(C)hange rate,"
	i ##Class(DataMove.API).IsRunning(Name,.DMState) {
		s Prompt=Prompt_"(H)alt,"
	} else {
		i (DMState>1  /*Create*/)&&(DMState<=11 /*NSPActivating*/) s Prompt=Prompt_"(S)tart,"
	}
	w Prompt_"(Q)uit => " 
	s StartInterval=$zh
ReGet
	r *Key:%Rate s ZB=$ZB
	s Interval=$zh-StartInterval
	u 0:(:"-S")
	i (Key=-1)||(Key=13) {
		i Interval<2 g ReGet
		continue
	}
	i (Key=81)!(Key=113) s Action="Quit" q
GetMaxMBPerMin
	i (Key=67)!(Key=99) {
		k Properties
		i DMState<=6 /*Copy*/ {
			w /cup(23,1),"Max allowed MB Copied/Min is currently set to: "_$s(DMMaxMBPerMin=0:"0-Unlimited",1:DMMaxMBPerMin),/el(0)
			w /cup(24,1),"New value "_DMMaxMBPerMin_" (0=Unlimited) => ",/el(0)
			Read Ans
			i (Ans="")||(Ans=DMMaxMBPerMin) continue
			s Properties("MaxMBPerMin")=+Ans
			s Status=##Class(DataMove.API).Modify(Name,.Properties)
			i '(''Status) w /cup(24,1),"Invalid entry, please re-enter" h 2 g GetMaxMBPerMin
			w /cup(24,1)
			i $$YNSCREEN("Do you want to apply this value to the system default","N")="Y" {
		 		s DM=##Class(DataMove.Defaults).%OpenId("DMDEFAULTS")
				s DM.MaxMBPerMin=Properties("MaxMBPerMin")
				d DM.%Save()
			}		
			continue
		}
		i DMState>6 /*Copy*/ {
			w /cup(23,1),"Max allowed MB Checked/Min is currently set to: "_$s(DMMaxMBCheckPerMin=0:"0-Unlimited",1:DMMaxMBCheckPerMin),/el(0)
			w /cup(24,1),"New value "_DMMaxMBCheckPerMin_" (0=Unlimited) => ",/el(0)
			Read Ans
			i (Ans="")||(Ans=DMMaxMBCheckPerMin) continue
			s Properties("MaxMBCheckPerMin")=+Ans
			s Status=##Class(DataMove.API).Modify(Name,.Properties)
			i '(''Status) w /cup(24,1),"Invalid entry, please re-enter" h 2 g GetMaxMBPerMin
			w /cup(24,1)
			i $$YNSCREEN("Do you want to apply this value to the system default","N")="Y" {
		 		s DM=##Class(DataMove.Defaults).%OpenId("DMDEFAULTS")
				s DM.MaxMBCheckPerMin=Properties("MaxMBCheckPerMin")
				d DM.%Save()
			}		
			continue
		}
	}
	s Action=""
	i (Key=82)!(Key=114) s Action="Ranges" q
	i (Key=74)!(Key=106) s Action="Jobs" q 
	i (Key=68)!(Key=100) s Action="DataCheck" q
	i ##Class(DataMove.API).IsRunning(Name) {
		i (Key=72)!(Key=104) s Action="Halt"
	} else {
		i (DMState>1  /*Create*/)&&(DMState<=11 /*NSPActivating*/) {
			i (Key=83)!(Key=115) s Action="Start"
		}
	}
	continue:Action=""
RangeAction 
 	d DMACTION(Name,Action)
 	continue
 }
Exit
 q Action
Error s $zt=""
 i $ze'["<INTER"  w /cup(23,1),$ze_%Blank h 10
 s Action="Quit"
 g Exit
GetMetrics
 s SrcDB=""
 f  {
 	s SrcDB=$o(^|"^^"_%DMStorageDir|IRIS.DataMove.RangesD(Name,SrcDB)) q:SrcDB=""
 	s DstDB=""
 	f  {
	 	s DstDB=$o(^|"^^"_%DMStorageDir|IRIS.DataMove.RangesD(Name,SrcDB,DstDB)) q:DstDB=""
	 	s Range=""
		f {
		 	s Range=$o(^|"^^"_%DMStorageDir|IRIS.DataMove.RangesD(Name,SrcDB,DstDB,Range)) i Range'="" { s RngRecord=^|"^^"_%DMStorageDir|IRIS.DataMove.RangesD(Name,SrcDB,DstDB,Range,2) } q:Range=""
			s Pid=$li(RngRecord,35 /*PidCopy*/)
			s JobNumber=$zu(67,Pid)
			i (JobNumber'=0),($zu(61,20,JobNumber)["DATAMOVE") {
				d UpdateMetrics
			} else {
				k Jobs(Pid)
			}
			s Pid=$li(RngRecord,36 /*PidJRN*/)
			s JobNumber=$zu(67,Pid)
			i (JobNumber'=0),($zu(61,20,JobNumber)["DATAMOVE") {
				d UpdateMetrics
			} else {
				k Jobs(Pid)
			}
			;i '$$$ISOK(Status) continue
			s Pid=$li(RngRecord,64)
			s JobNumber=$zu(67,Pid)
			i (JobNumber'=0),($zu(61,20,JobNumber)["DATAMOVE") {
				d UpdateMetrics
			} else {
				k Jobs(Pid)
			}
		}
 	}
 }
 s DMGLOREF=0
 s DMGLOSET=0
 s DMJRNENT=0
 s DMPHYRD=0
 s JobNumber=""
 f  {
	 s JobNumber=$o(Jobs(JobNumber)) q:JobNumber=""
	 s DMGLOREF=DMGLOREF+Jobs(JobNumber,"Diff","GLOREF")
	 s DMGLOSET=DMGLOSET+Jobs(JobNumber,"Diff","GLOSET")
	 s DMJRNENT=DMJRNENT+Jobs(JobNumber,"Diff","JRNENT")
	 s DMPHYRD=DMPHYRD+Jobs(JobNumber,"Diff","PHYRD")
 }
 s DMGLOREF=DMGLOREF\Interval
 s DMGLOSET=DMGLOSET\Interval
 s DMJRNENT=DMJRNENT\Interval
 s DMPHYRD=DMPHYRD\Interval
 i $d(MBCopied)=0 {
	s CurTime=$zh
	s MBCopied=+$li(DMRecord,11 /*MBCopied*/)
	s MBCopiedPerMin=0
	s DMTimeLastUpdatedExternal=$li(DMRecord,4 /*TimeLastUpdatedExternal*/)
	Try {s Seconds=$ztimeh(DMTimeLastUpdatedExternal)} catch {s Seconds=+$p($h,",",2)}
	s SecondsDiff=+$p($h,",",2)-Seconds
	s MBCopied("Prev2$zh")=CurTime-SecondsDiff
	s MBCopied("Prev1$zh")=CurTime
	s MBCopied("Prev$zh")=CurTime
	s MBCopied("Cur$zh")=CurTime
	s MBCopied("Prev2")=MBCopied
	s MBCopied("Prev1")=MBCopied
	s MBCopied("Prev")=MBCopied
	s MBCopied("Cur")=MBCopied
 } else {
	s MBCopied=+$li(DMRecord,11 /*MBCopied*/)
 }
 i MBCopied'=MBCopied("Cur") {
	s CurTime=$zh
	s MBCopiedPerMin=$fn(MBCopied-MBCopied("Prev2")*$fn((60/(CurTime-MBCopied("Prev2$zh"))),"",0),"",0)
	s MBCopied("Prev2$zh")=MBCopied("Prev1$zh")
	s MBCopied("Prev1$zh")=MBCopied("Prev$zh")
	s MBCopied("Prev$zh")=MBCopied("Cur$zh")
	s MBCopied("Cur$zh")=CurTime
	s MBCopied("Prev2")=MBCopied("Prev1")
	s MBCopied("Prev1")=MBCopied("Prev")
	s MBCopied("Prev")=MBCopied("Cur")
	s MBCopied("Cur")=MBCopied
 }
 i $d(MBChecked)=0 {
	s CurTime=$zh
	s Status=##Class(DataMove.API).DataCheckGetInfo(Name,.Properties)
	s MBChecked=Properties("MBChecked")
	s MBCheckedPerMin=0
	s LastUpdated=$p(Properties("LastUpdated")," ",2)
	Try {s Seconds=$ztimeh(LastUpdated)} catch {s Seconds=+$p($h,",",2)}
	s SecondsDiff=+$p($h,",",2)-Seconds
	s MBChecked("Prev2$zh")=CurTime-SecondsDiff
	s MBChecked("Prev1$zh")=CurTime
	s MBChecked("Prev$zh")=CurTime
	s MBChecked("Cur$zh")=CurTime
	s MBChecked("Prev2")=MBChecked
	s MBChecked("Prev1")=MBChecked
	s MBChecked("Prev")=MBChecked
	s MBChecked("Cur")=MBChecked
 } else {
	s Status=##Class(DataMove.API).DataCheckGetInfo(Name,.Properties)
	s MBChecked=Properties("MBChecked")
 }
 i MBChecked'=MBChecked("Cur") {
	s CurTime=$zh
	s MBCheckedPerMin=$fn(MBChecked-MBChecked("Prev2")*$fn((60/(CurTime-MBChecked("Prev2$zh"))),"",0),"",0)
	s MBChecked("Prev2$zh")=MBChecked("Prev1$zh")
	s MBChecked("Prev1$zh")=MBChecked("Prev$zh")
	s MBChecked("Prev$zh")=MBChecked("Cur$zh")
	s MBChecked("Cur$zh")=CurTime
	s MBChecked("Prev2")=MBChecked("Prev1")
	s MBChecked("Prev1")=MBChecked("Prev")
	s MBChecked("Prev")=MBChecked("Cur")
	s MBChecked("Cur")=MBChecked
 }
 s Stats=$zu(190,6,1)
 s GLOREF=$p(Stats,",",5)
 s GLOSET=$p(Stats,",",10)
 s JRNENT=$p(Stats,",",22)
 s PHYRD=$p(Stats,",",8)
 s SYS("Prev","GLOREF")=$g(SYS("Cur","GLOREF"),GLOREF)
 s SYS("Prev","GLOSET")=$g(SYS("Cur","GLOSET"),GLOSET)
 s SYS("Prev","JRNENT")=$g(SYS("Cur","JRNENT"),JRNENT)
 s SYS("Prev","PHYRD")=$g(SYS("Cur","PHYRD"),PHYRD)
 s SYS("Cur","GLOREF")=GLOREF
 s SYS("Cur","GLOSET")=GLOSET
 s SYS("Cur","JRNENT")=JRNENT
 s SYS("Cur","PHYRD")=PHYRD
 s SYS("Diff","GLOREF")=(SYS("Cur","GLOREF")-SYS("Prev","GLOREF"))\Interval
 s SYS("Diff","GLOSET")=(SYS("Cur","GLOSET")-SYS("Prev","GLOSET"))\Interval
 s SYS("Diff","JRNENT")=(SYS("Cur","JRNENT")-SYS("Prev","JRNENT"))\Interval
 s SYS("Diff","PHYRD")=(SYS("Cur","PHYRD")-SYS("Prev","PHYRD"))\Interval
 i $li(DMRecord,5 /*State*/)>=7 /*CopyDone*/ s MBCopiedPerMin=0
 i $li(DMRecord,5 /*State*/)<7 /*CopyDone*/ s MBCheckedPerMin=0
 s DMMaxMBPerMin=$li(DMRecord,26 /*MaxMBPerMin*/)
 s DMMaxMBCheckPerMin=$li(DMRecord,35 /*MaxMBCheckPerMin*/)
 k Mirrors
 if MirrorName'="" {
	Set Rset = ##class(%Library.ResultSet).%New("SYS.Mirror:MemberStatusList")
	s Status=Rset.Execute(MirrorName)
	i '(''Status) {
		s Status="Status: Error running  SYS.Mirror:MemberStatusList"_$System.Status.GetErrorText(Status)
 		w /cup(4,1),$e(Status_$e(%Blank,1,160-$l(Status)),1,159) h 5
		q
 	}
	While (Rset.Next()) {
		i Rset.CurrentRole="Primary" continue
		s Mirrors=$g(Mirrors)+1
		s Mirrors(Mirrors,"MemberName")=Rset.MemberName
		s Mirrors(Mirrors,"CurrentRole")=Rset.DisplayType
		s Mirrors(Mirrors,"CurrentStatus")=Rset.DisplayStatus
		s Mirrors(Mirrors,"DatabaseLatency")=Rset.DataBaseLatency
		s Mirrors(Mirrors,"DatabaseTimeLatency")=Rset.DataBaseTimeLatency
 	}
 }
 q
UpdateMetrics	
 s Jobs(Pid,"Prev","GLOREF")=$g(Jobs(Pid,"Cur","GLOREF"),($zu(61,9,JobNumber)+$zu(61,39,JobNumber)))
 s Jobs(Pid,"Prev","GLOSET")=$g(Jobs(Pid,"Cur","GLOSET"),($zu(61,35,JobNumber)+$zu(61,40,JobNumber)))
 s Jobs(Pid,"Prev","JRNENT")=$g(Jobs(Pid,"Cur","JRNENT"),$zu(61,37,JobNumber))
 s Jobs(Pid,"Prev","PHYRD")=$g(Jobs(Pid,"Cur","PHYRD"),$zu(61,34,JobNumber))
 s Jobs(Pid,"Cur","GLOREF")=$zu(61,9,JobNumber)+$zu(61,39,JobNumber)
 s Jobs(Pid,"Cur","GLOSET")=$zu(61,35,JobNumber)+$zu(61,40,JobNumber)
 s Jobs(Pid,"Cur","JRNENT")=$zu(61,37,JobNumber)
 s Jobs(Pid,"Cur","PHYRD")=$zu(61,34,JobNumber)
 s Jobs(Pid,"Diff","GLOREF")=Jobs(Pid,"Cur","GLOREF")-Jobs(Pid,"Prev","GLOREF")
 s Jobs(Pid,"Diff","GLOSET")=Jobs(Pid,"Cur","GLOSET")-Jobs(Pid,"Prev","GLOSET")
 s Jobs(Pid,"Diff","JRNENT")=Jobs(Pid,"Cur","JRNENT")-Jobs(Pid,"Prev","JRNENT")	
 s Jobs(Pid,"Diff","PHYRD")=Jobs(Pid,"Cur","PHYRD")-Jobs(Pid,"Prev","PHYRD")	
 q
} 
RunRangeDisplayDetail(Num,RetRanges) { 
 d CLEAR(7,22)
 s MaxNum=$o(RetRanges(""),-1)
 f  {	 
	s RngList=RetRanges(Num)
	i '$$RangeDisplayDetail($li(RngList,1),$li(RngList,2),$li(RngList,3),$li(RngList,4),0) q	 
	d CLEAR(23,23)
	w /cup(23,1)
	u 0:(:"+S")
	r "(N)ext range,(P)rev range,(Q)uit => ",*Key:%Rate s ZB=$ZB
	u 0:(:"-S")
	i (Key=27),($a($e(ZB,2))=91),($a($e(ZB,3))=65) s Num=Num-1 s:Num=0 Num=1 d CLEAR(7,22) continue
	i (Key=27),($a($e(ZB,2))=91),($a($e(ZB,3))=66) s Num=Num+1 s:Num>MaxNum Num=MaxNum d CLEAR(7,22) continue
	i (Key=78)!(Key=110) s Num=Num+1 s:Num>MaxNum Num=MaxNum d CLEAR(7,22) continue
	i (Key=80)!(Key=112) s Num=Num-1 s:Num=0 Num=1 d CLEAR(7,22) continue
	i (Key=81)!(Key=113) d CLEAR(7,22) q
 }
 q
}
RangeDisplayDetail(Name,SrcDB,DstDB,Range,ClearEnd=1) {
 i '$$RangeDisplay(Name,SrcDB,DstDB,Range,,,,,ClearEnd) q 0
 Set Rset = ##class(%Library.ResultSet).%New("DataMove.API:ListRanges")
 s Status=Rset.Execute(Name,SrcDB,DstDB,Range)
 i '(''Status) {
	s Status="Status: Error running query ListRanges "_$System.Status.GetErrorText(Status)
 	w /cup(4,1),$e(Status_$e(%Blank,1,160-$l(Status)),1,159) h 5
	q 0
 }
 d Rset.Next()
 w /cup(8,1)
 w ?18,$j(Rset.MBToCopy,8)
 w ?26,$j(Rset.MBCopied,8)
 w ?35,$j(Rset.PctCopied,3)
 w ?38,$j(Rset.MBChecked,8)
 w ?47,$j(Rset.PctChecked,3)
 w ?51,$j(Rset.JRNMBToApply,5)
 w /el(0)
 s Row=9
 w /cup(Row,1),    "Last Updated:    ",Rset.LastUpdated
 w /cup($i(Row),1),"Jrn Cycle Time:  ",$j(Rset.JRNCycleTime,23)
 w /cup($i(Row),1),"Jrn Cycle End:   ",Rset.JRNCycleEnd
 w /cup($i(Row),1),"Jrn Cycle Start: ",Rset.JRNCycleStart
 w /cup($i(Row),1),"DataCheck Time:  ",$j(Rset.DataCheckTime,23)
 w /cup($i(Row),1),"DataCheck End:   ",Rset.DataCheckEnd
 w /cup($i(Row),1),"DataCheck Start: ",Rset.DataCheckStart
 i '$zb(+Rset.Flags,2 /*Range*/,1) {
	d $i(Row)
	w /cup(Row,1),"CopyTime:        ",$j(Rset.CopyTime,23)
	d $i(Row)
	w /cup(Row,1),"End Copy:        ",Rset.CopyEnd
	d $i(Row)
	w /cup(Row,1),"Start Copy:      ",Rset.CopyStart
	d $i(Row)
	w /cup(Row,1),"Size Time:       ",$j(Rset.SizeTime,23)
	d $i(Row)
	w /cup(Row,1),"End Size:        ",Rset.SizeEnd
	d $i(Row)
 	w /cup(Row,1),"Start Size:      ",Rset.SizeStart
	w /cup(9,52),"Done/Avoid/Copy"
	s Row=10
	w /cup(Row,42),      "Sets:     ",$j(Rset.JRNSets,7)_"/"_Rset.JRNSetsAvoided_"/"_Rset.JRNSetsCopy
	w /cup($i(Row),42),  "Kills:    ",$j(Rset.JRNKills,7)_"/"_Rset.JRNKillsAvoided_"/"_Rset.JRNKillsCopy
	w /cup($i(Row),42),  "BitSets:  ",$j(Rset.JRNBitSets,7)_"/"_Rset.JRNBitSetsAvoided_"/"_Rset.JRNBitSetsCopy
	w /cup($i(Row),42),  "ZKILLS:   ",$j(Rset.JRNZKills,7)_"/"_Rset.JRNZKillsAvoided_"/"_Rset.JRNZKillsCopy
	w /cup($i(Row),42),  "MB/Min:   ",$j(Rset.MBPerMin,10)
	w /cup($i(Row),42),  "Blks copied: "_$j(Rset.BlocksCopied,10)
	w /cup($i(Row),42),  "JRN Count/Size: ",Rset.JRNCount_"/"_Rset.JRNSize
	w /cup($i(Row),42),  "Pid Mov/Jrn:    ",Rset.PidCopy_"/"_Rset.PidJrn
 } 
 q 1
}
JobDisplay(Name,SrcDBs,DstDBs,Ranges,FirstDisplayed,LastDisplayed,PageSize,RetJobs) Private {
 w /cup(4,1)
 s Status=##Class(DataMove.API).GetProperties(Name,.Properties)
 i '(''Status) {
	s Status="Status: Error running GetProperties()"_$System.Status.GetErrorText(Status)
	w /cup(4,1),$e(Status_$e(%Blank,1,160-$l(Status)),1,159) h 5
	q
 }
 s Status="Status: "_$case(Properties("Status"),1:"OK",:$System.Status.GetErrorText(Properties("Status")))
 w $e(Status_$e(%Blank,1,160-$l(Status)),1,159)
 w /cup(6,1),$$FormatDataMoveHeader^JOBEXAM()
Redo
 Set Rset = ##class(%Library.ResultSet).%New("DataMove.API:ListProcesses")
 s Status=Rset.Execute(Name)
 i '(''Status) {
	s Status="Status: Error running query ListProcesses "_$System.Status.GetErrorText(Status)
 	w /cup(4,1),$e(Status_$e(%Blank,1,160-$l(Status)),1,159) h 5
	q 0
 }
 k RetJobs
 k JobsCount
 s RowCount=1
 s PageSize=15
 i '$d(FirstDisplayed) s FirstDisplayed=1
 s LastDisplayed=FirstDisplayed+PageSize
 s NumDisplayed=0
 While Rset.Next() {
	s RetJobs($i(JobsCount))=Rset.Data("JobNum")
	i (JobsCount>=FirstDisplayed),(JobsCount<=LastDisplayed) {
		s NumDisplayed=NumDisplayed+1
		w /cup(RowCount+6,1)
  		w $j(Rset.Data("RowCount"),2)
  		w ?4,Rset.Data("Info")
 		w /el(0)
 		s RowCount=RowCount+1
	}
 }
 d Rset.Close()
 k Rset
 i LastDisplayed>$g(JobsCount,0) s LastDisplayed=$g(JobsCount,1)
 i (NumDisplayed=0),$d(JobsCount) {
 	d CLEAR(7,24)
	s FirstDisplayed=1 
	g Redo
 }
 s RetJobs=$g(JobsCount,0)
 d CLEAR(RowCount+6,22) 
 q 1
}
DMACTION(Name,Action) Private {
 q:Action=""
 s Status=##Class(DataMove.API).GetProperties(Name,.Properties)
 i '(''Status) {
	s Status="Status: Error running GetProperties()"_$System.Status.GetErrorText(Status)
	w /cup(4,1),$e(Status_$e(%Blank,1,160-$l(Status)),1,159) h 5
	q
 }
 i Action="Start" {
	i '##Class(DataMove.API).IsRunning(Name) {
		i Properties("State")=2 /*NotStarted*/ {
			s Msg="Confirm start of DataMove"
		} else {
			s Msg="Confirm restart of DataMove"
		}
		w /cup(23,1) 
		i $$YN(Msg_" "_Name,"N")="N" q
		s Status=##Class(DataMove.API).StartCopy(Name)
		i '(''Status) {
			d MESSAGE24("Unable to start DataMove",2)
		} else {
			d MESSAGE24("Starting DataMove...",2)
		}
		q
	} else {
		d MESSAGE24("DataMove is already running",2)
	}
 }
 i Action="Halt" {
	i 'Properties("Stop") {
		w /cup(23,1) 
		i $$YN("Confirm halting DataMove "_Name,"N")="N" q
	} else {
		d MESSAGE24("DataMove is already halted",2)
	}
	s Status=##Class(DataMove.API).StopCopy(Name)
	i '(''Status) {
		s Msg=$SYSTEM.Status.GetErrorText(Status)
	} else {
		s Msg="Halting DataMove..."
	}
	d MESSAGE24(Msg,2)
	q
 }
 i Action="Activate" {
	d CLEAR(1,24)
	i $$YN("Confirm activating DataMove "_Name,"N")="N" q
	s Status=##Class(DataMove.API).Activate(Name)
	r !,"Press return to continue: ",x
 	f i=1:1:24 w !
	q	 
 }
}
DCDisplay(Names,FirstDisplayed,LastDisplayed,PageSize,DMNames,ClearBottom=1) Private {
 w /cup(1,1),$J("DataCheck Monitor",$L("DataCheck Monitor")+%RM\2),/el(0)
 w /cup(2,1)
 w " #",?3,"Name",?20,"Copied",?29,"Checked",?37,"Pct",?42,"Diff",?52,"State",?64,"Last Update/Done",/el(0)
Redo
 Set Rset = ##class(%Library.ResultSet).%New("DataMove.API:ListDMs")
 s Status=Rset.Execute(Names,0)
 i '(''Status) {
	s Status="Status: Error running query ListDMs "_$System.Status.GetErrorText(Status)
 	w /cup(4,1),$e(Status_$e(%Blank,1,160-$l(Status)),1,159) h 5
	q 0
 }
 k DMNames
 k DMNamesCount
 s RowCount=1
 s PageSize=20
 i '$d(FirstDisplayed) s FirstDisplayed=1
 s LastDisplayed=FirstDisplayed+PageSize
 s NumDisplayed=0
 While Rset.Next() {
	s DMNames($i(DMNamesCount))=Rset.Data("Name")
	i (DMNamesCount>=FirstDisplayed),(DMNamesCount<=LastDisplayed) {
		s NumDisplayed=NumDisplayed+1
		w /cup(RowCount+2,1)
  		w $j(Rset.Data("RowCount"),2)
  		w ?3,$e(Rset.Data("Name"),1,15)
  		s Status=##Class(DataMove.API).DataCheckGetInfo(Rset.Data("Name"),.Info)
  		i '(''Status) continue
 		w ?18,$j(Rset.Data("MBCopied"),8)
 		w ?28,$j(Rset.Data("MBChecked"),8)
 		w ?37,$j(Info("PctChecked"),3)
	 	w ?41,$j(Info("Differences"),5)
  		w ?52,Info("State") 
  		w ?63,$j($e(Info("LastUpdated"),4,*),17)
	}
	s RowCount=RowCount+1
 }
 d Rset.Close()
 k Rset
 i LastDisplayed>$g(DMNamesCount,0) s LastDisplayed=$g(DMNamesCount,1)
 i (NumDisplayed=0),$d(DMNamesCount) {
 	d CLEAR(3,24)
	s FirstDisplayed=1 
	g Redo
 }
 s DMNames=$g(DMNamesCount,0)
 i (NumDisplayed=0),'$d(DMNamesCount) q 0
 i ClearBottom d CLEAR(RowCount+2,22)
 q 1
}
RunCheckRangeDisplay(Name,SrcDBs,DstDBs,Ranges){
 s $zt="Error"
 i '$$DCDisplay(Name) q 0
 s Action="Quit"
 s Header=1
 f  {
  	i '$d(Header) {
	  	i '$$DCDisplay(Name,,,,,0) q
  	}
  	k Header
	i '$$CheckRangeDisplay(Name,"*","*","*",.FirstDisplayed,.LastDisplayed,.PageSize,.RetRanges) s Action="Quit" q
	d CLEAR(23,23)
	w /cup(23,1)
	u 0:(:"+S")
	s Prompt=""
	i RetRanges>0 {
		s Status=##Class(DataMove.API).DataCheckGetInfo(Name,.Info)
		i '(''Status) d MESSAGE24($system.Status.GetErrorText(Status),2)
		i RetRanges>PageSize s Prompt=Prompt_"(N)ext,(P)rev,"
		s Prompt=Prompt_"(E)xamine,(R)anges,(J)obs,(M)etrics,"
		i 'Info("Done") {
			i ##Class(DataMove.API).DataCheckIsRunning(Name) {
				s Prompt=Prompt_"(H)altDataCheck,"
			} else {
				s Status=##Class(DataMove.API).GetProperties(Name,.DMInfo)
				i '(''Status) d MESSAGE24($system.Status.GetErrorText(Status),2)
				s DMState=+$g(DMInfo("State"))
				i DMState>=7 /*CopyDone*/ {
					s Prompt=Prompt_"(S)tartDataCheck,"
				}
			}
		} else {
			s Prompt=Prompt_"Run(A)gain,"			
		}
		i Info("Differences") s Prompt=Prompt_"(D)iffs,"
	}
	w Prompt_"(Q)uit => " 
	r *Key:%Rate s ZB=$ZB
	u 0:(:"-S")
	i (Key=-1)||(Key=13) continue
	i (Key>=49),(Key<=57) {
		w $c(Key)
		s Key=$$GetKeyNum(Key)
		i Key<=0 s Key=1
		i (Key>0),('$d(RetRanges(Key))) s Key=$o(RetRanges(Key),-1)
		i (Key=0)||'$d(RetRanges(Key)) {
			d MESSAGE24("Invalid number, please re-enter",1)
			continue	
		}
		d RunCheckRangeDisplayDetail(.Key,.RetRanges)
		s FirstDisplayed=Key
		continue
	}
	i (Key=27),($a($e(ZB,2))=91),($a($e(ZB,3))=65) s FirstDisplayed=FirstDisplayed-1 s:FirstDisplayed<=0 FirstDisplayed=1 continue
	i (Key=27),($a($e(ZB,2))=91),($a($e(ZB,3))=66) continue:LastDisplayed=RetRanges  s FirstDisplayed=FirstDisplayed+1 continue
	i (Key=78)!(Key=110) continue:LastDisplayed=RetRanges  s FirstDisplayed=LastDisplayed+1 d CLEAR(7,22) continue
	i (Key=80)!(Key=112) s FirstDisplayed=FirstDisplayed-PageSize-1 s:FirstDisplayed<=0 FirstDisplayed=1 d CLEAR(7,22) continue
	i (Key=81)!(Key=113) s Action="Quit" q
	i (Key=82)!(Key=114) s Action="Ranges" q
	i (Key=74)!(Key=106) s Action="Jobs" q 
	i (Key=77)!(Key=109) s Action="Metrics" q
	s Action=""
	i ((Key=68)!(Key=100))&Info("Differences") {
		d CLEAR(6,23)
		w /cup(6,1)
		d ExportRangeDiff(Name,"*","*","*")
		continue
	}
	i ((Key=69)!(Key=101)) {
		s Action="Examine"
		i RetRanges=1 {
			d RunCheckRangeDisplayDetail(1,.RetRanges)
			continue	
		}
	}
	i (Key=69)!(Key=101) s Action="Examine"
	i 'Info("Done") {
		i ##Class(DataMove.API).DataCheckIsRunning(Name) {
			i (Key=72)!(Key=104) s Action="Halt"
		} else {
			i DMState>=7 /*CopyDone*/ {
				i (Key=83)!(Key=115) s Action="Start"
			}
		}
	} else {
		i (Key=65)!(Key=97) s Action="RunAgain"
	}
	continue:Action=""
RangeAction 
	i Action="Examine" {
		w /cup(24,1)
 		u 0:(:"+S")
		w Action_": Enter Range #: "
		r *Num
		u 0:(:"-S")
 		i Num=13 {
			w /cup(23,1),%Blank
			d MESSAGE24("",0)
			continue
	 	}
 		i (Num>=49),(Num<=57) {
			w $c(Num)
			s Num=$$GetKeyNum(Num)
			continue:Num=0
 		}  
 		i '$d(RetRanges(Num)) {
			d MESSAGE24("Invalid number, please re-enter",1)
 			g RangeAction
 		}
		d MESSAGE24("",0)
	  	d RunCheckRangeDisplayDetail(Num,.RetRanges)
  		continue
	}
	i Action="Start" {
		s Msg="Confirm start of DataMove DataCheck"
		w /cup(23,1) 
		i $$YN("Confirm start of DataMove DataCheck","N")="Y" {
			s Status=##Class(DataMove.API).DataCheckStart(Name)
			i '(''Status) {
				d MESSAGE24($System.Status.GetErrorText(Status),2)
	 			Continue
 			}
			s Msg="Starting DataCheck..."
			d MESSAGE24(Msg,2)
		}
		continue
	}
	i Action="Halt" {
		w /cup(23,1) 
		i $$YN("Confirm halt of DataMove DataCheck","N")="Y" {
			s Status=##Class(DataMove.API).DataCheckStop(Name)
			i '(''Status)  {
				s Msg="Error halting DataCheck "_$SYSTEM.Status.GetErrorText(Status)
				Try { s TransactionMode=$zu(139,1) s ^|"^^"_%DMStorageDir|IRIS.DataMove.LogD(Name,$i(^|"^^"_%DMStorageDir|IRIS.DataMove.LogD(Name)))=$lb($ztimestamp,Msg,$j) d $zu(139,TransactionMode) } catch { d $zu(139,TransactionMode) } k TransactionMode
				d MESSAGE24(Msg,4)
			} else {
				s Msg="Halting DataCheck..."
				d MESSAGE24(Msg,2)
			}
		}
		continue
	}
 	i Action="RunAgain" {
	 	d CLEAR(6,23)
		w /cup(7,1),"You have selected to run the DataCheck on all the ranges again."
		w /cup(8,1),"You will not be able to run activate until after the DataCheck finishes."
		w /cup(9,1),"The last DataCheck took "_Info("CheckTime")_" to run."
		w /cup(11,1)
		i $$YNSCREEN("Do you want to run DataCheck for all ranges","N")="Y" {
			w /cup(12,1)
			i $$YNSCREEN("Confirm running DataCheck for all ranges","N")="Y" {
				w /cup(13,1),"Restarting DataCheck..."
				s Status=##Class(DataMove.API).DataCheckRestartAll(Name)
				i '(''Status)  {
					s Msg="Error running DataCheck Restart "_$SYSTEM.Status.GetErrorText(Status)
					w:1 !,Msg Try { s TransactionMode=$zu(139,1) s ^|"^^"_%DMStorageDir|IRIS.DataMove.LogD(Name,$i(^|"^^"_%DMStorageDir|IRIS.DataMove.LogD(Name)))=$lb($ztimestamp,Msg,$j) d $zu(139,TransactionMode) } catch { d $zu(139,TransactionMode) } k TransactionMode h 4
				}
			}
		}
		d CLEAR(6,24)
		continue
 	}
	continue
 }
Exit
 q Action
Error s $zt=""
 i $ze'["<INTER"  w /cup(23,1),$ze_%Blank h 10
 s Action="Quit"
 g Exit
} 
CheckRangeDisplay(Name,SrcDBs,DstDBs,Ranges,FirstDisplayed,LastDisplayed,PageSize,RetRanges,ClearEnd=1) Private {
 w /cup(4,1)
 s Status=##Class(DataMove.API).GetProperties(Name,.Properties)
 i '(''Status) {
	s Status="Status: Error running GetProperties()"_$System.Status.GetErrorText(Status)
	w /cup(4,1),$e(Status_$e(%Blank,1,160-$l(Status)),1,159) h 5
	q
 }
 s Status="Status: "_$case(Properties("Status"),1:"OK",:$System.Status.GetErrorText(Properties("Status")))
 w $e(Status_$e(%Blank,1,160-$l(Status)),1,159)
Redo
 Set Rset = ##class(%Library.ResultSet).%New("DataMove.API:ListDataCheckRanges")
 s Status=Rset.Execute(Name,SrcDBs,DstDBs,Ranges)
 i '(''Status) {
	s Status="Status: Error running query ListDataCheckRanges "_$System.Status.GetErrorText(Status)
 	w /cup(4,1),$e(Status_$e(%Blank,1,160-$l(Status)),1,159) h 5
	q 0
 }
 k RetRanges
 k RangesCount
 s RowCount=1
 s PageSize=7
 i '$d(FirstDisplayed) s FirstDisplayed=1
 s LastDisplayed=FirstDisplayed+PageSize
 s NumDisplayed=0
 s MaxRangeLen=14
 While Rset.Next() {
	s RetRanges($i(RangesCount))=$lb(Name,Rset.Data("SrcDB"),Rset.Data("DstDB"),Rset.Data("Range"))
	i (RangesCount>=FirstDisplayed),(RangesCount<=LastDisplayed) {
		s NumDisplayed=NumDisplayed+1
		w /cup(RowCount*2-2+6+1,1)
  		w $j(Rset.Data("RowCount"),3)
  		s Displayed(NumDisplayed,1)=Rset.Data("SrcDB")_"->"_Rset.Data("DstDB")
  		s Displayed(NumDisplayed,2)=Rset.Data("Range")
  		i $l(Displayed(NumDisplayed,1))>MaxRangeLen s MaxRangeLen=$l(Displayed(NumDisplayed,1))
 		s Displayed(NumDisplayed,3)=Rset.Data("StateExternal")
		i Rset.Data("StateExternal")="Done" {
	  		s Displayed(NumDisplayed,4)=$j($e($p($e(Rset.Data("TimeEndLocal"),3,*),"."),4,*),17)
		} else {
	  		s Displayed(NumDisplayed,4)=$j($e($p($e(Rset.Data("LastUpdateTimeLocal"),3,*),"."),4,*),17)
		}
		;w /el(0)
 		w /cup(RowCount*2-2+6+2,1)
 		s Displayed(NumDisplayed,5)=Rset.Data("MBCopied")
 		s Displayed(NumDisplayed,6)=Rset.Data("MBChecked")
 		s Displayed(NumDisplayed,7)=Rset.Data("PctChecked")
 		s Displayed(NumDisplayed,8)=Rset.Data("Differences") 		
		s RowCount=RowCount+1
	}
 }
 d Rset.Close()
 k Rset
 w /cup(6,1)
 w "  ",?4,"SrcDB->DstDB",?MaxRangeLen+5,"Range" w /el(0)
 f i=1:1:NumDisplayed {
	w /cup(i*2-2+6+1,5)
	w Displayed(i,1),?MaxRangeLen+5,Displayed(i,2)
  	w /cup(i*2-2+6+1,53),Displayed(i,3),/el(0)
  	w /cup(i*2-2+6+1,64),Displayed(i,4)
  	w /cup(i*2-2+6+2,1)
 	w ?18,$j(Displayed(i,5),8)
 	w ?28,$j(Displayed(i,6),8)
 	w ?37,$j(Displayed(i,7),3)
  	w ?41,$j(Displayed(i,8),5)
 	w /el(0)
}
 i LastDisplayed>$g(RangesCount,0) s LastDisplayed=$g(RangesCount,1)
 i (NumDisplayed=0),$d(RangesCount) {
 	d CLEAR(7,24)
	s FirstDisplayed=1 
	g Redo
 }
 s RetRanges=$g(RangesCount,0)
 i ClearEnd d CLEAR(RowCount*2+5,22) 
 q 1
}
RunCheckRangeDisplayDetail(Num,RetRanges) { 
 d CLEAR(7,22)
 s MaxNum=$o(RetRanges(""),-1)
 f  {	 
	s RngList=RetRanges(Num)
	i '$$CheckRangeDisplayDetail($li(RngList,1),$li(RngList,2),$li(RngList,3),$li(RngList,4),0) q	 
	s Status=##Class(DataMove.API).DataCheckGetRangeInfo($li(RngList,1),$li(RngList,2),$li(RngList,3),$li(RngList,4),.Info)
	i '(''Status) {
		d MESSAGE24($System.Status.GetErrorText(Status),3)
		q
	}
	s Prompt="(N)ext range,(P)rev range,"
	i Info("Differences") {
		s Prompt=Prompt_"(D)iffs,"
	}
	i Info("StateExternal")="Done" {
		s Prompt=Prompt_"Run(A)gain,"			
	}
	s Prompt=Prompt_"(Q)uit => "
	d CLEAR(23,23)
	w /cup(23,1)
	u 0:(:"+S")
	w Prompt
	r *Key:%Rate s ZB=$ZB
	u 0:(:"-S")
	i (Key=27),($a($e(ZB,2))=91),($a($e(ZB,3))=65) s Num=Num-1 s:Num=0 Num=1 d CLEAR(7,22) continue
	i (Key=27),($a($e(ZB,2))=91),($a($e(ZB,3))=66) s Num=Num+1 s:Num>MaxNum Num=MaxNum d CLEAR(7,22) continue
	i (Key=78)!(Key=110) s Num=Num+1 s:Num>MaxNum Num=MaxNum d CLEAR(7,22) continue
	i (Key=80)!(Key=112) s Num=Num-1 s:Num=0 Num=1 d CLEAR(7,22) continue
	i (Key=81)!(Key=113) d CLEAR(7,22) q
	i ((Key=68)!(Key=100))&Info("Differences") {
		d CLEAR(18,23)
		w /cup(18,1)
		d ExportRangeDiff($li(RngList,1),$li(RngList,2),$li(RngList,3),$li(RngList,4))
		q
	}
 	i ((Key=65)!(Key=97))&(Info("StateExternal")="Done")  {
	 	d CLEAR(18,23)
		w /cup(18,1),"You have selected to run the DataCheck on the selected range."
		w /cup(19,1),"You will not be able to run activate until after the DataCheck finishes."
		w /cup(20,1),"The last DataCheck on this range took "_Info("CheckTime")_" to run."
		w /cup(21,1)
		i $$YNSCREEN("Do you want to run DataCheck for this range","N")="Y" {
			w /cup(22,1)
			i $$YNSCREEN("Confirm running DataCheck for this range","N")="Y" {
				w /cup(23,1),"Restarting DataCheck..."
				s Status=##Class(DataMove.API).DataCheckRestartRange($li(RngList,1),$li(RngList,2),$li(RngList,3),$li(RngList,4))
				i '(''Status)  {
					s Msg="Error running DataCheck Range Restart "_$SYSTEM.Status.GetErrorText(Status)
					w:1 !,Msg Try { s TransactionMode=$zu(139,1) s ^|"^^"_%DMStorageDir|IRIS.DataMove.LogD(Name,$i(^|"^^"_%DMStorageDir|IRIS.DataMove.LogD(Name)))=$lb($ztimestamp,Msg,$j) d $zu(139,TransactionMode) } catch { d $zu(139,TransactionMode) } k TransactionMode h 4
				}
			}
		}
		d CLEAR(6,23)
		q
 	}
 }
 q
}
CheckRangeDisplayDetail(Name,SrcDB,DstDB,Range,ClearEnd=1) {
 i '$$CheckRangeDisplay(Name,SrcDB,DstDB,Range,,,,,ClearEnd) q 0
 Set Rset = ##class(%Library.ResultSet).%New("DataMove.API:ListDataCheckRanges")
 s Status=Rset.Execute(Name,SrcDB,DstDB,Range)
 i '(''Status) {
	s Status="Status: Error running query ListRanges "_$System.Status.GetErrorText(Status)
 	w /cup(4,1),$e(Status_$e(%Blank,1,160-$l(Status)),1,159) h 5
	q 0
 }
 d Rset.Next()
 w /cup(8,1)
 w ?18,$j(Rset.Data("MBCopied"),8)
 w ?28,$j(Rset.Data("MBChecked"),8)
 w ?37,$j(Rset.Data("PctChecked"),3)
 w ?41,$j(Rset.Data("Differences"),5)
 w /el(0)
 s Row=9
 ;w /cup(Row,1),    "Last Updated:    ",Rset.LastUpdateTimeLocal
 w /cup($i(Row),1),"Start Time:      ",Rset.TimeStartLocal
 w /cup($i(Row),1),"End Time:        ",Rset.TimeEndLocal
 w /cup($i(Row),1),"Total Time:      ",$j(Rset.CheckTime,23)
 w /cup($i(Row),1),"Nodes Checked:   ",Rset.NodesChecked
 w /cup($i(Row),1),"Last Node:       ",$e(Rset.LastNodeChecked,1,220)
 w /cup($i(Row),1),"Pid:             ",Rset.CheckPid
 d $i(Row)
 d $i(Row)
 w /cup($i(Row),1),"Status:          "
 i Rset.Status=1 {
	 w "Ok"
 } else {
	 w $SYSTEM.Status.GetErrorText(Rset.Status)
 }
 q 1
}
ExportRangeDiff(Name,SrcDBs="*",DstDBs="*",Ranges="*") {
 s $zt="Error"
 s SaveIO=$i
 s Flag=8+4
 s IOFlag=4
 s Prompt="Output device?",Help(1)="Enter the device to which you wish to write DataCheck differences."
 s Status=##class(%Library.Device).Get(Prompt,.IO,.Help,Flag,,IOFlag,.IOSL,.IOF,.IOBS,.IOM,.IOPAR,.IOT,.IOST,.ANS,.RMSDF)
 i (Status=0)||(Status=3)||(Status=2) g Exit
 i IO'=SaveIO u SaveIO w !,"Exporting....."
 Set Rset = ##class(%Library.ResultSet).%New("DataMove.API:ListDataCheckDiffs")
 s Status=Rset.Execute(Name,SrcDBs,DstDBs,Ranges)
 i '(''Status) {
	w !,"Status: Error running query ListDataCheckDiffs "_$System.Status.GetErrorText(Status)
 	g Exit
 }
 u IO
 w !,$J("DataCheck report for DataMove "_Name,$L("DataCheck report for DataMove "_Name)+%RM\2)
 w !,$J($ZDATETIME($H),$L($ZDATETIME($H))+%RM\2)
 w !
 w !,"Source DBs selection:      "_SrcDBs
 w !,"Destination DBs selection: "_DstDBs
 w !,"Ranges selection:          "_Ranges
 w !
 w !," Num",?6,"Node",?40,"Reason"
 w !," ---",?6,"----",?40,"------"
 s Num=0
 While Rset.Next() {
 	w !
 	s Num=Num+1
  	w $j(Num,4)
  	w ?6,Rset.Data("Node")
  	i $x>40 w !
	w ?40,Rset.Data("Reason")
 }
 c IO
 u SaveIO
 w !,"Export of "_Num_" differences complete"
 r !,"Press any key to continue: ",*x
Exit
 u SaveIO
 i $d(IO),(IO'="") c IO
 f i=1:1:24 w !
 q
Error s $zt=""
 s $zt=""
 d BACK^%ETN
 g Exit
}
GetKeyNum(Key) Public {
 s RetKey=""
 f  {
	i (Key>=48),(Key<=57) {
		s RetKey=RetKey_$c(Key)
		r *Key:1
		q:Key=-1
		q:Key=13  ;<CR>
 	} else {
 		s RetKey=0
 		q
 	}
 }
 q +RetKey ;helps 001
}
CenterString(String,Size) {
 s Len=$l(String)
 s PadLen=Size-Len
 q:PadLen<=0 String
 s (PadFront,PadEnd)=PadLen\2
 s PadEnd=PadEnd+(PadLen#2)
 q $e(%Blank,1,PadFront)_String_$e(%Blank,1,PadEnd)
}
CLEAR(first,last) {
 w /cup(first,1)
 f i=first:1:last w /cup(i,1),%Blank 
 w /cup(1,1)
 q
}
MESSAGE24(msg,hangval) w /cup(24,1),msg,$j("",80-$x) h hangval w /cup(24,1),$j("",80) q
LOG() Public {
 s $zt="MENUE"
 w " #",?3,"Name",?18,"MBToCopy",?28,"Copied",?35,"Pct",?39,"Checked",?47,"Pct",?51,"JrnMB",?57,"State",/el(0)
 Set Rset = ##class(%Library.ResultSet).%New("DataMove.API:ListDMs")
 s Status=Rset.Execute("*",0)
 i '(''Status) {
	w !,"Status: Error running query ListDMs "_$System.Status.GetErrorText(Status)
 	q Status
 }
 While Rset.Next() {
 	s DMNames($i(DMNamesCount))=Rset.Data("Name")
	w !
  	w $j(Rset.Data("RowCount"),2)
  	w ?3,$e(Rset.Data("Name"),1,3)
	w ?18,$j(Rset.MBToCopy,8)
	w ?26,$j(Rset.MBCopied,8)
	w ?35,$j(Rset.PctCopied,3)
	w ?38,$j(Rset.MBChecked,8)
	w ?47,$j(Rset.PctChecked,3)
	w ?51,$j(Rset.JRNMBToApply,5)
	w ?57,Rset.ExpandedState w /el(0)
 }
 d Rset.Close()
 k Rset
 w !
 s DMNum=$$NUMOPTION("Which DataMove (0=End)",1,0,DMNamesCount)
 i DMNum=0 q 1
 s Name=DMNames(DMNum)
MENU
 w !
 w !,"Operating on DataMove "_Name
 w !
 w !,"1) Export range log to file"
 w !,"2) Edit DataMove settings"
 w !,"3) Exit"
 w !
 s Option=$$OPTION("Option? ",3,3)
 i Option=1 d DUMPRANGE g MENU
 ;i Option=2 d SETTINGS g MENU
 q 1
MENUE s $zt=""
 i $ze'["<INTERRUPT>" w !,"ERROR: "_$ZE
 q 1
DUMPRANGE
 Set Rset = ##class(%Library.ResultSet).%New("DataMove.API:ListRanges")
 s Status=Rset.Execute(Name)
 i '(''Status) {
	w !,"Error running query ListRanges "_$System.Status.GetErrorText(Status)
 	q
 }
 k RangesCount
 k RetRanges
 s MaxRangeLen=14
 s NumDisplayed=0
 While Rset.Next() {
	s RetRanges($i(RangesCount))=$lb(Name,Rset.Data("SrcDB"),Rset.Data("DstDB"),Rset.Data("Range"),Rset.Data("RangeInternal"))
	s NumDisplayed=NumDisplayed+1 
  	s Displayed(NumDisplayed,1)=Rset.Data("SrcDB")_"->"_Rset.Data("DstDB")
  	s Displayed(NumDisplayed,2)=Rset.Data("Range")
  	i $l(Displayed(NumDisplayed,1))>MaxRangeLen s MaxRangeLen=$l(Displayed(NumDisplayed,1))
  	s Displayed(NumDisplayed,3)=Rset.Data("PidCopy")
  	s Displayed(NumDisplayed,4)=Rset.Data("PidJrn")
 }
 d Rset.Close()
 k Rset
 w !,"  ",?4,"SrcDB->DstDB",?MaxRangeLen+5,"Range",?63," PidCopy",?71,"   PidJrn"
 f i=1:1:NumDisplayed {
	w !,$j(i,3)," ",Displayed(i,1),?MaxRangeLen+5,Displayed(i,2),?63,$j(Displayed(i,3),8)_" "_$j(Displayed(i,4),8)
 }
 w !
 s RngNum=$$NUMOPTION("Which Range (0=Quit)",0,0,RangesCount)
 i RngNum=0 q
 s Search1=$$STRINGOPTION("Search for string","",1) q:Search1=-1
 k FileName
 s Flag=8+4
 s IOFlag=4
 s Prompt="Export to file name:",Help(1)="Enter the File Name."
 s Status=##class(%Library.Device).Get(Prompt,.FileName,.Help,Flag,,IOFlag,.IOSL,.IOF,.IOBS,.IOM,.IOPAR,.IOT,.IOST,.ANS,.RMSDF)
 i (Status=0)||(Status=3) q
 u FileName
 s SrcDB=$li(RetRanges(RngNum),2)
 s DstDB=$li(RetRanges(RngNum),3)
 s Range=$li(RetRanges(RngNum),5)
 s Status=##Class(DataMove.Data).ExportRangeLog(Name,$lb($lb(SrcDB,DstDB,Range)),Search1)
 c FileName
 i '(''Status) w !,"Error "_$System.Status.GetErrorText(Status)
 q
}
OPTION(prompt,default,max) [] PRIVATE {
 s $zt="OPTIONE"
OPTION1 w !,prompt
 r Option#1 i Option="" q default
 i "QUIT"[$zcvt(Option,"U") s Option=max
 i '(Option?1.2N)!(Option<1)!(Option>max) w !!,"Please enter a number between 1 and "_max,! g OPTION1
 q +Option
OPTIONE s $zt=""
 i $ze'["<INTERRUPT>" w !,"ERROR: "_$ZE
 q 0
}
NUMOPTION(prompt,default,min,max) [] PRIVATE {
 s $zt="NUMOPTIONE"
NUMOPTION1 w !,prompt_"? "_+default_" => "
 r Option i Option="" q default
 i '(Option?1.5N)!(Option<min)!(Option>max) w !!,"Please enter a number between "_min_" and "_max,! g NUMOPTION1
 q +Option
NUMOPTIONE s $zt=""
 i $ze'["<INTERRUPT>" w !,"ERROR: "_$ZE
 q -1
}
STRINGOPTION(prompt,default,allownull) [] PRIVATE {
 s $zt="STRINGOPTIONE"
STRINGOPTION1 w !,prompt_"? " i default'="" w default_" => "
 r Option i Option="",(default'="") q default
 i Option="",(allownull=0) w !,"Please enter a non-null value" g STRINGOPTION1 
 i ($zstrip(Option,"<>W")=""),(allownull=1) s Option=""
 q Option
STRINGOPTIONE s $zt=""
 i $ze'["<INTERRUPT>" w !,"ERROR: "_$ZE
 q -1
}
YNSCREEN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 F  W P_"? "_D Read:t R:t Read:'t R DO  I "^YN"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"yn","YN") I "^YN"'[R W "  enter Yes or No, please"
 S POP=(R="^") Q R
YN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YN"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"yn","YN") I "^YN"'[R W "  enter Yes or No, please"
 S POP=(R="^") W $E($S(R="N":"No",R="Y":"Yes",1:""),$L(X)+1,3) Q R

DBACK^INT^1^67214,47330
DBACK ; Part one of Incremental Backup ;$Change: 7440104 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	; Revision: $Id: //iris/2024.1.3/databases/sys/rtn/user/dback.mac#1 $
 N QUIET,logfile,INTERNAL,NOINPUT,OK
 n BUWARNING
 n quietimeout s quietimeout=60
 S NOINPUT=0   ; Enable input from the user
 S QUIET=0     ; Turn off quiet mode
 S INTERNAL=0  ; We did not come in through the BACKUP entry point
 ;
DEFVARS ; This is the tag used by the 'external' entry point as it has
 ;   already loaded the above variables with its own values...
 i '$SYSTEM.Security.Check("%Admin_Operate","USE") {
 	d msgout($C(7)_$c(13,10)_"Operation requires %Admin_Operate:Use privilege, [Backup failed.]",FORCE)
	s OK=0
	q	 
 }
 s DEFAULTLOG="idpbackup"
 i $g(logfile)="" {
	 ; Generate a new filename
	 s rc=##class(Backup.General).GetFilename(DEFAULTLOG,1,1)
	 i '+$list(rc,1) s OK=0 q
	 s isDefaultLog=1
	 s logfile=$list(rc,2)
	 ; Create output directory if it doesn't exist
	 s dirname=##class(%Library.File).GetDirectory(logfile)
	 i '$l(dirname) s OK=0 q
	 i '##class(%Library.File).DirectoryExists(dirname) {
		 s rc=##class(%Library.File).CreateDirectoryChain(dirname)
		 i 'rc s OK=0 q
	 }
	 ; Record last default backup run
	 s ^SYS("BACKUPTASK",DEFAULTLOG,"LASTFILE")=$$getname^Wsback(DEFAULTLOG)
 } else {
	 s isDefaultLog=0
 }
 s oldmask=##class(%Library.File).SetUMask((64+8+7))
 i logfile'="" d  ;i 'OK q 0   ; signals an error condition   
 . o logfile:"WNS":5 ;new file mode
 . e  w !,"Error creating log file ",logfile,! s OK=0,logfile=""
 d ##class(%Library.File).SetUMask(oldmask) ;restore previous umask
 N %ST,GARCUR,GARNEXT,WDTOP
 N FULL,PARTIAL,NOCHANGE,CLEAR,DELETE,CLOSE,RESTART,CNTINU
 N CUMINC,DIRNAM,LOST,BEGTIME,%SW,%VAL
 N INLOGOR,IBUPass,INC,IND,INE,INF,NoErr
 N BUTYP,DIR,RC,NUMPASS,VOLDIR,DEV,I,MaxPASS
 N ibEOT,ibOfflin,ibDevFul,ibInErr,ibOutErr,ibNoIND,ibNoDAT
 N FORCE,NOFORCE,LOGONLY                                     
 N DIRMNT,ALRDY10,ALRDY13                                
 n i,x,y,stat,CLUMEM,markid,marktx,markinfo
 n CLSTATE,CLUBACKUP  ; used for cluster backups
 n mirrorid,MIRDBINFO  ;used when back is run on a failover mirror member
 n USEENQ ;0 if backup of non-clustered, new format databases only
 n PREVMNT ; Set if we mounted the backup tape
 s PREVMNT=0
 n RCSUCCESS,RCINERR,RCOUTERR,RCMOUNT,RCBADMAP,RCMAPINERR,RCEOT,RCOFFLINE
 n RCDEVFUL,RCOLDFORMAT,RCBADVOLUME,RCENDOFVOL,RCENDOFVOLSET,RCDIRLABELRECORD
 n RCDIRLABELMISSING,RCINERRLABELGOOD,RCBADRECORDONCOPY,RCBADRECORDONRESTORE
 n RCMISSINGBLKS,RCBLKSIZE,RCOUTCLUMNT,RCMAPERR,A,a,VOL,TYPE,DELIM
 n %DN,%DS,%TN,%TS,ANS,DEVMNT,L,LASTDATE,LASTFDATE,LASTFDEV
 n LASTFTIME,LASTHDATE,LASTHFULL,LASTTIME,LASTTYPE,PREVDEV,delerr
 n BACKHDATE,BUFCOUNT,DATE,FN,LastPass,PASS,SIMLABEL,TIME,Y,status,success
 n dlmlock  ;for getLock()
 D INITVARS
 S $ZE=""
 k ze
 ; see if switch 10 is already raised.  If so, leave it
 ; set for the duration of this code
 s ALRDY10=$$CHECK10                                       
 s ALRDY13=$$CHECK13                                       
 s status=$$getLock(.dlmlock)
 if '+status S $ZE="Backup already running, "_$P(status,"^",2) G ERR1 
 S $ZT="ERR1^DBACK"
 d ##class(Backup.General).ClearAbortStatus()
 d msgout($c(13,10)_$c(13,10)_$c(13,10)_"*** The time is: "_$zdt($h,3)_" ***",NOFORCE)
 d msgout($c(13,10)_$c(13,10)_"              "_"InterSystems IRIS"_" Backup Utility",NOFORCE)
 d msgout($c(13,10)_"              --------------------------------",NOFORCE)
 i $$ZU(32,5)  ;free any existing memory
 S $ZT="ERR^DBACK"
 I ALRDY13 S $ZE="Switch 13 must be clear to run DBACK" G ERR 
 I 'INTERNAL,'$$InitDirList^DBACKA(0) do releaseLock(.dlmlock),closelog s OK=0 q
 D GETTYP^DBACKA I TYPE="" do releaseLock(.dlmlock),closelog s OK=0 q  ; Type of backup
 s mirrorid=$$LookupMirrorInfo() ;<mirname>:<mir guid> if a failover member
MAIN ;
 ; Get info for last full backup
 S LASTHFULL=$G(^SYS("BACKUP","LASTFULL","DATE"))
 S LASTFDEV=$G(^SYS("BACKUP","LASTFULL","DEVICE"))
 D CONVDATE(LASTHFULL,.LASTFDATE,.LASTFTIME)
 ; Get info for last backup of any kind
 d ConvHistDate^DBACK
 n LASTHDATENUM
 S LASTHDATENUM=$ZP(^SYS("BACKUP","HISTORY",""))
 S LASTHDATE=$S(LASTHDATENUM:((LASTHDATENUM\1000000)_","_(LASTHDATENUM#1000000)),1:"")
 S LASTTYPE=$S(LASTHDATENUM:$G(^SYS("BACKUP","HISTORY",LASTHDATENUM,"TYPE")),1:"")
 i LASTHDATE<LASTHFULL
 e  i +LASTHDATE=+LASTHFULL,$p(LASTHDATE,",",2)<$p(LASTHFULL,",",2) 
 i  d
 .  ; Last backup was a full backup, so use its data
 . S LASTTYPE=$G(^SYS("BACKUP","LASTFULL","TYPE"))          
 . s:LASTTYPE="" LASTTYPE="Full"   ; Version compatibility  
 . S LASTHDATE=LASTHFULL
 D CONVDATE(LASTHDATE,.LASTDATE,.LASTTIME)
 D GETDEV^DBACKA I 'OK do releaseLock(.dlmlock),closelog D CLEANUP Q
 i 'INTERNAL R !,"Description: ",DESCRIPTION,!
 s DESCRIPTION=$E(DESCRIPTION,1,250)
 d msgout($c(13,10)_"Description"_$c(13,10),LOGONLY)
 ; d msgout("DESCRIPTION"_$$$CRLF,LOGONLY)
 d msgout(DESCRIPTION_$c(13,10),LOGONLY) ; DAH029
 D GETDIRS^DBACKA   
 I 'DIRNAM d  do releaseLock(.dlmlock),closelog s OK=0 q  
 . d msgout($c(13,10)_"Nothing to Backup"_$c(13,10),FORCE)
 . d FREETAPE(1)
 s OK=1 i 'INTERNAL d  q:'OK
 . d msgout($c(13,10)_"Start the Backup (y/n)?",NOFORCE)
 . i '$$YESNO(-1) d
 .. do releaseLock(.dlmlock)
 .. d msgout(" [Not Started]"_$C(7)_$c(13,10)_$c(13,10),NOFORCE)
 .. d FREETAPE(1)
 .. d closelog
 .. s OK=0
 ; switch journal files
 i CLUBACKUP d CLUBINIT d:'OK releaseLock(.dlmlock),closelog q:'OK  i CLUMEM>1 d CLUBEXEC(1,0) d:'OK releaseLock(.dlmlock),closelog q:'OK
 i CLUBACKUP d msgout($c(13,10)_"current system: ")
 d JRNCHECK^DBACKB  ;switch local journal file
 s VOL=1
 ; Record the list of databases which are being backed up this time
 ; to compare with what we use next time.
 k ^SYS("BACKUP","LASTDIRECTORIES")
 merge ^SYS("BACKUP","LASTDIRECTORIES")=^SYS("BACKUP","DIRECTORIES")
 d GetJournalInfo^DBACKB()
 ; Get date/time for this backup
 s BACKHDATE=$H D CONVDATE(BACKHDATE,.DATE,.TIME)
 D VOLLABEL^DBACKA ; output volume label w/ directory names 
 i 'OK D CLEANUP  g:'##class(Backup.General).GetAbortStatus() MAIN do releaseLock(.dlmlock),closelog s OK=0 q
 s LastPass=0 F PASS=1:1 D PASS^DBACKA Q:'OK!LastPass         
 I 'OK G ERR
 i USEENQ D MARKJRN i 'OK g ERR ;place a marker in the journal file
 D CLEANUP
 D POSTPROC^DBACKB
 do releaseLock(.dlmlock)
 d msgout($c(13,10)_"Backup complete."_$c(13,10),FORCE)
 do closelog
 s OK=1
 Q
closelog
 i $g(logfile)'="" c logfile s logfile=""
 q
CLUBINIT ;
 n x,y,i s x=$zu(172,0),CLUMEM=$l(x,";") 
 f i=2:1:CLUMEM d  i $g(CLUMEM(i))="",'$$CONTONERR() s OK=0 q  ;CLUMEM(1) is local system
 . s y=$p(x,";",i),CLUMEM(i,"HOST")=$p(y,",",2),CLUMEM(i,"PORT")=+y 
 . i 'CLUMEM(i,"HOST") d msgout($c(13,10)_"Missing host address of cluster member "_(i-1)_$c(13,10)) q
 . i 'CLUMEM(i,"PORT") d msgout($c(13,10)_"Missing superserver port number on cluster member "_(i-1)_$c(13,10)) q
 . s CLUMEM(i)="|TCP|"_i
 q
CLUBEXEC(cmd,askonerr,markinfo) ;
 n msg,errmsg,i,stat
 s msg=$s(cmd=1:"switching journal file",+cmd=2:"setting journal marker",1:"")
 q:msg=""
 i cmd=1 s cmd=cmd_","_4
 s errmsg="Error "_msg_" on cluster member ",askonerr=+$g(askonerr)
 s i=1 f  s i=$o(CLUMEM(i)) q:i=""  d  i stat<0,askonerr,'$$CONTONERR() s OK=0 q  ;CLUMEM(1) is local system
 . s msg=$c(13,10)_errmsg_(i-1)_":"_$c(13,10)
 . s stat=$$CLIopen^JRNMARK(CLUMEM(i,"HOST"),CLUMEM(i),CLUMEM(i,"PORT"))
 . i stat<0 d msgout(msg_"failed to connect: "_$$ERRMSG^JRNMARK(stat)_$c(13,10)) c CLUMEM(i) s CLUMEM(i)="",CLUMEM(i,"ERR")=stat q
 . s $zt="etCLUBEXEC"
 . s stat=$$CLIexec^JRNMARK(CLUMEM(i),"JMK"_cmd)
 . i stat<0 d msgout(msg_"network error: "_$$ERRMSG^JRNMARK(stat)_$c(13,10)) c CLUMEM(i) s CLUMEM(i,"ERR")=stat q
 . s stat=$p(stat,",",2,$l(stat)) ;status of journal switch or marker setting
 . i stat>0 s:$d(markinfo) markinfo=markinfo_$c(13,10)_stat d msgout($c(13,10)_"cluster member "_(i-1)_": "_$s(cmd=1:"Journal file switched to"_$c(13,10)_$e(stat,2,$l(stat)),1:"Journal marker set at"_$c(13,10)_stat)_$c(13,10)) i 1
 . e  d msgout(msg_"execution failed: "_$p(stat,",",2,$l(stat))_$c(13,10))
 . i $$CLIquit^JRNMARK(CLUMEM(i))
 q
etCLUBEXEC ;
 s $zt=""
 c CLUMEM(i)
 d msgout(msg_"program error: "_$ze_$c(13,10))
 q
CONTONERR() ;returns 1 if we should continue on error; 0 otherise.
 i INTERNAL!QUIET q 1  ;always continue on error if running internally or quietly
 q 0 
INITVARS ; Initialize.
 D:$D(%ST)<11 ^ST                                     
 S DEV=""
 s VOL=1 ; GETDEV needs this
 S FULL=2,PARTIAL=1,NOCHANGE=0,CLEAR=1,DELETE=2,CLOSE=5,NoErr=1
 s CUMINC=3,DELIM=$c(0)
 S RESTART=4,CNTINU=3,INLOGOR=31,IBUPass=32
 S ibEOT=2,ibOfflin=3,ibDevFul=4,ibInErr=-1,ibOutErr=-2
 S ibNoIND=-3,ibNoDAT=-4
 S MaxPASS=20                                           
 S FORCE=1,NOFORCE=2,LOGONLY=3
 s CLUBACKUP=0  ; Gets set to non-zero if a cluster bkup
 s USEENQ=0
 d initconstants
 Q
LookupMirrorInfo() {
 ; returns <mirname>:<MIRROR GUID>:
 ;               <Our Mirror System Guid>:<Our mirror system name>
 ; if we're a failover mirror member or 
 ;         ::<our async system guid>:<our mirror system name>
 ; if we're a NULL if we're a reporting (async) member or
 ; NULL if we're not a mirror member. 
 ;
 ; Backups on failover members contain the mirror name in the 
 ; volume header where as backups on non-failover members
 ; don't
 s retstr=""
 s cls=##class(Config.MirrorMember).Open(,,.rc)
 if '('rc) {
	 s reportingNode=cls.isAsyncMember()
	 if reportingNode {
		s ourname=cls.SystemName
		s ourguid=cls.GetAsyncMemberGUID()
		s cls=""
		; ':' is the seperator because it can't be present
		; within any of the fields. For reporting nodes the mirname
		; and mirguid are null. 
		s retstr="::"_ourname_":"_ourguid
	 } else {
	    s validmember=cls.ValidatedMember
	    if validmember {
			s cls=""
			s mirname=##class(Config.Mirrors).GetMirrorName()
			s cls=##class(Config.Mirrors).Open(mirname,,,.rc)
			if '('rc) {
				s mirguid=cls.GUID
				; id #0 is always the information for the local node
				s info=$G(^SYS("MIRRORSET",mirname,"Member",0))
				s ourname=$LG(info,1)
				s ourguid=$LG(info,2)
				; ':' is the seperator because it can't be present
				; within any of the fields
				s retstr=mirname_":"_mirguid_":"_ourname_":"_ourguid
			}
	    }
	 }
 }
 s cls=""
 quit retstr
}
getLock(dlmlock) ;
 L +^DBACK:1 E  quit "0^another process on this node holds the DBACK lock"
 if $s($S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0):''$zu(59,0),1:0) {
	 s dlmlock=##class(SYS.DLM).%New("DBACK")
	 s dlmlock.Timeout=1 ; 1 second to get the lock
	 s rc=dlmlock.acquire("EXCLUSIVE")
	 if (rc '= 1) {
		 l -^DBACK
		 if rc=-1 quit "0^another cluster member holds the DBACK lock"
		 quit "0^unexpected error, "_dlmlock.ErrorCode_" acquiring cluster DBACK lock"
	 }
 }
 n bckjob s bckjob=$zu(182,3,1) 
 i bckjob<=0 { ;likely to have been set by ExternalFreeze
   d releaseLock(.dlmlock) ;OK to call $zu(182,3,0) as it would do nothing
   q "0^a backup (job #"_(-bckjob)_") on this node is in progress"
 }
 i $zu(182,1) {
   d releaseLock(.dlmlock)
   q "0^an external backup on this node is in progress"
 }
 q 1  ; succeeded
releaseLock(dlmlock)
 i $zu(182,3,0)
 l -^DBACK
 if $s($S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0):''$zu(59,0),1:0),$l($G(dlmlock)) do dlmlock.release() s dlmlock=""
 d ##class(Backup.General).ClearAbortStatus()
 q ;
CONVDATE(IN,DATE,TIME) i IN="" S DATE="",TIME="" q
 s %DN=+IN,%TN=+$P(IN,",",2)
 I '%DN s %DS="",%TS=""
 E  D ^%DO,^%TO
 s DATE=%DS,TIME=%TS
 Q
SWSET   do $SYSTEM.Util.SetSwitch(%SW,%VAL)
	quit
SET10   do $SYSTEM.Util.SetSwitch(10,1)
        quit
CLEAR10 do $SYSTEM.Util.SetSwitch(10,0) 
        quit
CHECK10() n res
	s res=$SYSTEM.Util.GetSwitch(10)
	if '+res quit 0  ; not owned
	if +$P(res,",",2)'=+$J quit 0  ; not owned by us
	quit 1  ; set and owned by us
CHECK13() ;
 quit $SYSTEM.Util.GetSwitch(13)
ERR S $ZT="ERR1" 
 s ze=$ze 
 s zemsg="Backup failed"
 i ze'="" s zemsg=zemsg_", ERROR: "_ze
 s zemsg=zemsg_", see "_$g(logfile)_" for more details"
 d $zu(9,"",zemsg,1 /* broadcast and log message*/,2  /* Severe error */)
 D CLEANUP
 h 20 ; Allow monitor to see the error
ERR1 S $ZT=""
 do releaseLock(.dlmlock)
 do closelog
 i $g(ze)'=$ze {
	 i $g(ze)'="" {
		d msgout($c(13,10)_ze,FORCE)
		d $zu(9,"","Backup failed, ERROR: "_ze_", see "_$g(logfile)_" for more details",1 /* broadcast and log message*/,2  /* Severe error */)
	 }
	 s ze=$ze
 }
 D FREEWD^DBACKA
 D DEQ10^DBACKA
 D DEQ13^DBACKA
 If $d(BUTYP),$d(TYPE),$d(DESCRIPTION) d SETHISTORY^DBACKB($s(##class(Backup.General).GetAbortStatus():-1,1:0))
 d msgout($c(13,10)_ze,FORCE)
 d msgout($C(7)_$c(13,10)_"[Backup failed.]",FORCE)
 s OK=0
 Q
MARKJRN ;
 if CLUBACKUP d  i 1
 . n QUIETMASTERONLY s QUIETMASTERONLY=1 ;quiesce master only
 . d ENQ10 s markinfo=$$CLUSET^JRNMARK(-1,DATE_";"_TIME_";"_TYPE,1) d DEQ10
 e  s markinfo=$$ADD^JRNMARK(-1,DATE_";"_TIME_";"_TYPE)
 i markinfo'>0 d msgout($c(13,10)_"Error setting journal marker: "_$p(markinfo,",",2,$l(markinfo))_$c(13,10)) i 1
 e  d msgout($c(13,10)_"Journal marker set at"_$c(13,10)_"offset "_$p(markinfo,",")_" of "_$p(markinfo,",",2)_$c(13,10))
 q
CLEANUP ;
 d done^DBACKC
 d FREETAPE(0)
 q
 ;
FREETAPE(nounload) ; Dismount tape, with optional unload inhibit
 i PREVMNT d DISMOUNT^DBACKA(PREVDEV,nounload) s PREVMNT=0
 Q
 ;
TIME(a,b) q (a-b*24*3600)+$p(a,",",2)-$p(b,",",2)
 ;
Option(prompt,allow,default) ;ask a prompt, single char return from allow
 ; NOTE: Do not call this routine if NOINPUT is set or else!
 N %ans,%i I default]"" S prompt=prompt_" ["_default_"]"
 d msgout($c(13,10)_prompt,FORCE)
Opt1 d msgout(" (",FORCE)
 F %i=1:1:$L(allow) d
 . d msgout($E(allow,%i),FORCE)
 . d:%i<$L(allow) msgout(", ",FORCE)
 R ") ",%ans
 d msgout(") "_%ans_$c(13,10),LOGONLY)
 I default]"",%ans="" Q $$UP($E(default))
 S %ans=$$UP($E(%ans)) I allow[%ans,(%ans'="") Q %ans
 d msgout($c(13,10)_$J("",$L(prompt)),FORCE) G Opt1
UP(C) Q $zcvt(C,"u")
GYESNO(a,msg,type,title) 
 i '$g(gui,0) q $$YESNO(a)
 q $$IjcMB^%Wprima(msg,type,title)
YESNO(a,c) n b,str
YESNO1 W *-1 ; Flush input buffer
 d msgout($s(a>0:" Yes=> ",a<0:" => ",1:" No=> "),FORCE)
 i $G(c)'="" r b:c i 1
 e  r b
 d msgout(b_$c(13,10),LOGONLY)
 i b="",a'=-1 q a
 s b=$e(b) i b="Y"!(b="y") q 1
 i b="N"!(b="n") q 0
 d msgout($C(7)_" [answer Y or N]",FORCE)
 i $x>70 d msgout($c(13,10),"FORCE")
 goto YESNO1
 ;-------------------------------------------------------------------
 ; EXTERNAL ENTRY POINTS
 ; These are for use by 'external' backup procedures and must be
 ;   used in the order and manner for which they were intended or
 ;   InterSystems will not be able to guarentee the integrity of
 ;   a backup.
 ; All of these entry points return 1 if they are successful or 0 if
 ;   they fail.  Note that this differs from the standard for crossing
 ;   the M/SQL-DCL boarder of 3 for failure and 5 for success generated
 ;   with ZU 4:<ret status>
 ;-------------------------------------------------------------------
LISTDIRS(file,mode) ;
 ; This procedure takes a file name and a mode. See DBACKB for more info
 g LISTDIRS^DBACKB
CLRINC(mode) ;
 ; This procedure clears the incremental backup bits. See DBACKB for more info
 g CLRINC^DBACKB
 ;---------------------------------------------------------------
 ; Cache Version 7.1 BACKUP NOTES/CHANGES
 ; Starting with this version the meaning of the following parameters
 ; has changed somewhat. Due to changes in the journaling mechanism, it is no
 ; longer possible to delete the current journal file, clear the current journal
 ; file, or specify a new journal file name. See the documentation below on
 ; how the behavior has changed.
 ; 
 ; The following procedure invokes a backup using the passed
 ;  arguments to satisfy the questions that are normally asked
 ;  of the user.
 ;
 ;Argument description:
 ; argfile - Values- NULL - take arguments from the argument list
 ;                   <filename> - read arguments from this file
 ;                              - all arguments must be specified
 ;                   NOTE: This argument will be removed in
 ;                         V5b0-9010. See MBACKUP.COM for a discussion
 ;                         of the whys/wherefores (search for 'ofile')
 ;    type - Values-  'I'ncremental
 ;                    'C'umlative incremental
 ;                    'F'ull
 ;                    'E'xternal full backup (mumps up or down)
 ;
 ;    desc - Values - Free form text string, may be NULL
 ;           This is stored in the backup label and in the history
 ;               global and describes the backup
 ;
 ;The following are ignored (and not requried) for backups of type="E"
 ;
 ;  outdev - Values - Where the backup should be sent to:
 ;               Magtape device
 ;               RMS File name
 ;
 ;*******THE MEANING OF THIS PARAMETER HAS CHANGED***********************
 ;  kiljrn - Required (except type="E")
 ;       PREVIOUSLY:
 ;           Values - "Y" delete the journal after backup
 ;                    "N" do NOT delete the journal after backup
 ;                    PH028: Note, when kiljrn is set to "Y", then
 ;                           clrjrn and swjrn are ignored
 ;       CURRENTLY:
 ;           Values - "Y" Switch the journal file after backup
 ;                    "N" ignored
 ;
 ; logfile - Required (ignored if type="E")
 ;           Values - NULL = no log file
 ;                    RMS file name = Send a copy of all messages which
 ;                         would be sent to the terminal to this file
 ;
 ;    mode - Required (ignored if type="E")
 ;       Two piece value delimited by "," where the first piece is one of the following:
 ;           Values - "NOISY" - Default, print all text on terminal
 ;                    "QUIET" - Only display text related to abnormal
 ;                                  conditions
 ;                    "NOINPUT" - No terminal is attached to this
 ;                             process. No output will be sent to
 ;                             the terminal and if a read must be
 ;                             executed the backup is aborted.
 ;                             It is advisable to have a log file.
 ;             NOTE: This switch only affects what is displayed
 ;                   at the terminal, the logfile is always
 ;                   'NOISY'
 ;        The second piece if passed can be = 1 which means that the database backup list
 ;        in ^SYS("BACKUP","DIRECTORIES") has been set by an external call, and to not copy and use the
 ;        predefined list in ^SYS("BACKUPDB")
 ;*******THE MEANING OF THIS PARAMETER HAS CHANGED**********************
 ;    clrjrn - Required
 ;       PREVIOUSLY:
 ;            Values - "Y" - Clear the journal file after backup and
 ;                           swjrn will be ignored.
 ;                     "N" - Do not switch the journal file.
 ;       CURRENTLY:
 ;            Values - "Y" - Switch the journal file.
 ;                     "N" - ignored
 ;*******THE MEANING OF THIS PARAMETER HAS CHANGED**********************
 ;    swjrn  - Required
 ;       PREVIOUSLY:
 ;            Values - "Y" - Switch the journal file after backup
 ;                     "N" - Do not switch the journal file.
 ;       CURRENTLY:
 ;    swjrn  - Required
 ;            Values - "Y" - Switch the journal file after backup
 ;                     "N" - Do not switch the journal file. Note that this
 ;                           is overridden if clrjrn or kiljrn is "Y"
 ;*******THE MEANING OF THIS PARAMETER HAS CHANGED**********************
 ;       PREVIOUSLY:
 ;    nwjrnfil - Required
 ;            Values - NULL - If swjrn is "N"
 ;                   - RMS file specification for the new journal
 ;                     file.
 ;       CURRENTLY:
 ;                 This parameter is now ignored
 ;    quietimeout - Optional (default = 60)
 ;            # of seconds to wait for system to quiesce before aborting backup
 ;            0 or negative # = wait indefinitely
 ;    taskname - passed by Backup.General.StartTask() when the backup is
 ;               jobbed off and quietmode is 1 meaning that we're not called
 ;               from BACKUP^Wsback (eg. a GUI driven backup). In this case
 ;               we need to update the task status here before exiting. Only
 ;               evaluated for backup types F, I and C. 
 ; NOTES:
 ;    Requires read/write access to the SYS global (all modes)
 ;    Mode 'E' causes the .IND, .INE and .INF files in the 
 ;            directories in the SYS global to be deleted.
 ;            The only other action taken is to record this backup
 ;            along with the description in the history global
 ;            as being the LASTFULL backup.
 ;    If SWITCH 10 or 13 is set when this routine is called they
 ;        remain set throughout the backup.  If switch 13 is set then
 ;        it will be converted into a switch 10 since backup needs
 ;        to do sets/kills.  It will be restored upon exit.
 ;    Variables defined by this entry point are NEWed but those
 ;        defined within the body of the DBACK procedure are not.
 ; return value: 0 - failed. Check log file if specified.
 ;               1 - Success.
 ;               1,warning message string - Success but with some warnings.
 ;                 The warnings are separated by ~ in the string.
BACKUP(argfile,EXTTYP,DESCRIPTION,outdev,kiljrn,logfile,mode,clrjrn,swjrn,nwjrnfil,quietimeout,taskname) 
 s taskname=$G(taskname)
 s quietimeout=+$g(quietimeout,60)
 s:'quietimeout quietimeout=60
 New (argfile,EXTTYP,DESCRIPTION,outdev,kiljrn,logfile,mode,clrjrn,swjrn,nwjrnfil,quietimeout,taskname)
 s alias=$s(($i?.N)&&($p($zu(91,$i),",",3)'=""):$p($zu(91,$i),",",3),1:$i)
 i ($zversion(1)=2),($e(alias,1,7)="//./nul") s $p(mode,",",1)="NOINPUT"
 i ($zversion(1)=3),($e(alias,1,9)="/dev/null") s $p(mode,",",1)="NOINPUT"   ;STC2275-
 S $ZT="BCKERR^DBACK"
 i '$SYSTEM.Security.Check("%Admin_Operate","USE") {
 	w !,"Operation requires %Admin_Operate:Use privilege"
 	d $zu(9,"","Backup failed: Operation requires %Admin_Operate:Use privilege",1 /* broadcast and log message*/,2  /* Severe error */)
	s OK=0
	q 0
 }
 s gui=0 ; If called from client mode="GUI"
 i $g(mode)="GUI" s mode="NOISY" s gui=1
 D INITVARS              ; Set up some variables for backup...
 S NOINPUT=1,QUIET=1,INTERNAL=1
 S OK=1
 i argfile'="" d  i 'OK q 0   ; signals an error condition
 . o argfile:"R":5
 . e   w !,"Error opening argument file ",argfile,! s OK=0 q
 . u argfile
 . r EXTTYP,DESCRIPTION,outdev,kiljrn,logfile,mode,clrjrn,swjrn,nwjrnfil
 . c argfile
 s EXTTYP=$$UP($E(EXTTYP))
 i "EFCI"'[EXTTYP d   q 0   ; Signal an error
 . W *7,*7,!,"Invalid backup type - ",EXTTYP,!,*7,*7
 S SW10SET=$$CHECK10                                           
 S SW13SET=$$CHECK13
 ;      If switch 13 is set then we need to convert it to switch 10
 ;      to play with globals. 
 I SW13SET D                                                   
 . S %SW=10,%VAL=1 D INT^SWSET        ; Set switch 10
 . S %SW=13,%VAL=0 D INT^SWSET        ; Clear switch 13        
 i $L($g(mode),",")=1 i '$$InitDirList^DBACKA(0) s $ZE="" g BCKERR
 s alldb=+$p($g(mode),",",2)
 i EXTTYP="E" D   q 1  ; Signals success
 . S ^SYS("BACKUP","LASTFULL","DATE")=$H    ; Record date/time
 . S ^("DESC")=$G(DESCRIPTION)
 . S ^("TYPE")="External Full"                   ; Just so we know...
 . S ^("LOG")=$G(logfile)
 . s BACKHDATE=^SYS("BACKUP","LASTFULL","DATE")
 . s BUTYP=5,TYPE="External Full",DEV=$G(outdev)
 . D SETHISTORY^DBACKB(1)
 . S DIR=""
 . I SW13SET  S %SW=13,%VAL=1 D INT^SWSET  ; Set switch 13  
 . I 'SW10SET S %SW=10,%VAL=0 D INT^SWSET  ; Clear switch 10
 . F  S DIR=$O(^SYS("BACKUP","DIRECTORIES",DIR)) q:DIR=""  d  
 .. s zu49=+$$ZU(49,DIR)  ;KMK106
 .. I zu49'=-2,zu49'=-3 D     ; Only process directories which exist
 ...     S D=$$ZU(12,DIR)  ; Just incase is a logical w/o ":" 
 ...     ;Clear force full back flag, it assumes full back has been done for BACKUP^DBACK("","E")
 ...     D $zu(52,9,DIR,0)
 ...     D SetNames^DBACKA(D)       
 ...     I $$INLOGOR(D,2,2,1)
 ...     I $$INLOGOR(D,1,1,1)
 ...     I $$INLOGOR(D,0,0,1)
 .; Record the list of databases which are being backed up this time
 .; to compare with what we use next time.
 . k ^SYS("BACKUP","LASTDIRECTORIES")
 . merge ^SYS("BACKUP","LASTDIRECTORIES")=^SYS("BACKUP","DIRECTORIES")
 ;
 ; EXTTYPE="C", ="F" or "I". Invoke DEFVARS to run the backup
 ;
 I SW13SET  S %SW=13,%VAL=1 D INT^SWSET    ; Set switch 13
 I 'SW10SET S %SW=10,%VAL=0 D INT^SWSET    ; Clear switch 10
 i 'OK q 0 ;this line is probably redundant
 s INTERNAL=1                 ; Flag that this is from here         
 s mode=$$UP($E(mode,1,4))
 S QUIET=0          ; Turn off quiet mode
 S NOINPUT=0        ; Flag that we do have an input device
 I mode="QUIE" s QUIET=1  ; quiet mode
 I mode="NOIN" s QUIET=1,NOINPUT=1 ; quiet mode & no input
 D DEFVARS                      ; Invoke the dback procedure
 If $g(BUWARNING)]"",OK s OK=OK_","_BUWARNING
 I SW13SET D                                                   
 . S %SW=10,%VAL=1 D INT^SWSET        ; Set switch 10
 . S %SW=13,%VAL=0 D INT^SWSET        ; Clear switch 13        
 if $L(taskname) {
	 ; When taskname is passed this is a jobbed backup from
	 ; Backup.General.StartTask() and we need to update the
	 ; task status before exiting.
	 s P10=taskname
	 s return=OK
	 d SetStatus^Wsback
 }
 i $g(logfile)'="" c logfile
 I SW13SET  S %SW=13,%VAL=1 D INT^SWSET       ; Set switch 13 
 I 'SW10SET S %SW=10,%VAL=0 D INT^SWSET       ; Clear switch 10
 n dir s dir="" f  s dir=$o(bkpmount(dir)) q:dir=""  i $zu(3,dir)
 q OK      ; Ok contains the exit status (0=fail, 1=success)
BCKERR s $ZT="" 
 i $ZE'="" w !,$ZE
 s zemsg="Backup failed"
 i $ZE'="" s zemsg=zemsg_", ERROR: "_$ZE
 s zemsg=zemsg_", see "_$g(logfile)_" for more details"
 d $zu(9,"",zemsg,1 /* broadcast and log message*/,2  /* Severe error */)
 w !
 if $L(taskname) {
	 ; When taskname is passed this is a jobbed backup from
	 ; Backup.General.StartTask() and we need to update the
	 ; task status before exiting.
	 I ($$CHECK13) {                                                   
	    ;Convert to switch 10 so we can update globals
	    S %SW=10,%VAL=1 D INT^SWSET        ; Set switch 10
 		S %SW=13,%VAL=0 D INT^SWSET        ; Clear switch 13        
	 }
	 s ^SYS("BACKUP","LastError")=logfile_","_$ZE
	 s P10=taskname
	 s return=0 ; failure status
	 d SetStatus^Wsback
 }
 if $l($g(logfile)) {
	 s IO=$I 
	 o logfile:"WAS":5
	 if $T {
	    u logfile 
	    w !,"Unexpected error: ",$ZE 
	    c logfile 
	 }
	 u IO
 }
 I SW13SET  S %SW=13,%VAL=1 D INT^SWSET       ; Set switch 13  
 I 'SW10SET S %SW=10,%VAL=0 D INT^SWSET       ; Clear switch 10
 n dir s dir="" f  s dir=$o(bkpmount(dir)) q:dir=""  i $zu(3,dir)
 q 0                       ; Indicates failure
initconstants ;
 s RCSUCCESS=1   ;success
 s RCINERR=-1    ; General Input error
 s RCOUTERR=-2   ; General output error 
 s RCMOUNT=-4    ; either directory name was too long or we couldn't mount the directory
 ; input errors during backup (in addition to RCINERR)
 s RCBADMAP=-11  ; 2kb: missing incremental bitmaps
 ;big database: Bad label in incremental backup bitmap
 s RCMAPINERR=-13 ; disk error reading incremental backup bitmap
 ;
 ; write errors during backup (in addition to RCOUTERR)
 ;
 s RCEOT=2       ; Output: end of tape or volume
 s RCOFFLINE=3   ; Output device offline
 s RCDEVFUL=4    ; Output: file expansion failed
 ; # 5 no longer used
 ;
 ; input errors during $zu(52,0,device) which opens input volume and reads label
 ; (in addition to RCINERR)
 s RCOLDFORMAT=-6        ; On a restore, Input file has old backup
                         ;file format.  Abort the restore.
 s RCBADVOLUME=-7        ; Input file is not backup file format.
                         ;In general, if we fail during open of input
                         ;device or 1st read of it we get an RCINERR error.
                         ;If the volume block's contents are bad, we
                         ;get either RCBADVOLUME or RCOLDFORMAT
 ; success returns during restore
 s RCENDOFVOL=-10        ; End of input backup volume reached
 s RCENDOFVOLSET=-17     ; End of input backup volume reached and
                         ; this is the last volume
 s RCDIRLABELRECORD=-18  ; reached a directory label record, current
                         ; record is next record
 s RCDIRLABELMISSING=-19 ; we're at a data record for a different
                         ; directory and we should act as if we
                         ; reached a directory label except the
                         ; current record is the first data block of the
                         ; next directory to be restored.  This usually
                         ; is the result of various read errors that
                         ; resulted in missing a directory label record
 ; input errors during restore (during restore, if we get an input
 ; error we usually translate it to something else)
 s RCINERRLABELGOOD=-14  ; We got an error reading a block but
                         ; it passed validation on its label.
                         ; The contents should be reported by the
                         ; utility as suspicious unless we can
                         ; determine that there's a particular
                         ; 1 or more records that fail crc.
                         ; We should then try to restore its contents,
                         ; and we should expect one or more of the
                         ; records in the block to result in
                         ; a RCBADRECORDONRESTORE error.
 s RCBADRECORDONCOPY=-15 ; record in rinbp->ricurr is bad
                         ; It was bad when the backup was originally
                         ; created i.e. we got a read error during
                         ; the backup). Normally the utility
                         ; should save a copy of the block that
                         ; is already in the CACHE.DAT file and
                         ; then restore this block
 s RCBADRECORDONRESTORE=-8 ; record in rinbp->ricurr failed
                         ; CRC validation, probably due to a read
                         ; error during the restore.
                         ; We probably previously got a
                         ; RCINERR_LABELGOOD error on this block.
                         ;  If both _ONCOPY and _ONRESTORE conditions
                         ; are present, we report it as _ONRESTORE.
                         ; Normally the utility should save a copy of the
                         ; block that is already in the CACHE.DAT file and
                         ; then restore this block
 s RCMISSINGBLKS=-16     ; The block # of the last record in the last block
                         ; successfully read from the input media doesn't
                         ; match what this block has in incrlabel_LASTBLKNUM
                         ; and incrlabel_LASTSFN.   We must have skipped
                         ; some blocks (which is probably the result of read
                         ; errors.)
 s RCABORT=-21           ; The backup operation is aborted by user's request.
 ; -9, RCBADLABEL, is no longer used.  If we get an input block
 ; whose label fails validation (e.g. CRC wrong), we act like we
 ; just got an input error
 s RCBLKSIZE=-12 ; record in rinbp->ricurr has the wrong
                 ;block size for this CACHE.DAT file
                 ;If this is the first block for this CACHE.DAT
                 ;then we probably are restoring to the wrong
                 ;CACHE.DAT (one with a different block size),
                 ;and that is a fatal error.  Otherwise it is
                 ;probably a label error and we should skip this
                 ;input block.
 ; other restore errors in $zu(52,1,...) and $zu(52,4)*/
 s RCOUTCLUMNT=-3        ; Target of restore is cluster mounted
                         ; but must be privately mounted.  This error
                         ; occurs when we issue $zu(52,1,...) to open
                         ; cache.dat file as target JAO742
 s RCMAPERR=-5   ; 2kb only: Problem detected between
                 ; source & target map blocks.  This is
                 ; a fatal error in attempting to restore
                 ; to this target file JAO572
 q
ConvHistDate ;
 n idx,nidx s idx=""
 while (1) {
  s idx=$O(^SYS("BACKUP","HISTORY",idx)) q:$l(idx,",")<2
  s nidx=(+idx*1000000+$p(idx,",",2))
  m ^SYS("BACKUP","HISTORY",nidx)=^SYS("BACKUP","HISTORY",idx)
  k ^SYS("BACKUP","HISTORY",idx)
 }
 q
PurgeLog(ByDays=30,Timeout=60) [] public {
  s timelimit=(+($h-ByDays)_","_($p($h,",",2)-1)*1000000+$p(($h-ByDays)_","_($p($h,",",2)-1),",",2))
  L +^DBACK:Timeout e  q 0
  s Status=1
  s $zt="exit"
  s date=""
  f {
	  s date=$o(^SYS("BUHISTORY",0,"LOGNOTPURGED",date),-1)
	  q:date=""
	  continue:(date>timelimit)
	  s logfile=$g(^SYS("BUHISTORY",date,"LOG"))
	  i logfile'="" {
		  s rc=##class(%Library.File).Delete(logfile)
		  i rc<0 {
			  d $zu(9,"","PurgeLog^DBACK: Error deleting "_logfile_": "_rc,(1>0),1)
			  s Status=$$Error^%apiOBJ(5019,logfile)
			  q
		  }
	  }
	  k ^SYS("BUHISTORY",0,"LOGNOTPURGED",date)
  }
exit s $zt="" i $ze'="" s Status=$$Error^%apiOBJ(5002,$ze)
  L -^DBACK
  q $g(Status,1)
}
INLOGOR(DIR,SOURCE,TARGET,DISPOSE) ;Adapter, present same i'face for VAX & UX
 n rc
 try {
   s rc=$ZU(31,DIR,SOURCE,TARGET,DISPOSE)
 } catch {
   s rc=-1_","_$ze
   s $ze=""
 }
 q rc
FILENORM(NAME) ;Return normalized version of NAME
 S OK=1,$ZT="FNERR"
 N MTDEV,DIR S MTDEV=$$OSDEVICE(NAME) I MTDEV'="" S ISREG=0 Q NAME
 i ($zversion(1)=2),$E(NAME,1,2)="\\" S L=$$CheckForTape(NAME) I L'="" S ISREG=0 Q L
 i ($zversion(1)=2) S L=$L(NAME,"\"),DIR=$P(NAME,"\",1,L-1)
 i ($zversion(1)=2) IF L>1 S DIR=DIR_"\"
 i ($zversion(1)=2) S NAME=$ZU(12,DIR)_$P(NAME,"\",L,L),ISREG=$ZU(140,7,NAME),ISREG=$S(ISREG>0:1,ISREG=-2:1,1:0) Q NAME
 i ($zversion(1)=3) S L=$L(NAME,"/"),DIR=$P(NAME,"/",1,L-1)
 i ($zversion(1)=3) IF L>1 S DIR=DIR_"/"
 i ($zversion(1)=3) S NAME=$ZU(12,DIR)_$P(NAME,"/",L,L),ISREG=$ZU(140,7,NAME),ISREG=$S(ISREG=-2:1,ISREG/32768#2:1,1:0) Q NAME
FNERR S OK=0,ERRMSG="Not a valid device name." Q
CheckForTape(NAME)
 S NAME=$ZCVT(NAME,"U")
 N I,TAPE
 For I=47:1:62 s TAPE=$$OSDEVICE(I) I NAME=$ZCVT(TAPE,"U") S NAME=I Q
 I NAME?2N Q NAME
 I NAME?1"\\.\TAPE"1N Q NAME
 Q ""
TQUIWRITE(verbose) q $$QUIESCE(1,"buffer activity",10,verbose)
TQUIGC(verbose) q $$QUIESCE(2,"garbage collection",10,verbose)
TQUIDB(verbose) q $$QUIESCE(4,"database expansion",10,verbose)
TQUIGLO(verbose) q $$QUIESCE(8,"global activity",10,verbose)
TQUIGLOUPD(verbose) q $$QUIESCE(16,"global updates",10,verbose)
TQUINET(verbose) q $$QUIESCE(32,"network activity",10,verbose)
TQUIDISK(verbose) q $$QUIESCE(1+2,"disk activity",10,verbose)
TQUIUPD(verbose) q $$QUIESCE(1+2+4+16,"update activity",10,verbose)
TQUISYS(verbose) q $$QUIESCE(1+2+4+8,"system activity",10,verbose)
QUIESCE(bits,text,retries,verbose,intv) ;
 s verbose=+$g(verbose),retries=+$g(retries,-1),intv=+$g(intv,1)
 q ($$Quiesce(bits,text,retries,verbose,intv)>0)
Quiesce(bits,text,retries,verbose,intv) ;
 n noWDbits
 s $zt="QUIESCEE"
 q:$zu(51,bits) 1 ;double checking $ZU(51) is no longer necessary
 s verbose=+$g(verbose),retries=+$g(retries,-1),intv=+$g(intv,1)
 d msgout($c(13,10)_"WARNING: Switch is set and may affect production for up to "_(retries*intv)_" seconds."_$c(13,10)_"Waiting for "_text_" to finish...",NOFORCE)
 f  q:'retries  h intv q:$zu(51,bits)  s retries=retries-1 i retries#5=0 d msgout(".",NOFORCE)
 s noWDbits=1
 s:$s($S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0):''$zu(59,0),1:0) noWDbits=noWDbits+2
 s noWDbits=$zboolean(bits,noWDbits,2)  ;2 = x & ~ y
 if '$ZU(51,bits),bits'=1,$zboolean(bits,1,1),$zu(51,noWDbits) {
	 d msgout($c(13,10)_"System is idle except WD is still running."_$c(13,10)_"     Waiting up to 2 minutes for WD to finish",NOFORCE)
	 f i=1:1:120 q:$ZU(51,bits)  h 1 if i#5=0 d msgout(".",NOFORCE)
	 if $ZU(51,bits) s retries=1 ;signal success
 }
 d msgout($s(retries:" ready.",1:" abort. "_$$quiescefailmsg(bits))_$c(13,10),NOFORCE)
 q retries
quiescefailmsg(bits)
 N ret,clu,clumsg s ret="",clu=$zb(bits,512+256+128,1),clumsg=""
 if $zb(clu,128,1)||($zb(clu,(256+512),1)=(256+512)) s clu=128,clumsg=" (cluster wide)"
 if $zb(clu,512,1) s clumsg=" (cluster master only)"
 if $zb(clu,256,1) s clumsg=" (cluster slaves only)"
 if $zb(bits,1,1)&&('$ZU(51,clu+1)) S ret=ret_"write daemon"_clumsg_","
 if $zb(bits,2,1)&&('$ZU(51,clu+2)) S ret=ret_"garbage collector"_clumsg_"," 
 if $zb(bits,4,1)&&('$ZU(51,clu+4)) S ret=ret_"file expander"_clumsg_","
 if $zb(bits,8,1)&&('$ZU(51,clu+8)) S ret=ret_"global reference"_clumsg_","
 if $zb(bits,16,1)&&('$ZU(51,clu+16)) S ret=ret_"global update"_clumsg_","
 if $zb(bits,32,1)&&('$ZU(51,clu+32)) S ret=ret_"client-side network connections"_clumsg_","
 if $zb(bits,64,1)&&('$ZU(51,clu+64)) S ret=ret_"network server activity"_clumsg_","
 if ret'="" s ret="Quiesce failed reason: "_$e(ret,1,*-1) d $zu(9,"",ret,1,2) i $d(^rOBJ("ZQuiesceFail")) d ^ZQuiesceFail
 Q ret
QUIESCEE s $zt="" d $zu(9,"","QUIESCE: "_$ze,(1>0),1) q -1 ;0
CluQuiet(switch,target,timeout)
 n flags,rc
 i $g(switch)-10,$g(switch)-13 ztrap "SWITCH"
 n targetmsg s target=$g(target)
 i target=1 s target=256,targetmsg=" on cluster slave members"
 e  i target=2 s target=512,targetmsg=" on cluster master"
 e  s target=512+256,targetmsg=" cluster wide"
 s flags=1+2+4+$s(switch=10:8,1:16)
 s rc=$$Quiesce(flags+target,$s(switch=10:"system activity",1:"update activity")_targetmsg,$g(timeout,10),'$g(QUIET,$g(QUIETLY)))
 i rc<0 ztrap "Abort"
 q rc
quietsw(switch,timeout) ;quiesce activities w/ timeout after setting switch 10 or 13
 n flags,rc
 i $g(switch)-10,$g(switch)-13 ztrap "SWITCH"
 s flags=1+2+4+$s(switch=10:8,1:16)
 i CLUBACKUP s flags=flags+128
 s rc=$$Quiesce(flags,"disk cleanup",$s($g(timeout)="":30,1:timeout),'$g(QUIET))
 i rc<0 ztrap "Abort"
 q rc
hibernate(switch,released,timeo) ;
 i +$g(released) d msgout($c(13,10)_"Switch "_switch_" is released.",NOFORCE)
 n hibtime s hibtime=$s(timeo>3:10,timeo>2:1,timeo>1:.1,timeo>0:.01,1:10)
 d msgout($c(13,10)_"Backup will hibernate for "_hibtime_" second(s) and try again."_$c(13,10)_"You may abort Backup via Ctrl-C. ",NOFORCE) 
 i hibtime<1 h hibtime
 e  n i f i=1:1:hibtime h 1 d msgout(".",NOFORCE)
 d msgout($c(13,10),NOFORCE)
 q
ENQ10 ;
 n t s t=$g(quietimeout,60) s:t>0 t=(t+9)\10 ;rounded up to 10 sec
 s $zt="ENQ10e"
 i CLUBACKUP d  q
 . f  q:$$CLU^SWSET(10,1,ALRDY10,$g(QUIETMASTERONLY))  s t=t-1 zt:'t "Abort" d hibernate(10,'ALRDY10,t)
 i ALRDY10 q:$$quietsw(10)  zt "Abort"
 f  S %SW=10,%VAL=1 D INT^SWSET  q:$$quietsw(10)  s t=t-1 zt:'t "Abort" d DEQ10,hibernate(10,1,t)
 Q
ENQ10e s $zt="" d DEQ10 ztrap $ze
DEQ10 ;
 i CLUBACKUP,$ZU(95,10,0)  ; Clear SW10 clusterwide
 i 'ALRDY10 s %SW=10,%VAL=0 D INT^SWSET
 Q
ENQ13 ;
 n t s t=$g(quietimeout,60) s:t>0 t=(t+9)\10 ;rounded up to 10 sec
 s $zt="ENQ13e"
 i CLUBACKUP d  q
 . f  q:$$CLU^SWSET(13,1,ALRDY13)  s t=t-1 zt:'t "Abort" d DEQ13,hibernate(13,'ALRDY13,t)
 i ALRDY13 q:$$quietsw(13)  zt "Abort"
 f  S %SW=13,%VAL=1 D INT^SWSET  q:$$quietsw(13)  s t=t-1 zt:'t "Abort" d DEQ13,hibernate(13,1,t)
 Q
ENQ13e s $zt="" d DEQ13 zq 1 g:$zt'="" @$zt q
DEQ13 ;
 i CLUBACKUP,$ZU(95,13,0)  ; Clear SW13 clusterwide
 i 'ALRDY13 s %SW=13,%VAL=0 D INT^SWSET
 Q
HOLDWD(dir,time,flag) ;suspend write daemon (dir may be passed as an array)
 n n
 i $zu(182,1,0) ;clear any remaining backup request
 f  q:'$zu(182,0)  h 1  ;wait until write daemon runs again
 i $d(dir)<10 d $zu(52,9,dir,1) d:$g(flag)=1 $zu(52,8,dir,0) d $zu(182,2,0,+$zu(49,dir)) s n=1 i 1
 e  s dir="" f n=0:1 s dir=$o(dir(dir)) q:dir=""  d $zu(52,9,dir,1) d:$g(flag)=1 $zu(52,8,dir,0) d $zu(182,2,n,+$zu(49,dir))
 i $zu(182,1,n,$g(time))  ;set number of databases to back up (and optional CP wait time)
 f  q:$zu(182,0)  h 1  ;wait until write daemon suspends
 q
FREEWD ;unsuspend write daemon
 i $zu(182,1,0)
 q
msgout(aaamess,flag) ;
         s flag=$g(flag,1) ; default to FORCE
         W *-1            ;Flush the input buffer 
         q:'$L(aaamess)   ; Avoid argumentless writes...
         i $g(logfile)'="" u logfile w aaamess
         u 0
         q:flag=3  ; 1 = FORCE, FORCE, 2 = NOFORCE, 3 = LOGONLY
         i '$G(INTERNAL,0)!('$G(NOINPUT,0)&(flag=1!'$G(QUIET,0))) w aaamess
         i $g(gui) D  
         . s return=$$IjcMsg^%Wprima("DI"_aaamess) ; Retval might =  cancel msg
         . i return="CANCEL" d  
         . . i $$IjcMsg^%Wprima("DI"_$c(13,10)_"Abort received!"_$c(13,10))
         . . zt "Abort"
         u 0 
         q
timestmp(flag) 
         n msg,%TS,%TN
         s msg="TIMESTAMP: "
         s %DN=+$H d INT^%DO
         s msg=msg_%DS
         s %TN=$P($h,",",2) d ^%TO
         s msg=msg_" "_%TS
         d msgout($c(13,10)_msg_$c(13,10))
         q
OSDEVICE(mdevice,new) ;osdevice + range check, pad input, strip output.
 s mdevice=+mdevice q:mdevice<47 ""  q:mdevice>62 ""
 i $d(new) s new=$$zpad(new,32)
 q $$zstrip($$osdevice(mdevice,.new))
osdevice(mdevice,new) ;"Raw" osdevice
 n adr,old,size,where,charsize
 s $ZT="osdeverr"
 s charsize=$$charsize^%Wprim() ; check size one char
 s size=32,adr=(mdevice-47)*(size*charsize)+$ZU(40,2,28),where=-2
 s old=$v(adr,where,-size_"w")
 i $d(new) v adr:where:-size_"w":new
 q old
osdeverr q ""
zstrip(x) ;Return x with ASCII NUL's removed
 q $tr(x,$c(0),"")
zpad(x,len) ;x, maybe truncated, NUL-padded to length len, one NUL guaranteed
 n zeroes
 s zeroes=$j("",len),zeroes=$tr(zeroes," ",$c(0)) ;String of len NUL's
 s x=$e(x,1,len-1) ;Silently truncate x if necessary
 s $e(zeroes,1,$l(x))=x
 q zeroes
ZU(A,B,C,D,E,F,G,H,I,J,K,L,M,N,P) ;so needn't change $$ZU's to $ZU's
 IF '$D(B) Q $ZU(A)
 IF '$D(C) Q $ZU(A,B)
 IF '$D(D) Q $ZU(A,B,C)
 IF '$D(E) Q $ZU(A,B,C,D)
 IF '$D(F) Q $ZU(A,B,C,D,E)
 IF '$D(G) Q $ZU(A,B,C,D,E,F)
 IF '$D(H) Q $ZU(A,B,C,D,E,F,G)
 IF '$D(I) Q $ZU(A,B,C,D,E,F,G,H)
 IF '$D(J) Q $ZU(A,B,C,D,E,F,G,H,I)
 IF '$D(K) Q $ZU(A,B,C,D,E,F,G,H,I,J)
 IF '$D(L) Q $ZU(A,B,C,D,E,F,G,H,I,J,K)
 IF '$D(M) Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L)
 IF '$D(N) Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L,M)
 IF '$D(P) Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
           Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L,M,N,P)
MORE Q
YN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YN"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"yn","YN") I "^YN"'[R W "  enter Yes or No, please"
 S POP=(R="^") W $E($S(R="N":"No",R="Y":"Yes",1:""),$L(X)+1,3) Q R

DBACKA^INT^1^67214,47330
DBACKA ; Part two of Incremental Backup  ;$Change: 7440104 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	; Revision: $Id: //iris/2024.1.3/databases/sys/rtn/user/dbacka.mac#1 $
 ; Part II of the Incremental Backup Utility.
 ;      Subroutines called by DBACK split out to keep the size down.
ASKSET(prompt,val,backup,help,pattern) ;procedure
 N x,done,def,enahelp,helpavail,backupavail
 s done=0
 s def=$G(val)
 s backup=$G(backup,0) 
 s enabackup=$S(backup=-1:0,1:1)
 s backupavail=$S(backup=1:1,1:0)
 s help=$G(help)
 s enahelp=$S(help="*":0,1:1) ;there might not be any help though
 s helpavail=$s(enahelp&($L(help)!($D(help)>1)):1,1:0)
 if 'enabackup n POP
 s POP=0
 f  d  q:done!POP
 . W !,$G(prompt)
 . w:($X+$L(def))>65 !,?5
 . w:$L(def) " <",def,">"
 . if helpavail!backupavail do
 . . w " [" w:helpavail "?" w:backupavail "^" w "]"
 . w:(($X+$L(def))>75) !,?5
 . W " => " 
 . R x,!
 . if x="^" d  q
 . . if 'enabackup s done=1 q
 . . if backupavail s POP=1 q
 . . w "...backup not available here"
 . if enabackup,x="""^""" s x="^",done=1 q
 . ;
 . if x="?" d  q
 . . if 'enahelp s done=1 q
 . . if 'helpavail w "...help not available here" q
 . . if $D(help)=1 w !?5,help q
 . . s x="" f  s x=$O(help(x)) q:x=""  w !,?5,help(x)
 . . w !
 . if enahelp,x="""?""" s x="?",done=1 q
 . i x]"",$g(pattern)]"",x'?@pattern w !?5,$s(helpavail:help,1:"[bad format]") q
 . s:'$L(x) x=val 
 . s done=1
 s:'POP val=x
 q
 ;
GETDEV ;
 I DEV="",BUTYP=FULL S DEV=$G(^SYS("BACKUP","LASTFULL","DEVICE"))
 I DEV="",LASTHDATE d ConvHistDate^DBACK S DEV=$G(^SYS("BACKUP","HISTORY",(+LASTHDATE*1000000+$p(LASTHDATE,",",2)),"DEVICE"))
 s DEVMNT=0 ; Gets set if we mount current tape
 ;
 s OK=1                                                        ;JAO264+
 i INTERNAL,outdev'="" s DEV=outdev,outdev="",ANS=""
 e  i NOINPUT,'$g(gui,0) s OK=0 q  ; If no input device, return failure
 e  d
 . d msgout($c(13,10)_"Specify output device (type STOP to exit)",FORCE)
 . d msgout($c(13,10)_"Device: "_DEV_" => ",FORCE)
 . i '$g(gui) R ANS
 . e  d  
 . . n text
 . . s text="Enter the device where output should continue."
 . . s ANS=$$IjcIB^%Wprima(text,"Specify Output Device",DEV)
 . . s:ANS="" ANS="STOP" ; Cancel button
 . d msgout(ANS_$c(13,10),LOGONLY)
 S:ANS]"" DEV=ANS I DEV=""!(DEV="STOP")!(DEV="stop") S OK=0 Q
 s ISREG=1
 S DEV=$$FILENORM(DEV) d:'OK  g GETDEV2:OK,GETDEV
 . d msgout("   "_ERRMSG_$c(13,10),FORCE)
 i DEV?2N&(DEV>46)&(DEV<55) d
 . s ISREG=0
 . s ANS="SYS$MT"_DEV ; Build logical name SYS$MTnn
 . s DEV=$$ZU(12,ANS,4) ; Translate logical name
 . i DEV="" d  q
 . . d msgout($c(13,10)_"Undefined tape device - "_ANS_$c(13,10),FORCE)
 . s DEV=$P(DEV,":")_":" ; Pick off the device part
 i DEV="" s OK=0 q:NOINPUT  g GETDEV
 i $E(DEV,$L(DEV))=":" d
 . s ANS=$$ZU(148,3,DEV) ; Obtain mount status for tape
 . i ANS d  s DEV="" q  ; Status failure
 . . d msgout($c(13,10)_"STATUS check failed for "_DEV,FORCE)
 . . d msgout($c(13,10)_"Error code = "_ANS_$c(13,10),FORCE)
 . i ANS]"0" d  q  ; Already mounted by some process, possibly ours
 . . i $p(ANS,"^",2)-$j d  s DEV=""
 . . . d msgout($c(13,10)_"Device "_DEV_" is unavailable (mounted)"_$c(13,10),FORCE)
 . s ANS=$$ZU(148,1,DEV) ; Try to mount the tape  
 . i ANS d  s DEV="" q
 . . d msgout($c(13,10)_"MOUNT failed for "_DEV,FORCE)
 . . d msgout($c(13,10)_"Error code = "_ANS_$c(13,10),FORCE)
 . s DEVMNT=1
 e  s DEV=$$ZU(12,DEV) do CheckDir
 i DEV="" s OK=0 q:NOINPUT  g GETDEV
GETDEV1 I $G(VOL)>1 D                                                 ;AN012+
 . I $G(VOL)=2 S FIRSTDEV=PREVDEV
 . I DEV'=PREVDEV D
 .. d msgout($c(13,10)_$c(13,10)_"Device used on previous volume was "_PREVDEV,NOFORCE)
 .. d msgout($c(13,10)_"Device specified now is "_DEV,NOFORCE)
 . . d msgout($c(13,10)_"Are you sure you want to do this ?",NOFORCE)
 . . i '$g(gui) s ANS=$$YESNO^DBACK(0)
 . . e  d
 . . . n text
 . . . s text="Are you sure you want to do this?"
 . . . s ANS=$$IjcIB^%Wprima(text,"Please answer Yes or No","No")
 . . . s ANS=$tr($e(ANS),"y","Y")="Y"
 . . d msgout($s(ANS:"Yes",1:"No")_$c(13,10),LOGONLY)
 . . i 'ANS d:DEVMNT DISMOUNT(DEV,1) s OK=0 q
 . . d:PREVMNT DISMOUNT(PREVDEV,0)
 . e  s:'DEVMNT DEVMNT=PREVMNT
 i 'OK q:NOINPUT  g GETDEV
 s PREVDEV=DEV,PREVMNT=DEVMNT
 d msgout($c(13,10)_"Backing up to device: "_DEV,NOFORCE)
 q:'ISREG
 i '$zu(140,4,DEV) d   ; if file exists  
 . s delerr=$zu(140,5,DEV)
 . i delerr d msgout($c(13,10)_"Error "_delerr_" deleting file "_DEV_" before reuse.",NOFORCE) s OK=0
 Q
CheckDir  ;Check if the specified directory exist or not, if not create it.
 ; In put is DEV, if failed to create the directory the DEV will be set to "". 
 i 'INTERNAL!($g(outdev,"")="") do   ; Not a tape
 . n dirname,rc
 . s dirname=##class(%Library.File).GetDirectory(DEV,1)
 . if '$l(dirname) d msgout($c(13,10)_"Unable to determine base directory for "_DEV,FORCE) S DEV="" Q
 . if '##class(%Library.File).DirectoryExists(dirname) do
 . . s rc=##class(%Library.File).CreateDirectoryChain(dirname)
 . . if 'rc d msgout($c(13,10)_"Unable to create backup output directory: "_dirname,FORCE) S DEV="" Q
 . e  if ##class(%Library.File).Exists(DEV) f  d  q:'rc
 . . i NOINPUT s rc=0 q   ;overwrite it when no input for the backup.
 . . d msgout($c(13,10)_"File exists, do you want to overwrite it <N>?",FORCE)
 . . R rc i rc="" s DEV="" s rc=0 q
 . . s rc=$zconvert($e(rc),"u")
 . . if rc="Y"!(rc="N") s:rc="N" DEV="" s rc=0 q
 . . d msgout("  Enter 'Y' or 'N'.") s rc=1
 Q
GETDEV2 ;
 I 'ISREG G:'($zversion(1)=2) GETDEV1   ; Don't need to check directory for Tape.
 I 'ISREG,$ZCVT(DEV,"U")?1"\\.\TAPE"1N G GETDEV1  ;must be Tape for Windows.
 I 'ISREG,(+$zu(91,DEV))=7 G GETDEV1  ;must be Tape for Windows.
 do CheckDir G:DEV="" GETDEV
 G GETDEV1
GETTYP S TYPE="" ; TR243 fixed
 i INTERNAL D                                                  ;JAO264+
 . s a=$TR($E(EXTTYP),"FIC","123")
 E  D
 . d msgout($c(13,10)_"What kind of backup:"_$c(13,10),FORCE)              ;JAO266+
 . d msgout("   1. Full backup of all in-use blocks"_$c(13,10),FORCE)
 . d msgout("   2. Incremental since last backup"_$c(13,10),FORCE)
 . d msgout("   3. Cumulative incremental since last full backup"_$c(13,10),FORCE)
 . d msgout("   4. Exit the backup program"_$c(13,10),FORCE)       ;JAO266
 . r "1 => ",a i a="" s a=1                                    ;JAO264-
 . d msgout("1 => "_a,LOGONLY)    ; log the response       ;JAO264
 quit:a="STOP"!(a="stop")
 s a=$e(a)
 i "1234"'[a d  g GETTYP
 . d msgout($c(13,10)_" ?? Type the number of the function you want"_$c(13,10),FORCE)
 i a=4 s TYPE="",BUTYP="" q
 S BUTYP=$S(a=3:CUMINC,a=1:FULL,1:PARTIAL)
 S TYPE=$S(a=3:"Cumulative Incremental",a=1:"Full",1:"Incremental")
 s OK=1                                                       ;JAO265+
 if BUTYP'=FULL {
    new full set full=0
    if '$D(^SYS("BACKUP","LASTFULL")) {
       set full=1
       do msgout($c(13,10)_$c(13,10)_"You cannot do an Incremental or Cumulative Backup until a Full Backup"_$c(13,10)_"has been performed."_$c(13,10),FORCE)
    } else {
       new d,nobup set (d,nobup)=""
	   new newdirlist,olddirlist,dir,zu49,REASON
	   merge olddirlist=^SYS("BACKUP","LASTDIRECTORIES")
       for  {
	       set d=$o(^SYS("BACKUP","DIRECTORIES",d)) 
	       quit:d=""  
	       k olddirlist(d) 
	       s zu49=+$zu(49,d)
	       if zu49'=-2&&(zu49'=-3) {
		       i zu49=-1||(zu49=$zu(40,0,41)) d MNTDIR^DBACKB(d) s zu49=+$ZU(49,d)
		       i zu49'=-1&&(zu49'=$zu(40,0,41)) {
			       set:($zu(52,8,d)+$zu(52,9,d)) nobup=nobup_d_", "
			       if '$D(^SYS("BACKUP","LASTDIRECTORIES",d)) s newdirlist(d)=""
		       }
	       }
       }
	   if $D(olddirlist) {
	      do msgout($c(13,10)_"Below is a list directories which were part of the last backup"_$c(13,10)_"     but are not part of the current backup.",FORCE)
		  s d=""
          f  s d=$O(olddirlist(d)) q:d=""  do msgout($c(13,10)_"     "_d,FORCE)
	   }
	   if $D(newdirlist) {
	      do msgout($c(13,10)_"Below is a list directories which were NOT part of the last backup"_$c(13,10)_"     but will be part of the current backup.",FORCE)
		  s d=""
          f  s d=$O(newdirlist(d)) q:d=""  do msgout($c(13,10)_"     "_d,FORCE)
          do msgout($c(13,10)_"Since new databases have been added, a full backup is required.",FORCE)
          s full=1
	   }
       if nobup'="" {
          set full=1
          do msgout($c(13,10)_$c(13,10)_"Below is a list of directories for which a Full Backup is mandatory:",FORCE)
          for i=1:1:$l(nobup,", ")-1 do msgout($c(13,10)_"   "_$p(nobup,", ",i),FORCE)
          do msgout($c(13,10)_$c(13,10)_"A Full Backup of the entire directory set must be done first.",FORCE)
       }
    }
    quit:'full
    new text
    if NOINPUT {
       set text="Performing a Full Backup of these databases"
    } else {
       set text="The Full Backup will take much longer than the "_TYPE_" Backup."_$c(13,10)_$c(13,10)_"Do you wish to do a Full Backup now? "
    }
    if '$g(gui) {
       do msgout($c(13,10)_text,FORCE)
       if NOINPUT {set ANS=1} else {set ANS=$$YESNO^DBACK(0)}
       if 'ANS {set OK=0,TYPE=""} else {set BUTYP=FULL,TYPE="Full"}
    } else {
       set ANS=$$IjcMB^%Wprima(text,4+256,"Mandatory Full Backup")
       if ANS="No" {set OK=0,TYPE=""} else {set BUTYP=FULL,TYPE="Full"}
    }
    if OK && INTERNAL && $L($G(taskname)) {
	    new rc,dirname,saveof
	    s newtask="FullDBList"
	    if ('(outdev?2N&(outdev>46)&(outdev<55))) {
		    s rc=$Find(outdev,taskname)
		    if (rc) {
			    s dirname=##class(%Library.File).GetDirectory(outdev,1)
			    s rc=##class(Backup.General).GetFilename(newtask,1,0,dirname)
			    if '+$list(rc,1) d msgout($c(13,10)_"Failed to switch backup file to Full Backup Task.",FORCE) s OK=0,TYPE="" Q
			    s outdev=$List(rc,2)
		    }
	    }
	    if $L($G(logfile)) {
		    s rc=$Find(logfile,taskname)
		    if (rc) {
			    s rc=##class(Backup.General).GetFilename(newtask,1,1)
			    if '+$list(rc,1) d msgout($c(13,10)_"Failed to switch log file to Full Backup Task.",FORCE) s OK=0,TYPE="" Q
			    s newlog=$List(rc,2)
			    o newlog:"WNS":5
			    i '$Test d msgout($c(13,10)_"Failed to open new log file "_newlog_".",FORCE) s OK=0,TYPE="" Q
			    d msgout($c(13,10)_"Log file switched to "_newlog_" due to switch to Full Backup.",FORCE)
			    c logfile o logfile
			    s saveof=$zu(68,40,1)
			    f  u logfile r rc q:$zeof=-1  u newlog w rc_$c(13,10)
			    c logfile
			    d $zu(68,40,saveof)
			    s logfile=newlog
		    }
	    }
	    s P10=taskname
	    s return="1,"  ; For Warning
	    d SetStatus^Wsback
	    s taskname=newtask
	    s rc=$$SetLast^Wsback(taskname)
   }
 }
 if 'OK quit:INTERNAL  goto GETTYP
 if INTERNAL d msgout($c(13,10)_"Performing a "_TYPE_" backup.",FORCE)
 quit
 ;
InitDirList(flg) ;
 ;Setup ^SYS("BACKUP","DIRECTORIES") from ^SYS("BACKUPDB")
 ;and warn if any directories backed up last time are missing this
 ;time. flg=0 means build list from ^SYS("BACKUPDB"). 
 ;flg=1 means build list of all databases on the system
 ;
 ;Returns 0 = failed, 1 = success
 n list,rc,del1,del2,db,dir,cachetemp,cnt
 k ^SYS("BACKUP","DIRECTORIES")
 s del1=$$del1^%Wprim,del2=$$del2^%Wprim
 s list=""
 if 'flg && $d(^SYS("BACKUPDB")) {
    s rc=$$DbList^Wsback(.list)
    if '+rc do msgout($c(13,10)_$P(rc,del1,2),FORCE) q 0
    s cnt=$L(list,del1)-1
    f i=1:1:cnt {
 	   s db=$P(list,del1,i)
	   s dir=$P(db,del2,2)
	   s:$L(dir) ^SYS("BACKUP","DIRECTORIES",dir)=""
    }
 } else {
	; This is the special "FullAllDatabase" task which includes
	; all databases except for IRISTemp
	s context=""
	do {
		k list
		s notdone=$$List^Wsdba(.list,.context) ;returns 0 for the last chunk
 	    s cnt=$L(list,del1)
 	    f i=1:1:cnt {
 	       s db=$p(list,del1,i)
 	       s dbname=$p(db,del2)
 	       if $L(dbname) {
	          s dbdir=$p(db,del2,2)
   	          ; Don't include temp, CACHELIB and DOCBOOK 
	          if (+$p(db,del2,4)'=$ZU(173))&&(dbname'="IRISLIB")&&(dbname'="DOCBOOK")&&(dbname'="IRISLOCALDATA") {
		          s:$L(dbdir) ^SYS("BACKUP","DIRECTORIES",dbdir)=""
	          }
 	       }
 	    }
	} while (notdone)
 }
 q 1
GETDIRS ;
 n NODIR,MVDIR k DIRNAM S (DIRNAM,NODIR,MVDIR)=0
 n REASON,SEV
 S DIR=""
 F I=0:0 S DIR=$O(^SYS("BACKUP","DIRECTORIES",DIR)) Q:DIR=""  d
 . D GD1^DBACKB(DIR)
 i DIRNAM d
 . d msgout($c(13,10)_$c(13,10)_"Backing up the following directories:"_$c(13,10),NOFORCE) ;JAO266
 . s DIR="" f  S DIR=$o(DIRNAM(DIR)) Q:DIR=""  D msgout(" "_DIR_$c(13,10),NOFORCE)    ;JAO266
 i NODIR d
 . s BUWARNING="Directory could not be backed up~"_$g(BUWARNING)
 . s SEV=1 i INTERNAL f  s DIR=$O(NODIR(DIR)) q:DIR=""  i $G(REASON(DIR))'="(Database is readonly)" s SEV=2 q
 . d $zu(9,"","The following directories could not be backed up:",(SEV>0),SEV)
 . d msgout($c(13,10)_"WARNING - the following directories could not be backed up"_$C(7)_$c(13,10),NOFORCE)
 . s DIR=""  
 . f  s DIR=$O(NODIR(DIR)) Q:DIR=""  d
 . . d $zu(9,"",DIR_" "_$G(REASON(DIR)),(0>0),0)
 . . d msgout(" "_DIR_" "_$G(REASON(DIR))_$c(13,10),NOFORCE)
 d msgout($c(13,10),NOFORCE) Q
 ;
 ; Write a volume label
 ; If VOL = 1, then also output the directories
VOLLABEL s OK=1,RC=$$ZU(50,0,DEV) I RC'=NoErr G VOL1 ; Open the output file
 D OUTVOL("InterSystems IRIS"_" BACKUP")
 if mirrorid="" {
	D OUTVOL("VERSION")  ;Version[0] does not include mirror support
 } else {
    D OUTVOL("VERSION1.1")  ;VERSION1.1 includes mirror support & readonly flag
 }
 D OUTVOL($P($ZV,DELIM,1))
 ; BUFCOUNT is the number of full buffers written on the previous
 ; volume.  It is parsed out of the return code when a volume is full.
 I VOL=1 S BUFCOUNT=0
 FOR I=VOL,DATE,TIME,TYPE,BACKHDATE,LASTDATE,LASTTIME,LASTTYPE,LASTFDATE,LASTFTIME,DESCRIPTION,BUFCOUNT d OUTVOL(I) G VOL1:'OK
 ; Add Mirror name and mirror guid
 if mirrorid'="" {
	 do OUTVOL(mirrorid)  ;<mirname>:<mirror guid>:<system name>: etc....
 }
 G VOL1:'OK  ;OUTVOL() failed.
 ; If this is the first volume label, output the directory names
 i VOL=1 n A s A="" d  G VOL1:'OK
 . for  s A=$o(DIRNAM(A)) Q:A=""  D  q:'OK
 . . D OUTVOL(A_"^"_CLSTATE(A)_"^"_MIRDBINFO(A)) q:'OK   ;JO2313
 . . D OUTVOL($P($$ZU(49,A),",",1,12)) q:'OK
 d OUTVOL("") G VOL1:'OK ; indicate end of logical label
 S RC=$$ZU(50,2,DELIM) 
 I RC=NoErr s OK=1 q  ; write the label
VOL1 s OK=0  d msgout($c(13,10)_" [",FORCE)
 I RC=ibEOT d msgout("End of Volume",FORCE)
 I RC=ibOfflin d msgout("Device "_DEV_" Offline",FORCE) 
 I RC=ibDevFul d msgout("Device "_DEV_" Full",FORCE)
 I RC=ibOutErr d msgout("Output I/O",FORCE)
 I RC=ibInErr d msgout("Input I/O",FORCE)
 d msgout(" Error has occurred]"_$c(13,10),FORCE)
 i NOINPUT d msgout("No input device - Terminating backup",FORCE) q
 s A="Y"
 d ASKSET(DEV_": Retry? ",.A)
 I A'?1"N".E,A'?1"n".E G VOLLABEL
 Q
OUTVOL(a) s RC=$$ZU(50,1,a_DELIM) i RC'=1 s OK=0
 q
 ;
PASS ;
 N I
 d msgout($c(13,10)_$c(13,10)_"Starting backup pass "_PASS,FORCE)
 ; If last pass took longer than 1/3 of previous pass, or last pass
 ; was less than 30 seconds, then make this the last pass
 ;MaxWaitTime: max wait time for WD to resume before CP freezes system.
 N MaxWaitTime s MaxWaitTime=0 ;10 minutes (600 seconds) by default
 I PASS>2 {
   i PASS(PASS-1)<30 {
     s LastPass=1 ;last pass should be brief enough
   } elseif PASS(PASS-1)>(PASS(PASS-2)/3)&(PASS(PASS-1)<300) {
     s LastPass=1 ;use default wait time (600), which is > 2 * prev pass 
   } elseif PASS(PASS-1)>(PASS(PASS-2)/3*2) { ;implying PASS(PASS-1)>=300
     s LastPass=1 ;no more additional passes as prev two were converging
     s MaxWaitTime=PASS(PASS-1)*2 ;max wait is twice as long as prev pass
   } elseif PASS=MaxPASS {
     s LastPass=1
     i PASS(PASS-1)>=300 s MaxWaitTime=PASS(PASS-1)*2
   }
 }
 S DIR="" F  {
   S DIR=$O(DIRNAM(DIR)) Q:DIR=""  
   d SetNames(DIR) S RC=NoErr
   s zu49=+$$ZU(49,DIR)
   i zu49=-1!(zu49=-2)!(zu49=-3) {
     d msgout($c(13,10)_"Directory "_DIR_" *** Isn't Present and Can't Be Backed Up ***"_$c(13,10)_$c(13,10),NOFORCE) 
     s OK=1 K DIRNAM(DIR) 
   }
   i PASS=1 {
     n gfowner,i s gfowner=0
     f  {
       s x=$v(+zu49*4+$zu(40,2,92),-2,4) 
       i 'x { 
         d:gfowner msgout(" Done"_$c(13,10),NOFORCE) 
         q
       }
       i x'=gfowner {
         d msgout($c(13,10)_"Waiting for job #"_x_" to release ownership of database "_DIR,NOFORCE) 
         s gfowner=x
       }
       i $i(i)#10=0 d msgout(".",NOFORCE)
       h 1 
     }
   }
 }
 i LastPass {
   n rc s rc=##class(%SYS.Journal.File).RequiredForRecovery(.RequiredFile)
   i $g(RequiredFile)'="" d msgout($c(13,10)_$c(13,10)_"Journal file '"_RequiredFile_"' and the subsequent ones are required for recovery purpose if the backup were to be restored",NOFORCE)
   i USEENQ {
   	d msgout(" - This is the last pass - Suspending sets and kills",NOFORCE)
   } else {
   	d msgout($c(13,10)),MARKJRN^DBACK
   	d msgout($c(13,10)_" - This is the last pass - Suspending write daemon",NOFORCE)
   }
 }
 S BEGTIME=$H,LOST=0 ; keep track of pass time
 n SUCCESSDIR  ; Record success backup in last pass.
 S A=$ZH D:USEENQ ENQ13 D:'USEENQ HOLDWD(.DIRNAM,$g(MaxWaitTime)) S LOST=LOST+($ZH-A)
 n DIRBCK k DIRBCK ;DIRBCK is an array of DBs with sth to back up for this pass
 S DIR="" F  {
   S DIR=$O(DIRNAM(DIR)) Q:DIR=""  
   s RC=$$DIRPASSINLOGOR(DIR,PASS)
   ; If RC=-2, There was nothing to backup because an input file for
   ;     one of the INLOGOR calls did not exist.
   ;  Otherwise, if RC<0, there was an I/O error when attempting to process the IN* files.
   I RC<0,RC'=-2 {
  	D msgout($c(13,10)_"["_$s(RC=+RC:"I/O Error",1:"Error "_$p(RC,",",2,*))_" occurred while processing directory '"_DIR_"']"_$c(13,10),FORCE)
	k DIRNAM(DIR) ;to ensure GFFORCEFULBK flag stays on in DIR
  	S OK=0
   	Q  ;If RC<0, it is a bad error.  Abort BACKUP.
   }
   i RC>=0 s DIRBCK(DIR)=DIRNAM(DIR)
   i LastPass,'USEENQ S SUCCESSDIR(DIR)=""
 }
 i 'LastPass {
   i USEENQ {
     d DEQ13
   } else {
     d FREEWD
     s DIR="" f  s DIR=$o(DIRNAM(DIR)) q:DIR=""  d $zu(52,9,DIR,0) 
   }
 }
 i OK {
   S DIR="" F I=0:0 S DIR=$O(DIRBCK(DIR)) Q:DIR=""  D DIRPASS^DBACKC Q:'OK
 }
 d msgout($c(13,10)_"Backup pass "_PASS_" complete at "_$ZDATETIME($H),FORCE)
 I LastPass d msgout($c(13,10),FORCE)
 s PASS(PASS)=$$TIME($H,BEGTIME)-LOST
 ; D DEQ:LastPass  ; TR242 removed
 i LastPass,'USEENQ d FREEWD s I="" f  s I=$o(SUCCESSDIR(I)) q:I=""  d $zu(52,9,I,0) 
 Q
 ;Uses public variables BUTYP, FULL, etc.
DIRPASSINLOGOR(DIR,PASS) ;
 i PASS=1 {
   i BUTYP=FULL { ;the first pass of a full backup
     ; GFFORCEFULBK should be already set in HOLDWD()
     ; and not cleared until FREEWD()
     ; clear .INC (INCACTIVEMAP) as it may include killed blocks
     s I=$$INLOGOR(DIR,3,3,1)
     ; mark all in-use blocks in .IND file (INCBACKUPMAP) 
     s RC=$$INLOGOR(DIR,3,2,2)
     i RC'<0 {
       ; delete .INE file (INCRECORDMAP)
       s I=$$INLOGOR(DIR,1,1,1)
       ; -2 = incremental backup not enabled on this database (OK)
       I I'=-2 s RC=I
     }
   } else { ;the first pass of a partial (incremental) or cumulative backup
     ; OR .INE file into .IND and delete the .INE file
     ; so that we can recover from a previously interrupted backup
     s RC=$$INLOGOR(DIR,1,2,1)
     i BUTYP=CUMINC { ;first pass of a cumulative incremental backup,
       ; OR .INF into .IND and leave .INF alone
       s I=$$INLOGOR(DIR,0,2,0)
       s:(RC=-2)||(RC'<0) RC=I
     }
     ; OR .INC into .IND and clear the .INC file
     s I=$$INLOGOR(DIR,3,2,1) D
     S:(RC=-2)||(RC'<0) RC=I
   }
 }
 ; If not 1st pass, OR .INC into .IND and clear the .INC file
 I PASS'=1 s RC=$$INLOGOR(DIR,3,2,1)
 Q RC
 ;
DIRPASS ;
 D SetNames(DIR) S RC=NoErr
 n zu49 s zu49=+$$ZU(49,DIR)  ;KMK106
 i zu49=-1!(zu49=-2)!(zu49=-3) d  q
 . d msgout($c(13,10)_"Directory "_DIR_" *** Isn't Present and Can't Be Backed Up ***"_$c(13,10)_$c(13,10),NOFORCE) 
 . s OK=1 K DIRNAM(DIR)
 ;
 I 'LastPass S A=$H D ENQ13 S LOST=LOST+$$TIME($H,A)
 i PASS=1 DO
 .; If this is first pass of a full backup, mark all in-use
 .; blocks in .IND file and delete .INE file
 . I BUTYP=FULL s RC=$$INLOGOR(DIR,3,2,2) Q:RC=-2
 . i BUTYP=FULL,(RC'<0) s I=$$INLOGOR(DIR,1,1,1)
 .; If first pass of a partial or cumulative backup,
 .; OR .INE file into .IND and delete the .INE file
 .; so that we can recover from a previously interrupted backup,
 . i BUTYP'=FULL s RC=$$INLOGOR(DIR,1,2,1)
 .; If first pass of a cumulative incremental backup,
 .; OR .INF into .IND and leave .INF alone
 . i BUTYP=CUMINC s I=$$INLOGOR(DIR,0,2,0) D
 ..   s:(RC=-2)!(RC'<0) RC=I
 .; OR .INC into .IND and clear the .INC file
 . s I=$$INLOGOR(DIR,3,2,1) D
 ..    ; If the first pass during Full Backup.  Ignore the fact
 ..    ;   that the .INC file does not exist.
 ..   I (BUTYP=FULL)&(PASS=1)&(I=-2) Q
 ..   E  S:(RC=-2)!(RC'<0) RC=I
 ; If not 1st pass, OR .INC into .IND and clear the .INC file
 I PASS'=1 s RC=$$INLOGOR(DIR,3,2,1)
 ; If RC=-2, There was nothing to backup because an input file for
 ;     one of the above INLOGOR calls did not exist.
 I RC=-2 Q   ;Continue backup, but do not process this directory
 ;  Otherwise, if RC<0, then there was an I/O error or configuration error
 E  I RC<0 D  Q  ;If RC<0, it is a bad error.  Abort BACKUP.
 . D msgout($c(13,10)_"["_$s(RC=+RC:"I/O Error",1:"Error "_$p(RC,",",2,*))_" occurred while processing directory '"_DIR_"']"_$c(13,10),FORCE)
 . S OK=0
 D DEQ13:'LastPass
 ; Backup this directory for this pass
 d msgout($c(13,10)_"Backing up "_DIR_" at "_$ZDATETIME($H),NOFORCE)
 S VOLDIR=DIR,RC=$$ZU(IBUPass,PARTIAL,DIR)
 d msgout(" - Done",NOFORCE)
 ;
RC ; Handle return code from ZU(IBUPass...) which does one pass of 
 ; backup.  Only the last three conditions are absolutely fatal.
 I +RC=NoErr G DPX
 I +RC=ibEOT D NEXTVOL("End of Volume.") Q:'OK  G CNT
 I +RC=ibOfflin D FATAL("Device "_DEV_" Offline.") Q
 I +RC=ibDevFul D NEXTVOL("Device "_DEV_" Full.") Q:'OK  G CNT
 I +RC=ibOutErr D FATAL("Output I/O") Q
 I +RC=ibInErr D FATAL("Input I/O") Q
 I +RC=ibNoIND D FATAL("IRIS"_".IND not present") Q
 I +RC=ibNoDAT D FATAL("IRIS"_".DAT has disappeared.") Q
 D FATAL(+RC_" has occurred.")
 Q
CNT ;
 S VOLDIR=DIR
 S RC=$$ZU(IBUPass,CNTINU,DEV) G RC
DPX  
 S OK=1 S RC=$$INLOGOR(DIR,2,1,1) I (RC'=-2)&(RC<0) D 
 . D msgout($c(13,10)_"["_$s(RC=+RC:"I/O Error",1:"Error "_$p(RC,",",2,*))_" occurred while processing directory '"_DIR_"' - Check the log]"_$c(13,10),FORCE)
 . S OK=0
 Q
 ; end of DIRPASS
 ;------------------------------------------------------------------
FATAL(msg) ;
 S OK=0 d msgout($C(7)_$c(13,10)_"["_msg_" Fatal Error]"_$c(13,10),FORCE)
 Q
 ;
NEXTVOL(prompt) ;
 n BEG s BEG=$H,VOL=VOL+1
 S BUFCOUNT=$P(RC,",",2)
 i NOINPUT d   s OK=0 q                                       ;JAO264+
 . d msgout($c(13,10)_"End of volume detected",FORCE)
 . d msgout($c(13,10)_"Terminal input not enabled-Terminating backup",FORCE)
 d msgout($c(13,10)_prompt,FORCE)                                   ;JAO266
NXTVOL1 d msgout($c(13,10)_" Where should output continue?",FORCE)         ;JAO266
 D GETDEV Q:'OK  D VOLLABEL G NXTVOL1:'OK
 S LOST=LOST+$$TIME($H,BEG) ; count the lost time
 Q
DISMOUNT(dev,nounload) ; Dismount a tape volume
 i $$ZU(148,2,dev,nounload) ; Unload can be inhibited
 q
SetNames(D) N M
 S M=D_"IRIS"_".",INC=M_"INC",IND=M_"IND",INE=M_"INE",INF=M_"INF"
 Q
 ; subtract two times in $H format, and return the diff in # seconds
TIME(a,b) q (a-b*24*3600)+$p(a,",",2)-$p(b,",",2)
INLOGOR(DIR,SOURCE,TARGET,DISPOSE) ;Adapter, present same i'face for VAX & UX
 n rc
 try {
   s rc=$ZU(31,DIR,SOURCE,TARGET,DISPOSE)
 } catch {
   s rc=-1_","_$ze
   s $ze=""
 }
 q rc
FILENORM(NAME) ;Return normalized version of NAME
 S OK=1,$ZT="FNERR"
 N MTDEV,DIR S MTDEV=$$OSDEVICE(NAME) I MTDEV'="" S ISREG=0 Q NAME
 i ($zversion(1)=2),$E(NAME,1,2)="\\" S L=$$CheckForTape(NAME) I L'="" S ISREG=0 Q L
 i ($zversion(1)=2) S L=$L(NAME,"\"),DIR=$P(NAME,"\",1,L-1)
 i ($zversion(1)=2) IF L>1 S DIR=DIR_"\"
 i ($zversion(1)=2) S NAME=$ZU(12,DIR)_$P(NAME,"\",L,L),ISREG=$ZU(140,7,NAME),ISREG=$S(ISREG>0:1,ISREG=-2:1,1:0) Q NAME
 i ($zversion(1)=3) S L=$L(NAME,"/"),DIR=$P(NAME,"/",1,L-1)
 i ($zversion(1)=3) IF L>1 S DIR=DIR_"/"
 i ($zversion(1)=3) S NAME=$ZU(12,DIR)_$P(NAME,"/",L,L),ISREG=$ZU(140,7,NAME),ISREG=$S(ISREG=-2:1,ISREG/32768#2:1,1:0) Q NAME
FNERR S OK=0,ERRMSG="Not a valid device name." Q
CheckForTape(NAME)
 S NAME=$ZCVT(NAME,"U")
 N I,TAPE
 For I=47:1:62 s TAPE=$$OSDEVICE(I) I NAME=$ZCVT(TAPE,"U") S NAME=I Q
 I NAME?2N Q NAME
 I NAME?1"\\.\TAPE"1N Q NAME
 Q ""
TQUIWRITE(verbose) q $$QUIESCE(1,"buffer activity",10,verbose)
TQUIGC(verbose) q $$QUIESCE(2,"garbage collection",10,verbose)
TQUIDB(verbose) q $$QUIESCE(4,"database expansion",10,verbose)
TQUIGLO(verbose) q $$QUIESCE(8,"global activity",10,verbose)
TQUIGLOUPD(verbose) q $$QUIESCE(16,"global updates",10,verbose)
TQUINET(verbose) q $$QUIESCE(32,"network activity",10,verbose)
TQUIDISK(verbose) q $$QUIESCE(1+2,"disk activity",10,verbose)
TQUIUPD(verbose) q $$QUIESCE(1+2+4+16,"update activity",10,verbose)
TQUISYS(verbose) q $$QUIESCE(1+2+4+8,"system activity",10,verbose)
QUIESCE(bits,text,retries,verbose,intv) ;
 s verbose=+$g(verbose),retries=+$g(retries,-1),intv=+$g(intv,1)
 q ($$Quiesce(bits,text,retries,verbose,intv)>0)
Quiesce(bits,text,retries,verbose,intv) ;
 n noWDbits
 s $zt="QUIESCEE"
 q:$zu(51,bits) 1 ;double checking $ZU(51) is no longer necessary
 s verbose=+$g(verbose),retries=+$g(retries,-1),intv=+$g(intv,1)
 d msgout($c(13,10)_"WARNING: Switch is set and may affect production for up to "_(retries*intv)_" seconds."_$c(13,10)_"Waiting for "_text_" to finish...",NOFORCE)
 f  q:'retries  h intv q:$zu(51,bits)  s retries=retries-1 i retries#5=0 d msgout(".",NOFORCE)
 s noWDbits=1
 s:$s($S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0):''$zu(59,0),1:0) noWDbits=noWDbits+2
 s noWDbits=$zboolean(bits,noWDbits,2)  ;2 = x & ~ y
 if '$ZU(51,bits),bits'=1,$zboolean(bits,1,1),$zu(51,noWDbits) {
	 d msgout($c(13,10)_"System is idle except WD is still running."_$c(13,10)_"     Waiting up to 2 minutes for WD to finish",NOFORCE)
	 f i=1:1:120 q:$ZU(51,bits)  h 1 if i#5=0 d msgout(".",NOFORCE)
	 if $ZU(51,bits) s retries=1 ;signal success
 }
 d msgout($s(retries:" ready.",1:" abort. "_$$quiescefailmsg(bits))_$c(13,10),NOFORCE)
 q retries
quiescefailmsg(bits)
 N ret,clu,clumsg s ret="",clu=$zb(bits,512+256+128,1),clumsg=""
 if $zb(clu,128,1)||($zb(clu,(256+512),1)=(256+512)) s clu=128,clumsg=" (cluster wide)"
 if $zb(clu,512,1) s clumsg=" (cluster master only)"
 if $zb(clu,256,1) s clumsg=" (cluster slaves only)"
 if $zb(bits,1,1)&&('$ZU(51,clu+1)) S ret=ret_"write daemon"_clumsg_","
 if $zb(bits,2,1)&&('$ZU(51,clu+2)) S ret=ret_"garbage collector"_clumsg_"," 
 if $zb(bits,4,1)&&('$ZU(51,clu+4)) S ret=ret_"file expander"_clumsg_","
 if $zb(bits,8,1)&&('$ZU(51,clu+8)) S ret=ret_"global reference"_clumsg_","
 if $zb(bits,16,1)&&('$ZU(51,clu+16)) S ret=ret_"global update"_clumsg_","
 if $zb(bits,32,1)&&('$ZU(51,clu+32)) S ret=ret_"client-side network connections"_clumsg_","
 if $zb(bits,64,1)&&('$ZU(51,clu+64)) S ret=ret_"network server activity"_clumsg_","
 if ret'="" s ret="Quiesce failed reason: "_$e(ret,1,*-1) d $zu(9,"",ret,1,2) i $d(^rOBJ("ZQuiesceFail")) d ^ZQuiesceFail
 Q ret
QUIESCEE s $zt="" d $zu(9,"","QUIESCE: "_$ze,(1>0),1) q -1 ;0
CluQuiet(switch,target,timeout)
 n flags,rc
 i $g(switch)-10,$g(switch)-13 ztrap "SWITCH"
 n targetmsg s target=$g(target)
 i target=1 s target=256,targetmsg=" on cluster slave members"
 e  i target=2 s target=512,targetmsg=" on cluster master"
 e  s target=512+256,targetmsg=" cluster wide"
 s flags=1+2+4+$s(switch=10:8,1:16)
 s rc=$$Quiesce(flags+target,$s(switch=10:"system activity",1:"update activity")_targetmsg,$g(timeout,10),'$g(QUIET,$g(QUIETLY)))
 i rc<0 ztrap "Abort"
 q rc
quietsw(switch,timeout) ;quiesce activities w/ timeout after setting switch 10 or 13
 n flags,rc
 i $g(switch)-10,$g(switch)-13 ztrap "SWITCH"
 s flags=1+2+4+$s(switch=10:8,1:16)
 i CLUBACKUP s flags=flags+128
 s rc=$$Quiesce(flags,"disk cleanup",$s($g(timeout)="":30,1:timeout),'$g(QUIET))
 i rc<0 ztrap "Abort"
 q rc
hibernate(switch,released,timeo) ;
 i +$g(released) d msgout($c(13,10)_"Switch "_switch_" is released.",NOFORCE)
 n hibtime s hibtime=$s(timeo>3:10,timeo>2:1,timeo>1:.1,timeo>0:.01,1:10)
 d msgout($c(13,10)_"Backup will hibernate for "_hibtime_" second(s) and try again."_$c(13,10)_"You may abort Backup via Ctrl-C. ",NOFORCE) 
 i hibtime<1 h hibtime
 e  n i f i=1:1:hibtime h 1 d msgout(".",NOFORCE)
 d msgout($c(13,10),NOFORCE)
 q
ENQ10 ;
 n t s t=$g(quietimeout,60) s:t>0 t=(t+9)\10 ;rounded up to 10 sec
 s $zt="ENQ10e"
 i CLUBACKUP d  q
 . f  q:$$CLU^SWSET(10,1,ALRDY10,$g(QUIETMASTERONLY))  s t=t-1 zt:'t "Abort" d hibernate(10,'ALRDY10,t)
 i ALRDY10 q:$$quietsw(10)  zt "Abort"
 f  S %SW=10,%VAL=1 D INT^SWSET  q:$$quietsw(10)  s t=t-1 zt:'t "Abort" d DEQ10,hibernate(10,1,t)
 Q
ENQ10e s $zt="" d DEQ10 ztrap $ze
DEQ10 ;
 i CLUBACKUP,$ZU(95,10,0)  ; Clear SW10 clusterwide
 i 'ALRDY10 s %SW=10,%VAL=0 D INT^SWSET
 Q
ENQ13 ;
 n t s t=$g(quietimeout,60) s:t>0 t=(t+9)\10 ;rounded up to 10 sec
 s $zt="ENQ13e"
 i CLUBACKUP d  q
 . f  q:$$CLU^SWSET(13,1,ALRDY13)  s t=t-1 zt:'t "Abort" d DEQ13,hibernate(13,'ALRDY13,t)
 i ALRDY13 q:$$quietsw(13)  zt "Abort"
 f  S %SW=13,%VAL=1 D INT^SWSET  q:$$quietsw(13)  s t=t-1 zt:'t "Abort" d DEQ13,hibernate(13,1,t)
 Q
ENQ13e s $zt="" d DEQ13 zq 1 g:$zt'="" @$zt q
DEQ13 ;
 i CLUBACKUP,$ZU(95,13,0)  ; Clear SW13 clusterwide
 i 'ALRDY13 s %SW=13,%VAL=0 D INT^SWSET
 Q
HOLDWD(dir,time,flag) ;suspend write daemon (dir may be passed as an array)
 n n
 i $zu(182,1,0) ;clear any remaining backup request
 f  q:'$zu(182,0)  h 1  ;wait until write daemon runs again
 i $d(dir)<10 d $zu(52,9,dir,1) d:$g(flag)=1 $zu(52,8,dir,0) d $zu(182,2,0,+$zu(49,dir)) s n=1 i 1
 e  s dir="" f n=0:1 s dir=$o(dir(dir)) q:dir=""  d $zu(52,9,dir,1) d:$g(flag)=1 $zu(52,8,dir,0) d $zu(182,2,n,+$zu(49,dir))
 i $zu(182,1,n,$g(time))  ;set number of databases to back up (and optional CP wait time)
 f  q:$zu(182,0)  h 1  ;wait until write daemon suspends
 q
FREEWD ;unsuspend write daemon
 i $zu(182,1,0)
 q
msgout(aaamess,flag) ;
         s flag=$g(flag,1) ; default to FORCE
         W *-1            ;Flush the input buffer 
         q:'$L(aaamess)   ; Avoid argumentless writes...
         i $g(logfile)'="" u logfile w aaamess
         u 0
         q:flag=3  ; 1 = FORCE, FORCE, 2 = NOFORCE, 3 = LOGONLY
         i '$G(INTERNAL,0)!('$G(NOINPUT,0)&(flag=1!'$G(QUIET,0))) w aaamess
         i $g(gui) D  
         . s return=$$IjcMsg^%Wprima("DI"_aaamess) ; Retval might =  cancel msg
         . i return="CANCEL" d  
         . . i $$IjcMsg^%Wprima("DI"_$c(13,10)_"Abort received!"_$c(13,10))
         . . zt "Abort"
         u 0 
         q
timestmp(flag) 
         n msg,%TS,%TN
         s msg="TIMESTAMP: "
         s %DN=+$H d INT^%DO
         s msg=msg_%DS
         s %TN=$P($h,",",2) d ^%TO
         s msg=msg_" "_%TS
         d msgout($c(13,10)_msg_$c(13,10))
         q
OSDEVICE(mdevice,new) ;osdevice + range check, pad input, strip output.
 s mdevice=+mdevice q:mdevice<47 ""  q:mdevice>62 ""
 i $d(new) s new=$$zpad(new,32)
 q $$zstrip($$osdevice(mdevice,.new))
osdevice(mdevice,new) ;"Raw" osdevice
 n adr,old,size,where,charsize
 s $ZT="osdeverr"
 s charsize=$$charsize^%Wprim() ; check size one char
 s size=32,adr=(mdevice-47)*(size*charsize)+$ZU(40,2,28),where=-2
 s old=$v(adr,where,-size_"w")
 i $d(new) v adr:where:-size_"w":new
 q old
osdeverr q ""
zstrip(x) ;Return x with ASCII NUL's removed
 q $tr(x,$c(0),"")
zpad(x,len) ;x, maybe truncated, NUL-padded to length len, one NUL guaranteed
 n zeroes
 s zeroes=$j("",len),zeroes=$tr(zeroes," ",$c(0)) ;String of len NUL's
 s x=$e(x,1,len-1) ;Silently truncate x if necessary
 s $e(zeroes,1,$l(x))=x
 q zeroes
ZU(A,B,C,D,E,F,G,H,I,J,K,L,M,N,P) ;so needn't change $$ZU's to $ZU's
 IF '$D(B) Q $ZU(A)
 IF '$D(C) Q $ZU(A,B)
 IF '$D(D) Q $ZU(A,B,C)
 IF '$D(E) Q $ZU(A,B,C,D)
 IF '$D(F) Q $ZU(A,B,C,D,E)
 IF '$D(G) Q $ZU(A,B,C,D,E,F)
 IF '$D(H) Q $ZU(A,B,C,D,E,F,G)
 IF '$D(I) Q $ZU(A,B,C,D,E,F,G,H)
 IF '$D(J) Q $ZU(A,B,C,D,E,F,G,H,I)
 IF '$D(K) Q $ZU(A,B,C,D,E,F,G,H,I,J)
 IF '$D(L) Q $ZU(A,B,C,D,E,F,G,H,I,J,K)
 IF '$D(M) Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L)
 IF '$D(N) Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L,M)
 IF '$D(P) Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
           Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L,M,N,P)
MORE Q

DBACKB^INT^1^67214,47330
DBACKB ; Part three of Incremental Backup ;$Change: 7440104 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	; Revision: $Id: //iris/2024.1.3/databases/sys/rtn/user/dbackb.mac#1 $
POSTPROC ;
 d DEQ13
 ; Now allow full use of the global module, unless the
 ; caller already had switch 10 set
 D DEQ10
 I 'ALRDY10,'ALRDY13 d msgout($c(13,10)_"Global references are enabled."_$c(13,10),NOFORCE)
 S DIR=""
 F  S DIR=$O(DIRNAM(DIR)) Q:DIR=""  D EORFTOF
 ; store parameters about this backup
 S Y=$zu(78,22)
 i BUTYP=FULL D
 . K ^SYS("BACKUP","HISTORY")
 . S ^SYS("BACKUP","LASTFULL","DATE")=BACKHDATE
 . S ^("DESC")=DESCRIPTION,^("DEVICE")=$S($D(FIRSTDEV):FIRSTDEV,1:DEV)
 . S ^("TYPE")="Full"     ; as opposed to External Full
 . S ^("LOG")=logfile     ; logfile gets displayed on GUI
 . i Y S ^("JOURNAL")=$zu(78,3)  ; Current journal file
 i BUTYP'=FULL D
 . d ConvHistDate^DBACK
 . S ^SYS("BACKUP","HISTORY",(+BACKHDATE*1000000+$p(BACKHDATE,",",2)),"DESC")=DESCRIPTION
 . S ^("DEVICE")=$S($D(FIRSTDEV):FIRSTDEV,1:DEV),^("TYPE")=TYPE
 . S ^("LOG")=logfile     ; logfile gets displayed on GUI
 . i Y S ^("JOURNAL")=$zu(78,3)  ; Current journal file
 D SETHISTORY(1+($g(BUWARNING)]""))
 q
ExternalSetHistory(logfile,DESCRIPTION,BACKHDATE)
 Set TYPE="Paused External Full",BUTYP=5,DEV="",FULL=2
 D SETHISTORY(1)
 q
SETHISTORY(Complete)
 s BACKHDATE=$G(BACKHDATE,$H)
 s hindex=(+BACKHDATE*1000000+$p(BACKHDATE,",",2))
 S Y=$zu(78,22)
 s ^SYS("BUHISTORY",0,"LOGNOTPURGED",hindex)=""
 s ^SYS("BUHISTORY",hindex,"STATUS")=$case(Complete,-1:"Aborted",2:"Warning",1:"Completed",0:"Failed",:"")
 S ^("DESC")=$G(DESCRIPTION),^("DEVICE")=$S($D(FIRSTDEV):FIRSTDEV,1:DEV)
 S ^("TYPE")=$S(BUTYP=FULL:"Full",1:TYPE)
 S ^("LOG")=$G(logfile)     ; logfile gets displayed on GUI
 s ^("LIST")=$s(+$g(alldb):"All",1:"List")
 s ^("Complete")=Complete ;numeric completion status (cf. "STATUS")
 I Y&(Complete>0) d SetJournalHistory(hindex)
 i $p($g(^%SYS("JOURNAL","LIFESPAN","FILE")),",",2) d PPURGE^JRNUTIL
 q
SetJournalHistory(hindex) ;
 n wijinfo s wijinfo=$g(^SYS("BACKUP","WIJINFO"))
 m ^SYS("BUHISTORY",hindex,"JOURNAL")=^SYS("BACKUP","MIRINFO")
 s ^SYS("BUHISTORY",hindex,"JOURNAL")=$p(wijinfo,",",2)
 s ^SYS("BUHISTORY",hindex,"WIJINFO")=wijinfo
 q
GetJournalInfo() public {
 s ^SYS("BACKUP","WIJINFO")=$zu(78,21)
 i $SYSTEM.Mirror.IsPrimary() q  ;to use wijinfo
 k ^SYS("BACKUP","MIRINFO")
 s mirnames=$SYSTEM.Mirror.GetMirrorNames()
 s mircnt=$LL(mirnames)
 f i=1:1:mircnt {
 	s name=$LG(mirnames,i)
 	s idx=$SYSTEM.Mirror.MirrorNameToIndex(name)
 	i (idx > -1) {
		s filecnt=+$SYSTEM.Mirror.GetInfo(2,idx)
		; filecnt=0 when mirroring is stopped in backup or async member
		; or when they are in synchronizing state
 		i filecnt>0 s ^SYS("BACKUP","MIRINFO",name)=filecnt
 	}
 }
}
SetNames(D) N M
 S M=D_"IRIS"_".",INC=M_"INC",IND=M_"IND",INE=M_"INE",INF=M_"INF"
 Q
 ;
EORFTOF ; After a Full BU, we delete INE and INF
 ; after a Cumulative or Incremental,
 ; we merge INE into INF, and then delete INE.
 D SetNames(DIR)
 i BUTYP=FULL d 
 . s RC=$$INLOGOR(DIR,1,1,1)
 . s RC=$$INLOGOR(DIR,0,0,1)
 i BUTYP=PARTIAL!(BUTYP=CUMINC) D
 . S RC=$$INLOGOR(DIR,1,0,1)
 ; If the above functions failed due to an I/O error report it and
 ;    abort backup.
 I (RC'=-2)&(RC<0) D  Q
 . D msgout($c(13,10)_"["_$s(RC=+RC:"I/O Error",1:"Error "_$p(RC,",",2,*))_" occurred while processing directory '"_DIR_"']"_$c(13,10),FORCE)
 . S OK=0
 Q
JRNCHECK ;
 i $p($zu(78,22),"^",3) d  q
 . n status,error,SAVE13,SAVE10 s SAVE13=ALRDY13,SAVE10=ALRDY10
 . i ALRDY13 s ALRDY13=0,ALRDY10=1 d ENQ10,DEQ13
 . d msgout("Journaling is currently off due to I/O error. Restarting journaling..."_$c(13,10),FORCE)
 . s status=##class(%SYS.Journal.System).Start()
 . i 'status d  i 1
 . . s error=$System.Status.GetErrorText(status)
 . . d msgout("Journal start did not complete: "_error_$c(13,10),FORCE)
 . e  d msgout($c(13,10)_"Journaling started at "_$zu(78,3)_$c(13,10),FORCE)
 . I SAVE13 D ENQ13 S ALRDY13=1
 . i 'SAVE10 d DEQ10 s ALRDY10=0
 S Y=$zu(78,22)
 I 'Y d msgout("Journaling is not enabled"_$c(13,10),FORCE) Q
JRNSWTCH ;
 I INTERNAL,$zcvt($G(swjrn),"U")="N" d msgout($c(13,10)_"Journaling is NOT switched"_$c(13,10),FORCE) Q
 n SAVE13,SAVE10 s SAVE13=ALRDY13,SAVE10=ALRDY10
 ;if switch 13 is set, replace it with switch 10 since JRNSWCH sets globals
 i ALRDY13 s ALRDY13=0,ALRDY10=1 d ENQ10,DEQ13
 S status=$$JRNSWCH^JRNUTIL("",4)
 i status=1 d 
 . d msgout($C(13,10)_"Journal file switched to:"_$C(13,10),FORCE)
 . d msgout($zu(78,3)_$C(13,10),FORCE)
 i status'=1 d
 . d msgout("Journal switch did not complete"_$c(13,10),FORCE)
 . d msgout($p(status,",",2,$l(status))_$c(13,10),FORCE)
 I SAVE13 D ENQ13 S ALRDY13=1
 i 'SAVE10 d DEQ10 s ALRDY10=0
 Q
GD1(DIR) S DIR=$$ZU(12,DIR) ; get canonic name for directory
 n zu49,zu49l s zu49l=$$ZU(49,DIR),zu49=+zu49l  ;KMK106
  i zu49=-2!(zu49=-3) d
  . s NODIR(DIR)="",NODIR=NODIR+1  ;KMK106
  . s REASON(DIR)="(probably doesn't exist)"
  e  d  
  . ;  MNTDIR() sets up REASON(DIR) if it fails
  . i zu49=-1!(zu49=$zu(40,0,41)) d MNTDIR(DIR) s zu49=+$ZU(49,DIR)
  . i zu49=-1!(zu49=$zu(40,0,41)) s NODIR(DIR)="",NODIR=NODIR+1
  . e  d
  . . i +zu49=$zu(173) s NODIR(DIR)="",NODIR=NODIR+1,REASON(DIR)="("_UCDIRNAME_"TEMP cannot be backed up)" q
  . . i (('$zb(+$p(zu49l,",",17),$zu(40,8,28),1))||$zb(+$p(zu49l,",",18),$zu(40,8,30),1))&&($zb(+$p(zu49l,",",17),$zu(40,8,13),1)||($zb(+$p(zu49l,",",18),$zu(40,8,2),1))) s NODIR(DIR)="",NODIR=NODIR+1,REASON(DIR)="(Database is readonly)" q
  . . i $p(zu49l,",",15)>1&&'$g(^SYS("BACKUP","MULTIVOLUMEOK")) s NODIR(DIR)="",NODIR=NODIR+1,REASON(DIR)="(Multi-volume database not supported)" q
  . . s DIRNAM(DIR)="",DIRNAM=DIRNAM+1
  . . ; The 2nd piece of $ZU(49,dir,1) is the gfcfn which is 0
  . . ; if the database is privately mounted, non-zero if cluster mntd.
  . . S CLSTATE(DIR)=$S(+$P($ZU(49,DIR,1),",",2):"C",1:"P")
  . . i 'CLUBACKUP,CLSTATE(DIR)="C" s CLUBACKUP=1,USEENQ=1
  . . i 'USEENQ,'$p($zu(49,DIR),",",21) s USEENQ=1
  . . ;for mirrored db's we also store a series of fields from
  . . ; the mirror info block seperate by :'s
  . . ;    <mirdbname>:<mirdb guid>:<mirname>:<mirguid>: etc...
  . . s MIRDBINFO(DIR)=$$getMirDBInfo(DIR)
 Q
getMirDBInfo(dir) PUBLIC {
  ; returns null string if database is not a mirrored db or we
  ; return the information from the mirror info block that we
  ; want to store in the database list in volume #1 for use
  ; by DBREST.
  if '$$isMirroredDb^MIRRORMGR(dir) quit ""
  s info=$SYSTEM.Mirror.DBGetInfoByName(0,dir)
  if info="" quit ""  ;shouldn't happen but this isn't a mirrored database
  ;
  s dbname        =$P(info,"^",2)
  s mirjrnfilecnt =$P(info,"^",3)
  s jrnoff        =$P(info,"^",4)
  s dbguid        =$P(info,"^",6)
  s mirguid       =$P(info,"^",7)
  s mirname       =$P(info,"^",8)
  s sysguid       =$P(info,"^",9)
  ; lastfilecntrestored is usually zero unless the database
  ; is currently being caught up. In that situation this contains
  ; the mirjrnfilecnt of the last journal file replayed to
  ; this database.
  s lastfilerest =$P(info,"^",11)
  s nofailoverbit=+$ZU(40,8,31)
  s nofailoverflag=+$P(info,"^",12)
  s readonly=$ZB(nofailoverflag,nofailoverbit,1)			
  if readonly'=0 s readonly=1  ;change to 1/0 for read-only/read-write
  ; use : as a seperator, not ^. ^ is already the delimiter for the
  ; string this gets added to in the backup with the $ZU(49) and
  ; cluster flag. : is safe as long as we don't store any file names
  ; in this info as : can't be in any of the other strings.
  s backupinfo=dbname_":"_mirjrnfilecnt_":"_jrnoff_":"_dbguid
  s backupinfo=backupinfo_":"_mirguid_":"_mirname_":"_sysguid
  s backupinfo=backupinfo_":"_readonly
  quit backupinfo
}
MNTDIR(DIR) ; 
 N (DIR,%ST,REASON,bkpmount,zu49)
 s:zu49'=$zu(40,0,41) bkpmount(DIR)=""
 s Status=##Class(SYS.Database).MountDatabase(DIR,0,0)
 i (''Status) q
 i '$S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0) s REASON(DIR)="(cannot be mounted, "_$SYSTEM.Status.GetErrorText(Status)_")" q
 s Status=##Class(SYS.Database).MountDatabase(DIR,0,1)
 i '(''Status) s REASON(DIR)="(might be privately mounted elsewhere, "_$SYSTEM.Status.GetErrorText(Status)_")"
 q
 ;        
 ; subtract two times in $H format, and return the diff in # seconds
TIME(a,b) q (a-b*24*3600)+$p(a,",",2)-$p(b,",",2)
LISTDIRS ; This tag was moved here from DBACK
 ; This procedure takes a file name and a mode.  It opens the file
 ;   and dumps the list of directories which are included in a backup.
 ;   If the list is empty, all directories on the system (except temp)
 ;   are backed up.
 ; If MODE is not equal to "QUIET" then it also displays this list
 ;  on the terminal.
 ; It is intended that this list provide the list of directories
 ;    who's CACHE.DATs will be backed up.  If the backup is performed
 ;    with Cache up then it is expected that the external backup
 ;    will be followed immediatly by a 'concurrent incremental' backup
 ;    as it is necessary in order to record blocks which were modified
 ;    during the external backup.  If a directory is present in the
 ;    SYS global but does not really exist then it is not listed and
 ;    the DBACK utility will report that it isn't being backed up...
 ; Notes:
 ;     This procedure requires read access to the SYS global.
 ;     No switches are set or cleared
 ;     All local variables are NEWed
 N DIR,QUIET,D,zu49
 n rc,cnt,list,i,del1,del2,db,dbname,msg
 S $ZT="LSTERR^DBACKB"
 i $$UP^DBACK(mode)'="QUIET" d
 . s QUIET=0
 . w !,"List of directories to be backed up"
 e  s QUIET=1
 O file:"WNS"   ; Create a new copy of this file
 s del1=$$del1^%Wprim,del2=$$del2^%Wprim
 s rc=$$DbList^Wsback(.list)
 if '+rc w !,"Error building list of databases: ",$P(rc,del1,2) g LSTERR2
 s cnt=$L(list,del1)-1
 f i=1:1:cnt {
	s db=$P(list,del1,i)
	s dbname=$P(db,del2,1)
	q:dbname=""  
	s DIR=$P(db,del2,2)
 	s zu49=+$$ZU(49,DIR)  
 	i zu49=-1 {  ; skip unmounted directories
 	   s msg=DIR_" NOT mounted.  Omitted from backup."
 	   u file w msg,! i 'QUIET u 0 w !,?5,msg
 	} elseif zu49'=-2 {
 	   S D=$$ZU(12,DIR) ;Just incase it is a logical w/o ":" 
 	   u file w D,!
 	   i 'QUIET u 0 w !,?5,D
 	}
 }
 use 0
 c file
 i 'QUIET w !
 s $ZT="" Q 1   ; indicates success
LSTERR s $ZT="" i $ZE'="" w !,$ZE,!
LSTERR2
 c file
 q 0   ; indicates failures
 ;-------------------------------------------------------------------
CLRINC ;This tag was moved here from DBACK
 ;This procedure is called to clear the bitmaps that mark blocks as
 ;  modified for the databases in the backup list.  At the same
 ;  time it also deletes the backup history as it is no longer possible
 ;  to do any sort of a backup without first performing a full backup.
 ;  This procedure is designed to be used prior to doing an external
 ;  full backup with Cache running.  If an external backup is
 ;  performed with Cache down then before shutting down the system,
 ;  this entry point should be called. (JAO614 updated this comment)
 ;If MODE is not equal to QUIET then the procedure prints out the
 ;  directory names as it goes along.
 ;This procedure sets switch 10, waits for the daemon/garcol to
 ;  quiesse, and dismounts the directories before deleting the .INC
 ;  files.  
 ; Notes:
 ;    This process requires read/write access to the SYS global.
 ;    This procedure will record the state of switch 13,
 ;          insure switch 13 is set and restore switch 13 upon exit.
 ;    All local variables are NEWed EXCEPT for those defined by
 ;          INITVARS^DBACK
 ;    If a directory is dismounted when this routine is called then
 ;          it is left dismounted when the routine exits
 ; Error processing:
 ;   If an error is encountered (although none are expected) then we
 ;      restore switch 13.  At this point however we have deleted
 ;      the backup history information as we may have cleared one
 ;      or more bitmaps (JAO614)
 S $ZT="CLRERR"
 i '$SYSTEM.Security.Check("%Admin_Operate","USE") {
 	w !,"Operation requires %Admin_Operate:Use privilege"
	q 0	 
 }
 N DIR,%SW,%VAL,RC,TMP,QUIET,SW13SET,SW10SET,OK,D         
 n zu49  
 n CLUBACKUP,LCKTYPE,NODIR,DIRNAM,CLSTATE
 n mirrorid,MIRDBINFO
 n rc,cnt,list,i,del1,del2,db,dbname,msg
 n ALRDY13 ;used in ENQ13, same as SW13SET
 D INITVARS^DBACK                   ; Note: This executes ^%ST
 s DIR=""
 ; Insure switch 10 is set, switch 13 is clear
 S SW10SET=$$CHECK10^DBACK          ; Records current setting of switch 10
 S SW13SET=$$CHECK13^DBACK          ; Records current setting of switch 13
 I 'SW10SET S %SW=10,%VAL=1 d INT^SWSET       ; Set switch 10
 I SW13SET S %SW=13,%VAL=0 d INT^SWSET        ; Clear switch 13
 i $$UP^DBACK(mode)'="QUIET" s QUIET=0
 e  s QUIET=1
 ;
 S NODIR=0,DIRNAM=0
 s del1=$$del1^%Wprim,del2=$$del2^%Wprim
 s rc=$$DbList^Wsback(.list)
 if '+rc w !,"Error building list of databases: ",$P(rc,del1,2) g CLRERR3
 s cnt=$L(list,del1)-1
 f i=1:1:cnt {
	s db=$P(list,del1,i)
	s dbname=$P(db,del2,1)
	q:dbname=""  
	s DIR=$P(db,del2,2)
	do GD1(DIR)
    i $d(NODIR(DIR)),'QUIET w !,?5,DIR,$tr($g(REASON(DIR)),"()","  ")
 }
 ; Kill off the history and initialize the variables for using
 ;   the Backup specific $ZU functions
 K ^SYS("BACKUP","HISTORY")   ; Once we start this we can no longer
 K ^SYS("BACKUP","LASTFULL")  ;    use the old history information
 d GetJournalInfo()
 ; Wait for disk cleanup to complete
 I SW13SET S %SW=13,%VAL=1 D INT^SWSET        ; Set switch 13  
 I 'SW10SET S %SW=10,%VAL=0 D INT^SWSET       ; Clear switch 10
 i $g(USEENQ) s ALRDY13=SW13SET d ENQ13 i 1 
 e  d HOLDWD(.DIRNAM)
 s $zt="CLRERR2"
 S DIR=""
 F  S DIR=$O(DIRNAM(DIR)) q:DIR=""  d
 . S D=$$ZU(12,DIR) ; Just incase it is a logical w/o ":"     
 . do $ZU(52,8,D,0)  ;Clear the GFNOBACKUP bit on the database
 . ;Set GFFORCEFULBK for non-HOLDWD because HOLDWD already turned it on.
 . ;We need to set it for CLRINC to make sure this DB needs a full backup
 . ;afterwards. The BACKUP^DBACK("","E") will clear it after a full backup
 . ;is succeed.
 . I $g(USEENQ) D $zu(52,9,DIR,1)
 . s RC=$$INLOGOR^DBACK(D,3,3,1) ; clear it
 . i 'QUIET D
 .. I RC>-1 W !,?5,"Cleared incremental backup bitmap in ",D q
 .. i RC=-1 w !,?5,"I/O Error clearing bitmap in ",D q
 .. i RC=-2 w !,?5,"Incremental backup not enabled for ",D q
 .. w !,?5,"Unknown error (",RC,") clearing bitmap in ",D
 ; Post processing - reset switches
 i $g(USEENQ) d DEQ13 i 1
 e  d FREEWD
 S $ZT=""
 Q 1                         ; Indicates success
CLRERR s $ZT="" i $ZE'="" w !,$ZE
CLRERR3 ;
 w !
 I SW13SET  S %SW=13,%VAL=1 D INT^SWSET       ; Set switch 13  
 I 'SW10SET S %SW=10,%VAL=0 D INT^SWSET       ; Clear switch 10
 q 0                       ; Indicates failure
CLRERR2 s $ZT="" i $ZE'="" w !,$ZE
 w !
 i $g(USEENQ) d DEQ13 i 1
 e  d FREEWD 
 q 0
INLOGOR(DIR,SOURCE,TARGET,DISPOSE) ;Adapter, present same i'face for VAX & UX
 n rc
 try {
   s rc=$ZU(31,DIR,SOURCE,TARGET,DISPOSE)
 } catch {
   s rc=-1_","_$ze
   s $ze=""
 }
 q rc
FILENORM(NAME) ;Return normalized version of NAME
 S OK=1,$ZT="FNERR"
 N MTDEV,DIR S MTDEV=$$OSDEVICE(NAME) I MTDEV'="" S ISREG=0 Q NAME
 i ($zversion(1)=2),$E(NAME,1,2)="\\" S L=$$CheckForTape(NAME) I L'="" S ISREG=0 Q L
 i ($zversion(1)=2) S L=$L(NAME,"\"),DIR=$P(NAME,"\",1,L-1)
 i ($zversion(1)=2) IF L>1 S DIR=DIR_"\"
 i ($zversion(1)=2) S NAME=$ZU(12,DIR)_$P(NAME,"\",L,L),ISREG=$ZU(140,7,NAME),ISREG=$S(ISREG>0:1,ISREG=-2:1,1:0) Q NAME
 i ($zversion(1)=3) S L=$L(NAME,"/"),DIR=$P(NAME,"/",1,L-1)
 i ($zversion(1)=3) IF L>1 S DIR=DIR_"/"
 i ($zversion(1)=3) S NAME=$ZU(12,DIR)_$P(NAME,"/",L,L),ISREG=$ZU(140,7,NAME),ISREG=$S(ISREG=-2:1,ISREG/32768#2:1,1:0) Q NAME
FNERR S OK=0,ERRMSG="Not a valid device name." Q
CheckForTape(NAME)
 S NAME=$ZCVT(NAME,"U")
 N I,TAPE
 For I=47:1:62 s TAPE=$$OSDEVICE(I) I NAME=$ZCVT(TAPE,"U") S NAME=I Q
 I NAME?2N Q NAME
 I NAME?1"\\.\TAPE"1N Q NAME
 Q ""
TQUIWRITE(verbose) q $$QUIESCE(1,"buffer activity",10,verbose)
TQUIGC(verbose) q $$QUIESCE(2,"garbage collection",10,verbose)
TQUIDB(verbose) q $$QUIESCE(4,"database expansion",10,verbose)
TQUIGLO(verbose) q $$QUIESCE(8,"global activity",10,verbose)
TQUIGLOUPD(verbose) q $$QUIESCE(16,"global updates",10,verbose)
TQUINET(verbose) q $$QUIESCE(32,"network activity",10,verbose)
TQUIDISK(verbose) q $$QUIESCE(1+2,"disk activity",10,verbose)
TQUIUPD(verbose) q $$QUIESCE(1+2+4+16,"update activity",10,verbose)
TQUISYS(verbose) q $$QUIESCE(1+2+4+8,"system activity",10,verbose)
QUIESCE(bits,text,retries,verbose,intv) ;
 s verbose=+$g(verbose),retries=+$g(retries,-1),intv=+$g(intv,1)
 q ($$Quiesce(bits,text,retries,verbose,intv)>0)
Quiesce(bits,text,retries,verbose,intv) ;
 n noWDbits
 s $zt="QUIESCEE"
 q:$zu(51,bits) 1 ;double checking $ZU(51) is no longer necessary
 s verbose=+$g(verbose),retries=+$g(retries,-1),intv=+$g(intv,1)
 d msgout($c(13,10)_"WARNING: Switch is set and may affect production for up to "_(retries*intv)_" seconds."_$c(13,10)_"Waiting for "_text_" to finish...",NOFORCE)
 f  q:'retries  h intv q:$zu(51,bits)  s retries=retries-1 i retries#5=0 d msgout(".",NOFORCE)
 s noWDbits=1
 s:$s($S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0):''$zu(59,0),1:0) noWDbits=noWDbits+2
 s noWDbits=$zboolean(bits,noWDbits,2)  ;2 = x & ~ y
 if '$ZU(51,bits),bits'=1,$zboolean(bits,1,1),$zu(51,noWDbits) {
	 d msgout($c(13,10)_"System is idle except WD is still running."_$c(13,10)_"     Waiting up to 2 minutes for WD to finish",NOFORCE)
	 f i=1:1:120 q:$ZU(51,bits)  h 1 if i#5=0 d msgout(".",NOFORCE)
	 if $ZU(51,bits) s retries=1 ;signal success
 }
 d msgout($s(retries:" ready.",1:" abort. "_$$quiescefailmsg(bits))_$c(13,10),NOFORCE)
 q retries
quiescefailmsg(bits)
 N ret,clu,clumsg s ret="",clu=$zb(bits,512+256+128,1),clumsg=""
 if $zb(clu,128,1)||($zb(clu,(256+512),1)=(256+512)) s clu=128,clumsg=" (cluster wide)"
 if $zb(clu,512,1) s clumsg=" (cluster master only)"
 if $zb(clu,256,1) s clumsg=" (cluster slaves only)"
 if $zb(bits,1,1)&&('$ZU(51,clu+1)) S ret=ret_"write daemon"_clumsg_","
 if $zb(bits,2,1)&&('$ZU(51,clu+2)) S ret=ret_"garbage collector"_clumsg_"," 
 if $zb(bits,4,1)&&('$ZU(51,clu+4)) S ret=ret_"file expander"_clumsg_","
 if $zb(bits,8,1)&&('$ZU(51,clu+8)) S ret=ret_"global reference"_clumsg_","
 if $zb(bits,16,1)&&('$ZU(51,clu+16)) S ret=ret_"global update"_clumsg_","
 if $zb(bits,32,1)&&('$ZU(51,clu+32)) S ret=ret_"client-side network connections"_clumsg_","
 if $zb(bits,64,1)&&('$ZU(51,clu+64)) S ret=ret_"network server activity"_clumsg_","
 if ret'="" s ret="Quiesce failed reason: "_$e(ret,1,*-1) d $zu(9,"",ret,1,2) i $d(^rOBJ("ZQuiesceFail")) d ^ZQuiesceFail
 Q ret
QUIESCEE s $zt="" d $zu(9,"","QUIESCE: "_$ze,(1>0),1) q -1 ;0
CluQuiet(switch,target,timeout)
 n flags,rc
 i $g(switch)-10,$g(switch)-13 ztrap "SWITCH"
 n targetmsg s target=$g(target)
 i target=1 s target=256,targetmsg=" on cluster slave members"
 e  i target=2 s target=512,targetmsg=" on cluster master"
 e  s target=512+256,targetmsg=" cluster wide"
 s flags=1+2+4+$s(switch=10:8,1:16)
 s rc=$$Quiesce(flags+target,$s(switch=10:"system activity",1:"update activity")_targetmsg,$g(timeout,10),'$g(QUIET,$g(QUIETLY)))
 i rc<0 ztrap "Abort"
 q rc
quietsw(switch,timeout) ;quiesce activities w/ timeout after setting switch 10 or 13
 n flags,rc
 i $g(switch)-10,$g(switch)-13 ztrap "SWITCH"
 s flags=1+2+4+$s(switch=10:8,1:16)
 i CLUBACKUP s flags=flags+128
 s rc=$$Quiesce(flags,"disk cleanup",$s($g(timeout)="":30,1:timeout),'$g(QUIET))
 i rc<0 ztrap "Abort"
 q rc
hibernate(switch,released,timeo) ;
 i +$g(released) d msgout($c(13,10)_"Switch "_switch_" is released.",NOFORCE)
 n hibtime s hibtime=$s(timeo>3:10,timeo>2:1,timeo>1:.1,timeo>0:.01,1:10)
 d msgout($c(13,10)_"Backup will hibernate for "_hibtime_" second(s) and try again."_$c(13,10)_"You may abort Backup via Ctrl-C. ",NOFORCE) 
 i hibtime<1 h hibtime
 e  n i f i=1:1:hibtime h 1 d msgout(".",NOFORCE)
 d msgout($c(13,10),NOFORCE)
 q
ENQ10 ;
 n t s t=$g(quietimeout,60) s:t>0 t=(t+9)\10 ;rounded up to 10 sec
 s $zt="ENQ10e"
 i CLUBACKUP d  q
 . f  q:$$CLU^SWSET(10,1,ALRDY10,$g(QUIETMASTERONLY))  s t=t-1 zt:'t "Abort" d hibernate(10,'ALRDY10,t)
 i ALRDY10 q:$$quietsw(10)  zt "Abort"
 f  S %SW=10,%VAL=1 D INT^SWSET  q:$$quietsw(10)  s t=t-1 zt:'t "Abort" d DEQ10,hibernate(10,1,t)
 Q
ENQ10e s $zt="" d DEQ10 ztrap $ze
DEQ10 ;
 i CLUBACKUP,$ZU(95,10,0)  ; Clear SW10 clusterwide
 i 'ALRDY10 s %SW=10,%VAL=0 D INT^SWSET
 Q
ENQ13 ;
 n t s t=$g(quietimeout,60) s:t>0 t=(t+9)\10 ;rounded up to 10 sec
 s $zt="ENQ13e"
 i CLUBACKUP d  q
 . f  q:$$CLU^SWSET(13,1,ALRDY13)  s t=t-1 zt:'t "Abort" d DEQ13,hibernate(13,'ALRDY13,t)
 i ALRDY13 q:$$quietsw(13)  zt "Abort"
 f  S %SW=13,%VAL=1 D INT^SWSET  q:$$quietsw(13)  s t=t-1 zt:'t "Abort" d DEQ13,hibernate(13,1,t)
 Q
ENQ13e s $zt="" d DEQ13 zq 1 g:$zt'="" @$zt q
DEQ13 ;
 i CLUBACKUP,$ZU(95,13,0)  ; Clear SW13 clusterwide
 i 'ALRDY13 s %SW=13,%VAL=0 D INT^SWSET
 Q
HOLDWD(dir,time,flag) ;suspend write daemon (dir may be passed as an array)
 n n
 i $zu(182,1,0) ;clear any remaining backup request
 f  q:'$zu(182,0)  h 1  ;wait until write daemon runs again
 i $d(dir)<10 d $zu(52,9,dir,1) d:$g(flag)=1 $zu(52,8,dir,0) d $zu(182,2,0,+$zu(49,dir)) s n=1 i 1
 e  s dir="" f n=0:1 s dir=$o(dir(dir)) q:dir=""  d $zu(52,9,dir,1) d:$g(flag)=1 $zu(52,8,dir,0) d $zu(182,2,n,+$zu(49,dir))
 i $zu(182,1,n,$g(time))  ;set number of databases to back up (and optional CP wait time)
 f  q:$zu(182,0)  h 1  ;wait until write daemon suspends
 q
FREEWD ;unsuspend write daemon
 i $zu(182,1,0)
 q
msgout(aaamess,flag) ;
         s flag=$g(flag,1) ; default to FORCE
         W *-1            ;Flush the input buffer 
         q:'$L(aaamess)   ; Avoid argumentless writes...
         i $g(logfile)'="" u logfile w aaamess
         u 0
         q:flag=3  ; 1 = FORCE, FORCE, 2 = NOFORCE, 3 = LOGONLY
         i '$G(INTERNAL,0)!('$G(NOINPUT,0)&(flag=1!'$G(QUIET,0))) w aaamess
         i $g(gui) D  
         . s return=$$IjcMsg^%Wprima("DI"_aaamess) ; Retval might =  cancel msg
         . i return="CANCEL" d  
         . . i $$IjcMsg^%Wprima("DI"_$c(13,10)_"Abort received!"_$c(13,10))
         . . zt "Abort"
         u 0 
         q
timestmp(flag) 
         n msg,%TS,%TN
         s msg="TIMESTAMP: "
         s %DN=+$H d INT^%DO
         s msg=msg_%DS
         s %TN=$P($h,",",2) d ^%TO
         s msg=msg_" "_%TS
         d msgout($c(13,10)_msg_$c(13,10))
         q
OSDEVICE(mdevice,new) ;osdevice + range check, pad input, strip output.
 s mdevice=+mdevice q:mdevice<47 ""  q:mdevice>62 ""
 i $d(new) s new=$$zpad(new,32)
 q $$zstrip($$osdevice(mdevice,.new))
osdevice(mdevice,new) ;"Raw" osdevice
 n adr,old,size,where,charsize
 s $ZT="osdeverr"
 s charsize=$$charsize^%Wprim() ; check size one char
 s size=32,adr=(mdevice-47)*(size*charsize)+$ZU(40,2,28),where=-2
 s old=$v(adr,where,-size_"w")
 i $d(new) v adr:where:-size_"w":new
 q old
osdeverr q ""
zstrip(x) ;Return x with ASCII NUL's removed
 q $tr(x,$c(0),"")
zpad(x,len) ;x, maybe truncated, NUL-padded to length len, one NUL guaranteed
 n zeroes
 s zeroes=$j("",len),zeroes=$tr(zeroes," ",$c(0)) ;String of len NUL's
 s x=$e(x,1,len-1) ;Silently truncate x if necessary
 s $e(zeroes,1,$l(x))=x
 q zeroes
ZU(A,B,C,D,E,F,G,H,I,J,K,L,M,N,P) ;so needn't change $$ZU's to $ZU's
 IF '$D(B) Q $ZU(A)
 IF '$D(C) Q $ZU(A,B)
 IF '$D(D) Q $ZU(A,B,C)
 IF '$D(E) Q $ZU(A,B,C,D)
 IF '$D(F) Q $ZU(A,B,C,D,E)
 IF '$D(G) Q $ZU(A,B,C,D,E,F)
 IF '$D(H) Q $ZU(A,B,C,D,E,F,G)
 IF '$D(I) Q $ZU(A,B,C,D,E,F,G,H)
 IF '$D(J) Q $ZU(A,B,C,D,E,F,G,H,I)
 IF '$D(K) Q $ZU(A,B,C,D,E,F,G,H,I,J)
 IF '$D(L) Q $ZU(A,B,C,D,E,F,G,H,I,J,K)
 IF '$D(M) Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L)
 IF '$D(N) Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L,M)
 IF '$D(P) Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
           Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L,M,N,P)
MORE Q

DBACKC^INT^1^67214,47330
DBACKC ; Part three of Incremental Backup ;$Change$
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	; Revision: $Id$
ASKSET(prompt,val,backup,help,pattern) ;procedure
 N x,done,def,enahelp,helpavail,backupavail
 s done=0
 s def=$G(val)
 s backup=$G(backup,0) 
 s enabackup=$S(backup=-1:0,1:1)
 s backupavail=$S(backup=1:1,1:0)
 s help=$G(help)
 s enahelp=$S(help="*":0,1:1) ;there might not be any help though
 s helpavail=$s(enahelp&($L(help)!($D(help)>1)):1,1:0)
 if 'enabackup n POP
 s POP=0
 f  d  q:done!POP
 . W !,$G(prompt)
 . w:($X+$L(def))>65 !,?5
 . w:$L(def) " <",def,">"
 . if helpavail!backupavail do
 . . w " [" w:helpavail "?" w:backupavail "^" w "]"
 . w:(($X+$L(def))>75) !,?5
 . W " => " 
 . R x,!
 . if x="^" d  q
 . . if 'enabackup s done=1 q
 . . if backupavail s POP=1 q
 . . w "...backup not available here"
 . if enabackup,x="""^""" s x="^",done=1 q
 . ;
 . if x="?" d  q
 . . if 'enahelp s done=1 q
 . . if 'helpavail w "...help not available here" q
 . . if $D(help)=1 w !?5,help q
 . . s x="" f  s x=$O(help(x)) q:x=""  w !,?5,help(x)
 . . w !
 . if enahelp,x="""?""" s x="?",done=1 q
 . i x]"",$g(pattern)]"",x'?@pattern w !?5,$s(helpavail:help,1:"[bad format]") q
 . s:'$L(x) x=val 
 . s done=1
 s:'POP val=x
 q
 ; Part III of the Incremental Backup Utility. NEWINC
 ;
DIRPASS ;
 n zu49,x,err,start,end,numerr,s,lastblk
 i PASS=1,BUTYP=FULL,$zu(32,8,$g(^SYS("BACKUP","UseLargeRead"),1))!1
 e  i $zu(32,8,+$g(^SYS("BACKUP","UseLargeRead","All")))
 ;$ZU(32,1,DIR) writes the directory label to the backup file which
 ;includes the "$ZU(49)" info. It is important that the current size
 ;of the database in the directory label caters for all the blocks
 ;stored in that pass so we do this after setting switch 13, not before.
 f  s x=$$ZU(32,1,DIR) q:+x=1  d  i OK'=1 q
 . ;in here set OK to 0 if we get a fatal error and want to abort the backup
 . ;set OK to -1 to abort this directory, drop it from the backup but continue
 . ; with the backup for other directories
 . ;leave OK alone or set it to 1 to retry the $ZU(32,1,DIR) operation
 . i +x=RCABORT s OK=0 d msgout($c(13,10)_$c(13,10)_"We got an abort signal while trying to open directory "_DIR_$c(13,10)_"and write a label."_$c(13,10)_$c(13,10),NOFORCE) Q
 . n sx s sx=x n x s x=sx ; preserve x because it'll be used just after the current do scope
 . d msgout($c(13,10)_$c(13,10)_"We got an error trying to open directory "_DIR_$c(13,10)_"and write a label."_$c(13,10)_$c(13,10),NOFORCE)
 . s err=$$error(x)
 . i +x=RCINERR!(+x=RCMAPINERR)!(+x=RCBADMAP)!(+x=RCMOUNT) d  s OK=-1 k DIRNAM(DIR) q
 . . d msgout("We got a '"_err_"' error trying to mount the "_"IRIS"_".DAT file in "_DIR_$c(13,10)_"  It will be skipped."_$c(13,10),FORCE)
 . d msgout("We got a '"_err_"' write error trying to write the label for the"_$c(13,10)_"IRIS"_".DAT file in "_DIR_$c(13,10),FORCE)
 . d msgout($c(13,10)_"Switch to another output file and we won't lose any data."_$c(13,10),FORCE)
 . d nextvol($s(+x=RCOFFLINE:"",1:"End of Volume")) q
 ;OK is 0 to abort backup or 1 to skip this directory and continue
 i +x'=1 s:OK<0 OK=1 q  
 ; Backup this directory for this pass
 d msgout($c(13,10)_"Backing up "_DIR_" at "_$ZDATETIME($H),NOFORCE)
 ;
continue ;
 S VOLDIR=DIR,start=$zh,RC=$$ZU(IBUPass,2),end=$zh
 ;
 d msgout($c(13,10)_"Copied "_$p(RC,",",3)_" blocks in "_$j(end-start,0,3)_" seconds"_$c(13,10),FORCE)
 s numerr=$l(RC,",")-3 i numerr s s=$s(numerr=1:"",1:"s") d  
 . d msgout($c(13,10)_" With "_numerr_" read error"_s_" on block"_s,FORCE)
 . s s="" f i=1:1:numerr s s=s_$j($p(RC,",",i+3),11) s:$l($p(s,$c(13,10),$l(s,$c(13,10))))>68 s=x_$c(13,10)
 . d msgout($c(13,10)_s_$c(13,10),FORCE)
 i +RC=1 d msgout($c(13,10)_"Finished this pass of copying "_DIR_$c(13,10),FORCE) g DPX
 s err=$$error(RC),lastblk=$p(RC,",",numerr+3)
 ;
 i +RC=RCINERR g readerr
 i +RC=RCABORT d msgout("We got an abort signal,backup aborted."_$c(13,10),FORCE) g abort
 i +RC=RCBADMAP d  d msgout("  - this is a fatal error"_$c(13,10),FORCE) g abort
 . i lastblk d msgout("Bitmap block "_lastblk_" has a bad label",FORCE)
 . e  d msgout("We are missing incremental bitmaps for this 2kb "_"IRIS"_".DAT file",FORCE)
 i +RC=RCMAPINERR d msgout("We got a fatal read error on a bitmap block "_lastblk_$c(13,10),FORCE) g abort
 ; we got a write error while copying a database
 d msgout("We got a '"_err_"' write error trying to copy this "_"IRIS"_".DAT directory."_$c(13,10),FORCE)
 d msgout("Switch to another output file and we won't lose any data."_$c(13,10),FORCE)
 d nextvol($s(+RC=RCOFFLINE:"",1:"End of Volume")) g continue:OK d abort s OK=0 q
 ;
 ; readerr
 ; we got a read error while copying a database
readerr ;
 d msgout("We got too many read errors on "_DIR_"."_$c(13,10),FORCE)
 n text,def s text="Do you wish to continue with this directory?",def="Yes"
 i '$g(gui) d  R a s:a="" a=def
 . d msgout(text_" ["_def_"] ",FORCE)
 e  s a=$$IjcMB^%Wprima(text,4,"Backup: Too Many Input Errors")
 ;
 i a?1"Y".e!(a?1"y".e) d msgout($c(13,10)_"Continuing copy of "_DIR,FORCE) g continue
abort d msgout($c(13,10)_"Copy of "_DIR_" aborted."_$c(13,10),FORCE) s OK=1 k DIRNAM(DIR) q
 ;
 ; done
 ; we've finished the backup - write the end of volume record and close structures
done ;
 i $g(markinfo)]"" f  s a=$$ZU(32,6,markinfo) q:+a=1!(+a=RCABORT)  d  q:'OK
 . s err=$$error(a)
 . d msgout("We got a rare "_err_" writing a journal marker information record."_$c(13,10),FORCE)
 . d msgout("You must output to another volume briefly to finish the backup"_$c(13,10),FORCE)
 . d nextvol("End of Volume.")
 s a=$$ZU(32,4)
 i +a'=1&(+a'=RCABORT) d  q:'OK
 . s err=$$error(a)
 . d msgout("We got a rare "_err_" writing the last couple of blocks and the end-of-volume-set label record."_$c(13,10),FORCE)
 . d msgout("You must output to another volume briefly to finish the backup"_$c(13,10),FORCE)
 . d nextvol("End of Volume.")
 . q
 s a=$$ZU(32,5) ; close structures
 d msgout($c(13,10)_"***"_$s(##class(Backup.General).GetAbortStatus():"ABORTED",1:"FINISHED")_" BACKUP***"_$c(13,10),FORCE)
 q
 ;
DPX ;
 S OK=1 S RC=$$INLOGOR(DIR,2,1,1) I RC'=-2,RC<0 D 
 . D msgout($c(13,10)_"["_$s(RC=+RC:"I/O Error",1:"Error "_$p(RC,",",2,*))_" occurred while processing directory '"_DIR_"' - Check the log]"_$c(13,10),FORCE)
 . S OK=0
 Q
 ; end of DIRPASS
 ;------------------------------------------------------------------
 ;
 ; $$error(x)
 ; translate return code into text
error(a) ;
 i a>0 s a=$p("Success,End Of Tape,Device Off Line,Device Full,not used",",",a)
 e  d
 . i a>-10 s a=$p("General Read,General Write,Cluster Mounted Target,Directory Mount Error,Restore Map Error,Restore Old Format,Restore Bad Input Volume,Restore Bad Block Contents (failed CRC on read),no longer used,Restore End Of Volume",",",-a) q
 . e  s a=$p("2kb Missing Bitmaps/Bad Bitmap Label,Restore Wrong Block Size,Read Error on Incrmental Bitmap,Input Error But Label Is Good,Restore Bad Block Contents (was bad when backup made),Missing Blocks Due to Read Errors,End of Volume Set,Directory Label Record,Missing Directory Label Record",",",-a-10)
 i a="" s a="***Unknown Problem***"
 q a
 ;
nextvol(prompt) ;
 s x=$$ZU(32,3)
 n BEG s BEG=$ZH,VOL=VOL+1
 S BUFCOUNT=$P(RC,",",2)
 i NOINPUT d   s OK=0 q                                       ;JAO264+
 . d msgout($c(13,10)_"End of volume detected",FORCE)
 . d msgout($c(13,10)_"Terminal input not enabled-Terminating backup",FORCE)
 d msgout($c(13,10)_prompt,FORCE)                                   ;JAO266
NXTVOL1 d msgout($c(13,10)_" Where should output continue?",FORCE)         ;JAO266
 D GETDEV^DBACKA Q:'OK  D VOLLABEL^DBACKA G NXTVOL1:'OK
 S LOST=LOST+($ZH-BEG) ; count the lost time
 Q
INLOGOR(DIR,SOURCE,TARGET,DISPOSE) ;Adapter, present same i'face for VAX & UX
 n rc
 try {
   s rc=$ZU(31,DIR,SOURCE,TARGET,DISPOSE)
 } catch {
   s rc=-1_","_$ze
   s $ze=""
 }
 q rc
FILENORM(NAME) ;Return normalized version of NAME
 S OK=1,$ZT="FNERR"
 N MTDEV,DIR S MTDEV=$$OSDEVICE(NAME) I MTDEV'="" S ISREG=0 Q NAME
 i ($zversion(1)=2),$E(NAME,1,2)="\\" S L=$$CheckForTape(NAME) I L'="" S ISREG=0 Q L
 i ($zversion(1)=2) S L=$L(NAME,"\"),DIR=$P(NAME,"\",1,L-1)
 i ($zversion(1)=2) IF L>1 S DIR=DIR_"\"
 i ($zversion(1)=2) S NAME=$ZU(12,DIR)_$P(NAME,"\",L,L),ISREG=$ZU(140,7,NAME),ISREG=$S(ISREG>0:1,ISREG=-2:1,1:0) Q NAME
 i ($zversion(1)=3) S L=$L(NAME,"/"),DIR=$P(NAME,"/",1,L-1)
 i ($zversion(1)=3) IF L>1 S DIR=DIR_"/"
 i ($zversion(1)=3) S NAME=$ZU(12,DIR)_$P(NAME,"/",L,L),ISREG=$ZU(140,7,NAME),ISREG=$S(ISREG=-2:1,ISREG/32768#2:1,1:0) Q NAME
FNERR S OK=0,ERRMSG="Not a valid device name." Q
CheckForTape(NAME)
 S NAME=$ZCVT(NAME,"U")
 N I,TAPE
 For I=47:1:62 s TAPE=$$OSDEVICE(I) I NAME=$ZCVT(TAPE,"U") S NAME=I Q
 I NAME?2N Q NAME
 I NAME?1"\\.\TAPE"1N Q NAME
 Q ""
TQUIWRITE(verbose) q $$QUIESCE(1,"buffer activity",10,verbose)
TQUIGC(verbose) q $$QUIESCE(2,"garbage collection",10,verbose)
TQUIDB(verbose) q $$QUIESCE(4,"database expansion",10,verbose)
TQUIGLO(verbose) q $$QUIESCE(8,"global activity",10,verbose)
TQUIGLOUPD(verbose) q $$QUIESCE(16,"global updates",10,verbose)
TQUINET(verbose) q $$QUIESCE(32,"network activity",10,verbose)
TQUIDISK(verbose) q $$QUIESCE(1+2,"disk activity",10,verbose)
TQUIUPD(verbose) q $$QUIESCE(1+2+4+16,"update activity",10,verbose)
TQUISYS(verbose) q $$QUIESCE(1+2+4+8,"system activity",10,verbose)
QUIESCE(bits,text,retries,verbose,intv) ;
 s verbose=+$g(verbose),retries=+$g(retries,-1),intv=+$g(intv,1)
 q ($$Quiesce(bits,text,retries,verbose,intv)>0)
Quiesce(bits,text,retries,verbose,intv) ;
 n noWDbits
 s $zt="QUIESCEE"
 q:$zu(51,bits) 1 ;double checking $ZU(51) is no longer necessary
 s verbose=+$g(verbose),retries=+$g(retries,-1),intv=+$g(intv,1)
 d msgout($c(13,10)_"WARNING: Switch is set and may affect production for up to "_(retries*intv)_" seconds."_$c(13,10)_"Waiting for "_text_" to finish...",NOFORCE)
 f  q:'retries  h intv q:$zu(51,bits)  s retries=retries-1 i retries#5=0 d msgout(".",NOFORCE)
 s noWDbits=1
 s:$s($S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0):''$zu(59,0),1:0) noWDbits=noWDbits+2
 s noWDbits=$zboolean(bits,noWDbits,2)  ;2 = x & ~ y
 if '$ZU(51,bits),bits'=1,$zboolean(bits,1,1),$zu(51,noWDbits) {
	 d msgout($c(13,10)_"System is idle except WD is still running."_$c(13,10)_"     Waiting up to 2 minutes for WD to finish",NOFORCE)
	 f i=1:1:120 q:$ZU(51,bits)  h 1 if i#5=0 d msgout(".",NOFORCE)
	 if $ZU(51,bits) s retries=1 ;signal success
 }
 d msgout($s(retries:" ready.",1:" abort. "_$$quiescefailmsg(bits))_$c(13,10),NOFORCE)
 q retries
quiescefailmsg(bits)
 N ret,clu,clumsg s ret="",clu=$zb(bits,512+256+128,1),clumsg=""
 if $zb(clu,128,1)||($zb(clu,(256+512),1)=(256+512)) s clu=128,clumsg=" (cluster wide)"
 if $zb(clu,512,1) s clumsg=" (cluster master only)"
 if $zb(clu,256,1) s clumsg=" (cluster slaves only)"
 if $zb(bits,1,1)&&('$ZU(51,clu+1)) S ret=ret_"write daemon"_clumsg_","
 if $zb(bits,2,1)&&('$ZU(51,clu+2)) S ret=ret_"garbage collector"_clumsg_"," 
 if $zb(bits,4,1)&&('$ZU(51,clu+4)) S ret=ret_"file expander"_clumsg_","
 if $zb(bits,8,1)&&('$ZU(51,clu+8)) S ret=ret_"global reference"_clumsg_","
 if $zb(bits,16,1)&&('$ZU(51,clu+16)) S ret=ret_"global update"_clumsg_","
 if $zb(bits,32,1)&&('$ZU(51,clu+32)) S ret=ret_"client-side network connections"_clumsg_","
 if $zb(bits,64,1)&&('$ZU(51,clu+64)) S ret=ret_"network server activity"_clumsg_","
 if ret'="" s ret="Quiesce failed reason: "_$e(ret,1,*-1) d $zu(9,"",ret,1,2) i $d(^rOBJ("ZQuiesceFail")) d ^ZQuiesceFail
 Q ret
QUIESCEE s $zt="" d $zu(9,"","QUIESCE: "_$ze,(1>0),1) q -1 ;0
CluQuiet(switch,target,timeout)
 n flags,rc
 i $g(switch)-10,$g(switch)-13 ztrap "SWITCH"
 n targetmsg s target=$g(target)
 i target=1 s target=256,targetmsg=" on cluster slave members"
 e  i target=2 s target=512,targetmsg=" on cluster master"
 e  s target=512+256,targetmsg=" cluster wide"
 s flags=1+2+4+$s(switch=10:8,1:16)
 s rc=$$Quiesce(flags+target,$s(switch=10:"system activity",1:"update activity")_targetmsg,$g(timeout,10),'$g(QUIET,$g(QUIETLY)))
 i rc<0 ztrap "Abort"
 q rc
quietsw(switch,timeout) ;quiesce activities w/ timeout after setting switch 10 or 13
 n flags,rc
 i $g(switch)-10,$g(switch)-13 ztrap "SWITCH"
 s flags=1+2+4+$s(switch=10:8,1:16)
 i CLUBACKUP s flags=flags+128
 s rc=$$Quiesce(flags,"disk cleanup",$s($g(timeout)="":30,1:timeout),'$g(QUIET))
 i rc<0 ztrap "Abort"
 q rc
hibernate(switch,released,timeo) ;
 i +$g(released) d msgout($c(13,10)_"Switch "_switch_" is released.",NOFORCE)
 n hibtime s hibtime=$s(timeo>3:10,timeo>2:1,timeo>1:.1,timeo>0:.01,1:10)
 d msgout($c(13,10)_"Backup will hibernate for "_hibtime_" second(s) and try again."_$c(13,10)_"You may abort Backup via Ctrl-C. ",NOFORCE) 
 i hibtime<1 h hibtime
 e  n i f i=1:1:hibtime h 1 d msgout(".",NOFORCE)
 d msgout($c(13,10),NOFORCE)
 q
ENQ10 ;
 n t s t=$g(quietimeout,60) s:t>0 t=(t+9)\10 ;rounded up to 10 sec
 s $zt="ENQ10e"
 i CLUBACKUP d  q
 . f  q:$$CLU^SWSET(10,1,ALRDY10,$g(QUIETMASTERONLY))  s t=t-1 zt:'t "Abort" d hibernate(10,'ALRDY10,t)
 i ALRDY10 q:$$quietsw(10)  zt "Abort"
 f  S %SW=10,%VAL=1 D INT^SWSET  q:$$quietsw(10)  s t=t-1 zt:'t "Abort" d DEQ10,hibernate(10,1,t)
 Q
ENQ10e s $zt="" d DEQ10 ztrap $ze
DEQ10 ;
 i CLUBACKUP,$ZU(95,10,0)  ; Clear SW10 clusterwide
 i 'ALRDY10 s %SW=10,%VAL=0 D INT^SWSET
 Q
ENQ13 ;
 n t s t=$g(quietimeout,60) s:t>0 t=(t+9)\10 ;rounded up to 10 sec
 s $zt="ENQ13e"
 i CLUBACKUP d  q
 . f  q:$$CLU^SWSET(13,1,ALRDY13)  s t=t-1 zt:'t "Abort" d DEQ13,hibernate(13,'ALRDY13,t)
 i ALRDY13 q:$$quietsw(13)  zt "Abort"
 f  S %SW=13,%VAL=1 D INT^SWSET  q:$$quietsw(13)  s t=t-1 zt:'t "Abort" d DEQ13,hibernate(13,1,t)
 Q
ENQ13e s $zt="" d DEQ13 zq 1 g:$zt'="" @$zt q
DEQ13 ;
 i CLUBACKUP,$ZU(95,13,0)  ; Clear SW13 clusterwide
 i 'ALRDY13 s %SW=13,%VAL=0 D INT^SWSET
 Q
HOLDWD(dir,time,flag) ;suspend write daemon (dir may be passed as an array)
 n n
 i $zu(182,1,0) ;clear any remaining backup request
 f  q:'$zu(182,0)  h 1  ;wait until write daemon runs again
 i $d(dir)<10 d $zu(52,9,dir,1) d:$g(flag)=1 $zu(52,8,dir,0) d $zu(182,2,0,+$zu(49,dir)) s n=1 i 1
 e  s dir="" f n=0:1 s dir=$o(dir(dir)) q:dir=""  d $zu(52,9,dir,1) d:$g(flag)=1 $zu(52,8,dir,0) d $zu(182,2,n,+$zu(49,dir))
 i $zu(182,1,n,$g(time))  ;set number of databases to back up (and optional CP wait time)
 f  q:$zu(182,0)  h 1  ;wait until write daemon suspends
 q
FREEWD ;unsuspend write daemon
 i $zu(182,1,0)
 q
msgout(aaamess,flag) ;
         s flag=$g(flag,1) ; default to FORCE
         W *-1            ;Flush the input buffer 
         q:'$L(aaamess)   ; Avoid argumentless writes...
         i $g(logfile)'="" u logfile w aaamess
         u 0
         q:flag=3  ; 1 = FORCE, FORCE, 2 = NOFORCE, 3 = LOGONLY
         i '$G(INTERNAL,0)!('$G(NOINPUT,0)&(flag=1!'$G(QUIET,0))) w aaamess
         i $g(gui) D  
         . s return=$$IjcMsg^%Wprima("DI"_aaamess) ; Retval might =  cancel msg
         . i return="CANCEL" d  
         . . i $$IjcMsg^%Wprima("DI"_$c(13,10)_"Abort received!"_$c(13,10))
         . . zt "Abort"
         u 0 
         q
timestmp(flag) 
         n msg,%TS,%TN
         s msg="TIMESTAMP: "
         s %DN=+$H d INT^%DO
         s msg=msg_%DS
         s %TN=$P($h,",",2) d ^%TO
         s msg=msg_" "_%TS
         d msgout($c(13,10)_msg_$c(13,10))
         q
OSDEVICE(mdevice,new) ;osdevice + range check, pad input, strip output.
 s mdevice=+mdevice q:mdevice<47 ""  q:mdevice>62 ""
 i $d(new) s new=$$zpad(new,32)
 q $$zstrip($$osdevice(mdevice,.new))
osdevice(mdevice,new) ;"Raw" osdevice
 n adr,old,size,where,charsize
 s $ZT="osdeverr"
 s charsize=$$charsize^%Wprim() ; check size one char
 s size=32,adr=(mdevice-47)*(size*charsize)+$ZU(40,2,28),where=-2
 s old=$v(adr,where,-size_"w")
 i $d(new) v adr:where:-size_"w":new
 q old
osdeverr q ""
zstrip(x) ;Return x with ASCII NUL's removed
 q $tr(x,$c(0),"")
zpad(x,len) ;x, maybe truncated, NUL-padded to length len, one NUL guaranteed
 n zeroes
 s zeroes=$j("",len),zeroes=$tr(zeroes," ",$c(0)) ;String of len NUL's
 s x=$e(x,1,len-1) ;Silently truncate x if necessary
 s $e(zeroes,1,$l(x))=x
 q zeroes
ZU(A,B,C,D,E,F,G,H,I,J,K,L,M,N,P) ;so needn't change $$ZU's to $ZU's
 IF '$D(B) Q $ZU(A)
 IF '$D(C) Q $ZU(A,B)
 IF '$D(D) Q $ZU(A,B,C)
 IF '$D(E) Q $ZU(A,B,C,D)
 IF '$D(F) Q $ZU(A,B,C,D,E)
 IF '$D(G) Q $ZU(A,B,C,D,E,F)
 IF '$D(H) Q $ZU(A,B,C,D,E,F,G)
 IF '$D(I) Q $ZU(A,B,C,D,E,F,G,H)
 IF '$D(J) Q $ZU(A,B,C,D,E,F,G,H,I)
 IF '$D(K) Q $ZU(A,B,C,D,E,F,G,H,I,J)
 IF '$D(L) Q $ZU(A,B,C,D,E,F,G,H,I,J,K)
 IF '$D(M) Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L)
 IF '$D(N) Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L,M)
 IF '$D(P) Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
           Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L,M,N,P)
MORE Q

DBACKP^INT^1^67214,47330
DBACKP ; Part one of Incremental Backup ;$Change: 6243835 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 N QUIET,logfile,INTERNAL,NOINPUT,OK
 n BUWARNING
 n quietimeout s quietimeout=60
 S NOINPUT=0   ; Enable input from the user
 S QUIET=0     ; Turn off quiet mode
 S INTERNAL=0  ; We did not come in through the BACKUP entry point
 q
 ;
DEFVARS ; This is the tag used by the 'external' entry point as it has
 ;   already loaded the above variables with its own values...
 i '$SYSTEM.Security.Check("%Admin_Operate","USE") {
 	d msgoutb($C(7)_$C(13,10)_"Operation requires %Admin_Operate:Use privilege, [Backup failed.]",FORCE)
	s OK=$system.Status.EmbedStatus($$Error^%apiOBJ(7341),$$Error^%apiOBJ(921,"%Admin_Operate"_":"_"USE"))
	q	 
 }
 i ##class(%Library.File).DirectoryExists(outdev),'##class(%Library.File).RemoveDirectoryTree(outdev) {
     d msgoutb($c(13,10)_"Failed to delete directory "_outdev_" before reuse.",NOFORCE) 
     s OK=$system.Status.EmbedStatus($$Error^%apiOBJ(7341),$system.Status.EmbedStatus($$Error^%apiOBJ(7343,outdev),%objlasterror))
     q
 }
 i '##class(%Library.File).CreateDirectoryChain(outdev) { ;boolean return
     d msgoutb($c(13,10)_"Failed to create directory "_outdev,NOFORCE) 
     s OK=$system.Status.EmbedStatus($$Error^%apiOBJ(7341),$$Error^%apiOBJ(7318,outdev))
     q
 }
 i $g(logfile)="" s logfile=##class(%Library.File).NormalizeFilename("backup.log",outdev) 
 d OpenNewLogfile
 i 'OK {
   s OK=$system.Status.EmbedStatus($$Error^%apiOBJ(7341),$s(OK=0:$$Error^%apiOBJ(7300,logfile),1:OK))
   q
 }
 N %ST,GARCUR,GARNEXT,WDTOP
 N FULL,PARTIAL,NOCHANGE,CLEAR,DELETE,CLOSE,RESTART,CNTINU
 N CUMINC,DIRNAM,LOST,BEGTIME,%SW,%VAL
 N INLOGOR,IBUPass,INC,IND,INE,INF,NoErr
 N BUTYP,DIR,RC,NUMPASS,VOLDIR,DEV,I,MaxPASS
 N ibEOT,ibOfflin,ibDevFul,ibInErr,ibOutErr,ibNoIND,ibNoDAT
 N FORCE,NOFORCE,LOGONLY                                     
 N DIRMNT,ALRDY10,ALRDY13                                
 n i,x,y,stat,markid,marktx,markinfo
 n mirrorid,MIRDBINFO  ;used when back is run on a failover mirror member
 n PREVMNT ; Set if we mounted the backup tape
 s PREVMNT=0
 n RCSUCCESS,RCINERR,RCOUTERR,RCMOUNT,RCBADMAP,RCMAPINERR,RCEOT,RCOFFLINE
 n RCDEVFUL,RCOLDFORMAT,RCBADVOLUME,RCENDOFVOL,RCENDOFVOLSET,RCDIRLABELRECORD
 n RCDIRLABELMISSING,RCINERRLABELGOOD,RCBADRECORDONCOPY,RCBADRECORDONRESTORE
 n RCMISSINGBLKS,RCBLKSIZE,RCOUTCLUMNT,RCMAPERR,A,a,VOL,TYPE,DELIM
 n %DN,%DS,%TN,%TS,ANS,DEVMNT,L,LASTDATE,LASTFDATE,LASTFDEV
 n LASTFTIME,LASTHDATE,LASTHFULL,LASTTIME,LASTTYPE,PREVDEV,delerr
 n BACKHDATE,BUFCOUNT,DATE,FN,LastPass,PASS,SIMLABEL,TIME,Y,status,success
 n dlmlock  ;for getLock()
 n DIRNAMSAV,manifest
 D INITVARS
 S $ZE=""
 k ze
 ; see if switch 10 is already raised.  If so, leave it
 ; set for the duration of this code
 s ALRDY10=$$CHECK10                                       
 s ALRDY13=$$CHECK13                                       
 s status=$$getLock(.dlmlock)
 i 'status {
   d closelog 
   s OK=$system.Status.EmbedStatus($$Error^%apiOBJ(7341),$$Error^%apiOBJ(7356,$P(status,"^",2))) 
   q
 }
 S $ZT="ERR1"
 d ##class(Backup.General).ClearAbortStatus()
 d msgoutb($C(13,10)_$C(13,10)_$C(13,10)_"*** The time is: "_$zdt($h,3)_" ***",NOFORCE)
 d msgoutb($C(13,10)_$C(13,10)_"              "_"InterSystems IRIS"_" Backup Utility",NOFORCE)
 d msgoutb($C(13,10)_"              --------------------------------",NOFORCE)
 i $$ZU(32,5)  ;free any existing memory
 S $ZT="ERR"
 I ALRDY13 S $ZE="Switch 13 must be clear to run DBACK" G ERR 
 D GETTYP 
 I 'OK { ;expecting an error status in 'OK'
   do releaseLock(.dlmlock),closelog 
   s OK=$system.Status.EmbedStatus($$Error^%apiOBJ(7341),OK) 
   q
 }
 s mirrorid=$$LookupMirrorInfo() ;<mirname>:<mir guid> if a failover member
MAIN ;
 ; Get info for last full backup
 S LASTHFULL=$G(^SYS("BACKUP","LASTFULL","DATE"))
 S LASTFDEV=$G(^SYS("BACKUP","LASTFULL","DEVICE"))
 D CONVDATE(LASTHFULL,.LASTFDATE,.LASTFTIME)
 ; Get info for last backup of any kind
 d ConvHistDate
 n LASTHDATENUM
 S LASTHDATENUM=$ZP(^SYS("BACKUP","HISTORY",""))
 S LASTHDATE=$S(LASTHDATENUM:((LASTHDATENUM\1000000)_","_(LASTHDATENUM#1000000)),1:"")
 S LASTTYPE=$S(LASTHDATENUM:$G(^SYS("BACKUP","HISTORY",LASTHDATENUM,"TYPE")),1:"")
 i LASTHDATE<LASTHFULL
 e  i +LASTHDATE=+LASTHFULL,$p(LASTHDATE,",",2)<$p(LASTHFULL,",",2) 
 i  d
 .  ; Last backup was a full backup, so use its data
 . S LASTTYPE=$G(^SYS("BACKUP","LASTFULL","TYPE"))          
 . s:LASTTYPE="" LASTTYPE="Full"   ; Version compatibility  
 . S LASTHDATE=LASTHFULL
 D CONVDATE(LASTHDATE,.LASTDATE,.LASTTIME)
 n savoutdev s savoutdev=outdev ;outdev and DEV may be "" in GETDEV
 D GETDEV 
 I 'OK {
   do releaseLock(.dlmlock),closelog 
   s OK=$system.Status.EmbedStatus($$Error^%apiOBJ(7341),$$Error^%apiOBJ(7357,savoutdev)) 
   q
 }
 s DESCRIPTION=$E(DESCRIPTION,1,250)
 d msgoutb($C(13,10)_"Description"_$C(13,10),LOGONLY)
 ; d msgoutb("DESCRIPTION"_$$$CRLF,LOGONLY)
 d msgoutb(DESCRIPTION_$C(13,10),LOGONLY) ; DAH029
 D GETDIRS   
 I 'OK {
   d releaseLock(.dlmlock),closelog 
   s OK=$System.Status.EmbedStatus($$Error^%apiOBJ(7341),OK) 
   q  
 }
 I $d(DIRNAM)<10 {
   d msgoutb($C(13,10)_"Nothing to Backup"_$C(13,10),FORCE)
   d releaseLock(.dlmlock),closelog 
   s sc=$$REASONtoStatus(.REASON)
   s OK=$System.Status.EmbedStatus($$Error^%apiOBJ(7341),$System.Status.EmbedStatus($$Error^%apiOBJ(BkpNoDB),sc)) 
   q  
 }
 s OK=1 
 ; switch journal files
 d JRNCHECK  ;switch local journal file
 s VOL=1
 d GetJournalInfo()
 ; Get date/time for this backup
 s BACKHDATE=$H D CONVDATE(BACKHDATE,.DATE,.TIME)
 n NumberWorkers,queue
 s NumberWorkers=$g(^SYS("BACKUP","NumberWorkers"),8)
 s queue=$system.JobMgr.%New($g(NumberWorkers)) 
 i queue="" {
   d releaseLock(.dlmlock),closelog 
   s OK=$System.Status.EmbedStatus($$Error^%apiOBJ(7341),%objlasterror)
   d $zu(9,"","unable to instantiate JobMgr object") 
   q
 }
 s manifest=$zu(12,DEV_"/manifest.json",0)
 m DIRNAMSAV=DIRNAM ;dbname needed for creating manifest in the end
 s DEVDIR=DEV
 s DIR="" f {
   s DIR=$o(DEV(DIR),1,DEV) ;DEV to be used by VOLLABEL
   i DIR="" q
   s DIRNAM(DIR)=+DIRNAM(DIR)
   D VOLLABEL ; output volume label w/ directory names 
   d $zu(32,9,DIRNAM(DIR)) ;save obstr info for other jobs (same vollabel)
   d $zu(32,5)
   i 'OK { ;error status from VOLLABEL
     k DIRNAM(DIR),DEV(DIR)
     s REASON(DIR)=OK
     s OK=1 ;continue to other databases
   }
 }
 s DEV=DEVDIR ;DEV is recorded in the "DEVICE" node by POSTPROC and SETHISTORY 
 i $d(DIRNAM)<10 { ;no database to back up
   d releaseLock(.dlmlock),closelog 
   s sc=$$REASONtoStatus(.REASON)
   s OK=$System.Status.EmbedStatus($$Error^%apiOBJ(7341),$System.Status.EmbedStatus($$Error^%apiOBJ(7365),sc)) 
   q
 }
 s LastPass=0 F PASS=1:1 D PASS Q:'OK!LastPass
 I 'OK g ERR
 D POSTPROC ;set up 'OK' (return status) based on result from PASS
 do releaseLock(.dlmlock)
 i OK=1 {
   d msgoutb($C(13,10)_"Backup complete."_$C(13,10),FORCE)
 } elseif +$system.Status.GetErrorCodes(OK)=$system.Status.GetErrorCodes($$Error^%apiOBJ(7341)) {
   d msgoutb($C(13,10)_"Backup failed."_$C(13,10),FORCE)
 } else {
   d msgoutb($C(13,10)_"Backup failed for some databases."_$C(13,10),FORCE)
 }
 do closelog
 Q
OpenNewLogfile ;
 i $g(logfile)="" {
   s OK=$$Error^%apiOBJ(7300,logfile)
   q
 }
createlog ;input: logfile; return: set OK to 0 or 1
 s OK=1
 s oldmask=##class(%Library.File).SetUMask((64+8+7))
 o logfile:"WNS":5 ;new file mode
 i '$t {
   d msgoutb($C(13,10)_"Error creating log file "_logfile_$C(13,10),FORCE)
   s OK=$$Error^%apiOBJ(7300,logfile),logfile=""
 }
 d ##class(%Library.File).SetUMask(oldmask) ;restore previous umask
 q
openlog ;input: logfile; return: set OK to 0 or 1
 s OK=1
 i logfile="" q
 o logfile:"WAS":5 ;to append to an existing file
 i '$t {
   d msgoutb($C(13,10)_"Error opening log file "_logfile_$C(13,10),FORCE)
   s OK=$$Error^%apiOBJ(7300,logfile),logfile=""
 }
 q
closelog ;
 i $g(logfile)'="" c logfile s logfile=""
 q
INITVARS ; Initialize.
 D:$D(%ST)<11 ^ST                                     
 S DEV=""
 s VOL=1 ; GETDEV needs this
 d initconstants
 Q
LookupMirrorInfo() {
 ; returns <mirname>:<MIRROR GUID>:
 ;               <Our Mirror System Guid>:<Our mirror system name>
 ; if we're a failover mirror member or 
 ;         ::<our async system guid>:<our mirror system name>
 ; if we're a NULL if we're a reporting (async) member or
 ; NULL if we're not a mirror member. 
 ;
 ; Backups on failover members contain the mirror name in the 
 ; volume header where as backups on non-failover members
 ; don't
 s retstr=""
 s cls=##class(Config.MirrorMember).Open(,,.rc)
 if '('rc) {
	 s reportingNode=cls.isAsyncMember()
	 if reportingNode {
		s ourname=cls.SystemName
		s ourguid=cls.GetAsyncMemberGUID()
		s cls=""
		; ':' is the seperator because it can't be present
		; within any of the fields. For reporting nodes the mirname
		; and mirguid are null. 
		s retstr="::"_ourname_":"_ourguid
	 } else {
	    s validmember=cls.ValidatedMember
	    if validmember {
			s cls=""
			s mirname=##class(Config.Mirrors).GetMirrorName()
			s cls=##class(Config.Mirrors).Open(mirname,,,.rc)
			if '('rc) {
				s mirguid=cls.GUID
				; id #0 is always the information for the local node
				s info=$G(^SYS("MIRRORSET",mirname,"Member",0))
				s ourname=$LG(info,1)
				s ourguid=$LG(info,2)
				; ':' is the seperator because it can't be present
				; within any of the fields
				s retstr=mirname_":"_mirguid_":"_ourname_":"_ourguid
			}
	    }
	 }
 }
 s cls=""
 quit retstr
}
getLock(dlmlock) ;
 L +^DBACK:1 E  quit "0^another process on this node holds the DBACK lock"
 n bckjob s bckjob=$zu(182,3,1) 
 i bckjob<=0 { ;likely to have been set by ExternalFreeze
   d releaseLock(.dlmlock) ;OK to call $zu(182,3,0) as it would do nothing
   q "0^a backup (job #"_(-bckjob)_") on this node is in progress"
 }
 i $zu(182,1) {
   d releaseLock(.dlmlock)
   q "0^an external backup on this node is in progress"
 }
 q 1  ; succeeded
releaseLock(dlmlock)
 i $zu(182,3,0)
 l -^DBACK
 if $s($S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0):''$zu(59,0),1:0),$l($G(dlmlock)) do dlmlock.release() s dlmlock=""
 d ##class(Backup.General).ClearAbortStatus()
 q ;
CONVDATE(IN,DATE,TIME) i IN="" S DATE="",TIME="" q
 s %DN=+IN,%TN=+$P(IN,",",2)
 I '%DN s %DS="",%TS=""
 E  D ^%DO,^%TO
 s DATE=%DS,TIME=%TS
 Q
SWSET   do $SYSTEM.Util.SetSwitch(%SW,%VAL)
	quit
SET10   do $SYSTEM.Util.SetSwitch(10,1)
        quit
CLEAR10 do $SYSTEM.Util.SetSwitch(10,0) 
        quit
CHECK10() n res
	s res=$SYSTEM.Util.GetSwitch(10)
	if '+res quit 0  ; not owned
	if +$P(res,",",2)'=+$J quit 0  ; not owned by us
	quit 1  ; set and owned by us
CHECK13() ;
 quit $SYSTEM.Util.GetSwitch(13)
ERR S $ZT="ERR1" 
 s ze=$ze 
 s zemsg="Backup failed"
 i ze'="" s zemsg=zemsg_", ERROR: "_ze
 s zemsg=zemsg_", see "_$g(logfile)_" for more details"
 d $zu(9,"",zemsg,1 /* broadcast and log message*/,2  /* Severe error */)
 s OKsav=OK s OK=1
 s OK=$System.Status.AppendStatus(OKsav,OK)
 h 20 ; Allow monitor to see the error
ERR1 S $ZT=""
 do releaseLock(.dlmlock)
 do closelog
 i $g(ze)'=$ze {
	 i $g(ze)'="" {
		d msgoutb($C(13,10)_ze,FORCE)
		d $zu(9,"","Backup failed, ERROR: "_ze_", see "_$g(logfile)_" for more details",1 /* broadcast and log message*/,2  /* Severe error */)
	 }
	 s ze=$ze
 }
 D FREEWD
 D DEQ10
 D DEQ13
 If $d(BUTYP),$d(TYPE),$d(DESCRIPTION) d SETHISTORY($s(##class(Backup.General).GetAbortStatus():-1,1:0))
 d msgoutb($C(13,10)_ze,FORCE)
 d msgoutb($C(7)_$C(13,10)_"[Backup failed.]",FORCE)
 i $g(ze)'="" s OK=$$Error^%apiOBJ(5002,ze)
 s OK=$system.Status.EmbedStatus($$Error^%apiOBJ(7341),$g(OK))
 q OK
MARKJRN ;
 s markinfo=$$ADD^JRNMARK(-1,DATE_";"_TIME_";"_TYPE)
 i markinfo'>0 d msgoutb($C(13,10)_"Error setting journal marker: "_$p(markinfo,",",2,$l(markinfo))_$C(13,10)) s OK=$$Error^%apiOBJ(7307) i 1
 e  d msgoutb($C(13,10)_"Journal marker set at"_$C(13,10)_"offset "_$p(markinfo,",")_" of "_$p(markinfo,",",2)_$C(13,10))
 q
 ;
TIME(a,b) q (a-b*24*3600)+$p(a,",",2)-$p(b,",",2)
 ;
UP(C) Q $zcvt(C,"u")
 ;-------------------------------------------------------------------
 ; EXTERNAL ENTRY POINTS
 ; These are for use by 'external' backup procedures and must be
 ;   used in the order and manner for which they were intended or
 ;   InterSystems will not be able to guarentee the integrity of
 ;   a backup.
 ; All of these entry points return 1 if they are successful or 0 if
 ;   they fail.  Note that this differs from the standard for crossing
 ;   the M/SQL-DCL boarder of 3 for failure and 5 for success generated
 ;   with ZU 4:<ret status>
 ;-------------------------------------------------------------------
LISTDIRS(file,mode) ;
 ; This procedure takes a file name and a mode. See DBACKB for more info
 g LISTDIRSDBACKB
CLRINC(mode) ;
 ; This procedure clears the incremental backup bits. See DBACKB for more info
 g CLRINCDBACKB
 ;---------------------------------------------------------------
 ; Cache Version 7.1 BACKUP NOTES/CHANGES
 ; Starting with this version the meaning of the following parameters
 ; has changed somewhat. Due to changes in the journaling mechanism, it is no
 ; longer possible to delete the current journal file, clear the current journal
 ; file, or specify a new journal file name. See the documentation below on
 ; how the behavior has changed.
 ; 
 ; The following procedure invokes a backup using the passed
 ;  arguments to satisfy the questions that are normally asked
 ;  of the user.
 ;
 ;Argument description:
 ; argfile - Values- NULL - take arguments from the argument list
 ;                   <filename> - read arguments from this file
 ;                              - all arguments must be specified
 ;                   NOTE: This argument will be removed in
 ;                         V5b0-9010. See MBACKUP.COM for a discussion
 ;                         of the whys/wherefores (search for 'ofile')
 ;    type - Values-  'I'ncremental
 ;                    'C'umlative incremental
 ;                    'F'ull
 ;                    'E'xternal full backup (mumps up or down)
 ;
 ;    desc - Values - Free form text string, may be NULL
 ;           This is stored in the backup label and in the history
 ;               global and describes the backup
 ;
 ;The following are ignored (and not requried) for backups of type="E"
 ;
 ;  outdev - Values - Where the backup should be sent to:
 ;               Magtape device
 ;               RMS File name
 ;
 ;*******THE MEANING OF THIS PARAMETER HAS CHANGED***********************
 ;  kiljrn - Required (except type="E")
 ;       PREVIOUSLY:
 ;           Values - "Y" delete the journal after backup
 ;                    "N" do NOT delete the journal after backup
 ;                    PH028: Note, when kiljrn is set to "Y", then
 ;                           clrjrn and swjrn are ignored
 ;       CURRENTLY:
 ;           Values - "Y" Switch the journal file after backup
 ;                    "N" ignored
 ;
 ; logfile - Required (ignored if type="E")
 ;           Values - NULL = no log file
 ;                    RMS file name = Send a copy of all messages which
 ;                         would be sent to the terminal to this file
 ;
 ;    mode - Required (ignored if type="E")
 ;       Two piece value delimited by "," where the first piece is one of the following:
 ;           Values - "NOISY" - Default, print all text on terminal
 ;                    "QUIET" - Only display text related to abnormal
 ;                                  conditions
 ;                    "NOINPUT" - No terminal is attached to this
 ;                             process. No output will be sent to
 ;                             the terminal and if a read must be
 ;                             executed the backup is aborted.
 ;                             It is advisable to have a log file.
 ;             NOTE: This switch only affects what is displayed
 ;                   at the terminal, the logfile is always
 ;                   'NOISY'
 ;        The second piece if passed can be = 1 which means that the database backup list
 ;        in ^SYS("BACKUP","DIRECTORIES") has been set by an external call, and to not copy and use the
 ;        predefined list in ^SYS("BACKUPDB")
 ;*******THE MEANING OF THIS PARAMETER HAS CHANGED**********************
 ;    clrjrn - Required
 ;       PREVIOUSLY:
 ;            Values - "Y" - Clear the journal file after backup and
 ;                           swjrn will be ignored.
 ;                     "N" - Do not switch the journal file.
 ;       CURRENTLY:
 ;            Values - "Y" - Switch the journal file.
 ;                     "N" - ignored
 ;*******THE MEANING OF THIS PARAMETER HAS CHANGED**********************
 ;    swjrn  - Required
 ;       PREVIOUSLY:
 ;            Values - "Y" - Switch the journal file after backup
 ;                     "N" - Do not switch the journal file.
 ;       CURRENTLY:
 ;    swjrn  - Required
 ;            Values - "Y" - Switch the journal file after backup
 ;                     "N" - Do not switch the journal file. Note that this
 ;                           is overridden if clrjrn or kiljrn is "Y"
 ;*******THE MEANING OF THIS PARAMETER HAS CHANGED**********************
 ;       PREVIOUSLY:
 ;    nwjrnfil - Required
 ;            Values - NULL - If swjrn is "N"
 ;                   - RMS file specification for the new journal
 ;                     file.
 ;       CURRENTLY:
 ;                 This parameter is now ignored
 ;    quietimeout - Optional (default = 60)
 ;            # of seconds to wait for system to quiesce before aborting backup
 ;            0 or negative # = wait indefinitely
 ;    taskname - passed by Backup.General.StartTask() when the backup is
 ;               jobbed off and quietmode is 1 meaning that we're not called
 ;               from BACKUP^Wsback (eg. a GUI driven backup). In this case
 ;               we need to update the task status here before exiting. Only
 ;               evaluated for backup types F, I and C. 
 ; NOTES:
 ;    Requires read/write access to the SYS global (all modes)
 ;    Mode 'E' causes the .IND, .INE and .INF files in the 
 ;            directories in the SYS global to be deleted.
 ;            The only other action taken is to record this backup
 ;            along with the description in the history global
 ;            as being the LASTFULL backup.
 ;    If SWITCH 10 or 13 is set when this routine is called they
 ;        remain set throughout the backup.  If switch 13 is set then
 ;        it will be converted into a switch 10 since backup needs
 ;        to do sets/kills.  It will be restored upon exit.
 ;    Variables defined by this entry point are NEWed but those
 ;        defined within the body of the DBACK procedure are not.
 ; return value: 0 - failed. Check log file if specified.
 ;               1 - Success.
 ;               1,warning message string - Success but with some warnings.
 ;                 The warnings are separated by ~ in the string.
BACKUP(argfile,EXTTYP,DESCRIPTION,outdev,kiljrn,logfile,mode,clrjrn,swjrn,nwjrnfil,quietimeout,taskname) 
 s taskname=$G(taskname)
 s quietimeout=+$g(quietimeout,60)
 s:'quietimeout quietimeout=60
 New (argfile,EXTTYP,DESCRIPTION,outdev,kiljrn,logfile,mode,clrjrn,swjrn,nwjrnfil,quietimeout,taskname,%qdev,%qserveroptions)
 s CLUBACKUP=0 ;used in DEQ10/13
 s alias=$s(($i?.N)&&($p($zu(91,$i),",",3)'=""):$p($zu(91,$i),",",3),1:$i)
 i ($zversion(1)=2),($e(alias,1,7)="//./nul") s $p(mode,",",1)="NOINPUT"
 i ($zversion(1)=3),($e(alias,1,9)="/dev/null") s $p(mode,",",1)="NOINPUT"   ;STC2275-
 S $ZT="BCKERR"
 i '$SYSTEM.Security.Check("%Admin_Operate","USE") {
 	w !,"Operation requires %Admin_Operate:Use privilege"
 	d $zu(9,"","Backup failed: Operation requires %Admin_Operate:Use privilege",1 /* broadcast and log message*/,2  /* Severe error */)
	q $system.Status.EmbedStatus($$Error^%apiOBJ(7341),$$Error^%apiOBJ(921,"%Admin_Operate"_":"_"USE"))
 }
 s gui=0 ; If called from client mode="GUI"
 i $g(mode)="GUI" s mode="NOISY" s gui=1
 D INITVARS              ; Set up some variables for backup...
 S NOINPUT=1,QUIET=1,INTERNAL=1
 S OK=1
 i argfile'="" d  i 'OK q 0   ; signals an error condition
 . o argfile:"R":5
 . e   w !,"Error opening argument file ",argfile,! s OK=0 q
 . u argfile
 . r EXTTYP,DESCRIPTION,outdev,kiljrn,logfile,mode,clrjrn,swjrn,nwjrnfil
 . c argfile
 s EXTTYP=$$UP($E(EXTTYP))
 i "EFCI"'[EXTTYP d   q 0   ; Signal an error
 . W *7,*7,!,"Invalid backup type - ",EXTTYP,!,*7,*7
 S SW10SET=$$CHECK10                                           
 S SW13SET=$$CHECK13
 ;      If switch 13 is set then we need to convert it to switch 10
 ;      to play with globals. 
 I SW13SET D                                                   
 . S %SW=10,%VAL=1 D INT^SWSET        ; Set switch 10
 . S %SW=13,%VAL=0 D INT^SWSET        ; Clear switch 13        
 i $L($g(mode),",")=1 s OK=$$InitDirList0 i 'OK s $ZE="" g BCKERR
 s alldb=+$p($g(mode),",",2)
 i EXTTYP="E" { ;##class(Backup.Online).FinishExternalBackup()
   S ^SYS("BACKUP","LASTFULL","DATE")=$H    ; Record date/time
   S ^("DESC")=$G(DESCRIPTION)
   S ^("TYPE")="External Full"                   ; Just so we know   
   S ^("LOG")=$G(logfile)
   s BACKHDATE=^SYS("BACKUP","LASTFULL","DATE")
   s BUTYP=5,TYPE="External Full",DEV=$G(outdev)
   D SETHISTORY(1)
   I SW13SET  S %SW=13,%VAL=1 D INT^SWSET  ; Set switch 13  
   I 'SW10SET S %SW=10,%VAL=0 D INT^SWSET  ; Clear switch 10
   s DIR="" F  {
     S DIR=$O(^SYS("BACKUP","DIRECTORIES",DIR)) q:DIR=""
     s zu49=+$ZU(49,DIR)  ;KMK106
     i (zu49=-2)||(zu49=-3) {
       s REASON(DIR)=$$Error^%apiOBJ(7344,DIR,zu49)
       continue
     }
     ; Only process directories which exist
     S D=$ZU(12,DIR)  ; Just incase is a logical w/o ":" 
     ;Clear force full back flag, it assumes full back has been done for BACKUP("","E")
     D $zu(52,9,DIR,0)
     D SetNames(D)       
     s RC=$$INLOGOR(D,2,2,1)
     i RC<0 {
       s REASON(D)=$s(+RC=-1:$$Error^%apiOBJ(7345,D,$p(RC,",",2)),1:$$Error^%apiOBJ(7346,D,RC))
       continue
     }
     s RC=$$INLOGOR(D,1,1,1)
     i RC<0 {
       s REASON(D)=$s(+RC=-1:$$Error^%apiOBJ(7345,D,$p(RC,",",2)),1:$$Error^%apiOBJ(7346,D,RC))
       continue
     }
     s RC=$$INLOGOR(D,0,0,1)
     i RC<0 {
       s REASON(D)=$s(+RC=-1:$$Error^%apiOBJ(7345,D,$p(RC,",",2)),1:$$Error^%apiOBJ(7346,D,RC))
       continue
     }
     s SUCCESSDIR(D)=""
   }
  ; Record the list of databases which are being backed up this time
  ; to compare with what we use next time 
   k ^SYS("BACKUP","LASTDIRECTORIES")
   m ^SYS("BACKUP","LASTDIRECTORIES")=SUCCESSDIR
   i '$d(REASON) q 1 ;success, no error
   s tsc=$$REASONtoStatus(.REASON)
   i $d(SUCCESS) { ;partial failure or success
     q $system.Status.EmbedStatus($$Error^%apiOBJ(7340),tsc)
   }
   q $system.Status.EmbedStatus($$Error^%apiOBJ(7341),tsc) ;all failed
 }
 ;
 ; EXTTYPE="C", ="F" or "I". Invoke DEFVARS to run the backup
 ;
 I SW13SET  S %SW=13,%VAL=1 D INT^SWSET    ; Set switch 13
 I 'SW10SET S %SW=10,%VAL=0 D INT^SWSET    ; Clear switch 10
 i 'OK q 0 ;this line is probably redundant
 s INTERNAL=1                 ; Flag that this is from here         
 s mode=$$UP($E(mode,1,4))
 S QUIET=0          ; Turn off quiet mode
 S NOINPUT=0        ; Flag that we do have an input device
 I mode="QUIE" s QUIET=1  ; quiet mode
 I mode="NOIN" s QUIET=1,NOINPUT=1 ; quiet mode & no input
 D DEFVARS  ;Invoke the dback procedure, which returns status in 'OK'
 I SW13SET D                                                   
 . S %SW=10,%VAL=1 D INT^SWSET        ; Set switch 10
 . S %SW=13,%VAL=0 D INT^SWSET        ; Clear switch 13        
 if $L(taskname) {
	 ; When taskname is passed this is a jobbed backup from
	 ; Backup.General.StartTask() and we need to update the
	 ; task status before exiting.
	 s P10=taskname
	 s return=OK
	 d SetStatus^Wsback
 }
 i $g(logfile)'="" c logfile
 I SW13SET  S %SW=13,%VAL=1 D INT^SWSET       ; Set switch 13 
 I 'SW10SET S %SW=10,%VAL=0 D INT^SWSET       ; Clear switch 10
 n dir s dir="" f  s dir=$o(bkpmount(dir)) q:dir=""  i $zu(3,dir)
 q OK      ; Ok contains the exit status (0=fail, 1=success)
BCKERR s $ZT="" 
 k ze 
 s zemsg="Backup failed"
 i $ZE'="" {
   s ze=$ZE 
   i 'QUIET w !,$ZE
   s zemsg=zemsg_", ERROR: "_$ZE
 }
 s zemsg=zemsg_", see "_$g(logfile)_" for more details"
 d $zu(9,"",zemsg,1 /* broadcast and log message*/,2  /* Severe error */)
 i 'QUIET w !
 if $L(taskname) {
	 ; When taskname is passed this is a jobbed backup from
	 ; Backup.General.StartTask() and we need to update the
	 ; task status before exiting.
	 I ($$CHECK13) {                                                   
	    ;Convert to switch 10 so we can update globals
	    S %SW=10,%VAL=1 D INT^SWSET        ; Set switch 10
 		S %SW=13,%VAL=0 D INT^SWSET        ; Clear switch 13        
	 }
	 s ^SYS("BACKUP","LastError")=logfile_","_$ZE
	 s P10=taskname
	 s return=0 ; failure status
	 d SetStatus^Wsback
 }
 if $l($g(logfile)) {
	 s IO=$I 
	 o logfile:"WAS":5
	 if $T {
	    u logfile 
	    w !,"Unexpected error: ",$ZE 
	    c logfile 
	 }
	 u IO
 }
 I SW13SET  S %SW=13,%VAL=1 D INT^SWSET       ; Set switch 13  
 I 'SW10SET S %SW=10,%VAL=0 D INT^SWSET       ; Clear switch 10
 n dir s dir="" f  s dir=$o(bkpmount(dir)) q:dir=""  i $zu(3,dir)
 i $g(ze)="" { ;expect error status in 'OK', e.g., from InitDirList()
   q $system.Status.EmbedStatus($$Error^%apiOBJ(7341),$g(OK))
 }
 q $system.Status.EmbedStatus($$Error^%apiOBJ(7341),$$Error^%apiOBJ(5002,ze))
initconstants ;
 S FULL=2,PARTIAL=1,NOCHANGE=0,CLEAR=1,DELETE=2,CLOSE=5,NoErr=1
 s CUMINC=3,DELIM=$c(0)
 S RESTART=4,CNTINU=3,INLOGOR=31,IBUPass=32
 S ibEOT=2,ibOfflin=3,ibDevFul=4,ibInErr=-1,ibOutErr=-2
 S ibNoIND=-3,ibNoDAT=-4
 S MaxPASS=10
 S FORCE=1,NOFORCE=2,LOGONLY=3
 s RCSUCCESS=1   ;success
 s RCINERR=-1    ; General Input error
 s RCOUTERR=-2   ; General output error 
 s RCMOUNT=-4    ; either directory name was too long or we couldn't mount the directory
 ; input errors during backup (in addition to RCINERR)
 s RCBADMAP=-11  ; 2kb: missing incremental bitmaps
 ;big database: Bad label in incremental backup bitmap
 s RCMAPINERR=-13 ; disk error reading incremental backup bitmap
 ;
 ; write errors during backup (in addition to RCOUTERR)
 ;
 s RCEOT=2       ; Output: end of tape or volume
 s RCOFFLINE=3   ; Output device offline
 s RCDEVFUL=4    ; Output: file expansion failed
 ; # 5 no longer used
 ;
 ; input errors during $zu(52,0,device) which opens input volume and reads label
 ; (in addition to RCINERR)
 s RCOLDFORMAT=-6        ; On a restore, Input file has old backup
                         ;file format.  Abort the restore.
 s RCBADVOLUME=-7        ; Input file is not backup file format.
                         ;In general, if we fail during open of input
                         ;device or 1st read of it we get an RCINERR error.
                         ;If the volume block's contents are bad, we
                         ;get either RCBADVOLUME or RCOLDFORMAT
 ; success returns during restore
 s RCENDOFVOL=-10        ; End of input backup volume reached
 s RCENDOFVOLSET=-17     ; End of input backup volume reached and
                         ; this is the last volume
 s RCDIRLABELRECORD=-18  ; reached a directory label record, current
                         ; record is next record
 s RCDIRLABELMISSING=-19 ; we're at a data record for a different
                         ; directory and we should act as if we
                         ; reached a directory label except the
                         ; current record is the first data block of the
                         ; next directory to be restored.  This usually
                         ; is the result of various read errors that
                         ; resulted in missing a directory label record
 ; input errors during restore (during restore, if we get an input
 ; error we usually translate it to something else)
 s RCINERRLABELGOOD=-14  ; We got an error reading a block but
                         ; it passed validation on its label.
                         ; The contents should be reported by the
                         ; utility as suspicious unless we can
                         ; determine that there's a particular
                         ; 1 or more records that fail crc.
                         ; We should then try to restore its contents,
                         ; and we should expect one or more of the
                         ; records in the block to result in
                         ; a RCBADRECORDONRESTORE error.
 s RCBADRECORDONCOPY=-15 ; record in rinbp->ricurr is bad
                         ; It was bad when the backup was originally
                         ; created i.e. we got a read error during
                         ; the backup). Normally the utility
                         ; should save a copy of the block that
                         ; is already in the CACHE.DAT file and
                         ; then restore this block
 s RCBADRECORDONRESTORE=-8 ; record in rinbp->ricurr failed
                         ; CRC validation, probably due to a read
                         ; error during the restore.
                         ; We probably previously got a
                         ; RCINERR_LABELGOOD error on this block.
                         ;  If both _ONCOPY and _ONRESTORE conditions
                         ; are present, we report it as _ONRESTORE.
                         ; Normally the utility should save a copy of the
                         ; block that is already in the CACHE.DAT file and
                         ; then restore this block
 s RCMISSINGBLKS=-16     ; The block # of the last record in the last block
                         ; successfully read from the input media doesn't
                         ; match what this block has in incrlabel_LASTBLKNUM
                         ; and incrlabel_LASTSFN.   We must have skipped
                         ; some blocks (which is probably the result of read
                         ; errors.)
 s RCABORT=-21           ; The backup operation is aborted by user's request.
 ; -9, RCBADLABEL, is no longer used.  If we get an input block
 ; whose label fails validation (e.g. CRC wrong), we act like we
 ; just got an input error
 s RCBLKSIZE=-12 ; record in rinbp->ricurr has the wrong
                 ;block size for this CACHE.DAT file
                 ;If this is the first block for this CACHE.DAT
                 ;then we probably are restoring to the wrong
                 ;CACHE.DAT (one with a different block size),
                 ;and that is a fatal error.  Otherwise it is
                 ;probably a label error and we should skip this
                 ;input block.
 ; other restore errors in $zu(52,1,...) and $zu(52,4)*/
 s RCMAPERR=-5   ; 2kb only: Problem detected between
                 ; source & target map blocks.  This is
                 ; a fatal error in attempting to restore
                 ; to this target file JAO572
 q
ConvHistDate ;
 n idx,nidx s idx=""
 while (1) {
  s idx=$O(^SYS("BACKUP","HISTORY",idx)) q:$l(idx,",")<2
  s nidx=(+idx*1000000+$p(idx,",",2))
  m ^SYS("BACKUP","HISTORY",nidx)=^SYS("BACKUP","HISTORY",idx)
  k ^SYS("BACKUP","HISTORY",idx)
 }
 q
DBACKA ; Part two of Incremental Backup  ;$Change: 6291103 $
ASKSET(prompt,val,backup,help,pattern) ;procedure
 N x,done,def,enahelp,helpavail,backupavail
 s done=0
 s def=$G(val)
 s backup=$G(backup,0) 
 s enabackup=$S(backup=-1:0,1:1)
 s backupavail=$S(backup=1:1,1:0)
 s help=$G(help)
 s enahelp=$S(help="*":0,1:1) ;there might not be any help though
 s helpavail=$s(enahelp&($L(help)!($D(help)>1)):1,1:0)
 if 'enabackup n POP
 s POP=0
 f  d  q:done!POP
 . W !,$G(prompt)
 . w:($X+$L(def))>65 !,?5
 . w:$L(def) " <",def,">"
 . if helpavail!backupavail do
 . . w " [" w:helpavail "?" w:backupavail "^" w "]"
 . w:(($X+$L(def))>75) !,?5
 . W " => " 
 . R x,!
 . if x="^" d  q
 . . if 'enabackup s done=1 q
 . . if backupavail s POP=1 q
 . . w "...backup not available here"
 . if enabackup,x="""^""" s x="^",done=1 q
 . ;
 . if x="?" d  q
 . . if 'enahelp s done=1 q
 . . if 'helpavail w "...help not available here" q
 . . if $D(help)=1 w !?5,help q
 . . s x="" f  s x=$O(help(x)) q:x=""  w !,?5,help(x)
 . . w !
 . if enahelp,x="""?""" s x="?",done=1 q
 . i x]"",$g(pattern)]"",x'?@pattern w !?5,$s(helpavail:help,1:"[bad format]") q
 . s:'$L(x) x=val 
 . s done=1
 s:'POP val=x
 q
 ;
GETDEV ;
 I DEV="",BUTYP=FULL S DEV=$G(^SYS("BACKUP","LASTFULL","DEVICE"))
 I DEV="",LASTHDATE d ConvHistDate S DEV=$G(^SYS("BACKUP","HISTORY",(+LASTHDATE*1000000+$p(LASTHDATE,",",2)),"DEVICE"))
 s DEVMNT=0 ; Gets set if we mount current tape
 ;
 s OK=1                                                        ;JAO264+
 i outdev="" s OK=0 q  ; If no input device, return failure
 s DEV=outdev,outdev="",ANS=""
 s ISREG=1
 S DEV=$$FILENORM(DEV) i 'OK d msgoutb("   "_ERRMSG_$C(13,10),FORCE) q
 s DEV=$ZU(12,DEV)
 i DEV="" s OK=0 q
GETDEV1 I $G(VOL)>1 s OK=0 q  ;shouldn't be here
 i 'OK q
 s PREVDEV=DEV,PREVMNT=DEVMNT
 d msgoutb($C(13,10)_"Backing up to device: "_DEV,NOFORCE)
 Q
GETTYP S TYPE="" ; TR243 fixed
 s a=$TR($E(EXTTYP),"FIC","123")
 s a=$e(a)
 i "123"'[a s TYPE="",BUTYP="" q
 S BUTYP=$S(a=3:CUMINC,a=1:FULL,1:PARTIAL)
 S TYPE=$S(a=3:"Cumulative Incremental",a=1:"Full",1:"Incremental")
 s OK=1                                                       ;JAO265+
 if BUTYP'=FULL {
    if '$D(^SYS("BACKUP","LASTFULL")) {
       set OK=$$Error^%apiOBJ(7353),TYPE="" ;signal failure
       do msgoutb($C(13,10)_$C(13,10)_"You cannot do an Incremental or Cumulative Backup until a Full Backup"_$C(13,10)_"has been performed."_$C(13,10),FORCE)
    } else {
       new d,nobup set (d,nobup)=""
	   new newdirlist,olddirlist,dir,zu49
	   merge olddirlist=^SYS("BACKUP","LASTDIRECTORIES")
       for  {
	       set d=$o(^SYS("BACKUP","DIRECTORIES",d)) 
	       quit:d=""  
	       k olddirlist(d) 
	       s zu49=+$zu(49,d)
	       if zu49'=-2&&(zu49'=-3) {
		       i zu49=-1||(zu49=$zu(40,0,41)) d MNTDIR(d) s zu49=+$ZU(49,d)
		       i zu49'=-1&&(zu49'=$zu(40,0,41)) {
			       s nd=$zu(12,d) ;a la GD1()
			       i ($zu(52,8,d)+$zu(52,9,d)) {
			         s nobup=nobup_d_", "
				 s REASON(d)=$$Error^%apiOBJ(7355,d)
	                         k ^SYS("BACKUP","DIRECTORIES",d)
			       } elseif '$D(^SYS("BACKUP","LASTDIRECTORIES",d))&&((nd'="")&&'$D(^SYS("BACKUP","LASTDIRECTORIES",nd))) {
			         s newdirlist(d)=""
				 s REASON(d)=$$Error^%apiOBJ(7354,d)
	                         k ^SYS("BACKUP","DIRECTORIES",d)
			       }
		       }
	       }
       }
	   if $D(olddirlist) {
	      do msgoutb($C(13,10)_"Below is a list directories which were part of the last backup"_$C(13,10)_"     but are not part of the current backup.",FORCE)
		  s d=""
          f  s d=$O(olddirlist(d)) q:d=""  do msgoutb($C(13,10)_"     "_d,FORCE)
	   }
	   if $D(newdirlist) {
	      do msgoutb($C(13,10)_"Below is a list of to-be-backed-up directories which were NOT part of the last backup",FORCE)
		  s d=""
          f  s d=$O(newdirlist(d)) q:d=""  do msgoutb($C(13,10)_"     "_d,FORCE)
          do msgoutb($C(13,10)_"They will be skipped.",FORCE)
	   }
       if nobup'="" {
          do msgoutb($C(13,10)_$C(13,10)_"Below is a list of directories for which a Full Backup is mandatory:",FORCE)
          for i=1:1:$l(nobup,", ")-1 do msgoutb($C(13,10)_"   "_$p(nobup,", ",i),FORCE)
          do msgoutb($C(13,10)_$C(13,10)_"They will be skipped.",FORCE)
       }
    }
 }
 i '$d(^SYS("BACKUP","DIRECTORIES")) { ;no database to back up
   s OK=$System.Status.EmbedStatus($$Error^%apiOBJ(7365),$$REASONtoStatus(.REASON))
   s TYPE=""
 }
 if 'OK quit
 d msgoutb($C(13,10)_"Performing a "_TYPE_" backup.",FORCE)
 quit
 ;
InitDirList0() ;
 k ^SYS("BACKUP","DIRECTORIES")
 s db="" f  {
   s db=$o(^SYS("BACKUPDB",db)) q:db=""  
   s OK=##class(Config.Databases).Get(db,.p)
   i 'OK q
   s dir=p("Directory")
   s dir=##class(%Library.File).ComputeFullDBDir(dir)
   i dir="" s OK=$$Error^%apiOBJ(5021,p("Directory")) q
   i '##class(%Library.File).DirectoryExists(dir) s OK=$$Error^%apiOBJ(5021,dir) q
   s ^SYS("BACKUP","DIRECTORIES",dir)=db
 }
 q $g(OK,$$Error^%apiOBJ(7323)) 
GETDIRS ;
 n NODIR,MVDIR k DIRNAM S (DIRNAM,NODIR,MVDIR)=0
 n SEV
 S DIR=""
 ;i $$$ISWINDOWS,$e(DEV,*)="\" s DEV=$e(DEV,1,*-1) ;"
 ;i '$$$ISWINDOWS,$e(DEV,*)="/" s DEV=$e(DEV,1,*-1)
 s bckname=##class(%Library.File).GetFilename(DEV)
 i bckname="" s bckname=##class(%Library.File).GetFilename($e(DEV,1,*-1))
 F I=0:0 {
   S DIR=$O(^SYS("BACKUP","DIRECTORIES",DIR),1,dbname) Q:DIR=""
   D GD1(DIR)
   s dir=$zu(12,DIR) ;in lower cases on Windows
   i $g(DIRNAM(dir))="" d $zu(9,"",dir_" bad: "_$System.Status.GetErrorText(REASON(dir))) continue
   s bckdir=$zu(12,DEV_"/"_dbname)
   i '##class(%Library.File).CreateDirectoryChain(bckdir) { ;boolean return
     d $zu(9,"","Error creating directory "_bckdir)
     d msgoutb($c(13,10)_"Error creating directory "_bckdir,NORFORCE)
     d msgoutb($c(13,10)_"Aborting backup",NOFORCE)
     s REASON(dir)=$$Error^%apiOBJ(7318,bckdir)
     s NODIR(dir)=""
     k DIRNAM(dir)
     continue
   }
   s DEV(dir)=##class(%Library.File).NormalizeFilename(bckdir_"/"_bckname_dbname_".bck")
   i '$zu(140,4,DEV(dir)) {   ; if file exists
     s delerr=$zu(140,5,DEV(dir))
     i delerr {
       d msgoutb($c(13,10)_"Error "_delerr_" deleting file "_DEV(dir)_" before reuse.",NOFORCE) 
       d msgoutb($c(13,10)_dbname_" will not be backed up",NOFORCE) 
       s REASON(dir)=$$Error^%apiOBJ(5019,DEV(dir))
       s NODIR(dir)=""
       k DIRNAM(dir),DEV(dir)
       continue
     }
   }
   s $p(DIRNAM(dir),",",2)=dbname ;for output to manifest
 }
 i $d(DIRNAM)>10 {
   d msgoutb($C(13,10)_$C(13,10)_"Backing up the following directories:"_$C(13,10),NOFORCE) ;JAO266
   s DIR="" f  S DIR=$o(DIRNAM(DIR)) Q:DIR=""  D msgoutb(" "_DIR_$C(13,10),NOFORCE)    ;JAO266
 } else {
   d msgoutb($C(13,10)_$C(13,10)_"No database to back up"_$C(13,10),NOFORCE)
   s OK=0
   q
 }
 i NODIR d
 . ;s BUWARNING="Directory could not be backed up~"_$g(BUWARNING)
 . s SEV=1 f  s DIR=$O(NODIR(DIR)) q:DIR=""  i $G(REASON(DIR))'=$$Error^%apiOBJ(372,DIR) s SEV=2 q
 . d $zu(9,"","The following directories could not be backed up:",(SEV>0),SEV)
 . d msgoutb($C(13,10)_"WARNING - the following directories could not be backed up"_$C(7)_$C(13,10),NOFORCE)
 . s DIR=""  
 . f  s DIR=$O(NODIR(DIR)) Q:DIR=""  d
 . . d $zu(9,"",DIR_" "_$System.Status.GetErrorText(REASON(DIR,0)),(0>0),0)
 . . d msgoutb(" "_DIR_" "_$System.Status.GetErrorText(REASON(DIR,0))_$C(13,10),NOFORCE)
 d msgoutb($C(13,10),NOFORCE) Q
 ;
 ; Write a volume label
 ; If VOL = 1, then also output the directories
VOLLABEL s OK=1,RC=$ZU(50,0,DEV) I RC'=NoErr G VOL1 ; Open the output file
 D OUTVOL("InterSystems IRIS"_" BACKUP")
 if mirrorid="" {
	D OUTVOL("VERSION")  ;Version[0] does not include mirror support
 } else {
    D OUTVOL("VERSION1.1")  ;VERSION1.1 includes mirror support & readonly flag
 }
 D OUTVOL($P($ZV,DELIM,1))
 ; BUFCOUNT is the number of full buffers written on the previous
 ; volume.  It is parsed out of the return code when a volume is full.
 I VOL=1 S BUFCOUNT=0
 FOR I=VOL,DATE,TIME,TYPE,BACKHDATE,LASTDATE,LASTTIME,LASTTYPE,LASTFDATE,LASTFTIME,DESCRIPTION,BUFCOUNT d OUTVOL(I) G VOL1:'OK
 ; Add Mirror name and mirror guid
 if mirrorid'="" {
	 do OUTVOL(mirrorid)  ;<mirname>:<mirror guid>:<system name>: etc....
 }
 G VOL1:'OK  ;OUTVOL() failed.
 ; If this is the first volume label, output the directory names
 i VOL=1 n A s A=DIR d  G VOL1:'OK
 . D OUTVOL(A_"^P^"_MIRDBINFO(A)) q:'OK   ;JO2313
 . D OUTVOL($P($ZU(49,A),",",1,12))
 d OUTVOL("") G VOL1:'OK ; indicate end of logical label
 S RC=$ZU(50,2,DELIM) 
 I RC=NoErr s OK=1 q  ; write the label
VOL1 s OK=0  d msgoutb($C(13,10)_" [",FORCE)
 I RC=ibEOT d msgoutb("End of Volume",FORCE)
 I RC=ibOfflin d msgoutb("Device "_DEV_" Offline",FORCE) 
 I RC=ibDevFul d msgoutb("Device "_DEV_" Full",FORCE)
 I RC=ibOutErr d msgoutb("Output I/O",FORCE)
 I RC=ibInErr d msgoutb("Input I/O",FORCE)
 d msgoutb(" Error has occurred]"_$C(13,10),FORCE)
 d msgoutb("No input device - Terminating backup",FORCE) s OK=$$Error^%apiOBJ(7362,DEV,RC) q
 Q
OUTVOL(a) s RC=$ZU(50,1,a_DELIM) i RC'=1 s OK=0
 q
 ;
PASS ;
 N I
 d msgoutb($C(13,10)_$C(13,10)_"Starting backup pass "_PASS_" at "_$ZDATETIME($H),FORCE)
 ; If last pass took longer than 1/3 of previous pass, or last pass
 ; was less than 30 seconds, then make this the last pass
 ;MaxWaitTime: max wait time for WD to resume before CP freezes system.
 N MaxWaitTime s MaxWaitTime=0 ;10 minutes (600 seconds) by default
 n autothaw s autothaw=0
 I PASS>2 {
   i PASS(PASS-1)<60 {
     s LastPass=1 ;last pass should be brief enough
     s autothaw=300 
   } elseif (PASS(PASS-1)>(PASS(PASS-2)/3)) && (PASS(PASS-1)<300) {
     s LastPass=1
     s autothaw=600
   } elseif (PASS(PASS-1)>(PASS(PASS-2)/3*2)) || (PASS>=MaxPASS) {
     s LastPass=1
     s autothaw=PASS(PASS-1)*2 ;max wait is twice as long as prev pass
   }
 }
 S DIR="" F  {
   S DIR=$O(DIRNAM(DIR)) Q:DIR=""  
   d SetNames(DIR) S RC=NoErr
   s zu49=+$ZU(49,DIR)
   i zu49=-1!(zu49=-2)!(zu49=-3) {
     d msgoutb($C(13,10)_"Directory "_DIR_" *** Isn't Present and Can't Be Backed Up ***"_$C(13,10)_$C(13,10),NOFORCE) 
     s REASON(DIR)=$$Error^%apiOBJ(7321,DIR)
     s OK=1 K DIRNAM(DIR) 
   }
   i PASS=1 {
     n gfowner,i s gfowner=0
     f  {
       s x=$v(+zu49*4+$zu(40,2,92),-2,4) 
       i 'x { 
         d:gfowner msgoutb(" Done"_$C(13,10),NOFORCE) 
         q
       }
       i x'=gfowner {
         d msgoutb($C(13,10)_"Waiting for job #"_x_" to release ownership of database "_DIR,NOFORCE) 
         s gfowner=x
       }
       i $i(i)#10=0 d msgoutb(".",NOFORCE)
       h 1 
     }
   }
 }
 i $d(DIRNAM)<10 s OK=$System.Status.EmbedStatus($$Error^%apiOBJ(7365),$$REASONtoStatus(.REASON)) q  ;no database to back up
 i PASS=1,BUTYP=FULL {
   ; We have reached the point of no return once bitmaps are modified.
   ; If the full backup fails totally, another good full backup is required
   ; before any incremental or cumulative backup can be performed.
   k ^SYS("BACKUP","LASTDIRECTORIES")
   k ^SYS("BACKUP","LASTFULL")
   k ^SYS("BACKUP","HISTORY")
 }
 i LastPass {
   n rc s rc=##class(%SYS.Journal.File).RequiredForRecovery(.RequiredFile)
   i $g(RequiredFile)'="" d msgoutb($C(13,10)_$C(13,10)_"Journal file '"_RequiredFile_"' and the subsequent ones are required for recovery purpose if the backup were to be restored",NOFORCE)
   d msgoutb($C(13,10)),MARKJRN ;may set OK to error status
   i 'OK q  ;continue or abort??
   d msgoutb($C(13,10)_" - This is the last pass - Suspending write daemon",NOFORCE)
 }
 S BEGTIME=$H,LOST=0 ; keep track of pass time
 n SUCCESSDIR  ; Record success backup in last pass.
 S A=$ZH
 if LastPass {
    ; We will enable autothaw after INLOGOR operations (see below).
    ; We want the write daemon to resume automatically if the backup gets stuck
    ; for much longer than it's expected to take (autothaw), or if the system 
    ; is running out of buffers. Extend the write daemon monitoring allowance 
    ; to accomodate this time in addition to its normal allowance.
    d HOLDWD(.DIRNAM,autothaw+$system.Util.WDCycleFreezeTime())
 } else {
    d HOLDWD(.DIRNAM)
 }
 s WDPASS=$zu(190,13)
 S LOST=LOST+($ZH-A)
 n DIRBCK k DIRBCK ;DIRBCK is an array of DBs with sth to back up for this pass
 S DIR="" F  {
   S DIR=$O(DIRNAM(DIR)) Q:DIR=""  
   s RC=$$DIRPASSINLOGOR(DIR,PASS)
   I RC<0 d INLOGORerr(DIR,RC) continue
   s DIRBCK(DIR)=DIRNAM(DIR)
   i LastPass S SUCCESSDIR(DIR)=""
 }
 i 'LastPass {
     d FREEWD
     s DIR="" f  s DIR=$o(DIRNAM(DIR)) q:DIR=""  d $zu(52,9,DIR,0) 
 } else {  ;the final pass
    i $zu(182,4,-autothaw) ;enable autothaw
    i $g(^SYS("BACKUP","DEBUG","STARVE")) d $zu(9,"","WD set to autothaw on starvation or after "_autothaw_"s")
 }
 s OK=1,DIR="" f  {
   s DIR=$o(DIRBCK(DIR)) q:DIR=""
   s OK=queue.CallRoutine(DIR,1,"DIRPASSQ^DBACKP",DIR,DIRNAM(DIR),PASS,LastPass,logfile,DEV(DIR),BUTYP,VOL,$g(markinfo),QUIET) 
   i 'OK d msgoutb($c(13,10)_"Queue "_DIR_" error:"_$System.Status.GetErrorText(OK)) q
 }
 i 'OK g failexit
 f  {
        s msgid=queue.GetReturn(10,.DIR,.sc,.result) 
	;msgid >0, 0 on timeout or <0 if done or on error
	i 'msgid continue  ;timeout
	i msgid<0 {
		i msgid<-1 s OK=sc ;error
		q
	}
       	s OK=$li(result)
	i OK=$$Error^%apiOBJ(7347) q  ;backup aborted by user
	i LastPass { ;in last pass, save final database info for manifest
	  s DIRNAMSAV(DIR,"DBINFO")=$lg(result,2)
	}
	i 'OK { ;skipping DIR due to error in DIRPASS
	  k DIRNAM(DIR)
	  s REASON(DIR)=OK
	  d $zu(9,"","Error backing up "_DIR_": "_$System.Status.GetErrorText(OK))
	  s OK=1 ;continue with other databases
	} else {
	  S RC=$$INLOGOR(DIR,2,1,1) 
	  I RC<0 d INLOGORerr(DIR,RC) ;k DIRNAM(DIR) s REASON(DIR)
	}
 }
 i 'OK g failexit
 i LastPass {
   i '$zu(182,0)||($zu(190,13)>WDPASS) { ;WD must have auto-thawed
     s LastPass=0 ;to do additional passes or not to clear flag in failexit
     d $zu(9,"","Backup performing additional passes because write daemon was resumed during the last pass")
     i PASS=MaxPASS {
       i BUTYP'=FULL {
         s I="" f  s I=$o(SUCCESSDIR(I)) q:I=""  d $zu(52,9,I,0)
	 k SUCCESSDIR
         d CLEANUP ;finalize backups
       }
       s sc=$$Error^%apiOBJ(7337)
       s OK=$s(OK:sc,1:$system.Status.AppendStatus(sc,OK))
       g failexit ;to abort backup
     } 
     ; to do additional passes (cf. the post-FREEWD code below for LastPass)
     s I="" f  s I=$o(SUCCESSDIR(I)) q:I=""  d $zu(52,9,I,0)
     k SUCCESSDIR
     i $g(^SYS("BACKUP","DEBUG","STARVE")),$i(^SYS("BACKUP","DEBUG","STARVE"),-1)
   } else { ;WD still suspended
     d FREEWD s I="" f  s I=$o(SUCCESSDIR(I)) q:I=""  d $zu(52,9,I,0)
     d CLEANUP ;finalize backups
     i 'OK s LastPass=0 g failexit ;LastPass=0 since we have cleared the flag
   }
 }
 d msgoutb($C(13,10)_"Backup pass "_PASS_" complete at "_$ZDATETIME($H),FORCE)
 I LastPass d msgoutb($C(13,10),FORCE)
 s PASS(PASS)=$$TIME($H,BEGTIME)-LOST
 i LastPass {
   s sc=$$WriteManifestJSON()
   i ('sc) {
     d msgoutb($C(13,10)_"Error writing manifest: "_$System.Status.GetErrorText(sc)_$C(13,10),FORCE)
     s OK=sc
     q
   }
 }
 Q
failexit ;
 k DIRNAM,REASON ;total failure due to error 'OK'
 k queue
 i LastPass d FREEWD s I="" f  s I=$o(SUCCESSDIR(I)) q:I=""  d $zu(52,9,I,0)
 d $zu(9,"","Backup failed on "_$System.Status.GetErrorText(OK))
 q
CLEANUP ; write journal marker and end of volumen set to each backup file
 s OK=1,DIR="" f  {
   s DIR=$o(DIRNAM(DIR)) q:DIR=""
   s OK=queue.CallRoutine(DIR,1,"DIRPASSQ^DBACKP",DIR,DIRNAM(DIR),PASS,-1,logfile,DEV(DIR),BUTYP,VOL,markinfo,QUIET) 
   i 'OK d msgoutb($c(13,10)_"Queue "_DIR_" error:"_$System.Status.GetErrorText(OK)) return
 }
 f  {
        s msgid=queue.GetReturn(10,.DIR,.sc,.result) 
	;msgid >0, 0 on timeout or <0 if done or on error
	i 'msgid continue  ;timeout
	i msgid<0 {
		i msgid<-1 s OK=sc ;error
		q
	}
       	s OK=$li(result)
	i OK=$$Error^%apiOBJ(7347) q  ;backup aborted by user
	i 'OK { ;skipping DIR due to error writing journal marker or EOVS
	  k DIRNAM(DIR)
	  s REASON(DIR)=OK
	  d $zu(9,"","Error backing up "_DIR_": "_$System.Status.GetErrorText(OK))
	  s OK=1 ;continue with other databases
	}
 }
 q
INLOGORerr(DIR,RC) ;
 n msg s msg=$p(RC,",",2)
 k DIRNAM(DIR)
 i +RC=-1 {
   s REASON(DIR)=$$Error^%apiOBJ(7345,DIR,msg)
   s msg="I/O Error "_msg
 } elseif +RC=-2 {
   s REASON(DIR)=$$Error^%apiOBJ(372,DIR)
 } else {
   s REASON(DIR)=$$Error^%apiOBJ(7346,DIR,RC)
   s msg="Unknown Error "_RC
 }
 D msgoutb($C(13,10)_"["_msg_" occurred while processing directory '"_DIR_"' - Check the log]"_$C(13,10),FORCE)
 q
 ;Uses public variables BUTYP, FULL, etc.
DIRPASSINLOGOR(DIR,PASS) ;
 i PASS=1 {
   i BUTYP=FULL { ;the first pass of a full backup
     ; GFFORCEFULBK should be already set in HOLDWD()
     ; and not cleared until FREEWD()
     ; clear .INC (INCACTIVEMAP) as it may include killed blocks
     s I=$$INLOGOR(DIR,3,3,1)
     ; mark all in-use blocks in .IND file (INCBACKUPMAP) 
     s RC=$$INLOGOR(DIR,3,2,2)
     i RC'<0 {
       ; delete .INE file (INCRECORDMAP)
       s I=$$INLOGOR(DIR,1,1,1)
       ; -2 = incremental backup not enabled on this database (ReadOnly)
       s RC=I
     }
   } else { ;the first pass of a partial (incremental) or cumulative backup
     ; OR .INE file into .IND and delete the .INE file
     ; so that we can recover from a previously interrupted backup
     s RC=$$INLOGOR(DIR,1,2,1)
     i BUTYP=CUMINC { ;first pass of a cumulative incremental backup,
       ; OR .INF into .IND and leave .INF alone
       s I=$$INLOGOR(DIR,0,2,0)
       s:RC'<0 RC=I
     }
     ; OR .INC into .IND and clear the .INC file
     s I=$$INLOGOR(DIR,3,2,1) D
     S:RC'<0 RC=I
   }
 } else { ; If not 1st pass, OR .INC into .IND and clear the .INC file
   s RC=$$INLOGOR(DIR,3,2,1)
 }
 Q RC
 ;
 ;------------------------------------------------------------------
FATAL(msg) ;
 S OK=0 d msgoutb($C(7)_$C(13,10)_"["_msg_" Fatal Error]"_$C(13,10),FORCE)
 Q
 ;
NEXTVOL(prompt) ;
 n BEG s BEG=$H
 S BUFCOUNT=$P(RC,",",2)
 d msgoutb($C(13,10)_"End of volume detected",FORCE)
 s OK=0 
 q 
DISMOUNT(dev,nounload) ; Dismount a tape volume
 i $ZU(148,2,dev,nounload) ; Unload can be inhibited
 q
SetNames(D) N M
 S M=D_"IRIS"_".",INC=M_"INC",IND=M_"IND",INE=M_"INE",INF=M_"INF"
 Q
DBACKB ; Part three of Incremental Backup ;$Change: 5153899 $
POSTPROC ;
 d DEQ13
 ; Now allow full use of the global module, unless the
 ; caller already had switch 10 set
 D DEQ10
 I 'ALRDY10,'ALRDY13 d msgoutb($C(13,10)_"Global references are enabled."_$C(13,10),NOFORCE)
 S DIR=""
 F  S DIR=$O(DIRNAM(DIR)) Q:DIR=""  D EORFTOF
 ; store parameters about this backup
 S Y=$zu(78,22)
 i BUTYP=FULL,OK,$d(DIRNAM)>10 D  ;a full backup that succeeded at least partially
 . m ^SYS("BACKUP","LASTDIRECTORIES")=DIRNAM ;databases backed up w/o error
 . K ^SYS("BACKUP","HISTORY")
 . S ^SYS("BACKUP","LASTFULL","DATE")=BACKHDATE
 . S ^("DESC")=DESCRIPTION,^("DEVICE")=$S($D(FIRSTDEV):FIRSTDEV,1:DEV)
 . S ^("TYPE")="Full"     ; as opposed to External Full
 . S ^("LOG")=logfile     ; logfile gets displayed on GUI
 . i Y S ^("JOURNAL")=$zu(78,3)  ; Current journal file
 i BUTYP'=FULL D
 . d ConvHistDate
 . S ^SYS("BACKUP","HISTORY",(+BACKHDATE*1000000+$p(BACKHDATE,",",2)),"DESC")=DESCRIPTION
 . S ^("DEVICE")=$S($D(FIRSTDEV):FIRSTDEV,1:DEV),^("TYPE")=TYPE
 . S ^("LOG")=logfile     ; logfile gets displayed on GUI
 . i Y S ^("JOURNAL")=$zu(78,3)  ; Current journal file
 try {
   i 'OK { ;backup-wide failure (error status in OK)
     s OK=$system.Status.EmbedStatus($$Error^%apiOBJ(7341),OK)
     D SETHISTORY(0)
   } elseif $d(REASON) { ;backup failed for some or all databases 
     s tsc=$$REASONtoStatus(.REASON)
     i $d(DIRNAM)>10 { ;partial failure
       s OK=$system.Status.EmbedStatus($$Error^%apiOBJ(7340),tsc)
       D SETHISTORY(2)
     } else { ;total failure
       s OK=$system.Status.EmbedStatus($$Error^%apiOBJ(7341),tsc)
       D SETHISTORY(0)
     }
   } else { ;success
     s OK=1
     D SETHISTORY(1)
   }
 } catch {
   s OK=$system.Status.EmbedStatus($$Error^%apiOBJ(7341),$$Error^%apiOBJ(5002,$ze))
   D SETHISTORY(0)
 }
 q
ExternalSetHistory(logfile,DESCRIPTION,BACKHDATE)
 Set TYPE="Paused External Full",BUTYP=5,DEV="",FULL=2
 D SETHISTORY(1)
 q
SETHISTORY(Complete) 
 s BACKHDATE=$G(BACKHDATE,$H)
 s hindex=(+BACKHDATE*1000000+$p(BACKHDATE,",",2))
 S Y=$zu(78,22)
 s ^SYS("BUHISTORY",0,"LOGNOTPURGED",hindex)=""
 s ^SYS("BUHISTORY",hindex,"STATUS")=$case(Complete,-1:"Aborted",2:"Warning",1:"Completed",0:"Failed",:"")
 S ^("DESC")=$G(DESCRIPTION),^("DEVICE")=$S($D(FIRSTDEV):FIRSTDEV,1:DEV)
 S ^("TYPE")=$S(BUTYP=FULL:"Full",1:TYPE)
 S ^("LOG")=$G(logfile)     ; logfile gets displayed on GUI
 s ^("LIST")=$s(+$g(alldb):"All",1:"List")
 s ^("Complete")=Complete ;numeric completion status (cf. "STATUS")
 I Y&(Complete>0) d SetJournalHistory(hindex)
 i $p($g(^%SYS("JOURNAL","LIFESPAN","FILE")),",",2) d PPURGE^JRNUTIL
 q
SetJournalHistory(hindex) ;
 n wijinfo s wijinfo=$g(^SYS("BACKUP","WIJINFO"))
 m ^SYS("BUHISTORY",hindex,"JOURNAL")=^SYS("BACKUP","MIRINFO")
 s ^SYS("BUHISTORY",hindex,"JOURNAL")=$p(wijinfo,",",2)
 s ^SYS("BUHISTORY",hindex,"WIJINFO")=wijinfo
 q
GetJournalInfo() public {
 s ^SYS("BACKUP","WIJINFO")=$zu(78,21)
 i $SYSTEM.Mirror.IsPrimary() q  ;to use wijinfo
 k ^SYS("BACKUP","MIRINFO")
 s mirnames=$SYSTEM.Mirror.GetMirrorNames()
 s mircnt=$LL(mirnames)
 f i=1:1:mircnt {
 	s name=$LG(mirnames,i)
 	s idx=$SYSTEM.Mirror.MirrorNameToIndex(name)
 	i (idx > -1) {
		s filecnt=+$SYSTEM.Mirror.GetInfo(2,idx)
		; filecnt=0 when mirroring is stopped in backup or async member
		; or when they are in synchronizing state
 		i filecnt>0 s ^SYS("BACKUP","MIRINFO",name)=filecnt
 	}
 }
}
 ;
EORFTOF ; After a Full BU, we delete INE and INF
 ; after a Cumulative or Incremental,
 ; we merge INE into INF, and then delete INE.
 D SetNames(DIR)
 i BUTYP=FULL d 
 . s RC=$$INLOGOR(DIR,1,1,1)
 . s RC=$$INLOGOR(DIR,0,0,1)
 i BUTYP=PARTIAL!(BUTYP=CUMINC) D
 . S RC=$$INLOGOR(DIR,1,0,1)
 I RC<0 D INLOGORerr(DIR,RC) ;k DIRNAM(DIR) s REASON(DIR)
 Q
JRNCHECK ;
 i $p($zu(78,22),"^",3) d  q
 . n status,error,SAVE13,SAVE10 s SAVE13=ALRDY13,SAVE10=ALRDY10
 . i ALRDY13 s ALRDY13=0,ALRDY10=1 d ENQ10,DEQ13
 . d msgoutb("Journaling is currently off due to I/O error. Restarting journaling..."_$C(13,10),FORCE)
 . s status=##class(%SYS.Journal.System).Start()
 . i 'status d  i 1
 . . s error=$System.Status.GetErrorText(status)
 . . d msgoutb("Journal start did not complete: "_error_$C(13,10),FORCE)
 . e  d msgoutb($C(13,10)_"Journaling started at "_$zu(78,3)_$C(13,10),FORCE)
 . I SAVE13 D ENQ13 S ALRDY13=1
 . i 'SAVE10 d DEQ10 s ALRDY10=0
 S Y=$zu(78,22)
 I 'Y d msgoutb("Journaling is not enabled"_$C(13,10),FORCE) Q
JRNSWTCH ;
 n SAVE13,SAVE10 s SAVE13=ALRDY13,SAVE10=ALRDY10
 ;if switch 13 is set, replace it with switch 10 since JRNSWCH sets globals
 i ALRDY13 s ALRDY13=0,ALRDY10=1 d ENQ10,DEQ13
 S status=$$JRNSWCH^JRNUTIL("",4)
 i status=1 d 
 . d msgoutb($C(13,10)_"Journal file switched to:"_$C(13,10),FORCE)
 . d msgoutb($zu(78,3)_$C(13,10),FORCE)
 i status'=1 d
 . d msgoutb("Journal switch did not complete"_$C(13,10),FORCE)
 . d msgoutb($p(status,",",2,$l(status))_$C(13,10),FORCE)
 I SAVE13 D ENQ13 S ALRDY13=1
 i 'SAVE10 d DEQ10 s ALRDY10=0
 Q
GD1(DIR) S DIR=$ZU(12,DIR) ; get canonic name for directory
 n zu49,zu49l s zu49l=$ZU(49,DIR),zu49=+zu49l  ;KMK106
 i zu49=-2!(zu49=-3) {
   s NODIR(DIR)="",NODIR=NODIR+1  ;KMK106
   s REASON(DIR)=$$Error^%apiOBJ(7321,DIR)
   s REASON(DIR,0)=$$Error^%apiOBJ(57)
   q
 } 
 i zu49=-1!(zu49=$zu(40,0,41)) {
   d MNTDIR(DIR) 
   s zu49l=$ZU(49,DIR),zu49=+zu49l ;keep the longer version of $zu(49)
   i zu49=-1!(zu49=$zu(40,0,41)) {
     s NODIR(DIR)="",NODIR=NODIR+1
     ; REASON(DIR) has been set up in MNTDIR()
     q
   }
 }
 i +zu49=$zu(173) {
   s NODIR(DIR)="",NODIR=NODIR+1
   s REASON(DIR)=$$Error^%apiOBJ(7342,DIR)
   s REASON(DIR,0)=$$Error^%apiOBJ(7322)
   q
 }
 i (('$zb(+$p(zu49l,",",17),$zu(40,8,28),1))||$zb(+$p(zu49l,",",18),$zu(40,8,30),1))&&($zb(+$p(zu49l,",",17),$zu(40,8,13),1)||($zb(+$p(zu49l,",",18),$zu(40,8,2),1))) {
   s NODIR(DIR)="",NODIR=NODIR+1
   s REASON(DIR)=$$Error^%apiOBJ(372,DIR) 
   s REASON(DIR,0)=$$Error^%apiOBJ(302) 
   q
 }
 s DIRNAM(DIR)=DIRNAM,DIRNAM=DIRNAM+1
 ;for mirrored db's we also store a series of fields from
 ; the mirror info block seperate by :'s
 ;    <mirdbname>:<mirdb guid>:<mirname>:<mirguid>: etc...
 s MIRDBINFO(DIR)=$$getMirDBInfo(DIR)
 Q
getMirDBInfo(dir) PUBLIC {
  ; returns null string if database is not a mirrored db or we
  ; return the information from the mirror info block that we
  ; want to store in the database list in volume #1 for use
  ; by DBREST.
  if '$$isMirroredDb^MIRRORMGR(dir) quit ""
  s info=$SYSTEM.Mirror.DBGetInfoByName(0,dir)
  if info="" quit ""  ;shouldn't happen but this isn't a mirrored database
  ;
  s dbname        =$P(info,"^",2)
  s mirjrnfilecnt =$P(info,"^",3)
  s jrnoff        =$P(info,"^",4)
  s dbguid        =$P(info,"^",6)
  s mirguid       =$P(info,"^",7)
  s mirname       =$P(info,"^",8)
  s sysguid       =$P(info,"^",9)
  ; lastfilecntrestored is usually zero unless the database
  ; is currently being caught up. In that situation this contains
  ; the mirjrnfilecnt of the last journal file replayed to
  ; this database.
  s lastfilerest =$P(info,"^",11)
  s nofailoverbit=+$ZU(40,8,31)
  s nofailoverflag=+$P(info,"^",12)
  s readonly=$ZB(nofailoverflag,nofailoverbit,1)			
  if readonly'=0 s readonly=1  ;change to 1/0 for read-only/read-write
  ; use : as a seperator, not ^. ^ is already the delimiter for the
  ; string this gets added to in the backup with the $ZU(49) and
  ; cluster flag. : is safe as long as we don't store any file names
  ; in this info as : can't be in any of the other strings.
  s backupinfo=dbname_":"_mirjrnfilecnt_":"_jrnoff_":"_dbguid
  s backupinfo=backupinfo_":"_mirguid_":"_mirname_":"_sysguid
  s backupinfo=backupinfo_":"_readonly
  quit backupinfo
}
MNTDIR(DIR) ; 
 N (DIR,%ST,REASON,bkpmount,zu49)
 s:zu49'=$zu(40,0,41) bkpmount(DIR)=""
 s Status=##Class(SYS.Database).MountDatabase(DIR,0,0)
 i (''Status) q
 s REASON(DIR)=$System.Status.EmbedStatus($$Error^%apiOBJ(6044,DIR),Status)
 s REASON(DIR,0)=$$Error^%apiOBJ(6044,$SYSTEM.Status.GetErrorText(Status))
 q
 ;        
LISTDIRSDBACKB ; This tag was moved here from DBACK
 ; This procedure takes a file name and a mode.  It opens the file
 ;   and dumps the list of directories which are included in a backup.
 ;   If the list is empty, all directories on the system (except temp)
 ;   are backed up.
 ; If MODE is not equal to "QUIET" then it also displays this list
 ;  on the terminal.
 ; It is intended that this list provide the list of directories
 ;    who's CACHE.DATs will be backed up.  If the backup is performed
 ;    with Cache up then it is expected that the external backup
 ;    will be followed immediatly by a 'concurrent incremental' backup
 ;    as it is necessary in order to record blocks which were modified
 ;    during the external backup.  If a directory is present in the
 ;    SYS global but does not really exist then it is not listed and
 ;    the DBACK utility will report that it isn't being backed up...
 ; Notes:
 ;     This procedure requires read access to the SYS global.
 ;     No switches are set or cleared
 ;     All local variables are NEWed
 N DIR,QUIET,D,zu49
 n rc,cnt,list,i,del1,del2,db,dbname,msg
 S $ZT="LSTERR"
 i $$UP(mode)'="QUIET" d
 . s QUIET=0
 . w !,"List of directories to be backed up"
 e  s QUIET=1
 O file:"WNS"   ; Create a new copy of this file
 s del1=$$del1^%Wprim,del2=$$del2^%Wprim
 s rc=$$DbList^Wsback(.list)
 if '+rc w !,"Error building list of databases: ",$P(rc,del1,2) g LSTERR2
 s cnt=$L(list,del1)-1
 f i=1:1:cnt {
	s db=$P(list,del1,i)
	s dbname=$P(db,del2,1)
	q:dbname=""  
	s DIR=$P(db,del2,2)
 	s zu49=+$ZU(49,DIR)  
 	i zu49=-1 {  ; skip unmounted directories
 	   s msg=DIR_" NOT mounted.  Omitted from backup."
 	   u file w msg,! i 'QUIET u 0 w !,?5,msg
 	} elseif zu49'=-2 {
 	   S D=$ZU(12,DIR) ;Just incase it is a logical w/o ":" 
 	   u file w D,!
 	   i 'QUIET u 0 w !,?5,D
 	}
 }
 use 0
 c file
 i 'QUIET w !
 s $ZT="" Q 1   ; indicates success
LSTERR s $ZT="" i $ZE'="" w !,$ZE,!
LSTERR2
 c file
 q 0   ; indicates failures
 ;-------------------------------------------------------------------
CLRINCDBACKB ;This tag was moved here from DBACK
 ;This procedure is called to clear the bitmaps that mark blocks as
 ;  modified for the databases in the backup list.  At the same
 ;  time it also deletes the backup history as it is no longer possible
 ;  to do any sort of a backup without first performing a full backup.
 ;  This procedure is designed to be used prior to doing an external
 ;  full backup with Cache running.  If an external backup is
 ;  performed with Cache down then before shutting down the system,
 ;  this entry point should be called. (JAO614 updated this comment)
 ;If MODE is not equal to QUIET then the procedure prints out the
 ;  directory names as it goes along.
 ;This procedure sets switch 10, waits for the daemon/garcol to
 ;  quiesse, and dismounts the directories before deleting the .INC
 ;  files.  
 ; Notes:
 ;    This process requires read/write access to the SYS global.
 ;    This procedure will record the state of switch 13,
 ;          insure switch 13 is set and restore switch 13 upon exit.
 ;    All local variables are NEWed EXCEPT for those defined by
 ;          INITVARS
 ;    If a directory is dismounted when this routine is called then
 ;          it is left dismounted when the routine exits
 ; Error processing:
 ;   If an error is encountered (although none are expected) then we
 ;      restore switch 13.  At this point however we have deleted
 ;      the backup history information as we may have cleared one
 ;      or more bitmaps (JAO614)
 S $ZT="CLRERR"
 i '$SYSTEM.Security.Check("%Admin_Operate","USE") {
 	w !,"Operation requires %Admin_Operate:Use privilege"
	q $system.Status.EmbedStatus($$Error^%apiOBJ(7341),$$Error^%apiOBJ(921,"%Admin_Operate"_":"_"USE"))
 }
 N DIR,%SW,%VAL,RC,TMP,QUIET,SW13SET,SW10SET,OK,D         
 n zu49  
 n LCKTYPE,NODIR,DIRNAM
 n mirrorid,MIRDBINFO
 n rc,cnt,list,i,del1,del2,db,dbname,msg
 D INITVARS                   ; Note: This executes ^%ST
 n REASON
 s DIR=""
 i $$UP(mode)'="QUIET" s QUIET=0
 e  s QUIET=1
 n haslock
 L +^DBACK:1
 i '$t {
   s OK=system.Status.EmbedStatus($$Error^%apiOBJ(7341),$$Error^%apiOBJ(7309))
   i 'QUIET d $System.Status.DisplayError(OK)
   q OK
 }
 s haslock=1
 ;
 S NODIR=0,DIRNAM=0
 s del1=$$del1^%Wprim,del2=$$del2^%Wprim
 n sc s sc=1
 s rc=$$DbList^Wsback(.list)
 if 'rc {
   s OK=$$Error^%apiOBJ(7323,$P(rc,del1,2))
   i 'QUIET d $System.Status.DisplayError(OK)
   g CLRERR3
 }
 s cnt=$L(list,del1)-1
 f i=1:1:cnt {
	s db=$P(list,del1,i)
	s dbname=$P(db,del2,1)
	q:dbname=""  
	s DIR=$P(db,del2,2)
	do GD1(DIR)
    i $d(NODIR(DIR)) {
      i 'QUIET w !,?5,$System.Status.GetErrorText(REASON(DIR))
    }
 }
 ; Kill off the history and initialize the variables for using
 ;   the Backup specific $ZU functions
 K ^SYS("BACKUP","HISTORY")   ; Once we start this we can no longer
 K ^SYS("BACKUP","LASTFULL")  ;    use the old history information
 d GetJournalInfo()
 L -^DBACK s haslock=0
 d HOLDWD(.DIRNAM,,1) ;1 = clear GFNOBACKUP before suspending WD
 s $zt="CLRERR2"
 S DIR=""
 F  {
   S DIR=$O(DIRNAM(DIR)) q:DIR=""
   S D=$ZU(12,DIR) ; Just incase it is a logical w/o ":"     
   s RC=$$INLOGOR(D,3,3,1) ; clear it
   I RC>-1 {
     i 'QUIET W !,?5,"Cleared incremental backup bitmap in ",D
   } elseif +RC=-1 { ;expecting RC=-1,$ZE
     s msg=$p(RC,",",2,*)
     i 'QUIET w !,?5,"I/O Error clearing bitmap in ",D,": ",msg
     k DIRNAM(DIR)
     s REASON(DIR)=$$Error^%apiOBJ(7345,D,msg)
   } else {
     i 'QUIET w !,?5,"Unknown error (",RC,") clearing bitmap in ",D
     k DIRNAM(DIR)
     s REASON(DIR)=$$Error^%apiOBJ(7346,D,RC)
   }
 }
 ; Post processing - reset switches
 d FREEWD
 S $ZT=""
 try {
   s OK=1
   i $d(REASON) {
     s tsc=$$REASONtoStatus(.REASON)
     i $d(DIRNAM)<10 {
       s OK=$system.Status.EmbedStatus($$Error^%apiOBJ(7341),tsc)
     } else {
       s OK=$system.Status.EmbedStatus($$Error^%apiOBJ(7340),tsc)
     }
   }
 } catch {
   s OK=$system.Status.EmbedStatus($$Error^%apiOBJ(7341),$$Error^%apiOBJ(5002,$ze))
 }
 Q OK
CLRERR s $ZT="" 
 i $ZE'="" {
   i 'QUIET w !,$ZE
   s OK=$system.Status.EmbedStatus($$Error^%apiOBJ(7341),$$Error^%apiOBJ(5002,$ze))
 }
CLRERR3 ;
 i 'QUIET w !
 i $g(haslock) L -^DBACK
 q OK 
CLRERR2 s $ZT=""
 i $ZE'="" {
   i 'QUIET w !,$ZE
   s OK=$system.Status.EmbedStatus($$Error^%apiOBJ(7341),$$Error^%apiOBJ(5002,$ze))
 }
 i 'QUIET w !
 d FREEWD 
 q OK
REASONtoStatus(REASON) {
 s tsc=1,DIR="" f  {
   s DIR=$o(REASON(DIR)) q:DIR=""
   s tsc=$system.Status.AppendStatus(tsc,REASON(DIR))
 }
 q tsc
}
DBACKC ; Part three of Incremental Backup ;$Change$
 ;
DIRPASSQ(DIR,DIRNAMVAL,PASS,LastPass,logfile,DEV,BUTYP,VOL,markinfo,QUIET) ;
 n (DIR,DIRNAMVAL,PASS,LastPass,logfile,DEV,BUTYP,VOL,markinfo,QUIET,%result)
 s PREVMNT=0 ;disable FREETAPE()
 try {
   i LastPass>0,$g(^SYS("BACKUP","DEBUG","STARVE")) {
     d $zu(9,"","hanging until starvation in PASS "_PASS)
     f  {
       i $zu(190,13,3)#2 q  ;starvation
       i '$zu(182,0) d $zu(9,"","resuming") q  ;WD has auto-thawed
       h 1
     }
     h 2 ;allow WD time to auto-thaw
   }
   d initconstants ;NOFORCE, NoErr, etc.
   S NOINPUT=1,INTERNAL=1
   s logfile=##class(%Library.File).NormalizeFilename("backup.log",##class(%Library.File).GetDirectory(DEV))
   i '##class(%Library.File).Exists(logfile) {
     d createlog
     i 'OK s %result=$listbuild(OK) return
   }
   d openlog i 'OK s %result=$listbuild(OK) return
   ;s LOST=0
   s DIRNAM(DIR)=DIRNAMVAL
   s RC=$zu(50,0,DEV) 
   i RC'=1 {
     s func="$zu(50,0,"_DEV_")"
     s %result=$listbuild($$Error^%apiOBJ(5039,func))
     d closelog
     return
   }
   ; need to adjust obcurb, which $zu(50,0) set to obnumb
   ; -- this can be addressed by restoring saved outbp
   d $zu(32,0,DIRNAM(DIR)) ;retrieve output info from previous pass or master
   i LastPass<0 {
     d done ;write markinfo and end of volume set
     ; OK may be set to abort or other errors (journal marker, etc.)
   } else { 
     d DIRPASS
     i $d(REASON(DIR)) { ;DIR has been skipped
       s OK=REASON(DIR)
     }
   }
   s RC=$zu(32,5) ;wait for writes to complete (always succeed)
   k dbinfo
   i LastPass>0 {
     s sc=$$RecordLastPassDBInfo(DIR,DEV,.dbinfo)
     i ('sc) {
       s OK=$System.Status.AppendStatus(OK,sc)
     }
   }
   s %result=$listbuild($g(OK,1),$g(dbinfo))
 } catch {
   d BACK^%ETN
   d $zu(9,"","Caught error "_$ze)
   s %result=$listbuild($$Error^%apiOBJ(5002,$ze))
 }
 d closelog
 q
DIRPASS ;
 n zu49,x,err,start,end,numerr,s,lastblk
 i PASS=1,BUTYP=FULL,$zu(32,8,$g(^SYS("BACKUP","UseLargeRead"),1))!1
 e  i $zu(32,8,+$g(^SYS("BACKUP","UseLargeRead","All")))
 ;$ZU(32,1,DIR) writes the directory label to the backup file which
 ;includes the "$ZU(49)" info. It is important that the current size
 ;of the database in the directory label caters for all the blocks
 ;stored in that pass so we do this after setting switch 13, not before.
 s x=$ZU(32,1,DIR)
 i +x'=1 {
   i +x=RCABORT {
     s OK=$$Error^%apiOBJ(7347) 
     d msgoutb($C(13,10)_$C(13,10)_"We got an abort signal while trying to open directory "_DIR_$C(13,10)_"and write a label."_$C(13,10)_$C(13,10),NOFORCE) 
     Q
   }
   d msgoutb($C(13,10)_$C(13,10)_"We got an error trying to open directory "_DIR_$C(13,10)_"and write a label."_$C(13,10)_$C(13,10),NOFORCE)
   s err=$$error(x)
   i +x=RCINERR!(+x=RCMAPINERR)!(+x=RCBADMAP)!(+x=RCMOUNT) {
     d msgoutb("We got a '"_err_"' error trying to mount the "_"IRIS"_".DAT file in "_DIR_$C(13,10)_"  It will be skipped."_$C(13,10),FORCE)
     s REASON(DIR)=$$Error^%apiOBJ(7344,DIR,err) ;reason for skipping DIR
     k DIRNAM(DIR) 
     q
   }
   d msgoutb("We got a '"_err_"' write error trying to write the label for the"_$C(13,10)_"IRIS"_".DAT file in "_DIR_$C(13,10),FORCE)
   s REASON(DIR)=$$Error^%apiOBJ(7364,DIR,err) ;reason for skipping DIR
   k DIRNAM(DIR) 
   q
 }
 ; Backup this directory for this pass
 d msgoutb($C(13,10)_"Pass "_$g(PASS)_" ("_$j_"): Backing up "_DIR_" at "_$ZDATETIME($H),NOFORCE)
 ;
continue ;
 S VOLDIR=DIR,start=$zh,RC=$ZU(IBUPass,2),end=$zh
 ;
 d msgoutb($C(13,10)_"Copied "_$p(RC,",",3)_" blocks in "_$j(end-start,0,3)_" seconds"_$C(13,10),FORCE)
 s numerr=$l(RC,",")-3 i numerr s s=$s(numerr=1:"",1:"s") d  
 . d msgoutb($C(13,10)_" With "_numerr_" read error"_s_" on block"_s,FORCE)
 . s s="" f i=1:1:numerr s s=s_$j($p(RC,",",i+3),11) s:$l($p(s,$C(13,10),$l(s,$C(13,10))))>68 s=x_$C(13,10)
 . d msgoutb($C(13,10)_s_$C(13,10),FORCE)
 i +RC=1 d msgoutb($C(13,10)_"Finished this pass of copying "_DIR_" at "_$ZDATETIME($H)_$C(13,10),FORCE) g DPX
 s err=$$error(RC),lastblk=$p(RC,",",numerr+3)
 ;
 i +RC=RCINERR g readerr
 i +RC=RCABORT d msgoutb("We got an abort signal,backup aborted."_$C(13,10),FORCE) g abort
 i +RC=RCBADMAP d  d msgoutb("  - this is a fatal error"_$C(13,10),FORCE) g skip
 . i lastblk d msgoutb("Bitmap block "_lastblk_" has a bad label",FORCE)
 . e  d msgoutb("We are missing incremental bitmaps for this 2kb "_"IRIS"_".DAT file",FORCE)
 i +RC=RCMAPINERR d msgoutb("We got a fatal read error on a bitmap block "_lastblk_$C(13,10),FORCE) g skip
 ; we got a write error while copying a database
 d msgoutb("We got a '"_err_"' write error trying to copy this "_"IRIS"_".DAT directory."_$C(13,10),FORCE)
 g skip
 ;
 ; readerr
 ; we got a read error while copying a database
readerr ;
 d msgoutb("We got too many read errors on "_DIR_"."_$C(13,10),FORCE)
 i QUIET g skip ;default action is to skip backing up DIR on read errors
 n text,def s text="Do you wish to continue with this directory?",def="Yes"
 i '$g(gui) d  R a s:a="" a=def
 . d msgoutb(text_" ["_def_"] ",FORCE)
 e  s a=$$IjcMB^%Wprima(text,4,"Backup: Too Many Input Errors")
 ;
 i a?1"Y".e!(a?1"y".e) d msgoutb($C(13,10)_"Continuing copy of "_DIR,FORCE) g continue
skip d msgoutb($C(13,10)_"Copy of "_DIR_" aborted."_$C(13,10),FORCE) 
 s OK=1 k DIRNAM(DIR) 
 s REASON(DIR)=$$Error^%apiOBJ(7348,DIR,err)
 q
abort d msgoutb($C(13,10)_"Backup aborted by request."_$C(13,10),FORCE) s OK=$$Error^%apiOBJ(7347) q
 ;
 ; done
 ; we've finished the backup - write the end of volume record and close structures
done ;
 s OK=1
 i $g(markinfo)]"" {
   s a=$ZU(32,6,markinfo) 
   i +a'=1,+a'=RCABORT {
     s err=$$error(a)
     d msgoutb("We got a rare "_err_" writing a journal marker information record."_$C(13,10),FORCE)
     s OK=$$Error^%apiOBJ(7349,DIR,err)
   }
 }
 s a=$ZU(32,4)
 i +a'=1,+a'=RCABORT {
   s err=$$error(a)
   d msgoutb("We got a rare "_err_" writing the last couple of blocks and the end-of-volume-set label record."_$C(13,10),FORCE)
   s OK=$System.Status.AppendStatus(OK,$$Error^%apiOBJ(7350,DIR,err))
 }
 s a=$ZU(32,5) ; close structures
 i ##class(Backup.General).GetAbortStatus() {
   d msgoutb($C(13,10)_"***ABORTED BACKUP***"_$C(13,10),FORCE)
   s OK=$$Error^%apiOBJ(7347)
 } else {
   d msgoutb($C(13,10)_"***FINISHED BACKUP***"_$C(13,10),FORCE)
 }
 q
 ;
DPX ;
 d $zu(32,9,DIRNAM(DIR)) ;save pincrioctl->outbp to shared space
 Q
 ; end of DIRPASS
 ;------------------------------------------------------------------
 ;
 ; $$error(x)
 ; translate return code into text
error(a) ;
 i a>0 s a=$p("Success,End Of Tape,Device Off Line,Device Full,not used",",",a)
 e  d
 . i a>-10 s a=$p("General Read,General Write,Cluster Mounted Target,Directory Mount Error,Restore Map Error,Restore Old Format,Restore Bad Input Volume,Restore Bad Block Contents (failed CRC on read),no longer used,Restore End Of Volume",",",-a) q
 . e  s a=$p("2kb Missing Bitmaps/Bad Bitmap Label,Restore Wrong Block Size,Read Error on Incrmental Bitmap,Input Error But Label Is Good,Restore Bad Block Contents (was bad when backup made),Missing Blocks Due to Read Errors,End of Volume Set,Directory Label Record,Missing Directory Label Record",",",-a-10)
 i a="" s a="***Unknown Problem***"
 q a
 ;
msgoutb(aaamess,flag) ;
         W *-1            ;Flush the input buffer 
         q:'$L(aaamess)   ; Avoid argumentless writes...
         i $g(logfile)'="" u logfile w aaamess
         i $g(flag)=LOGONLY q
         u 0
         i '$G(QUIET) w aaamess
         q
WriteManifestJSON() ;
 n (manifest,TYPE,DESCRIPTION,BACKHDATE,RequiredFile,DIRNAM,REASON,DEV,DIRNAMSAV,MIRDBINFO)
 try {
   s mObj={}
   s mObj.manifestVersion="1.0"
   s mObj.type=$g(TYPE)
   s mObj.description=$g(DESCRIPTION)
   s mObj.timestamp=$s($d(BACKHDATE):$zdt(BACKHDATE,3,7),1:"")
   s mObj.firstJournalForRecovery=$g(RequiredFile)
   s mObj.instanceId=##class(%SYS.System).InstanceGUID()
   s mObj.instanceName=##class(%SYS.System).GetInstanceName()
   s mObj.instanceDirectory=$SYSTEM.Util.InstallDirectory()
   s mObj.instanceHost=##class(%SYS.System).GetNodeName(1)
   s mObj.instanceVersion=$zv
   s mObj.databases=[]
   s dir="" f  { ;backed up databases are in DIRNAM
     s dir=$o(DIRNAM(dir)) q:dir=""
     s alldirs(dir)=""
   }
   s dir="" f  { ;failed databases are in REASON
     s dir=$o(REASON(dir)) q:dir=""
     s alldirs(dir)=""
   }
   s dir="" f  {
     s dir=$o(alldirs(dir)) q:dir=""
     s dbObj={}
     s dbObj.directory=dir
     i $d(REASON(dir)) { ;this database failed
       d dbObj.%Set("statusOK",0,"boolean")
       s dbObj.statusText=$System.Status.GetErrorText(REASON(dir))
       s dbObj.backupDirectory=""
       s dbObj.backupFile=""
       s dbObj.mirrorName=""
       s dbObj.volumes=[]
       d mObj.databases.%Push(dbObj)
       continue
     }
     d dbObj.%Set("statusOK",1,"boolean")
     s dbObj.statusText=""
     s dbObj.backupDirectory=$p(DIRNAMSAV(dir),",",2)
     s dbObj.backupFile=##class(%Library.File).GetFilename(DEV(dir))
     s dbObj.mirrorName=$s($l(MIRDBINFO(dir)):":mirror:"_$p(MIRDBINFO(dir),":",6)_":"_$p(MIRDBINFO(dir),":",1),1:"")
     s dbObj.volumes=[]
     s sfn=+$lg(DIRNAMSAV(dir,"DBINFO"),1)
     s blksize=+$lg(DIRNAMSAV(dir,"DBINFO"),2)
     s totvol=+$lg(DIRNAMSAV(dir,"DBINFO"),3)
     s volnumblks=$lg(DIRNAMSAV(dir,"DBINFO"),4)
     s dirlist=$s(totvol>1:$li($system.DB.GetMultiVolDirList(dir),2,*),1:"")
     f i=1:1:totvol {
       s volObj={}
       i i=1 {
         s voldir=dir
       } else {
         try { s voldir=$lg(dirlist,+$li($system.DB.GetVolInfo(sfn,i-1)),dir) }
         catch { s voldir=dir } ;realistically should never get here
       }
       s blks=$p(volnumblks,",",i)
       s volObj.file=$s(i=1:"IRIS.DAT",1:("IRIS-"_$extract("000"_+(i-1),*-3,*)_".VOL"))
       s volObj.sizeMB=blks*blksize/1048576
       i volObj.sizeMB#1 s volObj.sizeMB=volObj.sizeMB\1+1 ;round up
       s volObj.restoreTo=voldir
       d dbObj.volumes.%Push(volObj)
     }
     d mObj.databases.%Push(dbObj)
   }
   o manifest:"WNSK\UTF8\":5
   return:'$t $$Error^%apiOBJ(7351)
   s opened=1
   i ($zversion(1)=3) d $zu(140,8,manifest,256+32)
   u manifest
   s formatter=##class(%JSON.Formatter).%New()
   s sc=formatter.Format(mObj)
   c manifest
   s opened=0
   return:('sc) $$Error^%apiOBJ(7352,$System.Status.GetErrorText(sc))
   return 1
 } catch {
   i $g(opened) c manifest
   s ze=$ze,$ze=""
   return $$Error^%apiOBJ(7352,ze)
 }
RecordLastPassDBInfo(dbdir,bkpdev,dbinfo) {
 try {
   k dbinfo ;in case it contained anything previously
   s params=$zu(32,10,dbdir) ;dkvolinfo() output parameters
   i params<0 { ;should not happen, but not much we can do...
     s func="$zu(32,10,"_dbdir_")"
     return $$Error^%apiOBJ(5039,func)
   }
   s sfn=+params ;sfn from $zu(32,10)
   s blksize=+$p(params,",",2) ;blksize in bytes from $zu(32,10)
   s totvol=+$p(params,",",15) ;total # of volumes from $zu(32,10)
   s blksinfile=+$p(params,",",22) ;blksinfile from $zu(32,10)
   f i=1:1:totvol { ;save the final size of each volume
     s volinfo=$system.DB.GetVolInfo(sfn,i-1)
     i i<totvol {
       s blks=$li(volinfo,3)-$li(volinfo,2)+1
     } else {
       s blks=blksinfile-$li(volinfo,2)+1
     }
     s $p(volnumblks,",",i)=blks ;blks in vol
   }
   s cdate=$p($zu(49,dbdir,6),",",2,3) ;file creation date (high,low)
   s filedata=$lb(dbdir,params,volnumblks,cdate)
   s lpfile=$p(bkpdev,".",1,*-1)_".lastpass" ;change file extension
   o lpfile:"WNU":5
   return:'$t $$Error^%apiOBJ(5005,lpfile)
   s opened=1
   i ($zversion(1)=3) d $zu(140,8,lpfile,256+128+32+16) ;same as .bck
   u lpfile
   w $lb($zcrc(filedata,7),filedata)
   c lpfile
   s opened=0
   s dbinfo=$lb(sfn,blksize,totvol,volnumblks)
   return 1
 } catch {
   i $g(opened) c lpfile
   s ze=$ze,$ze=""
   return $$Error^%apiOBJ(5002,ze)
 }
}
ZU(A,B,C,D,E,F,G,H,I,J,K,L,M,N,P) ;so needn't change $$ZU's to $ZU's
 IF '$D(B) Q $ZU(A)
 IF '$D(C) Q $ZU(A,B)
 IF '$D(D) Q $ZU(A,B,C)
 IF '$D(E) Q $ZU(A,B,C,D)
 IF '$D(F) Q $ZU(A,B,C,D,E)
 IF '$D(G) Q $ZU(A,B,C,D,E,F)
 IF '$D(H) Q $ZU(A,B,C,D,E,F,G)
 IF '$D(I) Q $ZU(A,B,C,D,E,F,G,H)
 IF '$D(J) Q $ZU(A,B,C,D,E,F,G,H,I)
 IF '$D(K) Q $ZU(A,B,C,D,E,F,G,H,I,J)
 IF '$D(L) Q $ZU(A,B,C,D,E,F,G,H,I,J,K)
 IF '$D(M) Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L)
 IF '$D(N) Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L,M)
 IF '$D(P) Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
           Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L,M,N,P)
MORE Q
INLOGOR(DIR,SOURCE,TARGET,DISPOSE) ;Adapter, present same i'face for VAX & UX
 n rc
 try {
   s rc=$ZU(31,DIR,SOURCE,TARGET,DISPOSE)
 } catch {
   s rc=-1_","_$ze
   s $ze=""
 }
 q rc
FILENORM(NAME) ;Return normalized version of NAME
 S OK=1,$ZT="FNERR"
 N MTDEV,DIR S MTDEV=$$OSDEVICE(NAME) I MTDEV'="" S ISREG=0 Q NAME
 i ($zversion(1)=2),$E(NAME,1,2)="\\" S L=$$CheckForTape(NAME) I L'="" S ISREG=0 Q L
 i ($zversion(1)=2) S L=$L(NAME,"\"),DIR=$P(NAME,"\",1,L-1)
 i ($zversion(1)=2) IF L>1 S DIR=DIR_"\"
 i ($zversion(1)=2) S NAME=$ZU(12,DIR)_$P(NAME,"\",L,L),ISREG=$ZU(140,7,NAME),ISREG=$S(ISREG>0:1,ISREG=-2:1,1:0) Q NAME
 i ($zversion(1)=3) S L=$L(NAME,"/"),DIR=$P(NAME,"/",1,L-1)
 i ($zversion(1)=3) IF L>1 S DIR=DIR_"/"
 i ($zversion(1)=3) S NAME=$ZU(12,DIR)_$P(NAME,"/",L,L),ISREG=$ZU(140,7,NAME),ISREG=$S(ISREG=-2:1,ISREG/32768#2:1,1:0) Q NAME
FNERR S OK=0,ERRMSG="Not a valid device name." Q
CheckForTape(NAME)
 S NAME=$ZCVT(NAME,"U")
 N I,TAPE
 For I=47:1:62 s TAPE=$$OSDEVICE(I) I NAME=$ZCVT(TAPE,"U") S NAME=I Q
 I NAME?2N Q NAME
 I NAME?1"\\.\TAPE"1N Q NAME
 Q ""
TQUIWRITE(verbose) q $$QUIESCE(1,"buffer activity",10,verbose)
TQUIGC(verbose) q $$QUIESCE(2,"garbage collection",10,verbose)
TQUIDB(verbose) q $$QUIESCE(4,"database expansion",10,verbose)
TQUIGLO(verbose) q $$QUIESCE(8,"global activity",10,verbose)
TQUIGLOUPD(verbose) q $$QUIESCE(16,"global updates",10,verbose)
TQUINET(verbose) q $$QUIESCE(32,"network activity",10,verbose)
TQUIDISK(verbose) q $$QUIESCE(1+2,"disk activity",10,verbose)
TQUIUPD(verbose) q $$QUIESCE(1+2+4+16,"update activity",10,verbose)
TQUISYS(verbose) q $$QUIESCE(1+2+4+8,"system activity",10,verbose)
QUIESCE(bits,text,retries,verbose,intv) ;
 s verbose=+$g(verbose),retries=+$g(retries,-1),intv=+$g(intv,1)
 q ($$Quiesce(bits,text,retries,verbose,intv)>0)
Quiesce(bits,text,retries,verbose,intv) ;
 n noWDbits
 s $zt="QUIESCEE"
 q:$zu(51,bits) 1 ;double checking $ZU(51) is no longer necessary
 s verbose=+$g(verbose),retries=+$g(retries,-1),intv=+$g(intv,1)
 d msgout($c(13,10)_"WARNING: Switch is set and may affect production for up to "_(retries*intv)_" seconds."_$c(13,10)_"Waiting for "_text_" to finish...",NOFORCE)
 f  q:'retries  h intv q:$zu(51,bits)  s retries=retries-1 i retries#5=0 d msgout(".",NOFORCE)
 s noWDbits=1
 s:$s($S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0):''$zu(59,0),1:0) noWDbits=noWDbits+2
 s noWDbits=$zboolean(bits,noWDbits,2)  ;2 = x & ~ y
 if '$ZU(51,bits),bits'=1,$zboolean(bits,1,1),$zu(51,noWDbits) {
	 d msgout($c(13,10)_"System is idle except WD is still running."_$c(13,10)_"     Waiting up to 2 minutes for WD to finish",NOFORCE)
	 f i=1:1:120 q:$ZU(51,bits)  h 1 if i#5=0 d msgout(".",NOFORCE)
	 if $ZU(51,bits) s retries=1 ;signal success
 }
 d msgout($s(retries:" ready.",1:" abort. "_$$quiescefailmsg(bits))_$c(13,10),NOFORCE)
 q retries
quiescefailmsg(bits)
 N ret,clu,clumsg s ret="",clu=$zb(bits,512+256+128,1),clumsg=""
 if $zb(clu,128,1)||($zb(clu,(256+512),1)=(256+512)) s clu=128,clumsg=" (cluster wide)"
 if $zb(clu,512,1) s clumsg=" (cluster master only)"
 if $zb(clu,256,1) s clumsg=" (cluster slaves only)"
 if $zb(bits,1,1)&&('$ZU(51,clu+1)) S ret=ret_"write daemon"_clumsg_","
 if $zb(bits,2,1)&&('$ZU(51,clu+2)) S ret=ret_"garbage collector"_clumsg_"," 
 if $zb(bits,4,1)&&('$ZU(51,clu+4)) S ret=ret_"file expander"_clumsg_","
 if $zb(bits,8,1)&&('$ZU(51,clu+8)) S ret=ret_"global reference"_clumsg_","
 if $zb(bits,16,1)&&('$ZU(51,clu+16)) S ret=ret_"global update"_clumsg_","
 if $zb(bits,32,1)&&('$ZU(51,clu+32)) S ret=ret_"client-side network connections"_clumsg_","
 if $zb(bits,64,1)&&('$ZU(51,clu+64)) S ret=ret_"network server activity"_clumsg_","
 if ret'="" s ret="Quiesce failed reason: "_$e(ret,1,*-1) d $zu(9,"",ret,1,2) i $d(^rOBJ("ZQuiesceFail")) d ^ZQuiesceFail
 Q ret
QUIESCEE s $zt="" d $zu(9,"","QUIESCE: "_$ze,(1>0),1) q -1 ;0
CluQuiet(switch,target,timeout)
 n flags,rc
 i $g(switch)-10,$g(switch)-13 ztrap "SWITCH"
 n targetmsg s target=$g(target)
 i target=1 s target=256,targetmsg=" on cluster slave members"
 e  i target=2 s target=512,targetmsg=" on cluster master"
 e  s target=512+256,targetmsg=" cluster wide"
 s flags=1+2+4+$s(switch=10:8,1:16)
 s rc=$$Quiesce(flags+target,$s(switch=10:"system activity",1:"update activity")_targetmsg,$g(timeout,10),'$g(QUIET,$g(QUIETLY)))
 i rc<0 ztrap "Abort"
 q rc
quietsw(switch,timeout) ;quiesce activities w/ timeout after setting switch 10 or 13
 n flags,rc
 i $g(switch)-10,$g(switch)-13 ztrap "SWITCH"
 s flags=1+2+4+$s(switch=10:8,1:16)
 i CLUBACKUP s flags=flags+128
 s rc=$$Quiesce(flags,"disk cleanup",$s($g(timeout)="":30,1:timeout),'$g(QUIET))
 i rc<0 ztrap "Abort"
 q rc
hibernate(switch,released,timeo) ;
 i +$g(released) d msgout($c(13,10)_"Switch "_switch_" is released.",NOFORCE)
 n hibtime s hibtime=$s(timeo>3:10,timeo>2:1,timeo>1:.1,timeo>0:.01,1:10)
 d msgout($c(13,10)_"Backup will hibernate for "_hibtime_" second(s) and try again."_$c(13,10)_"You may abort Backup via Ctrl-C. ",NOFORCE) 
 i hibtime<1 h hibtime
 e  n i f i=1:1:hibtime h 1 d msgout(".",NOFORCE)
 d msgout($c(13,10),NOFORCE)
 q
ENQ10 ;
 n t s t=$g(quietimeout,60) s:t>0 t=(t+9)\10 ;rounded up to 10 sec
 s $zt="ENQ10e"
 i CLUBACKUP d  q
 . f  q:$$CLU^SWSET(10,1,ALRDY10,$g(QUIETMASTERONLY))  s t=t-1 zt:'t "Abort" d hibernate(10,'ALRDY10,t)
 i ALRDY10 q:$$quietsw(10)  zt "Abort"
 f  S %SW=10,%VAL=1 D INT^SWSET  q:$$quietsw(10)  s t=t-1 zt:'t "Abort" d DEQ10,hibernate(10,1,t)
 Q
ENQ10e s $zt="" d DEQ10 ztrap $ze
DEQ10 ;
 i CLUBACKUP,$ZU(95,10,0)  ; Clear SW10 clusterwide
 i 'ALRDY10 s %SW=10,%VAL=0 D INT^SWSET
 Q
ENQ13 ;
 n t s t=$g(quietimeout,60) s:t>0 t=(t+9)\10 ;rounded up to 10 sec
 s $zt="ENQ13e"
 i CLUBACKUP d  q
 . f  q:$$CLU^SWSET(13,1,ALRDY13)  s t=t-1 zt:'t "Abort" d DEQ13,hibernate(13,'ALRDY13,t)
 i ALRDY13 q:$$quietsw(13)  zt "Abort"
 f  S %SW=13,%VAL=1 D INT^SWSET  q:$$quietsw(13)  s t=t-1 zt:'t "Abort" d DEQ13,hibernate(13,1,t)
 Q
ENQ13e s $zt="" d DEQ13 zq 1 g:$zt'="" @$zt q
DEQ13 ;
 i CLUBACKUP,$ZU(95,13,0)  ; Clear SW13 clusterwide
 i 'ALRDY13 s %SW=13,%VAL=0 D INT^SWSET
 Q
HOLDWD(dir,time,flag) ;suspend write daemon (dir may be passed as an array)
 n n
 i $zu(182,1,0) ;clear any remaining backup request
 f  q:'$zu(182,0)  h 1  ;wait until write daemon runs again
 i $d(dir)<10 d $zu(52,9,dir,1) d:$g(flag)=1 $zu(52,8,dir,0) d $zu(182,2,0,+$zu(49,dir)) s n=1 i 1
 e  s dir="" f n=0:1 s dir=$o(dir(dir)) q:dir=""  d $zu(52,9,dir,1) d:$g(flag)=1 $zu(52,8,dir,0) d $zu(182,2,n,+$zu(49,dir))
 i $zu(182,1,n,$g(time))  ;set number of databases to back up (and optional CP wait time)
 f  q:$zu(182,0)  h 1  ;wait until write daemon suspends
 q
FREEWD ;unsuspend write daemon
 i $zu(182,1,0)
 q
msgout(aaamess,flag) ;
         s flag=$g(flag,1) ; default to FORCE
         W *-1            ;Flush the input buffer 
         q:'$L(aaamess)   ; Avoid argumentless writes...
         i $g(logfile)'="" u logfile w aaamess
         u 0
         q:flag=3  ; 1 = FORCE, FORCE, 2 = NOFORCE, 3 = LOGONLY
         i '$G(INTERNAL,0)!('$G(NOINPUT,0)&(flag=1!'$G(QUIET,0))) w aaamess
         i $g(gui) D  
         . s return=$$IjcMsg^%Wprima("DI"_aaamess) ; Retval might =  cancel msg
         . i return="CANCEL" d  
         . . i $$IjcMsg^%Wprima("DI"_$c(13,10)_"Abort received!"_$c(13,10))
         . . zt "Abort"
         u 0 
         q
timestmp(flag) 
         n msg,%TS,%TN
         s msg="TIMESTAMP: "
         s %DN=+$H d INT^%DO
         s msg=msg_%DS
         s %TN=$P($h,",",2) d ^%TO
         s msg=msg_" "_%TS
         d msgout($c(13,10)_msg_$c(13,10))
         q
OSDEVICE(mdevice,new) ;osdevice + range check, pad input, strip output.
 s mdevice=+mdevice q:mdevice<47 ""  q:mdevice>62 ""
 i $d(new) s new=$$zpad(new,32)
 q $$zstrip($$osdevice(mdevice,.new))
osdevice(mdevice,new) ;"Raw" osdevice
 n adr,old,size,where,charsize
 s $ZT="osdeverr"
 s charsize=$$charsize^%Wprim() ; check size one char
 s size=32,adr=(mdevice-47)*(size*charsize)+$ZU(40,2,28),where=-2
 s old=$v(adr,where,-size_"w")
 i $d(new) v adr:where:-size_"w":new
 q old
osdeverr q ""
zstrip(x) ;Return x with ASCII NUL's removed
 q $tr(x,$c(0),"")
zpad(x,len) ;x, maybe truncated, NUL-padded to length len, one NUL guaranteed
 n zeroes
 s zeroes=$j("",len),zeroes=$tr(zeroes," ",$c(0)) ;String of len NUL's
 s x=$e(x,1,len-1) ;Silently truncate x if necessary
 s $e(zeroes,1,$l(x))=x
 q zeroes
YN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YN"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"yn","YN") I "^YN"'[R W "  enter Yes or No, please"
 S POP=(R="^") W $E($S(R="N":"No",R="Y":"Yes",1:""),$L(X)+1,3) Q R

DBREST^INT^1^67214,47330
DBREST ;Incremental Backup Restore ;$Change: 7440104 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ; Revision: $Id: //iris/2024.1.3/databases/sys/rtn/user/dbrest.mac#1 $
MAIN k  D ^DBRTEXT G main     ;Entry point for D ^DBRTEXT
ALL N dbrtext D ^DBRTEXT G all      ;Entry point from menu
SELECT N dbrtext D ^DBRTEXT G select   ;Entry point from menu
VOLUMEINFO g volumeinfo
main d Show("title")
 i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
 ; Set up display text in DBRTEXT ;AN038         
ASKRES D Show("ASKRES") r !,"    1 => ",R S:R="" R=1 Q:$$STOP(R)  S R=$E(R)
 I "1234"'[R w " ?? Type the number of the function you want",! g ASKRES
 W ! S RESTYPE=R G all:RESTYPE=1,select:RESTYPE=2,volumeinfo:RESTYPE=3
 Q
NOJRN G all ; ***REMOVED ENTRYPOINT
EXTALL(QUIETMODE,ALLOWUPD,INPDEV,DIRLIST,JRNOPT,JRNFILE,JDIRGLO) 
 S $ZE="",JRNOPT=$E($G(JRNOPT))
 i $zj\2#2 s %UI="CHUI" ;jobbed job
 n dlmlock ;JO1991
 I 1_2_3_4'[JRNOPT S RC=-5 G begin2
 I JRNOPT=3 I JDIRGLO="" S RC=-6 G begin2
 i '$SYSTEM.Security.Check("%Admin_Manage","USE") s RC=-7 g begin2
 G all
all ;
 i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
 N TopDir
 n RESTYPE,X,DEJRNSTART
 I $G(QUIETMODE) S RESTYPE="ALL" G BEGIN
 W !,"Proceed with restoring ALL directories" S X=$$YESNO(1) W !
 G ASKRES:'X
 n dirdlm s dirdlm=$s(($zversion(1)=2):"\",($zversion(1)=3):"/",1:"")
TopDir ;
 W !,"Top directory for all Databases to be restored to (? for Help)?" R TopDir W !
 I TopDir="?" D  G TopDir
 . W !,"Enter the top path you want all the databases to be restored to."
 . W !,"The system will prefix it to the original path of the DB to be restored."
 . W !,"So all the DBs will be restored under this directory with their original"
 . W !,"directory as sub-directory to this directory."
 . W !,"Press RETURN to ignore it and restore the DBs to their original path.",!
 I TopDir'="" s TopDir=$zu(12,TopDir) I TopDir=""!($e(TopDir,*)'=dirdlm) W !,"Bad path!!",! G TopDir
 s RESTYPE="ALL" g BEGIN
EXTSELCT(QUIETMODE,ALLOWUPD,INPDEV,DIRLIST,JRNOPT,JRNFILE,JDIRGLO) 
 S $ZE="",JRNOPT=$E($G(JRNOPT))
 i $zj\2#2 s %UI="CHUI" ;jobbed job
 n dlmlock ;JO1991
 I 1_2_3_4'[JRNOPT S RC=-5 G begin2
 I DIRLIST="" S RC=-4 G begin2
 I JRNOPT=3 I JDIRGLO="" S RC=-6 G begin2
 i '$SYSTEM.Security.Check("%Admin_Manage","USE") s RC=-7 g begin2
 S SELFILE=$ZU(12,DIRLIST)
 S $ZT="SELERR"
 s $ZE="" 
 O SELFILE:"R":5 
 I $T { 
	 U SELFILE 
     F I=1:1 {
	     R SELDIR(I) 
	     I $ZEOF {
		     S $ZE="<ENDOFFILE>" 
		     G @$ZT
	     }
     }
 } else {
	 s RC=-4
	 goto begin2
 }
SELERR ;
 I $ZE'["<ENDOF" {
	 S RC=-4 
	 try {
		 close SELFILE
	 } catch {}
	 G begin2
 }
 C SELFILE:"D" 
 S $ZT="" 
 G select
 ; EXTERNAL ENTRYPOINT: ask each directory name and allow
 ; renaming the directories
select ; Determine what is probably the journal directory
 i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
 N TopDir
 n RESTYPE,X,DEJRNSTART
 S RESTYPE="SELECT" G BEGIN
BEGIN ;
 S logfile=""  ; Do not log the text of the backup
 ;S logfile="d:\backup\log4xrst.txt"  ; Log the text of the backup
 i logfile'="" d  ;i 'OK q 0   ; signals an error condition   
 . o logfile:"WNS":5
 . e   w !,"Error opening log file ",logfile,! s OK=0
 ; Some external entry points don't set this up so do it now
 i '$d(dbrtext) d ^DBRTEXT
 N mtemp1 M mtemp1("menuse",$j)=^mtemp1("menuse",$j)
 s DEJRNSTART=""
 G BEGIN^DBREST2
finish ; DBREST1 goes here
 M ^mtemp1("menuse",$j)=mtemp1("menuse",$j)
 n mirlist  ;SML1106
 D remount
 D JRNIN ; dejournal
 ; moved here from DBREST1, DBREST1 goes here
begin2 D CLEAR10:'$G(ALREADY) ; clear switch 10 if we set it
 i $g(mirlist,"")'="" {
   s ndir=""
   i $G(ALREADY) {
		w !,"Skiping catchup of mirrored DBs because switch 10 is set."
		w !,"Use ^JRNRESTO or ^MIRROR later when switch 10 has been cleared."
   } else {
 		i ($SYSTEM.Mirror.GetInfo()'[",DEFINED,") {
			if $V($ZU(40,2,93),-2,1)'=0 {
				do MirrorCatchup^JRNRESTO()
				goto restoreComplete
			}
	 		if $G(QUIETMODE) {
		 		s ndir=$G(^%SYS("JOURNAL","CURDIR"))
	 		} else {
	 			w !!,"There are mirrored DBs restored, please make sure the mirror"
	 			w !,"journal files are copied to a specific directory in order to"
	 			w !,"let system restore the journal records."
	 			w !,"Please enter the directory contains the mirror journal files:"
	 			w !,"<",$G(^%SYS("JOURNAL","CURDIR")),">? "
	 			r ndir 
	 			i ndir="" s ndir=$G(^%SYS("JOURNAL","CURDIR")) w ndir
	 		}
 			s ndir=$LB($zu(12,ndir))
 	   	}
 		n rc,errlist,sfn,i
 		s rc=##class(SYS.Mirror).CatchupDB(mirlist,ndir,.errlist)
 		if 'rc {
	 		w !,"*** WARNING **** Failed to restore the journal records for the mirrored DBs"
 		} else {
	 		if '$LL(errlist) {
 				w !,"Journal records for mirrored DBs were restored successfully."
	 		} else {
		 		w !,"Journal records for the following databases were successfully restored"
		 		k sfnlist
		 		f i=1:1:$LL(mirlist) s sfnlist($LG(mirlist,i))=""
		 		f i=1:1:$LL(errlist) k sfnlist($LG(errlist,i))
		 		s sfn=""
		 		for  {
			 		s sfn=$O(sfnlist(sfn))
			 		q:sfn=""
			 		w !,?5,$P($ZU(49,+sfn,3),"^",2)
		 		}
		 		w !,"The following databases were not successfully restored"
		 		f i=1:1:$LL(errlist) {
			 		s sfn=$LG(errlist,i)
			 		w !,?5,$P($ZU(49,+sfn,3),"^",2)
		 		}
 			}
   		}
 	}
 }
restoreComplete ; JO2538
 Try {d $zu(52,0)} catch {}  ;STC2150
 i $V($ZU(40,2,82),-2,4)=+$ZU(61,30,$ZU(61)) V $ZU(40,2,82):-2:4:0     ;JAO580,HYY302,JO1984
 M ^mtemp1("menuse",$j)=mtemp1("menuse",$j)
 K %ST
 n ndir,dd,mf s dd="" f  s dd=$o(DIRNAM(dd)) q:dd=""  s mf=+$p(DIRNAM(dd),"^",3) d:mf
 . s ndir=$p(DIRNAM(dd),"^") i ndir="" s ndir=dd
 . if $$isMirroredDb^MIRRORMGR(ndir) q
 . i mf=$zu(40,0,41) q  ;don't dismount if it was unmounted (NOT dismounted)
 . d DISMOUNT^DBREST2(ndir)
 . i mf=2 d $zu(17,ndir,1)
 do releaseLock^DBACK(.dlmlock)
 Q:'$G(QUIETMODE)  K SELDIR,JDIR,JDIRECTORY S:+RC=1 RC=3 Q +RC
remount n ndir,dir,runmir,dbobj,status,rc
 s dir="",mirlist="",runmir=($SYSTEM.Mirror.GetInfo()[",DEFINED,")
 f  s dir=$o(dejrn(dir)) q:dir=""  d
 . S ndir=$G(dejrn(dir)),ndir=$P(ndir,",",2,$L(ndir)) S:ndir="" ndir=dir
 . s dbobj=##Class(SYS.Database).%OpenId(ndir,,.status)
 . q:'status
 . w !,"Mounting ",ndir i dbobj.Mirrored w " which is a mirrored DB"
 . d ONE^MOUNT(ndir)
 . i dbobj.Mirrored d
 . . if runmir&&('dbobj.InActiveMirror)&&dbobj.MirrorNoWrite d  q:'+rc
 . . . s rc=$SYSTEM.Mirror.DBActivate(ndir)
 . . . if '+rc W !,"Warning! Failed to activate mirrored DB ",ndir," due to ",$p(rc,",",2) k dejrn(dir) q
 . . . d:##class(Config.MirrorMember).IsReadWriteReportingMember() $SYSTEM.Mirror.ClearFailoverDBFlag(ndir)
 . . . d ##Class(%SYS.Audit).WriteToAuditFile("%System","%System","ConfigurationChange",ndir,"Activate mirrored database "_dbobj.MirrorDBName)
 . . s mirlist=mirlist_$lb(+$zu(49,ndir)) k dejrn(dir)
 q
JRNIN Q:$O(dejrn(""))=""  S $ZT="JX^"_$ZN
 f i=0:1:$l($g(DEJRNSTART),$C(13,10))-1 d
 . s DEJRNSTART(i)=$p(DEJRNSTART,$C(13,10),i+1)
 . i +DEJRNSTART(i)'>0 w:DEJRNSTART(i)]"" !,*7,"[Invalid journal marker] ",DEJRNSTART(i),! k DEJRNSTART(i) q 
 s node=$name(^SYS("RESTORE","BACKUP",$zdt($h,8)))
 s @node@("device")=$g(INCDEV)
 s @node@("backtime")=$g(BACKH)
 m @node@("databases")=dejrn
 m @node@("jrnmarker")=DEJRNSTART
 m @node@("CLSTATE")=CLSTATE
 i CLUBACKUP,$D(QUIETMODE) s QUIETMODE=0  ; off for clu restore
  I $G(QUIETMODE) DO  Q
 . S fromrest=JRNOPT,restjrn=$G(JRNFILE)
 . I fromrest=4 s RC=3 W !,*7,"[Journal not applied to any directory]",! Q
 . S RC=1 I JRNOPT=3 S RC=$$GETJDIR(JDIRGLO)
 . I RC=1 G jrnin2
 ;
 i CLUBACKUP d
 . w !!,"The backup that was restored contains directories that were"
 . w !,"cluster mounted when the backup was performed. If you restore"
 . w !,"the journal you must be sure to specify the journal files"
 . w !,"in use by the other cluster members when the backup was "
 . w !,"performed in addition to the journal file for this system "
 . w !,*7
 W ! D Show("JRNIN0")
jrnin1 ;
 D Show("JRNIN1") R R S R=$E(R_1) I "1234"'[R DO  G jrnin1
 . w " ??? Type the number of the function you want",!
 i CLUBACKUP,R=2 d  g jrnin1
 . w !,"You cannot restore the entire journal when the backup"
 . w !,"   contains clustered databases because that journal restore"
 . w !,"   function does not support the restoration from multiple"
 . w !,"   journal files"
 S fromrest=R I fromrest=4 Q
jrnin2 ; restore journal and rollback transactions
 i $d(DEJRNSTART) d
 . n i
 . w !!,"We know something about where journaling was at the time of the backup:",!
 . s i="" f  s i=$o(DEJRNSTART(i)) q:i=""  w i,": ","offset "_+DEJRNSTART(i)_" in "_$p(DEJRNSTART(i),",",2),!
 . i CLUBACKUP s DEJRNSTART=""  ;cluster: don't know which one is primary system
 . e  s DEJRNSTART=$g(DEJRNSTART(0)) ;just to be safe
 G INT^JRNRESTO ; restore journal and rollback transactions
JX Q
GETJDIR(dev) ;modifies 'dejrn', and 'JDIR'
 N II,JJ,XX,ALL,dir S $ZT="JDIRERR^"_$ZN O dev:"R":5 E  Q -6
 F II=1:1 U dev R JDIR(II) ;read in directories to restore journal
 ;
JDIRERR K dejrn S $ZT="" F II=1:1 Q:'$D(JDIR(II))  S XX=JDIR(II) DO
 . S dir=$P(XX,",") Q:dir=""  S dir=$ZU(12,dir),ALL=$E($P(XX,",",2)_"?")
 . I "Yy"[ALL K dejrn(dir) S dejrn(dir)=1 Q  ;all globals in directory
 . I "Nn"[ALL DO  ;selected entries in directory -- specific globals
 . . N g S g=$G(dejrn(dir)),$P(g,",")=0,dejrn(dir)=g ;mark as *not-all*
 . . F JJ=3:1 S g=$P(JDIR(II),",",JJ) Q:g=""  S dejrn(dir,g)=1_""""_g_"""" ;globals
 C dev Q 1
volumeinfo
 n
 S DEV=$G(^SYS("BACKUP","LASTFULL","DEVICE"))
 w !
 w !,"Enter the backup volume you want to display information from"
 W !," (Type STOP to exit)"
 W !,"Device: " W:DEV]"" DEV_" => " R ANS,! S:ANS]"" DEV=ANS
 I DEV=""!$$STOP(ANS) Q
 s Status=##Class(Backup.General).GetBackupVolumeInfo(DEV,.Info)
 i '(''Status) {
	 d $SYSTEM.OBJ.DisplayError(Status)
	 q
 }
 w !,"This backup volume was created by:"
 w !,Info("CacheVersion")
 w !
 w !,"The volume label contains:"
 w !,?3,"Volume number",?23,Info("BackupVolume")
 w !,?3,"Volume backup",?23,Info("BackupDate")," ",Info("BackupTime")," ",Info("BackupType")
 w !,?3,"Previous backup",?23,Info("PrevBackupDate")," ",Info("PrevBackupTime")," ",Info("PrevBackupType")
 w !,?3,"Last FULL backup",?23,Info("LastFullBackupDate")," ",Info("LastFullBackupTime")
 w !,?3,"Description",?23,Info("Description")
 w !,?3,"Buffer Count",?23,Info("BufferCount")
 s Mirror=0
 i $d(Info("MirrorName")) {
	w !,?3,"Mirror name",?23,Info("MirrorName")
	w !,?3,"Failover member",?23,Info("FailoverMember")
	s Mirror=1
 }
 i $d(Info("AsyncMember")) {
	 w !,?3,"Async mirror member",?23,Info("AsyncMember")
	 s Mirror=1
 }
 w !,?3,"Journal File",?23,Info("JournalFile")
 w !,?3,"Log file",?23,Info("LogFile")
 w !,?3,"Backup Status",?23,Info("Status") 
 s Index="",Cluster=0
 f  {
	s Index=$o(Info("Database",Index)) q:Index=""
 	i Info("Database",Index,"ClusterFlag")'="P" {
 		s Cluster=1
 		quit
 	}
 }
 s ClusterOff=68
 i Cluster,'Mirror s ClusterOff=49
 w !
 w !,"Database",?40,"Size(mb)"
 i Mirror w ?49,"Mirror DB Name"
 i Cluster w ?ClusterOff,"Mount Status"
 w !,"--------",?40,"--------"
 i Mirror w ?49,"--------------"
 i Cluster w ?ClusterOff,"------------"
 s Index="",TotalSize=0
 f  {
	s Index=$o(Info("Database",Index)) q:Index=""
 	s Count=Index
 	w !,Info("Database",Index,"Directory")
 	i $x>40 w !
 	s Size=$p(Info("Database",Index,"ZU49"),",",4)
 	w ?40,$j(Size,8)
 	s TotalSize=TotalSize+Size
 	i Mirror w ?49,$g(Info("Database",Index,"Mirror","dbname"))
	i Cluster w ?ClusterOff,$case(Info("Database",Index,"ClusterFlag"),"P":"Private",:"Clustered")
 }
 w !,"Total of "_Count_" databases, totaling "_TotalSize_" mb"
 w !,"Backup volume size is "_Info("Size")_" mb"
 g volumeinfo
 ;uppercase function
UC(x) q $zcvt(x,"u")
 ;check  for stop text function
STOP(x) S x=$$UC($E(x,1,4)) Q (x["EXIT")!(x["STOP")!(x["QUIT")!(x["HALT")!($E(x)="^")
YESNO(a) N v,b S a=$G(a)  F  DO  Q:$D(v)
 . W *-1,$S(a:" Yes",1:" No")_" => " R b I b="" S v=a Q
 . S b=$TR($E(b),"yn","YN") I "YN"[b S v=(b="Y") Q
 . W *7," [answer Yes or No, please]" I $x>68 W !
 Q v
Show(item,p1,p2,p3,p4) ;
 n d,i,p0,p,tx s d="#",tx=$g(dbrtext(item))
 i tx="" w !,*7,"MISSING DBRTEXT ITEM ",item
 e  f i=0:1:4 s p="p"_i w $p(tx,d,i),$g(@p)
 h 0 q 
SWSET   do $SYSTEM.Util.SetSwitch(%SW,%VAL)
	quit
SET10   do $SYSTEM.Util.SetSwitch(10,1)
        quit
CLEAR10 do $SYSTEM.Util.SetSwitch(10,0) 
        quit
CHECK10() n res
	s res=$SYSTEM.Util.GetSwitch(10)
	if '+res quit 0  ; not owned
	if +$P(res,",",2)'=+$J quit 0  ; not owned by us
	quit 1  ; set and owned by us

DBREST2^INT^1^67214,47330
DBREST2 ;Incremental Backup Restore (continued) ;$Change: 7440104 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ; Revision: $Id: //iris/2024.1.3/databases/sys/rtn/user/dbrest2.mac#1 $
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/_syMirror.inc#1 $ ($Change: 7440104 $) */
        /* Initializing is the state a member has at startup until it
           gets to wait^MIRRORMGR for the 1st time. At that point it has 
           either become the backup or primary or we set the role to null
           to indicate that it is up and running as opposed to still getting
           started */
				    /* Arbiter failover rules are in effect */
				    /* Agent contact is required */
					/* IsOtherNodeDown^ZMIRROR */
				/* The client supports the arbiter */
			 	/* This system is connected to the arbiter */
		  		/* The other failover member is connected to the arbiter */
		  		/* Either the QOSTimeout changed or the arbiter address changed.
		  		   we should look up the current values and use them */
				/* Arbiter job shoud close the connection and exit. The
				   retry routine can restart the arbiter if conditions
				   warrent. Generally used with clearing ArbiterSupported
				   when the backup is removed or demoted. Cleared when
				   the arbiter exits (eg. its a one time flag). */
  ;#if $$$NEWINC   ; CFL284+       
  ; start the restore
BEGIN ;
 n %DIR,%SYSDIR,ALREADY,ANS,BACKSET,DELIM,DEV,DIR,INCDEV,OK,OURDIR
 n PREVDATE,PREVFDATE,PREVFTIME,PREVH,PREVTIME,PREVTYPE,VOLNUM,sfn
 n dlmlock
 n TOTAL
 n vernum
 n MIRRORINFO,MirrorBackup,MirrorRestore,MirrorDBList
 n SelectOnlyMirrorDBs ; for selective restore indicates whether we only ask about mirrored db's
 s MirrorRestore=0,MirrorBackup=0
 i '$SYSTEM.Security.Check("%Admin_Manage","USE") s RC=-7 g begin2
 n oldmode s oldmode=$ZU(69,12)
 D INT^%DIR S OURDIR=%DIR,DELIM=$c(0)
 s OK=$$getLock^DBACK(.dlmlock)
 if '+OK do  s RC=-3 g begin2
 . W *7,!,"[A backup or restore is already in progress"
 . W !,"This restore is aborted.]",!!
 V $ZU(40,2,82):-2:4:$ZU(61,30,$ZU(61))  ; Load our jobid into incbkjobid
 ; DO NOT CALL ^%ST. Define any %ST nodes required here.
 ; Calling ^%ST can result in <PROTECT> errors when restoring the
 ; manager's directory.
 S %ST=$Case($zversion(1),1:"M/AV",2:"M/WNT",3:"M/UX",:"UNKNOWN")
 S %ST("PLEN")=$ZU(40,0,4)
 s %ST("GIND")=$V($ZU(40,2,11)+($ZU(40,0,4)*4),-2,"S")
 I $$ZU(52,0)  ;Free any existing memory
 N BUFCOUNT S BUFCOUNT=0
 B 0 S DEV=$G(INPDEV) 
 I '$G(QUIETMODE) {
    S DEV=$G(^SYS("BACKUP","LASTFULL","DEVICE"))
    S INCDEV=$$GETINC("FIRST","") ;get first incremental backup file
    if DEV="" s DEV=INCDEV,INCDEV=""
 }
 k ze
 N DIRNAM,NOREST,dejrn,global
 N CLSTATE,CLUBACKUP
 n RCSUCCESS,RCINERR,RCOUTERR,RCMOUNT,RCBADMAP,RCMAPINERR,RCEOT,RCOFFLINE
 n RCDEVFUL,RCOLDFORMAT,RCBADVOLUME,RCENDOFVOL,RCENDOFVOLSET,RCDIRLABELRECORD
 n RCDIRLABELMISSING,RCINERRLABELGOOD,RCBADRECORDONCOPY,RCBADRECORDONRESTORE
 n RCMISSINGBLKS,RCBLKSIZE,RCOUTCLUMNT,RCMAPERR,A,a,OBDIRLAB,startday,starttime
 d initconstants s a=$h,startday=+a,starttime=+$p(a,",",2)
 ; delete bad blocks recorded by any former restores more than 30 days old
 f  s a=$o(^CacheRestoreBad("")) q:'a!(a>($h-30))  k ^(a)
 S CLUBACKUP=0
 S BACKSET=1,PREVDATE="",PREVTIME="",PREVTYPE=""
 S PREVFDATE="",PREVFTIME="",PREVH=""
 I +$G(QUIETMODE) {  ;switch 10 based on passed parameter
    I ALLOWUPD=0 S ALREADY=$$CHECK10() I 'ALREADY D SET10
 }
 I '$G(QUIETMODE) DO
 . S ALREADY=$$CHECK10() Q:ALREADY
 . D Show("ALREADY") S X=$$YESNO(1) I X D SET10
 . I 'X D Show("MAYBE")
 S $ZT="ERR^"_$ZN
 New batch Set batch=$$GETBATCH^%PRIO() Do SET^%PRIO("BATCH")
begin1 I '$G(QUIETMODE) DO  I $$YESNO(1) G begin1
 . F BACKSET=BACKSET:1 S X=$ZU(69,12,0) D NEXTBACK S X=$ZU(69,12,oldmode) Q:'OK  ; restore the next backup
 . D Show("anymore"_(BACKSET>1))
 I +$G(QUIETMODE) S X=$ZU(69,12,0) D NEXTBACK S X=$ZU(69,12,oldmode) S:OK RC=1 ;just the first one when quiet
 ;
 S DIR="" F  S DIR=$O(DIRNAM(DIR)) Q:DIR=""  D
 . s dir=$P(DIRNAM(DIR),"^",1),char=$P(DIRNAM(DIR),"^",2)
 . s:dir="" dir=DIR
 . s n=$$ZU(52,8,dir,1)  ;JO2329
 . i char'="" d
 . . s n=$$ZU(52,7,dir,+char)
 . . i n'=1 d
 . . . d Show("zu52err",n,DIR,char,$p($ZU(49,dir),",",4))
 . . . d Show("zu52e"_(-n))
 . s n=$$ZU(52,5,dir,0)
 . i n=-1 d Show("GFINCRES",DIR) k dejrn(DIR)
 Do:$d(batch) SET^%PRIO(batch)
 G finish^DBREST
begin2 S X=$ZU(69,12,oldmode) Do:$d(batch) SET^%PRIO(batch) G begin2^DBREST
ERR I $G(QUIETMODE) S $ZT="" G begin2
 S $ZT="",ze=$ZE
 D Show("errabort",ze) G begin2
NEXTBACK ; If appropriate, reset default device to incremental default
 N ALREADY,dir,yes S ALREADY=$$CHECK10()
 I BACKSET=2,PREVTYPE="Full" S DEV=INCDEV ;INCDEV might be null
 I BACKSET>1,INCDEV'="",PREVTYPE'="Full" S DEV=$$GETINC("NEXT",PREVH)
 do $ZU(31,1,0)
 S VOLNUM=1,sfn=-1 D VOLLABEL I 'OK Q
 ; Process directory names if necessary
nxtback1 K NEWDIR,NODIR S added=0,DIRLOC=VOLLOC ; input variables for DIRNAM()
 s flag=0
 For {
	 S DIR=$$nextvol() 
	 if DIR="" {
		; End of volume label info, see if there's a continuation block
		if $V(VOLLOC,-3,1)=0 quit  ; we're done
		; there is a continuation label block, read it and get more databases
		s RC=$$ZU(52,10)
		i +RC'=1 {
		   s flag=1
		   quit
 		}
 		S VOLLOC=$P(RC,",",4)+$P(RC,",",2)
		S DIR=$$nextvol() 
		if DIR="" quit  ; this is the end of the list, then we're done
	 }
	 S ZU49=$$nextvol() 
	 if ZU49="" {
		; End of volume label info, see if there's a continuation block
		if $V(VOLLOC,-3,1)=0 quit  ; we're done
		; there is a continuation label block, read it and get more databases
		s RC=$$ZU(52,10)
		i +RC'=1 {
		   s flag=1
		   quit
		}
		S VOLLOC=$P(RC,",",4)+$P(RC,",",2)
		S ZU49=$$nextvol()
		if ZU49="" quit  ; this is the end of the list, then we're done
	 }
	 D DIRNAM(DIR,ZU49)
 }
 q:OK=0
 if flag {
	 W *7,!,"[Failed to read continuation volume label from "_DEV_"]"
	 i $G(QUIETMODE) {
		s OK=0
		s flag=$$ZU(52,3,"")
		quit
	 }
	 w !,"Do you want to continue anyway?"
	 s yes=$$YESNO(0) w !
	 i 'yes {
		s OK=0
		s flag=$$ZU(52,3,"")
		quit
	 }
 }
 ; Go through the databases to be restore and see if we can privatly
 ; mount them. If they don't exist that's ok but if we can't privatly
 ; mount them they are mounted by someone else in the cluster and
 ; can't be restored to.
 S DIR="",flag=0 k BADDIR
 if BACKSET=1,'$D(NEWDIR) {
	 w:'$G(QUIETMODE) !,"No databases selected for restore."
	 s OK=0
	 s flag=$$ZU(52,3,"") 
	 Q
 }
 n rc
 f  {
	S DIR=$O(NEWDIR(DIR)) 
	Q:DIR=""  
	s rc=$$TSTDIR(DIR)
	if rc {
		i 'flag {
 			w !,"The following directories appear to be dismounted, read-only or"
 			w !,"mounted elsewhere and can't be restored"
 			if $G(QUIETMODE) w " and skipped"
 			s flag=1
		}
 		w !,?5,$S($P(NEWDIR(DIR),"^")="":DIR,1:$P(NEWDIR(DIR),"^")) ;cf. mntdir in TSTDIR JO2936
 		w "    *"_$Case(rc,1:"Dismounted",2:"ReadOnly",3:"Cluster Mounted by other")
	}
 }
 i '$G(^SYS("RESTORE","MULTIVOLUMEOK")) {
	s DIR="",rc=0
	f  {
		s DIR=$O(NEWDIR(DIR))
		q:DIR=""
		s dir=$S($P(NEWDIR(DIR),"^")="":DIR,1:$P(NEWDIR(DIR),"^"))
		i $P($zu(49,dir),",",15)>1 {
			i 'rc {
				w !,"The following directories contain multi-volume databases and"
				w !,"can't be the target of a restore."
				i $G(QUIETMODE) w " They will be skipped."
				s rc=1,flag=1
			}
			w !,?5,dir
			s BADDIR(DIR)=""
		}
	}
 }
 i flag,'$G(QUIETMODE) {
 	w !,"Do you wish to continue, skipping these databases?"
 	s yes=$$YESNO(0) w !
 	i 'yes s OK=0 s flag=$$ZU(52,3,"") q
 }
 ; TSTDIR left list of databases we can't restore in BADDIR
 s DIR="" 
 f  {
	 S DIR=$O(BADDIR(DIR)) 
	 q:DIR=""
 	 k NEWDIR(DIR) 
 	 s NODIR(DIR)=""
 }
 ;
 I added,RESTYPE="SELECT" {
 	D Show("chnglist") 
 	S yes=$$YESNO(0) W !
 	I yes {
	 	S VOLLOC=DIRLOC 
	 	G nxtback1
 	}
 }
 I BACKSET=1,'$G(QUIETMODE) {
 	D Show("confirmRestore") 
 	S yes=$$YESNO(0) W !
	I 'yes {
		s OK=0
		s flag=$$ZU(52,3,"") 
		Q
	}
 }
 S DIR=$O(NODIR(""))
 while (DIR '= "") {
 	s NOREST(DIR)=""
 	k NODIR(DIR)
 	s DIR=$O(NODIR(""))
 }
 s DIR=$O(NEWDIR(""))
 while (DIR '="" ) {
	 s DIRNAM(DIR)=NEWDIR(DIR)
 	 K NEWDIR(DIR)
 	 S dir=$P(DIRNAM(DIR),"^",1)
 	 s:dir="" dir=DIR  ; if restoring to same place, dir would be null
 	 I dir=DIR {
	 	 S dejrn(DIR)=1
 	 } else {
 		 s dejrn(DIR)="1,"_dir
 	 }
	 ; If the target is mirrored then we need to remove it from the
	 ; mirror now so it can be restored. After the restore it will be
	 ; added back.
	 s mirdbname=$G(MirrorDBList("path",dir))
	 if mirdbname'="" {
		 if 'MirrorDBList(mirdbname,"inactive") {
		    s rc=$$PauseMirroredDB($G(QUIETMODE),mirdbname,dir)	
		    if 'rc {
	 	       s NOREST(DIR)="" 
	 	       k DIRNAM(DIR)
	 	       k dejrn(DIR) 
	 	       goto nextdir
		    }
	 	 }
		 s rc=$SYSTEM.Mirror.DBRemove(dir)
		 if '+rc {
		    s err=$P(rc,",",2)
		    if '$G(QUIETMODE) {
		       w !,"Failed to remove restore target ",dir
		       w !,"from the mirror, it will not be restored"
		    } else {
			   d $zu(9,"","DBREST failed to remove "_dir_" from the mirror - Skipped",1 /* broadcast and log message*/,1  /* Warning */)
		    }
	 	    s NOREST(DIR)="" 
	 	    k DIRNAM(DIR)
	 	    k dejrn(DIR) 
	 	    goto nextdir
		 }
		 d ##Class(%SYS.Audit).WriteToAuditFile("%System","%System","ConfigurationChange",dir,"Remove mirrored database "_$p(mirdbname,":",4))
	 }
 	 ; Now set the GFINCREST flag to prevent others from using this dir
 	 i +$ZU(49,dir)>-2 {
	 	 s rc=+$$ZU(52,5,dir,1)
	 	 if rc<0 {  ;-1, -2 or -3
	 	     s NOREST(DIR)="" 
	 	     k DIRNAM(DIR)
	  	     k dejrn(DIR) 
	  	     if (rc = -1) {
	   	        d Show("errmrk",dir,DIR) ;error marking db as target as restore
	  	     } elseif (rc = -2) {
	   	        d Show("errmrk2",dir,DIR) ;mirrored db cannot be target of restore
	  	     } elseif (rc = -3) {
	   	        do Show("errcol",dir,DIR) ;db collation is not available
	  	     }
	 	 }
 	 }
  	 D MOUNTQ(dir)
nextdir ;
	 s DIR=$O(NEWDIR(""))
 } 
 if BACKSET=1,'$D(DIRNAM) {
	 w:'$G(QUIETMODE) !,"No databases remaining to be restored."
	 s OK=0
	 s flag=$$ZU(52,3,"") 
	 Q
 }
 For  DO  Q:'OK!EOS
 . s StartVolume=1,StartTime=$h D VOLUME s StartVolume=0 S RC=$$ZU(52,3,"") Q:'OK!EOS
 . S VOLNUM=VOLNUM+1 D VOLLABEL
 Q:'OK
 S DIR="" For  S DIR=$O(DIRNAM(DIR)) Q:DIR=""  Do
 . S DIRNAM=$P(DIRNAM(DIR),"^",1) S:DIRNAM="" DIRNAM=DIR
 . Q:$D(NOREST(DIRNAM))  D DISMOUNT(DIRNAM) S RC=$$MOUNTQ2(DIRNAM)
 . I RC=-86 D Show("errcol2",DIRNAM) S OK=0 K DIRNAM(DIR),dejrn(DIR)
 S PREVDATE=BACKDATE,PREVTIME=BACKTIME,PREVTYPE=BACKTYPE,PREVH=BACKH
 i $g(logfile)'="" c logfile s logfile=""
 Q
nextvol() N a,b ; see if can find string in current line
 S a=$F($V(VOLLOC,-3,-512),DELIM) I 'a Q ""
 I $L(DELIM)+1=a s VOLLOC=VOLLOC+$l(DELIM) q ""
 S b=$v(VOLLOC,-3,-(a-$l(DELIM)-1)),VOLLOC=VOLLOC+a-1
 I '$D(XLT) S XLT=$$GETXLT(DEV)
 Q $ZCVT(b,"I",XLT)
GETINC(btype,prevdt) N dev,date,type I btype="FIRST" S prevdt=""
 i +$ZU(49,$ZU(12))<0 q ""  ; if directory is dismounted, just quit
 d ConvHistDate^DBACK s date=$S($G(prevdt):(+prevdt*1000000+$p(prevdt,",",2)),1:"")
 S dev="",date=$O(^SYS("BACKUP","HISTORY",date)) I date]"" DO
 . S dev=$G(^(date,"DEVICE")),type=$G(^("TYPE")) Q:type["Cumulative"
 . N OK S OK=0
 . F  S date=$O(^SYS("BACKUP","HISTORY",date)) Q:date=""  DO  Q:OK
 . . I $G(^(date,"TYPE"))["Cumulative" S dev=$G(^("DEVICE")),OK=1
 ;
 Q dev
DISMOUNT(dir) ;Dismount a directory
 N a
 s a=$ZU(3,dir)  ; dismount the directory
 Q
TSTDIR(DIR) ;
 n zu49,mntdir,zu17,CLUSFLAG,zu49str,rc
 s mntdir=$S($P(NEWDIR(DIR),"^")="":DIR,1:$P(NEWDIR(DIR),"^"))  ;JO2936
 s zu49str=$ZU(49,mntdir)
 s zu49=+zu49str
 q:zu49<-1 0
 if zu49=-1!(zu49=$zu(40,0,41)) {
	 d MOUNTQ(mntdir) 
	 s $p(NEWDIR(DIR),"^",3)=zu49 ;-1 or $$$SFNUNDEF
	 s zu49str=$ZU(49,mntdir)
 	 s zu49=+zu49str
 }
 if $zb(+$p(zu49str,",",17),$zu(40,8,13),1) {
	 s rc=2
	 G SetBad
 }
 if ($zb(+$p(zu49str,",",18),$zu(40,8,2),1)) {
	 ;If its read only because its mirrored, then its fine to restore 
	 ; to it (as long as its not marked mirrornowrite)
	 if $zb(+$p(zu49str,",",17),$zu(40,8,28),1) && '$zb(+$p(zu49str,",",18),$zu(40,8,30),1) {
		 quit 0
	 }
	 s rc=2
	 G SetBad
 }
 q:'$S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0) 0
 ; if database is mounted privately, return success otherwise,
 ;    if database is mounted clustered, dismount it
 n dismounted s dismounted=0
 i zu49>-1,zu49'=$zu(40,0,41) q:+$P($ZU(49,mntdir,1),",",2)=0 0 s dismounted=1,$p(NEWDIR(DIR),"^",3)=2 i $ZU(3,mntdir)
 ; database is not mounted or dismounted. Try to mount it privately
 s Status=##Class(SYS.Database).MountDatabase(mntdir,0,0)
 i (''Status) q 0
 i dismounted i $ZU(17,mntdir,1)
 s rc=3
SetBad
 ; Database can't be mounted privately, don't restore it and 
 ; signal failure
 S BADDIR(DIR)=""
 if $p(NEWDIR(DIR),"^",3)=-1 d DISMOUNT(mntdir)
 q rc
QUIET() ;wait for the system to quiet down -- set switch 10 if needed
 N already,%SW,%VAL,rc
 S already=$$CHECK10() I 'already S %SW=10,%VAL=1 D SWSET
 s rc=$$TQUISYS^SWSET(1)
 I 'already S %SW=10,%VAL=0 D SWSET ;reset switch 10 when done
 q rc
DIRNAM(dir,zu49) ;
 n clflag
 n mirdata,mirdbname,info,mirname,mirindex,rc
 n curjrnfilecnt,curjrnoff,backupjrnfilecnt,backupjrnfileoff
 n indent,path
 s mirdata=$P(dir,"^",3)  ;stored by getMirDBInfo^DBACKB
 if mirdata="" {
	 s mirdbname=""
 } else {
	 s mirdbname=":mirror:"_$P(mirdata,":",6)_":"_$P(mirdata,":",1)
 }
 s clflag=$P(dir,"^",2),dir=$P(dir,"^",1)  ; get cluflag
 i clflag="" s clflag="P"  ;from a prior/non-cluster version
 i $D(NOREST(dir))||$D(DIRNAM(dir)) { ; make sure its sfn didn't change
   i $g(gdir(+zu49))=dir q  ;sfn didn't change
   ;sfn of the directory changed between consecutive backups
   ;remove the gdir entry for the directory with the old sfn
   n sfn s sfn="" f  s sfn=$o(gdir(sfn)) q:sfn=""  i gdir(sfn)=dir k gdir(sfn) q
   s gdir(+zu49)=dir ;add the new gdir entry
   q
 }
 ; if restore all directories, add to restore list
 i RESTYPE="ALL" G diradd
 ; Select individual directories and see if need to rename
 if ($G(SelectOnlyMirrorDBs)=1) && (mirdata="") {
	 S NODIR(dir)=""
	 s gdir(+zu49)=dir 
	 quit
 }
 I $G(QUIETMODE) {
	 ; Set up arrays for selecting directories to restore only
	 ; for non-interactive restore
	 S gdir(+zu49)=dir
	 D SELDIR(dir,mirdbname)
	 quit
 } 
 I 'added {
	 W *7 
 	 D Show("DIRNAM") W !
 	 S added=1
 }
 n zdir,xdir,dpl
ask4new ; Display original directory name so user can select/reject/rename it
 w dir
 if mirdbname'="" w " (",mirdbname,")"
 w " => " 
 r a,! 
 I $$UC(a)="X"!$$STOP(a) {
	 S NODIR(dir)=""
	 s gdir(+zu49)=dir 
	 Q
 }
 if a="" {
	 if mirdbname="" {
		 s a=dir
	 } else {
		 ; set a to the local database (if there is one)
		 ; with the same mirror database name
		 s a=$G(MirrorDBList(mirdbname,"path"))
		 if a="" {
		    s a=dir
		 }
	 }
 }
 s a=$zu(12,a),dpl=0,zdir=""
 s zdir=$O(NEWDIR(""))
 while (zdir'="") {
	 s xdir=$P(NEWDIR(zdir),"^")  ;JO2936
	 s:xdir="" xdir=zdir
	 if xdir=a {
		 D Show("DUPLDIR",a)
		 goto ask4new  ;get a new response
	 }
	 s zdir=$O(NEWDIR(zdir))
 }
 i $l(zu49,",")=4 {
	 if (($zu(12,a,3)="") || ($zu(49,a)<-1)) {
		 i $zu(12,a,3)="" {
			 d Show("NotExist",a)
		 } else {
			 d Show("dirnexis",a)
		 }
		 d Show("MakeLater")
		 s yes=$$YESNO(0) 
		 w !
		 if yes goto ask4new   ;get a new choice
	 } else {
		 set yes=$$CheckForMirrorTarget(dir,mirdbname,mirdata,a)
		 if 'yes goto ask4new 
	 }
 }
 i $l(zu49,",")=12 {
	 if (($zu(12,a,3)="") || ($zu(49,a)<-1)) {
		 i $zu(12,a,3)="" {
			 d Show("NotExist",a)
		 } else {
			 d Show("dirnexis",a)
		 }
		 w !,"Do you want to create this database?"
		 s yes=$$YESNO(1) 
		 w ! 
		 if 'yes goto ask4new  ;don't create it, get a new choice
		 s DIRNAM=a
		 s dirneed=zu49
		 i ('$$c5(DIRNAM)) || ($ZU(12,DIRNAM,3)="") || ($zu(49,DIRNAM)<-1) {
			 w !,"Could not create database "_DIRNAM_", please enter different name.",!
			 goto ask4new 
		 }
		 s a=DIRNAM
	 } else {
		 set yes=$$CheckForMirrorTarget(dir,mirdbname,mirdata,a)
		 if 'yes goto ask4new 
	 }
	 s rc=$P($ZU(49,a),",",2)  ;blocksize of the target
	 s info=$P(zu49,",",2)  ;blocksize of the source
 	 if rc'=info {
	 	 w !,"The block size (",rc,") of the restore target ",a
	 	 w !,"does not match the block size of the source in the backup (",info,")"
	 	 w !,"Please enter a different target"
	 	 goto ask4new
 	 }
 }
 if (mirdbname'="") {  ;from the backupo
	 s path=$G(MirrorDBList(mirdbname,"path"))  ;local database list
	 if (path'="") {
	    if a'=path,'MirrorDBList(mirdbname,"activationreq") {
		    w !,"Warning, mirror database ",mirdbname," exists in"
		    w !,?5,path
		    w !,"but you are restoring it to"
		    w !,?5,a
		    w !,"Activation and catchup of the restored database will fail"
		    w !,"because a mirror database name can only be used by one"
		    w !,"database on an instance at a time."
			w !,"Do you want to continue anyway?"
		    s yes=$$YESNO(0) 
		    w ! 
		    if 'yes goto ask4new 
	    }
	 }
 }
 S NEWDIR(dir)=$s(a=dir:"",1:a)
 S gdir(+zu49)=dir
 S CLSTATE(dir)=clflag
 i 'CLUBACKUP,clflag="C" s CLUBACKUP=1
 Q
diradd ;
 S gdir(+zu49)=dir
 if 'added {
 	W !,"The following directories will "
 	W $s(BACKSET'=1:"also ",1:""),"be restored: ",!
 }
 S added=1
 if $G(TopDir)="" {
	 if 'MirrorRestore {
	    s a=$ZU(12,dir)
	 } else {
		 ; For MirrorRestore=2 we only restore mirrored databases
		 ; and only if they have a corresponding local location
		 if (MirrorRestore=2) && ((mirdbname="") || '$D(MirrorDBList(mirdbname))) {
			 s NODIR(dir)=""
			 quit
		 }
		 ; If this is a mirrored database and it has a local copy then
		 ; set up the redirection. If the local copy is currently active,
		 ; we have to deactivate it. If the local copy is active and newer
		 ; than the copy in the backup, we ask the user to confirm or we
		 ; abort the operation (for non-interactive).
		 if (mirdbname="") || '$D(MirrorDBList(mirdbname)) {
		    s a=$ZU(12,dir)
		 } else {
		     s info=MirrorDBList(mirdbname,"info")
		     if $P(info,":",4)'=$P(mirdata,":",4) {  ;database guid
				 if '$G(QUIETMODE) {
				    w !,dir," skipped because its guid does not"
				    w !,?5,"match the guid of the current database."
				 }
			     s NODIR(dir)=""
			     quit
		     }
		     if $P(info,":",5)'=$P(mirdata,":",5) {  ; mirror guid
				 if '$G(QUIETMODE) {
				    w !,dir," skipped because its mirror guid does not "
				    w !,?5,"match the mirror guid of the current database."
				 }
			 	 s NODIR(dir)=""
			 	 quit
		     }
		     s curjrnfilecnt=+$P(info,":",2),curjrnoff=+$P(info,":",3)
		     s backupjrnfilecnt=+$P(mirdata,":",2),backupjrnoff=+$P(mirdata,":",3)
		     if (curjrnfilecnt>backupjrnfilecnt) || 
		           ((curjrnfilecnt=backupjrnfilecnt) && (curjrnoff>backupjrnoff)) {
			    if 'MirrorDBList(mirdbname,"inactive") {
				    if '$G(QUIETMODE) {
					    if $SYSTEM.Mirror.GetInfo()["PRIMARY" {
					    	w !,dir," skipped because the"
							w !,?5,"target database is active and this is the primary mirror member."
							w !,?5,"The target database needs to be removed from the mirror"
							w !,?5,"before it can be the target of a restore."
					    } else {
					    	w !,dir," skipped because the target database "
							w !,?5,"is active and is newer than the database in the backup"
							w !,?5,"The database in the backup is current as of journal file #",backupjrnfilecnt
							w !,?5,"and the current database is current as of file #",curjrnfilecnt," and the current"
							w !,?5,"database does not appear to be damaged as it is active."
							w !,?5,"Use a Selective Restore if you want to restore over the existing copy."
					    }
					    w !
				    }
				    S NODIR(dir)=""
				    quit
			    } else {
				    if '$G(QUIETMODE) {
					    w !,"Note that the copy of ",dir
					    w !,?5,"in the backup is older than the current"
					    w !,?5,"database, ",MirrorDBList(mirdbname,"path"),"."
					    w !,?5,"However the current database is not active in the mirror"
					    w !,?5,"so it can be overwritten if the current database is damaged."
					    w !
				    }
			    }
		    }
		    s a=MirrorDBList(mirdbname,"path")
	    }
	 }
 } else {
	 s a=$ZU(12,$$prefix(TopDir,dir))
 }
 W dir," => " ;
 if (mirdbname'="") {  ;from the backupo
	 s path=$G(MirrorDBList(mirdbname,"path"))  ;local database list
	 if (path'="") {
	    if a'=path,'MirrorDBList(mirdbname,"activationreq") {
		    w !,"Warning, mirror database ",mirdbname," exists in"
		    w !,?5,path
		    w !,"but you are restoring it to"
		    w !,?5,a
		    w !,"Activation and catchup of the restored database will fail"
		    w !,"because a mirror database name can only be used by one"
		    w !,"database on an instance at a time."
	    }
	 }
 }
 s rc=$P($ZU(49,a),",",2)  ;blocksize of the target
 s info=$P(zu49,",",2)     ;blocksize of the source
 if rc'=info {
	 w !,"The target database ",a," has a block "
	 w !,?5,"size of ",rc," which does not match the block size of the database"
	 w !,?5,"in the backup (",info,")"
 	 w !,"This database will be skipped"
 	 w !
 	 s NODIR(dir)=""
 	 Q
 }
 S NEWDIR(dir)="" 
 I a'=dir {
	 s NEWDIR(dir)=a 
	 s:mirdbname'="" a=a_" ("_mirdbname_")"
	 ; If the target + mirrordb name won't fit on the
	 ; same line as the source then try to align it so
	 ; it fits on the next line indenteted a bit
	 if $L(a)+$X>79 {
		 w ! 
		 s indent=79-$L(a)
		 if (indent > $L(dir)) {
			 s indent=$L(dir)-10
		 }
		 if (indent<0) {
			 s indent=5
		 }	 
		 w @("?"_indent)
	 }
	 W a
 }
 S CLSTATE(dir)=clflag
 i 'CLUBACKUP,clflag="C" {
	 s CLUBACKUP=1
 }
 w ! Q
prefix(top,dir)
 i ($zversion(1)=2) q top_$s($e(dir,1,2)="\\":$p(dir,"\",2,999),$e(dir,2)=":":$e(dir,3,$l(dir)),1:dir)
 i ($zversion(1)=3) q top_dir
 q dir
PauseMirroredDB(QUIETMODE,mirdbname,dir) PUBLIC {
   S sw10set=$$CHECK10() 
   I sw10set {
	   do CLEAR10
   }
   d $zu(9,"","De-activating mirrored restore target: "_dir,0,0  /* Informational message */)
   S mirname=$P(mirdbname,":",3)
   s mirindex=$SYSTEM.Mirror.MirrorNameToIndex(mirname,1)+1 
   s rc=$SYSTEM.Mirror.PauseDatabase(mirindex,dir)
   I sw10set {
	   do SET10
   }
   if +rc=0 {  ;0,<error text>
	   if 'QUIETMODE {
		   w !,dir," skipped - failed to deactivate ",dir," (",$P(rc,",",2),")"
	   } else {
		   d $zu(9,"","DBREST failed to deactivate "_dir_" - Skipped ("_$P(rc,",",2)_")",1 /* broadcast and log message*/,1  /* Warning */)
	   }
	   quit 0
   }
   quit 1
}
CheckForMirrorTarget(src,mirdbname,mirdata,targ) [MirrorDBList] PUBLIC {
	; This is called during an interactive selective restore when
	; the target database exists. We want to check whether the target
	; is a mirrored database and if so, warn the user if it doesn't match
	; the database in the backup and ask if they want to continue
	;
	; mirdbname is the mirror database name of the src database as
	;    extracted from the info stored in the backup header. This
	;    is used as a subscript into the MirrorDBList() array to get the
	;    mirror inforation for this db that was extracted from the
	;    database header record in the backup file.
	;
	; Returns: 0 = do not restore to this target
	;          1 = ok to restore to this target
	s targmirdbname=$g(MirrorDBList("path",targ))
	if targmirdbname="" {
		; Target is not mirrored, all is well
		quit 1
	}
	s targmirdata=MirrorDBList(targmirdbname,"info")
	s inactive=MirrorDBList(targmirdbname,"activationreq")
	s targmirname=$P(targmirdata,":",6)
	s targmirindex=$SYSTEM.Mirror.MirrorNameToIndex(targmirname,1)+1 
	if mirdbname="" {
		; Source is not mirrored, this is not good
		w !,"The output database ",targ," is mirrored but the "
		w !,"database in the backup ",src," is not."
		w !,"Continuing will remove the target database from the "
		w !,"mirror and destroy it."
		goto checkContinue
	}
	; Source is mirrored, see if the target matches the source
	if targmirdbname'=mirdbname {
		w !,"The mirror database name of the target ",targmirdbname
		w !,"does not match the name of the source in the backup ",mirdbname
		w !,"Continuing will overwrite the contents of ",targ
		goto checkContinue
	}
	; The mirror database names match so the guids should also match
	; but we check them just to be sure.
	if $P(targmirdata,":",4)'=$P(mirdata,":",4) {  ;database guid
		w !,"The mirror database guid ",$P(targmirdata,":",4)," of the target database"
		w !,"does not match the guid ",$P(mirdata,":",4)," of the source in the backup."
		w !,"Continuing will overwrite the contents of ",targ
		goto checkContinue
	}
	if $P(targmirdata,":",5)'=$P(mirdata,":",5) {  ; mirror guid
		w !,"The mirror guid ",$P(targmirdata,":",5)," of the target database"
		w !,"does not match the mirror guid ",$P(mirdata,":",5)," of the source in the backup."
		w !,"Continuing will overwrite the contents of ",targ
		goto checkContinue
	}
	if inactive {
		; The target database is inactive, go ahead and let the user
		; restore over it
		quit 1
	}
    ; If this is the primary then we don't allow this. 
    if $SYSTEM.Mirror.GetInfo()["PRIMARY" {
	    w !,"The target database is active and this is the primary"
	    W !,"mirror member so it cannot be the target of a restore."
	    w !,"If you really want to restore to this database then mark"
	    w !,"it as not mirrored."
	    w !
	    quit 0
    }
	; The database is active so check whether it is more current
	; than the copy we're restoring
    s curjrnfilecnt=+$P(targmirdata,":",2),curjrnoff=+$P(targmirdata,":",3)
    s backupjrnfilecnt=+$P(mirdata,":",2),backupjrnoff=+$P(mirdata,":",3)
    if (curjrnfilecnt>backupjrnfilecnt) || 
        ((curjrnfilecnt=backupjrnfilecnt) && (curjrnoff>backupjrnoff)) {
	    w !,"The target database is active and is more up to date"
	    w !,"than the copy in the backup. Continuing will overwrite"
	    w !,"the contents of ",targ," with older data."
checkContinue ;		
		r !,"Continue? <No> ",resp
		w !
		if "Yy"'[$E(resp_"X") {
			quit 0
		}
    }
    quit 1  ;ok to restore
}
SELDIR(dir,mirdbname) ;get the list of arrays
 N DONE,SELTARG,SEL1 
 S DONE=0
 S I=1
 while $D(SELDIR(I)) && ('DONE) {
    S SEL1=$P(SELDIR(I),",")
    if SEL1'="" {
	    ;See if the configuration file entry is based on mirror db names
	    if $E(SEL1,1,8)=":mirror:" {
		    if SEL1=mirdbname {
			    s SEL1=dir
		    } else {
			    goto next	    
		    }
	    }
 	    S SEL1=$ZU(12,SEL1)
 	    if SEL1=$zu(12,dir) {
 			S SELTARG=$P(SELDIR(I),",",2) ; Second piece is target dir
 		    I (SELTARG="X") || (SELTARG="x") {
	 		    S NODIR(dir)=""   ;not a directory
 		    } else {
 			   	I SELTARG="" {
	 			   	; If the source directory is mirrored then use the local
	 			   	; copy of that mirror db as the default output directory
	 			   	if mirdbname'="" {
		 			   s SELTARG=$G(MirrorDBList(mirdbname,"path"))
	 			   	}
	 			   	if SELTARG="" {
	 			   	   S SELTARG=dir ;same directory
	 			   	}
 			   	}
 			   	IF $E(SELTARG,1,8)=":mirror:" {
	 			   	s SELTARG=$G(MirrorDBList(SELTARG,"path"))
	 			   	if SELTARG="" {
		 			   	; Have to abort here - we don't have a location
		 			   	; for this so we can't just create a missing database
		 			   	s NODIR(dir)=""
		 			   	s DONE=1
		 			   	goto next
	 			   	}
 			   	}
 				S SELTARG=$ZU(12,SELTARG)
 				; See if the target is a mirrored database
			    s targmirdbname=$G(MirrorDBList("path",SELTARG))
 				if targmirdbname'="" {
	 				; The target is mirrored. We don't overwrite a mirrored
	 				; database during non-interactive restore (eg. now) unless
	 				; the source matches the target and the source is newer 
	 				; than the target or the target is inactve (eg. might be
	 				; broken)
	 				;
	 				; mirdata & mirdbname are set based on the source
	 				; database. Now compare them to the values in the
	 				; target db in info.
	 				s info=$G(MirrorDBList(targmirdbname,"info"))
	 				if targmirdbname'=mirdbname {
		 				s NODIR(dir)=""
	 				} elseif $P(info,":",4)'=$P(mirdata,":",4) {  ;database guid
					    s NODIR(dir)=""
				    } elseif $P(info,":",5)'=$P(mirdata,":",5) {  ; mirror guid
					    s NODIR(dir)=""
				    } elseif 'MirrorDBList(targmirdbname,"activationreq") {
					    ; If the db needs activation, then we're good to go. Otherwise
					    ; make sure that it isn't more current than the copy we're restoring. 
					    s curjrnfilecnt=+$P(info,":",2),curjrnoff=+$P(info,":",3)
					    s backupjrnfilecnt=+$P(mirdata,":",2)
					    s backupjrnoff=+$P(mirdata,":",3)
					    if (curjrnfilecnt>backupjrnfilecnt) || 
					        ((curjrnfilecnt=backupjrnfilecnt) && (curjrnoff>backupjrnoff)) {
						    S NODIR(dir)=""
					    }
				    }
 				}
 				if '$D(NODIR(dir)) {
 				   	if (SELTARG=dir) {
	 				   	s NEWDIR(dir)=""
 					} else {
	 					s NEWDIR(dir)=SELTARG
 					}
 					; Third piece is used if target directory does not exist
 					S DIRNEW(SELTARG)=$P(SELDIR(I),",",3)
 				}
 		    }
 			s DONE=1  ;exit while loop and indicate we found a match
 	    }
    }
next ;    
    s I=I+1
 }
 I 'DONE S NODIR(dir)="" ;never found
 Q
SWSET   do $SYSTEM.Util.SetSwitch(%SW,%VAL)
	quit
SET10   do $SYSTEM.Util.SetSwitch(10,1)
        quit
CLEAR10 do $SYSTEM.Util.SetSwitch(10,0) 
        quit
CHECK10() n res
	s res=$SYSTEM.Util.GetSwitch(10)
	if '+res quit 0  ; not owned
	if +$P(res,",",2)'=+$J quit 0  ; not owned by us
	quit 1  ; set and owned by us
 ;uppercase function
UC(x) q $zcvt(x,"u")
 ;check  for stop text function
STOP(x) S x=$$UC($E(x,1,4)) Q (x["EXIT")!(x["STOP")!(x["QUIT")!(x["HALT")!($E(x)="^")
YESNO(a) N v,b S a=$G(a)  F  DO  Q:$D(v)
 . W *-1,$S(a:" Yes",1:" No")_" => " R b I b="" S v=a Q
 . S b=$TR($E(b),"yn","YN") I "YN"[b S v=(b="Y") Q
 . W *7," [answer Yes or No, please]" I $x>68 W !
 Q v
Show(item,p1,p2,p3,p4) ;
 n d,i,p0,p,tx s d="#",tx=$g(dbrtext(item))
 i tx="" w !,*7,"MISSING DBRTEXT ITEM ",item
 e  f i=0:1:4 s p="p"_i w $p(tx,d,i),$g(@p)
 h 0 q 
 ;
 ;Restore a volume
VOLUME s EOV=0,EOS=0,OK=1 ; haven't yet reached an end of volume
 I VOLNUM=1 S LASTFUNC="",DIRNAM="" ; if 1st, not continuing a func
 I LASTFUNC="SKIP" d SKIPDIR q:'OK!EOV!EOS  G dirnext
 I LASTFUNC="RESTORE" DO  D DIRREST Q:'OK!EOV!EOS  G dirnext
 . w !,"***Continuing restore of "_DIR w:DIR'=DIRNAM " to "_DIRNAM W !
 D SKIPDIR ; read to the first directory block
 I EOV!EOS W *7,!,"[Can't find any directories in this input file]",! q
 Q:'OK
 ; process additional directories in this file
dirnext For  D dodir Q:'OK!EOV!EOS
 Q
dodir ;
 S LEN=$V(VOLLOC,-3,2),VOLLOC=VOLLOC+2
 s dirneed=$$nextvol() ; get file characteristics from label
 g dirnamer:dirneed="" s DIR=$g(gdir(+dirneed)) g dirnamer:DIR=""
 s DIRNAM=$p($g(DIRNAM(DIR)),"^",1) s:DIRNAM="" DIRNAM=DIR
 g SKIPDIR:$D(NOREST(DIR)),dirnamer:'$D(DIRNAM(DIR))
 g dirnamer:($l(dirneed,",")<24)
 s dirhave=$ZU(49,DIRNAM) ; get actual file characteristics
 i +dirhave=-2!(+dirhave=-3) d create i 'OK d SKIPDIR q
 ; If necessary, change the file characteristics of this directory
 s OK2=1
 i $p(dirhave,",",2)=2048 d
 . n partialmap,havemaps,zt,blkn,mapsz
 . s partialmap=0,havemaps=+$p(dirhave,",",24)
 . i havemaps=+$p(dirneed,",",24) d  
 . . S mapsz=+$P(dirhave,",",23) O 63:"^^"_DIRNAM V (havemaps-1)*mapsz+1
 . . f blkn=mapsz-1:-1:0 q:$V(blkn,0,1)'=254 
 . . s partialmap=mapsz-1-blkn C 63
 . i partialmap!(havemaps<$p(dirneed,",",24)) d  i 'OK d SKIPDIR s OK2=0 q
 . . i partialmap S $P(dirneed,",",24)=0
 . . do modify 
 . i havemaps>$p(dirneed,",",24) d MOUNTQ(DIRNAM)
 e  d
 . n partialmap,havemaps,zt
 . s partialmap=0,havemaps=+$p(dirhave,",",4)
 . i havemaps<$p(dirneed,",",4) d  i 'OK d SKIPDIR s OK2=0 q
 . . do modify 
 . i havemaps>$p(dirneed,",",4) d MOUNTQ(DIRNAM)
 ;
 q:'OK!EOV!EOS!'OK2
 ; Start the restore
 d output^%Wprim("***Restoring "_DIR_$s(DIR'=DIRNAM:" to "_DIRNAM,1:"")_" at "_$ztime($p($h,",",2)))
 d DIRREST ; restore the directory
 q
DIRREST S LASTFUNC="RESTORE",FUNC=1
dirrest1 H 0 S sec=$zh
 s RC=$$ZU(52,FUNC,DIRNAM,sfn),sec=$zh-sec,FUNC=1,VOLLOC=BUFBASE+$P(RC,",",3)
 s TOTAL(DIRNAM)=$g(TOTAL(DIRNAM))+$p(RC,",",2)
 d Show("stchk0",$P(RC,",",2),$fn(sec,"",1),TOTAL(DIRNAM))
 ; check return code
 i +RC=RCDIRLABELRECORD!(+RC=RCDIRLABELMISSING)!(+RC=RCBADRECORDONRESTORE&($p(RC,",",3)=OBDIRLAB)) d  q
 . i +RC=RCBADRECORDONRESTORE d Show("stchk2") s DEV=""
 . d nextlabel(RC)
 i +RC=RCJRNMARKINFORECORD s DEJRNSTART=$p(RC,",",3,$l(RC)),EOS=1 q
 i +RC=RCENDOFVOL s EOV=1 q
 i +RC=RCENDOFVOLSET d done s EOS=1 q
 i +RC=RCINERRLABELGOOD d  g dirrest1
 . s y=$p(RC,",",3,999) f i=0:1 s a=$p(y,",",i*3+3) q:a  i a="" d  q
 . . d Show("stchk3") s DEV=""
 . . f i=0:1 s a=$p(y,",",i*3+1) q:a=""  i a<(65536*65536-10) w a,?8,gdir($p(y,",",i*3+2)),!
 i +RC=RCMISSINGBLKS d  g dirrest1
 . d Show("stchk4") s DEV=""
 . s lastblk=$p(RC,",",3),lastsfn=$p(RC,",",4),nextblk=$p(RC,",",5),nextsfn=$p(RC,",",6)
 . s lastdir=$g(gdir(lastsfn),"<sfn="_lastsfn_">")
 . s nextdir=$g(gdir(nextsfn),"<sfn="_nextsfn_">")
 . i lastsfn=nextsfn,nextblk'<lastblk d
 . . d Show("stchk5",lastblk,nextblk,lastdir)
 . e  d Show("stchk6",lastblk,lastdir,nextblk,nextdir)
 . w ! q
 i +RC=RCBADRECORDONCOPY!(+RC=RCBADRECORDONRESTORE) d  g dirrest1
 . s DEV=""
 . Set size=+$p(RC,",",4),blk=$p(RC,",",5),skip=$p(RC,",",6)\4
 . If +RC=RCBADRECORDONCOPY Do Show("stchk8",blk) If 1
 . Else  Do Show("stchk7",blk)
 . If skip Do Show("stchk24") Set a=$$ZU(52,2) q
 . w ! i '$$viewblk d Show("stchk9") s a=$$ZU(52,2) q
 . d Show("stchk10")
 . s i=$increment(^CacheRestoreBad(startday,starttime,DIRNAM,blk))
 . s ^CacheRestoreBad(startday,starttime,DIRNAM)=size
 . s a=size\(16*1024),b=size#(16*1024),c=0
 . f j=0:1:a-1 s ^CacheRestoreBad(startday,starttime,DIRNAM,blk,i,j)=$v(c,0,-(16*1024)),c=16*1024+c
 . i b s ^CacheRestoreBad(startday,starttime,DIRNAM,blk,i,a)=$v(c,0,-b)
 . c 63
 i +RC=RCBLKSIZE d Show("stchk11"),SKIPDIR q
 i +RC=RCMAPERR d Show("stchk12"),abortdir,SKIPDIR q
 i +RC=RCOUTCLUMNT d Show("stchk13",DIRNAM),abortdir,SKIPDIR q
 i +RC=RCMOUNT d Show("stchk14",DIRNAM),abortdir,SKIPDIR q
 i +RC=RCOUTERR d Show("stchk15"),abortdir,SKIPDIR q
 d Show("stchk16") g abortrestore
 q
 ;
 ; done with restore
done ;
 d Show("stchk17") s a=$$ZU(52,4)
 q
 ;
 ;abortrestore
 ; abort rest of restore
abortrestore ;
 d Show("stchk18") i $$ZU(52,4)
 q
 ;
 ; viewblk
viewblk() ;
 s $zt="viewerr"
 o 63:"^^"_dir v blk q 1
viewerr q 0
 ;
abortdir ;
 d Show("abtdmt")
 s outdir=$P(DIRNAM(DIR),"^",1)
 s:outdir="" outdir=DIR  ; if restoring to same place, outdir would be null
 n origchr
 s origchr=$P(DIRNAM(DIR),"^",2)
 i +$ZU(49,outdir)>-1,origchr'="" d
 . s n=$$ZU(52,7,outdir,+origchr)
 . i n'=1 w !,*7,"Failed to restore size characteristics of ",DIR
 . i n'=1 w " (code = ",n,")"
 s n=$$ZU(52,5,outdir,-1)  ; Convert the GFINCREST flag to a DISMOUNT state
 ; indicate skip in future
 ; & don't remount & don't restore journal
 K DIRNAM(DIRNAM),nodir(DIR),dejrn(DIR)
 k CLSTATE(DIR)
 S NOREST(DIR)="" K DIRNAM(DIR),nodir(DIRNAM),dejrn(DIRNAM) Q
SKIPDIR ;returns OK, EOV, EOS
 i DIRNAM'="" d Show("stchk19",DIRNAM)
 s begintime=$zh
 S LASTFUNC="SKIP",RC=$$ZU(52,2,"",sfn),VOLLOC=BUFBASE+$P(RC,",",3)
 s sec=$zh-begintime,numblks=$p(RC,",",2)
 d:DIRNAM'="" Show("stchk20",numblks,sec)
 ; check return code
 ; If no error, see if we reached end of volume condition
 i +RC=RCDIRLABELRECORD!(+RC=RCDIRLABELMISSING) d  s OK=1 q
 . d nextlabel(RC)
 i +RC=RCBADRECORDONRESTORE d Show("stchk2"),nextlabel(RC) s OK=1 q
 i +RC=RCJRNMARKINFORECORD s DEJRNSTART=$p(RC,",",3,$l(RC)),EOS=1,OK=1 q
 i +RC=RCENDOFVOLSET d Show("stchk21",DIRNAM),done s EOS=1,OK=1 q
 ; Check for end of input volume
 I +RC=RCENDOFVOL d Show("stchk22",DEV,DIRNAM) S BUFCOUNT=$P(RC,",",2),EOV=1,OK=1,a=$$ZU(52,3) q
 i +RC=RCMISSINGBLKS d  g SKIPDIR
 . d Show("stchk4")
 . s lastblk=$p(RC,",",3),lastsfn=$p(RC,",",4),nextblk=$p(RC,",",5),nextsfn=$p(RC,",",6)
 . s lastdir=$g(gdir(lastsfn),"<sfn="_lastsfn_">")
 . s nextdir=$g(gdir(nextsfn),"<sfn="_nextsfn_">")
 . i lastsfn=nextsfn,nextblk'<lastblk d
 . . d Show("stchk5",lastblk,nextblk,lastdir)
 . e  d Show("stchk6",lastblk,lastdir,nextblk,nextdir)
 ; Must have an input error
 d Show("stchk23",DEV,DIRNAM)
 d Show("SKIPDIR") S OK=$$YESNO(1) w ! g SKIPDIR:OK
 q
create ;
 I $G(QUIETMODE)!($g(TopDir,"")'="") DO  Q  ;non-interactive
 . i "Yy"[$e($g(DIRNEW(DIRNAM))_"?")!($g(TopDir,"")'="") d  q
 . . i $$c5(DIRNAM) d c2 q
 . . s OK=0 d abortdir q
 . i RESTYPE="ALL",$$c5(DIRNAM) d c2 q
 . S OK=0 D Show("restwont",DIRNAM)
 . D abortdir Q
 ;
 I $ZU(12,DIRNAM,3)="" D Show("NotExist",DIRNAM),Show("MakExist") I 1
 E  D Show("dirnexis",DIRNAM)
 D Show("CREATE") W !
c1 r "R[etry], C[reate], or A[bort]? ",R,! S R=$$UC($E(R_"?"))
 if "RCA"'[R w "Invalid response - ",R,! G c1
 I R="A" S OK=0 G abortdir
 S OK=1
 I R="R" S dirhave=$ZU(49,DIRNAM) G create:dirhave<-1 Q
 ; Must be a creation at this point....
 w "Creating "_DIRNAM_" ... " h 0
 i '$$c5(DIRNAM) g create
 w "done!",!
c2 ;
 g:'$$QUIET() c1 d DISMOUNT(DIRNAM)   ; File created mounted, dismount
 g:'$$QUIET() c1 d MOUNTQ(DIRNAM)     ; remount
 i +$$ZU(52,5,DIRNAM,1)<0 d  g abortdir  ; No retry on this type of error
 . do Show("errmrk1",DIRNAM)
 . s OK=0
 d MOUNTQ(DIRNAM)
 i $$QUIET()   ; can't hurt
 s dirhave=$ZU(49,DIRNAM)
 s OK=1 q
c3() s $ZT="c4" X $$zucom(0) q zuret
c4 s $ZT="",$ZE="" q -1
c5(DIRNAM) {  /* Private so it can't be called from outside of DBREST2 */
 	i $zu(12,DIRNAM,3)="" {  ; First create all directories in path
		Set name=$zu(12,DIRNAM,1,1)
		If name="" {
			w !,*7,"[Couldn't create ",DIRNAM,"]",!
			Quit 0
		}
		s rc=$ZU(140,9,DIRNAM,1) ;,1 = create missing dirs in the tree
		if rc<0 {
			w !,*7,"[Couldn't create this directory (rc = "_rc_")]",!
			q 0
		}
 	}
 	i $$c3<0 {
		w !,*7,"[Couldn't create this directory]",!
		q 0 ; Now try to create the database file
 	}
 	q 1
}
MOUNTQ(dir) ;
 N a S a=$ZU(17,dir) Q  ;Quick Mount: mount w/o implicit/replication
MOUNTQ2(dir) ;
 Q $ZU(17,dir)  ;Like MOUNTQ but returning status
 ; form ZU command for file create or file modify
zucom(func) ;build appropriate execute for ZU functions
 s a="s zuret=$ZU("_func_",DIRNAM"
 f i=2:1:12 s a=a_","_$p(dirneed,",",i)
 Q a_")"
 ; error in directory name
dirnamer S OK=0 w *7,!,"[Directory label error]",! Q
modify ; Modify a directory
 I '$G(QUIETMODE) w "Expanding "_DIRNAM_" ...",!
 n curchar
 s curchar=$ZU(49,DIRNAM)
 i partialmap s zt=$ZT,$ZT="mod2"
 X $$zucom(1) ; modify the directory
mod2 I partialmap S $ZT=zt,$ZE="",$P(dirneed,",",24)=havemaps
 E  I zuret<0 DO  Q
 . w !,*7,"[Couldn't expand directory "_DIRNAM_" Error "_zuret_"]",!
 . s OK=0 d abortdir
 ; Wait for expansion to complete
 n x,v
 s x=$ZU(40,2,46)
 i partialmap d Show("expmap",DIRNAM)
 i 'partialmap d
 . d Show("expand2",DIRNAM,$p(curchar,",",4),$P(dirneed,",",4))
 f  h 1 s v=$v(x,-2,$ZU(40,0,22)) q:v'=1  w "." i $X>67 d
 . W !,"        ." ;show every 60
 V x:-2:$ZU(40,0,22):0 ;reset internal flag so others can use it
 I $V(x,-2,$ZU(40,0,22)) V x:-2:$ZU(40,0,22):0 ; ? this came from MSUUS2 but why?
 I partialmap D
 . S mapsz=+$P(dirhave,",",23) O 63:"^^"_DIRNAM V (havemaps-1)*mapsz+1
 . f blkn=mapsz-1:-1:0 q:$V(blkn,0,1)'=254 
 . s blkn=mapsz-1-blkn C 63
 . i blkn=partialmap D Show("expnoblk",DIRNAM,mapsz-blkn)
 . i blkn<partialmap D Show("expblk",DIRNAM,mapsz-partialmap,mapsz-blkn)
 I 'partialmap,v=2 D Show("experr") s OK=0 d abortdir q
 ;
 d DISMOUNT(DIRNAM)  ; Flush blocks to disk
 d MOUNTQ(DIRNAM)    ; and make it accessable to us again
                     ; note: gfincrest prevents others 
                     ;       from using it.
 s OK=1 q
VOLLABEL ;read a volume label
 I $G(QUIETMODE),VOLNUM=1 DO  Q
 . s RC=$$ZU(52,4),RC=$$ZU(52,0)
 . H 0 S RC=$$OpenDev(DEV)
 . I +RC'=1 W *7,!,"[Can't open "_DEV_"]",! S OK=0 Q
 . S BUFBASE=$P(RC,",",4),VOLLOC=BUFBASE+$P(RC,",",2) D VOLHEAD I 'OK S RC=-2
 i +$G(QUIETMODE) {
	w !!,"RESTORE OF FILE "_INPDEV_" HAS FAILED, BACKUP MAY BE CORRUPT",!
	s OK=0
	q
 }
 For  D GETDEV Q:OK  Q:VOLNUM=1  DO  Q:'OK  ; get device name
 . W !,"Do you want to abort the restore of this backup?"
 . S OK='$$YESNO(0) W !
 Q:'OK
vol1 i VOLNUM=1 s RC=$$ZU(52,4),RC=$$ZU(52,0)
 S RC=$$OpenDev(DEV),BUFBASE=$P(RC,",",4),VOLLOC=BUFBASE+$P(RC,",",2)
 i +RC=RCINERR DO  G vol1:$$YESNO(1) S DEV="" G VOLLABEL
 . W *7,!,"[Can't open "_DEV_"] Retry it?"
head D VOLHEAD I 'OK S RC=$$ZU(52,3,"") G VOLLABEL ;get header part of label
 Q
OpenDev(DEV) s $ZT="OpenErr" Quit $$ZU(52,0,DEV)
OpenErr Quit RCINERR
VOLHEAD ;
 S OK=0 ;,VOLLOC=BUFBASE+$P(RC,",",2) ; start at beginning of volume label
 I +RC=RCOLDFORMAT D  S OK=0 S DEV="" Q
 . W *7,!,"[This volume has an obsolete backup format not supported by this "_"InterSystems IRIS"_" version]",!
 I +RC=RCBADVOLUME D  S OK=0 S DEV="" Q
 . W *7,!,"[This is not a "_"InterSystems IRIS"_" Backup File]",!
 N HEAD S HEAD=$$nextvol()
 I "InterSystems IRIS"_" BACKUP"'=HEAD,"Open M BACKUP"'=HEAD DO  S OK=0 S DEV="" Q
 . W *7," [This is not a "_"InterSystems IRIS"_" Backup File]",!
 N VERID,HEAD,BackupVersion
 S VERID=$$nextvol()  ;"VERSION<nnn>" where <nnn> is the version #
 I $E(VERID,1,7)="VERSION" {
     s vernum=+$E(VERID,8,*)
     ; vernum is 0 for "VERSION", 1 for "VERSION1.0", etc...
    S BackupVersion=$$nextvol()  ;$ZV string
    S HEAD(1)=$$nextvol()  ;Backup volume #
 } else {
    S HEAD(1)=VERID,BackupVersion="UNKNOWN"
    s vernum=0
 }
 F I=2:1:12 S HEAD(I)=$$nextvol() ; Read header info
 if vernum>0 {
     ; version 1 introduces mirror support. 
     s HEAD(13)=$$nextvol()  ; : seperated mirror name, guid, local sys name, etc
 } else {
     s HEAD(13)=""  ;JO2379
 }
 if VOLNUM=1,$P(HEAD(13),":",3)="" {
     s MirrorBackup=0
 } else {
     s MirrorBackup=1
 }
 I HEAD(1)'=VOLNUM do $ZU(31,1,BUFCOUNT) D volerr("Volume number") Q
 I VOLNUM'=1 {
    /* This is not a 1st volume, so verify that it is for
       the correct backup and then quit
       [JO2313] we could add code here to store/validate the mirror id
       (eg. HEAD(13)) across volumes if that seems useful
    */
    i BACKDATE'=HEAD(2) do $ZU(31,1,BUFCOUNT) D volerr("Date") q
    i BACKTIME'=HEAD(3) do $ZU(31,1,BUFCOUNT) D volerr("Time") q
    i BACKTYPE'=HEAD(4) do $ZU(31,1,BUFCOUNT) D volerr("Type") q
    i DESCRIPTION'=HEAD(11) do $ZU(31,1,BUFCOUNT) D volerr("Description") q
    if MIRRORINFO'=HEAD(13) do $ZU(31,1,BUFCOUNT) D volerr("MirrorInfo") q
    S OK=1 ; This volume label is correct
    quit
 }
 I BACKSET=1 {
     if '$G(QUIETMODE) {
         D volh1 
         Q:'OK  ;1st volume for 1st backup
     }
     if MirrorBackup {
         ; MirrorRestore=0 - ignore mirror informatin
         ;              =1 - restore all db's (backup is from this system)
         ;              =2 - restore only mirrored db's which exist
         s MirrorRestore=$$GetMirrorInfo(HEAD(13),RESTYPE,$G(QUIETMODE))
         if MirrorRestore'=0 {
             if (vernum<1.1)&&(RESTYPE="ALL")&&(TopDir="") {
                 /* For a restore of all databases without specifying a
                   new topdir we require a backup version # of 1.1 or 
                   higher. 1.1 added the mirror database nofailover flag to
                   the backup header. It would be ok to continue however the
                   code will think all the mirrored databases have the nofailover
                   flag clear (eg. they are read/write) so it will refuse to restore
                   any of them. */
                   if '$G(QUIETMODE) {
                       w !,"This is a version ",vernum," backup file from an older"
                       w !,"mirror member so the mirrored databases cannot be automatically"
                       w !,"restored. Use a selective restore or pick a new top level"
                       w !,"directory. Because it is from an older version, DBREST will not"
                       w !,"prevent a database in the backup which was marked read/write on"
                       w !,"an async member from begin restored over a read/only failover copy."
                   }
                   goto ERR
             }
             if (RESTYPE="SELECT") && ('$G(QUIETMODE)) {
	             ; If this is a selective restore involving mirrored databases
	             ; we ask the user whether they want to process all databases or
	             ; only mirrored databases. 
	             r !,"Limit restore to mirrored databases? ",resp
	             while "YyNn"'[$E(resp_"X") {
		             w !,"Please answer yes or no"
	                 r !,"Limit restore to mirrored databases? ",resp
	             }
	             if "Yy"[$E(resp) {
		             s SelectOnlyMirrorDBs=1
	             } else {
		             s SelectOnlyMirrorDBs=0
	             }
             }
             do BuildMirrorDBList($G(QUIETMODE),.MirrorDBList)
         }
     }
 }
 I $G(QUIETMODE) S OK=1
 I BACKSET'=1 DO  q:'OK
 . i HEAD(4)="Full" DO  Q
 . . w !,"This is a full backup file. A full backup can only be"
 . . w !,"the first backup restored in a sequence. If there are"
 . . w !,"multiple full backups which need to be restored, ^DBREST"
 . . w !,"must be run separately for each file. Restoring"
 . . w !,"multiple full backups in a single run of DBREST would"
 . . w !,"cause problems with the subsequent journal restore."
 . . s DEV=""
 . . s OK=0
 . i HEAD(4)="Cumulative Incremental" DO  Q
 . . I HEAD(5)<PREVH ;either before that date
 . . E  I +HEAD(5)=+PREVH,$p(HEAD(5),",",2)<$p(PREVH,",",2) ;or time
 . . I  W !,"Date must be more recent than last restored backup"
 . . I  D volerr("Date") Q
 . . I PREVFDATE'="",PREVFDATE'=HEAD(9) D volerr("Date") q
 . . I PREVFTIME'="",PREVFTIME'=HEAD(10) D volerr("Time") q
 . . S OK=1
 . ; Must be a regular incremental backup - Check that the
 . ; previous date/time match the last restored date/time
 . i PREVDATE'=HEAD(6) D volerr("Date") q
 . i PREVTIME'=HEAD(7) D volerr("Time") q
 . S OK=1 ; This volume label is correct
 ;
 S BACKDATE=HEAD(2),BACKTIME=HEAD(3),BACKTYPE=HEAD(4),BACKH=HEAD(5)
 S PREVDATE=HEAD(6),PREVTIME=HEAD(7),PREVTYPE=HEAD(8)
 S PREVFDATE=HEAD(9),PREVFTIME=HEAD(10),DESCRIPTION=HEAD(11)
 S MIRRORINFO=HEAD(13)  ;From $$LookupMirrorInfo^DBACK()
 I BACKTYPE="Full" S PREVFDATE=BACKDATE,PREVFTIME=BACKTIME ;Full!
 Q
volerr(A) w !,*7," [",A," error in the volume label]",!
 D voldisp S OK=0
 W !,"We were expecting:",!,"  Volume #: ",VOLNUM
 W "  with Previous date: ",PREVDATE,"  and time: ",PREVTIME
 W !,"  and buffer count of: ",BUFCOUNT,!!
 Q
 ; Display the volume label
voldisp d:BackupVersion="UNKNOWN" Show("volnover")
 d:BackupVersion'="UNKNOWN"
 . n Vers ; remove date & time from end of version string
 . s Vers=BackupVersion,Vers=$e(Vers,1,$f(Vers," ",$f(Vers,")")+1)-2)
 . d Show("voldisver",Vers)
 d Show("voldis14",HEAD(1),HEAD(2),HEAD(3),HEAD(4))
 d Show("voldis68",HEAD(6),HEAD(7),HEAD(8))
 d Show("voldis9e",HEAD(9),HEAD(10),HEAD(11),HEAD(12))
 if HEAD(13)'="" {
	 if $P(HEAD(13),":",1)'="" {
		; backup is from a failover member, mirror name is not null
        d Show("voldis13",$P(HEAD(13),":",1),$P(HEAD(13),":",3))
	 } else {
		; backup is from an async member, mirror name is null
        d Show("voldis13b",$P(HEAD(13),":",3))
	 }
 }
 Q
volh1 D voldisp W !,"Is this the backup you want to start restoring?"
 S OK=$$YESNO(1) Q
GETDEV ;select a device to use -- returns DEV,OK
 W !!,"Specify input file for volume "_VOLNUM
 ;
 I VOLNUM=1 DO  ;first time!
 . I PREVDATE="" W " of backup "_BACKSET
 . E  w " of backup following "_PREVDATE_"  "_PREVTIME
 ;
 I VOLNUM>1 W " dated "_BACKDATE_"  "_BACKTIME
 ;
 W !," (Type STOP to exit)"
 W !,"Device: " W:DEV]"" DEV_" => " R ANS,! S:ANS]"" DEV=ANS
 I DEV=""!$$STOP(ANS) S OK=0 Q
 ;
 S DEV=$$FILENORM(DEV) S OK=1
 S XLT=$$GETXLT(DEV)
 Q        
GETXLT(DEV) ;get nls translation table for this device
 I DEV?2N,$G(^%IS(DEV,0))="Magnetic tape" S XLT=$$GetPDefIO^%SYS.NLS(4)
 E  S XLT=$$GetPDefIO^%SYS.NLS(3)
 Q XLT
 ;
 ; nextlabel
 ; we've reached a label record or missing label record
 ; get its characteristics
 ; call: x is return string from a function
 ;       with return code of RCDIRLABELRECORD,RCDIRLABELMISSING, or RCBADRECORDONRESTORE
 ; returns: sfn  input file #
 ;          dir  directory name to which restore
nextlabel(x) ;
 s zu49=""
 i +x=RCDIRLABELMISSING s sfn=$p(x,",",3),filesize=$p(x,",",4) q:'filesize
 e  i +x=RCDIRLABELRECORD!(+x=RCBADRECORDONRESTORE) s sfn=$p(x,",",6),filesize=$p(x,",",7),zu49=$p(x,",",8,99)
 s (dir,DIR)=gdir(sfn)  ; get directory name
 s DIRNAM=$p($g(DIRNAM(DIR)),"^",1) s:DIRNAM="" DIRNAM=DIR
 i +x'=RCBADRECORDONRESTORE,$d(DIRNAM(DIR)) s $p(DIRNAM(DIR),"^",2)=filesize
 ; make sure current file is at least filesize big
 ; If not, then expand it
 ; If +x=RCBADRECORDONRESTORE, then the filesize and zu49 info is questionable but the rest is reliable
 q
 ;
initconstants ;
 s OBDIRLAB=65536*65536-1 ;directory label "blk #"
 s RCSUCCESS=1   ;success
 s RCINERR=-1    ; General Input error
 s RCOUTERR=-2   ; General output error 
 s RCMOUNT=-4    ; either directory name was too long or we couldn't mount the directory
 ; input errors during backup (in addition to RCINERR)
 s RCBADMAP=-11  ; 2kb: missing incremental bitmaps
                 ;big database: Bad label in incremental backup bitmap
 s RCMAPINERR=-13 ; disk error reading incremental backup bitmap
 ;
 ; write errors during backup (in addition to RCOUTERR)
 ;
 s RCEOT=2       ; Output: end of tape or volume
 s RCOFFLINE=3   ; Output device offline
 s RCDEVFUL=4    ; Output: file expansion failed
 ; # 5 no longer used
 ;
 ; input errors during $zu(52,0,device) which opens input volume and reads label
 ; (in addition to RCINERR)
 s RCOLDFORMAT=-6        ; On a restore, Input file has old backup
                         ;file format.  Abort the restore.
 s RCBADVOLUME=-7        ; Input file is not backup file format.
                         ;In general, if we fail during open of input
                         ;device or 1st read of it we get an RCINERR error.
                         ;If the volume block's contents are bad, we
                         ;get either RCBADVOLUME or RCOLDFORMAT
 ; success returns during restore
 s RCENDOFVOL=-10        ; End of input backup volume reached
 s RCENDOFVOLSET=-17     ; End of input backup volume reached and
                         ; this is the last volume
 s RCDIRLABELRECORD=-18  ; reached a directory label record, current
                         ; record is next record
 s RCDIRLABELMISSING=-19 ; we're at a data record for a different
                         ; directory and we should act as if we
                         ; reached a directory label except the
                         ; current record is the first data block of the
                         ; next directory to be restored.  This usually
                         ; is the result of various read errors that
                         ; resulted in missing a directory label record
 s RCJRNMARKINFORECORD=-20 ;reached a journal marker info record, likely the
                         ; last record on the last volume
 ; input errors during restore (during restore, if we get an input
 ; error we usually translate it to something else)
 s RCINERRLABELGOOD=-14  ; We got an error reading a block but
                         ; it passed validation on its label.
                         ; The contents should be reported by the
                         ; utility as suspicious unless we can
                         ; determine that there's a particular
                         ; 1 or more records that fail crc.
                         ; We should then try to restore its contents,
                         ; and we should expect one or more of the
                         ; records in the block to result in
                         ; a RCBADRECORDONRESTORE error.
 s RCBADRECORDONCOPY=-15 ; record in rinbp->ricurr is bad
                         ; It was bad when the backup was originally
                         ; created i.e. we got a read error during
                         ; the backup). Normally the utility
                         ; should save a copy of the block that
                         ; is already in the CACHE.DAT file and
                         ; then restore this block
 s RCBADRECORDONRESTORE=-8 ; record in rinbp->ricurr failed
                         ; CRC validation, probably due to a read
                         ; error during the restore.
                         ; We probably previously got a
                         ; RCINERR_LABELGOOD error on this block.
                         ;  If both _ONCOPY and _ONRESTORE conditions
                         ; are present, we report it as _ONRESTORE.
                         ; Normally the utility should save a copy of the
                         ; block that is already in the CACHE.DAT file and
                         ; then restore this block
 s RCMISSINGBLKS=-16     ; The block # of the last record in the last block
                         ; successfully read from the input media doesn't
                         ; match what this block has in incrlabel_LASTBLKNUM
                         ; and incrlabel_LASTSFN.   We must have skipped
                         ; some blocks (which is probably the result of read
                         ; errors.)
 ; -9, RCBADLABEL, is no longer used.  If we get an input block
 ; whose label fails validation (e.g. CRC wrong), we act like we
 ; just got an input error
 s RCBLKSIZE=-12 ; record in rinbp->ricurr has the wrong
                 ;block size for this CACHE.DAT file
                 ;If this is the first block for this CACHE.DAT
                 ;then we probably are restoring to the wrong
                 ;CACHE.DAT (one with a different block size),
                 ;and that is a fatal error.  Otherwise it is
                 ;probably a label error and we should skip this
                 ;input block.
 ; other restore errors in $zu(52,1,...) and $zu(52,4)*/
 s RCOUTCLUMNT=-3        ; Target of restore is cluster mounted
                         ;       but must be privately mounted.  This error
                         ;       occurs when we issue $zu(52,1,...) to open
                         ;       cache.dat file as target JAO742
 s RCMAPERR=-5   ; 2kb only: Problem detected between
                 ;          source & target map blocks.  This is
                 ;           a fatal error in attempting to restore
                 ;           to this target file JAO572
 q
 /* GetMirrorInfo when the volume header of the 1st backup being
    restored indicates it came from a mirror. We come here to
    figure out whether we're a member of this mirror and if so,
    what we want to do.
    Returns a value for MirrorRestore based on what we should do with 
    mirrored db's for a full database restore (selective database restores 
    the user decides what to do with each database).
    ReturnValue = 0 - Mirrored databases are not restored
                = 1 - Backup being restored on mirror member which generated
                      the backup, all databases are restored
                = 2 - Backup being restored on a different mirror member, only
                      mirrored databases which exist locally are restored 
                      (also used when restoring to async members)
 */
GetMirrorInfo(MIRINFO,RESTYPE,QUIETMODE) PUBLIC {
    ; When MirrorRestore is 0 we will restore mirrored db's but
    ; we don't do anything special. The target of a restore cannot be
    ; a mirrored database.
    s QUIETMODE=+QUIETMODE
    s isMirror=($SYSTEM.Mirror.GetInfo()[",DEFINED,")||$D(^SYS("MIRRORSET"))
    if 'isMirror {
        if 'QUIETMODE {
           w !,"Restoring a mirror backup but this system is not a mirror member"
        }
        quit 0
    }
    ;
    Set isReportingNode = ##class(Config.MirrorMember).isAsyncMember()
    if isReportingNode {
        ; Only restore databases which exist on the local system
        quit 2
    }
	s MirrorName=##class(Config.Mirrors).GetMirrorName()
    if MirrorName="" {
        if 'QUIETMODE {
           w !,"Mirror name not set in mirror configuration"
        }
        quit 0
    }
	s cls=##class(Config.Mirrors).Open(MirrorName,,,.rc)
    s MirrorGUID=cls.GUID
    s cls=""
    ;
    s cls=##class(Config.MirrorMember).Open(,,.rc)
    if ('rc) {
        if 'QUIETMODE {
            k err
            Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
            w !,"Failed to open mirror member configuration: ",err(1)
        }
        quit 0
    }
    s SystemName=cls.SystemName
    if SystemName="" {
        if 'QUIETMODE {
            w !,"Mirror system name not defined in mirror member configuration"
        }
        quit 0
    }
    ;
    s cls=##class(Config.MapMirrors).Open(MirrorName,SystemName,,,.rc)
    if ('rc) {
        if 'QUIETMODE {
            k err
            Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
            w !,"Failed to open MapMirrors.",MirrorName," to read info for ",SystemName,": ",err(1)
        }
        quit 0
    }
    s SystemGUID=cls.GUID
    s cls=""
    ;
    ; these are stored in HEAD(13) by LookupMirrorInfo^DBACK()
    s BackupMirrorName=$P(MIRINFO,":",1)  ;mirror name
    s BackupMirrorGUID=$P(MIRINFO,":",2)  ;guid of mirror
    s BackupSystemName=$P(MIRINFO,":",3)  ;guid of instance which ran backup
    s BackupSystemGUID=$P(MIRINFO,":",4)  ;guid of instance which ran backup
    if MirrorGUID'=BackupMirrorGUID {
        ; this backup is from a different mirror (and we're not a reporting
        ; node).
        if 'QUIETMODE {
            w !,"This backup is from a different mirror (",BackupMirrorName,")."
        }
        quit 0
    }
    if SystemGUID'=BackupSystemGUID {
        if 'QUIETMODE {
            w !,"This backup was made on the other mirror member."
            if RESTYPE="ALL" {
               w !,"Only mirrored databases which exist locally will be"
               w !,"restored."
            }
        }
        quit 2  ;only restore mirrored databases
    }
    ; this backup was created by this mirror member,
    ; restore everything (we could ask what they want to do here)
    quit 1
}   
 /* BuildMirrorDBList returns information about a mirrored
    database on the local system which might or might not be
    part of the active mirror (it could be dismounted, it could
    require catchup or it could be an active database). The
    information returned matches the information stored by
    getMirDBINFO^DBACKB for each database when the backup was
    created. */
BuildMirrorDBList(QUIETMODE,dblistp) PUBLIC {
    s x=$zu(40,0,41)
    s sfnmax=($V($ZU(40,2,176),-2,4))-1  ;highest sfn used
    s QUIETMODE=+QUIETMODE
    for sfn=0:1:sfnmax {
        s dbdata=$ZU(49,+sfn)
        if +dbdata>-1,($zb(+$p(dbdata,",",17),$zu(40,8,28),1)) {
           s namedata=$zu(49,+sfn,3)
           s locdir=$P(namedata,"^",2)
    	   s info=$SYSTEM.Mirror.DBGetInfoByName(0,locdir)
    	   if info'="" {
			   s dbname  =$P(info,"^",2)
			   s mirjrnfilecnt =$P(info,"^",3)
			   s jrnoff  =$P(info,"^",4)
			   s dbguid  =$P(info,"^",6)
			   s mirguid =$P(info,"^",7)
			   s mirname =$P(info,"^",8)
			   s sysguid =$P(info,"^",9)
			   ;
			   s nofailoverflag=+$P(info,"^",12)
			   s nofailoverbit=+$ZU(40,8,31)
			   s readonly=$ZB(nofailoverflag,nofailoverbit,1)          
			   if readonly'=0 s readonly=1
			   ; lastfilecntrestored is usually zero unless the database
			   ; is currently being caught up. In that situation this contains
			   ; the mirjrnfilecnt of the last journal file replayed to
			   ; this database.
			   s lastfilerest =$P(info,"^",11)
			   ; 
			   ; getMirDBINFO uses : as a seperator so we'll use that here
			   ; as well as it probably reduces confusion. Since we're using
			   ; : though we can't store any filenames/paths in the string
			   s backupinfo=dbname_":"_mirjrnfilecnt_":"_jrnoff_":"_dbguid
			   s backupinfo=backupinfo_":"_mirguid_":"_mirname_":"_sysguid
			   s backupinfo=backupinfo_":"_readonly
			   ;
			   s mirdbname=":mirror:"_mirname_":"_dbname
			   if '$D(dblistp(mirdbname)) {
                  s dblistp(mirdbname,"path")=locdir
                  s dblistp(mirdbname,"info")=backupinfo
                  s dblistp(mirdbname,"inactive")='$zb(+$p(dbdata,",",18),$zu(40,8,29),1)
                  s dblistp(mirdbname,"activationreq")=$zb(+$p(dbdata,",",18),$zu(40,8,32),1)
                  s dblistp("path",locdir)=mirdbname  ;create a translation from path->mirror db name
			   } else {
				  if 'QUIETMODE {
				     w !,"Two copies of ",mirdbname," found"
			         ; 1st copy				     
					 w !,?5,dblistp(mirdbname,"path")," "
					 if dblistp(mirdbname,"inactive") {
						 w "(inactive)"
					 } else {
						 w "(active)"
					 }
					 ; new copy
					 w !,?5,locdir," "
					 if '$zb(+$p(dbdata,",",18),$zu(40,8,29),1) {
						 w "(inactive)"
					 } else {
						 w "(active)"
					 }
					 w !,"Ignoring 2nd copy"
			      }
			   }
	   	    }
        }
    }
    quit
}
INLOGOR(DIR,SOURCE,TARGET,DISPOSE) ;Adapter, present same i'face for VAX & UX
 n rc
 try {
   s rc=$ZU(31,DIR,SOURCE,TARGET,DISPOSE)
 } catch {
   s rc=-1_","_$ze
   s $ze=""
 }
 q rc
FILENORM(NAME) ;Return normalized version of NAME
 S OK=1,$ZT="FNERR"
 N MTDEV,DIR S MTDEV=$$OSDEVICE(NAME) I MTDEV'="" S ISREG=0 Q NAME
 i ($zversion(1)=2),$E(NAME,1,2)="\\" S L=$$CheckForTape(NAME) I L'="" S ISREG=0 Q L
 i ($zversion(1)=2) S L=$L(NAME,"\"),DIR=$P(NAME,"\",1,L-1)
 i ($zversion(1)=2) IF L>1 S DIR=DIR_"\"
 i ($zversion(1)=2) S NAME=$ZU(12,DIR)_$P(NAME,"\",L,L),ISREG=$ZU(140,7,NAME),ISREG=$S(ISREG>0:1,ISREG=-2:1,1:0) Q NAME
 i ($zversion(1)=3) S L=$L(NAME,"/"),DIR=$P(NAME,"/",1,L-1)
 i ($zversion(1)=3) IF L>1 S DIR=DIR_"/"
 i ($zversion(1)=3) S NAME=$ZU(12,DIR)_$P(NAME,"/",L,L),ISREG=$ZU(140,7,NAME),ISREG=$S(ISREG=-2:1,ISREG/32768#2:1,1:0) Q NAME
FNERR S OK=0,ERRMSG="Not a valid device name." Q
CheckForTape(NAME)
 S NAME=$ZCVT(NAME,"U")
 N I,TAPE
 For I=47:1:62 s TAPE=$$OSDEVICE(I) I NAME=$ZCVT(TAPE,"U") S NAME=I Q
 I NAME?2N Q NAME
 I NAME?1"\\.\TAPE"1N Q NAME
 Q ""
TQUIWRITE(verbose) q $$QUIESCE(1,"buffer activity",10,verbose)
TQUIGC(verbose) q $$QUIESCE(2,"garbage collection",10,verbose)
TQUIDB(verbose) q $$QUIESCE(4,"database expansion",10,verbose)
TQUIGLO(verbose) q $$QUIESCE(8,"global activity",10,verbose)
TQUIGLOUPD(verbose) q $$QUIESCE(16,"global updates",10,verbose)
TQUINET(verbose) q $$QUIESCE(32,"network activity",10,verbose)
TQUIDISK(verbose) q $$QUIESCE(1+2,"disk activity",10,verbose)
TQUIUPD(verbose) q $$QUIESCE(1+2+4+16,"update activity",10,verbose)
TQUISYS(verbose) q $$QUIESCE(1+2+4+8,"system activity",10,verbose)
QUIESCE(bits,text,retries,verbose,intv) ;
 s verbose=+$g(verbose),retries=+$g(retries,-1),intv=+$g(intv,1)
 q ($$Quiesce(bits,text,retries,verbose,intv)>0)
Quiesce(bits,text,retries,verbose,intv) ;
 n noWDbits
 s $zt="QUIESCEE"
 q:$zu(51,bits) 1 ;double checking $ZU(51) is no longer necessary
 s verbose=+$g(verbose),retries=+$g(retries,-1),intv=+$g(intv,1)
 d msgout($c(13,10)_"WARNING: Switch is set and may affect production for up to "_(retries*intv)_" seconds."_$c(13,10)_"Waiting for "_text_" to finish...",NOFORCE)
 f  q:'retries  h intv q:$zu(51,bits)  s retries=retries-1 i retries#5=0 d msgout(".",NOFORCE)
 s noWDbits=1
 s:$s($S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0):''$zu(59,0),1:0) noWDbits=noWDbits+2
 s noWDbits=$zboolean(bits,noWDbits,2)  ;2 = x & ~ y
 if '$ZU(51,bits),bits'=1,$zboolean(bits,1,1),$zu(51,noWDbits) {
	 d msgout($c(13,10)_"System is idle except WD is still running."_$c(13,10)_"     Waiting up to 2 minutes for WD to finish",NOFORCE)
	 f i=1:1:120 q:$ZU(51,bits)  h 1 if i#5=0 d msgout(".",NOFORCE)
	 if $ZU(51,bits) s retries=1 ;signal success
 }
 d msgout($s(retries:" ready.",1:" abort. "_$$quiescefailmsg(bits))_$c(13,10),NOFORCE)
 q retries
quiescefailmsg(bits)
 N ret,clu,clumsg s ret="",clu=$zb(bits,512+256+128,1),clumsg=""
 if $zb(clu,128,1)||($zb(clu,(256+512),1)=(256+512)) s clu=128,clumsg=" (cluster wide)"
 if $zb(clu,512,1) s clumsg=" (cluster master only)"
 if $zb(clu,256,1) s clumsg=" (cluster slaves only)"
 if $zb(bits,1,1)&&('$ZU(51,clu+1)) S ret=ret_"write daemon"_clumsg_","
 if $zb(bits,2,1)&&('$ZU(51,clu+2)) S ret=ret_"garbage collector"_clumsg_"," 
 if $zb(bits,4,1)&&('$ZU(51,clu+4)) S ret=ret_"file expander"_clumsg_","
 if $zb(bits,8,1)&&('$ZU(51,clu+8)) S ret=ret_"global reference"_clumsg_","
 if $zb(bits,16,1)&&('$ZU(51,clu+16)) S ret=ret_"global update"_clumsg_","
 if $zb(bits,32,1)&&('$ZU(51,clu+32)) S ret=ret_"client-side network connections"_clumsg_","
 if $zb(bits,64,1)&&('$ZU(51,clu+64)) S ret=ret_"network server activity"_clumsg_","
 if ret'="" s ret="Quiesce failed reason: "_$e(ret,1,*-1) d $zu(9,"",ret,1,2) i $d(^rOBJ("ZQuiesceFail")) d ^ZQuiesceFail
 Q ret
QUIESCEE s $zt="" d $zu(9,"","QUIESCE: "_$ze,(1>0),1) q -1 ;0
CluQuiet(switch,target,timeout)
 n flags,rc
 i $g(switch)-10,$g(switch)-13 ztrap "SWITCH"
 n targetmsg s target=$g(target)
 i target=1 s target=256,targetmsg=" on cluster slave members"
 e  i target=2 s target=512,targetmsg=" on cluster master"
 e  s target=512+256,targetmsg=" cluster wide"
 s flags=1+2+4+$s(switch=10:8,1:16)
 s rc=$$Quiesce(flags+target,$s(switch=10:"system activity",1:"update activity")_targetmsg,$g(timeout,10),'$g(QUIET,$g(QUIETLY)))
 i rc<0 ztrap "Abort"
 q rc
quietsw(switch,timeout) ;quiesce activities w/ timeout after setting switch 10 or 13
 n flags,rc
 i $g(switch)-10,$g(switch)-13 ztrap "SWITCH"
 s flags=1+2+4+$s(switch=10:8,1:16)
 i CLUBACKUP s flags=flags+128
 s rc=$$Quiesce(flags,"disk cleanup",$s($g(timeout)="":30,1:timeout),'$g(QUIET))
 i rc<0 ztrap "Abort"
 q rc
hibernate(switch,released,timeo) ;
 i +$g(released) d msgout($c(13,10)_"Switch "_switch_" is released.",NOFORCE)
 n hibtime s hibtime=$s(timeo>3:10,timeo>2:1,timeo>1:.1,timeo>0:.01,1:10)
 d msgout($c(13,10)_"Backup will hibernate for "_hibtime_" second(s) and try again."_$c(13,10)_"You may abort Backup via Ctrl-C. ",NOFORCE) 
 i hibtime<1 h hibtime
 e  n i f i=1:1:hibtime h 1 d msgout(".",NOFORCE)
 d msgout($c(13,10),NOFORCE)
 q
ENQ10 ;
 n t s t=$g(quietimeout,60) s:t>0 t=(t+9)\10 ;rounded up to 10 sec
 s $zt="ENQ10e"
 i CLUBACKUP d  q
 . f  q:$$CLU^SWSET(10,1,ALRDY10,$g(QUIETMASTERONLY))  s t=t-1 zt:'t "Abort" d hibernate(10,'ALRDY10,t)
 i ALRDY10 q:$$quietsw(10)  zt "Abort"
 f  S %SW=10,%VAL=1 D INT^SWSET  q:$$quietsw(10)  s t=t-1 zt:'t "Abort" d DEQ10,hibernate(10,1,t)
 Q
ENQ10e s $zt="" d DEQ10 ztrap $ze
DEQ10 ;
 i CLUBACKUP,$ZU(95,10,0)  ; Clear SW10 clusterwide
 i 'ALRDY10 s %SW=10,%VAL=0 D INT^SWSET
 Q
ENQ13 ;
 n t s t=$g(quietimeout,60) s:t>0 t=(t+9)\10 ;rounded up to 10 sec
 s $zt="ENQ13e"
 i CLUBACKUP d  q
 . f  q:$$CLU^SWSET(13,1,ALRDY13)  s t=t-1 zt:'t "Abort" d DEQ13,hibernate(13,'ALRDY13,t)
 i ALRDY13 q:$$quietsw(13)  zt "Abort"
 f  S %SW=13,%VAL=1 D INT^SWSET  q:$$quietsw(13)  s t=t-1 zt:'t "Abort" d DEQ13,hibernate(13,1,t)
 Q
ENQ13e s $zt="" d DEQ13 zq 1 g:$zt'="" @$zt q
DEQ13 ;
 i CLUBACKUP,$ZU(95,13,0)  ; Clear SW13 clusterwide
 i 'ALRDY13 s %SW=13,%VAL=0 D INT^SWSET
 Q
HOLDWD(dir,time,flag) ;suspend write daemon (dir may be passed as an array)
 n n
 i $zu(182,1,0) ;clear any remaining backup request
 f  q:'$zu(182,0)  h 1  ;wait until write daemon runs again
 i $d(dir)<10 d $zu(52,9,dir,1) d:$g(flag)=1 $zu(52,8,dir,0) d $zu(182,2,0,+$zu(49,dir)) s n=1 i 1
 e  s dir="" f n=0:1 s dir=$o(dir(dir)) q:dir=""  d $zu(52,9,dir,1) d:$g(flag)=1 $zu(52,8,dir,0) d $zu(182,2,n,+$zu(49,dir))
 i $zu(182,1,n,$g(time))  ;set number of databases to back up (and optional CP wait time)
 f  q:$zu(182,0)  h 1  ;wait until write daemon suspends
 q
FREEWD ;unsuspend write daemon
 i $zu(182,1,0)
 q
msgout(aaamess,flag) ;
         s flag=$g(flag,1) ; default to FORCE
         W *-1            ;Flush the input buffer 
         q:'$L(aaamess)   ; Avoid argumentless writes...
         i $g(logfile)'="" u logfile w aaamess
         u 0
         q:flag=3  ; 1 = FORCE, FORCE, 2 = NOFORCE, 3 = LOGONLY
         i '$G(INTERNAL,0)!('$G(NOINPUT,0)&(flag=1!'$G(QUIET,0))) w aaamess
         i $g(gui) D  
         . s return=$$IjcMsg^%Wprima("DI"_aaamess) ; Retval might =  cancel msg
         . i return="CANCEL" d  
         . . i $$IjcMsg^%Wprima("DI"_$c(13,10)_"Abort received!"_$c(13,10))
         . . zt "Abort"
         u 0 
         q
timestmp(flag) 
         n msg,%TS,%TN
         s msg="TIMESTAMP: "
         s %DN=+$H d INT^%DO
         s msg=msg_%DS
         s %TN=$P($h,",",2) d ^%TO
         s msg=msg_" "_%TS
         d msgout($c(13,10)_msg_$c(13,10))
         q
OSDEVICE(mdevice,new) ;osdevice + range check, pad input, strip output.
 s mdevice=+mdevice q:mdevice<47 ""  q:mdevice>62 ""
 i $d(new) s new=$$zpad(new,32)
 q $$zstrip($$osdevice(mdevice,.new))
osdevice(mdevice,new) ;"Raw" osdevice
 n adr,old,size,where,charsize
 s $ZT="osdeverr"
 s charsize=$$charsize^%Wprim() ; check size one char
 s size=32,adr=(mdevice-47)*(size*charsize)+$ZU(40,2,28),where=-2
 s old=$v(adr,where,-size_"w")
 i $d(new) v adr:where:-size_"w":new
 q old
osdeverr q ""
zstrip(x) ;Return x with ASCII NUL's removed
 q $tr(x,$c(0),"")
zpad(x,len) ;x, maybe truncated, NUL-padded to length len, one NUL guaranteed
 n zeroes
 s zeroes=$j("",len),zeroes=$tr(zeroes," ",$c(0)) ;String of len NUL's
 s x=$e(x,1,len-1) ;Silently truncate x if necessary
 s $e(zeroes,1,$l(x))=x
 q zeroes
ZU(A,B,C,D,E,F,G,H,I,J,K,L,M,N,P) ;so needn't change $$ZU's to $ZU's
 IF '$D(B) Q $ZU(A)
 IF '$D(C) Q $ZU(A,B)
 IF '$D(D) Q $ZU(A,B,C)
 IF '$D(E) Q $ZU(A,B,C,D)
 IF '$D(F) Q $ZU(A,B,C,D,E)
 IF '$D(G) Q $ZU(A,B,C,D,E,F)
 IF '$D(H) Q $ZU(A,B,C,D,E,F,G)
 IF '$D(I) Q $ZU(A,B,C,D,E,F,G,H)
 IF '$D(J) Q $ZU(A,B,C,D,E,F,G,H,I)
 IF '$D(K) Q $ZU(A,B,C,D,E,F,G,H,I,J)
 IF '$D(L) Q $ZU(A,B,C,D,E,F,G,H,I,J,K)
 IF '$D(M) Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L)
 IF '$D(N) Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L,M)
 IF '$D(P) Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
           Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L,M,N,P)
MORE Q
  ;#endif $$$NEWINC  ; CFL284-

DBRESTP^INT^1^67214,47330
DBRESTP ;Incremental Backup Restore ;$Change: 6287789 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/_syMirror.inc#1 $ ($Change: 7440104 $) */
        /* Initializing is the state a member has at startup until it
           gets to wait^MIRRORMGR for the 1st time. At that point it has 
           either become the backup or primary or we set the role to null
           to indicate that it is up and running as opposed to still getting
           started */
				    /* Arbiter failover rules are in effect */
				    /* Agent contact is required */
					/* IsOtherNodeDown^ZMIRROR */
				/* The client supports the arbiter */
			 	/* This system is connected to the arbiter */
		  		/* The other failover member is connected to the arbiter */
		  		/* Either the QOSTimeout changed or the arbiter address changed.
		  		   we should look up the current values and use them */
				/* Arbiter job shoud close the connection and exit. The
				   retry routine can restart the arbiter if conditions
				   warrent. Generally used with clearing ArbiterSupported
				   when the backup is removed or demoted. Cleared when
				   the arbiter exits (eg. its a one time flag). */
 q  ;disable UI for now ;HYY2550
EXTALL(QUIETMODE,MasterJob,INPDEV,DIRLIST,JRNOPT,DEJRNSTART,dejrn)
 n (QUIETMODE,MasterJob,INPDEV,DIRLIST,JRNOPT,DEJRNSTART,dejrn)
 i MasterJob {
   i '($zu(12,INPDEV,2)'="") {
     q $System.Status.EmbedStatus($$Error^%apiOBJ(7359),$$Error^%apiOBJ(5021,INPDEV))
   }
 } elseif '($zu(140,4,INPDEV)=0) { ;for worker job
     s %result=$listbuild($$Error^%apiOBJ(5012,INPDEV))  ;Cannot open input device
     q 1
 }
 n OK,RC s OK=1,RC=1
 n INTERNAL,NOINPUT s INTERNAL=1,NOINPUT=1 ;INTERNAL implying NOINPUT
 n OverrideManifest s OverrideManifest=$g(dejrn)
 S $ZE="",JRNOPT=$E($G(JRNOPT))
 i $zj\2#2 s %UI="CHUI" ;jobbed job
 n dlmlock ;JO1991
 i '$SYSTEM.Security.Check("%Admin_Manage","USE") {
   s OK=$$Error^%apiOBJ(921,"%Admin_Operate"_":"_"USE")
   g begin2 ;error exit
 }
 G all
all ;
 N TopDir
 n RESTYPE,X
 S RESTYPE="ALL" G BEGIN
EXTSELCT(QUIETMODE,MasterJob,INPDEV,DIRLIST,JRNOPT,JRNFILE,JDIRGLO) 
 n (QUIETMODE,MasterJob,INPDEV,DIRLIST,JRNOPT,JRNFILE,JDIRGLO,%result)
 n OK,RC s OK=1,RC=1
 S $ZE="",JRNOPT=$E($G(JRNOPT))
 i $zj\2#2 s %UI="CHUI" ;jobbed job
 n dlmlock ;JO1991
 s MasterJob=0 ;EXTSELCT is called by a worker only
 n INTERNAL,NOINPUT s INTERNAL=1,NOINPUT=1 ;INTERNAL implying NOINPUT
 i '$SYSTEM.Security.Check("%Admin_Manage","USE") {
   s OK=$$Error^%apiOBJ(921,"%Admin_Operate"_":"_"USE")
   g begin2 ;error exit
 }
 s SELDIR(1)=$p(DIRLIST,",",1,2)_",y" ;SourceDatabaseDirectory,TargetDatabaseDirectory,createyes
 g select
 ; EXTERNAL ENTRYPOINT: ask each directory name and allow
 ; renaming the directories
select ; Determine what is probably the journal directory
 N TopDir
 n RESTYPE,X
 S RESTYPE="SELECT" G BEGIN
BEGIN ;
 S logfile=""  ; Do not log the text of the backup
 ;S logfile="d:\backup\log4xrst.txt"  ; Log the text of the backup
 i logfile'="" {
   o logfile:"WNS":5
   i '$t {
     w !,"Error opening log file ",logfile,!
     s OK=$$Error^%apiOBJ(5005,logfile)
     g begin2 ;error exit
   }
 }
 ; Some external entry points don't set this up so do it now
 n dbrtext d ^DBRTEXT
 N mtemp1 M mtemp1("menuse",$j)=^mtemp1("menuse",$j)
 s DEJRNSTART=""
 G BEGINDBREST2
FINISH() ;
 n 
 s FINAL=1,MasterJob=1,OK=1
 L +^DBACK:1
 i '$t q $$Error^%apiOBJ(7356,"")
 s time=$o(^SYS("RESTORE","BACKUP",""),-1) ;last restore
 i time="" L -^DBACK q OK ;no prior Restore() calls
 m dejrn=^SYS("RESTORE","BACKUP",time,"databases")
 m DIRNAM=^SYS("RESTORE","BACKUP",time,"DIRNAM")
 V $ZU(40,2,82):-2:4:$ZU(61,30,$ZU(61))  ; Load our jobid into incbkjobid
 s $ze="",$zt="begin2" ;to clear incbkjobid on exit
finish ; DBREST1 goes here
 i 'MasterJob { ;for individual workers
   s DIR=$o(DIRNAM("")) ;expecting DIR'="" if OK
   i DIR'="",OK { ;success
     s %result=$listbuild(OK,DIRNAM(DIR),DEJRNSTART)
     q 1
   }
   s %result=$listbuild(OK) ;expecting OK to be an error status
   q 1
 }
 i $g(FINAL) {
   ; clear GFINCREST flag in restored databases before exiting
   S DIR="" F  {
     S DIR=$O(DIRNAM(DIR)) Q:DIR=""
     s dir=$P(DIRNAM(DIR),"^",1)
     s:dir="" dir=DIR
     s n=$$ZU(52,5,dir,0)
     i n=-1 {
       d Show("GFINCRES",DIR) 
       k dejrn(DIR)
       s REASON(DIR)=$$Error^%apiOBJ(7373,DIR,n)
     }
   }
   g begin2
 }
 S DIR="" F  S DIR=$O(DIRNAM(DIR)) Q:DIR=""  D
 . s dir=$P(DIRNAM(DIR),"^",1),char=$P(DIRNAM(DIR),"^",2)
 . s:dir="" dir=DIR
 . s n=$$ZU(52,8,dir,1)  ;JO2329
 . i char'="" d
 . . s n=$$ZU(52,7,dir,+char)
 . . i n'=1 d
 . . . d Show("zu52err",n,DIR,char,$p($ZU(49,dir),",",4))
 . . . d Show("zu52e"_(-n))
 M ^mtemp1("menuse",$j)=mtemp1("menuse",$j)
 n mirlist  ;SML1106
 D remount
 D JRNIN ; save dejrn, DIRNAM, DEJRNSTART, etc.
 ; moved here from DBREST1, DBREST1 goes here
begin2 ;
 i $g(OK,1),$ze'="" s OK=$$Error^%apiOBJ(179,$ze) s $ze=""
 i 'MasterJob { ;error exit for individual workers
   s %result=$listbuild(OK) ;expecting OK to be an error status
   q 1
 }
 s $zt="restoreComplete"
 i 'OK { ;a fatal error (incl. restore failed for all databases)
   s OK=$system.Status.EmbedStatus($$Error^%apiOBJ(7359),OK)
 } elseif $d(REASON) { ;restore failed for some or all databases
   s tsc=$$REASONtoStatus(.REASON)
   i $d(DIRNAM)<10 { ;restore failed for all databases
     s OK=$system.Status.EmbedStatus($$Error^%apiOBJ(7359),tsc)
   } else { ;restore succeeded for some databases
     s OK=$system.Status.EmbedStatus($$Error^%apiOBJ(7361),tsc)
   }
 }
 D CLEAR10:'$G(ALREADY) ; clear switch 10 if we set it
restoreComplete ; JO2538
 Try {d $zu(52,0)} catch {}  ;STC2150
 s $zt="exitrestore"
 M ^mtemp1("menuse",$j)=mtemp1("menuse",$j)
 K %ST
 n ndir,dd,mf s dd="" f  s dd=$o(DIRNAM(dd)) q:dd=""  s mf=+$p(DIRNAM(dd),"^",3) d:mf
 . s ndir=$p(DIRNAM(dd),"^") i ndir="" s ndir=dd
 . if $$isMirroredDb^MIRRORMGR(ndir) q
 . i mf=$zu(40,0,41) q  ;don't dismount if it was unmounted (NOT dismounted)
 . d DISMOUNT(ndir)
 . i mf=2 d $zu(17,ndir,1)
exitrestore s $zt="" 
 i $V($ZU(40,2,82),-2,4)=+$ZU(61,30,$ZU(61)) V $ZU(40,2,82):-2:4:0     ;JAO580,HYY302,JO1984
 i MasterJob L -^DBACK ;by master only
 K SELDIR,JDIR,JDIRECTORY 
 q OK
remount n ndir,dir,runmir,dbobj,status,rc
 s dir="",mirlist="",runmir=($SYSTEM.Mirror.GetInfo()[",DEFINED,")
 f  s dir=$o(dejrn(dir)) q:dir=""  d
 . S ndir=$G(dejrn(dir)),ndir=$P(ndir,",",2,$L(ndir)) S:ndir="" ndir=dir
 . s dbobj=##Class(SYS.Database).%OpenId(ndir,,.status)
 . q:'status
 . i '$g(QUIETMODE) w !,"Mounting ",ndir w:dbobj.Mirrored " which is a mirrored DB" d ONE^MOUNT(ndir)
 . i $g(QUIETMODE) s status=dbobj.Mount()
 . i dbobj.Mirrored d
 . . s mirlist=mirlist_$lb(+$zu(49,ndir)) k dejrn(dir)
 q
JRNIN ;save dejrn, DIRNAM, DEJRNSTART, etc.
 s node=$name(^SYS("RESTORE","BACKUP",$zdt($h,8)))
 s @node@("device")=$g(INCDEV)
 s @node@("backtime")=$g(BACKH)
 m @node@("databases")=dejrn
 m @node@("jrnmarker")=DEJRNSTART
 m @node@("DIRNAM")=DIRNAM
 q
 ;uppercase function
UC(x) q $zcvt(x,"u")
 ;check  for stop text function
STOP(x) S x=$$UC($E(x,1,4)) Q (x["EXIT")!(x["STOP")!(x["QUIT")!(x["HALT")!($E(x)="^")
YESNO(a) N v,b S a=$G(a) q:$g(NOINPUT) a F  DO  Q:$D(v)
 . W *-1,$S(a:" Yes",1:" No")_" => " R b I b="" S v=a Q
 . S b=$TR($E(b),"yn","YN") I "YN"[b S v=(b="Y") Q
 . W *7," [answer Yes or No, please]" I $x>68 W !
 Q v
Show(item,p1,p2,p3,p4) ;
 I '$G(^SYS("RESTORE","BACKUP.DEBUG")) q
 n d,i,p0,p,tx s d="#",tx=$g(dbrtext(item))
 i tx="" w !,*7,"MISSING DBRTEXT ITEM ",item h 0 q
 s msg="" f i=0:1:4 s p="p"_i,msg=msg_$p(tx,d,i)_$g(@p)
 d $zu(9,"",msg)
 h 0 q 
DBREST2 ;Incremental Backup Restore (continued) ;$Change: 5546961 $
  ;#if $$$NEWINC   ; CFL284+       
GetBckSet(rootdir,select,bckset) public {
 s bckset=$zu(12,rootdir) ;parent directory of dbname directories
 s sc=##class(Backup.Online).GetManifest(bckset,.mObj)
 i ('sc) q sc
 i $d(select)>=10 s alldbs=0 ;selected databases
 e  s alldbs=1 ;all databases
 try {
   s iter=mObj.databases.%GetIterator()
   while iter.%GetNext(.k,.v,.t) {
     s dbdir=v.directory
     if alldbs {
       i 'v.statusOK continue
     } else {
       i dbdir=""||'$d(select(dbdir)) continue
     }
     i dbdir="" {
       s err="null database entry"
       return $$Error^%apiOBJ(7374,err)
     }
     i $d(found(dbdir)) {
       s err="database '"_dbdir_"' is duplicated"
       return $$Error^%apiOBJ(7374,err)
     }
     i 'v.statusOK {
       s err="database '"_dbdir_"' is failed"
       return $$Error^%apiOBJ(7374,err)
     }
     s bkpdir=v.backupDirectory
     s bkpfile=v.backupFile
     i (bkpdir="")||(bkpfile="") {
       s err="database '"_dbdir_"' has invalid backup location"
       return $$Error^%apiOBJ(7374,err)
     }
     i $d(bckset(bkpdir,bkpfile)) {
       s err="database '"_dbdir_"' has non-unique backup location"
       return $$Error^%apiOBJ(7374,err)
     }
     s found(dbdir)=bkpdir_","_bkpfile ;for tracking DBs found in manifest
     s bckset(bkpdir,bkpfile)=dbdir_","_dbdir ;add DB to backup set
     s totvol=v.volumes.%Size()
     f i=2:1:totvol { ;add target directories for additional volumes, if any
       s vol=v.volumes.%Get(i-1)
       s voldir=vol.restoreTo
       s bckset(bkpdir,bkpfile)=bckset(bkpdir,bkpfile)_","_voldir
     }
   }
 } catch {
   s ze=$ze,$ze=""
   return $$Error^%apiOBJ(7374,ze)
 }
 i 'alldbs {
   s dbdir="" f  {
     s dbdir=$o(select(dbdir)) q:dbdir=""
     return:'$d(found(dbdir)) $$Error^%apiOBJ(7376)
   }
 }
 k mObj
 i $g(select)'="" {
   try {
     s mObj={}.%FromJSONFile(select)
     s iter=mObj.databases.%GetIterator()
     while iter.%GetNext(.k,.v,.t) {
       s dbdir=v.directory
       continue:(dbdir="")||'$d(found(dbdir)) ;ignore, not in backup set
       i $d(found2(dbdir)) {
         s err="database '"_dbdir_"' is duplicated"
         return $$Error^%apiOBJ(7375,err)
       }
       s found2(dbdir)="" ;for tracking DBs found in override manifest
       s bkpdir=$p(found(dbdir),",",1)
       s bkpfile=$p(found(dbdir),",",2)
       s voldir=v.volumes.%Get(0).restoreTo
       i voldir="" {
         s err="database '"_dbdir_"' has invalid restore location"
         return $$Error^%apiOBJ(7375,err)
       }
       s bckset(bkpdir,bkpfile)=dbdir_","_voldir
       s totvol=v.volumes.%Size()
       f i=2:1:totvol { ;add target directories for additional volumes, if any
         s vol=v.volumes.%Get(i-1)
         s voldir=vol.restoreTo
         s bckset(bkpdir,bkpfile)=bckset(bkpdir,bkpfile)_","_voldir
       }
     }
     s dbdir="" f  {
       s dbdir=$o(found(dbdir)) q:dbdir=""
       return:'$d(found2(dbdir)) $$Error^%apiOBJ(7377)
     }
   } catch {
     s ze=$ze,$ze=""
     return $$Error^%apiOBJ(7375,ze)
   }
 }
 q 1
}
PrecheckBckSet(bckset,REASON) [NEWDIR] {
 try {
   s bkpdir="" f  {
     s bkpdir=$o(bckset(bkpdir)) q:bkpdir=""
     s bkpfile="" f  {
       s bkpfile=$o(bckset(bkpdir,bkpfile),1,srctarg) q:bkpfile=""
       s dbdir=$p(srctarg,",",1)
       s targdir=$p(srctarg,",",2)
       s cantargdir=$zu(12,targdir) ;canonize it for comparison
       i $d(found(cantargdir)) {
         s REASON(dbdir)=$$Error^%apiOBJ(7378,targdir)
         continue
       }
       s found(cantargdir)="" ;remember target for future comparisons
       s bckfilepath=$zu(12,bckset_"/"_bkpdir_"/"_bkpfile,0)
       i '($zu(140,4,bckfilepath)=0) {
         s REASON(dbdir)=$$Error^%apiOBJ(5012,bckfilepath)
         continue
       }
       s NEWDIR(dbdir)=targdir ;used by TSTDIR()
       i $$TSTDIR(dbdir) { ;an error (only '2' expected)
         s REASON(dbdir)=$$Error^%apiOBJ(372,targdir)
         continue
       }
       s sc=$$FixTargetDatabase(bckfilepath,srctarg,"",1)
       i ('sc) {
         s REASON(dbdir)=sc
         continue
       }
     }
   }
   return 1
 } catch {
   s ze=$ze,$ze=""
   return $$Error^%apiOBJ(5002,ze)
 }
}
FixTargetDatabase(bkpfile,srctarg,zu49need,precheck) [QUIETMODE,dbrtext] {
 s targdb=$p(srctarg,",",2)
 s:targdb'="" targdb=$zu(12,targdb) ;in case not already canonized
 q:targdb="" $$Error^%apiOBJ(5007,$p(srctarg,",",2))
 try {
   s lpfile=$p(bkpfile,".",1,*-1)_".lastpass"
   o lpfile:"RU":5
   i '$t {
     w:'$g(QUIETMODE) !,*7,"[Couldn't open last pass backup file ",lpfile,"]",!
     return $$Error^%apiOBJ(5005,lpfile)
   }
   s opened=1
   u lpfile r filedata:5 c lpfile
   s opened=0
   s crc=$li(filedata,1) ;crc for data in this file
   s filedata=$li(filedata,2)
   i crc'=$zcrc(filedata,7) {
     w:'$g(QUIETMODE) !,*7,"[CRC error in last pass backup file ",lpfile,"]",!
     return $$Error^%apiOBJ(7379,lpfile)
   }
   s dir=$li(filedata,1) ;source database dir
   i dir'=$p(srctarg,",",1) {
     w:'$g(QUIETMODE) !,*7,"[Missing ",$p(srctarg,",",1)," in last pass backup file ",lpfile,"]",!
     return $$Error^%apiOBJ(7379,lpfile)
   }
   s srcdkvolinfo=$li(filedata,2) ;dkvolinfo() output parameters from last pass
   s srcblkspervol=$li(filedata,3) ;# of blks in each volume
   s srcmultivol=$l(srcblkspervol,",")-1 ;# of secondary volumes
   s srccreatedate=$li(filedata,4) ;file creation date (high,low)
 } catch {
   i $g(opened) c lpfile
   s ze=$ze,$ze=""
   return $$Error^%apiOBJ(5002,ze)
 }
 s targzu49=$zu(49,targdb)
 s firstnewvol=$s(targzu49>-2:+$p(targzu49,",",15),1:0)
 f i=firstnewvol:1:srcmultivol {
   s dir=$p(srctarg,",",i+2) s:dir="" dir=targdb
   i $zu(12,dir,3)="" {
     s name=$zu(12,dir,1,1)
     i name="" {
       w:'$g(QUIETMODE) !,*7,"[Couldn't create directory ",dir,"]",!
       return $$Error^%apiOBJ(5007,dir)
     }
     s rc=$zu(140,9,name,1)
     i rc<0 {
       w:'$g(QUIETMODE) !,*7,"[Couldn't create directory ",dir," (rc = "_rc_")]",!
       return $$Error^%apiOBJ(5032,dir)
     }
   }
   s candir=$zu(12,dir)
   i i&&(candir'=targdb) {
     s mode=$s(precheck:1,1:2)
     s sc=##class(SYS.Database).UseVolumeDirectory(targdb,candir,mode,0)
     i ('sc) {
       w:'$g(QUIETMODE) !,*7,"[Couldn't use ",dir," as volume directory of database ",targdb,"]",!
       return sc
     }
   }
 }
 q:precheck 1
 if targzu49<=-2 {
   f i=2:1:12 s a(i)=+$p(zu49need,",",i)
   i srcmultivol>0 {
     s a(4)=$p(srcblkspervol,",",1)*a(2)/1048576
     i a(4)#1 s a(4)=a(4)\1+1 ;round up to next whole # (should not be needed)
   }
   try {
     s rc=$zu(0,targdb,a(2),a(3),a(4),a(5),a(6),a(7),a(8),a(9),a(10),a(11),a(12))
     i rc<0 {
       w:'$g(QUIETMODE) !,*7,"[Couldn't create database ",targdb," (rc = "_rc_")]",!
       return $$Error^%apiOBJ(7372,targdb,rc)
     }
   } catch {
     s ze=$ze,$ze=""
     w:'$g(QUIETMODE) !,*7,"[Couldn't create database ",targdb,"]",!
     return $$Error^%apiOBJ(5002,ze)
   }
   s rc=$$ZU(52,5,targdb,1)
   i rc<0 {
     d Show("errmrk1",targdb)
     return $$Error^%apiOBJ(7368,rc)
   }
   d MOUNTQ(targdb)
   s targzu49=$zu(49,targdb) ;get udpated $ZU(49) info
 }
 s multivol=$p(targzu49,",",15)-1
 i (srcmultivol>0)||(multivol>0) {
   try {
     i $p(srcdkvolinfo,",",22)>$p(targzu49,",",22) {
       f i=2:1:12 s a(i)=+$p(srcdkvolinfo,",",i)
       s a(4)=+$p(targzu49,",",4) ;don't do any expansion
       s rc=$zu(1,targdb,a(2),a(3),a(4),a(5),a(6),a(7),a(8),a(9),a(10),a(11),a(12))
       i rc<0 {
         w:'$g(QUIETMODE) !,*7,"[Couldn't modify ",targdb," (rc = "_rc_")]",!
         return $select(+$$Error^%apiOBJ(313,targdb):$$Error^%apiOBJ(-rc),1:$$AppendStatus^%occSystem($$Error^%apiOBJ(313,targdb),$$Error^%apiOBJ(-rc)))
       }
     }
     s rc=$ZU(52,11,targdb,0) ;reinit structures for new topology
     i rc<0 {
       w:'$g(QUIETMODE) !,*7,"[Couldn't init topology of ",targdb," (rc = "_rc_")]",!
       return $$Error^%apiOBJ(7380,targdb,rc)
     }
     s lastshared=$s(srcmultivol<multivol:srcmultivol,1:multivol)
     f i=0:1:lastshared {
       s needblks=+$p(srcblkspervol,",",i+1)
       d $ZU(52,12,0,needblks) ;[0] indicate another volume
     }
     d $ZU(52,12,1,+$p(srcdkvolinfo,",",26)) ;[1] indicate volblk
     d $ZU(52,12,2,+$p(srccreatedate,",",1)) ;[2] indicate createdatehigh
     d $ZU(52,12,3,+$p(srccreatedate,",",2)) ;[3] indicate createdatelow
     s rc=$ZU(52,11,targdb,1) ;activate new topology
     i rc<0 {
       w:'$g(QUIETMODE) !,*7,"[Couldn't adjust topology of ",targdb," (rc = "_rc_")]",!
       return $$Error^%apiOBJ(7380,targdb,rc)
     }
     d DISMOUNT(targdb) ;dismount to flush blocks and reload gfiletab
     i lastshared<srcmultivol { ;need to add some volumes
       d MOUNTQ(targdb) ;remount first
       f i=lastshared+1:1:srcmultivol {
         s needblks=+$p(srcblkspervol,",",i+1)
         s dir=$p(srctarg,",",i+2) s:dir="" dir=targdb
         s rc=$ZU(52,13,dir,needblks) ;create/add volume with specified size
         i rc<0 {
           w:'$g(QUIETMODE) !,*7,"[Couldn't create new volume for ",targdb," (rc = "_rc_")]",!
           return $$Error^%apiOBJ(7380,targdb,rc)
         }
       }
     } else { ;might need to delete volumes
       s dirlist=$li($system.DB.GetMultiVolDirList(targdb),2,*)
       f i=lastshared+1:1:200 {
         i ($zu(140,4,targdb_("IRIS-"_$extract("000"_+(i),*-3,*)_".VOL"))=0) { ;found in primary dir
           s delete(i)=targdb_("IRIS-"_$extract("000"_+(i),*-3,*)_".VOL") ;mark for deletion
           continue ;keep scanning for subsequent files
         }
         s ptr=0
         while $listnext(dirlist,ptr,dir) {
           i ($zu(140,4,dir_("IRIS-"_$extract("000"_+(i),*-3,*)_".VOL"))=0) { ;found in volume dir
             s sc=##class(SYS.Database).UseVolumeDirectory(targdb,dir,0,0)
             s:(''sc) delete(i)=dir_("IRIS-"_$extract("000"_+(i),*-3,*)_".VOL") ;mark for deletion
             q
           }
         }
         q:'$d(delete(i)) ;done scanning, nothing else to delete
       }
       s vol="" f  { ;delete extra volumes (in reverse in case we crash)
         s vol=$o(delete(vol),-1,file) q:vol=""
         d $zu(140,5,file)
       }
       d MOUNTQ(targdb) ;remount after
     }
   } catch {
     s ze=$ze,$ze=""
     return $$Error^%apiOBJ(5002,ze)
   }
 }
 q 1
}
  ; start the restore
BEGINDBREST2 ;
 n %DIR,%SYSDIR,ALREADY,ANS,BACKSET,DELIM,DEV,DIR,INCDEV,OURDIR
 n PREVDATE,PREVFDATE,PREVFTIME,PREVH,PREVTIME,PREVTYPE,VOLNUM,sfn
 n dlmlock
 n TOTAL
 n vernum
 n MIRRORINFO,MirrorBackup,MirrorRestore,MirrorDBList
 n SelectOnlyMirrorDBs ; for selective restore indicates whether we only ask about mirrored db's
 s MirrorRestore=0,MirrorBackup=0
 n oldmode s oldmode=$ZU(69,12)
 D INT^%DIR S OURDIR=%DIR,DELIM=$c(0)
 s FINAL=0
 i MasterJob {
   L +^DBACK:1
   i '$t {
     i '$g(QUIETMODE) {
       W *7,!,"[A backup or restore is already in progress"
       W !,"This restore is aborted.]",!!
     }
     d $zu(9,"","A backup or restore is already in progress")
     s OK=$$Error^%apiOBJ(7356,$p(OK,"^",2))
     g begin2 ;error exit
   }
   s $zt="begin2"
   V $ZU(40,2,82):-2:4:$ZU(61,30,$ZU(61))  ; Load our jobid into incbkjobid
   s NumberWorkers=$g(^SYS("BACKUP","NumberWorkers"),8)
   Set queue=$system.JobMgr.%New(NumberWorkers) 
   If queue="" {
     d $zu(9,"","unable to instantiate JobMgr object") 
     s OK=%objlasterror
     g begin2
   }
   i '$g(QUIETMODE) w !,"Started ",NumberWorkers," workers to restore databases",! 
   k bckset,REASON ;to hold a list of dbname directories and backup files under them
   s rc=$$GetBckSet(INPDEV,.dejrn,.bckset) ;build backup set from manifest(s)
   i ('rc) { ;error building backup set is fatal
     s OK=rc
     g begin2
   } elseif $d(bckset)<10 {
     d $zu(9,"","no db to restore") 
     s OK=$$Error^%apiOBJ(7371)
     g begin2
   }
   s rc=$$PrecheckBckSet(.bckset,.REASON) ;pre-screen for problems
   i ('rc) { ;error during precheck is fatal
     s OK=rc
     g begin2
   } elseif $d(REASON) {
     s OK=$$REASONtoStatus(.REASON) ;return Fail on any issue during precheck
     g begin2
   }
   k dejrn ;dejrn will be reused to set up selection/redirection for journal restore
   s dbname="" f  {
     s dbname=$o(bckset(dbname)) q:dbname=""
     s bckfile=$o(bckset(dbname,""),1,srctarg) 
     i bckfile="" continue  ;not supposed to happen
     s bckfile=$zu(12,INPDEV_"/"_dbname_"/"_bckfile,0) ;full path
     s QUIETMODE='$G(^SYS("RESTORE","BACKUP.DEBUG"))
     s rc=queue.CallRoutine(dbname,1,"EXTSELCT^DBRESTP",QUIETMODE,0,bckfile,srctarg,4)
     i 'rc {
       s DIR=$p(srctarg,",") ;source db directory
       s REASON(DIR)=rc
       k bckset(dbname) ;skip the db
       i '$g(QUIETMODE) d msgout($c(13,10)_"Queue "_DIR_" error:"_$System.Status.GetErrorText(rc)) 
     }
   }
   f  {
        s msgid=queue.GetReturn(10,.dbname,.sc,.result) 
	;msgid >0, 0 on timeout or <0 if done or on error
	i 'msgid continue  ;timeout
	i msgid<0 {
		i msgid<-1 s OK=sc ;error
		q
	}
	;s bckfile=args(3) ;we have access to the argument list provided on the 'Queue'
        s bckfile=$o(bckset(dbname,""),1,srctarg) 
	; Any %result data from the work unit
	s DIR=$p(srctarg,",")
        s rc=$li(result)
	i 'rc { ;restore failed for the db
	  s REASON(DIR)=rc 
	} else { ;success
	  ; same markinfo stored in all backup files
	  s DIRNAM(DIR)=$li(result,2)
	  s DEJRNSTART=$li(result,3)
	  s targ=$p(srctarg,",",2)
	  i (targ="")||(targ=DIR) {
	    s dejrn(DIR)=1 ;no DB redirection
	  } else {
	    s dejrn(DIR)="1,"_targ
	  }
	}
   }
   i 'OK {
	k queue
        s dbname="" f  {
          s dbname=$o(bckset(dbname)) q:dbname=""
          s bckfile=$o(bckset(dbname,""),1,srctarg) 
	  s dir=$p(srctarg,","),target=$p(srctarg,",",2)
	  i target="" s target=dir ;no redirection
	  ; databases in DIRNAM() are restored OK and will be handled in finish
	  i $g(DIRNAM(dir))="" { 
	    ; If GFINCREST flag is on in target db, convert it to DISMOUNT.
	    ; It's possible that it has been converted in abortdir.
	    i $zu(49,target)>-1,$zu(52,5,target) d $zu(52,5,target,-1)
	  }
	}
   }
   s dir="" f  {
     s dir=$o(DIRNAM(dir),1,target) q:dir=""
     ; GetBckSet() calls TSTDIR(), which may mount the target db and save its
     ; old state in NEWDIR(dir). finish goes through DIRNAM() to dismount
     ; databases that have been re-mounted for the purpose of restore.
     i $p(target,"^",3)="" s $p(DIRNAM(dir),"^",3)=$p(NEWDIR(dir),"^",3)
   }
   g finish ;to resize databases in DIRNAM() and clear their GFINCREST flags
 } ; end of MasterJob
 ; DO NOT CALL ^%ST. Define any %ST nodes required here.
 ; Calling ^%ST can result in <PROTECT> errors when restoring the
 ; manager's directory.
 S $ZT="ERR"
 S %ST=$Case($zversion(1),1:"M/AV",2:"M/WNT",3:"M/UX",:"UNKNOWN")
 S %ST("PLEN")=$ZU(40,0,4)
 s %ST("GIND")=$V($ZU(40,2,11)+($ZU(40,0,4)*4),-2,"S")
 d $zu(52,-1) ;enable access to GFINCREST-marked databases
 I $$ZU(52,0)
 N BUFCOUNT S BUFCOUNT=0
 B 0 S DEV=$G(INPDEV) 
 k ze
 N DIRNAM,NOREST,dejrn,global
 N CLSTATE,CLUBACKUP
 n RCSUCCESS,RCINERR,RCOUTERR,RCMOUNT,RCBADMAP,RCMAPINERR,RCEOT,RCOFFLINE
 n RCDEVFUL,RCOLDFORMAT,RCBADVOLUME,RCENDOFVOL,RCENDOFVOLSET,RCDIRLABELRECORD
 n RCDIRLABELMISSING,RCINERRLABELGOOD,RCBADRECORDONCOPY,RCBADRECORDONRESTORE
 n RCMISSINGBLKS,RCBLKSIZE,RCOUTCLUMNT,RCMAPERR,A,a,OBDIRLAB,startday,starttime
 d initconstants s a=$h,startday=+a,starttime=+$p(a,",",2)
 ; delete bad blocks recorded by any former restores more than 30 days old
 f  s a=$o(^CacheRestoreBad("")) q:'a!(a>($h-30))  k ^(a)
 S CLUBACKUP=0
 S BACKSET=1,PREVDATE="",PREVTIME="",PREVTYPE=""
 S PREVFDATE="",PREVFTIME="",PREVH=""
 S $ZT="ERR^"_$ZN
 New batch Set batch=$$GETBATCH^%PRIO() Do SET^%PRIO("BATCH")
begin1 
 S X=$ZU(69,12,0) D NEXTBACK S X=$ZU(69,12,oldmode) S:OK RC=1 ;just the first one when quiet
 ;
 Do:$d(batch) SET^%PRIO(batch)
 G finish
begin22  s $zt="begin2"
 S X=$ZU(69,12,oldmode) Do:$d(batch) SET^%PRIO(batch) G begin2
ERR I $G(QUIETMODE) S $ZT="" G begin22
 S $ZT="",ze=$ZE
 D Show("errabort",ze) G begin22
NEXTBACK ; If appropriate, reset default device to incremental default
 N ALREADY,dir,yes S ALREADY=$$CHECK10()
 I BACKSET=2,PREVTYPE="Full" S DEV=INCDEV ;INCDEV might be null
 I BACKSET>1,INCDEV'="",PREVTYPE'="Full" S DEV=$$GETINC("NEXT",PREVH)
 do $ZU(31,1,0)
 S VOLNUM=1,sfn=-1 D VOLLABEL I 'OK Q
 ; Process directory names if necessary
nxtback1 K NEWDIR,NODIR S added=0,DIRLOC=VOLLOC ; input variables for DIRNAM()
 s flag=0
 For {
	 S DIR=$$nextvol() 
	 if DIR="" {
		; End of volume label info, see if there's a continuation block
		if $V(VOLLOC,-3,1)=0 quit  ; we're done
		; there is a continuation label block, read it and get more databases
		s RC=$$ZU(52,10)
		i +RC'=1 {
		   s flag=1
		   quit
 		}
 		S VOLLOC=$P(RC,",",4)+$P(RC,",",2)
		S DIR=$$nextvol() 
		if DIR="" quit  ; this is the end of the list, then we're done
	 }
	 S ZU49=$$nextvol() 
	 if ZU49="" {
		; End of volume label info, see if there's a continuation block
		if $V(VOLLOC,-3,1)=0 quit  ; we're done
		; there is a continuation label block, read it and get more databases
		s RC=$$ZU(52,10)
		i +RC'=1 {
		   s flag=1
		   quit
		}
		S VOLLOC=$P(RC,",",4)+$P(RC,",",2)
		S ZU49=$$nextvol()
		if ZU49="" quit  ; this is the end of the list, then we're done
	 }
	 D DIRNAM(DIR,ZU49)
 }
 q:OK=0
 if flag {
	 W:'$g(QUIETMODE) *7,!,"[Failed to read continuation volume label from "_DEV_"]"
	 s flag=$$ZU(52,3,"")
	 s OK=$$Error^%apiOBJ(7363,DEV)
	 quit
 }
 ; Go through the databases to be restore and see if we can privatly
 ; mount them. If they don't exist that's ok but if we can't privatly
 ; mount them they are mounted by someone else in the cluster and
 ; can't be restored to.
 S DIR="",flag=0 k BADDIR
 if BACKSET=1,'$D(NEWDIR) {
	 w:'$G(QUIETMODE) !,"No databases selected for restore."
	 s OK=$$Error^%apiOBJ(7371)
	 s flag=$$ZU(52,3,"") 
	 Q
 }
 n rc
 f  {
	S DIR=$O(NEWDIR(DIR)) 
	Q:DIR=""  
	s rc=$$TSTDIR(DIR)
	if rc {
		i 'flag {
 			i '$G(QUIETMODE) {
 			  w !,"The following directories appear to be dismounted, read-only or"
 			  w !,"mounted elsewhere and can't be restored"
 			  w " and skipped" ;abort restore
			}
 			s flag=1
		}
 		i '$G(QUIETMODE) {
 		  w !,?5,$S($P(NEWDIR(DIR),"^")="":DIR,1:$P(NEWDIR(DIR),"^")) ;cf. mntdir in TSTDIR JO2936
 		  w "    *"_$Case(rc,1:"Dismounted",2:"ReadOnly",3:"Cluster Mounted by other")
		}
		i rc=1 {
		  s BADDIR(DIR)=$$Error^%apiOBJ(371,DIR)
		} else {
		  s BADDIR(DIR)=$$Error^%apiOBJ(372,DIR)
		}
	}
 }
 i flag {
	s yes=0
	s OK=1,DIR="" f  {
		s DIR=$o(BADDIR(DIR),1,sc) q:DIR=""
		s OK=$System.Status.AppendStatus(OK,sc)
	}
 	i 'OK s flag=$$ZU(52,3,"") q
 }
 ; TSTDIR left list of databases we can't restore in BADDIR
 s DIR="" 
 f  {
	 S DIR=$O(BADDIR(DIR)) 
	 q:DIR=""
 	 k NEWDIR(DIR) 
 	 s NODIR(DIR)=""
 }
nxtback2 ; non-interactive
 S DIR=$O(NODIR(""))
 while (DIR '= "") {
 	s NOREST(DIR)=""
 	k NODIR(DIR)
 	s DIR=$O(NODIR(""))
 }
 s DIR=$O(NEWDIR(""))
 while (DIR '="" ) {
	 s DIRNAM(DIR)=NEWDIR(DIR)
 	 K NEWDIR(DIR)
 	 S dir=$P(DIRNAM(DIR),"^",1)
 	 s:dir="" dir=DIR  ; if restoring to same place, dir would be null
 	 I dir=DIR {
	 	 S dejrn(DIR)=1
 	 } else {
 		 s dejrn(DIR)="1,"_dir
 	 }
	 ; If the target is mirrored then we need to remove it from the
	 ; mirror now so it can be restored. After the restore it will be
	 ; added back.
	 s mirdbname=$G(MirrorDBList("path",dir))
	 if mirdbname'="" {
		 if 'MirrorDBList(mirdbname,"inactive") {
		    s rc=$$PauseMirroredDB($G(QUIETMODE),mirdbname,dir)	
		    if 'rc {
	 	       s NOREST(DIR)="" 
	 	       k DIRNAM(DIR)
	 	       k dejrn(DIR) 
	               s OK=$$Error^%apiOBJ(7370,DIR,rc)
		       q
		    }
	 	 }
		 s rc=$SYSTEM.Mirror.DBRemove(dir)
		 if '+rc {
		    s err=$P(rc,",",2)
		    if '$G(QUIETMODE) {
		       w !,"Failed to remove restore target ",dir
		       w !,"from the mirror, it will not be restored"
		    } else {
			   d $zu(9,"","DBREST failed to remove "_dir_" from the mirror - Skipped",1 /* broadcast and log message*/,1  /* Warning */)
		    }
	 	    s NOREST(DIR)="" 
	 	    k DIRNAM(DIR)
	 	    k dejrn(DIR) 
	            s OK=$$Error^%apiOBJ(7369,DIR,rc)
		    q
		 }
		 d ##Class(%SYS.Audit).WriteToAuditFile("%System","%System","ConfigurationChange",dir,"Remove mirrored database "_$p(mirdbname,":",4))
	 }
 	 ; Now set the GFINCREST flag to prevent others from using this dir
 	 i +$ZU(49,dir)>-2 {
	 	 s rc=+$$ZU(52,5,dir,1)
	 	 if rc<0 {  ;-1, -2 or -3
	 	     s NOREST(DIR)="" 
	 	     k DIRNAM(DIR)
	  	     k dejrn(DIR) 
	  	     if (rc = -1) {
	   	        d Show("errmrk",dir,DIR) ;error marking db as target as restore
	  	     } elseif (rc = -2) {
	   	        d Show("errmrk2",dir,DIR) ;mirrored db cannot be target of restore
	  	     } elseif (rc = -3) {
	   	        do Show("errcol",dir,DIR) ;db collation is not available
	  	     }
	             s OK=$$Error^%apiOBJ(7368,DIR,rc)
		     q
	 	 }
 	 }
  	 D MOUNTQ(dir)
nextdir ;
	 s DIR=$O(NEWDIR(""))
 } 
 if BACKSET=1,'$D(DIRNAM) {
	 w:'$G(QUIETMODE) !,"No databases remaining to be restored."
	 s flag=$$ZU(52,3,"") 
	 Q
 }
 For  DO  Q:'OK!EOS
 . s StartVolume=1,StartTime=$h D VOLUME s StartVolume=0 S RC=$$ZU(52,3,"") Q:'OK!EOS
 . S VOLNUM=VOLNUM+1 D VOLLABEL
 Q:'OK
 S DIR="" For  S DIR=$O(DIRNAM(DIR)) Q:DIR=""  Do
 . S DIRNAM=$P(DIRNAM(DIR),"^",1) S:DIRNAM="" DIRNAM=DIR
 . Q:$D(NOREST(DIRNAM))  D DISMOUNT(DIRNAM) S RC=$$MOUNTQ2(DIRNAM)
 . I RC=-86 D Show("errcol2",DIRNAM) S OK=$$Error^%apiOBJ(86) K DIRNAM(DIR),dejrn(DIR)
 S PREVDATE=BACKDATE,PREVTIME=BACKTIME,PREVTYPE=BACKTYPE,PREVH=BACKH
 i $g(logfile)'="" c logfile s logfile=""
 Q
nextvol() N a,b ; see if can find string in current line
 S a=$F($V(VOLLOC,-3,-512),DELIM) I 'a Q ""
 I $L(DELIM)+1=a s VOLLOC=VOLLOC+$l(DELIM) q ""
 S b=$v(VOLLOC,-3,-(a-$l(DELIM)-1)),VOLLOC=VOLLOC+a-1
 I '$D(XLT) S XLT=$$GETXLT(DEV)
 Q $ZCVT(b,"I",XLT)
GETINC(btype,prevdt) N dev,date,type I btype="FIRST" S prevdt=""
 i +$ZU(49,$ZU(12))<0 q ""  ; if directory is dismounted, just quit
 d ConvHistDate^DBACKP s date=$S($G(prevdt):(+prevdt*1000000+$p(prevdt,",",2)),1:"")
 S dev="",date=$O(^SYS("BACKUP","HISTORY",date)) I date]"" DO
 . S dev=$G(^(date,"DEVICE")),type=$G(^("TYPE")) Q:type["Cumulative"
 . N OK S OK=0
 . F  S date=$O(^SYS("BACKUP","HISTORY",date)) Q:date=""  DO  Q:OK
 . . I $G(^(date,"TYPE"))["Cumulative" S dev=$G(^("DEVICE")),OK=1
 ;
 Q dev
DISMOUNT(dir) ;Dismount a directory
 N a
 s a=$ZU(3,dir)  ; dismount the directory
 Q
TSTDIR(DIR) ;
 n zu49,mntdir,zu17,CLUSFLAG,zu49str,rc
 s mntdir=$S($P(NEWDIR(DIR),"^")="":DIR,1:$P(NEWDIR(DIR),"^"))  ;JO2936
 s zu49str=$ZU(49,mntdir)
 s zu49=+zu49str
 q:zu49<-1 0
 if zu49=-1!(zu49=$zu(40,0,41)) {
	 d MOUNTQ(mntdir) 
	 s $p(NEWDIR(DIR),"^",3)=zu49 ;-1 or $$$SFNUNDEF
	 s zu49str=$ZU(49,mntdir)
 	 s zu49=+zu49str
 }
 if $zb(+$p(zu49str,",",17),$zu(40,8,13),1) {
	 s rc=2
	 G SetBad
 }
 if ($zb(+$p(zu49str,",",18),$zu(40,8,2),1)) {
	 ;If its read only because its mirrored, then its fine to restore 
	 ; to it (as long as its not marked mirrornowrite)
	 if $zb(+$p(zu49str,",",17),$zu(40,8,28),1) && '$zb(+$p(zu49str,",",18),$zu(40,8,38),1) {
		 quit 0
	 }
	 s rc=2
	 G SetBad
 }
 q 0
SetBad
 ; Database can't be mounted privately, don't restore it and 
 ; signal failure
 S BADDIR(DIR)=""
 if $p(NEWDIR(DIR),"^",3)=-1 d DISMOUNT(mntdir)
 q rc
QUIET() ;wait for the system to quiet down -- set switch 10 if needed
 N already,%SW,%VAL,rc
 S already=$$CHECK10() I 'already S %SW=10,%VAL=1 D SWSET
 s rc=$$TQUISYS^SWSET(1)
 I 'already S %SW=10,%VAL=0 D SWSET ;reset switch 10 when done
 q rc
DIRNAM(dir,zu49) ;
 n clflag
 n mirdata,mirdbname,info,mirname,mirindex,rc
 n curjrnfilecnt,curjrnoff,backupjrnfilecnt,backupjrnfileoff
 n indent,path
 s mirdata=$P(dir,"^",3)  ;stored by getMirDBInfo^DBACKB
 if mirdata="" {
	 s mirdbname=""
 } else {
	 s mirdbname=":mirror:"_$P(mirdata,":",6)_":"_$P(mirdata,":",1)
 }
 s clflag=$P(dir,"^",2),dir=$P(dir,"^",1)  ; get cluflag
 i clflag="" s clflag="P"  ;from a prior/non-cluster version
 i $D(NOREST(dir))||$D(DIRNAM(dir)) { ; make sure its sfn didn't change
   i $g(gdir(+zu49))=dir q  ;sfn didn't change
   ;sfn of the directory changed between consecutive backups
   ;remove the gdir entry for the directory with the old sfn
   n sfn s sfn="" f  s sfn=$o(gdir(sfn)) q:sfn=""  i gdir(sfn)=dir k gdir(sfn) q
   s gdir(+zu49)=dir ;add the new gdir entry
   q
 }
 ; if restore all directories, add to restore list
 i RESTYPE="ALL" G diradd
 ; Select individual directories and see if need to rename
 if ($G(SelectOnlyMirrorDBs)=1) && (mirdata="") {
	 S NODIR(dir)=""
	 s gdir(+zu49)=dir 
	 quit
 }
 ; Set up arrays for selecting directories to restore only
 ; for non-interactive restore
 S gdir(+zu49)=dir
 D SELDIR(dir,mirdbname)
 quit
diradd ;
 S gdir(+zu49)=dir
 if 'added {
    if '$G(QUIETMODE) {
 	W !,"The following directories will "
 	W $s(BACKSET'=1:"also ",1:""),"be restored: ",!
    }
 }
 S added=1
 if $G(TopDir)="" {
	 if 'MirrorRestore {
	    s a=$ZU(12,dir)
	 } else {
		 ; For MirrorRestore=2 we only restore mirrored databases
		 ; and only if they have a corresponding local location
		 if (MirrorRestore=2) && ((mirdbname="") || '$D(MirrorDBList(mirdbname))) {
			 s NODIR(dir)=""
			 quit
		 }
		 ; If this is a mirrored database and it has a local copy then
		 ; set up the redirection. If the local copy is currently active,
		 ; we have to deactivate it. If the local copy is active and newer
		 ; than the copy in the backup, we ask the user to confirm or we
		 ; abort the operation (for non-interactive).
		 if (mirdbname="") || '$D(MirrorDBList(mirdbname)) {
		    s a=$ZU(12,dir)
		 } else {
		     s info=MirrorDBList(mirdbname,"info")
		     if $P(info,":",4)'=$P(mirdata,":",4) {  ;database guid
				 if '$G(QUIETMODE) {
				    w !,dir," skipped because its guid does not"
				    w !,?5,"match the guid of the current database."
				 }
			     s NODIR(dir)=""
			     quit
		     }
		     if $P(info,":",5)'=$P(mirdata,":",5) {  ; mirror guid
				 if '$G(QUIETMODE) {
				    w !,dir," skipped because its mirror guid does not "
				    w !,?5,"match the mirror guid of the current database."
				 }
			 	 s NODIR(dir)=""
			 	 quit
		     }
		     s curjrnfilecnt=+$P(info,":",2),curjrnoff=+$P(info,":",3)
		     s backupjrnfilecnt=+$P(mirdata,":",2),backupjrnoff=+$P(mirdata,":",3)
		     if (curjrnfilecnt>backupjrnfilecnt) || 
		           ((curjrnfilecnt=backupjrnfilecnt) && (curjrnoff>backupjrnoff)) {
			    if 'MirrorDBList(mirdbname,"inactive") {
				    if '$G(QUIETMODE) {
					    if $SYSTEM.Mirror.GetInfo()["PRIMARY" {
					    	w !,dir," skipped because the"
							w !,?5,"target database is active and this is the primary mirror member."
							w !,?5,"The target database needs to be removed from the mirror"
							w !,?5,"before it can be the target of a restore."
					    } else {
					    	w !,dir," skipped because the target database "
							w !,?5,"is active and is newer than the database in the backup"
							w !,?5,"The database in the backup is current as of journal file #",backupjrnfilecnt
							w !,?5,"and the current database is current as of file #",curjrnfilecnt," and the current"
							w !,?5,"database does not appear to be damaged as it is active."
							w !,?5,"Use a Selective Restore if you want to restore over the existing copy."
					    }
					    w !
				    }
				    S NODIR(dir)=""
				    quit
			    } else {
				    if '$G(QUIETMODE) {
					    w !,"Note that the copy of ",dir
					    w !,?5,"in the backup is older than the current"
					    w !,?5,"database, ",MirrorDBList(mirdbname,"path"),"."
					    w !,?5,"However the current database is not active in the mirror"
					    w !,?5,"so it can be overwritten if the current database is damaged."
					    w !
				    }
			    }
		    }
		    s a=MirrorDBList(mirdbname,"path")
	    }
	 }
 } else {
	 s a=$ZU(12,$$prefix(TopDir,dir))
 }
 W:'$g(QUIETMODE) dir," => " ;
 if (mirdbname'="") {  ;from the backupo
	 s path=$G(MirrorDBList(mirdbname,"path"))  ;local database list
	 if (path'="") {
	    if a'=path,'MirrorDBList(mirdbname,"activationreq") {
		i '$g(QUIETMODE) {
		    w !,"Warning, mirror database ",mirdbname," exists in"
		    w !,?5,path
		    w !,"but you are restoring it to"
		    w !,?5,a
		    w !,"Activation and catchup of the restored database will fail"
		    w !,"because a mirror database name can only be used by one"
		    w !,"database on an instance at a time."
		}
	    }
	 }
 }
 s rc=$P($ZU(49,a),",",2)  ;blocksize of the target
 s info=$P(zu49,",",2)     ;blocksize of the source
 if rc'=info {
     i '$g(QUIETMODE) {
	 w !,"The target database ",a," has a block "
	 w !,?5,"size of ",rc," which does not match the block size of the database"
	 w !,?5,"in the backup (",info,")"
 	 w !,"This database will be skipped"
 	 w !
     }
 	 s NODIR(dir)=""
 	 Q
 }
 S NEWDIR(dir)="" 
 I a'=dir {
     s NEWDIR(dir)=a 
     i '$g(QUIETMODE) {
	 s:mirdbname'="" a=a_" ("_mirdbname_")"
	 ; If the target + mirrordb name won't fit on the
	 ; same line as the source then try to align it so
	 ; it fits on the next line indenteted a bit
	 if $L(a)+$X>79 {
		 w ! 
		 s indent=79-$L(a)
		 if (indent > $L(dir)) {
			 s indent=$L(dir)-10
		 }
		 if (indent<0) {
			 s indent=5
		 }	 
		 w @("?"_indent)
	 }
	 W a
     }
 }
 S CLSTATE(dir)=clflag
 w:'$g(QUIETMODE) ! 
 Q
prefix(top,dir)
 i ($zversion(1)=2) q top_$s($e(dir,1,2)="\\":$p(dir,"\",2,999),$e(dir,2)=":":$e(dir,3,$l(dir)),1:dir)
 i ($zversion(1)=3) q top_dir
 q dir
PauseMirroredDB(QUIETMODE,mirdbname,dir) PUBLIC {
   S sw10set=$$CHECK10() 
   I sw10set {
	   do CLEAR10
   }
   d $zu(9,"","De-activating mirrored restore target: "_dir,0,0  /* Informational message */)
   S mirname=$P(mirdbname,":",3)
   s mirindex=$SYSTEM.Mirror.MirrorNameToIndex(mirname,1)+1 
   s rc=$SYSTEM.Mirror.PauseDatabase(mirindex,dir)
   I sw10set {
	   do SET10
   }
   if +rc=0 {  ;0,<error text>
	   if 'QUIETMODE {
		   w !,dir," skipped - failed to deactivate ",dir," (",$P(rc,",",2),")"
	   } else {
		   d $zu(9,"","DBREST failed to deactivate "_dir_" - Skipped ("_$P(rc,",",2)_")",1 /* broadcast and log message*/,1  /* Warning */)
	   }
	   quit 0
   }
   quit 1
}
CheckForMirrorTarget(src,mirdbname,mirdata,targ) [MirrorDBList] PUBLIC {
	; This is called during an interactive selective restore when
	; the target database exists. We want to check whether the target
	; is a mirrored database and if so, warn the user if it doesn't match
	; the database in the backup and ask if they want to continue
	;
	; mirdbname is the mirror database name of the src database as
	;    extracted from the info stored in the backup header. This
	;    is used as a subscript into the MirrorDBList() array to get the
	;    mirror inforation for this db that was extracted from the
	;    database header record in the backup file.
	;
	; Returns: 0 = do not restore to this target
	;          1 = ok to restore to this target
	s targmirdbname=$g(MirrorDBList("path",targ))
	if targmirdbname="" {
		; Target is not mirrored, all is well
		quit 1
	}
	s targmirdata=MirrorDBList(targmirdbname,"info")
	s inactive=MirrorDBList(targmirdbname,"activationreq")
	s targmirname=$P(targmirdata,":",6)
	s targmirindex=$SYSTEM.Mirror.MirrorNameToIndex(targmirname,1)+1 
	if mirdbname="" {
		; Source is not mirrored, this is not good
		w !,"The output database ",targ," is mirrored but the "
		w !,"database in the backup ",src," is not."
		w !,"Continuing will remove the target database from the "
		w !,"mirror and destroy it."
		goto checkContinue
	}
	; Source is mirrored, see if the target matches the source
	if targmirdbname'=mirdbname {
		w !,"The mirror database name of the target ",targmirdbname
		w !,"does not match the name of the source in the backup ",mirdbname
		w !,"Continuing will overwrite the contents of ",targ
		goto checkContinue
	}
	; The mirror database names match so the guids should also match
	; but we check them just to be sure.
	if $P(targmirdata,":",4)'=$P(mirdata,":",4) {  ;database guid
		w !,"The mirror database guid ",$P(targmirdata,":",4)," of the target database"
		w !,"does not match the guid ",$P(mirdata,":",4)," of the source in the backup."
		w !,"Continuing will overwrite the contents of ",targ
		goto checkContinue
	}
	if $P(targmirdata,":",5)'=$P(mirdata,":",5) {  ; mirror guid
		w !,"The mirror guid ",$P(targmirdata,":",5)," of the target database"
		w !,"does not match the mirror guid ",$P(mirdata,":",5)," of the source in the backup."
		w !,"Continuing will overwrite the contents of ",targ
		goto checkContinue
	}
	if inactive {
		; The target database is inactive, go ahead and let the user
		; restore over it
		quit 1
	}
    ; If this is the primary then we don't allow this. 
    if $SYSTEM.Mirror.GetInfo()["PRIMARY" {
	    w !,"The target database is active and this is the primary"
	    W !,"mirror member so it cannot be the target of a restore."
	    w !,"If you really want to restore to this database then mark"
	    w !,"it as not mirrored."
	    w !
	    quit 0
    }
	; The database is active so check whether it is more current
	; than the copy we're restoring
    s curjrnfilecnt=+$P(targmirdata,":",2),curjrnoff=+$P(targmirdata,":",3)
    s backupjrnfilecnt=+$P(mirdata,":",2),backupjrnoff=+$P(mirdata,":",3)
    if (curjrnfilecnt>backupjrnfilecnt) || 
        ((curjrnfilecnt=backupjrnfilecnt) && (curjrnoff>backupjrnoff)) {
	    w !,"The target database is active and is more up to date"
	    w !,"than the copy in the backup. Continuing will overwrite"
	    w !,"the contents of ",targ," with older data."
checkContinue ;		
		r !,"Continue? <No> ",resp
		w !
		if "Yy"'[$E(resp_"X") {
			quit 0
		}
    }
    quit 1  ;ok to restore
}
SELDIR(dir,mirdbname) ;get the list of arrays
 N DONE,SELTARG,SEL1 
 S DONE=0
 S I=1
 while $D(SELDIR(I)) && ('DONE) {
    S SEL1=$P(SELDIR(I),",")
    if SEL1'="" {
	    ;See if the configuration file entry is based on mirror db names
	    if $E(SEL1,1,8)=":mirror:" {
		    if SEL1=mirdbname {
			    s SEL1=dir
		    } else {
			    goto next	    
		    }
	    }
 	    S SEL1=$ZU(12,SEL1)
 	    if SEL1=$zu(12,dir) {
 			S SELTARG=$P(SELDIR(I),",",2) ; Second piece is target dir
 		    I (SELTARG="X") || (SELTARG="x") {
	 		    S NODIR(dir)=""   ;not a directory
 		    } else {
 			   	I SELTARG="" {
	 			   	; If the source directory is mirrored then use the local
	 			   	; copy of that mirror db as the default output directory
	 			   	if mirdbname'="" {
		 			   s SELTARG=$G(MirrorDBList(mirdbname,"path"))
	 			   	}
	 			   	if SELTARG="" {
	 			   	   S SELTARG=dir ;same directory
	 			   	}
 			   	}
 			   	IF $E(SELTARG,1,8)=":mirror:" {
	 			   	s SELTARG=$G(MirrorDBList(SELTARG,"path"))
	 			   	if SELTARG="" {
		 			   	; Have to abort here - we don't have a location
		 			   	; for this so we can't just create a missing database
		 			   	s NODIR(dir)=""
		 			   	s DONE=1
		 			   	goto next
	 			   	}
 			   	}
 				S SELTARG=$ZU(12,SELTARG)
 				; See if the target is a mirrored database
			    s targmirdbname=$G(MirrorDBList("path",SELTARG))
 				if targmirdbname'="" {
	 				; The target is mirrored. We don't overwrite a mirrored
	 				; database during non-interactive restore (eg. now) unless
	 				; the source matches the target and the source is newer 
	 				; than the target or the target is inactve (eg. might be
	 				; broken)
	 				;
	 				; mirdata & mirdbname are set based on the source
	 				; database. Now compare them to the values in the
	 				; target db in info.
	 				s info=$G(MirrorDBList(targmirdbname,"info"))
	 				if targmirdbname'=mirdbname {
		 				s NODIR(dir)=""
	 				} elseif $P(info,":",4)'=$P(mirdata,":",4) {  ;database guid
					    s NODIR(dir)=""
				    } elseif $P(info,":",5)'=$P(mirdata,":",5) {  ; mirror guid
					    s NODIR(dir)=""
				    } elseif 'MirrorDBList(targmirdbname,"activationreq") {
					    ; If the db needs activation, then we're good to go. Otherwise
					    ; make sure that it isn't more current than the copy we're restoring. 
					    s curjrnfilecnt=+$P(info,":",2),curjrnoff=+$P(info,":",3)
					    s backupjrnfilecnt=+$P(mirdata,":",2)
					    s backupjrnoff=+$P(mirdata,":",3)
					    if (curjrnfilecnt>backupjrnfilecnt) || 
					        ((curjrnfilecnt=backupjrnfilecnt) && (curjrnoff>backupjrnoff)) {
						    S NODIR(dir)=""
					    }
				    }
 				}
 				if '$D(NODIR(dir)) {
 				   	if (SELTARG=dir) {
	 				   	s NEWDIR(dir)=""
 					} else {
	 					s NEWDIR(dir)=SELTARG
 					}
 					; Third piece is used if target directory does not exist
 					S DIRNEW(SELTARG)=$P(SELDIR(I),",",3)
 				}
 		    }
 			s DONE=1  ;exit while loop and indicate we found a match
 	    }
    }
next ;    
    s I=I+1
 }
 I 'DONE S NODIR(dir)="" ;never found
 Q
 ;Restore a volume
VOLUME s EOV=0,EOS=0,OK=1 ; haven't yet reached an end of volume
 I VOLNUM=1 S LASTFUNC="",DIRNAM="" ; if 1st, not continuing a func
 I LASTFUNC="SKIP" d SKIPDIR q:'OK!EOV!EOS  G dirnext
 I LASTFUNC="RESTORE" DO:'$g(QUIETMODE)  D DIRREST Q:'OK!EOV!EOS  G dirnext
 . w !,"***Continuing restore of "_DIR w:DIR'=DIRNAM " to "_DIRNAM W !
 D SKIPDIR ; read to the first directory block
 I EOV!EOS W:'$g(QUIETMODE) *7,!,"[Can't find any directories in this input file]",! q
 Q:'OK
 ; process additional directories in this file
dirnext For  D dodir Q:'OK!EOV!EOS
 Q
dodir ;
 S LEN=$V(VOLLOC,-3,2),VOLLOC=VOLLOC+2
 s dirneed=$$nextvol() ; get file characteristics from label
 g dirnamer:dirneed="" s DIR=$g(gdir(+dirneed)) g dirnamer:DIR=""
 s DIRNAM=$p($g(DIRNAM(DIR)),"^",1) s:DIRNAM="" DIRNAM=DIR
 g SKIPDIR:$D(NOREST(DIR)),dirnamer:'$D(DIRNAM(DIR))
 g dirnamer:($l(dirneed,",")<24)
 s dirhave=$ZU(49,DIRNAM) ; get actual file characteristics
 i +dirhave=-2!(+dirhave=-3) {
   i '((RESTYPE="ALL")||("Yy"[$e($g(DIRNEW(DIRNAM))_"?"))||($g(TopDir,"")'="")) {
     S NOREST(DIR)="" K DIRNAM(DIR),nodir(DIRNAM),dejrn(DIRNAM)
     D Show("restwont",DIRNAM),SKIPDIR Q
   }
 }
 i '$g(DIRNAM(DIR,"fixedtargdb")) {
   s sc=$$FixTargetDatabase(DEV,DIRLIST,dirneed,0)
   i ('sc) s OK=sc d abortdir,SKIPDIR q
   s dirhave=$ZU(49,DIRNAM) ;update 'dirhave' in case it changed
   s DIRNAM(DIR,"fixedtargdb")=1 ;only do this once per directory
 }
 ; If necessary, change the file characteristics of this directory
 s OK2=1
 i $p(dirhave,",",2)=2048 d
 . n partialmap,havemaps,zt,blkn,mapsz
 . s partialmap=0,havemaps=+$p(dirhave,",",24)
 . i havemaps=+$p(dirneed,",",24) d  
 . . S mapsz=+$P(dirhave,",",23) O 63:"^^"_DIRNAM V (havemaps-1)*mapsz+1
 . . f blkn=mapsz-1:-1:0 q:$V(blkn,0,1)'=254 
 . . s partialmap=mapsz-1-blkn C 63
 . i partialmap!(havemaps<$p(dirneed,",",24)) d  i 'OK d SKIPDIR s OK2=0 q
 . . i partialmap S $P(dirneed,",",24)=0
 . . do modify 
 . i havemaps>$p(dirneed,",",24) d MOUNTQ(DIRNAM)
 e  d
 . n partialmap,havemaps,zt
 . s partialmap=0,havemaps=+$p(dirhave,",",4)
 . i havemaps<$p(dirneed,",",4) d  i 'OK d SKIPDIR s OK2=0 q
 . . do modify 
 . i havemaps>$p(dirneed,",",4) d MOUNTQ(DIRNAM)
 ;
 q:'OK!EOV!EOS!'OK2
 ; Start the restore
 if 'QUIETMODE {
   d $zu(9,"","Restoring "_DIR_$s(DIR'=DIRNAM:" to "_DIRNAM,1:"")_" at "_$ztime($p($h,",",2)))
 }
 d DIRREST ; restore the directory
 q
DIRREST S LASTFUNC="RESTORE",FUNC=1
dirrest1 H 0 S sec=$zh
 s RC=$$ZU(52,FUNC,DIRNAM,sfn),sec=$zh-sec,FUNC=1,VOLLOC=BUFBASE+$P(RC,",",3)
 s TOTAL(DIRNAM)=$g(TOTAL(DIRNAM))+$p(RC,",",2)
 d Show("stchk0",$P(RC,",",2),$fn(sec,"",1),TOTAL(DIRNAM))
 ; check return code
 i +RC=RCDIRLABELRECORD!(+RC=RCDIRLABELMISSING)!(+RC=RCBADRECORDONRESTORE&($p(RC,",",3)=OBDIRLAB)) d  q
 . i +RC=RCBADRECORDONRESTORE d Show("stchk2") s DEV=""
 . d nextlabel(RC)
 i +RC=RCJRNMARKINFORECORD s DEJRNSTART=$p(RC,",",3,$l(RC)),EOS=1 q
 i +RC=RCENDOFVOL s EOV=1 q
 i +RC=RCENDOFVOLSET d done s EOS=1 q
 i +RC=RCINERRLABELGOOD d  g dirrest1
 . s y=$p(RC,",",3,999) f i=0:1 s a=$p(y,",",i*3+3) q:a  i a="" d  q
 . . d Show("stchk3") s DEV=""
 . . i '$g(QUIETMODE) d
 . . . f i=0:1 s a=$p(y,",",i*3+1) q:a=""  i a<(65536*65536-10) w a,?8,gdir($p(y,",",i*3+2)),!
 i +RC=RCMISSINGBLKS d  g dirrest1
 . d Show("stchk4") s DEV=""
 . s lastblk=$p(RC,",",3),lastsfn=$p(RC,",",4),nextblk=$p(RC,",",5),nextsfn=$p(RC,",",6)
 . s lastdir=$g(gdir(lastsfn),"<sfn="_lastsfn_">")
 . s nextdir=$g(gdir(nextsfn),"<sfn="_nextsfn_">")
 . i lastsfn=nextsfn,nextblk'<lastblk d
 . . d Show("stchk5",lastblk,nextblk,lastdir)
 . e  d Show("stchk6",lastblk,lastdir,nextblk,nextdir)
 . w:'$g(QUIETMODE) ! q
 i +RC=RCBADRECORDONCOPY!(+RC=RCBADRECORDONRESTORE) d  g dirrest1
 . s DEV=""
 . Set size=+$p(RC,",",4),blk=$p(RC,",",5),skip=$p(RC,",",6)\4
 . If +RC=RCBADRECORDONCOPY Do Show("stchk8",blk) If 1
 . Else  Do Show("stchk7",blk)
 . If skip Do Show("stchk24") Set a=$$ZU(52,2) q
 . w:'$g(QUIETMODE) ! i '$$viewblk d Show("stchk9") s a=$$ZU(52,2) q
 . d Show("stchk10")
 . s i=$increment(^CacheRestoreBad(startday,starttime,DIRNAM,blk))
 . s ^CacheRestoreBad(startday,starttime,DIRNAM)=size
 . s a=size\(16*1024),b=size#(16*1024),c=0
 . f j=0:1:a-1 s ^CacheRestoreBad(startday,starttime,DIRNAM,blk,i,j)=$v(c,0,-(16*1024)),c=16*1024+c
 . i b s ^CacheRestoreBad(startday,starttime,DIRNAM,blk,i,a)=$v(c,0,-b)
 . c 63
 s OK=$$Error^%apiOBJ(7367,DIR,DIRNAM,RC)
 i +RC=RCBLKSIZE d Show("stchk11"),SKIPDIR q
 i +RC=RCMAPERR d Show("stchk12"),abortdir,SKIPDIR q
 i +RC=RCMOUNT d Show("stchk14",DIRNAM),abortdir,SKIPDIR q
 i +RC=RCOUTERR d Show("stchk15"),abortdir,SKIPDIR q
 d Show("stchk16") g abortrestore
 q
 ;
 ; done with restore
done ;
 d Show("stchk17") s a=$$ZU(52,4)
 q
 ;
 ;abortrestore
 ; abort rest of restore
abortrestore ;
 d Show("stchk18") i $$ZU(52,4)
 q
 ;
 ; viewblk
viewblk() ;
 s $zt="viewerr"
 o 63:"^^"_dir v blk q 1
viewerr q 0
 ;
abortdir ;
 d Show("abtdmt")
 s outdir=$P(DIRNAM(DIR),"^",1)
 s:outdir="" outdir=DIR  ; if restoring to same place, outdir would be null
 n origchr
 s origchr=$P(DIRNAM(DIR),"^",2)
 i +$ZU(49,outdir)>-1,origchr'="" d
 . s n=$$ZU(52,7,outdir,+origchr)
 . i $g(QUIETMODE) q
 . i n'=1 w !,*7,"Failed to restore size characteristics of ",DIR
 . i n'=1 w " (code = ",n,")"
 s n=$$ZU(52,5,outdir,-1)  ; Convert the GFINCREST flag to a DISMOUNT state
 ; indicate skip in future
 ; & don't remount & don't restore journal
 K DIRNAM(DIR),nodir(DIR),dejrn(DIR)
 k CLSTATE(DIR)
 S NOREST(DIR)="" K DIRNAM(DIR),nodir(DIRNAM),dejrn(DIRNAM) Q
SKIPDIR ;returns OK, EOV, EOS
 i DIRNAM'="" d Show("stchk19",DIRNAM)
 s begintime=$zh
 S LASTFUNC="SKIP",RC=$$ZU(52,2,"",sfn),VOLLOC=BUFBASE+$P(RC,",",3)
 s sec=$zh-begintime,numblks=$p(RC,",",2)
 d:DIRNAM'="" Show("stchk20",numblks,sec)
 ; check return code
 ; If no error, see if we reached end of volume condition
 i +RC=RCDIRLABELRECORD!(+RC=RCDIRLABELMISSING) d  s OK=1 q
 . d nextlabel(RC)
 i +RC=RCBADRECORDONRESTORE d Show("stchk2"),nextlabel(RC) s OK=1 q
 i +RC=RCJRNMARKINFORECORD s DEJRNSTART=$p(RC,",",3,$l(RC)),EOS=1,OK=1 q
 i +RC=RCENDOFVOLSET d Show("stchk21",DIRNAM),done s EOS=1,OK=1 q
 ; Check for end of input volume
 I +RC=RCENDOFVOL d Show("stchk22",DEV,DIRNAM) S BUFCOUNT=$P(RC,",",2),EOV=1,OK=1,a=$$ZU(52,3) q
 i +RC=RCMISSINGBLKS d  g SKIPDIR
 . d Show("stchk4")
 . s lastblk=$p(RC,",",3),lastsfn=$p(RC,",",4),nextblk=$p(RC,",",5),nextsfn=$p(RC,",",6)
 . s lastdir=$g(gdir(lastsfn),"<sfn="_lastsfn_">")
 . s nextdir=$g(gdir(nextsfn),"<sfn="_nextsfn_">")
 . i lastsfn=nextsfn,nextblk'<lastblk d
 . . d Show("stchk5",lastblk,nextblk,lastdir)
 . e  d Show("stchk6",lastblk,lastdir,nextblk,nextdir)
 ; Must have an input error
 d Show("stchk23",DEV,DIRNAM)
 s OK=$$Error^%apiOBJ(7366,DIR,RC)
 d Show("SKIPDIR") w:'$g(QUIETMODE) ! g SKIPDIR:OK
 q
create ;
 i (RESTYPE="ALL")||("Yy"[$e($g(DIRNEW(DIRNAM))_"?"))||($g(TopDir,"")'="") {
   s OK=$$c5(DIRNAM) 
   i OK d c2 
   i OK q
   S NOREST(DIR)="" K DIRNAM(DIR),nodir(DIRNAM),dejrn(DIRNAM)
   q
 }
 S OK=$$Error^%apiOBJ(7321,DIRNAM)
 D Show("restwont",DIRNAM)
 S NOREST(DIR)="" K DIRNAM(DIR),nodir(DIRNAM),dejrn(DIRNAM)
 Q
c2 ;
 i '$$QUIET() s OK=$$Error^%apiOBJ(7306) q
 d DISMOUNT(DIRNAM)   ; File created mounted, dismount
 i '$$QUIET() s OK=$$Error^%apiOBJ(7306) q 
 d MOUNTQ(DIRNAM)     ; remount
 i 'MasterJob s rc=$$ZU(52,5,DIRNAM,1)
 i rc<0 {
   d Show("errmrk1",DIRNAM)
   s OK=$$Error^%apiOBJ(7368,rc)
 }
 d MOUNTQ(DIRNAM)
 i $$QUIET()   ; can't hurt
 s dirhave=$ZU(49,DIRNAM)
 s OK=1 q
c3() s $ZT="c4" X $$zucom(0) q zuret
c4 s $ZT="",$ZE="" q -1
c5(DIRNAM) {  /* Private so it can't be called from outside of DBREST2 */
 	i $zu(12,DIRNAM,3)="" {  ; First create all directories in path
		Set name=$zu(12,DIRNAM,1,1)
		If name="" {
			w:'$g(QUIETMODE) !,*7,"[Couldn't create ",DIRNAM,"]",!
			Quit $$Error^%apiOBJ(5007,DIRNAM)
		}
		s rc=$ZU(140,9,DIRNAM,1) ;,1 = create missing dirs in the tree
		if rc<0 {
			w:'$g(QUIETMODE) !,*7,"[Couldn't create this directory (rc = "_rc_")]",!
			q $$Error^%apiOBJ(5032,DIRNAM)
		}
 	}
 	s rc=$$c3 ; Now try to create the database file
	i rc<0 {
		w:'$g(QUIETMODE) !,*7,"[Couldn't create this directory]",!
		q $$Error^%apiOBJ(7372,DIRNAM,rc)
 	}
 	q 1
}
MOUNTQ(dir) ;
 N a S a=$ZU(17,dir) Q  ;Quick Mount: mount w/o implicit/replication
MOUNTQ2(dir) ;
 Q $ZU(17,dir)  ;Like MOUNTQ but returning status
 ; form ZU command for file create or file modify
zucom(func) ;build appropriate execute for ZU functions
 s a="s zuret=$ZU("_func_",DIRNAM"
 f i=2:1:12 s a=a_","_$p(dirneed,",",i)
 Q a_")"
 ; error in directory name
dirnamer S OK=$$Error^%apiOBJ(7381,DEV) w *7,!,"[Directory label error]",! Q
modify ; Modify a directory
 I '$G(QUIETMODE) w "Expanding "_DIRNAM_" ...",!
 n curchar
 s curchar=$ZU(49,DIRNAM)
 i partialmap s zt=$ZT,$ZT="mod2"
 X $$zucom(1) ; modify the directory
mod2 I partialmap S $ZT=zt,$ZE="",$P(dirneed,",",24)=havemaps
 E  I zuret<0 DO  Q
 . w !,*7,"[Couldn't expand directory "_DIRNAM_" Error "_zuret_"]",!
 . s OK=$$Error^%apiOBJ(7383,DIRNAM,zuret) d abortdir
 ; Wait for expansion to complete
 n x,v
 s x=$ZU(40,2,46)
 i partialmap d Show("expmap",DIRNAM)
 i 'partialmap d
 . d Show("expand2",DIRNAM,$p(curchar,",",4),$P(dirneed,",",4))
 f  h 1 s v=$v(x,-2,$ZU(40,0,22)) q:v'=1  w "." i $X>67 d
 . W !,"        ." ;show every 60
 V x:-2:$ZU(40,0,22):0 ;reset internal flag so others can use it
 I $V(x,-2,$ZU(40,0,22)) V x:-2:$ZU(40,0,22):0 ; ? this came from MSUUS2 but why?
 I partialmap D
 . S mapsz=+$P(dirhave,",",23) O 63:"^^"_DIRNAM V (havemaps-1)*mapsz+1
 . f blkn=mapsz-1:-1:0 q:$V(blkn,0,1)'=254 
 . s blkn=mapsz-1-blkn C 63
 . i blkn=partialmap D Show("expnoblk",DIRNAM,mapsz-blkn)
 . i blkn<partialmap D Show("expblk",DIRNAM,mapsz-partialmap,mapsz-blkn)
 I 'partialmap,v=2 D Show("experr") s OK=$$Error^%apiOBJ(7383,DIRNAM,"") d abortdir q
 ;
 d DISMOUNT(DIRNAM)  ; Flush blocks to disk
 d MOUNTQ(DIRNAM)    ; and make it accessable to us again
                     ; note: gfincrest prevents others 
                     ;       from using it.
 s OK=1 q
VOLLABEL ;read a volume label
 I VOLNUM=1 DO  Q
 . s RC=$$ZU(52,4),RC=$$ZU(52,0)
 . H 0 S RC=$$OpenDev(DEV)
 . I +RC'=1 S OK=$$Error^%apiOBJ(7335,DEV) Q
 . S BUFBASE=$P(RC,",",4),VOLLOC=BUFBASE+$P(RC,",",2) D VOLHEAD
 ;VOLNUM>1, an error
 w:'$g(QUIETMODE) !!,"RESTORE OF FILE "_INPDEV_" HAS FAILED, BACKUP MAY BE CORRUPT",!
 q
OpenDev(DEV) s $ZT="OpenErr" Quit $$ZU(52,0,DEV)
OpenErr Quit RCINERR
VOLHEAD ;
 I +RC=RCOLDFORMAT D:'$g(QUIETMODE)  S OK=$$Error^%apiOBJ(7336,"InterSystems IRIS") S DEV="" Q
 . W *7,!,"[This volume has an obsolete backup format not supported by this "_"InterSystems IRIS"_" version]",!
 I +RC=RCBADVOLUME D:'$g(QUIETMODE)  S OK=$$Error^%apiOBJ(7336,"InterSystems IRIS") S DEV="" Q
 . W *7,!,"[This is not a "_"InterSystems IRIS"_" Backup File]",!
 N HEAD S HEAD=$$nextvol()
 I "InterSystems IRIS"_" BACKUP"'=HEAD,"Open M BACKUP"'=HEAD DO:'$g(QUIETMODE)  S OK=$$Error^%apiOBJ(7336,"InterSystems IRIS") S DEV="" Q
 . W *7," [This is not a "_"InterSystems IRIS"_" Backup File]",!
 N VERID,HEAD,BackupVersion
 S VERID=$$nextvol()  ;"VERSION<nnn>" where <nnn> is the version #
 I $E(VERID,1,7)="VERSION" {
     s vernum=+$E(VERID,8,*)
     ; vernum is 0 for "VERSION", 1 for "VERSION1.0", etc...
    S BackupVersion=$$nextvol()  ;$ZV string
    S HEAD(1)=$$nextvol()  ;Backup volume #
 } else {
    S HEAD(1)=VERID,BackupVersion="UNKNOWN"
    s vernum=0
 }
 F I=2:1:12 S HEAD(I)=$$nextvol() ; Read header info
 if vernum>0 {
     ; version 1 introduces mirror support. 
     s HEAD(13)=$$nextvol()  ; : seperated mirror name, guid, local sys name, etc
 } else {
     s HEAD(13)=""  ;JO2379
 }
 if VOLNUM=1,$P(HEAD(13),":",3)="" {
     s MirrorBackup=0
 } else {
     s MirrorBackup=1
 }
 I HEAD(1)'=VOLNUM do $ZU(31,1,BUFCOUNT) D volerr("Volume number") Q
 I VOLNUM'=1 {
    /* This is not a 1st volume, so verify that it is for
       the correct backup and then quit
       [JO2313] we could add code here to store/validate the mirror id
       (eg. HEAD(13)) across volumes if that seems useful
    */
    i BACKDATE'=HEAD(2) do $ZU(31,1,BUFCOUNT) D volerr("Date") q
    i BACKTIME'=HEAD(3) do $ZU(31,1,BUFCOUNT) D volerr("Time") q
    i BACKTYPE'=HEAD(4) do $ZU(31,1,BUFCOUNT) D volerr("Type") q
    i DESCRIPTION'=HEAD(11) do $ZU(31,1,BUFCOUNT) D volerr("Description") q
    if MIRRORINFO'=HEAD(13) do $ZU(31,1,BUFCOUNT) D volerr("MirrorInfo") q
    S OK=1 ; This volume label is correct
    quit
 }
 I BACKSET=1 {
     if MirrorBackup {
         ; MirrorRestore=0 - ignore mirror informatin
         ;              =1 - restore all db's (backup is from this system)
         ;              =2 - restore only mirrored db's which exist
         s MirrorRestore=$$GetMirrorInfo(HEAD(13),RESTYPE,$G(QUIETMODE))
         if MirrorRestore'=0 {
             if (vernum<1.1)&&(RESTYPE="ALL")&&(TopDir="") {
                 /* For a restore of all databases without specifying a
                   new topdir we require a backup version # of 1.1 or 
                   higher. 1.1 added the mirror database nofailover flag to
                   the backup header. It would be ok to continue however the
                   code will think all the mirrored databases have the nofailover
                   flag clear (eg. they are read/write) so it will refuse to restore
                   any of them. */
                   if '$G(QUIETMODE) {
                       w !,"This is a version ",vernum," backup file from an older"
                       w !,"mirror member so the mirrored databases cannot be automatically"
                       w !,"restored. Use a selective restore or pick a new top level"
                       w !,"directory. Because it is from an older version, DBREST will not"
                       w !,"prevent a database in the backup which was marked read/write on"
                       w !,"an async member from begin restored over a read/only failover copy."
                   }
                   goto ERR
             }
             do BuildMirrorDBList($G(QUIETMODE),.MirrorDBList)
         }
     }
 }
 S OK=1
 I BACKSET'=1 DO  q:'OK
 . i HEAD(4)="Full" DO  Q
 . . I '$G(QUIETMODE) D
 . . . w !,"This is a full backup file. A full backup can only be"
 . . . w !,"the first backup restored in a sequence. If there are"
 . . . w !,"multiple full backups which need to be restored, ^DBREST"
 . . . w !,"must be run separately for each file. Restoring"
 . . . w !,"multiple full backups in a single run of DBREST would"
 . . . w !,"cause problems with the subsequent journal restore."
 . . s DEV=""
 . . s OK=0
 . i HEAD(4)="Cumulative Incremental" DO  Q
 . . I HEAD(5)<PREVH ;either before that date
 . . E  I +HEAD(5)=+PREVH,$p(HEAD(5),",",2)<$p(PREVH,",",2) ;or time
 . . I  W:'$g(QUIETMODE) !,"Date must be more recent than last restored backup"
 . . I  D volerr("Date") Q
 . . I PREVFDATE'="",PREVFDATE'=HEAD(9) D volerr("Date") q
 . . I PREVFTIME'="",PREVFTIME'=HEAD(10) D volerr("Time") q
 . . S OK=1
 . ; Must be a regular incremental backup - Check that the
 . ; previous date/time match the last restored date/time
 . i PREVDATE'=HEAD(6) D volerr("Date") q
 . i PREVTIME'=HEAD(7) D volerr("Time") q
 . S OK=1 ; This volume label is correct
 ;
 S BACKDATE=HEAD(2),BACKTIME=HEAD(3),BACKTYPE=HEAD(4),BACKH=HEAD(5)
 S PREVDATE=HEAD(6),PREVTIME=HEAD(7),PREVTYPE=HEAD(8)
 S PREVFDATE=HEAD(9),PREVFTIME=HEAD(10),DESCRIPTION=HEAD(11)
 S MIRRORINFO=HEAD(13)  ;From $$LookupMirrorInfo^DBACK()
 I BACKTYPE="Full" S PREVFDATE=BACKDATE,PREVFTIME=BACKTIME ;Full!
 Q
volerr(A) ;
 S OK=$$Error^%apiOBJ(7382,DEV)
 i '$g(QUIETMODE) {
   w !,*7," [",A," error in the volume label]",!
   D voldisp 
   W !,"We were expecting:",!,"  Volume #: ",VOLNUM
   W "  with Previous date: ",PREVDATE,"  and time: ",PREVTIME
   W !,"  and buffer count of: ",BUFCOUNT,!!
 }
 Q
 ; Display the volume label
voldisp d:BackupVersion="UNKNOWN" Show("volnover")
 d:BackupVersion'="UNKNOWN"
 . n Vers ; remove date & time from end of version string
 . s Vers=BackupVersion,Vers=$e(Vers,1,$f(Vers," ",$f(Vers,")")+1)-2)
 . d Show("voldisver",Vers)
 d Show("voldis14",HEAD(1),HEAD(2),HEAD(3),HEAD(4))
 d Show("voldis68",HEAD(6),HEAD(7),HEAD(8))
 d Show("voldis9e",HEAD(9),HEAD(10),HEAD(11),HEAD(12))
 if HEAD(13)'="" {
	 if $P(HEAD(13),":",1)'="" {
		; backup is from a failover member, mirror name is not null
        d Show("voldis13",$P(HEAD(13),":",1),$P(HEAD(13),":",3))
	 } else {
		; backup is from an async member, mirror name is null
        d Show("voldis13b",$P(HEAD(13),":",3))
	 }
 }
 Q
volh1 D voldisp W !,"Is this the backup you want to start restoring?"
 S OK=$$YESNO(1) Q
GETDEV ;select a device to use -- returns DEV,OK
 W !!,"Specify input file for volume "_VOLNUM
 ;
 I VOLNUM=1 DO  ;first time!
 . I PREVDATE="" W " of backup "_BACKSET
 . E  w " of backup following "_PREVDATE_"  "_PREVTIME
 ;
 I VOLNUM>1 W " dated "_BACKDATE_"  "_BACKTIME
 ;
 W !," (Type STOP to exit)"
 W !,"Device: " W:DEV]"" DEV_" => " R ANS,! S:ANS]"" DEV=ANS
 I DEV=""!$$STOP(ANS) S OK=0 Q
 ;
 S DEV=$$FILENORM(DEV) S OK=1
 S XLT=$$GETXLT(DEV)
 Q        
GETXLT(DEV) ;get nls translation table for this device
 I DEV?2N,$G(^%IS(DEV,0))="Magnetic tape" S XLT=$$GetPDefIO^%SYS.NLS(4)
 E  S XLT=$$GetPDefIO^%SYS.NLS(3)
 Q XLT
 ;
 ; nextlabel
 ; we've reached a label record or missing label record
 ; get its characteristics
 ; call: x is return string from a function
 ;       with return code of RCDIRLABELRECORD,RCDIRLABELMISSING, or RCBADRECORDONRESTORE
 ; returns: sfn  input file #
 ;          dir  directory name to which restore
nextlabel(x) ;
 s zu49=""
 i +x=RCDIRLABELMISSING s sfn=$p(x,",",3),filesize=$p(x,",",4) q:'filesize
 e  i +x=RCDIRLABELRECORD!(+x=RCBADRECORDONRESTORE) s sfn=$p(x,",",6),filesize=$p(x,",",7),zu49=$p(x,",",8,99)
 s (dir,DIR)=gdir(sfn)  ; get directory name
 s DIRNAM=$p($g(DIRNAM(DIR)),"^",1) s:DIRNAM="" DIRNAM=DIR
 i +x'=RCBADRECORDONRESTORE,$d(DIRNAM(DIR)) s $p(DIRNAM(DIR),"^",2)=filesize
 ; make sure current file is at least filesize big
 ; If not, then expand it
 ; If +x=RCBADRECORDONRESTORE, then the filesize and zu49 info is questionable but the rest is reliable
 q
 ;
initconstants ;
 s OBDIRLAB=65536*65536-1 ;directory label "blk #"
 s RCSUCCESS=1   ;success
 s RCINERR=-1    ; General Input error
 s RCOUTERR=-2   ; General output error 
 s RCMOUNT=-4    ; either directory name was too long or we couldn't mount the directory
 ; input errors during backup (in addition to RCINERR)
 s RCBADMAP=-11  ; 2kb: missing incremental bitmaps
                 ;big database: Bad label in incremental backup bitmap
 s RCMAPINERR=-13 ; disk error reading incremental backup bitmap
 ;
 ; write errors during backup (in addition to RCOUTERR)
 ;
 s RCEOT=2       ; Output: end of tape or volume
 s RCOFFLINE=3   ; Output device offline
 s RCDEVFUL=4    ; Output: file expansion failed
 ; # 5 no longer used
 ;
 ; input errors during $zu(52,0,device) which opens input volume and reads label
 ; (in addition to RCINERR)
 s RCOLDFORMAT=-6        ; On a restore, Input file has old backup
                         ;file format.  Abort the restore.
 s RCBADVOLUME=-7        ; Input file is not backup file format.
                         ;In general, if we fail during open of input
                         ;device or 1st read of it we get an RCINERR error.
                         ;If the volume block's contents are bad, we
                         ;get either RCBADVOLUME or RCOLDFORMAT
 ; success returns during restore
 s RCENDOFVOL=-10        ; End of input backup volume reached
 s RCENDOFVOLSET=-17     ; End of input backup volume reached and
                         ; this is the last volume
 s RCDIRLABELRECORD=-18  ; reached a directory label record, current
                         ; record is next record
 s RCDIRLABELMISSING=-19 ; we're at a data record for a different
                         ; directory and we should act as if we
                         ; reached a directory label except the
                         ; current record is the first data block of the
                         ; next directory to be restored.  This usually
                         ; is the result of various read errors that
                         ; resulted in missing a directory label record
 s RCJRNMARKINFORECORD=-20 ;reached a journal marker info record, likely the
                         ; last record on the last volume
 ; input errors during restore (during restore, if we get an input
 ; error we usually translate it to something else)
 s RCINERRLABELGOOD=-14  ; We got an error reading a block but
                         ; it passed validation on its label.
                         ; The contents should be reported by the
                         ; utility as suspicious unless we can
                         ; determine that there's a particular
                         ; 1 or more records that fail crc.
                         ; We should then try to restore its contents,
                         ; and we should expect one or more of the
                         ; records in the block to result in
                         ; a RCBADRECORDONRESTORE error.
 s RCBADRECORDONCOPY=-15 ; record in rinbp->ricurr is bad
                         ; It was bad when the backup was originally
                         ; created i.e. we got a read error during
                         ; the backup). Normally the utility
                         ; should save a copy of the block that
                         ; is already in the CACHE.DAT file and
                         ; then restore this block
 s RCBADRECORDONRESTORE=-8 ; record in rinbp->ricurr failed
                         ; CRC validation, probably due to a read
                         ; error during the restore.
                         ; We probably previously got a
                         ; RCINERR_LABELGOOD error on this block.
                         ;  If both _ONCOPY and _ONRESTORE conditions
                         ; are present, we report it as _ONRESTORE.
                         ; Normally the utility should save a copy of the
                         ; block that is already in the CACHE.DAT file and
                         ; then restore this block
 s RCMISSINGBLKS=-16     ; The block # of the last record in the last block
                         ; successfully read from the input media doesn't
                         ; match what this block has in incrlabel_LASTBLKNUM
                         ; and incrlabel_LASTSFN.   We must have skipped
                         ; some blocks (which is probably the result of read
                         ; errors.)
 ; -9, RCBADLABEL, is no longer used.  If we get an input block
 ; whose label fails validation (e.g. CRC wrong), we act like we
 ; just got an input error
 s RCBLKSIZE=-12 ; record in rinbp->ricurr has the wrong
                 ;block size for this CACHE.DAT file
                 ;If this is the first block for this CACHE.DAT
                 ;then we probably are restoring to the wrong
                 ;CACHE.DAT (one with a different block size),
                 ;and that is a fatal error.  Otherwise it is
                 ;probably a label error and we should skip this
                 ;input block.
 ; other restore errors in $zu(52,1,...) and $zu(52,4)*/
 s RCOUTCLUMNT=-3        ; Target of restore is cluster mounted
                         ;       but must be privately mounted.  This error
                         ;       occurs when we issue $zu(52,1,...) to open
                         ;       cache.dat file as target JAO742
 s RCMAPERR=-5   ; 2kb only: Problem detected between
                 ;          source & target map blocks.  This is
                 ;           a fatal error in attempting to restore
                 ;           to this target file JAO572
 q
 /* GetMirrorInfo when the volume header of the 1st backup being
    restored indicates it came from a mirror. We come here to
    figure out whether we're a member of this mirror and if so,
    what we want to do.
    Returns a value for MirrorRestore based on what we should do with 
    mirrored db's for a full database restore (selective database restores 
    the user decides what to do with each database).
    ReturnValue = 0 - Mirrored databases are not restored
                = 1 - Backup being restored on mirror member which generated
                      the backup, all databases are restored
                = 2 - Backup being restored on a different mirror member, only
                      mirrored databases which exist locally are restored 
                      (also used when restoring to async members)
 */
GetMirrorInfo(MIRINFO,RESTYPE,QUIETMODE) PUBLIC {
    ; When MirrorRestore is 0 we will restore mirrored db's but
    ; we don't do anything special. The target of a restore cannot be
    ; a mirrored database.
    s QUIETMODE=+QUIETMODE
    s isMirror=($SYSTEM.Mirror.GetInfo()[",DEFINED,")||$D(^SYS("MIRRORSET"))
    if 'isMirror {
        if 'QUIETMODE {
           w !,"Restoring a mirror backup but this system is not a mirror member"
        }
        quit 0
    }
    ;
    Set isReportingNode = ##class(Config.MirrorMember).isAsyncMember()
    if isReportingNode {
        ; Only restore databases which exist on the local system
        quit 2
    }
	s MirrorName=##class(Config.Mirrors).GetMirrorName()
    if MirrorName="" {
        if 'QUIETMODE {
           w !,"Mirror name not set in mirror configuration"
        }
        quit 0
    }
	s cls=##class(Config.Mirrors).Open(MirrorName,,,.rc)
    s MirrorGUID=cls.GUID
    s cls=""
    ;
    s cls=##class(Config.MirrorMember).Open(,,.rc)
    if ('rc) {
        if 'QUIETMODE {
            k err
            Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
            w !,"Failed to open mirror member configuration: ",err(1)
        }
        quit 0
    }
    s SystemName=cls.SystemName
    if SystemName="" {
        if 'QUIETMODE {
            w !,"Mirror system name not defined in mirror member configuration"
        }
        quit 0
    }
    ;
    s cls=##class(Config.MapMirrors).Open(MirrorName,SystemName,,,.rc)
    if ('rc) {
        if 'QUIETMODE {
            k err
            Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
            w !,"Failed to open MapMirrors.",MirrorName," to read info for ",SystemName,": ",err(1)
        }
        quit 0
    }
    s SystemGUID=cls.GUID
    s cls=""
    ;
    ; these are stored in HEAD(13) by LookupMirrorInfo^DBACK()
    s BackupMirrorName=$P(MIRINFO,":",1)  ;mirror name
    s BackupMirrorGUID=$P(MIRINFO,":",2)  ;guid of mirror
    s BackupSystemName=$P(MIRINFO,":",3)  ;guid of instance which ran backup
    s BackupSystemGUID=$P(MIRINFO,":",4)  ;guid of instance which ran backup
    if MirrorGUID'=BackupMirrorGUID {
        ; this backup is from a different mirror (and we're not a reporting
        ; node).
        if 'QUIETMODE {
            w !,"This backup is from a different mirror (",BackupMirrorName,")."
        }
        quit 0
    }
    if SystemGUID'=BackupSystemGUID {
        if 'QUIETMODE {
            w !,"This backup was made on the other mirror member."
            if RESTYPE="ALL" {
               w !,"Only mirrored databases which exist locally will be"
               w !,"restored."
            }
        }
        quit 2  ;only restore mirrored databases
    }
    ; this backup was created by this mirror member,
    ; restore everything (we could ask what they want to do here)
    quit 1
}   
 /* BuildMirrorDBList returns information about a mirrored
    database on the local system which might or might not be
    part of the active mirror (it could be dismounted, it could
    require catchup or it could be an active database). The
    information returned matches the information stored by
    getMirDBINFO^DBACKB for each database when the backup was
    created. */
BuildMirrorDBList(QUIETMODE,dblistp) PUBLIC {
    s x=$zu(40,0,41)
    s sfnmax=($V($ZU(40,2,176),-2,4))-1  ;highest sfn used
    s QUIETMODE=+QUIETMODE
    for sfn=0:1:sfnmax {
        s dbdata=$ZU(49,+sfn)
        if +dbdata>-1,($zb(+$p(dbdata,",",17),$zu(40,8,28),1)) {
           s namedata=$zu(49,+sfn,3)
           s locdir=$P(namedata,"^",2)
    	   s info=$SYSTEM.Mirror.DBGetInfoByName(0,locdir)
    	   if info'="" {
			   s dbname  =$P(info,"^",2)
			   s mirjrnfilecnt =$P(info,"^",3)
			   s jrnoff  =$P(info,"^",4)
			   s dbguid  =$P(info,"^",6)
			   s mirguid =$P(info,"^",7)
			   s mirname =$P(info,"^",8)
			   s sysguid =$P(info,"^",9)
			   ;
			   s nofailoverflag=+$P(info,"^",12)
			   s nofailoverbit=+$ZU(40,8,31)
			   s readonly=$ZB(nofailoverflag,nofailoverbit,1)          
			   if readonly'=0 s readonly=1
			   ; lastfilecntrestored is usually zero unless the database
			   ; is currently being caught up. In that situation this contains
			   ; the mirjrnfilecnt of the last journal file replayed to
			   ; this database.
			   s lastfilerest =$P(info,"^",11)
			   ; 
			   ; getMirDBINFO uses : as a seperator so we'll use that here
			   ; as well as it probably reduces confusion. Since we're using
			   ; : though we can't store any filenames/paths in the string
			   s backupinfo=dbname_":"_mirjrnfilecnt_":"_jrnoff_":"_dbguid
			   s backupinfo=backupinfo_":"_mirguid_":"_mirname_":"_sysguid
			   s backupinfo=backupinfo_":"_readonly
			   ;
			   s mirdbname=":mirror:"_mirname_":"_dbname
			   if '$D(dblistp(mirdbname)) {
                  s dblistp(mirdbname,"path")=locdir
                  s dblistp(mirdbname,"info")=backupinfo
                  s dblistp(mirdbname,"inactive")='$zb(+$p(dbdata,",",18),$zu(40,8,29),1)
                  s dblistp(mirdbname,"activationreq")=$zb(+$p(dbdata,",",18),$zu(40,8,32),1)
                  s dblistp("path",locdir)=mirdbname  ;create a translation from path->mirror db name
			   } else {
				  if 'QUIETMODE {
				     w !,"Two copies of ",mirdbname," found"
			         ; 1st copy				     
					 w !,?5,dblistp(mirdbname,"path")," "
					 if dblistp(mirdbname,"inactive") {
						 w "(inactive)"
					 } else {
						 w "(active)"
					 }
					 ; new copy
					 w !,?5,locdir," "
					 if '$zb(+$p(dbdata,",",18),$zu(40,8,29),1) {
						 w "(inactive)"
					 } else {
						 w "(active)"
					 }
					 w !,"Ignoring 2nd copy"
			      }
			   }
	   	    }
        }
    }
    quit
}
REASONtoStatus(REASON) {
 s tsc=1,DIR="" f  {
   s DIR=$o(REASON(DIR)) q:DIR=""
   s tsc=$system.Status.AppendStatus(tsc,REASON(DIR))
 }
 q tsc
}
INLOGOR(DIR,SOURCE,TARGET,DISPOSE) ;Adapter, present same i'face for VAX & UX
 n rc
 try {
   s rc=$ZU(31,DIR,SOURCE,TARGET,DISPOSE)
 } catch {
   s rc=-1_","_$ze
   s $ze=""
 }
 q rc
FILENORM(NAME) ;Return normalized version of NAME
 S OK=1,$ZT="FNERR"
 N MTDEV,DIR S MTDEV=$$OSDEVICE(NAME) I MTDEV'="" S ISREG=0 Q NAME
 i ($zversion(1)=2),$E(NAME,1,2)="\\" S L=$$CheckForTape(NAME) I L'="" S ISREG=0 Q L
 i ($zversion(1)=2) S L=$L(NAME,"\"),DIR=$P(NAME,"\",1,L-1)
 i ($zversion(1)=2) IF L>1 S DIR=DIR_"\"
 i ($zversion(1)=2) S NAME=$ZU(12,DIR)_$P(NAME,"\",L,L),ISREG=$ZU(140,7,NAME),ISREG=$S(ISREG>0:1,ISREG=-2:1,1:0) Q NAME
 i ($zversion(1)=3) S L=$L(NAME,"/"),DIR=$P(NAME,"/",1,L-1)
 i ($zversion(1)=3) IF L>1 S DIR=DIR_"/"
 i ($zversion(1)=3) S NAME=$ZU(12,DIR)_$P(NAME,"/",L,L),ISREG=$ZU(140,7,NAME),ISREG=$S(ISREG=-2:1,ISREG/32768#2:1,1:0) Q NAME
FNERR S OK=0,ERRMSG="Not a valid device name." Q
CheckForTape(NAME)
 S NAME=$ZCVT(NAME,"U")
 N I,TAPE
 For I=47:1:62 s TAPE=$$OSDEVICE(I) I NAME=$ZCVT(TAPE,"U") S NAME=I Q
 I NAME?2N Q NAME
 I NAME?1"\\.\TAPE"1N Q NAME
 Q ""
TQUIWRITE(verbose) q $$QUIESCE(1,"buffer activity",10,verbose)
TQUIGC(verbose) q $$QUIESCE(2,"garbage collection",10,verbose)
TQUIDB(verbose) q $$QUIESCE(4,"database expansion",10,verbose)
TQUIGLO(verbose) q $$QUIESCE(8,"global activity",10,verbose)
TQUIGLOUPD(verbose) q $$QUIESCE(16,"global updates",10,verbose)
TQUINET(verbose) q $$QUIESCE(32,"network activity",10,verbose)
TQUIDISK(verbose) q $$QUIESCE(1+2,"disk activity",10,verbose)
TQUIUPD(verbose) q $$QUIESCE(1+2+4+16,"update activity",10,verbose)
TQUISYS(verbose) q $$QUIESCE(1+2+4+8,"system activity",10,verbose)
QUIESCE(bits,text,retries,verbose,intv) ;
 s verbose=+$g(verbose),retries=+$g(retries,-1),intv=+$g(intv,1)
 q ($$Quiesce(bits,text,retries,verbose,intv)>0)
Quiesce(bits,text,retries,verbose,intv) ;
 n noWDbits
 s $zt="QUIESCEE"
 q:$zu(51,bits) 1 ;double checking $ZU(51) is no longer necessary
 s verbose=+$g(verbose),retries=+$g(retries,-1),intv=+$g(intv,1)
 d msgout($c(13,10)_"WARNING: Switch is set and may affect production for up to "_(retries*intv)_" seconds."_$c(13,10)_"Waiting for "_text_" to finish...",NOFORCE)
 f  q:'retries  h intv q:$zu(51,bits)  s retries=retries-1 i retries#5=0 d msgout(".",NOFORCE)
 s noWDbits=1
 s:$s($S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0):''$zu(59,0),1:0) noWDbits=noWDbits+2
 s noWDbits=$zboolean(bits,noWDbits,2)  ;2 = x & ~ y
 if '$ZU(51,bits),bits'=1,$zboolean(bits,1,1),$zu(51,noWDbits) {
	 d msgout($c(13,10)_"System is idle except WD is still running."_$c(13,10)_"     Waiting up to 2 minutes for WD to finish",NOFORCE)
	 f i=1:1:120 q:$ZU(51,bits)  h 1 if i#5=0 d msgout(".",NOFORCE)
	 if $ZU(51,bits) s retries=1 ;signal success
 }
 d msgout($s(retries:" ready.",1:" abort. "_$$quiescefailmsg(bits))_$c(13,10),NOFORCE)
 q retries
quiescefailmsg(bits)
 N ret,clu,clumsg s ret="",clu=$zb(bits,512+256+128,1),clumsg=""
 if $zb(clu,128,1)||($zb(clu,(256+512),1)=(256+512)) s clu=128,clumsg=" (cluster wide)"
 if $zb(clu,512,1) s clumsg=" (cluster master only)"
 if $zb(clu,256,1) s clumsg=" (cluster slaves only)"
 if $zb(bits,1,1)&&('$ZU(51,clu+1)) S ret=ret_"write daemon"_clumsg_","
 if $zb(bits,2,1)&&('$ZU(51,clu+2)) S ret=ret_"garbage collector"_clumsg_"," 
 if $zb(bits,4,1)&&('$ZU(51,clu+4)) S ret=ret_"file expander"_clumsg_","
 if $zb(bits,8,1)&&('$ZU(51,clu+8)) S ret=ret_"global reference"_clumsg_","
 if $zb(bits,16,1)&&('$ZU(51,clu+16)) S ret=ret_"global update"_clumsg_","
 if $zb(bits,32,1)&&('$ZU(51,clu+32)) S ret=ret_"client-side network connections"_clumsg_","
 if $zb(bits,64,1)&&('$ZU(51,clu+64)) S ret=ret_"network server activity"_clumsg_","
 if ret'="" s ret="Quiesce failed reason: "_$e(ret,1,*-1) d $zu(9,"",ret,1,2) i $d(^rOBJ("ZQuiesceFail")) d ^ZQuiesceFail
 Q ret
QUIESCEE s $zt="" d $zu(9,"","QUIESCE: "_$ze,(1>0),1) q -1 ;0
CluQuiet(switch,target,timeout)
 n flags,rc
 i $g(switch)-10,$g(switch)-13 ztrap "SWITCH"
 n targetmsg s target=$g(target)
 i target=1 s target=256,targetmsg=" on cluster slave members"
 e  i target=2 s target=512,targetmsg=" on cluster master"
 e  s target=512+256,targetmsg=" cluster wide"
 s flags=1+2+4+$s(switch=10:8,1:16)
 s rc=$$Quiesce(flags+target,$s(switch=10:"system activity",1:"update activity")_targetmsg,$g(timeout,10),'$g(QUIET,$g(QUIETLY)))
 i rc<0 ztrap "Abort"
 q rc
quietsw(switch,timeout) ;quiesce activities w/ timeout after setting switch 10 or 13
 n flags,rc
 i $g(switch)-10,$g(switch)-13 ztrap "SWITCH"
 s flags=1+2+4+$s(switch=10:8,1:16)
 i CLUBACKUP s flags=flags+128
 s rc=$$Quiesce(flags,"disk cleanup",$s($g(timeout)="":30,1:timeout),'$g(QUIET))
 i rc<0 ztrap "Abort"
 q rc
hibernate(switch,released,timeo) ;
 i +$g(released) d msgout($c(13,10)_"Switch "_switch_" is released.",NOFORCE)
 n hibtime s hibtime=$s(timeo>3:10,timeo>2:1,timeo>1:.1,timeo>0:.01,1:10)
 d msgout($c(13,10)_"Backup will hibernate for "_hibtime_" second(s) and try again."_$c(13,10)_"You may abort Backup via Ctrl-C. ",NOFORCE) 
 i hibtime<1 h hibtime
 e  n i f i=1:1:hibtime h 1 d msgout(".",NOFORCE)
 d msgout($c(13,10),NOFORCE)
 q
ENQ10 ;
 n t s t=$g(quietimeout,60) s:t>0 t=(t+9)\10 ;rounded up to 10 sec
 s $zt="ENQ10e"
 i CLUBACKUP d  q
 . f  q:$$CLU^SWSET(10,1,ALRDY10,$g(QUIETMASTERONLY))  s t=t-1 zt:'t "Abort" d hibernate(10,'ALRDY10,t)
 i ALRDY10 q:$$quietsw(10)  zt "Abort"
 f  S %SW=10,%VAL=1 D INT^SWSET  q:$$quietsw(10)  s t=t-1 zt:'t "Abort" d DEQ10,hibernate(10,1,t)
 Q
ENQ10e s $zt="" d DEQ10 ztrap $ze
DEQ10 ;
 i CLUBACKUP,$ZU(95,10,0)  ; Clear SW10 clusterwide
 i 'ALRDY10 s %SW=10,%VAL=0 D INT^SWSET
 Q
ENQ13 ;
 n t s t=$g(quietimeout,60) s:t>0 t=(t+9)\10 ;rounded up to 10 sec
 s $zt="ENQ13e"
 i CLUBACKUP d  q
 . f  q:$$CLU^SWSET(13,1,ALRDY13)  s t=t-1 zt:'t "Abort" d DEQ13,hibernate(13,'ALRDY13,t)
 i ALRDY13 q:$$quietsw(13)  zt "Abort"
 f  S %SW=13,%VAL=1 D INT^SWSET  q:$$quietsw(13)  s t=t-1 zt:'t "Abort" d DEQ13,hibernate(13,1,t)
 Q
ENQ13e s $zt="" d DEQ13 zq 1 g:$zt'="" @$zt q
DEQ13 ;
 i CLUBACKUP,$ZU(95,13,0)  ; Clear SW13 clusterwide
 i 'ALRDY13 s %SW=13,%VAL=0 D INT^SWSET
 Q
HOLDWD(dir,time,flag) ;suspend write daemon (dir may be passed as an array)
 n n
 i $zu(182,1,0) ;clear any remaining backup request
 f  q:'$zu(182,0)  h 1  ;wait until write daemon runs again
 i $d(dir)<10 d $zu(52,9,dir,1) d:$g(flag)=1 $zu(52,8,dir,0) d $zu(182,2,0,+$zu(49,dir)) s n=1 i 1
 e  s dir="" f n=0:1 s dir=$o(dir(dir)) q:dir=""  d $zu(52,9,dir,1) d:$g(flag)=1 $zu(52,8,dir,0) d $zu(182,2,n,+$zu(49,dir))
 i $zu(182,1,n,$g(time))  ;set number of databases to back up (and optional CP wait time)
 f  q:$zu(182,0)  h 1  ;wait until write daemon suspends
 q
FREEWD ;unsuspend write daemon
 i $zu(182,1,0)
 q
msgout(aaamess,flag) ;
         s flag=$g(flag,1) ; default to FORCE
         W *-1            ;Flush the input buffer 
         q:'$L(aaamess)   ; Avoid argumentless writes...
         i $g(logfile)'="" u logfile w aaamess
         u 0
         q:flag=3  ; 1 = FORCE, FORCE, 2 = NOFORCE, 3 = LOGONLY
         i '$G(INTERNAL,0)!('$G(NOINPUT,0)&(flag=1!'$G(QUIET,0))) w aaamess
         i $g(gui) D  
         . s return=$$IjcMsg^%Wprima("DI"_aaamess) ; Retval might =  cancel msg
         . i return="CANCEL" d  
         . . i $$IjcMsg^%Wprima("DI"_$c(13,10)_"Abort received!"_$c(13,10))
         . . zt "Abort"
         u 0 
         q
timestmp(flag) 
         n msg,%TS,%TN
         s msg="TIMESTAMP: "
         s %DN=+$H d INT^%DO
         s msg=msg_%DS
         s %TN=$P($h,",",2) d ^%TO
         s msg=msg_" "_%TS
         d msgout($c(13,10)_msg_$c(13,10))
         q
OSDEVICE(mdevice,new) ;osdevice + range check, pad input, strip output.
 s mdevice=+mdevice q:mdevice<47 ""  q:mdevice>62 ""
 i $d(new) s new=$$zpad(new,32)
 q $$zstrip($$osdevice(mdevice,.new))
osdevice(mdevice,new) ;"Raw" osdevice
 n adr,old,size,where,charsize
 s $ZT="osdeverr"
 s charsize=$$charsize^%Wprim() ; check size one char
 s size=32,adr=(mdevice-47)*(size*charsize)+$ZU(40,2,28),where=-2
 s old=$v(adr,where,-size_"w")
 i $d(new) v adr:where:-size_"w":new
 q old
osdeverr q ""
zstrip(x) ;Return x with ASCII NUL's removed
 q $tr(x,$c(0),"")
zpad(x,len) ;x, maybe truncated, NUL-padded to length len, one NUL guaranteed
 n zeroes
 s zeroes=$j("",len),zeroes=$tr(zeroes," ",$c(0)) ;String of len NUL's
 s x=$e(x,1,len-1) ;Silently truncate x if necessary
 s $e(zeroes,1,$l(x))=x
 q zeroes
ZU(A,B,C,D,E,F,G,H,I,J,K,L,M,N,P) ;so needn't change $$ZU's to $ZU's
 IF '$D(B) Q $ZU(A)
 IF '$D(C) Q $ZU(A,B)
 IF '$D(D) Q $ZU(A,B,C)
 IF '$D(E) Q $ZU(A,B,C,D)
 IF '$D(F) Q $ZU(A,B,C,D,E)
 IF '$D(G) Q $ZU(A,B,C,D,E,F)
 IF '$D(H) Q $ZU(A,B,C,D,E,F,G)
 IF '$D(I) Q $ZU(A,B,C,D,E,F,G,H)
 IF '$D(J) Q $ZU(A,B,C,D,E,F,G,H,I)
 IF '$D(K) Q $ZU(A,B,C,D,E,F,G,H,I,J)
 IF '$D(L) Q $ZU(A,B,C,D,E,F,G,H,I,J,K)
 IF '$D(M) Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L)
 IF '$D(N) Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L,M)
 IF '$D(P) Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
           Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L,M,N,P)
MORE Q
SWSET   do $SYSTEM.Util.SetSwitch(%SW,%VAL)
	quit
SET10   do $SYSTEM.Util.SetSwitch(10,1)
        quit
CLEAR10 do $SYSTEM.Util.SetSwitch(10,0) 
        quit
CHECK10() n res
	s res=$SYSTEM.Util.GetSwitch(10)
	if '+res quit 0  ; not owned
	if +$P(res,",",2)'=+$J quit 0  ; not owned by us
	quit 1  ; set and owned by us
  ;#endif $$$NEWINC  ; CFL284-

DBRTEXT^INT^1^67214,47330
DBRTEXT ;
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ;DBRTEXT.INC;
GO       K dbrtext
aborting d entry("aborting")
 ;;[Aborting restoration from this backup file]
abtdmt d entry("abtdmt")
 ;;[Aborting restoration of this directory and dismounting it]
 ;;
anymore0 d entry("anymore0")
 ;;Do you have any backups to restore?
anymore1 d entry("anymore1")
 ;;Do you have any more backups to restore?
ASKRES d entry("ASKRES")
 ;;Restore: 1. All directories
 ;;         2. Selected and/or renamed directories
 ;;         3. Display backup volume information
 ;;         4. Exit the restore program
ALREADY d entry("ALREADY")
 ;;Do you want to set switch 10 so that other processes will be
 ;;prevented from running during the restore?
MAYBE d entry("MAYBE")
 ;;NOTE: Some operations could cause switch 10 to be set for a few seconds.
 ;;      A warning message will be printed if this happens.
chnglist d entry("chnglist")
 ;;Do you want to change this list of directories?
confirmRestore d entry("confirmRestore")
 ;;Restore will overwrite the data in the old database. Confirm Restore?
CREATE d entry("CREATE")
 ;;You can retry opening it, create it, or abort the restoration
 ;;of this directory.
DIRNAM d entry("DIRNAM")
 ;;
 ;;For each database included in the backup file, you can:
 ;;
 ;; -- press RETURN to restore it to its original directory;
 ;; -- type X, then press RETURN to skip it and not restore it at all.
 ;; -- type a different directory name.  It will be restored to the directory
 ;;    you specify.  (If you specify a directory that already contains a 
 ;;    database, the data it contains will be lost).
 ;;
DUPLDIR d entry("DUPLDIR")
 ;;!Directory # was already specified
 ;;as the target of another restore operation
 ;;
 ;;
NotExist d entry("NotExist")
 ;;!Directory # does not exist
 ;;at the operating system level so a database cannot be stored there.
MakeLater d entry("MakeLater")
 ;;   You can continue and this check will be repeated when restoration
 ;;   to that directory begins, at which time you can choose to have it
 ;;   be created, or else you can select a different directory now.
 ;;Do you want to modify your selection of directory?
MakExist d entry("MakExist")
 ;;   You can have this utility make the directory and then create a
 ;;   database in it by responding "C" to the following question.
dirnexis d entry("dirnexis")
 ;;!Directory # does not contain a database
 ;;or it can't be accessed.
DIRREST0 d entry("DIRREST0")
 ;; You can continue the restoration of this directory, abort the
 ;; restoration of this directory, or abort this restoration session
 ;; altogether.  All of these choices will probably result in losing
 ;; data and maybe in database degradation.
 ;;Continue the restoration of this directory?
 ;;
DIRREST1 d entry("DIRREST1")
 ;; You can retry writing these blocks, skip these blocks and continue
 ;; restoring to this directory, abort the restoration of this
 ;; directory, or abort restoring this backup.  All but the choice of
 ;; retrying will result in losing data and maybe in database
 ;; degradation.
 ;;Retry these blocks?
DIRREST2 d entry("DIRREST2")
 ;; You can skip this block and continue the restoration of this
 ;; directory, abort the restoration of this directory, or abort this
 ;; restoration session altogether.  All of these choices will probably
 ;; result in losing data and maybe in database degradation.
 ;;Continue the restoration of this directory?
erbadrec d entry("erbadrec")
 ;;!Invalid backup data record read from device # for
 ;;database block # of directory #.
erbadlab d entry("erbadlab")
 ;;!Invalid backup label record read from device # following
 ;;directory #.
skip2lab d entry("skip2lab")
 ;; If you do not continue, the restoration of this backup will be
 ;; aborted.  If you do continue, you will have missed a directory
 ;; label block that will result in your missing the restore of a
 ;; portion of a directory.
 ;;
 ;;Continue?
endofvol d entry("endofvol")
 ;;!End of backup device # encountered prematurely while
 ;;reading directory #.
 ;;Aborting restoration.  Data may have been lost.  Database degradation
 ;;is likely.
errabort d entry("errabort")
 ;;
 ;;***ERROR OCCURRED: [#] -- Aborting restoration.
 ;;
errmrk d entry("errmrk")
 ;;Error marking directory # as the target of a restore.
 ;;# will not be restored.
 ;;
errmrk1 d entry("errmrk1")
 ;;Directory # was created, but an error occurred trying
 ;;to mark it as a restoration target.
 ;;
errmrk2 d entry("errmrk2")
 ;;Directory # is mirrored and cannot be the target of a restore.
 ;;# will not be restored.
 ;;
errcol d entry("errcol")
 ;;Cannot mount database in # because
 ;;its default collation is not available (see messages.log).
 ;;# will not be restored.
 ;;
errcol2 d entry("errcol2")
 ;;Cannot mount database in # because
 ;;its default collation is not available (see messages.log).
 ;;
 g ^DBRTEXT1
entry(fromtag) ;Scan lines starting at fromtag+1 and put in dbrtext(fromtag)
 n break,i,line,stop,tag,text
 s break=$c(13,10) ;Maybe not system-independent???
 f i=1:1 d  q:stop  s dbrtext(fromtag)=$g(dbrtext(fromtag))_break_text
 . s line=$text(@fromtag+i)
 . s tag=$p(line,";;"),text=$p(line,";;",2)
 . i $e(text)="!" s $e(text)=$c(7) ;Leading bang becomes bell
 . s stop=$$isblank(line)!$$nonblank(tag)
 q
isblank(line) q $tr(line," ","")=""
nonblank(line) q '$$isblank(line)

DBRTEXT1^INT^1^67214,47330
DBRTEXT1 ; CONTINUATION OF DBRTEXT ;$Change: 7440104 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ; Revision: $Id: //iris/2024.1.3/databases/sys/rtn/user/dbrtext1.mac#1 $
 ;
 ; Display text for Cache VAX restore. Store a good part of the
 ; display text in dbrtext to compact DBREST.
expand d entry("expand")
 ;;Expanding # from # to # maps
 ;;
expand2 d entry("expand2")
 ;;Expanding # from # MB to # MB
 ;;
expblk d entry("expblk")
 ;;Expanded final map of # from # to # blocks
 ;;
expmap d entry("expmap")
 ;;Expanding final map of #
 ;;
experr d entry("experr")
 ;;!An error occurred during database expansion!
 ;;
expnoblk d entry("expnoblk")
 ;;Warning: unable to expand final map of #
 ;;         only # blocks are allocated in that map
 ;;
getdev d entry("getdev")
 ;;(Type STOP to exit)
 ;;Device name:  #  =>  
GFINCRES d entry("GFINCRES")
 ;;Failed to clear GFINCRES flag for #
 ;;Directory will not be accessible until Cache is restarted
 ;;
JRNIN0 d entry("JRNIN0")
 ;;Restoring a directory restores the globals in it only up to the
 ;;date of the backup.  If you have been journaling, you can apply  
 ;;journal entries to restore any changes that have been made in the
 ;;globals since the backup was made.
 ;;
JRNIN1 d entry("JRNIN1")
 ;;What journal entries do you wish to apply?
 ;;
 ;;     1. All entries for the directories that you restored
 ;;     2. All entries for all directories
 ;;     3. Selected directories and globals
 ;;     4. No entries
 ;;
 ;;Apply: 1 => 
nodevnum d entry("nodevnum")
 ;;You specified M device number #.  M device numbers are inappropriate
 ;;here because backup and restore do IO directly via the operating system.
 ;;Your specification has been replaced with the name of the underlying
 ;;IO device, "#"
 ;;
outerr d entry("outerr")
 ;;!Output error on one or more contiguous blocks"
 ;;starting with block # while writing to directory #
 ;;
procall d entry("procall")
 ;;Proceed with restoring ALL directories
quisys d entry("quisys")
 ;;Waiting for system activity to finish...
restdeve d entry("restdeve")
 ;;!Input error on device # while reading directory #
 ;;
restlast d entry("restlast")
 ;;Last block successfully restored was #
 ;;
restnone d entry("restnone")
 ;;No blocks successfully restored for this directory
 ;;
restabtq d entry("restabtq")
 ;;The rest of this directory will be skipped.  Do you want to
 ;;continue processing this backup file?
restabty d entry("restabty")
 ;;[Terminating restoration from this backup file]
 ;;
restwont d entry("restwont")
 ;;!Directory # will not be restored
 ;;
rincmpat d entry("rincmpat")
 ;;!Target of restore # is incompatible with the input volume.
 ;;Some blocks in the target are unavailable, either because
 ;;       a) they are marked as BAD, or
 ;;       b) they are located in the nonexistent portion of a partial map.
 ;;Cannot restore to this target
 ;;
SKIPDIR d entry("SKIPDIR")
 ;;If you do not continue, the restoration of this backup will be
 ;;aborted.  If you do continue, there is a small chance that you
 ;;will have missed a directory label block that will result in
 ;;your missing the restore of a portion of a directory.]
 ;;
 ;;Continue?
skipblks d entry("skipblks")
 ;;Skip these blocks and continue restoring to this directory?
skipdir d entry("skipdir")
 ;;Skip this directory and continue restoring to other directories?
stchk0 d entry("stchk0")
 ;;# blocks restored in # seconds for this pass, # total restored.
 ;;
stchk1 d entry("stchk1")
 ;;Finished this pass of restoring #
 ;;
stchk2 d entry("stchk2")
 ;;We encountered a directory label record with a CRC error.
 ;;Only the filesize entry is questionable.
 ;;
stchk3 d entry("stchk3")
 ;;We got a read error but all the records passed crc validation.
 ;;Maybe they're all ok.  The blocks are:
 ;;
stchk4 d entry("stchk4")
 ;;Due to read errors, we skipped some blocks during the restore.
 ;;
stchk5 d entry("stchk5")
 ;;Blocks after # through # in directory # were skipped.
 ;;
stchk6 d entry("stchk6")
 ;;Blocks after # in # through # in directory # were skipped along
 ;;with at least one directory label record.
 ;;
stchk7 d entry("stchk7")
 ;;We encountered a block (#) with a CRC error.
 ;;
stchk8 d entry("stchk8")
 ;;We encountered a block (#) with a CRC error that was bad during the original copy.
stchk9 d entry("stchk9")
 ;;We are skipping it because we also get a disk read error trying to read it from disk.
 ;;
stchk10 d entry("stchk10")
 ;;We will restore it and also keep a copy of its former contents on disk
 ;;so that you can decide later which version you prefer, or merge the two.
 ;;
stchk11 d entry("stchk11")
 ;;Block size mismatch - the database block size from the backup is not
 ;;the same as that in the target. Aborting restore of this directory.
 ;;
stchk12 d entry("stchk12")
 ;;Problem detected in a 2kb sized file between the source and target bitmaps.
 ;;
stchk13 d entry("stchk13")
 ;;Target of restore (#) is cluster mounted
 ;;but it must be privately mounted.
 ;;
stchk14 d entry("stchk14")
 ;;Couldn't mount the directory to be restored (#).
 ;;
stchk15 d entry("stchk15")
 ;;We got a write error.
 ;;
stchk16 d entry("stchk16")
 ;;Unhandled error. Aborting restore.
 ;;
stchk17 d entry("stchk17")
 ;;***FINISHED RESTORE***
 ;;
stchk18 d entry("stchk18")
 ;;The restore is aborted.
 ;;
stchk19 d entry("stchk19")
 ;;Starting skip of #.
 ;;
stchk20 d entry("stchk20")
 ;;     skipped # blocks in # seconds.
 ;;
stchk21 d entry("stchk21")
 ;;Finished this pass of skipping #
 ;;
stchk22 d entry("stchk22")
 ;;![End of volume on device # while skipping directory #].
 ;;
stchk23 d entry("stchk23")
 ;;![Input error on device # while skipping directory #].
 ;;
stchk24 d entry("stchk24")
 ;;We are skipping it because its contents are totally invalid.
 ;;If we just reached the end of the current volume, this record is
 ;;duplicated at the beginning of the next volume and you need not
 ;;worry because no data loss will occur.
 ;;
title d entry("title")
 ;;                        Cache DBREST Utility
 ;;         Restore database directories from a backup archive
 ;;
volnover d entry("volnover")
 ;;This backup volume was created by an earlier version of Cache
 ;;
voldisver d entry("voldisver")
 ;;This backup volume was created by:
 ;;   #
 ;;
voldis14 d entry("voldis14")
 ;;The volume label contains:
 ;;   Volume number      #
 ;;   Volume backup      # # #
voldis68 d entry("voldis68")
 ;;   Previous backup    # # #
voldis9e d entry("voldis9e")
 ;;   Last FULL backup   # #
 ;;   Description        #
 ;;   Buffer Count       #
voldis13 d entry("voldis13")
 ;;   Mirror name        #
 ;;   Failover Member    #
voldis13b d entry("voldis13b")
 ;;   Async Member       #
whichfun d entry("whichfun")
 ;;?? Type the number of the function you want
 ;;
zu52err d entry("zu52err")
 ;;!zu52 error number #
 ;;After restoring the data in #, an error occurred trying to
 ;;attempting to change its size from # to #
 ;;
zu52e0 d entry("zu52e0")
 ;;Some space might not be available between maps
zu52e1 d entry("zu52e1")
 ;;Failed to allocate incremental backup space because
 ;;Incremental backup has been disabled for database" 
zu52e2 d entry("zu52e2")
 ;;Unable to mount database.  Database should not be used.
 ;;
 Q       ; END OF DBRTEXT1 main routine
entry(fromtag) ;Scan lines starting at fromtag+1 and put in dbrtext(fromtag)
 n break,i,line,stop,tag,text
 s break=$c(13,10) ;Maybe not system-independent???
 f i=1:1 d  q:stop  s dbrtext(fromtag)=$g(dbrtext(fromtag))_break_text
 . s line=$text(@fromtag+i)
 . s tag=$p(line,";;"),text=$p(line,";;",2)
 . i $e(text)="!" s $e(text)=$c(7) ;Leading bang becomes bell
 . s stop=$$isblank(line)!$$nonblank(tag)
 q
isblank(line) q $tr(line," ","")=""
nonblank(line) q '$$isblank(line)

DBSIZE^INT^1^67214,47330
DBSIZE ; Incremental Backup Size Estimation Utility
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 N QUIET,NOINPUT,INTERNAL,TYPE
 N TOTDBLKS,NUMDIRS,TOTMTBYTES,TOTMTBLKS,TOTFLBYTES,TOTFLBLKS,PREALBLKS
 S (QUIET,NOINPUT,INTERNAL)=0
 S (TOTDBLKS,NUMDIRS,TOTMTBYTES,TOTMTBLKS,TOTFLBYTES,TOTFLBLKS,PREALBLKS)=0
 ;  Call Point for INT tag.
TOP N logfile,FULL,PARTIAL,NOCHANGE,CLEAR,LINE,DIRNAM,DIR,OK
 N ibEOT,ibOfflin,ibDevFul,ibInErr,ibOutErr,ibNoIND,ibNoDAT,MaxPASS
 N FORCE,NOFORCE,TOTOVRHD,TOTSIZE,TEMP1,TEMP2,DBSIZE,BLKSIZ
 n BUWARNING
 n rc,cnt,list,i,del1,del2,db,dbname,msg
 ;
 ;  Initialize Variables
 ;
 n dlmlock,rc ;JO1991
 S (TOTOVRHD,TOTSIZE,BLKSIZ)=0,logfile=""
 D INITVARS^DBACK
 D msgouta("!,?15,""Incremental Backup Size Estimator"",!!",FORCE)
 ;
 ;  This utility cannot be run at the same time as DBACK because
 ;        it uses the database bitmaps.
 ;  NOTE: LOCK + and LOCK - are used because the internal tag may
 ;        some day be used by DBACK.
 ;
 s rc=$$getLock^DBACK(.dlmlock)
 if '+rc D  S TOTDBLKS=-1 Q
 . D msgouta("""Backup is currently running. "",!",FORCE)
 S $ZT="ERR^"_$ZN
 ;
 ;  Get the Type of Backup that will be performed.
 ;
TYPE I 'NOINPUT D GETTYP^DBACKA I TYPE="" do releaseLock^DBACK(.dlmlock) S TOTDBLKS=-1 Q
 I 'NOINPUT S TYPE=$S(TYPE["Full":FULL,TYPE["Cum":CUMINC,1:PARTIAL)
 q:'$$InitDirList^DBACKA(0)
 ;
 ;  Get the list of directories from the ^SYS global.
 ;
 S TEMP1=NOINPUT,TEMP2=INTERNAL S (NOINPUT,INTERNAL)=1
 D GETDIRS^DBACKA 
 S NOINPUT=TEMP1,INTERNAL=TEMP2
 ;
 ;  Process all the directories
 ;
 I 'DIRNAM D  Q
 . D msgouta("""No Directories Selected."",!",FORCE)
 . do releaseLock^DBACK(.dlmlock)
 . S TOTDBLKS=-1
 E  D
 . s LINE=$s(TYPE=FULL:" In-Use",1:"Modified")
 . d msgouta("!?57,"""_LINE_""",?67,""Block""",FORCE)
 . d msgouta("!?5,""Directory"",?58,""Blocks"",?68,""Size"",!!",FORCE)
 . ; Process all the directories read from the ^SYS global.
 . s DIR="" f  s DIR=$o(DIRNAM(DIR)) q:DIR=""  d
 . . s DBSIZE=$$ONEDIR(DIR,TYPE,.NUMDIRS,.BLKSIZ)
 . . s TOTDBLKS=TOTDBLKS+DBSIZE ; Sum database blocks
 . . s TOTSIZE=TOTSIZE+(DBSIZE*BLKSIZ) ; Sum 2KB backup blocks
 . . s TOTSIZE=TOTSIZE+3 ; Add overhead for labels for 3 passes
 s TOTSIZE=TOTSIZE+1 ; Overhead for journal marker record
 s TOTOVRHD=2  ; Media blocks for archive header and trailer
DONE ;
 ;  Cleanup and display total information
 ;
 do releaseLock^DBACK(.dlmlock)
 ;
 ;  Total Database Blocks
 D msgouta("?50,""--------------"",!",FORCE)
 D msgouta("?5,""Total number of database blocks: """,FORCE)
 D msgouta("?50,$J($FN("_TOTDBLKS_","","",0),14),!",FORCE)
 ;
 S TOTFLBLKS=$$OUTSIZE(TOTSIZE,TOTOVRHD,0),TOTFLBYTES=TOTFLBLKS*512
 D msgouta("!,""Total backup size, including overhead of volume and pass labels:"",!",FORCE)
 ;  Total for UNIX or other byte-stream-oriented file.
 D msgouta("!?5,""For a disk file:""",FORCE)
 D msgouta("!?10,""Number of 512-byte blocks:  """,FORCE)
 D msgouta("$FN("_TOTFLBLKS_","","",0),""  (""",FORCE)
 D msgouta("$FN("_TOTFLBYTES_","","",0),"" bytes)"",!",FORCE)
 If TOTFLBYTES'<536870912 D msgouta("?10,""Size in gigabytes: "",$FN("_(TOTFLBYTES/1073741824)_","","",4),!",FORCE)
 S PREALBLKS=TOTFLBLKS
 ;
 ;  Total for MagTape.
 S TOTMTBLKS=$$OUTSIZE(TOTSIZE,TOTOVRHD,1),TOTMTBYTES=TOTMTBLKS*58*1024
 D msgouta("!?5,""For magnetic media:""",FORCE)
 D msgouta("!?10,""Number of "_58_"KB blocks:  """,FORCE)
 D msgouta("$FN("_TOTMTBLKS_","","",0),""  (""",FORCE)
 D msgouta("$FN("_TOTMTBYTES_","","",0),"" bytes)"",!",FORCE)
 If TOTMTBYTES'<536870912 D msgouta("?10,""Size in gigabytes: "",$FN("_(TOTMTBYTES/1073741824)_","","",4),!",FORCE)
 Q
ERR ;
 S $ZT=""
 do releaseLock^DBACK(.dlmlock)
 ;  No matter how we got here we want to output the error message.
 ;    Let's not leave the user totally in the dark while using the
 ;    extrinsic function.
 S (INTERNAL,QUIET)=0 D msgouta("!,""[Error: "_$ZE_"]"",!",FORCE)
 S TOTDBLKS=-1
 Q
 ;
 ;**********
 ;  Extrinsic Function to return the total number of database blocks
 ;     that will be output to the file/tape for the TYPE of backup.
 ;        TYPE values:
 ;             1 = INCREMENTAL
 ;             2 = FULL
 ;             3 = CUMULATIVE INCREMENTAL
 ;     On Exit:
 ;        String Containing seven pieces separated by "^"
 ;           Piece 1:  Number of database blocks for backup
 ;                        (-1 if error during processing or invalid
 ;                        parameter)
 ;           Piece 2:  Number of directories to be backed up
 ;           Piece 3:  Number of bytes for magnetic media
 ;                        (not including inter-record gaps)
 ;           Piece 4:  Number of blocks for magnetic media
 ;           Piece 5:  Number of bytes for a disk file
 ;           Piece 6:  Number of 512-byte blocks for a disk file
 ;           Piece 7:  Pre-allocation estimate of disk file blocks
 ;                        (for use under OpenVMS)
 ;
 ;**********
INT(TYPE) 
 N QUIET,NOINPUT,INTERNAL
 N TOTDBLKS,NUMDIRS,TOTMTBYTES,TOTMTBLKS,TOTFLBYTES,TOTFLBLKS,PREALBLKS
 S (QUIET,NOINPUT,INTERNAL)=1
 S (TOTDBLKS,NUMDIRS,TOTMTBYTES,TOTMTBLKS,TOTFLBYTES,TOTFLBLKS,PREALBLKS)=0
 I (TYPE>3)!(TYPE<1) S TOTDBLKS=-1
 E  D TOP
 Q TOTDBLKS_"^"_NUMDIRS_"^"_TOTMTBYTES_"^"_TOTMTBLKS_"^"_TOTFLBYTES_"^"_TOTFLBLKS_"^"_PREALBLKS
 ;
 ;*****************************
 ;  Subroutines and Functions *
 ;*****************************
 ;**********
 ; ONEDIR() - Calculates and returns the raw number of blocks that
 ;       will be written to the backup device.  If messages are enabled
 ;       the results of the calculations will be displayed.
 ;       It also updates the counter NUMDIRS.
 ;**********
ONEDIR(DIR,TYPE,NUMDIRS,BLKSIZ)   ;LRS735
 N M,INC,IND,INE,INF,SIZE,RC
 S NUMDIRS=NUMDIRS+1
 D SetNames^DBACKA(DIR)
 D msgouta(""""_DIR_"""",FORCE)
 ;   Ensure that the scratch bitmap is clear.
 if TYPE=FULL {
 	S RC=$$INLOGOR(DIR,-1,0,3)
   	; Don't count the directory if we can't access its bitmaps.
   	I RC<0 {
	   S NUMDIRS=NUMDIRS-1
	   S SIZE=0
    } else {
	   S SIZE=RC
    }
 } else {
 	S RC=$$INLOGOR(DIR,2,1,0)
 	S RC=$$INLOGOR(DIR,1,2,0)
 	;   Based on the type of backup, INLOGOR the appropriate bitmap.
 	I TYPE=CUMINC {
	 	S RC=$$INLOGOR(DIR,0,2,0)
 	}
 	S RC=$$INLOGOR(DIR,3,2,0)
 	; Don't count the directory if we can't access its bitmaps.
 	I RC<0 S NUMDIRS=NUMDIRS-1
 	; Count the number of bits set in the scratch bitmap.
 	S SIZE=$$INLOGOR(DIR,2,2,3)
 	;   Check for errors.
 	I SIZE=-2 S SIZE=0 ; If bitmaps were not acessible, assume ZERO.
    ; clean up the backup bitmap so we don't include
    ; these blocks during the next backup
    S RC=$$INLOGOR(DIR,2,2,1)
 }
 i SIZE'<0 {
    ; Get the database block size in 2KB units
    s RC=$zu(49,DIR),BLKSIZ=$s(RC<0:0,1:$p(RC,",",2)\2048)
    s LINE=$FN(SIZE,",",0),M=64-$L(LINE)
    d msgouta($S($X<M:"?",1:"!?")_M_","""_LINE_"""",FORCE)
    d msgouta("$J(""("_(BLKSIZ*2)_"KB)"",8),!",FORCE)
 }
 i SIZE<0,SIZE'=-2 D msgouta("?60,"" [I/O Error]"",!",FORCE)
 Q $S(SIZE<0:0,1:SIZE)  ; Return the count.
 ;
 ;**********
 ; OUTSIZE()  - Return the file size based on BLOCKS number of 2KB
 ;               blocks being on the device type. The final result
 ;               is rounded up to the next hardware block boundary.
 ;         INPUT:
 ;               BLOCKS = Number of 2K blocks of backup
 ;               OVRHEAD = number of media blocks
 ;                         (archive header and trailer)
 ;               DEVTYP=0 RMS FILE.
 ;               DEVTYP=1 MAGTAPE.
 ;**********
OUTSIZE(BLOCKS,OVRHEAD,DEVTYP) ;
 n outdata,outblks
 s outdata=$s($g(DEVTYP):56,1:64) ; Not counting header & trailer
 s outblks=BLOCKS*2+outdata-1\outdata+OVRHEAD
 ; If the DEVTYP is disk, return number of 512-byte blocks
 ; If it is magtape, just return number of physical blocks
 q $s($g(DEVTYP):outblks,1:(outdata+2)*outblks*2)
 ;
 ;**********
 ; ALLOCQTY() - Calculates the Allocation quantity that will be
 ;              used based on the NUMBER of BLOCKS that the file
 ;              will be (including Header and Trailer information).
 ;**********
ALLOCQTY(BLOCKS) ;
 ; BLOCKS  - Calculated number of blocks for output file size.
 ; MAXEXP  - Maximum Expansion Quantity for the output file.
 ; SIZE    - Total for the maximum size of the backup file.
 ; EXPQTY  - Current expansion quantity
 ; CLUSTER - SYSGEN Parameter CLUSTER_SIZE. (Default of 3)
 ; FUDGE   - Fudge factor for expansion quantity.  The fudge factor
 ;   is the additional blocks allocated based on the current cluster
 ;   size when a file of size 4000 blocks is created.  A fudge factor
 ;   of 2 is used because the default for the SYSGEN parameter 
 ;   CLUSTER_SIZE is 3.  If cluster size is 4, the fudge factor would
 ;   be zero.
 N MAXEXP,EXPQTY,EXTRA,SIZE,FUDGE,INITEXPQTY,I,CLUSTER
 S (INITEXPQTY,EXPQTY)=4000,SIZE=0,MAXEXP=16000,CLUSTER=3
 S FUDGE=CLUSTER-(INITEXPQTY#CLUSTER)
 F I=1:1 D  Q:SIZE'<BLOCKS  
 . S SIZE=SIZE+EXPQTY
 . I I=1 S EXPQTY=EXPQTY+FUDGE
 . E  D
 .. S:((EXPQTY<MAXEXP)&('(I#4))) EXPQTY=EXPQTY*2
 .. S:((I=2)&(BLOCKS>INITEXPQTY)) SIZE=SIZE+FUDGE
 Q SIZE
 ;
INLOGOR(DIR,SOURCE,TARGET,DISPOSE) ;Adapter, present same i'face for VAX & UX
 n rc
 try {
   s rc=$ZU(31,DIR,SOURCE,TARGET,DISPOSE)
 } catch {
   s rc=-1_","_$ze
   s $ze=""
 }
 q rc
FILENORM(NAME) ;Return normalized version of NAME
 S OK=1,$ZT="FNERR"
 N MTDEV,DIR S MTDEV=$$OSDEVICE(NAME) I MTDEV'="" S ISREG=0 Q NAME
 i ($zversion(1)=2),$E(NAME,1,2)="\\" S L=$$CheckForTape(NAME) I L'="" S ISREG=0 Q L
 i ($zversion(1)=2) S L=$L(NAME,"\"),DIR=$P(NAME,"\",1,L-1)
 i ($zversion(1)=2) IF L>1 S DIR=DIR_"\"
 i ($zversion(1)=2) S NAME=$ZU(12,DIR)_$P(NAME,"\",L,L),ISREG=$ZU(140,7,NAME),ISREG=$S(ISREG>0:1,ISREG=-2:1,1:0) Q NAME
 i ($zversion(1)=3) S L=$L(NAME,"/"),DIR=$P(NAME,"/",1,L-1)
 i ($zversion(1)=3) IF L>1 S DIR=DIR_"/"
 i ($zversion(1)=3) S NAME=$ZU(12,DIR)_$P(NAME,"/",L,L),ISREG=$ZU(140,7,NAME),ISREG=$S(ISREG=-2:1,ISREG/32768#2:1,1:0) Q NAME
FNERR S OK=0,ERRMSG="Not a valid device name." Q
CheckForTape(NAME)
 S NAME=$ZCVT(NAME,"U")
 N I,TAPE
 For I=47:1:62 s TAPE=$$OSDEVICE(I) I NAME=$ZCVT(TAPE,"U") S NAME=I Q
 I NAME?2N Q NAME
 I NAME?1"\\.\TAPE"1N Q NAME
 Q ""
TQUIWRITE(verbose) q $$QUIESCE(1,"buffer activity",10,verbose)
TQUIGC(verbose) q $$QUIESCE(2,"garbage collection",10,verbose)
TQUIDB(verbose) q $$QUIESCE(4,"database expansion",10,verbose)
TQUIGLO(verbose) q $$QUIESCE(8,"global activity",10,verbose)
TQUIGLOUPD(verbose) q $$QUIESCE(16,"global updates",10,verbose)
TQUINET(verbose) q $$QUIESCE(32,"network activity",10,verbose)
TQUIDISK(verbose) q $$QUIESCE(1+2,"disk activity",10,verbose)
TQUIUPD(verbose) q $$QUIESCE(1+2+4+16,"update activity",10,verbose)
TQUISYS(verbose) q $$QUIESCE(1+2+4+8,"system activity",10,verbose)
QUIESCE(bits,text,retries,verbose,intv) ;
 s verbose=+$g(verbose),retries=+$g(retries,-1),intv=+$g(intv,1)
 q ($$Quiesce(bits,text,retries,verbose,intv)>0)
Quiesce(bits,text,retries,verbose,intv) ;
 n noWDbits
 s $zt="QUIESCEE"
 q:$zu(51,bits) 1 ;double checking $ZU(51) is no longer necessary
 s verbose=+$g(verbose),retries=+$g(retries,-1),intv=+$g(intv,1)
 d msgout($c(13,10)_"WARNING: Switch is set and may affect production for up to "_(retries*intv)_" seconds."_$c(13,10)_"Waiting for "_text_" to finish...",NOFORCE)
 f  q:'retries  h intv q:$zu(51,bits)  s retries=retries-1 i retries#5=0 d msgout(".",NOFORCE)
 s noWDbits=1
 s:$s($S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0):''$zu(59,0),1:0) noWDbits=noWDbits+2
 s noWDbits=$zboolean(bits,noWDbits,2)  ;2 = x & ~ y
 if '$ZU(51,bits),bits'=1,$zboolean(bits,1,1),$zu(51,noWDbits) {
	 d msgout($c(13,10)_"System is idle except WD is still running."_$c(13,10)_"     Waiting up to 2 minutes for WD to finish",NOFORCE)
	 f i=1:1:120 q:$ZU(51,bits)  h 1 if i#5=0 d msgout(".",NOFORCE)
	 if $ZU(51,bits) s retries=1 ;signal success
 }
 d msgout($s(retries:" ready.",1:" abort. "_$$quiescefailmsg(bits))_$c(13,10),NOFORCE)
 q retries
quiescefailmsg(bits)
 N ret,clu,clumsg s ret="",clu=$zb(bits,512+256+128,1),clumsg=""
 if $zb(clu,128,1)||($zb(clu,(256+512),1)=(256+512)) s clu=128,clumsg=" (cluster wide)"
 if $zb(clu,512,1) s clumsg=" (cluster master only)"
 if $zb(clu,256,1) s clumsg=" (cluster slaves only)"
 if $zb(bits,1,1)&&('$ZU(51,clu+1)) S ret=ret_"write daemon"_clumsg_","
 if $zb(bits,2,1)&&('$ZU(51,clu+2)) S ret=ret_"garbage collector"_clumsg_"," 
 if $zb(bits,4,1)&&('$ZU(51,clu+4)) S ret=ret_"file expander"_clumsg_","
 if $zb(bits,8,1)&&('$ZU(51,clu+8)) S ret=ret_"global reference"_clumsg_","
 if $zb(bits,16,1)&&('$ZU(51,clu+16)) S ret=ret_"global update"_clumsg_","
 if $zb(bits,32,1)&&('$ZU(51,clu+32)) S ret=ret_"client-side network connections"_clumsg_","
 if $zb(bits,64,1)&&('$ZU(51,clu+64)) S ret=ret_"network server activity"_clumsg_","
 if ret'="" s ret="Quiesce failed reason: "_$e(ret,1,*-1) d $zu(9,"",ret,1,2) i $d(^rOBJ("ZQuiesceFail")) d ^ZQuiesceFail
 Q ret
QUIESCEE s $zt="" d $zu(9,"","QUIESCE: "_$ze,(1>0),1) q -1 ;0
CluQuiet(switch,target,timeout)
 n flags,rc
 i $g(switch)-10,$g(switch)-13 ztrap "SWITCH"
 n targetmsg s target=$g(target)
 i target=1 s target=256,targetmsg=" on cluster slave members"
 e  i target=2 s target=512,targetmsg=" on cluster master"
 e  s target=512+256,targetmsg=" cluster wide"
 s flags=1+2+4+$s(switch=10:8,1:16)
 s rc=$$Quiesce(flags+target,$s(switch=10:"system activity",1:"update activity")_targetmsg,$g(timeout,10),'$g(QUIET,$g(QUIETLY)))
 i rc<0 ztrap "Abort"
 q rc
quietsw(switch,timeout) ;quiesce activities w/ timeout after setting switch 10 or 13
 n flags,rc
 i $g(switch)-10,$g(switch)-13 ztrap "SWITCH"
 s flags=1+2+4+$s(switch=10:8,1:16)
 i CLUBACKUP s flags=flags+128
 s rc=$$Quiesce(flags,"disk cleanup",$s($g(timeout)="":30,1:timeout),'$g(QUIET))
 i rc<0 ztrap "Abort"
 q rc
hibernate(switch,released,timeo) ;
 i +$g(released) d msgout($c(13,10)_"Switch "_switch_" is released.",NOFORCE)
 n hibtime s hibtime=$s(timeo>3:10,timeo>2:1,timeo>1:.1,timeo>0:.01,1:10)
 d msgout($c(13,10)_"Backup will hibernate for "_hibtime_" second(s) and try again."_$c(13,10)_"You may abort Backup via Ctrl-C. ",NOFORCE) 
 i hibtime<1 h hibtime
 e  n i f i=1:1:hibtime h 1 d msgout(".",NOFORCE)
 d msgout($c(13,10),NOFORCE)
 q
ENQ10 ;
 n t s t=$g(quietimeout,60) s:t>0 t=(t+9)\10 ;rounded up to 10 sec
 s $zt="ENQ10e"
 i CLUBACKUP d  q
 . f  q:$$CLU^SWSET(10,1,ALRDY10,$g(QUIETMASTERONLY))  s t=t-1 zt:'t "Abort" d hibernate(10,'ALRDY10,t)
 i ALRDY10 q:$$quietsw(10)  zt "Abort"
 f  S %SW=10,%VAL=1 D INT^SWSET  q:$$quietsw(10)  s t=t-1 zt:'t "Abort" d DEQ10,hibernate(10,1,t)
 Q
ENQ10e s $zt="" d DEQ10 ztrap $ze
DEQ10 ;
 i CLUBACKUP,$ZU(95,10,0)  ; Clear SW10 clusterwide
 i 'ALRDY10 s %SW=10,%VAL=0 D INT^SWSET
 Q
ENQ13 ;
 n t s t=$g(quietimeout,60) s:t>0 t=(t+9)\10 ;rounded up to 10 sec
 s $zt="ENQ13e"
 i CLUBACKUP d  q
 . f  q:$$CLU^SWSET(13,1,ALRDY13)  s t=t-1 zt:'t "Abort" d DEQ13,hibernate(13,'ALRDY13,t)
 i ALRDY13 q:$$quietsw(13)  zt "Abort"
 f  S %SW=13,%VAL=1 D INT^SWSET  q:$$quietsw(13)  s t=t-1 zt:'t "Abort" d DEQ13,hibernate(13,1,t)
 Q
ENQ13e s $zt="" d DEQ13 zq 1 g:$zt'="" @$zt q
DEQ13 ;
 i CLUBACKUP,$ZU(95,13,0)  ; Clear SW13 clusterwide
 i 'ALRDY13 s %SW=13,%VAL=0 D INT^SWSET
 Q
HOLDWD(dir,time,flag) ;suspend write daemon (dir may be passed as an array)
 n n
 i $zu(182,1,0) ;clear any remaining backup request
 f  q:'$zu(182,0)  h 1  ;wait until write daemon runs again
 i $d(dir)<10 d $zu(52,9,dir,1) d:$g(flag)=1 $zu(52,8,dir,0) d $zu(182,2,0,+$zu(49,dir)) s n=1 i 1
 e  s dir="" f n=0:1 s dir=$o(dir(dir)) q:dir=""  d $zu(52,9,dir,1) d:$g(flag)=1 $zu(52,8,dir,0) d $zu(182,2,n,+$zu(49,dir))
 i $zu(182,1,n,$g(time))  ;set number of databases to back up (and optional CP wait time)
 f  q:$zu(182,0)  h 1  ;wait until write daemon suspends
 q
FREEWD ;unsuspend write daemon
 i $zu(182,1,0)
 q
msgout(aaamess,flag) ;
         s flag=$g(flag,1) ; default to FORCE
         W *-1            ;Flush the input buffer 
         q:'$L(aaamess)   ; Avoid argumentless writes...
         i $g(logfile)'="" u logfile w aaamess
         u 0
         q:flag=3  ; 1 = FORCE, FORCE, 2 = NOFORCE, 3 = LOGONLY
         i '$G(INTERNAL,0)!('$G(NOINPUT,0)&(flag=1!'$G(QUIET,0))) w aaamess
         i $g(gui) D  
         . s return=$$IjcMsg^%Wprima("DI"_aaamess) ; Retval might =  cancel msg
         . i return="CANCEL" d  
         . . i $$IjcMsg^%Wprima("DI"_$c(13,10)_"Abort received!"_$c(13,10))
         . . zt "Abort"
         u 0 
         q
msgouta(aaamess,flag) ;
         s flag=$g(flag,1) ; default to FORCE
         W *-1            ;Flush the input buffer
         q:'$L(aaamess)   ; Avoid argumentless writes...
         i $g(logfile)'="" u logfile w @aaamess
         u 0
         q:flag=3  ; 1 = FORCE, FORCE, 2 = NOFORCE, 3 = LOGONLY
         i '$G(INTERNAL,0)!('$G(NOINPUT,0)&(flag=1!'$G(QUIET,0))) w @aaamess
         i $g(gui) D  
         . s return=$$IjcMsg^%Wprima("DI"_aaamess) ; Retval might =  cancel msg
         . i return="CANCEL" d  
         . . i $$IjcMsg^%Wprima("DI"_$c(13,10)_"Abort received!"_$c(13,10))
         . . zt "Abort"
         u 0 
         q
timestmp(flag) 
         n msg,%TS,%TN
         s msg="TIMESTAMP: "
         s %DN=+$H d INT^%DO
         s msg=msg_%DS
         s %TN=$P($h,",",2) d ^%TO
         s msg=msg_" "_%TS
         d msgout($c(13,10)_msg_$c(13,10))
         q
OSDEVICE(mdevice,new) ;osdevice + range check, pad input, strip output.
 s mdevice=+mdevice q:mdevice<47 ""  q:mdevice>62 ""
 i $d(new) s new=$$zpad(new,32)
 q $$zstrip($$osdevice(mdevice,.new))
osdevice(mdevice,new) ;"Raw" osdevice
 n adr,old,size,where,charsize
 s $ZT="osdeverr"
 s charsize=$$charsize^%Wprim() ; check size one char
 s size=32,adr=(mdevice-47)*(size*charsize)+$ZU(40,2,28),where=-2
 s old=$v(adr,where,-size_"w")
 i $d(new) v adr:where:-size_"w":new
 q old
osdeverr q ""
zstrip(x) ;Return x with ASCII NUL's removed
 q $tr(x,$c(0),"")
zpad(x,len) ;x, maybe truncated, NUL-padded to length len, one NUL guaranteed
 n zeroes
 s zeroes=$j("",len),zeroes=$tr(zeroes," ",$c(0)) ;String of len NUL's
 s x=$e(x,1,len-1) ;Silently truncate x if necessary
 s $e(zeroes,1,$l(x))=x
 q zeroes
ZU(A,B,C,D,E,F,G,H,I,J,K,L,M,N,P) ;so needn't change $$ZU's to $ZU's
 IF '$D(B) Q $ZU(A)
 IF '$D(C) Q $ZU(A,B)
 IF '$D(D) Q $ZU(A,B,C)
 IF '$D(E) Q $ZU(A,B,C,D)
 IF '$D(F) Q $ZU(A,B,C,D,E)
 IF '$D(G) Q $ZU(A,B,C,D,E,F)
 IF '$D(H) Q $ZU(A,B,C,D,E,F,G)
 IF '$D(I) Q $ZU(A,B,C,D,E,F,G,H)
 IF '$D(J) Q $ZU(A,B,C,D,E,F,G,H,I)
 IF '$D(K) Q $ZU(A,B,C,D,E,F,G,H,I,J)
 IF '$D(L) Q $ZU(A,B,C,D,E,F,G,H,I,J,K)
 IF '$D(M) Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L)
 IF '$D(N) Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L,M)
 IF '$D(P) Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
           Q $ZU(A,B,C,D,E,F,G,H,I,J,K,L,M,N,P)
MORE Q

DISMOUNT^INT^1^67214,47330
DISMOUNT ;(KSO,PK) GET USERS TO CLOSE GLOBAL FILES
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 Write !,"This utility is deprecated in favor of ^DATABASE"
 Do DISMOUNT^DATABASE() q  

DMREPAIR^INT^1^67214,47330
DMREPAIR ; API for database repair ;$Change: 7440104 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	; Revision: $Id: //iris/2024.1.3/databases/sys/rtn/diagnostic/dmrepair.mac#1 $
ShowMessage(sc,device) [] PRIVATE {
    Do DecomposeStatus^%SYS.DATABASE(sc,.msglist,0,"")
    Do wrtmsg($C(13,10),device)
    For i=1:1:msglist {	Do wrtmsg(msglist(i)_$C(13,10),device) }
}
wrtmsg(msg,device) [] PRIVATE {
    Quit:'$L(msg)  ; Avoid argumentless writes...
    If device=-1 { Do $zu(9,"",msg,0,0) Quit }
    If $g(%UI,"CHUI")="CHUI" { Use device Write msg Quit }
    Do:$$IjcMsg^%Wprima("DI"_msg)="CANCEL"  ; Return value could be cancel message 
    . i $$IjcMsg^%Wprima("DI"_$C(13,10)_"Abort received!"_$C(13,10))
    . zt "Abort"
}
 q
ParseMapBlock(dir,blk,sum,mapnum,type,bad,incrfile,incrver) [] PUBLIC
{
    Set $Ztrap="errParseMapBlock"
    Quit:blk<1||(blk\1'=blk) $$Error^%apiOBJ(6075,blk)
    Set info=$zu(49,dir)
    Quit:(+info)<-1 $$Error^%apiOBJ(184)
    Quit:'$Piece(info,",",21) $$Error^%apiOBJ(344)
    Open 63:"^^"_dir
    View blk
    If $v($Zutil(40,32,1),0,1)'=$Case(1,0:170,:16) {
	Close 63
	Quit $$Error^%apiOBJ(342,blk)
    }
    Set sum=$View($zu(40,32,10),0,4)
    Set mapnum=$view($zu(40,0,47),0,4)
    Set type=$c($view($zu(40,0,44),0,1))
    Set bad=$view($zu(40,0,46),0,1)
    Set incrfile=$view($zu(40,0,45),0,1)
    Set incrver=$view($zu(40,0,48),0,4)
    Close 63
    Quit 1
errParseMapBlock
    Close 63
    Set $Ztrap=""
    Quit:$Zerror["<NOTOPEN>" $$Error^%apiOBJ(184)
    Quit $$Error^%apiOBJ(5002,$Zerror)
}
ParseRepairBlock(dir,blk,blockvar,offset,ref,refprn,val,ccc,len,pad,sub,long,info,N,blocktype,link,bigcount,pntlen,nextpntlen,nextpntval,nextpntoff,pntref,nextpntref,incver,collate,gartree) [] PUBLIC
{
    Set $Ztrap="errParse1"
    Set N=0
    Kill blocktype,link,bigcount,pntlen,nextpntlen,nextpntval,nextpntoff,pntref,nextpntref,incver,collate,gartree
    Set blksiz=$Piece($zu(49,dir),",",2)
    Quit:blksiz="" $$Error^%apiOBJ(184)
    Quit:blksiz=2048 $$Error^%apiOBJ(344)
    Open 63:"^^"_dir
    If '$Data(blockvar) {
    	Quit:(blk<1)||(blk\1'=blk) $$Error^%apiOBJ(6075,blk)
        View blk
    } Else {
	    If $Length(blockvar)=blksiz {
			View 0:0:-blksiz:blockvar
    	} Else {
			Close 63
			Quit $$Error^%apiOBJ(331,$Length(blockvar))
    	} 
    }
    Quit $$ParseRepairViewBuf(dir,.offset,.ref,.refprn,.val,.ccc,.len,.pad,.sub,.long,.info,.N,.blocktype,.link,.bigcount,.pntlen,.nextpntlen,.nextpntval,.nextpntoff,.pntref,.nextpntref,.incver,.collate,.gartree)
errParse1 ;
    Set $Ztrap=""
    Quit:$Zerror["<NOTOPEN>" $$Error^%apiOBJ(184)
    Quit $$Error^%apiOBJ(5002,$Zerror)
}
ParseRepairViewBuf(dir,offset,ref,refprn,val,ccc,len,pad,sub,long,info,N,blocktype,link,bigcount,pntlen,nextpntlen,nextpntval,nextpntoff,pntref,nextpntref,incver,collate,gartree) [] PUBLIC
{
	Set $Ztrap="err"
	Set N=0,allnodesparsed=0
	Kill blocktype,link,bigcount,pntlen,nextpntlen,nextpntval,nextpntoff,pntref,nextpntref,incver,collate,gartree
	Set blksiz=$Piece($zu(49,dir),",",2) 
	Quit:blksiz=2048 $$Error^%apiOBJ(344)
	Set link=$v($Zutil(40,32,4),0,4)
	Set blocktype=$v($Zutil(40,32,1),0,1)
	Quit:$$getType(blocktype)=24 $$Error^%apiOBJ(332)
	Quit:$$getType(blocktype)=17 $$Error^%apiOBJ(364)
	If $Zboolean(+blocktype,32,1) {
		If '$$IsTypeLegal(blocktype-32) {
			Set rc=$$Error^%apiOBJ(195,$$getType(blocktype))
			Goto errorrc
		}
		Set blocktype=blocktype-32
		View $Zutil(40,32,1):0:1:blocktype
		Set gartree=1
	} Else {
		Set gartree=0
		If '$$IsTypeLegal(blocktype) {
			Set rc=$$Error^%apiOBJ(195,blocktype)
			Goto errorrc
		}
	}
	Set OFF=$s($d(offset):offset,1:$v($zu(40,32,0),0,4)+$zu(40,32,10))
	Set incver=$View($Zutil(40,32,5),0,4)
	Set collate=$v($zu(40,32,2),0,1)
	If (blocktype=8)!(blocktype=9) {  ;JO2150
		Set bigcount=$View($zu(40,32,6),0,4)
		Set pntlen=$View($Zutil(40,32,3),0,2)
		Set nextpntlen=$View($Zutil(40,32,8),0,2)
		Set nextpntval=$View($Zutil(40,32,9),0,1)
		Set nextpntoff=$View($Zutil(40,32,7),0,1)
		Set rc=$$GetNodeReferences(0,.internal,.printable)
		If ('rc) {
			Set pntreferr=$$EmbedStatus^%apiOBJ($$Error^%apiOBJ(219),rc)
		} Else {
			Set pntref("internal")=internal
			Set pntref("printable")=printable
		}
	}
	Set offset=OFF 
	Set:OFF>blksiz OFF=blksiz
	Set off=$zu(40,32,10)
	If blocktype'=9,blocktype'=13 {
		For N=1:1 {
			Set X=$V(N-1*2+1,-6)
			Quit:X=""
			Set rc=$$GetNodeReferences(N-1*2+1,.internal,.printable)
			Goto:('rc) errorrc
			Set ref(N)=internal
			Set refprn(N)=printable
			Set val(N)=$V(N-1*2+2,-6)
			Set A=off
			Set info(N)=$v(A,0,4)
			Set info=$zu(167,0,'(blocktype=8 || (blocktype=9) || (blocktype=12) || (blocktype=24)),info(N))
			Set A=off+4
			Set sub(N)=$p(info,"^",2)
			Set ccc(N)=$p(info,"^",3)
			Set len(N)=$p(info,"^",4)
			Set pad(N)=$p(info,"^",5)
			Set long(N)=$p(info,"^",6)
			Set off=off+len(N)
		}
		Set N=N-1
    } Else {
		Set prev=""
		While off<OFF {
			Set A=off
			Set rawinfo=$v(A,0,4)
			Set info=$zu(167,0,0,rawinfo)
			Set A=off+4 ;string^sub^ccc^len^pad 
			Set sub=$p(info,"^",2)
			Set ccc=$p(info,"^",3)
			Set len=$p(info,"^",4)
			Set pad=$p(info,"^",5)
			Set S=$e(prev,1,ccc)
			Set end=A+sub-1
			For A=A:1:end { Set S=S_$C($V(A,0)) }
			Set prev=S
			Set N=N+1,ref(N)=S,refprn(N)="^"_S
			Set val(N)=$v(N*2,-6)
			Set len(N)=len
			Set info(N)=rawinfo
			Set pad(N)=pad
			Set ccc(N)=ccc
			Set sub(N)=sub
			Set long(N)=0
			Set off=off+len
		}
	}
	Set allnodesparsed=1
	If (blocktype=8)!(blocktype=9) {
		Set rc=$$GetNodeReferences(-1,.internal,.printable)
		Goto:('rc) errorrc
		Set nextpntref("internal")=internal
		Set nextpntref("printable")=printable
		If $v($Zutil(40,32,4),0,4),nextpntlen,(nextpntoff#2) {
			Set storednextoff=$Case(blksiz,2048:2036,:(blksiz-$zu(40,32,10)))-nextpntlen
			Set storednextoff=(storednextoff\4)*4
			Set storednext=$View(storednextoff+$zu(40,32,10),0,-nextpntlen)
			If storednext'=nextpntref("internal") {
				Set nextpntoff=-1_","_storednext
			}
		}
	}
	Set nextpntrefparsed=1
	Close 63
	Quit:$Data(pntreferr) pntreferr
	Quit 1 
err
	Set $Ztrap=""
	If $Zerror["<NOTOPEN>" {
		Set rc=$$Error^%apiOBJ(184)
	} Else {
		Set rc=$$Error^%apiOBJ(5002,$Zerror)
	}
errorrc
	Set $Ztrap=""
	If $g(N) && '$g(allnodesparsed) {
		Set N=N-1
		Set rc=$$EmbedStatus^%apiOBJ($$Error^%apiOBJ(218),rc)
		Set:$Data(pntreferr) rc=$select(+pntreferr:rc,1:$$AppendStatus^%occSystem(pntreferr,rc))
	} ElseIf $g(allnodesparsed) && '$g(nextpntrefparsed) {
		Set rc=$$EmbedStatus^%apiOBJ($$Error^%apiOBJ(220),rc)
		Set:$Data(pntreferr) rc=$select(+pntreferr:rc,1:$$AppendStatus^%occSystem(pntreferr,rc))
	}
	Close 63
	Quit rc
}
DeleteNodeInRepairBlock(dir,blk,node,num,ref,refprn,val,ccc,len,pad,sub,long,info,OFF,bigcount) [] PUBLIC
{
    Quit:(blk<1)||(blk\1'=blk) $$Error^%apiOBJ(6075,blk)
    Set blksiz=$Piece($zu(49,dir),",",2) 
    Quit:blksiz="" $$Error^%apiOBJ(184)
    Quit:blksiz=2048 $$Error^%apiOBJ(344)
    Open 63:"^^"_dir
    View blk
    Set type=$v($Zutil(40,32,1),0,1)
 i type=8!(type=12) s prefix=$A(val(node)) d   
 . i ($case(prefix,3:1,5:1,7:1,13:1,:0)) Do 
 . . s numblks=$Piece(val(node),",",2)
 . . Set bigcount=bigcount-1
 . . View $zu(40,32,6):0:4:bigcount
 . i prefix=6 s cmplen=$zu(153,$e(val(node),2,$l(val(node))))
 . s OFF=OFF-len(node)
 F I=node:1:num-1 DO
 . S ref(I)=ref(I+1),val(I)=val(I+1)
 . S refprn(I)=refprn(I+1)
 . i I=node d  ;Adjust the next node after the deleted node if there is one
 . . s info(I)=$zu(167,1,'(type=8 || (type=9) || (type=12) || (type=24)),info(I),info(I+1))
 . . s newinfo=$zu(167,0,'(type=8 || (type=9) || (type=12) || (type=24)),info(I))
 . . s len(I)=$p(newinfo,"^",4),pad(I)=$p(newinfo,"^",5),ccc(I)=$p(newinfo,"^",3),sub(I)=$p(newinfo,"^",2)
 . e  d  
 . . s len(I)=len(I+1)
 . . s info(I)=info(I+1)
 . . s pad(I)=pad(I+1)
 . . s ccc(I)=ccc(I+1)
 . . s sub(I)=sub(I+1)
 K val(num),ref(num),refprn(num),len(num),pad(num),sub(num),ccc(num),long(num),info(num) S num=num-1
 Set OFF=0
 For i=1:1:num Set OFF=OFF+len(i)
 v $zu(40,32,0):0:4:OFF
 Set OFF=OFF+$zu(40,32,10)
 s sc=1_$e($$Error^%apiOBJ(193),2,*)
 If node=1 && (type'=1) {
	if '((type=9) && (blk=3)) {   ;JO2438
       Set sc=$select(+sc:1_$e($$Error^%apiOBJ(194),2,*),1:$$AppendStatus^%occSystem(sc,1_$e($$Error^%apiOBJ(194),2,*)))
       Set sc=$select(+sc:1_$e($$Error^%apiOBJ(188),2,*),1:$$AppendStatus^%occSystem(sc,1_$e($$Error^%apiOBJ(188),2,*)))
	}
 }
 Quit sc
}
InsertNodeInRepairBlock(dir,blk,newref,insref,insval,num,ref,refprn,val,ccc,len,pad,sub,long,info,OFF,nodenum) [] PUBLIC
{
    Quit:(blk<1)||(blk\1'=blk) $$Error^%apiOBJ(6075,blk)
    Set blksiz=$Piece($zu(49,dir),",",2)
    Quit:blksiz="" $$Error^%apiOBJ(184)
    Quit:blksiz=2048 $$Error^%apiOBJ(344)
    Set sc=1
    Open 63:"^^"_dir
    View blk
    Set type=$v($Zutil(40,32,1),0,1)
 S lastccc=0,Z=0,POP=0
 F I=1:1:num S A=ref(I) G exists:A=insref d trackccc G insert:POP
 ; next 2 lines only if node is at beginning or end 
 i 'num s I=0
 s I=I+1,CON=0
 ;
insert Set nodenum=I If type=9 Do  
 . s newsub=$l(insref)-(Z-CON)
 . s newlen=newsub+11
 . s newpad=0,newlen=newlen+4 
 . i newlen#4 s newpad=4-(newlen#4),newlen=newlen+newpad
 . s newinfo=$zu(167,3,0,newlen,newsub,Z-CON,newpad,1)
 Else  i (type=8 || (type=9) || (type=12) || (type=24)) d  
 . s cmplen=$zu(153,insval)
 . i cmplen,cmplen<($l(insval)*2) s insval=$c(6)_insval  ;compact unicode
 . e  i cmplen s insval=$c(4)_insval   ; unicode
 . e  s insval=$c(0)_insval ; string
 . s newsub=$l(insref)-(Z-CON)
 . s newlen=newsub+$Case(cmplen,0:$l(insval)-1,:$Case($Ascii(insval),4:(2*$l(insval))-1,:cmplen+1))
 . s newpad=0,newlen=newlen+4 
 . i newlen#4 s newpad=4-(newlen#4),newlen=newlen+newpad
 . s newinfo=$zu(167,3,0,newlen,newsub,Z-CON,newpad,$Case(cmplen,0:1,:0))
 Else  Do  
 . Set blknum=$Piece(insval,",",2),insertlong=$Piece(insval,",",1)
 . Set newsub=$Length(insref)-(Z-CON)
 . Set ptrtype=$Case($Length(insref)>53,1:1,:2)
 . Set extracount=$Zutil(167,$Case(ptrtype,1:5,:4),0,blknum)
 . Set newpad=0,newlen=newsub+4+extracount
 . If newlen#4 Set newpad=4-(newlen#4),newlen=newlen+newpad
 . If ptrtype=1 Set newinfo=$zu(167,3,1,newlen,newsub,Z-CON,newpad,0)
 . Else  Set newinfo=$zu(167,3,2,newlen,newsub,Z-CON,newpad,0,blknum)
 . If $Piece(insval,",",1) Set newinfo=newinfo+$Case(ptrtype,1:(2**12),:(2**30))
 i OFF+newlen>blksiz Close 63 q $$Error^%apiOBJ(192)
 S OFF=OFF+newlen
 s N=num
 F J=N:-1:I S ref(J+1)=ref(J),val(J+1)=val(J),refprn(J+1)=refprn(J),ccc(J+1)=ccc(J),pad(J+1)=pad(J),len(J+1)=len(J),info(J+1)=info(J),sub(J+1)=sub(J),long(J+1)=long(J)
 S N=N+1,ref(I)=insref,val(I)=insval,refprn(I)="^"_newref,long(I)=$Get(insertlong)
 s sub(I)=newsub,pad(I)=newpad,len(I)=newlen,ccc(I)=Z-CON,info(I)=newinfo
 i I<N d  
 . s info(I+1)=$zu(167,2,'(type=8 || (type=9) || (type=12) || (type=24)),Zsave,info(I),info(I+1))
 . s newinfo=$zu(167,0,'(type=8 || (type=9) || (type=12) || (type=24)),info(I+1))
 . s len(I+1)=$p(newinfo,"^",4),pad(I+1)=$p(newinfo,"^",5),ccc(I+1)=$p(newinfo,"^",3),sub(I+1)=$p(newinfo,"^",2)
 s num=N 
 I N=I {
    s sc=$select(+sc:1_$e($$Error^%apiOBJ(185,I),2,*),1:$$AppendStatus^%occSystem(sc,1_$e($$Error^%apiOBJ(185,I),2,*)))
    s sc=$select(+sc:1_$e($$Error^%apiOBJ(186),2,*),1:$$AppendStatus^%occSystem(sc,1_$e($$Error^%apiOBJ(186),2,*)))
    Close 63 q sc
 }
 I I=1 {
    Set sc=$select(+sc:1_$e($$Error^%apiOBJ(187),2,*),1:$$AppendStatus^%occSystem(sc,1_$e($$Error^%apiOBJ(187),2,*)))
    Set sc=$select(+sc:1_$e($$Error^%apiOBJ(188),2,*),1:$$AppendStatus^%occSystem(sc,1_$e($$Error^%apiOBJ(188),2,*)))
    Set sc=$select(+sc:1_$e($$Error^%apiOBJ(186),2,*),1:$$AppendStatus^%occSystem(sc,1_$e($$Error^%apiOBJ(186),2,*)))
    Close 63 q sc
 }
 Set sc=$select(+sc:1_$e($$Error^%apiOBJ(189,I),2,*),1:$$AppendStatus^%occSystem(sc,1_$e($$Error^%apiOBJ(189,I),2,*)))
 Set sc=$select(+sc:1_$e($$Error^%apiOBJ(190,I),2,*),1:$$AppendStatus^%occSystem(sc,1_$e($$Error^%apiOBJ(190,I),2,*)))
 Close 63 Quit sc
trackccc  ;
 f Z=1:1 Q:$E(A,Z)'=$E(insref,Z) 
 s Z=Z-1,CON=0 ; sets Z to the last common character
 i Z-lastccc>0 s CON=Z-lastccc
 s Zsave=Z
 i Z<lastccc s POP=1,Z=lastccc q  
 s lastccc=Z i $e(A,Z+1)]$e(insref,Z+1) s POP=1
 q  
exists q 1_$e($$Error^%apiOBJ(191,I),2,*)
}
GetCollationRuleInViewBuffer(dir,blk) [] PUBLIC
{
    Quit:(blk<1)||(blk\1'=blk) $$Error^%apiOBJ(6075,blk)
    Set blksiz=$Piece($zu(49,dir),",",2) 
    Quit:blksiz="" $$Error^%apiOBJ(184)
    Quit:blksiz=2048 $$Error^%apiOBJ(344)
    Set $Ztrap="errGetCollation"
    Open 63:"^^"_dir
    View blk
    Set sc=1_$e($$Error^%apiOBJ($Zutil(70,1,$v($zu(40,32,2),0,1))),2,*)
    Close 63
    Quit sc
errGetCollation
    Close 63
    Set $Ztrap="" If $Zerror["<NOTOPEN>" Quit $$Error^%apiOBJ(184)
    Quit $$Error^%apiOBJ(5002,$Zerror)
}
EncodeGlobalReference(ref,colrule) [] PUBLIC
{
 s (beg,end)=1
 s glo=$p(ref,"("),sub=$p(ref,"(",2,$l(ref)),sub=$e(sub,1,$l(sub)-1)
 i $e(glo)="^" s glo=$e(glo,2,$l(glo))
 f  q:end>$l(sub)  s glo=glo_$$enum($$ename())
 q glo
ename() ; parse one subscript field
 s beg=end i $e(sub,beg)="""" g equote
 s end=$f(sub,",",beg) s:'end end=$l(sub)+2 q $e(sub,beg,end-2)
equote s glo=""
plp s end=end+1,c=$e(sub,end) i c]"",c'="""" s glo=glo_c g plp
 i c]"",$e(sub,end+1)="""" s glo=glo_c,end=end+1 g plp
 s end=end+2 q glo
enum(x) i x="" q ""
 Q $c(0)_$zu(70,2,x,colrule)
}
ChangeValueInRepairBlock(dir,blk,node,newval,ref,val,ccc,len,pad,sub,long,info,OFF) [] PUBLIC
{
    Quit:(blk<1)||(blk\1'=blk) $$Error^%apiOBJ(6075,blk)
    Set blksiz=$Piece($zu(49,dir),",",2) 
    Quit:blksiz="" $$Error^%apiOBJ(184)
    Quit:blksiz=2048 $$Error^%apiOBJ(344)
    Open 63:"^^"_dir
    View blk
 s OFF=$v($zu(40,32,0),0,4)+$zu(40,32,10)
 s type=$v($Zutil(40,32,1),0,1)
 I type=8!(type=24) DO  Quit:$Get(noroom) $$Error^%apiOBJ(192)
 . S prefix=$A(val(node)),L=$L(val(node))
 . i prefix=6 s cmplenold=$zu(153,$e(val(node),2,$l(val(node))))
 . s cmplen=$zu(153,newval)
 . i cmplen,cmplen<($l(newval)*2) s newval=$c(6)_newval  ; compact unicode
 . e  i 'cmplen s newval=$c(0)_newval  ; ascii
 . e  s newval=$c(4)_newval   ; unicode
 . s oldinfo=$zu(167,0,0,info(node)),oldsub=$p(oldinfo,"^",2),oldccc=$p(oldinfo,"^",3)
 . s newlen=oldsub+$Case(cmplen,0:$l(newval)-1,:$Case($Ascii(newval),4:(2*$l(newval))-1,:cmplen+1))
 . s newpad=0,newlen=newlen+4 i newlen#4 s newpad=4-(newlen#4),newlen=newlen+newpad
 . Set info(node)=$zu(167,3,0,newlen,oldsub,oldccc,newpad,$Case(cmplen,0:1,:0))
 . i (OFF-len(node)+newlen)>(blksiz-$zu(40,32,10)) Set noroom=1 Quit
 . s OFF=OFF-len(node)+newlen,len(node)=newlen,pad(node)=newpad
 . s val(node)=newval
 e  i type=9 d  Close 63 q 1 ;Global directory is a data block
 . s $p(val(node),",",2)=newval
 Else  Do  
 . Set oldinfo=info(node)
 . Set oldlong=$Piece(val(node),",",1)
 . Set val(node)=newval
 . Set newblockval=$Piece(newval,",",2),long(node)=$Piece(newval,",",1)
 . Set ptrtype=$Piece($Zutil(167,0,1,info(node)),"^",1)  
 . Set newextra=$Zutil(167,$Case(ptrtype,1:5,:4),0,newblockval)
 . If ptrtype=2,'newextra Do  ;Type 2 pointer node, only 12 bits needed
 . . Set oldinfo1=oldinfo\262144,oldblk=(oldinfo1#4096)*262144 
 . . Set info(node)=oldinfo-oldblk+(newblockval*262144)
 . Else  Do  
 . . Set newpad=0,newlen=sub(node)+4+newextra
 . . If newlen#4 Set newpad=4-(newlen#4),newlen=newlen+newpad
 . . Set len(node)=newlen,pad(node)=newpad
 . . If ptrtype=1 Set info(node)=$Zutil(167,3,1,newlen,sub(node),ccc(node),newpad,0)
 . . Else  Set info(node)=$Zutil(167,3,2,newlen,sub(node),ccc(node),newpad,0,newblockval)
 . ;If long(node)=1 Set info(node)=info(node)+$Case(ptrtype,1:$$$type1bigstringbit,:$$$type2bigstringbit)
 . If long(node)=1 && 'oldlong Set info(node)=info(node)+$Case(ptrtype,1:(2**12),:(2**30))
 . Else  If oldlong && 'long(node) Set info(node)=info(node)-$Case(ptrtype,1:(2**12),:(2**30))
 Close 63 Quit 1
}
WriteRepairBlock(saveblock,dir,blk,type,link,num,ref,val,ccc,len,pad,sub,long,info,pntlen,nextpntlen,nextpntval,nextpntoff,incver,collate,nextpntref,gartree) [] PUBLIC
{
    Quit:(blk<1)||(blk\1'=blk) $$Error^%apiOBJ(6075,blk)
    Set blksiz=$Piece($zu(49,dir),",",2) 
    Quit:blksiz="" $$Error^%apiOBJ(184)
    Quit:blksiz=2048 $$Error^%apiOBJ(344)
    Set $Ztrap="errWriteRepair"
    Open 63:"^^"_dir
    View blk
 If $Data(type) View $Zutil(40,32,1):0:1:$Case($Get(gartree),1:type+32,:type)
 Else  Set type=$$getType($v($Zutil(40,32,1),0,1))
 If $Data(link) View $Zutil(40,32,4):0:4:link
 If $Data(incver) View $Zutil(40,32,5):0:4:incver
 If (type=8)!(type=9) {  ;JO2150
    If $Data(pntlen) View $Zutil(40,32,3):0:2:pntlen
    If $Data(nextpntlen) View $Zutil(40,32,8):0:2:nextpntlen
    If $Data(nextpntval) View $Zutil(40,32,9):0:1:nextpntval
    If $Data(nextpntoff) View $Zutil(40,32,7):0:1:nextpntoff
    If $Data(collate) View $Zutil(40,32,2):0:1:collate
    If $Data(nextpntref) && ($Get(nextpntlen)) {
       Set storednextoff=$Case(blksiz,2048:2036,:(blksiz-$zu(40,32,10)))-nextpntlen
       Set storednextoff=((storednextoff\4)*4)+$zu(40,32,10)
       If ((storednextoff+nextpntlen)'>blksiz) {
          View storednextoff:0:-nextpntlen:nextpntref
          Set nextpntoff=1
       } Else {
          View $Zutil(40,32,7):0:1:0
          Set nextpntoff=0
       }
    }
 }
 Set bigcount=0
 S off=$zu(40,32,10),node=0,S="" G wrglodir:type=9
WR1 s A=off S node=node+1 G dowrite:node>num S S=ref(node)
 v A:0:4:info(node) s A=A+4
 i ccc(node) s S=$e(S,ccc(node)+1,$l(S))
 F Y=1:1:$L(S) V A:0:1:$A(S,Y) s A=A+1   ;store the name
 s A=A+pad(node)
 ;
 If (type=2)!(type=6)!(type=66)!(type=70) Do  Set off=off+len(node) Goto WR1
 . Set blknum=$Piece(val(node),",",2)
 . Set extracount=len(node)-sub(node)-pad(node)-4
 . If $Piece($Zutil(167,0,1,info(node)),"^",1)=2 Do  
 . . If extracount View A:0:extracount:$Zutil(167,4,1,blknum)
 . Else  View A:0:extracount:blknum
 S X=val(node),gdviewtype=$Ascii(X),X=$e(X,2,$Length(X))
 i $p($zu(167,0,0,info(node)),"^",1) d  s off=off+len(node) g WR1
  . If $Length(X) View A:0:-$Length(X):X
 If ($case(gdviewtype,3:1,5:1,7:1,13:1,:0)) Set bigcount=bigcount+1
 i gdviewtype=6 s cmplen=$zu(153,X)
 e  s cmplen=0 ;  What if this is already a long string?
 i cmplen>756 Close 63 Quit $$Error^%apiOBJ(212)
 I gdviewtype=1 DO  S off=off+len(node) G WR1 ; Integer value has type byte 0
 . v A:0:-($l(X)+1):$c(0)_X
 i gdviewtype=6!(gdviewtype=4) d  s off=off+len(node) g WR1 
 . View A:0:1:$Case(gdviewtype,6:3,:2) ; intro char in block for compact
 . If $Zutil(153,X) View A+1:0:(-$l(X))_$Case(gdviewtype,6:"E",:"W"):X
 . Else  View A+1:0:(-$l(X)):X
 ;
 ;BIGSTRINGS HERE
 i ($case(gdviewtype,3:1,5:1,7:1,13:1,:0)) d  s off=off+len(node) g WR1  ; big string types
 . v:gdviewtype=7 A:0:1:4 ;change type to 4
 . v:gdviewtype=13 A:0:1:14 ;type to 14
 . s A=A+1
 . v A:0:4:$p(X,",",3)
 . s numblks=$p(X,",",2)
 . f numi=1:1:numblks v A+(4*numi):0:4:$p(X,",",3+numi)
 i gdviewtype=8 s off=off+len(node) g WR1 // no value, first node in first block of glo
 i gdviewtype=12 d  s off=off+len(node) g WR1  ;vector type
 . v A:0:1:13 ;vectortype
 . v A+1:0:-$L(X):X
 v A:0:-($l(X)+1):$c(1)_X ;double id byte is 1
 s off=off+len(node) G WR1
dowrite 
 View $zu(40,32,6):0:4:bigcount
 v $zu(40,32,0):0:4:(off-$zu(40,32,10))
 If $Get(saveblock)="disk" d WriteBlock^DMREPAIR(blk)
 Else  Set saveblock=$View(0,0,-blksiz)
 Close 63 Quit 1
wrglodir s A=off S node=node+1 G dowrite:node>num S S=ref(node)
 v A:0:4:info(node) s A=A+4
 i ccc(node) s S=$e(S,ccc(node)+1,$l(S))
 F Y=1:1:$L(S) V A:0:1:$A(S,Y) s A=A+1   ;store the name
 S A=A+pad(node) ; move to type field
 v A:0:1:$p(val(node),",",4)
 V A+1:0:1:$p(val(node),",",3)
 V A+2:0:1:$p(val(node),",",5)
 v A+3:0:4:$p(val(node),",",2)
 v A+7:0:4:$p(val(node),",",1)
 S off=off+len(node) G wrglodir
errWriteRepair
 Close 63
 Set $Ztrap="" If $Zerror["<NOTOPEN>" Quit $$Error^%apiOBJ(184)
 Quit $$Error^%apiOBJ(5002,$Zerror)
}
GetTypeName(type)
 q $case(type,8:"DATA",9:"GLOBAL DIRECTORY",24:"BIG STRING DATA",66:"TOP POINTER",70:"TOP/BOTTOM POINTER",2:"POINTER",6:"BOTTOM POINTER",17:"MIRROR INFORMATION BLOCK",18:"VOLUME INFORMATION",:"")
IsTypeLegal(type) [] PUBLIC
{
 Set sc=0
 For i=2,6,8,9,66,70,13,17 If type=i Set sc=1 Quit  
 Quit sc
}
GetBlockTypeFromViewBuffer(big)
 q $case(big,0:$v(2043,0,1),:$v($Zutil(40,32,1),0,1))
GetDataOffsetFromViewBuffer(big)
 q $case(big,0:0,:$zu(40,32,10))
FindLeftBlock(dir,block,left) [] PUBLIC
{
    Set $Ztrap="errFindLeft"
    Quit:(block<1)||(block\1'=block) $$Error^%apiOBJ(6075,block)
    Set dirinfo=$zu(49,dir)
    Quit:dirinfo<0 $$Error^%apiOBJ(184)
    Quit:'$Piece(dirinfo,",",21) $$Error^%apiOBJ(344)
    Open 63:"^^"_dir
    View block
    Set type=$v($Zutil(40,32,1),0,1)
    Goto:$Zboolean(+type,32,1) quitBlockNotInUse
    If type=9 { ;JO2150+
	Set gdblk=3
	View gdblk
	Set right=$v($Zutil(40,32,4),0,4)
	While right,right'=block {
	    Set gdblk=right
	    View gdblk
	    Set right=$v($Zutil(40,32,4),0,4)
	}
	Goto:'right quitBlockNotInUse
	Set left=gdblk
	Goto fin
    } ;JO2150-
    Set isdatablock=(type=8 || (type=9) || (type=12) || (type=24))
    Set info=$View($zu(40,32,10),0,4)
    Set sublen=$Piece($Zutil(167,0,'isdatablock,info),"^",2)
    Goto:'sublen quitBlockNotInUse
    Set substr=$View($zu(40,32,10)+4,0,-sublen),gloname=$Piece(substr,$c(0))
    Set rc=$$GetGlobalPointers^%SYS.DATABASE(dir,gloname,.top,.firstdata)
    If ('rc) {
	Close 63
	Quit rc
    }
    Quit:'top $$Error^%apiOBJ(308,gloname)
    Quit:(top<1)||(top\1'=top) $$Error^%apiOBJ(6075,top)
    If block=top || (block=firstdata) {
	Set left=0
	Goto fin
    }
    View top
    Set toptype=$v($Zutil(40,32,1),0,1)
    If isdatablock {
	Set rc=$$FindGlobalLevels(dir,block,.levels,.blocktab,.curlev)
	If ('rc) {
	    Close 63
	    Quit rc
	}
	If 'levels {
	    Set left=0
	    Goto fin
	}
	Set upblock=blocktab(levels-1) ;get bottom pointer leftmost block
	Set lastprev=0
	Do {
	    View upblock
	    Set ptr=$View(2,-5)
	    If ptr=block {
		Set left=lastprev
		Quit
	    }
	    Set node=2
	    Do {
		Set nextptr=$View(node*2,-5)
		If nextptr="" { Set lastprev=ptr }
		ElseIf nextptr=block { Set left=ptr Quit }
		Else {
		    Set ptr=nextptr
		    Set node=node+1
		}
	    } While (nextptr'="") 
	    If $Data(left) { Set upblock=0 }
	    Else { Set upblock=$v($Zutil(40,32,4),0,4) }
	} While (upblock)
	Goto:'$Data(left) quitBlockNotInUse
    } ElseIf type=6 {
        Goto:toptype'=66 quitDatabaseError
	View top
	Set curblk=$View(2,-5) ; could be ptr or botptr
	View curblk
	While ($v($Zutil(40,32,1),0,1)'=type) {   ; Skip any pointer levels
	    View curblk
	    Set curblk=$View(2,-5)
	    View curblk
	}
	Goto:'$$checkLevel(block,curblk,.left) quitBlockNotInUse
    } ElseIf type=2 {
	View top
	Set curblk=$View(2,-5)
	View curblk
	Goto:$$getType($v($Zutil(40,32,1),0,1))'=type quitDatabaseError
	Do {
	    Quit:$$checkLevel(block,curblk,.left)
	    View curblk
	    Set curblk=$View(2,-5) ;Data block or first pointer block on next level
	    View curblk 
	} While ($v($Zutil(40,32,1),0,1)=type)
	Goto:$v($Zutil(40,32,1),0,1)'=type quitBlockNotInUse
    } Else {
	Goto quitDatabaseError
    }
fin Close 63
    Quit 1 ;If checkLevel returned TRUE
errFindLeft
    Close 63
    Set $Ztrap=""
    Quit:$Zerror["<NOTOPEN>" $$Error^%apiOBJ(184)
    Quit $$Error^%apiOBJ(5002,$Zerror)
quitDatabaseError
    Close 63
    Quit $$Error^%apiOBJ(329,gloname)
quitBlockNotInUse
    Close 63
    Quit $$Error^%apiOBJ(330,block)
}
checkLevel(block,curblk,left) [] PRIVATE
{
 If curblk=block { Set left=0 Quit 1 }
 Set sc=0
 Do {
    View curblk
    Set link=$v($Zutil(40,32,4),0,4)
    If link=block { Set left=curblk Set sc=1 Quit }
    Set curblk=link
 } While (curblk)
 Quit sc
}
FindGlobalLevels(dir,block,&levels,&blocktab,&curlev) [] PUBLIC
{
	Quit:(block<1)||(block\1'=block) $$Error^%apiOBJ(6075,block)
	Set dirinfo=$zu(49,dir)
	Quit:dirinfo<0 $$Error^%apiOBJ(184)
	Quit:$p(dirinfo,",",2)=2048 $$Error^%apiOBJ(344)
	Set $Ztrap="errFindGlobal"
	Set curlev=0
	Open 63:"^^"_dir
	View block
	Set $Ztrap=""
	Set type=$v($Zutil(40,32,1),0,1)
	If $Zboolean(+type,32,1) { Close 63 Quit $$Error^%apiOBJ(330,block) }
	If (type=9)||(type=13)||(type=17) {
		Close 63 Set levels=0,curlev=0 Quit 1
	}
	Set gloname=$$GetGlobalName(1)
	Quit:'$zname(gloname,3) $$Error^%apiOBJ(216,gloname)
	Set rc=$$GetGlobalPointers^%SYS.DATABASE(dir,gloname,.top,.firstdata)
	Set levels=1,blocktab(1)=top
	Quit:'top $$Error^%apiOBJ(308,gloname)
	Quit:(top<1)||(top\1'=top) $$Error^%apiOBJ(6075,top)
	View top
	Set toptype=$v($Zutil(40,32,1),0,1)
	If (toptype=70) || (toptype=6) {
		Set levels=2
		Set blocktab(2)=firstdata
	} Else {
		Set curblk=$View(2,-5)
		Goto:(curblk<1)||(curblk\1'=curblk) quitDatabaseError
		View curblk
		While ($v($Zutil(40,32,1),0,1)=2) {
			Set levels=levels+1,blocktab(levels)=curblk
			Set curblk=$View(2,-5)
			Goto:(curblk<1)||(curblk\1'=curblk) quitDatabaseError
			View curblk
		}
		Goto:$v($Zutil(40,32,1),0,1)'=6 quitDatabaseError
		Set levels=levels+2,blocktab(levels-1)=curblk,blocktab(levels)=firstdata
	}
	For i=1:1:levels {
		If blocktab(i)=block {
			Set curlev=i
			Quit
		}
	}
	If '$Get(curlev) {
		If (type=8) { Set curlev=levels }
		ElseIf type=66 { Set curlev=1 }
		ElseIf type'=2 { Set curlev=levels-1 }
		ElseIf levels=4 { Set curlev=2 }
		Else {
			For i=2:1:levels-2 {
				If $$checkLevel(block,blocktab(i)) {
					Set curlev=i
					Quit
				}
			}
			Goto:'$Get(curlev) quitDatabaseError
		}
	}
	Quit 1
errFindGlobal
	Close 63
	Set $Ztrap=""
	Quit:$Zerror["<NOTOPEN>" $$Error^%apiOBJ(184)
	Quit $$Error^%apiOBJ(5002,$Zerror)
quitDatabaseError
	Close 63
	Quit $$Error^%apiOBJ(329)
}
FindPointerBlock(dir,blk,upper,checktab) [] PUBLIC
{
    Set $Ztrap="errFindPointer"
    Set sc=$$FindGlobalLevels(dir,blk,.levels,.blocktab,.curlev)
    Quit:('sc) sc
    If $d(checktab) {
	For i=curlev-1:-1:1 {
	    If $d(@checktab@(dir,blocktab(i))) {
		Set upper=blocktab(i)
		Goto quitStatus
	    }
	}
    }
    If curlev<2 { Set upper=0 Goto quitStatus }
    Open 63:"^^"_dir
    View blk
    Set ref=$v(0,-6)
    Set upper=blocktab(1)
    If (curlev>2) {
        For b=1:1:curlev-2 {
	    If (upper<1)||(upper\1'=upper) {
		Set sc=$$Error^%apiOBJ(6075,upper)
		Quit
	    }
	    View upper
	    For i=1:1 {
		Set ref1=$v(i*2-1,-6)
		Quit:ref1=""
		If ref1]ref { Set found=1 Quit }
	    }
	    Set upper=$v((i-1)*2,-5)
	}
    }
quitStatus
    Close 63
    Quit sc
errFindPointer
    Set $Ztrap=""
    Quit $$Error^%apiOBJ(5002,$Zerror)
}
GetNodeReferences(node,internal,printable) [] PUBLIC
{
 	try {
		set internal=$View(node,-6)
		for {
			set $ze=""
 			try { 
 				if '$d(len) { set len=$l(internal),printable=$v(node,-5) }
 				else { set printable="^"_$zu(70,4,$e(internal,1,len),$Zutil(70,1,$View($Zutil(40,32,2),0,1))) } 
 			} catch {}
 			quit:($ze'["<SUBSCRIPT>")
 			set len=len-1
 		}
 	} catch {}
	quit:($ze'="") $$Error^%apiOBJ(5002,$ze)
	set:(len'=$l(internal)) $e(printable,*)="...)"
	quit 1
}
GetPrintableRef(ref,colrule) [] PUBLIC
{
 	try {
		Set len=$l(ref("internal"))
		for {
			set $ze=""
 			try {
 				set ref("printable")="^"_$zu(70,4,$e(ref("internal"),1,len),colrule) 
 			} catch {}
 			quit:($ze'["<SUBSCRIPT>")
 			set len=len-1
 		}
 	} catch {}
	quit:($ze'="") $$Error^%apiOBJ(5002,$ze)
	set:(len'=$l(ref("internal"))) $e(ref("printable"),*)="...)"
	quit 1
}
GetMapBlocks(dir,blocks) [] PUBLIC
{
 Set $Ztrap="errGetMapBlocks"
 Set info=$zu(49,dir) i (+info)<-1 Quit $$Error^%apiOBJ(184)
 Set curmaps=$Piece(info,",",24)
 Set bigval=$Piece(info,",",21)
 Quit:'bigval $$Error^%apiOBJ(344)
 Set curblks=$Piece(info,",",22)
 Set mapsiz=$Piece(info,",",23)
 For map=0:1:curmaps-1 {
    Set mapblock=$$findMapBlock^%SYS.DATABASE(map,bigval)
    Set first=(map*mapsiz)+1,last=(map+1)*mapsiz
    If map=(curmaps-1),curblks#mapsiz Set last=(map*mapsiz)+(curblks#mapsiz)
    Set blocks(mapblock,1)=first,blocks(mapblock,2)=last
 }
 Quit 1
errGetMapBlocks
 Close 63
 Set $Ztrap="" i $ze["<NOTOPEN>" q $$Error^%apiOBJ(184)
 Quit $$Error^%apiOBJ(5002,$Zerror)
}
FindMapBlock(dir,blk,mapblk) [] PUBLIC
{
    Quit:(blk<1)||(blk\1'=blk) $$Error^%apiOBJ(6075,blk)
    Set $Ztrap="errFindMapBlock"
    Set info=$zu(49,dir) i (+info)<-1 Quit $$Error^%apiOBJ(184)
    Set bigval=$Piece(info,",",21)
    Quit:'bigval $$Error^%apiOBJ(344)
    Set mapsiz=$Piece(info,",",23)
    Set curblks=$Piece(info,",",22)
    Quit:blk>curblks $$Error^%apiOBJ(341,blk)
    Set map=$Case(blk#mapsiz,0:(blk\mapsiz)-1,:(blk\mapsiz))
    Set mapblk=$$findMapBlock^%SYS.DATABASE(map,bigval)
    Quit 1
errFindMapBlock
    Close 63
    Set $Ztrap=""
    Quit:$ze["<NOTOPEN>" $$Error^%apiOBJ(184)
    Quit $$Error^%apiOBJ(5002,$Zerror)
}
AllocateBlockInMap(dir,blknum,op,mapblknum,already,newblock,commit) [] PUBLIC
{
 Set $Ztrap="errAllocate"
 Set info=$zu(49,dir) i (+info)<-1 Quit $$Error^%apiOBJ(184)
 Set blksiz=$Piece(info,",",2)
 Set bigval=$Piece(info,",",21)
 Quit:'bigval $$Error^%apiOBJ(344)
 Set secondaryoff=($Zutil(40,0,51)+((blksiz\4096)*4))
 Set rc=$$IsBlockAllocated(dir,blknum,.result,.mapblknum,.bitpos,.wordoff,.wordbits)
 Quit:('rc) rc
 If result=op { Set already=1 Quit 1 }
 Set already=0
 Open 63:"^^"_dir
 View mapblknum
 Set bit='op
 Set wordbits=$Zbitset(wordbits,bitpos,bit)
 If $Zutil(40,0,0) Set wordbits=$$convertBigEndianWord(wordbits)
 View wordoff:0:-4:$Extract(wordbits,2,5)
 Set free=$View($zu(40,32,10),0,4)+$Case(op,1:-1,:1)
 View $zu(40,32,10):0:4:free
 If (op && '$Zbitcount(wordbits)) || ('op && ($Zbitcount(wordbits)=1)) {
    Write !,"have to change 2ndary"
    s mapsiz=$Case(bigval,0:400,1:30720,2:62464,3:125952,4:252928,5:506880)
	s blknum=((blknum-1)#mapsiz)+1
    Set words2=((blknum-1)\32)\32
    Set bit2=(((blknum-1)\32)#32)+1 ; $zbitset uses 1-based bit #s
    Set wordoff2=secondaryoff+(words2*4)
    Set wordbits2=$c(0)_$View(wordoff2,0,-4)
    If $Zutil(40,0,0) Set wordbits2=$$convertBigEndianWord(wordbits2)
    Set wordbits2=$Zbitset(wordbits2,bit2,'op)
    If $Zutil(40,0,0) Set wordbits2=$$convertBigEndianWord(wordbits2)
    View wordoff2:0:-4:$Extract(wordbits2,2,5)
    If (op && '$Zbitcount(wordbits2)) || ('op && ($Zbitcount(wordbits2)=1)) {
       Write !,"have to change master"
       Set words1=words2\32
       Set bit1=((((blknum-1)\32)\32)#32)+1 ; $zbitset uses 1-based bit #s
       Set wordoff1=$Zutil(40,0,51)+(words1*4)
       Set wordbits1=$c(0)_$View(wordoff1,0,-4)
       If $Zutil(40,0,0) Set wordbits1=$$convertBigEndianWord(wordbits1)
       Set wordbits1=$Zbitset(wordbits1,bit1,'op)
       If $Zutil(40,0,0) Set wordbits1=$$convertBigEndianWord(wordbits1)
       View wordoff1:0:-4:$Extract(wordbits1,2,5)
    }
 }
 View:$Get(commit) -mapblknum
 Set newblock=$View(0,0,-blksiz)
 Close 63
 Quit 1
errAllocate
 Close 63
 Set $Ztrap="" i $ze["<NOTOPEN>" q $$Error^%apiOBJ(184)
 Quit $$Error^%apiOBJ(5002,$Zerror)
 Quit 1
}
ChangeFreeCount(dir,mapblk,newcount,commit,newblock) [] PUBLIC
{
    Set $Ztrap="errChangeFree"
    Set info=$zu(49,dir) i (+info)<-1 Quit $$Error^%apiOBJ(184)
    Set blksiz=$Piece(info,",",2)
    Set bigval=$Piece(info,",",21)
    Quit:'bigval $$Error^%apiOBJ(344)
    Open 63:"^^"_dir
    View mapblk
    If $v($Zutil(40,32,1),0,1)'=$Case(bigval,0:170,:16) {
	Close 63
	Quit $$Error^%apiOBJ(342,blk)
    }
    View $zu(40,32,10):0:4:newcount
    View:$Get(commit) -mapblk
    Set newblock=$View(0,0,-blksiz)
    Quit 1
errChangeFree
    Close 63
    Set $Ztrap="" i $ze["<NOTOPEN>" q $$Error^%apiOBJ(184)
    Quit $$Error^%apiOBJ(5002,$Zerror)
}
IsBlockAllocated(dir,blknum,result,mapblk,bitpos,wordoff,wordbits) [] PUBLIC
{
    Quit:(blknum<1)||(blknum\1'=blknum) $$Error^%apiOBJ(6075,blknum)
    Set $Ztrap="errIsBlock"
    Set info=$zu(49,dir) i (+info)<-1 Quit $$Error^%apiOBJ(184)
    Set blksiz=$Piece(info,",",2)
    Set bigval=$Piece(info,",",21)
    Quit:'bigval $$Error^%apiOBJ(344)
    Set mapsiz=$Piece(info,",",23)
    Set curblks=$Piece(info,",",22)
    Quit:blknum>curblks $$Error^%apiOBJ(341,blknum)
    Set mapdataoff=(($Zutil(40,0,51)+((blksiz\4096)*4))+((((blksiz\4096)*32)-(blksiz\4096)-1)*4))
    Set map=(blknum-1)\mapsiz
    Set blk=(blknum-1)#mapsiz
    Open 63:"^^"_dir
    Set mapblknum=$$findMapBlock^%SYS.DATABASE(map,bigval)
    If $Data(mapblk),mapblk'=mapblknum {
	Close 63
	Quit $$Error^%apiOBJ(343,mapblk,blknum)
    }
    Set mapblk=mapblknum
    If (mapblk<1)||(mapblk\1'=mapblk) {
	Close 63    
	Quit $$Error^%apiOBJ(6075,mapblk)
    }
    View mapblknum
    Set word=blk\32,bitpos=blk#32,wordoff=mapdataoff+(word*4)
    Set bitpos=bitpos+1 ; $zbitget uses 1-based bit #s
    Set wordbits=$View(wordoff,0,-4)
    Set wordbits=$c(0)_wordbits
    If $Zutil(40,0,0) { Set wordbits=$$convertBigEndianWord(wordbits) }
    Set result='$Zbitget(wordbits,bitpos)
    Close 63
    Quit 1
errIsBlock
    Close 63
    Set $Ztrap=""
    Quit:$ze["<NOTOPEN>" $$Error^%apiOBJ(184)
    Quit $$Error^%apiOBJ(5002,$Zerror)
}
MapOut(dir,mapblk,commit,newblock) [] PUBLIC
{
    Set $Ztrap="errMapOut"
    Set sc=$$GetMapBlocks(dir,.blocks)
    Quit:('sc) sc
    Quit:'$d(blocks(mapblk)) $$Error^%apiOBJ(342,mapblk)
    Set info=$zu(49,dir)
    Set blksiz=$Piece(info,",",2)
    Set bigval=$Piece(info,",",21)
    Quit:'bigval $$Error^%apiOBJ(344)
    Set mapsiz=$Piece(info,",",23)
    Set curblks=$Piece(info,",",22)
    Set nummap=$Piece(info,",",24)
    Open 63:"^^"_dir
    View mapblk
    Set map=mapblk\mapsiz
    If map=(nummap-1) {
        If curblks#mapsiz {Set numbytes=(curblks#mapsiz)\8}
	Else {Set numbytes=mapsiz\8}
    } Else {
        Set numbytes=mapsiz\8
    }
    Set mapoutstring="",$Piece(mapoutstring,$c(0),numbytes+1)=""
    View (($Zutil(40,0,51)+((blksiz\4096)*4))+((((blksiz\4096)*32)-(blksiz\4096)-1)*4)):0:-numbytes:mapoutstring
    Set numbytes=$Case(numbytes#32,0:0,:1)+(numbytes\32)
    Set mapoutstring="",$Piece(mapoutstring,$c(0),numbytes+1)=""
    View ($Zutil(40,0,51)+((blksiz\4096)*4)):0:-numbytes:mapoutstring
    Set numbytes=$Case(numbytes#32,0:0,:1)+(numbytes\32)
    Set mapoutstring="",$Piece(mapoutstring,$c(0),numbytes+1)=""
    View ($Zutil(40,0,51)):0:-numbytes:mapoutstring
    View $zu(40,32,10):0:4:0
    View:$Get(commit) -mapblk
    Set newblock=$View(0,0,-blksiz)
    Close 63
    Quit 1
errMapOut
    Close 63
    Set $Ztrap=""
    Quit:$ze["<NOTOPEN>" $$Error^%apiOBJ(184)
    Quit $$Error^%apiOBJ(5002,$Zerror)
}
convertBigEndianWord(wordbits) [] PUBLIC {
    Set wordbitsbe="",wordbits=$Extract(wordbits,2,5)
    For i=1:1:4 { Set wordbitsbe=wordbitsbe_$Extract(wordbits,5-i) }
    Set wordbits=$c(0)_wordbitsbe
    Quit wordbits
}
getType(type) [] Private {
    Quit $S($Zboolean(+type,32,1):type-32,1:type)
}
GetGlobalName(isbig) [] PUBLIC {
    Quit:'isbig ""
    Set rc=$$GetNodeReferences(0,.internal,.printable)
    Quit:('rc) ""
    Quit $p(internal,$c(0))
}
SetBlockList(blocktab,dir,dev) [] PUBLIC {
    Set $zt="errSet"
    Set dirinfo=$zu(49,dir)
    If '$Piece(info,",",21) {
        Do show("2K database format not supported",dev)
	Quit 0
    }
    Set block="",quit=0
    Open 63:"^^"_dir
    For {
	Set block=$o(@blocktab@(dir,block))
	Quit:block=""
	If (block<1)||(block\1'=block) {
	    Do show("Not a legal block number: "_block,dev)
	    Return 0
	}
	Quit:quit
	View block
	Set typ=$v($Zutil(40,32,1),0,1)
	If typ'=66,typ'=70,typ'=6,typ'=2 {
	    Kill @blocktab@(dir,block)
	    Continue:typ'=8
	    Set rc=$$FindPointerBlock(dir,block,.upblock,blocktab)
	    If 'rc {
		Return:$ze["INTERRUPT" 1
		Set rcx=$$IsBlockAllocated(dir,block,.alloc) 
		If alloc {
		    Do show("Error from FindPointerBlock in "_dir,dev)
		    Do ShowMessage(rc,dev)
		} Else {
		    Set $ze=""	;not an error
		}
	    } Else {
		Set:upblock @blocktab@(dir,upblock)=""
	    }
	} ElseIf typ=6 || (typ=2) {
	    Set rc=$$FindGlobalLevels(dir,block,.levels,.blktab,.curlev)
	    If 'rc {
		Return:$ze["INTERRUPT" 1
		Set rcx=$$IsBlockAllocated(dir,block,.alloc) 
		If alloc {
		    Do show("Error from FindGlobalLevels in "_dir,dev)
		    Do ShowMessage(rc,dev)
		} Else {
		    Set $ze=""  ;not an error
		}
	    } Else {
		For i=curlev-1:-1:1 {
		    If $d(@blocktab@(dir,blktab(i))) {
			Kill @blocktab@(dir,block)
			Quit
		    }
		}
	    }
	}
	Open 63:"^^"_dir
    }
    Quit 1
errSet
    Set $zt=""
    Do show("Unexpected error="_$ZE,dev)
    Quit 0
}
DoCheckBList(blocktab,dir,dev) [] PUBLIC
{
    Set $zt="errDoCheck"
    Set errmaxperglobal=1
    Set errors=0,checked=0,quit=0
    If dir'="" {
	Do CheckOneDir
	Quit 'errors
    }
    For {
	Set dir=$o(@blocktab@(dir))
	Quit:(dir=""!quit)
	Do CheckOneDir
    }
    Quit 'errors
errDoCheck
    Set $zt=""
    Do show("Unexpected error="_$ZE,dev)
    Quit 0
CheckOneDir
    Do show("Integrity checking DB="_dir,dev)
    Set block="",rc=1
    For {
	Set block=$o(@blocktab@(dir,block))
	Quit:block=""
	Do show("Checking Block "_block,dev)
	Set rc=$$CheckPointerIntegrity^%SYS.DATABASE(dir,block,errmaxperglobal,1)
	Do ShowMessage(rc,dev) 
	If 'rc {
	    Set errors=errors+1
	    Do show("Error found while checking block "_block,dev)
	    If $ze["INTERRUPT" {
		Set quit=1
		Quit
	    }
	} Else {
	    Do show("No error found for checking block "_block,dev)
	}
    }
}
show(msg,dev) [] PRIVATE
{
    Try {
	Do:dev=-1 $zu(9,"",msg,(0>0),0)
	Use dev
	Write !,msg
    } Catch { Return 0 }
    Return 1
}
WriteBlock(blk) PUBLIC {
	Try {
		S osw=$zu(68,80,1)
		V -blk
		Do $zu(68,80,osw)
	} Catch {
		Do $zu(68,80,osw)
		Throw
	}
}
ViewBigStringValue(viewdata) PUBLIC
{
	Set type=$ascii(viewdata)
	If '($case(type,3:1,5:1,7:1,13:1,:0)) { Do $ZUTIL(96,3,78) }
	Set list=$listfromstring($extract(viewdata,3,*),",")
	Set listptr=0
	Set binstr=""
	Set blocksize=$view($zu(40,1,70),-1,4)
	If '$listnext(list,listptr,blockcount) { Do $ZUTIL(96,3,78) }
	If '$listnext(list,listptr,lastblockbytes) { Do $ZUTIL(96,3,78) }
	For i=1:1:blockcount {
		If '$listnext(list,listptr,block) || (block < 1) { Do $ZUTIL(96,3,78) }
		View block
		If $v($Zutil(40,32,1),0,1)'=24 { Do $ZUTIL(96,3,28) }
		Set bytes=$select(i=blockcount:lastblockbytes,1:(blocksize-$zu(40,32,10)))
		Set remaining=3641144-$length(binstr)
		If remaining>=bytes {
			Set binstr=binstr_$view($zu(40,32,10),0,-bytes)
		} Else {
			Set firstbinstr=binstr_$view($zu(40,32,10),0,-remaining)
			Set binstr=$view($zu(40,32,10)+remaining,0,-(bytes-remaining))
		}
	}
	Quit:$data(firstbinstr) $zu(167,8,type,firstbinstr,binstr)
	Quit $zu(167,8,type,binstr)
}

DSET^INT^1^67214,47330
DSET ; SELECT A SET OF DIRECTORIES
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ;RETURN %UTILITY(D)="", WHERE 'D' IS ZERO OR MORE DIRECTORY NAMES
 N (%UTILITY) S DMERR="IRIS"_".DAT is dismounted." G DSETCOMM
DMENTRY N (%UTILITY) S DMERR="IRIS"_".DAT is already dismounted."
DSETCOMM D ^|"%SYS"|ST S MGDIR=%ST("MGRNSP")
 K %UTILITY S %UTILITY=0
READ R !,"Directory: ",%U S %U=$$Strip(%U) G EXIT:%U=""
 I %U="?" S %U="" F %I=0:1 S %U=$zu(49,%I) G READ:%U=-2  s TEMP=$ZU(49,%I,3) W !,$p(TEMP,"^",2)," is ",$s((+%U=-1)!(+%U=$zu(40,0,41)):"not ",1:""),"mounted" 
 ;
INT S $ZT="ZUERROR"
 n %C ; canonic name of %U
 s %C=$$ChkDirOrSpecEXISTS(%U) i %C="" w !!,$$DIRDIAG(%U) g READ
 s %U=%C O 63:"^^"_%U s %START=%U,%STOP=%U,$ZT=""
 C 63 O 63 C 63
 S %UTILITY(%START)="",%UTILITY=%UTILITY+1
 G READ
KILL I $O(%UTILITY(%START))]%STOP W *7," ???" G READ
 F  S %START=$O(%UTILITY(%START)) Q:%START=""  Q:%START]%STOP  DO
 . K %UTILITY(%START) S %UTILITY=%UTILITY-1
 G READ
ALL S %D="" F  S %D=$$GetNextDatabaseByUCI^%SYS.CONFIG(%D) Q:%D=""  DO
 . S %UTILITY(%D)="",%UTILITY=%UTILITY+1
EXIT W !,%UTILITY_" director"_$s(%UTILITY=1:"y",1:"ies") Q
ZUERROR S $ZT="" C 63 O 63 C 63 W !!,$$DIRDIAG(%U) G READ
NODIROS(D) ;Return 1 if D doesn't exist, 0 if it exists, -1 if can't tell
 i $zu(12,D,3)="" q 1
 q 0
DIRDIAG(D) ;If D is a mounted directory, return "", else a suitable comment.
 S TEMP=$P($ZU(49,D),",",1)
 IF $$NODIROS(D)=1 S TEMP=-3
 Q:TEMP=$zu(40,0,41) %U_" has not been mounted"   ;JAO742
 Q:TEMP=-3 "Operating system directory "_%U_" does not exist."
 Q:TEMP=-2 %U_"IRIS"_".DAT does not exist or is inaccessible."
 Q:TEMP=-1 %U_DMERR     ;"is [already] dismounted."
 Q:TEMP=0 ""
 Q "Unknown problem with "_%U_"."
Strip(x) Q $$StrHead($$StrTail(.x)) ;strip both leading and trailing spaces
StrHead(x) ;return 'x' without any leading spaces
 Q $E(x,$F(x,$E($TR(x," ")))-1,$L(x))
StrTail(x) ;return 'x' without any trailing spaces
 Q $P(x_$J("",$L(x)),$J("",$L(x)))
StrQuote(x) ; return 'x' without 1 layer of quotes
 I ($E(x)'="""")!($E(x,$L(x))'="""") Q x
 S x="S x="_x X x Q x
ChkDirVALID(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,1)
ChkDirEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkDirOrSpecEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,3)
ChkDir(R) N N S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkBad S $ZT="" W !,"<"_$P($P($ZE,"<",2),">")_"> error -- invalid directory"
 Q ""

DZCVTFILE^INT^1^67214,47330
DZCVTFILE ; Convert some sequential/RMS file types for cross-system compatibility
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	S $ZT="errmain"
	N cvtype,infile,outfile,err
getinput
	D DisplayOptions()
	R !!,"Enter Desired Option:  ",cvtype Q:cvtype=""  S cvtype=+cvtype
	I cvtype<1,cvtype>2 G getinput
	R !,"Source file for input:  ",infile I '$L(infile) G getinput
	R !,"Output file to create:  ",outfile I '$L(outfile) G getinput
	I '$$Convert(cvtype,infile,outfile,.err) {
		W !!,"Error occurred converting the file:  ",!,"  ",err
	} ELSE { W !!,"File successfully converted." }
	Q
errmain
	S $ZT=""
	W !,"Error:  "_$ZE
	Q
	; DisplayOptions()
	;   Write conversion options to current device
	; Returns: nothing
DisplayOptions() PUBLIC {
	W !!,"File Conversion Options: "
	W !,"1:  Reads an RMS variable length record format file (such as that"
	W !,"    created using COS variable record length file i/o on VMS), and"
	W !,"    outputs a file that is binary compatible with COS variable record"
	W !,"    length file i/o on UNIX and Windows.  The outputted file can be"
	W !,"    transferred to UNIX/Windows in a binary-compatible way such as"
	W !,"    binary FTP. This conversion must be performed on the VMS system."
	W !
	W !,"2:  Reads a file that was created on UNIX or Windows using COS variable"
	W !,"    record length file i/o and outputs an RMS file with variable record"
	W !,"    length.  The outputted file can be read on VMS using COS variable"
	W !,"    record length file i/o.  This coversion must be performed on VMS"
	W !,"    and the input file must be transferred from the source to VMS in a"
	W !,"    binary-compatible way such as binary FTP."
	W !
}
	; Convert()
	;   Converts between RMS file formats and Windows/UNIX
	; Returns: 1/0 for success/failure
	; Input Parameters
	;   cvtype - (required) type of conversion to perform
	;            See DisplayOptions() for allowed types and description
	;   infile - (required) file name to convert
	;   outfile - (required) file name to output
	; Output Parameters:
	;   err - error text set on failure return
Convert(cvtype,infile,outfile,err) PUBLIC {
	S $ZT="err",err="",opened=0
	S zu6840=$zu(68,40,1) ; use $ZEOF 
	S cvtype=$G(cvtype),infile=$G(infile),outfile=$G(outfile)
	I infile="" S err="Missing input file name" G retfail
	I outfile="" S err="Missing output file name" G retfail
	I cvtype=1 { ; prepare RMS "V" mode file to send to UNIX/Windows
		I '$$IsVMS() S err="This conversion must be run on a VMS system" G retfail
		S opened=$$OpenFiles(infile,outfile,"VR","WNU",.err) I 'opened G retfail
		F  U infile R x Q:$ZEOF  U outfile W $ZWCHAR($L(x)),x
	} 
	ELSEIF (cvtype=2) { ; convert UNIX/Windows "V" mode to RMS
		I '$$IsVMS() S err="This conversion must be run on a VMS system" G retfail
		S opened=$$OpenFiles(infile,outfile,"UR","WNV",.err) I 'opened G retfail
		F  {
			U infile R x#2 Q:$ZEOF  ; done conversion successfully
			; $ZEOF won't be set if there are fewer bytes than expected at the end of the file
			I $L(x)<2 S err="Unexpected end of file" G retfail
			S len=$ZWASCII(x) I 'len U outfile W "" CONTINUE
			R x#len I $ZEOF s err="Invalid input file format" G retfail
			; $ZEOF won't be set if there are fewer bytes than expected at the end of the file
			I $L(x)<len S err="Unexpected end of file" G retfail
			U outfile W x
		}
	}
	ELSE { ; default
		S err="Invalid conversion type specified"
		G retfail
	}
	I $ZU(68,40,zu6840)
	C infile,outfile
	Q 1
err 
	S $ZT=""
	S err="Unexpected error: "_$ZE
retfail
	I $ZU(68,40,zu6840)
	I $G(opened) C infile,outfile
	Q 0
}
	; OpenFiles()
	;   Opens two files in specified modes
	; Returns:
	;   1 on success
	;   0 on failure
	;   On failure return, both files will be closed.
	; Input Parameters:
	;   f1 - (required) first file name
	;   f2 - (required) second file name
	;   f1mode - (required) mode string for f1
	;   f2mode - (required) mode string for f2
	; Output Parameters:
	;   err - error text set on failure return
OpenFiles(f1,f2,f1mode,f2mode,err) PRIVATE {
	S $ZT="err",err="",opened=0
	O f1:f1mode:2 E  S err="Failed to open "_f1 Q 0
	S opened=1
	O f2:f2mode:2 E  C f1 S err="Failed to open "_f2 Q 0
	S opened=2
	Q 1
err 
	S $ZT=""
	I $G(opened) C f1 I opened=2 C f2
	S err="Unexpected error: "_$ZE
	Q 0
}
	; IsVMS()
	; Returns 1 if this is a VMS machine, 0 otherwise
IsVMS() PRIVATE { Q ($ZVERSION(1)=1) }

DeepSeeButtons^INT^1^67214,47330
DeepSeeButtons(namespace="ask", cubeString="ask", getLogs="", LogFile="", tracking="")
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	;DeepSeeButtons: routine to log system and DeepSee information
	;This can be launched from the %SYS namespace using: 
	;  %SYS>Do ^DeepSeeButtons
	;and can be launched from any other namespace using
	;  NAMESPACE>Do RunDSButtons^%SYS.DeepSee()
	;
	;You can use the following optional arguments:
	;namespace:		namespace where this routine will run, e.g. "SAMPLES". If "" the current namespace will be chosen
	;cubeString: 	comma separated list of cubes, e.g. "patients,holefoods", "ALL", or "" for no cubes at all
	;getLogs:		boolean flag to control inclusion of the cconsole.log, Query Log, and DeepSee logs. 
	;				A value of getLogs="" will prompt the user to make this choice from the interactive dialog 
	;LogFile:		output file. By default the output file will be stored in the /mgr directory
	;tracking:		Used to log progress into ^IRIS.Temp.DeepSeeButtonsTrack and track this routine
	;
	;Example using arguments:
	;Do ^DeepSeeButtons("SAMPLES","PATIENTS",1,"/home/amarin/Desktop/DSbuttons.html",0)
	;
	;
	;DeepSee Buttons includes the following general information 
	;	1) DeepSee Setup
	;		-Agent Count and cores
	;		-DeepSee.AuditCode, DeepSee.AuditQueryCode
	;		-Most recent activity in  Cube manager
	;		-Config section of cpf file
	;		-Important mappings
	;		-Server Initialization Code
	;		-Deepsee enabled webapps
	;	2) Server Details
	;		-Configuration
	;		-Customer name
	;		-License
	;		-Fully Qualified Host Name
	;		-User and date
	;		-Cache startup 
	;		-$ZV
	;		-Locale
	;		-Operating system
	;		-Disk space
	;		-RAM
	;	3) Cubes in namespace
	;		-Cubes table with Cube Name, Display name, Source Class, Cube Class, Related Cubes	
	;		-Versioned cubes
	;		-Abstract cubes
	;		-Cubes with Source Classes Based on SQL Storage
	;		-Cubes Based on Data Connectors
	;		-Build Order for Related Cubes
	;	4) Build/Synch
	;		-DSTIME
	;		-BuildSynchTable Table with Cube Name, Fact Count, Build Time, Build Rate, Build Errors, DSTIME, 
	;		 Last Compile, Last Build/Synch, Related Cubes
	;		-Build Errors
	;	5) Cube Registry Map
	;	6) Cube Info: Optional Extra data on a particular cube
	;		6A) Cube Info: display name, cube type, subject area class, inherits from, resource, source class, 
	;			fact class, caption, fact count, 
	;			build restrictions (maxfacts, buildrestriction/filterspec property, %OnProcessFact, and %OnGetFilterSpec), 
	;			last modified, DSTIME & DSINTERVAL, cube registry, build errors
	;		6B) Dimensions: dimension list, ^DeepSee.CalcMbrs, %Analyze, FieldNameToSpec, %AnalyzeMissing
	;		6C) Other Elements: Pivot variables, listing fields, listings, resources
	;	7) Query Log
	;		-Number of users runnign queries
	;		-User and Queries run
	;		-^DeepSee.LastQuery
	;		-Last 5 queries run by each user
	;	8) DeepSee Logs
	;	9) CPF file (includes mappings)
	;	10) cconsole.log
	;	11) Mappings - Show global mappings in the namespace
	;	12) Local Databases
	;	13) Task schedule
	;	14) Journaling
	;	15) Alerts
StartDialog
	New (namespace,cubeString,getLogs,LogFile,tracking)
	Set origNS=$Namespace
	Try {
		If '$system.Security.Check("%DeepSee_Admin","USE") {
			// Require %DeepSee_Admin in order to run this utility
			Write !,"This tool requires the %DeepSee_Admin resource to run"
			Quit
		}
		Do:tracking WriteTrack("setup","Starting DeepSeeButtons","")
		Set PDev=$Principal
		Use PDev
		Write !,"DeepSee Diagnostic Report Evidence Logging Tool"
		Write !,"This reporting tool provides the information required for"
		Write !,"InterSystems Technical Support to analyze DeepSee issues. "
		Set namespace=$$GetNamespace(namespace)
		Quit:namespace=""
		Set cubeList=$$GetCubesToLog(cubeString,namespace,tracking)
		//Later do not ask to confirm to proceed if anything was passed to getLogs argument
		Set proceed=(getLogs'="")
		Do:getLogs="" GetLogsConfirm
		Do:'proceed ReadLogTypeConfirm
		Quit:'proceed		
		Kill:tracking ^IRIS.Temp.DeepSeeButtonsTrack
		Do LaunchLogs(namespace,cubeList,getLogs)
 	} Catch(ex) {
		Set tSC = ex.AsStatus()
		Set msg = $System.Status.GetErrorText(tSC)
		Do:tracking WriteTrack("error","","",msg)
		Use $Principal
		Write !,msg
 	}
 	zn origNS
	Quit
GetNamespace(namespace) {
	//If namespace is "" choose the current namespace
	If namespace="" {
		Set namespace = $Namespace
		Write !,"Running in namespace: "_namespace
	}
	//Ask user if the namespace variable is not given
	Set:namespace="ask" namespace=""
	Set namespace=$$ValidateNamespace(namespace)	//Make sure input namespace exists
	While namespace="" {		//User didn't enter a namespace when calling routine
		Write !!,"Type namespace ["_$Namespace_"]"
		Read namespace
		Set:namespace="" namespace = $Namespace
		If namespace="?" {
			Do ListNamespaces()
			Set namespace=""
			Continue
		}
		Set namespace=$$ValidateNamespace(namespace)
	}
	Quit namespace
}
ListNamespaces() {
	Write !,"Available Namespaces:",!
	Do ##class(%SYS.Namespace).ListAll(.nsarray)
	Set ns=$O(nsarray(""))
	While ns'="" {
		Write ns,!
		Set ns=$O(nsarray(ns))
	}
	Quit
}
GetCubesToLog(cubeString,namespace,tracking=0) {
	If cubeString="ask" {
		Set allcubeList=$$DialogCubes(namespace)
	} ElseIf cubeString="" {
		Set allcubeList=""
	} ElseIf $LISTVALID(cubeString) {
		Set allcubeList=cubeString
	} ElseIf cubeString="ALL"{
		Set cubeString=$$GetAllCubes(namespace)
		Set allcubeList=$LFS(cubeString,",")
	} Else {
		Set allcubeList=$LFS(cubeString,",")
	}
	Set cubeList=$$VerifyInputCubes(allcubeList,namespace,tracking)
	Quit cubeList
}
GetLogsConfirm
	ZN "%SYS"	
	Write !, "Include "_$select(##class(%SYSTEM.Version).GetProduct()["IRIS":"messages.log",1:"cconsole.log")_", Query Log, and DeepSee Logs? [Y] "
	Read getLogs
	Set getLogs=$ZCONVERT(getLogs,"U")
	If (getLogs="") {
		Set getLogs=1		//If the user did not make a selection, add console and query logs
	} ElseIf (getLogs="N")||(getLogs="NO") {
		Set getLogs=0
	} ElseIf (getLogs="Y")||(getLogs="YES") {
		Set getLogs=1
	} ElseIf (getLogs=+getLogs) { 
		//secret option: if getLogs is a number it controls the number of queries by user shown
		//Just pass getLogs on
	} Else { 
		Write !,"Please enter Y or N"	
		Set getLogs=""
		Goto GetLogsConfirm
	}
	Quit
ReadLogTypeConfirm
	Write !,"Continue? [Y] " Read LogType
	Set LogType=$ZCONVERT(LogType,"U")
	If ((LogType="NO")!(LogType="N")!(LogType="Q")!(LogType="QUIT")) {
		Set proceed=0 } 
	ElseIf ((LogType="YES")!(LogType="Y")!(LogType="")) {
		Set proceed=1
	} Else {
		Write !,"Please enter Y or N" Goto ReadLogTypeConfirm
	}
	Quit proceed
LaunchLogs(namespace,cubeList,getLogs)
 	Try {
		Set CacheVerNumber=$System.Version.GetNumber()
		If +CacheVerNumber<5 { //Do  Quit Return
			Set Message="*** Wrong version of Diagnostic Report utility ! ***"_$Char(13,10)_$Char(13,10)_"You are running on Cache "_
						CacheVerNumber_" and this is the code for Cache 5.0 and later"
			Use PDev Write:$X ! Write !,Message
			Set Return="0|"_Message
			Quit
		}
		Use PDev Write:$X ! 
		Write "Collecting information, please do not interrupt this process.",!,"Do not close terminal until the process has completed"
 		Break 0
		Set EOF=$ZUtil(68,40)	
		//Start logging with the DeepSee Setup section 
		Set output=$$LogSections(cubeList,getLogs,LogFile)
		If $E(output,1,5)="Error" {
			Do:tracking WriteTrack("error","","",output_". Check your output path and permissions")
			W !,output," Abort",!
			Return
		} Else {
			Set LogFile = output
		}
		Set rc=1
		If $ZUtil(68,40,EOF) //Reset $ZEOF to the original setting
		Break 1 
		If LogFile="" { //Do  Quit Return
			Set Message="*** Log file could not be created in "_LogDirectory_". Check directory permissions. ***"
			Use PDev Write:$X ! Write !,Message
			Set Return="0|"_Message
			Quit
		}
		Use PDev
		Write:$X ! Write !,"DeepSeeButtons report saved to: ",!,LogFile
		Write !,"Please send the html file above to InterSystems Support."
	} Catch(ex) {
		Set tSC = ex.AsStatus()
		Do $System.Status.DisplayError(tSC)
		Do:tracking WriteTrack("error","","",$System.Status.GetErrorText(tSC))
	}
	Quit
OpenLogFile(LogFile,FileOpenTimeOut) {
	//Compared to ^Buttons the file is opened here, not in NewFile
	Open LogFile:"RWNSK\UTF8\":FileOpenTimeOut
	If '$Test Quit "Error opening file "_LogFile
	Quit LogFile
}
LogSections(cubeList,getLogs,LogFile)
	New (LogDirectory,namespace,cubeList,getLogs,LogFile,MgrDir,tracking)
	Do Init
	Set LogFile = $$InitLogFile
	Set out = $$OpenLogFile(LogFile,FileOpenTimeOut)
	If $E(out,1,5)="Error" Quit out
	If OS?1"***".e Quit ""
	Do LogHead(cubeList,getLogs)
	Do LogOpenMainDiv
	Do LogDeepSeeSetupSection   //Note Ale: here rs.%Execute("") messes up my ZW in DumpToFile
	Do LogServerSetup
	Do LogCubeSection
	Do LogBuildSynchSection
	Do LogCubeRegistry
	Do:(($D(cubeList)'=0) && (cubeList'="")) LogDetailedCubeInfo
	Do:getLogs>0 LogQuerylog
	Do:getLogs>0 LogDeepSeelog
	Do LogCPF
	Do:getLogs>0 LogCConsole
	Do LogMappings
	Do LogDataBases
	Do LogTasks
	Do LogJournal
	Do LogAlerts
	Do LogTrailer
	Do LogSidePanel(cubeList,getLogs,$G(alerts,0))	
	Do LogCloseBody
	ZN "%SYS"
	Close LogFile
	Quit LogFile
LogHead(cubeList,getLogs)
	//Writes the Header record
	Try {
	New %DAT,%TIM,x //,Build
	//Set x=$Text(+1),Build=$Piece(x,";",5),Build=$Piece(Build," ",2)
	Set colspan=12 If OS="UNIX" Set colspan=13
 	Use LogFile
 	Do WriteLog("<!DOCTYPE html>")
	Do WriteLog("<html>")
	Do WriteLog("<head>")
	Do WriteLog("<meta charset=""UTF-8"">")
	Do WriteLog("<meta http-equiv=""Content-type"" content=""text/html; charset=UTF-8"">")
	Do WriteLog("<title>",2)
	Do WriteLog("DeepSee Diagnostic Log for "_CustomerName ,4)
	Do WriteLog("</title>",2)
	Do WriteLog("<meta http-equiv=""Content-Type"" content=""text/html; charset=UTF-8"">",2)
	Do WriteLog("<script type=""text/javascript"">",2)
	/// toggle function
	Do WriteLog("function toggle(showHideDiv, switchTextDiv) {",4)
	Do WriteLog("var ele = document.getElementById(showHideDiv);",6)
	Do WriteLog("var text = document.getElementById(switchTextDiv);",6)
	Do WriteLog("if(ele.style.display == ""block"") {",6)
    Do WriteLog("ele.style.display = ""none"";",8) 
    Do WriteLog("text.innerHTML = ""&rtrif; Expand"";",8)
    Do WriteLog("}",6)
	Do WriteLog("else {",6)
    Do WriteLog("ele.style.display = ""block"";",8)
    Do WriteLog("text.innerHTML = ""&dtrif; Collapse"";",8)
	Do WriteLog("}",6)
	Do WriteLog("}",4)
	/// openNav function
    Do WriteLog("function openNav() {",4)
    Do WriteLog("document.getElementById(""mySidenav"").style.width = ""200px"";",6)
    Do WriteLog("document.getElementById(""main"").style.marginLeft = ""200px"";",6)
    Do WriteLog("}",4)
    Do WriteLog("function closeNav() {",4)
    Do WriteLog("document.getElementById(""mySidenav"").style.width = ""0px"";",6)
    Do WriteLog("document.getElementById(""main"").style.marginLeft= ""0px"";",6)
    Do WriteLog("}",4)
    /// highlightLink function
    Do WriteLog("function highlightLink(obj, mousein) {",4)
    Do WriteLog("bkg=(mousein ? 'rgb(68, 168, 223)' : '');",6)
    Do WriteLog("color=(mousein ? 'white' : '');",6)
    Do WriteLog("document.getElementById('l'+obj.id).style.background=bkg;",6)
    Do WriteLog("document.getElementById('l'+obj.id).style.color=color;",6)
    Do WriteLog("}",4)
	/// sortTable function
    Do WriteLog("function sortTable(elem,n,stringSort) {",4)
  	Do WriteLog("var table, rows, switching, i, x1, x2, shouldSwitch, dir, switchcount = 0;",6)
    Do WriteLog("//Climb up the table structure to find the <table> element",6)
    Do WriteLog("table = elem;",6)
    Do WriteLog("while(table.tagName!=""TABLE"") {",6)
    Do WriteLog("table = table.parentElement;",8)
    Do WriteLog("}",6)
  	Do WriteLog("switching = true;",6)
  	Do WriteLog("//Set the sorting direction to ascending:",6)
  	Do WriteLog("dir = 'asc'; ",6)
  	Do WriteLog("while (switching) {",6)
    Do WriteLog("switching = false;",8)
    Do WriteLog("rows = table.getElementsByTagName('TR');",8)
    Do WriteLog("//Loop through all table rows after the first",8)
    Do WriteLog("for (i = 1; i < (rows.length - 1); i++) {",8)
    Do WriteLog("shouldSwitch = false;",10)
    Do WriteLog("//Get the two adjacent elements to be compared",10)
    Do WriteLog("x1 = rows[i].getElementsByTagName('TD')[n].innerHTML;",10)
    Do WriteLog("x2 = rows[i+1].getElementsByTagName('TD')[n].innerHTML;",10)
    Do WriteLog("//Get sorting if undefined: string or number?",10)
    Do WriteLog("if (typeof stringSort === 'undefined') {",10)
    Do WriteLog("var stringSort = isNaN(x1) | isNaN(x2)",12)
    Do WriteLog("}",10)
    Do WriteLog("x1val = stringSort ? x1.toLowerCase() : +x1.replace(/,/g, '');",10)
    Do WriteLog("x2val = stringSort ? x2.toLowerCase() : +x2.replace(/,/g, '');",10)
    Do WriteLog("//When sorting numerically empty string or NA as -Infinity",10)
	Do WriteLog("if ((!stringSort)&&((x1=='')||(x1=='NA'))) {",10)
    Do WriteLog("x1val = -Infinity;",12)
	Do WriteLog("}",10)
	Do WriteLog("if ((!stringSort)&&((x2=='')||(x2=='NA'))) {",10)
	Do WriteLog("x2val = -Infinity;",12)
	Do WriteLog("}",10)
    Do WriteLog("if (dir == 'asc') {",10)
    Do WriteLog("if (x1val > x2val) {",12)
    Do WriteLog("//Mark as a switch and break the loop",14)
	Do WriteLog("shouldSwitch= true;",14)
	Do WriteLog("break;",14)
	Do WriteLog("}",12)
	Do WriteLog("} else if (dir == 'desc') {",10)
    Do WriteLog("if (x1val < x2val) {",12)
    Do WriteLog("//Mark as a switch and break the loop",14)
    Do WriteLog("shouldSwitch= true;",14)
	Do WriteLog("break;",14)
	Do WriteLog("}",12)
	Do WriteLog("}",10)
    Do WriteLog("}",8)
    Do WriteLog("if (shouldSwitch) {",8)
	Do WriteLog("//Make the switch when marked",10)
	Do WriteLog("rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);",10)
	Do WriteLog("switching = true;",10)
	Do WriteLog("switchcount ++; ",10)
    Do WriteLog("} else {",8)
	Do WriteLog("//If no switching AND dir = as,set dir to desc and rerun while loop",10)
	Do WriteLog("if (switchcount == 0 && dir == 'asc') {",10)
	Do WriteLog("dir = 'desc';",12)
	Do WriteLog("switching = true;",12)
	Do WriteLog("}",10)
    Do WriteLog("}",8)
	Do WriteLog("}",6)
	Do WriteLog("//Show or remove the triangles",6)
	Do WriteLog("console.log('Table: ',table.id,', Column: ',n,', Sorting: ',dir,stringSort?'string':'numeric')",6)
	Do WriteLog("var ths = table.getElementsByTagName('TH')",6)
	Do WriteLog("for (i = 0; i < ths.length; i++) {",6)
	Do WriteLog("ths[i].innerHTML = ths[i].innerHTML.replace(' \u25B4','');",8)
	Do WriteLog("ths[i].innerHTML = ths[i].innerHTML.replace(' \u25BE','');",8)
	Do WriteLog("if (i == n) {",8)
	Do WriteLog("ths[i].innerHTML = ths[i].innerHTML + ((dir == 'asc') ? ' &#x25BE;': ' &#x25B4;');",10)
	Do WriteLog("}",8)
	Do WriteLog("}",6)
	Do WriteLog("}",4)
	/// onload: call openNav to open the side panel
	Do WriteLog("window.onload = openNav;",4)
  	Do WriteLog("</script>",2)
  	/// Style section
	Do WriteLog("<style>",2)
	Do WriteLog("pre {",4)
 	Do WriteLog("white-space: pre-wrap;       /* css-3 */",6)
 	Do WriteLog("white-space: -moz-pre-wrap;  /* Mozilla, since 1999 */",6)
 	Do WriteLog("white-space: -pre-wrap;      /* Opera 4-6 */",6)
 	Do WriteLog("white-space: -o-pre-wrap;    /* Opera 7 */",6)
 	Do WriteLog("word-wrap: break-word;       /* Internet Explorer 5.5+ */",6)
	Do WriteLog("}",4)
	Do WriteLog(".sidenav {",4)
	Do WriteLog("box-sizing: border-box;",6)
	Do WriteLog("height: 100%;",6)
	Do WriteLog("width: 0;",6)
	Do WriteLog("resize: horizontal;",6)
	Do WriteLog("position: fixed;",6)
	Do WriteLog("z-index: 1;",6)
	Do WriteLog("top: 0;",6)
	Do WriteLog("left: 0;",6)
	Do WriteLog("background-color: rgb(220,231,241);",6)
	Do WriteLog("overflow-x: hidden;",6)
	Do WriteLog("transition: 0.75s;",6)
	Do WriteLog("padding-top: 60px;",6)
	Do WriteLog("}",4)
	Do WriteLog(".sidenav a {",4)
	Do WriteLog("font-family: Arial, Helvetica, sans-serif;",6)
	Do WriteLog("font-weight: bold;",6)
	Do WriteLog("padding: 8px 8px 8px 8px;",6)
	Do WriteLog("text-decoration: none;",6)
	Do WriteLog("font-size: 20px;",6)
	Do WriteLog("color: blue;",6)
	Do WriteLog("display: block;",6)
	Do WriteLog("transition: 0.3s;",6)
	Do WriteLog("}",4)
	Do WriteLog(".sidenav a:hover, .offcanvas a:focus{",4)
	Do WriteLog("font-family: Arial, Helvetica, sans-serif;",6)
	Do WriteLog("color: white;",6)
	Do WriteLog("}",4)
	Do WriteLog(".sidenav .closebtn {",4)
	Do WriteLog("position: absolute;",6)
	Do WriteLog("top: 0;",6)
	Do WriteLog("right: 0px;",6)
	Do WriteLog("font-size: 36px;",6)
	Do WriteLog("margin-left: 50px;",6)
	Do WriteLog("}",4)
	Do WriteLog(".sidenav .red {",4)
    Do WriteLog("color: red;",6)
    Do WriteLog("}",4)	
	Do WriteLog("#main {",4)
	Do WriteLog("transition: margin-left .5s;",6)
	Do WriteLog("padding: 16px;",6)
	Do WriteLog("}",4)
	Do WriteLog("@media screen and (max-height: 450px) {",4)
	Do WriteLog(".sidenav {padding-top: 15px;}",6)
	Do WriteLog(".sidenav a {font-size: 18px;}",6)
	Do WriteLog("}",4)
	Do WriteLog(".sidenav .cubelinks {",4)
    Do WriteLog("font-size: 14px;",6)
    Do WriteLog("text-decoration: none;",6)
    Do WriteLog("margin-left: 30px;",6)
    Do WriteLog("}",4)
	Do WriteLog(".trapezoid {",4)
	Do WriteLog("top: 0px;",6)
	Do WriteLog("width: 0px;",6)
	Do WriteLog("left: 0px;",6)
	Do WriteLog("opacity: 0.5;",6)
	Do WriteLog("text-align: center;",6)
	Do WriteLog("height: 25px; ",6)
	Do WriteLog("position:fixed;",6)
	Do WriteLog("border-top: 20px solid transparent;",6)
	Do WriteLog("border-left: 25px solid rgb(185,207,227);",6)
	Do WriteLog("border-bottom: 20px solid transparent;",6)
	Do WriteLog("box-sizing: content-box;",6)
	Do WriteLog("}",4)
	Do WriteLog(".trapezoid span { ",4)
	Do WriteLog("position: absolute;",6)
	Do WriteLog("left: -20px;",6)
	Do WriteLog("top: 15%;",6)
	Do WriteLog("color: blue;",6)
	Do WriteLog("}",4)
	Do WriteLog(".trapezoid span:hover, .offcanvas a:focus{",4)
	Do WriteLog("color: rgb(104,30,30);",6)
	Do WriteLog("opacity: 0.1;",6)
	Do WriteLog("}",4)
    Do WriteLog(".zebraStriped tbody tr:nth-child(odd) {",4)
    Do WriteLog("background-color: #ccc;",6)
    Do WriteLog("border-right: 2px solid #D0D0D0;",6)
    Do WriteLog("border-left: 2px solid #D0D0D0;",6)
    Do WriteLog("border-bottom: 2px solid #D0D0D0;",6)
    Do WriteLog("border-top: 2px solid #D0D0D0;",6)
	Do WriteLog("}",4)
	Do WriteLog(".zebraStriped td {",4)
    Do WriteLog("border-right: 2px solid #D0D0D0;",6)
    Do WriteLog("border-left: 2px solid #D0D0D0;",6)
    Do WriteLog("border-bottom: 2px solid #D0D0D0;",6)
    Do WriteLog("border-top: 2px solid #D0D0D0;",6)
	Do WriteLog("}",4)
    Do WriteLog(".scrollable {",4)
    Do WriteLog("overflow:auto;",6)
    Do WriteLog("resize:both;",6)
	Do WriteLog("}",4)
    Do WriteLog(".wrapped {",4)
    Do WriteLog("white-space: -moz-pre-wrap; /* Mozilla, supported since 1999 */",6)
    Do WriteLog("white-space: -pre-wrap; /* Opera */",6)
    Do WriteLog("white-space: -o-pre-wrap; /* Opera */",6)
    Do WriteLog("white-space: pre-wrap; /* CSS3 - Text module (Candidate Recommendation) http://www.w3.org/TR/css3-text/#white-space */",6)
    Do WriteLog("word-wrap: break-word; /* IE 5.5+ */",6)
	Do WriteLog("}",4)
    Do WriteLog(".tableWithBorders {",4)
    Do WriteLog("position: relative;",6)
    Do WriteLog("visibility: visible;",6)
    Do WriteLog("table-layout: fixed;",6)
    Do WriteLog("padding: 0px;",6)
    Do WriteLog("height: auto;",6)
    Do WriteLog("font-family: Arial;",6)
    Do WriteLog("border-collapse: collapse;",6)
    Do WriteLog("border-right: 2px solid #D0D0D0;",6)
    Do WriteLog("border-left: 2px solid #D0D0D0;",6)
    Do WriteLog("border-bottom: 2px solid #D0D0D0;",6)
    Do WriteLog("border-top: 2px solid #D0D0D0;",6)
	Do WriteLog("}",4)    
    Do WriteLog(".tableWithBorders th {",4)
    Do WriteLog("height: 22px;",6)
    Do WriteLog("overflow: hidden;",6)
    Do WriteLog("text-align: left;",6)
    Do WriteLog("border-bottom: 2px solid #D0D0D0;",6)
	Do WriteLog("}",4)
    Do WriteLog(".tableWithBorders td {",4)
    Do WriteLog("border-right: 1px solid #E8E8E8;",6)
    Do WriteLog("border-bottom: 1px solid #E8E8E8;",6)
    Do WriteLog("overflow: hidden;",6)
    //Do WriteLog("word-wrap:break-word;",6)
    //Do WriteLog("background: white;",6)
	Do WriteLog("}",4)	
	Do WriteLog(".grey {",4)
    Do WriteLog("background: #ccc;",6)
    Do WriteLog("}",4)
	Do WriteLog(".darkgrey {",4)
    Do WriteLog("background: #7a7a7a",6)
    Do WriteLog("}",4)
	Do WriteLog(".red {",4)
    Do WriteLog("color: red;",6)
    Do WriteLog("}",4)    
    Do WriteLog(".bold {",4)
    Do WriteLog("font-size: 15px;",6)
    Do WriteLog("font-weight: bold;",6)
    Do WriteLog("}",4)    
	Do WriteLog(".tableTabbed p,h5 {",4)
    Do WriteLog("padding-left: 4ch;",6)
    Do WriteLog("}",4)
    Do WriteLog("div a:hover {",4)
    Do WriteLog("background: rgb(40,94,124);",6)
	Do WriteLog("}",4)
	Do WriteLog("</style>",2)
	Do WriteLog("</head>")
	} Catch(ex) {
		Set tSC = ex.AsStatus()
		Do WriteLog(tSC)
	}
	Quit
LogOpenMainDiv()
	Do WriteLog("<body bgcolor=""#FFFFFF"" text=""#000000"">")
	Do WriteLog("<div id=""main"">")
	Do WriteLog("<a name=""top""></a>")
	Do WriteLog("<h1 title=""Version v0.1.7"">DeepSeeButtons - DeepSee diagnostic report</h1>")
	Quit
LogDeepSeeSetupSection
	//Begin body tag
	Try {
		//Do WriteLog("<body bgcolor=""#FFFFFF"" text=""#000000"">")
		Do WriteLog("<div class=""trapezoid"">")
		Do WriteLog("<span onclick=""openNav()""> &#9776; </span>",2)
		Do WriteLog("</div>")
		Do WriteUpdate("Getting system information")
		Do:tracking WriteTrack("setup","Getting system information","")
		Do WriteLog("<div id=""DSSetupDiv"" onmouseover=""highlightLink(this,1)"" onmouseout=""highlightLink(this,0)"">")
		Do WriteParagraph("deepseesetup","DeepSee Setup in "_namespace,0)
 		//Agent Count
 		ZN namespace
	 	Set count=##class(%DeepSee.Utils).%GetAgentCount()
	 	If count=""{
	 		Set tCPU=##class(%SYSTEM.CPU).%New()
	 		Set cores = tCPU.nCores
	 		Set counthigh=cores*4
	 		Set defaultagents="Default agent count"
	 		Set countstring=cores_" cores x 8 = "_(counthigh*2)_" agents  ("_counthigh_" high- and "_counthigh_" low-priority agents)"
 		} Else {
		 	Set defaultagents="Non-default agent count"
	 		Set countstring=(count*2)_" agents  ("_count_" high- and "_count_" low-priority agents)"
	 	}
 		ZN "%SYS"
 		Use LogFile
 		Do WriteLog("<table id=""DSSetupTable"" cellpadding=""7"" cellspacing=""3"" "_
 	            "class=""tableWithBorders tableTabbed"">",2)
  		Do WriteLog("<tbody>",4)
    	Do WriteLog("<tr>",6)
    	Do WriteLog("<td>",8)
 		Do WriteHeader4("Agent Count",10)
 		Do WriteLog("<p>"_defaultagents_"</p>",10)
 		Do WriteLog("<p>"_countstring_"</p>",10)	
 		Do WriteLog("</td>",8)
 		Do WriteLog("</tr>",6)
 		Do WriteLog("<tr>",6)
		Do WriteLog("<td>",8)
		//Audit section
 		Do GetDeepSeeAuditCode
 		Do WriteLog("</td>",8)
		Do WriteLog("</tr>",6)
 		Do WriteLog("<tr>",6)
		Do WriteLog("<td>",8)
 		Do WriteHeader4("Most Recent Activity in Cube Manager",10)
 		ZN namespace
 		Set msgbuild=$$GetLastBuild("Build")						//Get last build, synch, and update info
 		Set msgsynch=$$GetLastBuild("Synch")
 		Set msgupdate=$$GetLastBuild("Update")
 		Set msgrepair=$$GetLastBuild("Repair")
 		Do WriteLog("<p>Build event:  "_msgbuild_"</p>",10)
 		Do WriteLog("<p>Synch event:  "_msgsynch_"</p>",10)
 		Do WriteLog("<p>Registry Update event: "_msgupdate_"</p>",10)
 		Do WriteLog("<p>Repair event: "_msgrepair_"</p>",10)
 		//Cycle through all enabled cubes in cube manager and alert if ther are no build or repair events
 		Set rs=##class(%Library.ResultSet).%New("%DeepSee.CubeManager.RegistryMap:RegistryMapTableView")
		Set registered = ""
		Set state = ""
		Do rs.Execute()
		While (rs.Next()) {
			Set cube=rs.Get("CubeKey")
			Set state = rs.Get("Disabled")
			Set state = $S(state="Yes":"disabled",state="No":"enabled",1:"unknown")
			If ((rs.Get("IsRegistered")="Yes") && (rs.Get("Disabled")="No")) {
				Set msgbuild=$$GetLastBuild("Build",cube)	//Get last build
				Set msgrepair=$$GetLastBuild("Repair",cube)	//Get last repair
				Do:(state="enabled") alertInitialBuildCubeManager(cube,msgrepair,msgbuild,.alerts)
			}
		}
	 	ZN "%SYS"
	 	Do WriteLog("</td>",8)
		Do WriteLog("</tr>",6)
	 	/// Important Mappings subsection
	 	Set NsMap=""
		Set MirCount=0
		Set ECPCount=0
		Set isMirror=0
		Set isECP=0
		Set GlobalKSize=""
		Set RoutineSize=""
		Set bbsiz=""
			Do WriteLog("<tr>",6)
			Do WriteLog("<td>",8)	
			Do WriteHeader4("Config section of cpf file",8)
			Open ConfigFile:"R":FileOpenTimeOut
			If '$Test {
				Do WriteLog("<p>Error: could not open Cach&eacute; Configuration File "_ConfigFile_"</p>",10)
			} Else {
				For {
					Use ConfigFile
					Read x:FileReadTimeOut
					If $p(x,".",1)="[Map" {				//Grab namespace we are mapping from
						Set NsMap=x 						//Returns eg [Map.Analytics]
						Set NsMap=$p($p(NsMap,".",2),"]",1) 	//Returns eg Analytics
						Set MapCount=0 					//Reset counter for number of mappings within this namespace 
					}
					If x["Global_OBJ.DSTIME"{			//Grab OBJ.DSTIME mapping
						Set DSTimeMapTo=$p(x,"=",2)		//Namespace it is mapped to
						Set DSTimeMapFrom(NsMap)=DSTimeMapTo
					}
					If x["Global_DeepSee"{	//Create array of DeepSee.* global mappings within this namespace
						Set MapCount=$I(MapCount)
		 				Set DeepSeeMap(NsMap,MapCount)=x			
					}
					If x["[Mirrors]" Set isMirror=1		//We are in mirror section
					If isMirror=1{					
					If x=""{
						Set isMirror=0				//Mirror section has ended
					} Else {						//Store mirror information
						Set MirCount=$I(MirCount)
						Set MirArray(MirCount)=x
					}
				}
				If x["[ECPServers]" Set isECP=1		//We are in ECP section
				If isECP=1{
					If x=""{
						Set isECP=0					//ECP section has ended
					} ElseIf x'["[ECPServers]" {
						Set ECPCount=$I(ECPCount)	//Store ECP info
						Set ECPArray(ECPCount)=x
					}
				}
				//Store important values from cpf - Config section
				If x["[config]" Set configSect=1		//We are in Config section
				If x["[Miscellaneous]" Kill configSect	//Config section is over
				If $D(configSect) {
					If x["globals" Set GlobalKSize=$P(x,"globals=",2)
					If x["routines=" Set RoutineSize= $P(x,"routines=",2)
					If x["bbsiz=" Set bbsiz= $P(x,"=",2)
					}
				Quit:x["[Miscellaneous]"				//We have passed all information we are interested in, just quit
			}
			Close ConfigFile
			Do WriteLog("<p>globals="_GlobalKSize_"</p>",10)
			Do WriteLog("<p>routines="_RoutineSize_"</p>",10)
			Do WriteLog("<p>bbsiz="_bbsiz_"</p>",10)
			Set sc = $$alertGlobalKSize(GlobalKSize,.alerts)
			Set sc = $$alertRoutineSize(RoutineSize,.alerts)	
		}
		Do WriteLog("</td>",8)
		Do WriteLog("</tr>",6)
		//Important mapppings
		Do WriteLog("<tr>",6)
		Do WriteLog("<td>",8)
		Do WriteHeader4("Important Mappings",10)
		ZN "%SYS"
		Set status=##Class(Config.Namespaces).Get(namespace,.nsprop)
		Do:status=1 WriteLog("<p>Default DBs for globals and routines: "_nsprop("Globals")_", "_nsprop("Routines")_"</p>",10)
		If '$D(DSTimeMapFrom(namespace)){
			Do WriteLog("<p>^OBJ.DSTIME: no mappings defined</p>",10)
			Set pre="title=""Mapping ^OBJ.DSTIME to a separate database is recommended"">"
			Set alert = "Alert: No mapping for ^OBJ.DSTIME"
			Set alerts($I(alerts)) = pre_alert
			Do WriteLog("<p class=""red"" "_pre_alert_"</p>",8)
		} Else{
			Do WriteLog("<p>^OBJ.DSTIME: mapped to "_DSTimeMapFrom((namespace))_"</p>",10)
		}
		//DeepSeeMap is structured as follows: DeepSeeMap(namespace,mapping number)
 		If NsMap'="" {
			If $D(DeepSeeMap(namespace,1)){
				Set NumMaps=$O(DeepSeeMap(namespace,""))
				While NumMaps {					
					Do WriteLog("<p>"_DeepSeeMap(namespace,NumMaps)_"</p>",10)
					Set NumMaps=$O(DeepSeeMap(namespace,NumMaps))
				}
			}
			Set sc = $$alertCacheMappings(namespace,.alerts)
			Set sc = $$alertJoinIndexMappings(namespace,.alerts)
			If $D(DSTimeMapFrom(namespace)){
				Set sc = $$alertDStimeRW(DSTimeMapFrom(namespace),.alerts)
			}
			Set sc = $$alertAgentMappings(namespace,.alerts)
		}	
		Do WriteLog("</td>",8)
		Do WriteLog("</tr>",6)
		If ECPCount'=0{
			Do WriteLog("<tr>",6)
			Do WriteLog("<td>",8)
			Do WriteHeader4("ECP Servers",10)
			Do WriteLog("<p>",10)
			For i=1:1:ECPCount{
				Write ECPArray(i),!
			}
			Do WriteLog("</p>",10)
			Do WriteLog("</td>",8)
			Do WriteLog("</tr>",6)		
		}
		If MirCount'=0{
			Do WriteLog("<tr>",6)
			Do WriteLog("<td>",8)
			Do WriteHeader4("Mirroring Info",10)
			Do WriteLog("<p>",10)
			For i=1:1:MirCount{
				Write MirArray(i),!
			}
			Do WriteLog("</p>")
			Do WriteLog("</td>",8)
			Do WriteLog("</tr>",6)
		}
		//Initialization code
		Do WriteLog("<tr>",6)
		Do WriteLog("<td>",8)
		Do WriteHeader4("Server Initialization Code",8,"Defined in the ^DeepSee.InitCode global")
		Try {
			If $D(^[namespace]DeepSee.InitCode){
				Set initcode=$g(^[namespace]DeepSee.InitCode)
				Do WriteLog("<p>^DeepSee.InitCode: "_initcode_"</p>",10)
			} Else{
				Do WriteLog("<p>^DeepSee.InitCode is undefined"_initcode_"</p>",10)
			}
		} Catch {
			Do WriteLog("<p>Not Available</p>",10)
		}
		Do WriteLog("</td>",8)
		Do WriteLog("</tr>",6)
		//Webapps that are deepsee enabled
		Do WriteLog("<tr>",6)
		Do WriteLog("<td>",8)
		Do WriteHeader4("DeepSee-enabled namespaces",10)
		Do ##class(%CSP.Portal.Utils).%GetNamespaceList(.nsList)
		SET ns=$o(nsList(""))
		While ns'="" {
			If ##class(%DeepSee.Utils).%IsDeepSeeEnabled(ns) {
				Do WriteLog("<p>"_ns_" with default webapp: "_$system.CSP.GetDefaultApp(ns)_"</p>",10)
			}
			Set ns=$O(nsList(ns))
		}
		Do WriteLog("</td>",8)
		Do WriteLog("</tr>",6)
		//DeepSee overrides
		If (isInsight || isTrak) {
			If (nOverrides<10) {
				Do WriteLog("<tr>",4)
				Do WriteLog("<td>",6)
				Do WriteHeader4("DeepSee Overrides",10)
				Do PrintGlobal(namespace,"^DeepSee.Overrides",10)
				Do WriteLog("</td>",8)
				Do WriteLog("</tr>",6)	
				Do WriteLog("</tbody>",4)
	 			Do WriteLog("</table>",2)
			} Else {
				//If there are many overrides place them in a scrollable div
				Do WriteLog("</tbody>",4)
 				Do WriteLog("</table>",2)
		 		Do WriteLog("<hr noshade size=""4"">")
				Do WriteLog("<a name=""overrides""</a>")
				Do WriteLog("<h2>DeepSee Overrides</h2>")
				Do WriteLog("<div class=""scrollable"" style=""width:100%;height:400px;"">")
				Do PrintGlobal(namespace,"^DeepSee.Overrides",2)
				Do WriteLog("</div>")
 			}	
		} Else {
			Do WriteLog("</tbody>",4)
 			Do WriteLog("</table>",2)
		}
	} Catch(ex) {
		Set tSC = ex.AsStatus()
		Do WriteLog("Error in LogDeepSeeSetupSection: "_tSC,0)
		Do WriteLog("</tbody>",4)
 		Do WriteLog("</table>",2)
	}
	Do WriteLog("</div>")
	Quit
LogServerSetup()
	///Server Details section
	Do WriteLog("<div id=""ServerDetailsDiv"" onmouseover=""highlightLink(this,1)"""_
	            " onmouseout=""highlightLink(this,0)"">")
	Do WriteParagraph("serverdetails","Server Details",1)
	///The old "Configuration" section
	Do WriteLog("<table id=""ServerDetailsTable"" cellpadding=""7"" cellspacing=""3"" "_
	            "class=""tableWithBorders tableTabbed"">",2)
  	Do WriteLog("<tbody>",4)
	Do WriteLog("<tr>",6)
	Do WriteLog("<td>",8)
	Do WriteHeader4("Configuration",10)
	Do WriteLog("<p>"_ConfigName_" on Machine """_HostName_""""_"</p>",10)
	Do WriteLog("</td>",8)
	Do WriteLog("</tr>",6)	
	Do WriteLog("<tr>",6)
	Do WriteLog("<td>",8)
	If CustomerName'?1a.e Set CustomerName="Unknown"
	Do WriteHeader4("Customer Name",10)
	Do WriteLog("<p>"_CustomerName_"</p>",10)
	Do WriteLog("</td>",8)
	Do WriteLog("</tr>",6)	
	Do WriteLog("<tr>",6)
	Do WriteLog("<td>",8)
	Do WriteHeader4("License Order Number",10)
	Do WriteLog("<p>"_OrderNumber_"</p>",10)
	Do WriteLog("</td>",8)
	Do WriteLog("</tr>",6)	
	Do WriteLog("<tr>",6)
	Do WriteLog("<td>",8)
	Do WriteHeader4("Fully Qualified Host Name",10)
	Do WriteLog("<p>"_FullHostName_" with IP Address: "_IPAddr_"</p>",10)
	Do INT^%D,INT^%T
	Do WriteLog("</td>",8)
	Do WriteLog("</tr>",6)	
	Do WriteLog("<tr>",6)
	Do WriteLog("<td>",8)
	Do WriteHeader4("Log created by User",10)
	Do WriteLog("<p>"_CurUser_" on "_$ZD($ZDH(%DAT,7),3)_" at "_%TIM_"</p>",10)
	Do WriteLog("</td>",8)
	Do WriteLog("</tr>",6)
	//Last Cach Startup
	Do WriteLog("<tr>",6)
	Do WriteLog("<td>",8)
	Do WriteHeader4("Last Cach&eacute; Startup",10)
	Do WriteLastStartup
	Do WriteLog("</td>",8)
	Do WriteLog("</tr>",6)	
	Do WriteLog("<tr>",6)
	Do WriteLog("<td>",8)
	Do WriteHeader4("Cach&eacute; Version String",10)
	Do WriteLog("<p>"_CacheVerStr_"</p>",10)
	//Set isInsight=$$isHealthInsight(namespace) 	//Determine if this is a Health Insight namespace (1 if yes)
	Do:isInsight WriteLog("<p>"_##class(%ZHSLIB.HealthShareMgr).VersionInfo()_"</p>",8)
	Do WriteAdhocPatch //write information on Adhoc patch
	//Current Locale subsection
	Do WriteLog("</td>",8)
	Do WriteLog("</tr>",6)	
	Do WriteLog("<tr>",6)
	Do WriteLog("<td>",8)
	Do NLS
	Do WriteLog("</td>",8)
	Do WriteLog("</tr>",6)	
	//Operating System Version section
	Do WriteLog("<tr>",6)
	Do WriteLog("<td>",8)	
	Do OSVer
	Do WriteLog("</td>",8)
	Do WriteLog("</tr>",6)	
	//Disk space
	Do WriteLog("<tr>",6)
	Do WriteLog("<td>",8)
	Do DiskSpace
	Do WriteLog("</td>",8)
	Do WriteLog("</tr>",6)
	//RAM physical memory space
	Do WriteLog("<tr>",6)
	Do WriteLog("<td>",8)	
	Do RAM
	Do WriteLog("</td>",8)
	Do WriteLog("</tr>",6)
	//Close the table
	Use PDev
	If OS?1"Win".e!(OS="VMS"),OS'="Win9x" 
	Use LogFile	
	Do WriteLog("</tbody>",4)
	Do WriteLog("</table>",2)
	Do WriteLog("</div>")
	Use PDev
	Quit
LogCubeSection
	Try {
		Do WriteUpdate("Getting cube information")
		Do:tracking WriteTrack("cubelog","Getting cube information","")
		Do WriteLog("<div id=""CubesDiv"" onmouseover=""highlightLink(this,1)"" onmouseout=""highlightLink(this,0)"">")
		Do WriteParagraph("cubelist","Cubes in "_namespace)
		Use PDev
		ZN namespace
	 	Do ##class(%DeepSee.Utils).%GetCubeList(.plist)
		Set cubenode=$order(plist(""))
		If cubenode=""{
			Do WriteLog("<p>There are no cubes in this namespace</p>")
	 	} Else {
		 	Use LogFile
		 	Do WriteLog("<table id=""CubeTable"" border=""0"" cellpadding=""7"" cellspacing=""3"" "_
		 	            "class=""zebraStriped"">",2)
		 	Do WriteLog("<tbody>",4)
		 	Do WriteLog("<tr>",6)
		 	Do WriteLog("<th onclick=""sortTable(this,0,1)"">Cube Name</th>",8)
		 	Do WriteLog("<th onclick=""sortTable(this,1,1)"">Display Name</th>",8)
		 	Do WriteLog("<th onclick=""sortTable(this,2,1)"">Source Class</th>",8)
		 	Do WriteLog("<th onclick=""sortTable(this,3,1)"">Cube Class</th>",8)
		 	Do WriteLog("<th onclick=""sortTable(this,4,1)"" title=""Does not reflect build order"">Related Cubes</th>",8)
		 	Do WriteLog("</tr>",6)
		 	Set storageList=""
			Set dataConnectorList=""			
			Set abstractcount = 0
			Set versionedcount = 0
			For {
				Quit:cubenode=""				//Do the work to get info and write out the table
				Set cubename=$list(plist(cubenode),1)
				Try {
					Set versionedCube = ##class(%DeepSee.CubeVersion.Utils).%GetVersionedCubeName(cubename)
					Set isVersioned = ##class(%DeepSee.CubeVersion.Utils).%IsVersion(versionedCube)
				} Catch {
					Set versionedCube = cubename
					Set isVersioned = 0
				}				
				If ##class(%DeepSee.Utils).%IsCubeAbstract(cubenode){	//cube is abstract
					//Don't run if Health insight because there are too many abstract cubes
					Set:('isInsight) abstractList($I(abstractcount)) = cubenode
				} ElseIf isVersioned {
					Set versionedList($I(versionedcount)) = versionedCube
				} ElseIf (cubename'="") {
					Do WriteLog("<tr>",6)
					Do WriteLog("<td>"_cubename_"</td>",8)					//cubename					
					Set cubecaption=##class(%DeepSee.Utils).%GetCubeCaption(cubename)
					Do WriteLog("<td>"_cubecaption_"</td>",8)
					Set cubeclass=##class(%DeepSee.Utils).%GetCubeClass(cubename) //cube class
					Set lastmod=$zdt($LG(plist(cubenode),3),3)				//last cube compile
					Set type=$LG(plist(cubenode),4)							//subject area or cube?
					Set sourceClass = $$GetSourceClass(cubenode,type)
					Do WriteLog("<td>"_sourceClass_"</td>",8)		//writes sourceClass
					Do WriteLog("<td>"_cubeclass_"</td>",8)				
					Write !,?8,"<td>" Do GetRelationships(cubenode)  Write "</td>"		//RelatedCubes
					Do WriteLog("</tr>",6)
				}
				Set cubenode=$order(plist(cubenode))
			}
		 	Do WriteLog("</tbody>",4)
		 	Do WriteLog("</table>",2)
			//Write out list of special cubes: versioned, abstract, with SQL Storage, based on Data Connectors
			Do WriteHeader4("Versioned Cubes",2)
			If versionedcount { 
				Set ind = $O(versionedList(""))
				While ind {
						Do WriteLog("<p>"_versionedList(ind)_"</p>",2)
						Set ind = $O(versionedList(ind))
					}
			}			
			Do WriteHeader4("Abstract Cubes",2)
			If abstractcount { 
				Set ind = $O(abstractList(""))
				While ind {
						Do WriteLog("<p>"_abstractList(ind)_"</p>",2)
						Set ind = $O(abstractList(ind))
					}
			}
			Do WriteHeader4("Cubes with Source Classes Based on SQL Storage",2)
			Set ptr=0
			If ($D(storageList) && (storageList'="")){
				While $LISTNEXT(storageList,ptr,class){
					Do WriteLog("<p>"_class_"</p>",2)
				}
			}
			Do WriteHeader4("Cubes Based on Data Connectors",2)
			If $D(dataConnectorList){	
					Set ptr=0
					While $LISTNEXT(dataConnectorList,ptr,class){
						Do WriteLog("<p>"_class_"</p>",2)
					}
			}
			Do WriteHeader4("Build Order for Related Cubes",2)
			Do ##class(%DeepSee.CubeManager.Utils).GetCubeGroups(.groups)
			Set relatedCubesExist = 0
			//Invert this array from groups(group,cube)=order to groupOrderCube(group,order)=cube
			Set group = $O(groups(""))
			While (group'="") {
				Set cube = $O(groups(group,""))
				While (cube'="") {
					//NB: order can be ""
					Set order = $S(groups(group,cube)'="":groups(group,cube),1:"-")
					Set:('relatedCubesExist && (order > 1)) relatedCubesExist = 1 
					Set groupOrderCube(group,order) = cube
					Set cube = $O(groups(group,cube))
				}
				Set group = $O(groups(group))
			}
			//Print a table with build order for cubes with relationships
			If relatedCubesExist {
			Do WriteLog("<table id=""BuildOrderTable"" border=""0"" cellpadding=""7"" cellspacing=""3"" "_"class=""tableWithBorders tableTabbed"">",2)
		 	Do WriteLog("<tbody>",4)
		 	Do WriteLog("<tr>",6)
		 	Do WriteLog("<th>Cube Name</th>",8)
		 	Do WriteLog("<th>Cube Group</th>",8)
		 	Do WriteLog("<th>Order</th>",8)		 	
		 	Do WriteLog("</tr>",6)
			Set group = $O(groupOrderCube(""))
			While (group'="") {
				Set last = $O(groupOrderCube(group,""),-1)
				If (last=1) {
					Set group = $O(groupOrderCube(group))
				} Else {					
					Set order = $O(groupOrderCube(group,""))
					While (order'="") {
						Set cube = groupOrderCube(group,order)
						Do WriteLog("<tr>",6)	//background-color: #ccc;
						Do WriteLog("<td>"_cube_"</td>",10)
						Do WriteLog("<td>"_group_"</td>",10)
						Do WriteLog("<td>"_order_"</td>",10)
						Do WriteLog("</tr>",6)
						Set order = $O(groupOrderCube(group,order))
					}
					Set group = $O(groupOrderCube(group))
				}
			}
			Do WriteLog("</tbody>",4)
			Do WriteLog("</table>",2)
			} Else {
				Do WriteLog("No related cubes",4)
			}
	 	}
	 	Do WriteLog("</div>")
 	} catch exc {
	 	Use PDev
	 	zw exc
	}
	ZN "%SYS"
 	Quit
LogBuildSynchSection
	Try {
		Do WriteUpdate("Getting information on Build/Synch")
		Do:tracking WriteTrack("buildsynch","Getting information on Build/Synch","")
		Do WriteLog("<div id=""BuildSynchDiv"" onmouseover=""highlightLink(this,1)"" onmouseout=""highlightLink(this,0)"">",2)
		Do WriteParagraph("buildsynchlist","Cube Build/Synch")
		Use PDev
		ZN namespace
	 	Do ##class(%DeepSee.Utils).%GetCubeList(.plist)
		Set cubenode=$order(plist(""))
		If cubenode=""{
			Use LogFile 
			Do WriteLog("<p>There are no cubes in this namespace</p>",4)
		 	Do WriteLog("</div>",2)
		 	Use PDev
		 	Quit
	 	} Else {
		 	If ##class(%DeepSee.CubeManager.Utils).GetActiveRegistry()=""{
			 	Do WriteLog("<p>No active registry so Build Time and Build Rate will not be populated.</p>",4)
			 	Do WriteLog("")
		 	} Else {
			 	Do WriteLog("<p>BuildTime, BuildRate, Build Errors show no values when the cube has not been built from Cube Manager.</p>",4)
		 	}
		 	//Get the latest DSTIME
		 	//DTB422 moved ^DeepSee.Cubes to ^DeepSee.Update
			If ($D(^DeepSee.Update)#10) { //1 (only top node) or 11 (top node and descendants)
				Set DSTIME = ^DeepSee.Update
				Do WriteLog("<p>DSTIME from ^DeepSee.Update is "_DSTIME_"</p>",4)
			} ElseIf ($D(^OBJ.DSTIME)#10) { 				
				Set DSTIME = ^OBJ.DSTIME
				Do WriteLog("<p>DSTIME from ^OBJ.DSTIME is "_DSTIME_"</p>",4)
			} Else {
				Set lastDataUpdate = 0
				Set dstime = ""
				Do WriteLog("<p>Could not find DSTIME</p>",4)
			}
		 	Do WriteLog("<table id=""BuildSynchTable"" border=""0"" cellpadding=""7"" cellspacing=""3"" "_"class=""zebraStriped"">",4)
		 	Do WriteLog("<tbody>",6)
		 	Do WriteLog("<tr>",8)
		 	Do WriteLog("<th onclick=""sortTable(this,0,1)"">Cube Name</th>",10)
		 	Do WriteLog("<th onclick=""sortTable(this,1,0)"""_
				"title=""Empty for large source tables, Subject Areas"">Source Count</th>",10)
		 	Do WriteLog("<th onclick=""sortTable(this,2,0)"""_
				"title=""From %DeepSee.Utils:%GetCubeFactCount, i.e. does not include restrictions."">Fact Count</th>",10)
		 	Do WriteLog("<th onclick=""sortTable(this,3,0)"">Build Time [s]</th>",10)
		 	Do WriteLog("<th onclick=""sortTable(this,4,0)"">Build Rate [Facts/s]</th>",10)
		 	Do WriteLog("<th onclick=""sortTable(this,5,0)"">Build Errors</th>",10)
			Do WriteLog("<th onclick=""sortTable(this,6,0)"""_
				"title=""From ^DeepSeeUpdate (or ^OBJ.DSTIME before DTB422)"">DSTIME</th>",10)
		 	Do WriteLog("<th onclick=""sortTable(this,7,1)"">Last Compile</th>",10)
		 	Do WriteLog("<th onclick=""sortTable(this,8,1)"" title=""As logged in ^DeepSee.Update (or ^OBJ.DSTIME before DTB422)"">Last Build/Synch</th>",10)
		 	Do WriteLog("<th onclick=""sortTable(this,9,0)"">Cube Group</th>",10)
		 	Do WriteLog("<th onclick=""sortTable(this,10,0)"">Build Order</th>",10)
		 	//Do WriteLog("<th onclick=""sortTable(this,11,1)"" title=""Does not reflect build order"">Related Cubes</th>",10)
		 	Do WriteLog("</tr>",8)
		 	//Cube group and build order
		 	//Invert this array from groups(group,cube)=order to cubeGroupOrder(cube)=$LB(group,order)
		 	Do ##class(%DeepSee.CubeManager.Utils).GetCubeGroups(.groups)		 	
			Set group = $O(groups(""))
			While (group'="") {
				Set cube = $O(groups(group,""))
				While (cube'="") {
					//NB: order can be "" and cause errors
					Set order = $S(groups(group,cube)'="":groups(group,cube),1:"-")
					Set cubeGroupOrder(cube) = $LB(group,order)
					Set cube = $O(groups(group,cube))
				}
				Set group = $O(groups(group))
			}
		 	Set storageList=""
			Set dataConnectorList=""			
			Set abstractcount = 0
			For {
				Quit:cubenode=""		//Do the work to get info and write out the table
				Set cubename=$list(plist(cubenode),1)
				If (cubename'="" && '##class(%DeepSee.Utils).%IsCubeAbstract(cubenode)) {		//if cube is not abstract
					Do WriteLog("<tr>",8)
					Do WriteLog("<td>"_cubename_"</td>",10)	//cubename
					/// Keep an eye on this. Does it perform well?					
					// COUNT(*) - Check Extent Size.
 					Set cube = $zu(28,cubename,5)
					Set type = $LG(plist(cube),4)
					Set sourceclass = $$GetSourceClass(cube,type)
					Set sqlclass = ##class(%DeepSee.Utils).%GetSQLTableName(sourceclass)
					Set NewExtentSize = ##Class(%SQL.Manager.Catalog).GetCalcTableExtentSize($P(sqlclass,".",1), $P(sqlclass,".",2))
					// First exclude abstract cubes and data connectors
					If (sqlclass="Not available")||('##class(%SYSTEM.SQL).TableExists(sqlclass)) {
						Do WriteLog("<td title='SQL class not available'></td>",10)
					} ElseIf NewExtentSize>=200000 {
						Do WriteLog("<td title='Extent Size is large'></td>",8)
					} ElseIf (NewExtentSize<10000) {
						Do WriteUpdate("Getting COUNT(*) from source class of "_cube_". ExtentSize="_NewExtentSize)
 						Set countstar=$$GetCountStar(sqlclass)
						Do WriteLog("<td>"_$FNUMBER(countstar,"O,")_"</td>",8)
					} Else {
						// Check if bitmap or bitmap extent index. 
						Set tRS=##class(%Library.ResultSet).%New("%SQL.Manager.Catalog:Indices")
						Set tSC = tRS.Execute($P(sqlclass,".",1),$P(sqlclass,".",2))
						//SKIP Quit:$$$ISERR(tSC)
						Set hasBitmap= 0
						For {
							Quit:'rs.Next()
							Set tType = rs.Get("TYPE")
							Set:$E(tType,1,6)="Bitmap" hasBitmap=1
						}
						If hasBitmap {
							Do WriteUpdate("Getting COUNT(*) from source class of "_cube_". ExtentSize="_NewExtentSize_", Bitmap index found")
							Set countstar=$$GetCountStar(sqlclass)
							Do WriteLog("<td>"_$FNUMBER(countstar,"O,")_"</td>",10)
						} Else {
							Do WriteLog("<td title='No Bitmap index found in SQL table'></td>",8)
						}
					}
					Set lastmod=$zdt($LG(plist(cubenode),3),3)				//last cube compile
					Set facts=##class(%DeepSee.Utils).%GetCubeFactCount(cubename)	//number of facts
  					//DTB422 moved ^DeepSee.Cubes to ^DeepSee.Update
					If ($D(^DeepSee.Cubes("cubes",cubenode,"lastDataUpdate"))=1) {
						Set lastDataUpdate = ^DeepSee.Cubes("cubes",cubenode,"lastDataUpdate")
						Set dstime = $G(^DeepSee.Cubes("cubes",cubenode,"dstime"),"")
					} ElseIf ($D(^DeepSee.Update("cubes",cubenode,"lastDataUpdate"))=1) { 
						Set lastDataUpdate = ^DeepSee.Update("cubes",cubenode,"lastDataUpdate")
						Set dstime = $G(^DeepSee.Update("cubes",cubenode,"dstime"),"")
					} Else {
						Set lastDataUpdate = 0
						Set dstime = ""
					}
					If (lastDataUpdate'=0){
						Set lastSync=$zdt(lastDataUpdate,3)	//Last cube sync from cube global						
						If lastSync="1840-12-31"{
							Set lastSync=" "
						} Else{
							Set syncdate=$p(lastSync," ",1)
							Set synctime=$p(lastSync," ",2)
							Set lastSync=syncdate_" "_synctime
						}
					} Else {
						Set lastSync=""
					}					
					Set buildtime=$$GetBuildTime(cubename)
					Do WriteLog("<td>"_$FNUMBER(facts,"O,")_"</td>",10)
					If buildtime=""{
						Do WriteLog("<td></td>",10)
					} Else {
						Do WriteLog("<td>"_$FNUMBER(buildtime,"O,")_"</td>",10)
					}
					Try {
						If ((buildtime="") || (facts=0)) {
							Set rate=""
						} Else {
							Set rate=$FNUMBER(facts/buildtime,",",2)
						}
					} Catch {
						Set rate=""
					}
					Do WriteLog("<td>"_rate_"</td>",10)
  					Set builderrors = $G(^DeepSee.BuildErrors($ZCONVERT(cubename,"U")),"")
  					If (builderrors="") {
 						Do WriteLog("<td></td>",10)
  					} Else {
	  					Do WriteLog("<td>"_$FNUMBER(builderrors,"O,")_"</td>",10)
	  				}
  					Do WriteLog("<td>"_dstime_"</td>",10)
					Do WriteLog("<td>"_lastmod_"</td>",10)
					Do WriteLog("<td>"_lastSync_"</td>",10) 		//LastUpdate = Last time cube was synced or built, "" if not done in Cube Manager
					//Cube group and order
 					If $D(cubeGroupOrder(cubenode)) {
	 					Set group = $LG(cubeGroupOrder(cubenode),1)
	 					Set order = $LG(cubeGroupOrder(cubenode),2)
 					} Else {
	 					Set group = ""
	 					Set order = ""
 					}
					Do WriteLog("<td>"_group_"</td>",10)
					Do WriteLog("<td>"_order_"</td>",10)
					Do WriteLog("</tr>",8)
				} ElseIf ##class(%DeepSee.Utils).%IsCubeAbstract(cubenode){
					//Don't run if Health insight because there are too many abstract cubes
					Set:('isInsight) abstractList($I(abstractcount)) = cubenode
				}
				Set cubenode=$order(plist(cubenode))
			}
		 	Do WriteLog("</tbody>",6)
		 	Do WriteLog("</table>",4)
		}
		//Build Errors section
		Do WriteHeader4("Build Errors",2,"From the ^DeepSee.BuildErrors global")
		Set tCube = $O(^DeepSee.BuildErrors(""))
		Set errs = 0
		While (tCube'="") {
		 	If (^DeepSee.BuildErrors(tCube)) {
			 	Set errs(tCube) = ^DeepSee.BuildErrors(tCube)
			 	Set errs = errs + errs(tCube)
			}
			Set tCube = $O(^DeepSee.BuildErrors(tCube))
		}
		If (errs) {
			Set pre="title=""Build errors are logged in the ^DeepSee.BuildErrors global."">"
			Set alert = "Alert: "_$FNUMBER(errs,"O,")_" build error(s) found"
			Set alerts($I(alerts)) = pre_alert
			Do WriteLog("<p class=""red"" "_pre_alert_":</p>",2)
			Set tCube = $O(errs(""))
			While (tCube'="") {
				Do WriteLog("<p>"_$FNUMBER(errs(tCube),"O,")_" build error(s) for '"_tCube_"'</p>",2)
				Set tCube = $O(errs(tCube))
			}
		} Else {
			Do WriteLog("<p>No build errors</p>",2)
		}
		Do WriteLog("</div>")
 	} catch exc {
	 	Use PDev
	 	zw exc
	}
	ZN "%SYS"
 	Quit
LogCubeRegistry
	Do WriteLog("<div id=""RegistryMapDiv"" onmouseover=""highlightLink(this,1)"" onmouseout=""highlightLink(this,0)"">",2)
	Do WriteParagraph("cuberegistry","Cube Registry")
	ZN namespace	
	Set registry=##class(%DeepSee.CubeManager.Utils).GetActiveRegistry()
	If registry=""{
		Do WriteLog("<p>No cube registry defined in this namespace</p>",2)
	} Else{
		Do WriteLog("<p>Cube Registry storage class: "_registry_"</p>",2)
		Set rs=##class(%Library.ResultSet).%New("%DeepSee.CubeManager.RegistryMap:RegistryMapTableView")
		Do rs.Execute()
		Do WriteLog("<table id=""RegistryMapDiv"" cellpadding=""7"" cellspacing=""3"" "_
		"class=""tableWithBorders"">",2)
		Do WriteLog("<tbody>",4)
		Do WriteLog("<tr>",6)
		Do WriteLog("<th>Cube Name</th>",8)
		Do WriteLog("<th>Group Name</th>",8)
		Do WriteLog("<th>Registered</th>",8)
		Do WriteLog("<th>Exclude</th>",8)
		Do WriteLog("<th>Group Build Order</th>",8)
		Do WriteLog("<th>Update Plan</th>",8)
		Do WriteLog("<th>Supports Synchronize</th>",8)
		Do WriteLog("<th>Build Every</th>",8)
		Do WriteLog("<th>Synch Every</th>",8)
		Do WriteLog("</tr>",6)
		For {
			Quit:'rs.Next()		
			Do WriteLog("<tr class="""_$S(rs.Get("IsRegistered")="No":"darkgrey",rs.Get("Disabled")="Yes":"grey",1:"")_""">",6)
			Do WriteLog("<td>"_rs.Get("CubeKey")_"</td>",8)
			Do WriteLog("<td>"_rs.Get("MgmtGroup")_"</td>",8)
			Do WriteLog("<td>"_rs.Get("IsRegistered")_"</td>",8)
			Do WriteLog("<td>"_rs.Get("Disabled")_"</td>",8)
			Do WriteLog("<td>"_rs.Get("CustomBuildOrder")_"</td>",8)
			Do WriteLog("<td>"_rs.Get("UpdatePlan")_"</td>",8)
			Do WriteLog("<td>"_rs.Get("DSTimeEnabled")_"</td>",8)
			Do WriteLog("<td>"_rs.Get("BuildEvery")_"</td>",8)
			Do WriteLog("<td>"_rs.Get("SynchEvery")_"</td>",8)
			Do WriteLog("</tr>",6)
		}
		Do WriteLog("</tbody>",4)
		Do WriteLog("</table>",2)
		Do WriteLog("<br>",2)
	}
	Do WriteLog("</div>")
	ZN "%SYS"
	Quit
LogDetailedCubeInfo
	Do WriteLog("<div id=""CubeInfoDiv"" onmouseover=""highlightLink(this,1)"" onmouseout=""highlightLink(this,0)"">")
	Do WriteParagraph("cubeinfo","Cube Info")
	Set cubeListLength=$ll(cubeList)
 	For i=1:1:cubeListLength{
		Set cube=$LG(cubeList,i)
		If cube'=""{
			Do WriteLog("<a href=""#cubeinfo"_cube_""">"_cube_"</a>",2)
			Do WriteLog("<br>",2)
		}
	}
	Do WriteLog("</div>")
	For cubeind=1:1:cubeListLength {
		Set cube=$LG(cubeList,cubeind)
 		//Do:cube'="" LogCubeDetails(namespace,cube,PDev,LogFile) //PDev eg "/dev/pts/5"
 		If cube'="" {
 			ZN namespace
 			Do WriteLog("<div id=""CubeInfoDiv"_cube_""" onmouseover=""highlightLink(this,1)"" onmouseout=""highlightLink(this,0)"">")
			Do LogCubeInfo
			Do LogCubeDimensions
			Do LogOtherCubeElements
			Do WriteLog("</div>")
			Do:tracking WriteTrack("cube","Detailed information collected",cube)
		}
 	}
	Quit
LogCubeInfo
	//New (namespace,LogFile,PDev,cube)
	Do WriteUpdate("Getting detailed cube information for "_cube)
	Do:tracking WriteTrack("cube","Build/Synch",cube)
	Use LogFile
	ZN namespace	
	Try {
		Do WriteLog("<hr size=""4"" noshade>",2)
		Do WriteLog("<a name=""cubeinfo"_cube_"""></a>",2)
		Do WriteLog("<h2>Cube Info for "_cube_"</h2>",2)	
		Set cubeclass=##class(%DeepSee.Utils).%GetCubeClass(cube)
		Set factclass=##class(%DeepSee.Utils).%GetCubeFactClass(cube)
		Set cubecaption=##class(%DeepSee.Utils).%GetCubeCaption(cube)
		Set factcount=##class(%DeepSee.Utils).%GetCubeFactCount(cube)
		Set moddate=$zdt(##class(%DeepSee.Utils).%GetCubeModifiedDate(cube))
	 	//Get the cube type
	 	Set cubetype=""
	 	Set:##class(%DeepSee.Utils).%IsCubeCompound(cube,.joinlist) cubetype="Compound"	
	 	Set:##class(%DeepSee.Utils).%IsCubeAbstract(cube) cubetype="Abstract"
		Set base=##class(%DeepSee.Utils).%GetBaseCube(cube)	
		Set:((base'="") && (cubetype="")) cubetype="Subject Area"
		//Start logging cube info
		Do WriteLog("<table id=""CubeInfoTable"_cube_""" cellpadding=""7"" cellspacing=""3"""_
		            " class=""tableWithBorders tableTabbed"">",2)
	  	Do WriteLog("<tbody>",4)
	  	//Check versioned cube
	  	Try {
	    	Set versionedcube = ##class(%DeepSee.CubeVersion.Utils).%GetVersionedCubeName(cube,.vn)
	    	Set isversioned = ##class(%DeepSee.CubeVersion.Utils).%IsVersion(versionedcube)
	  	} Catch {
		  	Set versionedcube = cube
		  	Set isversioned = 0
		}
	    If isversioned {
	    	Do WriteLog("<tr>",6)
	    	Do WriteLog("<td>",8)
			Do WriteLog("<h4>Versioned Cube Name</h4>",10)
			Do WriteLog("<p>"_versionedcube_"</p>",10)
	    	Do WriteLog("</td>",8)
	    	Do WriteLog("</tr>",6)
	    }
		//Continue
	    Do WriteLog("<tr>",6)
	    Do WriteLog("<td>",8)
		Do WriteLog("<h4>Cube Display Name</h4>",10)
		Do WriteLog("<p>"_cubecaption_"</p>",10)
	    Do WriteLog("</td>",8)
	    Do WriteLog("</tr>",6)
	    Do WriteLog("<tr>",6)
	    Do WriteLog("<td>",8)
		Do WriteLog("<h4>Cube Type</h4>",10)
	 	Do:(cubetype="Subject Area") WriteLog("<p>Subject Area based on "_base_" cube</p>",10)
	 	Do:(cubetype="Compound") WriteLog("<p>Compound Cube based on: </p>",10)
	 	Do:(cubetype="Compound") WriteLog("<p>"_joinlist_"</p>",10)
	 	Do:(cubetype="Abstract") WriteLog("<p>Abstract Cube</p>",10)
		If (cubetype="") Do WriteLog("<p>Not a subject area, abstract, or a compound cube</p>",10)
	    Do WriteLog("</td>",8)
	    Do WriteLog("</tr>",6)
	    Do WriteLog("<tr>",6)
	    Do WriteLog("<td>",8)
		Do WriteLog("<h4>Subject Area Class</h4>",10)
		Do WriteLog("<p>"_cubeclass_"</p>",10)
	    Do WriteLog("</td>",8)
	    Do WriteLog("</tr>",6)
	    Do WriteLog("<tr>",6)
	    Do WriteLog("<td>",8)
		Do WriteLog("<h4>Inherits from</h4>",10)
		Set model = ##class(%DeepSee.Utils).%GetModel(cube)
		Set inheritsfrom = ""
		Set:(model'="") inheritsfrom = ##class(%DeepSee.Utils).%GetModel(cube).inheritsFrom
		Do WriteLog("<p>"_inheritsfrom_"</p>",10)
	    Do WriteLog("</td>",8)
	    Do WriteLog("</tr>",6)
	    Do WriteLog("<tr>",6)
	    Do WriteLog("<td>",8)
	    Do WriteLog("<h4>Resource</h4>",10)
	    Do WriteLog("<p>"_$G(^DeepSee.Cubes("cubes",cube,"resource"))_"</p>",10)
	    Do WriteLog("</td>",8)
	    Do WriteLog("</tr>",6)
	    Do WriteLog("<tr>",6)
	    Do WriteLog("<td>",8)
		Do WriteLog("<h4>Source Class</h4>",10)
		//Get the source class from override or from %GetCubeList, then log it
		If $D(^DeepSee.Overrides(cube,"SOURCECLASS")) {
			Set sourceclass = ^DeepSee.Overrides(cube,"SOURCECLASS")
			Do WriteLog("<p>"_sourceclass_" (from ^DeepSee.Overrides)</p>",10)
		} Else {
			Do ##class(%DeepSee.Utils).%GetCubeList(.plist)
			Set type = $LG(plist(cube),4)
			Set sourceclass = $$GetSourceClass(cube,type)
	 		If ((cubetype="Subject Area")||(cubetype="Compound")) {
	  			Do WriteLog("<p>Subject Area based on "_sourceclass_"</p>",10)
	 		} Else {
				Do WriteLog("<p>"_sourceclass_"</p>",10)
	 		}
		}	
	    Do WriteLog("</td>",8)
	    Do WriteLog("</tr>",6)
	    Do WriteLog("<tr>",6)
	    Do WriteLog("<td>",8)
	    //Get the SQL table name
		Do WriteLog("<h4>SQL Table Name </h4>",10)
		//NB: if sourceclass is invalid %GetSQLTableName returns the same string, possibly with _ instead of .
	 	Set sqlclass = ##class(%DeepSee.Utils).%GetSQLTableName(sourceclass)
	 	If (sqlclass="")||('##class(%SYSTEM.SQL).TableExists(sqlclass)) {
	 		Set sqlclass="Not available" //Often in abstract cubes
	 	}
	 	If ((cubetype="Subject Area")||(cubetype="Compound")) {
			Do WriteLog("<p>Subject Area based on "_sqlclass_"</p>",10)
	 	} Else {
			Do WriteLog("<p>"_sqlclass_"</p>",10)
	 	}
	    Do WriteLog("</td>",8)
	    Do WriteLog("</tr>",6)
	    Do WriteLog("<tr>",6)
	    Do WriteLog("<td>",8)
		Do WriteLog("<h4>Fact Class</h4>",10)
		Do WriteLog("<p>"_factclass_"</p>",10)
		Do WriteLog("</td>",8)
	    Do WriteLog("</tr>",6)
	    If isversioned {
	    	Do WriteLog("<tr>",6)
	    	Do WriteLog("<td>",8)
			Do WriteLog("<h4 title=""List of deprecated versions currently on the system"">Deprecated Versions</h4>",10)
			Do ##class(%DeepSee.CubeVersion.Utils).%GetDeprecatedVersionList(cube,.tList)
			Set tInd=$O(tList(""))
			While (tInd'="") {
				Do WriteLog("<p>"_tInd_"</p>",10)
				Set tInd=$O(tList(tInd))
			}
			Do WriteLog("</td>",8)
	    	Do WriteLog("</tr>",6)
	    	//Get all compiled versions
			Kill tList
			Set tVersionNo = $O(^DeepSee.Cubes("versionIndex","versions",cube,""))
			While (tVersionNo'="") {
				Set tVers = ##class(%DeepSee.CubeVersion.Utils).%GetVersionedCubeName(cube,tVersionNo)
				Set tStatus = ##class(%DeepSee.CubeVersion.Utils).%GetCubeVersionStatus(cube,tVersionNo)
				//Skip when tVersionNo is not a version and instead it marks "activeVersion", or "pendingVersion"
				Set:tVers'="" tList(tVers) = tStatus
				Set tVersionNo = $O(^DeepSee.Cubes("versionIndex","versions",cube,tVersionNo))
			}
			Do WriteLog("<tr>",6)
	    	Do WriteLog("<td>",8)
			Do WriteLog("<h4 title=""List of compiled versions and their status currently present in the system"">Compiled Versions</h4>",10)
			Set tInd=$O(tList(""))
			While (tInd'="") {
				Do WriteLog("<p>"_tInd_" - "_$S(tList(tInd)="":"unknown",1:tList(tInd))_"</p>",10)
				Set tInd=$O(tList(tInd))
			}
	    	Do WriteLog("</td>",8)
	    	Do WriteLog("</tr>",6)
		}
	    Do WriteLog("<tr>",6)
	    Do WriteLog("<td>",8)
	    //Row count on source. It might take some time (even 150 seconds on 100M facts)
	    Do WriteLog("<h4>Source Count</h4>",10)
	    //Check the following for abstract cubes and data connectors
	    If isTrak { //I noticed at a Trak site that COUNT(*) is slow.
		    Do WriteLog("<p>Not shown for Trak</p>",10)
	    } ElseIf (sqlclass="Not available")||('##class(%SYSTEM.SQL).TableExists(sqlclass)) {
			Do WriteLog("<p>Not available</p>",10)
	    } Else {
		    Set SourceFactCount=$$GetCountStar(sqlclass)
		    Do WriteLog("<p>"_$FNUMBER(SourceFactCount,"O,")_"</p>",10)
	    }
	    Do WriteLog("</td>",8)
	    Do WriteLog("</tr>",6)
	    Do WriteLog("<tr>",6)
	    Do WriteLog("<td>",8)
	    Do WriteLog("<h4 title=""From %DeepSee.Utils:%GetCubeFactCount, i.e. does not include restrictions."""_
	    			">Fact Count</h4>",10)
		Do WriteLog("<p>"_$FNUMBER(factcount,"O,")_"</p>",10)
		Do WriteLog("</td>",8)
	    Do WriteLog("</tr>",6)
	    Do WriteLog("<tr>",6)
	    Do WriteLog("<td>",8)
	    Do WriteLog("<h4>Build Restriction</h4>",10)
	    If base="" {
		    //Log buildRestriction property in cubes
		    Set tSC = $zobjclassmethod(cubeclass,"%GetSourceInfo",.tSourceInfo)
			Set buildRestriction = $G(tSourceInfo("buildRestriction"))
			If buildRestriction="" {
				Do WriteLog("<p>No build restriction</p>",10)
			} Else {
				Do WriteLog("<p>Build restriction: "_$$encode(buildRestriction)_"</p>",10)
			}
			//Log maxFacts property in cubes
			Set maxFacts = $G(tSourceInfo("maxFacts"))
			If maxFacts="" {
				Do WriteLog("<p>maxFacts property not found in subject area class</p>",10)
			} Else {
				Do WriteLog("<p>maxFacts = "_$FNUMBER(maxFacts,"O,")_"</p>",10)
			}
	    } Else {
		    //Log filterspec property in subject areas (not cubes)
		    //NB $zobjclassmethod(cubeclass,"%GetFilterSpec") would also return the result from %OnGetFilterSpec
		    Set filterspec = $G(^DeepSee.Cubes("cubes",cube,"filterSpec"))
		    Set:(filterspec="") filterspec = "filterspec property not defined"
		    Do WriteLog("<p>filterSpec: "_filterspec_"</p>",10)
	    }
	    Set method = ##class(%Dictionary.CompiledMethod).%OpenId(cubeclass_"||%OnProcessFact")
	    If ((method="")||(method.Origin="%DeepSee.CubeDefinition")) {
		    Do WriteLog("<p>%OnProcessFact method not found in subject area class</p>",10)
	    } ElseIf (method.Origin=cubeclass) {
			Do WriteLog("<p>%OnProcessFact method defined in subject area class</p>",10)
		}
	    Set method = ##class(%Dictionary.CompiledMethod).%OpenId(cubeclass_"||%OnGetFilterSpec")
		If ((method="")||(method.Origin="%DeepSee.CubeDefinition")||(method.Origin="%DeepSee.SubjectArea")) {
			//NB: checking (method="") might be overkill
			Do WriteLog("<p>%OnGetFilterSpec method not found in subject area class</p>",10)
		} ElseIf (method.Origin=cubeclass) {
			Do WriteLog("<p>%OnGetFilterSpec method defined in subject area class</p>",10)
		}
	    Do WriteLog("</td>",8)
	    Do WriteLog("</tr>",6)
	    Do WriteLog("<tr>",6)
	    Do WriteLog("<td>",8)
		Do WriteLog("<h4>Last Modified</h4>",10)
		Do WriteLog("<p>"_$ZDT($ZDTH(moddate),3)_"</p>",10)
	    Do WriteLog("</td>",8)
	    Do WriteLog("</tr>",6)
	    //DSTIME and DSINTERVAL
	    If (base="")&&(cubetype="") {
	    	Do WriteLog("<tr>",6)
	    	Do WriteLog("<td>",8)
			Do WriteLog("<h4>DSTIME, DSINTERVAL</h4>",10)
			Set dstime = $G(tSourceInfo("dstime"))
			If dstime="" {
				Do WriteLog("<p>DSTIME property not found in subject area class</p>",10)
			} Else {
				Do WriteLog("<p>DSTIME = "_dstime_"</p>",10)
				Set dsinterval = $G(tSourceInfo("dsinterval"))
				If dsinterval="" {
					Do WriteLog("<p>DSINTERVAL not specified</p>",10)
				} Else {
					Do WriteLog("<p>DSINTERVAL = "_dsinterval_"</p>",10)
				}
			}
	    	Do WriteLog("</td>",8)
	    	Do WriteLog("</tr>",6)
	    }
	    //Cube Registry
	    Do WriteLog("<tr>",6)
	    Do WriteLog("<td>",8)
	   	Do WriteUpdate("Getting detailed cube information for "_cube_": cube registry")
	   	Do:tracking WriteTrack("cube","Cube Registry",cube)
	    Do WriteLog("<h4>Cube Registry</h4>",10)
	    Set rs = ##class(%Library.ResultSet).%New("%DeepSee.CubeManager.RegistryMap:RegistryMapTableView")
		Set registered = ""
		Set state = ""	
		Do rs.Execute(cube)
		While (rs.Next()) {
			If (cube=rs.Get("CubeKey")){
				Set registered = rs.Get("IsRegistered")
				If (registered="No") {
					Set registered = $S(registered="Yes":"registered",registered="No":"not registered",1:"unknown")
				} ElseIf (registered="Yes") {
					Set state = rs.Get("Disabled")
					Set state = $S(state="Yes":"disabled",state="No":"enabled",1:"unknown")
				}
			}
		}	
		If (registered="not registered") {
			Do WriteLog("<p>Cube is "_registered_" in Cube Manager</p>",10)
		} Else {
			If (state="enabled") {
				Set msgsynch=$$GetLastBuild("Synch",cube)	//Get last synch
				Set msgbuild=$$GetLastBuild("Build",cube)	//Get last build		
				Set msgupdate=$$GetLastBuild("Update",cube)	//Get last update
				Set msgrepair=$$GetLastBuild("Repair",cube)	//Get last repair
				Do WriteLog("<p>Cube is "_state_" in Cube Manager. Most Recent events:</p>",10)
				Do WriteLog("<p>Synch event: "_msgsynch_"</p>",10)
				Do WriteLog("<p>Build event: "_msgbuild_"</p>",10)
				Do WriteLog("<p>Registry Update event: "_msgupdate_"</p>",10)
				Do WriteLog("<p>Repair event: "_msgrepair_"</p>",10)
				//Do alertInitialBuildCubeManager(cube,msgrepair,msgbuild,.alerts)
			} Else {
				Do WriteLog("<p>Cube is "_state_" in Cube Manager</p>",10)
			}
		}
		Do WriteLog("</td>",8)
	    Do WriteLog("</tr>",6)
	    //Build errors
		If ($D(^DeepSee.BuildErrors(cube)) && ^DeepSee.BuildErrors(cube)) {
			Do WriteLog("</tbody>",4)
	    	Do WriteLog("</table>",2)
	    	Do WriteLog("<h4>Build Errors</h4>",2)
			If ($D(^DeepSee.BuildErrors(cube)) && ^DeepSee.BuildErrors(cube) <4) {
				Do WriteLog("<div class=""scrollable"" style=""border:1px solid #D0D0D0;height:400px;"">")
	    	} Else {
	    		Do WriteLog("<div class=""scrollable"" style=""width:100%;height:400px;"">")
	    	}
			Do WriteLog("<pre>",10)
			Set totCount = ^DeepSee.BuildErrors(cube)
			Set tCount = 0
			Set k = $O(^DeepSee.BuildErrors(cube,""))
			While (k'="") {
				Set tCount = tCount + 1
				Set tSC = $G(^DeepSee.BuildErrors(cube,k))
				Write $J($FNUMBER(tCount,"O,"),5),$J("",3),"Source ID: ",k
				Write !,?8,$zconvert($System.Status.GetErrorText(tSC),"O","HTML"),!!
				If (tCount>1000) {
					Write !,?0,"... skipping build errors ..."
					Write !
					Write !
					Quit
				}
				Set k = $O(^DeepSee.BuildErrors(cube,k))
			}
			Write $FNUMBER(totCount,"O,")," build error(s) for '",cube,"'"
			Do WriteLog("</pre>",10)
			Do WriteLog("</div>") 
		} Else {
		    Do WriteLog("<tr>",6)
	    	Do WriteLog("<td>",8)
	    	Do WriteLog("<h4>Build Errors</h4>",4)
	    	Do WriteLog("<p>",10)
		    Do ##class(%DeepSee.Utils).%PrintBuildErrors(cube)
		    Write ?10,"</p>"
	    	Do WriteLog("</td>",8)
	    	Do WriteLog("</tr>",6)
	    	Do WriteLog("</tbody>",4)
	    	Do WriteLog("</table>",2)
	    }
	} Catch(ex) {
		Set tSC = ex.AsStatus()
		Do $System.Status.DisplayError(tSC)
		Do:tracking WriteTrack("warning","","LogCubeInfo",$System.Status.GetErrorText(tSC))
	}
	ZN "%SYS"
	Quit
LogCubeDimensions
	Do WriteUpdate("Getting detailed cube information for "_cube_": get dimension list")
	Do:tracking WriteTrack("cube","Dimension list",cube)
	ZN namespace
	Do WriteLog("<hr size=""4"" noshade>",2)
	Do WriteLog("<a name=""dimensions"_cube_"""></a>",2)
	Do WriteLog("<h2>Dimensions for "_cube_"</h2>",2)
	If ##class(%DeepSee.Utils).%IsCubeAbstract(cube) {
		Do WriteLog("<p>No dimensions because the cube is abstract</p>",2)
		Quit
	}	
	Do WriteLog("<h4>Dimension List</h4>",2)
	Set st=##class(%DeepSee.Utils).%GetDimensionList(cube,.dimensionlist,1)
	Do WriteLog("<table id=""DimensionTable"" border=""0"" class=""tableWithBorders"" cellpadding=""3"" cellspacing=""3"">",2)
	Do WriteLog("<tbody>",4)
	Do WriteLog("<tr>",6)
	Do WriteLog("<th>Dimension</th>",8)
	Do WriteLog("<th>Hierarchy </th>",8)
	Do WriteLog("<th>Level</th>",8)
	Do WriteLog("<th>Type</th>",6)
	Do WriteLog("</tr>",6)
	Set DimNo=$O(dimensionlist(-1)) //skip Calculated Dimensions
	Set oldHierNo=0
 	Kill timeLevels
	For {
		Quit:DimNo=""
		Set HierNo=$O(dimensionlist(DimNo,""))
		For {
			If HierNo="" {
				Set oldHierNo=0
				Quit
			}
			Set LevelNo=$O(dimensionlist(DimNo,HierNo,""))
			For {
				Quit:LevelNo=""
				Set type=$LG(dimensionlist(DimNo,HierNo,LevelNo),1)
				If (HierNo=0) {  //Dimension. 
					//In this case 4th item "type" is actually the caption for all level
					Do WriteLog("<tr>",6)
					Do WriteLog("<td>"_$LG(dimensionlist(DimNo,HierNo,LevelNo),2)_"</td>",8) 	//DimName
					If ($LG(dimensionlist(DimNo,HierNo,LevelNo),1)="r") { //relationships
						Do WriteLog("<td></td>",8)
						Do WriteLog("<td></td>",8)
						Do WriteLog("<td></td>",8)
					}
					If ((type="d") && ($LG(dimensionlist(DimNo,HierNo,LevelNo),4)'="")) {
						Do WriteLog("<td></td>",8)
						Do WriteLog("<td>"_$LG(dimensionlist(DimNo,HierNo,LevelNo),4)_"</td>",8)
						Do WriteLog("<td>[All level]</td>",8)
						Do WriteLog("</tr>",6)
						Do WriteLog("<tr>",6)
						Do WriteLog("<td></td>",8) 	//Skip DimName column
					}
				} 
				If (HierNo'=0){
					If type="all" {
						//Skip the all level because it was already shown next to the dimension
					} ElseIf ((LevelNo=0) && (DimNo'=0)) {
						Set newHier=0
						If (oldHierNo && (HierNo'=oldHierNo)) { //Maybe the logic could be simpler but this works
							Do WriteLog("</tr>",6)
							Do WriteLog("<tr>",6)
							Do WriteLog("<td></td>",8)
						}
						Do WriteLog("<td>"_$LG(dimensionlist(DimNo,HierNo,LevelNo),3)_"</td>",8)	//HierName
					} ElseIf ((LevelNo=0) && (DimNo=0)){ //Measures section
						If HierNo>1 {
 							Do WriteLog("</tr>",6)
							Do WriteLog("<tr>",6)
							Do WriteLog("<td></td>",8)
						} 
						Do WriteLog("<td>"_$LG(dimensionlist(DimNo,HierNo,LevelNo),3)_"</td>",8)	//MeasName
						Do WriteLog("<td></td>",8)
						Do WriteLog("<td></td>",8)
					} ElseIf (DimNo'=0) {
 						If $E($LG(^DeepSee.Cubes("cubes",cube,"mbr#",DimNo,HierNo,LevelNo),6),0,14)="%DeepSee.Time." {
	 						Set temp=^DeepSee.Cubes("cubes",cube,"mbr#",DimNo,HierNo,LevelNo)
	 						Set timeLevels(DimNo,HierNo,LevelNo)=$LB($LG(temp,6),cube,$LG(temp,2),$LG(temp,3),$LG(temp,4))
 						}
						If newHier {
							Do WriteLog("</tr>",6)
							Do WriteLog("<tr>",6)
								Do WriteLog("<td></td>",8)
								Do WriteLog("<td></td>",8)
							}
							Do WriteLog("<td>"_$LG(dimensionlist(DimNo,HierNo,LevelNo),4)_"</td>",8)	//LevelName
							Set type=$S(type="all":"[All level a]",1:"")
							Do WriteLog("<td>"_type_"</td>",8) 		//type
							Set newHier=1
						}
				}
				Set LevelNo=$O(dimensionlist(DimNo,HierNo,LevelNo))						
			}
			Set oldHierNo=HierNo
			Set HierNo=$O(dimensionlist(DimNo,HierNo))
		}
		Set DimNo=$O(dimensionlist(DimNo))
 		Do WriteLog("</tr>",6)
	}
	Do WriteLog("</tbody>",4)
	Do WriteLog("</table>",2)
	//Alert if incompatible time levels are found
 	Do alertTimeLevels(.timeLevels,.alerts)
	//Alert if non-time levels have non-unique parents
	Do alertBadHierarchies(cube,.alerts)
 	//Show calculated members in ^DeepSee.CalcMbrs
	Do WriteLog("<h4>Calculated Members</h4>",2)
	If $D(^DeepSee.CalcMbrs(cube)) {
		Do WriteLog("<table>",2)
		Do WriteLog("<tbody>",4)
		Do WriteLog("<tr>",6)
		Do PrintGlobal(namespace,"^DeepSee.CalcMbrs("""_cube_""")",10)
		Do WriteLog("</tr>",6)
		Do WriteLog("</tbody>",4)
		Do WriteLog("</table>",2)
	} Else {
		Do WriteLog("<p>No calculated members found for "_cube_"</p>",2)
	}
	//Detailed cube information
	Do WriteUpdate("Getting detailed cube information for "_cube_": %Analyze")
	Do:tracking WriteTrack("cube","%Analyze",cube)
	Do WriteLog("<h4>Analyze</h4>",2)
	Do WriteLog("<table border=""0"" cellpadding=""5"" cellspacing=""5"">",2)
	Do WriteLog("<tbody>",4)
	Do WriteLog("<tr>",6)
	Do WriteLog("<td>",8)
	Do WriteLog("<pre>",10)
	//Execute %Analyze but skip it if indices take too long
	Try {
		Set dirindices=##class(%SYS.Namespace).GetGlobalDest(namespace,"DeepSee.Index")
		Do ##class(%Library.GlobalEdit).GetGlobalSizeBySubscript($P(dirindices,"^",2),"DeepSee.Index("""_cube_""")","",.sizeindex) 
		Set dirfacts=##class(%SYS.Namespace).GetGlobalDest(namespace,"DeepSee.Fact")
 		Do ##class(%Library.GlobalEdit).GetGlobalSizeBySubscript($P(dirfacts,"^",2),"DeepSee.Fact("""_$zu(28,factclass,5)_""")","",.sizefacts)
		Set flag="c"
		Set:(sizeindex<500) flag="i"_flag
		If (flag'="c") {
			//See if analyzing facts is quick
			Set:(sizefacts<300) flag="f"_flag
			Do WriteLog("Do ##class(%DeepSee.Utils).%Analyze("""_cube_""","""_flag_""",0)")
			Do ##class(%DeepSee.Utils).%Analyze(cube,flag,0)
		} Else {
			Set msg="%Analyze was skipped because of the sizes of ^DeepSee.Fact or ^DeepSee.Index global ("_
					sizefacts_" and "_sizeindex_", respectively). Consider to run the following command: "
			Set msg2="Do ##class(%DeepSee.Utils).%Analyze("""_cube_""",""fci"",0)"
			Do WriteLog(msg)
			Do WriteLog(msg2)
			Do:tracking WriteTrack("warning","",cube,msg_msg2)
		}
		Do WriteLog("")
		Do WriteLog("")
		Do WriteLog("")
	} Catch(ex) {
		Set tSC = ex.AsStatus()
		Do WriteLog(tSC)
	}
	// Translate the filed names in %Analyze to actual specs
	Do WriteUpdate("Getting detailed cube information for "_cube_": FieldNameToSpec")
	Do:tracking WriteTrack("cube","FieldNameToSpec",cube)
	Write "FieldNameToSpec("""_cube_""")",!
	Do FieldNameToSpec(cube)
	Do WriteLog("")
	Do WriteLog("")
	Do WriteLog("")
	Do WriteUpdate("Getting detailed cube information for "_cube_": %AnalyzeMissing")
	Do:tracking WriteTrack("cube","%AnalyzeMissing",cube)
	Write "Do ##class(%DeepSee.Utils).%AnalyzeMissing(""",cube,""")",!
	Do ##class(%DeepSee.Utils).%AnalyzeMissing(cube)
	Do WriteLog("</pre>",10)
	Do WriteLog("</td>",8)
	Do WriteLog("</tr>",6)
	Do WriteLog("</tbody>",4)
	Do WriteLog("</table>",2)
	Do WriteLog("")
	ZN "%SYS"
	Quit
LogOtherCubeElements
	Do WriteUpdate("Getting detailed cube information for "_cube_": other cube elements")
	Do:tracking WriteTrack("cube","Other cube elements",cube)
	ZN namespace
	Do WriteLog("<hr noshade size=""4"">",2)
	Do WriteLog("<a name=""otherelements"_cube_"""></a>",2)
	Do WriteLog("<h2>Other Elements for "_cube_"</h2>",2)
	If ##class(%DeepSee.Utils).%IsCubeAbstract(cube) {
		Do WriteLog("<p>Not available because the cube is abstract</p>",0)
		ZN "%SYS"
		Quit
	}	
	Do ##class(%DeepSee.Utils).%GetPivotVariables(cube,.pivotvars)
	Do ##class(%DeepSee.Utils).%GetCubeListingFields(cube,.listingfields)
	Do ##class(%DeepSee.Utils).%GetCubeListings(cube,.listings)
	Set model = ##class(%DeepSee.Utils).%GetModel(cube)
	If model="" {
		Set defaultListingName = ""
	} Else {
		Set defaultListingName = model.defaultListing
	}
	/// Pivot Variables
	Do WriteLog("<h4>Pivot Variables</h4>",2)
	If $D(pivotvars){
		Do WriteLog("<table id=""PivotVarTable"" cellpadding=""5"" cellspacing=""5"" class=""tableWithBorders"">",2)
		Do WriteLog("<tbody>",4)
		Do WriteLog("<tr>",6)
		Do WriteLog("<th>Name</th><th>Description</th><th>Default Value</th><th>Type</th>",8)
		Do WriteLog("</tr>",6)
		For ii=1:1:pivotvars{
			Do WriteLog("<tr>",6)
			Do WriteLog("<td>"_$LG(pivotvars(ii),1)_"</td>",8)
			Do WriteLog("<td>"_$LG(pivotvars(ii),2)_"</td>",8)	//Description
			Do WriteLog("<td>"_$LG(pivotvars(ii),3)_"</td>",8)	//Default Value
			Do WriteLog("<td>"_$LG(pivotvars(ii),4)_"</td>",8)	//Type
			Do WriteLog("</tr>",6)
		}
		Do WriteLog("</tbody>",4)
	 	Do WriteLog("</table>",2)
	}
	/// Named sets	
	Do WriteLog("<h4>Named Sets</h4>",2)
	Do WriteLog("")
	Merge namedsets = ^DeepSee.Cubes("cubes",cube,"namedSets")
	If $D(namedsets){
		Do WriteLog("<table id=""NamedSetsTable"" cellpadding=""5"" cellspacing=""5"" class=""tableWithBorders"">",2)
		Do WriteLog("<tbody>",4)
		Do WriteLog("<tr>",6)
		Do WriteLog("<th>Name</th><th>Set Expression</th>",8)
		Do WriteLog("</tr>",6)
		Set ii = $O(namedsets(""))
		While ii'="" {
			Do WriteLog("<tr>",6)
			Do WriteLog("<td>"_$LG(namedsets(ii),1)_"</td>",8)
			Do WriteLog("<td>"_$LG(namedsets(ii),2)_"</td>",8)	//Set Expression
			Do WriteLog("</tr>",6)
			Set ii = $O(namedsets(ii))
		}
		Do WriteLog("</tbody>",4)
	 	Do WriteLog("</table>",2)
	}
	//Listing fields
	Do WriteLog("<h4>Listing Fields</h4>",2)
	If $D(listingfields){
		Do WriteLog("<table id=""ListingFields"" cellpadding=""5"" cellspacing=""5"" class=""tableWithBorders"">")
  		Do WriteLog("<tbody>",2)
    	Do WriteLog("<tr>",4)
      	Do WriteLog("<th>Name</th><th>Field Expression</th><th>Resource</th><th>Description</th>",6)
    	Do WriteLog("</tr>",4)
      	Set tIndex = $O(listingfields(""))
      	While tIndex'="" {
	      	Do WriteLog("<tr>",4)
	      	Do WriteLog("<td>"_$LG(listingfields(tIndex),1)_"</td>",6)
	      	Do WriteLog("<td>"_$LG(listingfields(tIndex),2)_"</td>",6)
	      	Do WriteLog("<td>"_$G(^DeepSee.Cubes("cubes",cube,"listingFields",$LG(listingfields(tIndex),1),"resource"))_"</td>",6)
	    	Do WriteLog("<td>"_$LG(listingfields(tIndex),3)_"</td>",6)
	    	Do WriteLog("</tr>",4)
	    	Set tIndex = $O(listingfields(tIndex))
	    }
		Do WriteLog("</tbody>",2)
		Do WriteLog("</table>")
		Do WriteLog("")
	}
	//Listings
	Do WriteLog("<h4>Listings</h4>",2)
	If $D(listings){
		Do WriteLog("<table id=""ListingTable"_cube_""" cellpadding=""5"" cellspacing=""5"" class=""tableWithBorders"">",2)
		Do WriteLog("<tbody>",4)
		Do WriteLog("<tr>",6)
		Do WriteLog("<th>Listing Name</th>",8)
		Do WriteLog("<th title='Fields are retrieved by parsing SQL expression by comma'>Fields</th>",8)
		Do WriteLog("<th>Source</th>",8)
		Do WriteLog("<th>Resource</th>",8)
		Do WriteLog("</tr>",6)
		//Write fields of listing nicely
		Set listing=$O(listings(""))
		While listing'="" {
			//$$$CUSTOM just marks there are listing fields			
			If listing="$$$CUSTOM" {
				Set listing=$O(listings(listing))
				Continue
			}
			Do WriteLog("<tr>",6)
 			Do WriteLog("<td>"_listing_$S((listing=defaultListingName):" (default)",1:"")_"</td>",8)
			Set fieldString=$LG(listings(listing),2)
 			Set listingSource=$LG(listings(listing),5) 			//Listing source
 			//Resource
 			Set resource = ""
 			Set:(listingSource="cube") resource = $G(^DeepSee.Cubes("cubes",cube,"listing",listing,"resource"))
			Set:(listingSource="listingGroup") resource = $G(^DeepSee.ListingGroups("cubes",cube,"listing",listing,"resource"))
 			Set listingSource=$S(listingSource="listingGroup":"Listing Group",listingSource="cube":"Cube",1:listingSource)
			//Custom SQL listing vs normal listing with fields
			If (fieldString="") {
				Do WriteLog("<td>*No Fields - Custom SQL Listing*</td>",8)	//FieldName
				Do WriteLog("<td>"_listingSource_"</td>",8)
				Do WriteLog("<td>"_resource_"</td>",8)
				Do WriteLog("</tr>",6)
				//Split listing expression on multiple lines on SQL keywords: FROM, WHERE
				//Split an write FROM part
				Set listingExpr = $G(^DeepSee.Cubes("cubes",cube,"listing",listing,"sql"))
				Set tInd = $FIND($ZCONVERT(listingExpr,"U")," FROM ")
				Set stub = $E(listingExpr,0,tInd-6)  
				Set listingExpr = $E(listingExpr,tInd-5,*)
				If tInd {
					Do WriteLog("<tr>",6)
					Do WriteLog("<td></td>",8)	//Skip Listing Name columns
					Do WriteLog("<td>"_stub_"</td>",8)
					Do WriteLog("<td></td>",8)	//Skip Listing Name column
					Do WriteLog("<td></td>",8)	//Skip Listing Name column
					Do WriteLog("</tr>",6)
				}
				//Split an write WHERE part
				Set tInd = $FIND($ZCONVERT(listingExpr,"U")," WHERE ")
				Set stub = $E(listingExpr,0,tInd-7)
				Set listingExpr = $E(listingExpr,tInd-6,*)
				If tInd {
					Do WriteLog("<tr>",6)					
					Do WriteLog("<td></td>",8)	//Skip Listing Name column
					Do WriteLog("<td>"_stub_"</td>",8)
					Do WriteLog("<td></td>",8)	//Skip Listing Name column
					Do WriteLog("<td></td>",8)	//Skip Listing Name column
					Do WriteLog("</tr>",6)
				}
				//Write all that is left
				Do WriteLog("<tr>",6)
				Do WriteLog("<td></td>",8)
				Do WriteLog("<td>"_listingExpr_"</td>",8)
				Do WriteLog("<td></td>",8)	//Skip Listing Name column
				Do WriteLog("<td></td>",8)	//Skip Listing Name column
				Do WriteLog("</tr>",6)
			} Else { //Normal listings
				//Print the list fields (the source properties) separately in the second column
				Set fieldList=$LFS(fieldString,",")
				//Place the first fieldList in the same line
				Set tInd=0
				Do WriteLog("<td></td>",8)	//Skip first field column
				Do WriteLog("<td>"_listingSource_"</td>",8)
				Do WriteLog("<td>"_resource_"</td>",8)
				Do WriteLog("</tr>",6)
				//Do WriteLog("<tr>",6)
				//Write one field per row
				Set field=$LG(fieldList,$I(tInd))
				While field'="" {
					//Try to parse $$$TEXT[] in listings correctly 
					If ($FIND($ZCONVERT(field,"U"),"$$$TEXT[") && '$FIND(field,"]")) { //Typical of Health Insight
						Set field=field_","_$LG(fieldList,$I(tInd))
					}
					//Health Insight has often NVL() || NVL() in listings
					If ($E($ZCONVERT(field,"U"),1,5)["NVL(") {
						Set field=field_","_$LG(fieldList,$I(tInd))
						While ($L(field)<1000) { //Stop in case things go wrong
 							Set fieldafter=$LG(fieldList,tInd+1)
 							If (($E(fieldafter)="'") || ($E(fieldafter)=")")) {
								Set field=field_","_fieldafter
								Set tInd=tInd+1
							} Else {
								Quit
							}
						}
					}
					/*//I don't think field can start with single quote but that happens when using eg NVL()
					If (($E(field)="'") || ($E(field,2)="'")) {
						Set field=field_$LG(fieldList,$I(tInd))
					}*/
					Do WriteLog("<tr>",6)
					Do WriteLog("<td></td>",8) //Nothing in the first column
					Do WriteLog("<td>"_field_"</td>",8)
					Do WriteLog("<td></td>",8) //Nothing in the 3rd column (Source)
					Do WriteLog("<td></td>",8) //Nothing in the 4th column (Resource)
					Do WriteLog("</tr>",6)
					Set field=$LG(fieldList,$I(tInd))
				}
			}
			Set listing=$O(listings(listing))
		}		
		Do WriteLog("</tbody>",4)
	 	Do WriteLog("</table>",2)
	} Else{
		Do WriteLog("No detail listings defined in this cube")
	}
	ZN "%SYS"
	Quit
LogQuerylog
	//Get last N queries run by each user, where N can be secretly chosen from the prompt instead of Y/N
	Do WriteUpdate("Getting Query Log, DeepSee logs, and "_$select(##class(%SYSTEM.Version).GetProduct()["IRIS":"messages.log",1:"cconsole.log"))
	Do:tracking WriteTrack("getlogs","Getting Query Log, DeepSee logs, and "_$select(##class(%SYSTEM.Version).GetProduct()["IRIS":"messages.log",1:"cconsole.log"),"")
	Do WriteLog("<div id=""queryLogMainDiv"" onmouseover=""highlightLink(this,1)"" onmouseout=""highlightLink(this,0)"">")
	Do WriteParagraph("querylog","Query Log")
	Do WriteLog("<h4 id=""querylogtoggle"" onclick=""javascript:toggle('querylogdiv',this.id);"">&rtrif; Expand</h4>",2)
	Do WriteLog("<div id=""querylogdiv"" style=""display:none;"">",2)
	ZN namespace
	Do:($D(^DeepSee.QueryLog)<10) WriteLog("<p>Query log global not found</p></div></div>",2)
	Quit:($D(^DeepSee.QueryLog)<10)
	//Get usercount and querycount in ^DeepSee.QueryLog
 	Set user=$O(^DeepSee.QueryLog(""))
 	Set usercount=0
	Set querycount=0
 	While (user'="") {
 		Set userqueries(user)=$G(^DeepSee.QueryLog(user))
		Set usercount=$I(usercount)
		Set querycount=$I(querycount,userqueries(user))
		Set user=$O(^DeepSee.QueryLog(user))
 	}	
 	//Show table with number of queries run by users
 	Do WriteHeader4("Users running MDX queries",2)
 	//Do WriteLog("<p>Number of users = "_usercount_"</p>")
 	If $D(userqueries) {
 		Do WriteLog("<table id=""QueryLogTable"" cellpadding=""5"" cellspacing=""5"" class=""tableWithBorders"">",2)
		Do WriteLog("<tbody>",4)
		Do WriteLog("<tr>",6)
		Do WriteLog("<th onclick=""sortTable(this,0,1)"">User ("_usercount_" total) </th>",8)
		Do WriteLog("<th onclick=""sortTable(this,1,0)"">Queries run ("_querycount_" total) </th>",8)
		Do WriteLog("</tr>",6)
		Set u = $O(userqueries(""))
		While (u'="") {
			Do WriteLog("<tr>",6)
			Do WriteLog("<td>"_u_"</td>",8)
			Do WriteLog("<td>"_userqueries(u)_"</td>",8)
			Do WriteLog("</tr>",6)
			Set u = $O(userqueries(u))		
		}	
 		Do WriteLog("</tbody>",4)
 		Do WriteLog("</table>",2)
 	}
 	//Show table with the most run queries, 5 by default unless the user used the secret option on prompt
 	Set numqueries = 5
 	Set:(getLogs>1) numqueries = getLogs 	
 	Do WriteHeader4("Most run queries",2)
 	Do MostRunQueries(numqueries) 
 	//Last Query subsection
 	Do WriteHeader4("Last query",2)
	Do WriteLog("<pre>",2)
	Set lastquery=$g(^[namespace]DeepSee.LastQuery)		//Display last query
	If lastquery'=""{		
		Do WriteLog(lastquery,0)
		Use PDev
	}
	Do WriteLog("</pre>",2)
	//Subsection with 5 last queries for each user
 	Do WriteHeader4("MDX queries by user",2)
 	//Show the last 5 queries by default unless the user used the secret option on prompt
	Do lastNQueries(numqueries)
 	Do WriteLog("</div>",2) //Close Expand/Collapse div
 	Do WriteLog("</div>")
	Use PDev
	Quit
LogDeepSeelog 
	//Processes DeepSee Log file
	Try {
		New x
		Set DSFile=$zu(12)_"DeepSeeTasks_"_namespace_".log"
		Do WriteLog("<div id=""DSLogMainDiv"" onmouseover=""highlightLink(this,1)"" onmouseout=""highlightLink(this,0)"">")
		Do WriteParagraph("dslog","DeepSee Logs")
		Do WriteLog("<h4 id=""dslogtoggle"" onclick=""javascript:toggle('dslogdiv',this.id);"">&rtrif; Expand</h4>",2)
		//Do WriteLog("<div id=""dslogdiv"" class=""scrollable"" style=""width:100%;height:400px;"">")
		Do WriteLog("<div id=""dslogdiv"" style=""display:none;"">",2)
		Do WriteLog("<pre>",4)
		Do WriteLog("DeepSee Logs File "_DSFile_":"),WriteLog("")
		Open DSFile:"R":FileOpenTimeOut
		If '$Test Do  Quit
		.	Do WriteLog("Error: could not open DeepSee Logs File "_DSFile)
		.	Use LogFile 
		.	Do WriteLog("</pre>",4)
		.	Do WriteLog("</div>",2)
		.	Do WriteLog("</div>",0)
		.	Use PDev
		.	Quit
		//Read timeout added to prevent the case where neither <ENDOFFILE> error nor $ZEOF terminate the loop
		For  Use DSFile Read x:FileReadTimeOut Set ZEOF=$ZEof Use PDev Quit:'$Test!(ZEOF)  Use LogFile Write x,CRLF Use PDev
		Close DSFile
		Use LogFile
		Do WriteLog("</pre>",4)
		Do WriteLog("</div>",2)
		Do WriteLog("</div>")
		Use PDev
	} Catch(ex) {
		Set tSC = ex.AsStatus()
		Close DSFile
		Use LogFile
		Do WriteLog("</pre>",4)
		Do WriteLog("</div>",2)
		Do WriteLog("</div>")
		Use PDev
	}
	Quit	
LogCPF
	Try {
		//Processes Cache configuration file (usually Cache.cpf)
		New x
		Do WriteLog("<div id=""cpfMainDiv"" onmouseover=""highlightLink(this,1)"" onmouseout=""highlightLink(this,0)"">")
		Do WriteParagraph("cpf","cache.cpf file")
		Use PDev
		Do WriteLog("")
		Do WriteLog("<h4 id=""cpftoggle"" onclick=""javascript:toggle('cpfdiv',this.id);"">&rtrif; Expand</h4>",2)
		//Do WriteLog("<div id=""cpfdiv"" class=""scrollable"" style=""width:100%;height:400px;"">")
		Do WriteLog("<div id=""cpfdiv"" style=""display:none;"">",2)
		Do WriteLog("<p>Cach&eacute; Configuration File "_ConfigFile_":"_"</p>",4)
		Do WriteLog("<pre>",4)
		Open ConfigFile:"R":FileOpenTimeOut
		If '$Test Do  Quit
		.	Do WriteLog("Error: could not open Cach&eacute; Configuration File "_ConfigFile)
		.	Do WriteLog("</pre>")
		.	Do WriteLog("</div>")
		.	Use PDev
		.	Quit
		//Read timeout added to prevent the case where neither <ENDOFFILE> error nor $ZEOF terminate the loop
		Set MapCount=1 		
		Set NsCount=1
		For {
			Use ConfigFile Read x:FileReadTimeOut
			If $p(x,".",1)="[Map"  {				//Grab namespace we are mapping from
				Set NsMap(NsCount) = x
				Set NsCount = $I(NsCount)
			}
			If x["OBJ.DSTIME" {						//Grab OBJ.DSTIME mapping
				Set DSTimeMap(NsCount)=x
			}
			If $p(x,".",1)="Global_DeepSee" {		//Create array of DeepSee.* global mappings within this namespace
				Set DeepSeeMap(NsCount,MapCount) = x
				Set MapCount = $I(MapCount)
			}
			Set ZEOF=$ZEof 
			Use PDev
			Quit:'$Test!(ZEOF)
			Use LogFile 
			Write x,CRLF 
			Use PDev
		}
		Close ConfigFile
		For i=1:1:NsCount{
			Write NsMap(i),!
			Set NumMaps=$O(DeepSeeMap(i,""),-1)
			For k=1:1:NumMaps{
				Write DeepSeeMap(i,k),!
				If k=NumMaps  Write !
			}	
		}
		Use LogFile 
		Do WriteLog("</pre>",4)
		Do WriteLog("</div>",2)
		Do WriteLog("</div>")
		Use PDev
	} Catch(ex) {
		Set tSC = ex.AsStatus()
		Close ConfigFile
		Use LogFile 
		Do WriteLog("</pre>",4)
		Do WriteLog("</div>",2)
		Do WriteLog("</div>")
		Use PDev
	}
	Quit
LogCConsole
	Try {
		//Processes cconsole.log/messages.log
		New cconsoleFile,cconsoleSize,x
		Do WriteLog("<div id=""cconsoleMainDiv"" onmouseover=""highlightLink(this,1)"" onmouseout=""highlightLink(this,0)"">")
		Do WriteParagraph("cconsole",$select(##class(%SYSTEM.Version).GetProduct()["IRIS":"messages.log",1:"cconsole.log"))
		Do WriteLog("<h4 id=""cconsoletoggle"" onclick=""javascript:toggle('cconsolediv',this.id);"">&rtrif; Expand</h4>",2)
		Do WriteLog("<div id=""cconsolediv"" style=""display:none;"">",2)
		Do WriteLog("<pre>",4)
		Use PDev
		If $Data(NoRun("cconsole")) Do  Quit
		.	Do WriteLog(""),WriteLog($select(##class(%SYSTEM.Version).GetProduct()["IRIS":"messages.log",1:"cconsole.log")_" information inhibited by User.")
		.	Do WriteLog("</pre>",4)
		.	Do WriteLog("</div>",2)
		.	Do WriteLog("</div>")
		.	Use PDev
		If OS?1"Win".e!(OS="UNIX"){
			Set cconsoleFile=MgrDir_DirDelim_$select(##class(%SYSTEM.Version).GetProduct()["IRIS":"messages.log",1:"cconsole.log")
		} Else {
			Set:(OS="VMS") cconsoleFile=MgrDir_$zu(28,$select(##class(%SYSTEM.Version).GetProduct()["IRIS":"messages.log",1:"cconsole.log"),5)
		}
		Set cconsoleSize=$ZUtil(140,1,cconsoleFile)
		If 'cconsoleSize Do  Quit
		.	Do WriteLog("File "_cconsoleFile_" is zero bytes long.")
		.	Do WriteLog("</pre>",4)
		.	Do WriteLog("</div>",2)
		.	Do WriteLog("</div>")
		.	Use PDev
		.	Quit
		//Only put the last 8mb in the file
		If cconsoleSize>(8388608 /* 8mb */) {
			Set SkipSize=cconsoleSize-8388608
			Do WriteLog("File "_cconsoleFile_" is too large, skipping first "_SkipSize_" bytes",2)
		} Else {
			Set SkipSize=0
		}
		Do CopyToLog(cconsoleFile,$select(##class(%SYSTEM.Version).GetProduct()["IRIS":"messages.log",1:"cconsole.log"),SkipSize)
	} Catch(ex) {
		Set tSC = ex.AsStatus()
		Do WriteLog("Error in logging the "_$select(##class(%SYSTEM.Version).GetProduct()["IRIS":"messages.log",1:"cconsole.log")_" file")
	}
	Do WriteLog("</pre>",4)
	Do WriteLog("</div>",2)
	Do WriteLog("</div>")
	Use PDev
	Quit
LogMappings
	Do WriteLog("<div id=""mappingsDiv"" onmouseover=""highlightLink(this,1)"" onmouseout=""highlightLink(this,0)"">")
	Do WriteParagraph("Mappings","Mappings")
	ZN "%SYS"
	Try {
		Set rs=##class(%Library.ResultSet).%New("Config.MapGlobals:List")
		Do rs.Execute(namespace)	
		Set next=rs.Next()
		If ('next) {
			Set pre="title=""Mapping ^DeepSee Globals to multiple DBs is recommended"">"
			Set alert = "Alert: No mappings for the "_namespace_" namespace"
			Set alerts($I(alerts)) = pre_alert
			Do WriteLog("<p class=""red"" "_pre_alert_"</p>",8)
			Do WriteLog("</div>")
			Return
		}
		Do rs.Execute(namespace)
		Do WriteLog("<table id=""mappingsTable"" border=""0"" cellpadding=""7"" cellspacing=""3"" class=""zebraStriped"">",2)
		Do WriteLog("<tbody>",4)
		Do WriteLog("<tr>",6)
		Do WriteLog("<th>Global</th>",8)
		Do WriteLog("<th>Database</th>",8)
		Do WriteLog("</tr>",6)
		For {
			Quit:'rs.Next()
			Do WriteLog("<tr>",6)
			Do WriteLog("<td>"_rs.Get("Name")_"</td>",8)
			Do WriteLog("<td>"_rs.Get("Database")_"</td>",8)
			Do WriteLog("</tr>",6)
		}
		Do WriteLog("</tbody>",4)
		Do WriteLog("</table>",2)
		Do WriteLog("<br>",2)		
	} Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Do WriteLog("</div>")
	ZN "%SYS"
	Quit
LogDataBases
	Try {
		Do WriteUpdate("Getting local databases information")
		Do:tracking WriteTrack("databases","Getting local databases information","")
		//CKEY^%SYS.LICENSE
		Do WriteLog("<div id=""LocalDBDiv"" onmouseover=""highlightLink(this,1)"" onmouseout=""highlightLink(this,0)"">")
		Do WriteParagraph("LocalDB","Local Databases")
		Do WriteLog("<br>",2)
		ZN "%SYS"
		Set Maj=##class(%SYSTEM.Version).GetMajor()
		If Maj<2009 {
			Set result=##class(%Library.ResultSet).%New("Config.DataStorage:LocalDatabaseList")
		} Else {
			Set result=##class(%Library.ResultSet).%New("Config.Databases:LocalDatabaseList")
		}
		Set tSC = result.Execute()
		If ('tSC) {
			Do $System.Status.DisplayError(tSC)
			Do:tracking WriteTrack("warning","","LogDataBases",$System.Status.GetErrorText(tSC))
			Quit
		}
		Do WriteLog("<table id=""databaseTable"" border=""0"" cellpadding=""7"" cellspacing=""3"" class=""zebraStriped"">",2)
		Do WriteLog("<tbody>",4)
		Do WriteLog("<tr>",6)		
		Do WriteLog("<th onclick=""sortTable(this,0,1)"">Database</th>",8)
		Do WriteLog("<th onclick=""sortTable(this,1,1)"">Directory</th>",8)
		Do WriteLog("<th onclick=""sortTable(this,2,0)"">Size [MB]</th>",8)
		Do WriteLog("<th onclick=""sortTable(this,3,0)"">Block Size [KB]</th>",8)
		Do WriteLog("<th onclick=""sortTable(this,4,1)"">Status</th>",8)
		Do WriteLog("<th onclick=""sortTable(this,5,1)"">Resource</th>",8)
		Do WriteLog("<th onclick=""sortTable(this,6,1)"">Encrypted</th>",8)
		Do WriteLog("<th onclick=""sortTable(this,7,1)"">Journal</th>",8)	
		Do WriteLog("</tr>",6)
		While result.Next(.tSC) {
			If ('tSC) Quit
			Do WriteLog("<tr>",6)
			Do WriteLog("<td>"_result.Data("Name")_"</td>",8)
			Do WriteLog("<td>"_result.Data("Directory")_"</td>",8)
			Do WriteLog("<td>"_$FNUMBER(result.Data("Size in MB"),",",0)_"</td>",8)
			Set db=##class(SYS.Database).%OpenId(result.Data("Directory"))
			Do WriteLog("<td>"_$FNUMBER(db.BlockSize/1024,",",0)_"</td>",8)
			Do WriteLog("<td>"_result.Data("Status")_"</td>",8)
			Do WriteLog("<td>"_result.Data("Resource")_"</td>",8)
			Do WriteLog("<td>"_result.Data("Encrypted")_"</td>",8)
			Do WriteLog("<td>"_result.Data("Journal")_"</td>",8)
			Do WriteLog("</tr>",6)
		}
		If ('tSC) {
			Do $System.Status.DisplayError(tSC)
			Do:tracking WriteTrack("warning","","LogDataBases",$System.Status.GetErrorText(tSC))
			Quit
		}
		Do WriteLog("</tbody>",4)
		Do WriteLog("</table>",2)
	} Catch(ex) {
		Set tSC = ex.AsStatus()
		Do $System.Status.DisplayError(tSC)
		Do:tracking WriteTrack("warning","","LogDataBases",$System.Status.GetErrorText(tSC))
	}
	Do WriteLog("</div>")
	Quit 1
LogTasks
	Try {
		Do WriteUpdate("Getting background tasks information")
		Do:tracking WriteTrack("tasks","Getting background tasks information","")
		Do WriteLog("<div id=""TaskscheduleDiv"" onmouseover=""highlightLink(this,1)"" onmouseout=""highlightLink(this,0)"">")
		Do WriteParagraph("Taskschedule","Task schedule")
		Use LogFile
		ZN "%SYS"
		Set rs = ##class(%Library.ResultSet).%New("%SYS.Task:TaskListFilter")
		Set:(rs="") rs = ##class(%Library.ResultSet).%New("%SYS.Task:TaskList") //Old versions
		Do rs.Execute()
		Do WriteLog("<table id=""tasksTable"" border=""0"" cellpadding=""7"" cellspacing=""3"" class=""zebraStriped"">",2)
		Do WriteLog("<tbody>",4)
		Do WriteLog("<tr>",6)
		Do WriteLog("<th onclick=""sortTable(this,0,1)"">Task Name</th>",8)
		Do WriteLog("<th onclick=""sortTable(this,1,1)"">Task Type</th>",8)
		Do WriteLog("<th onclick=""sortTable(this,2,1)"">Namespace</th>",8)
		Do WriteLog("<th onclick=""sortTable(this,3,1)"">Description</th>",8)
		Do WriteLog("<th onclick=""sortTable(this,4,0)"">ID</th>",8)
		Do WriteLog("<th onclick=""sortTable(this,5,1)"">Suspended</th>",8)
		Do WriteLog("<th onclick=""sortTable(this,6,1)"">Last Finished</th>",8)
		Do WriteLog("<th onclick=""sortTable(this,7,1)"">NextScheduled</th>",8)
		Do WriteLog("</tr>",6)
		While (rs.Next()) {
			Do WriteLog("<tr>",6)
			Do WriteLog("<td>"_rs.%Get("Task Name")_"</td>",8)
			Do WriteLog("<td>"_rs.%Get("Task Type")_"</td>",8)
			Do WriteLog("<td>"_rs.%Get("Namespace")_"</td>",8)
			Do WriteLog("<td>"_rs.%Get("Description")_"</td>",8)
			Do WriteLog("<td>"_rs.%Get("ID")_"</td>",8)
			Do WriteLog("<td>"_rs.%Get("Suspended")_"</td>",8)
			Do WriteLog("<td>"_rs.%Get("Last Finished")_"</td>",8)
			Do WriteLog("<td>"_rs.%Get("Next Scheduled")_"</td>",8)
			Do WriteLog("</tr>",6)
		}
	} Catch {
		//Do WriteLog("</table>")
		Do WriteLog("<p>An error occurred</p>",2)
	}
	Do WriteLog("</tbody>",4)
	Do WriteLog("</table>",2)
	Do WriteLog("</div>")
	Quit
LogJournal
	Do WriteUpdate("Getting journaling information")
	Do:tracking WriteTrack("journal","Getting journaling information","")
	Do WriteLog("<div id=""JournalingDiv"" onmouseover=""highlightLink(this,1)"" onmouseout=""highlightLink(this,0)"">")
	Do WriteParagraph("Journaling","Journaling",2)
	ZN "%SYS"
	Try{
		Set pdir = ##class(%SYS.Journal.System).GetPrimaryDirectory(.st)
		Set altdir = ##class(%SYS.Journal.System).GetAlternateDirectory(.st)
		Set freesp = ##class(%SYS.Journal.System).GetFreeSpace()
		Set stateString = ##class(%SYS.Journal.System).GetStateString()
		Set filen=1
		Set FileName = ##class(%SYS.Journal.System).GetCurrentFileName()
		While FileName'="" {
			Set FileSize=$zu(140,1,FileName) 
			i (FileSize<0)||($ZU(78,22,FileName)'=1) s Row="Filename" Quit
			Set $li(Row(filen),1)=FileName
			Set $li(Row(filen),2)=FileSize
			Set $li(Row(filen),3)=$zdt($zdth($p($zu(78,22,FileName,4),",",2),-2),3)
			Set $li(Row(filen),4)=4 //..TranslateReason($P($zu(78,22,FileName,1),",",3))
			Do ##class(%SYS.Journal.File).GetPrev(FileName,.FileName)			
			Set filen=filen+1
		}
		ZN namespace
		Use LogFile
		Do WriteLog("<table id=""journalinfoTable"" cellpadding=""7"" cellspacing=""3"" class=""tableWithBorders tableTabbed"">",2)
  		Do WriteLog("<tbody>",4)
    	Do WriteLog("<tr>",6)
    	Do WriteLog("<td>",8)
		Do WriteHeader4("Primary Directory",10)
		Do WriteLog("<p>"_pdir_"</p>",10)
		Do WriteLog("</td>",8)
 		Do WriteLog("</tr>",6)
 		Do WriteLog("<tr>",6)
    	Do WriteLog("<td>",8)
		Do WriteHeader4("Alternative Directory",10)
		Do WriteLog("<p>"_altdir_"</p>",10)
		Do WriteLog("</td>",8)
 		Do WriteLog("</tr>",6)
 		Do WriteLog("<tr>",6)
    	Do WriteLog("<td>",8)
		Do WriteHeader4("Free Space",10)
		Do WriteLog("<p>"_$FNUMBER(freesp/1024/1024,",",0)_" MB </p>",10)
		Do WriteLog("</td>",8)
 		Do WriteLog("</tr>",6)
 		Do WriteLog("<tr>",6)
    	Do WriteLog("<td>",8)
		Do WriteHeader4("State",10)
		Do WriteLog("<p>"_stateString_"</p>",10)
		Do WriteLog("</td>",8)
 		Do WriteLog("</tr>",6)
 		Do WriteLog("</tbody>",4)
    	Do WriteLog("</table>",2)
		If $D(Row(1)) {
			Do WriteHeader4("Journal Files",2)
			Do WriteLog("<table id=""journalTable"" border=""0"" cellpadding=""7"" cellspacing=""3"" class=""zebraStriped"">",2)
			Do WriteLog("<tbody>",4)
			Do WriteLog("<tr>",6)
			Do WriteLog("<th onclick=""sortTable(this,0,1)"">Name</th>",8)
			Do WriteLog("<th onclick=""sortTable(this,1,0)"">Size in KB</th>",8)
			Do WriteLog("<th onclick=""sortTable(this,2,1)"">Creation Time</th>",8)
			Do WriteLog("<th onclick=""sortTable(this,3,1)"">Reason</th>",8)
			Do WriteLog("</tr>",6)
			Set filen=1
			While $D(Row(filen)) {			
				Do WriteLog("<tr>",6)
				Do WriteLog("<td>"_$LG(Row(filen),1)_"</td>",8)
				Do WriteLog("<td style=""text-align:right"">"_$FNUMBER($LG(Row(filen),2)/1024,",",0)_"</td>",8)
				Do WriteLog("<td>"_$LG(Row(filen),3)_"</td>",8)
				Set a=$LG(Row(filen),6)
				Set reas=$S(a=-1:"<STARTUP>",a=0:"unspecified",a=1:"by user",a=2:"file size limit reached",a=3:"to retry failed I/O",
							a=4:"by backup",a=5:"by restore",a=6:"by task manager",a=7:"to activate journal changes",
							a=8:"to reenable journaling",a=9:"by mirror startup",a=10:"by mirror shutdown",a=11:"mirror database removed",1:"Unknown")
				Do WriteLog("<td>"_reas_"</td>",8)
				Do WriteLog("</tr>",6)
				Set filen=filen+1
			}
			Do WriteLog("</tbody>",4)
			Do WriteLog("</table>",2)
		}
	} Catch {
		Do WriteLog("<p>An error occurred</p>",2)
	}
	Do WriteLog("</div>")
	Quit
LogAlerts
	Try {
		Do WriteLog("<div id=""AlertsDiv"" onmouseover=""highlightLink(this,1)"" onmouseout=""highlightLink(this,0)"">")
		Do WriteParagraph("Alerts","Alerts")
		If $D(alerts)>9 { 	//alerts is an array
			Do WriteLog("<p>The following alerts were raised on this system. Please find more details above</p>",2)
			Set i = $O(alerts(""))
			While (i'="") {
				Do WriteLog("<p class=""red"""_alerts(i)_"</p>",2)
				Set i = $O(alerts(i))
			}		
		} Else {
			Do WriteLog("<p>No alerts"_"</p>",2)
		}
	} Catch(ex) {
		Set tSC = ex.AsStatus()
		Do WriteLog("<p>Error: "_tSC_"</p>",2)
	}
	Do WriteLog("</div>")
	Quit
LogTrailer
	//Records a Trailer record to LogFile
	Do WriteParagraph("end","End of DeepSeeButtons")	
	Do WriteLog("<p>"_ConfigName_" on Machine """_HostName_"""</p>")
	Do WriteLog("</div>") //End <div id="main">
	Use PDev
	Quit
LogSidePanel(cubeList,getLogs,numalerts)
	Do WriteLog("<div id=""mySidenav"" class=""sidenav"">")
	Do WriteLog("<a href=""javascript:void(0)"" class=""closebtn"" onclick=""closeNav()"">&times;</a>",2)
	Do WriteLog("<a id=""lDSSetupDiv"" href=""#top"" title=""General setting relevant for DeepSee"">DeepSee Setup</a>",2)
	If (isInsight || isTrak) {
		//Set nOverrides=$$CountNodes(namespace,"^DeepSee.Overrides")
		Do:(nOverrides>=10) WriteLog("<a href=""#overrides"">DeepSee Overrides</a>",2)
	}	
	Do WriteLog("<a id=""lServerDetailsDiv"" href=""#serverdetails"" title=""Information on the hosting machine"">Server Details</a>",2)
	Do WriteLog("<a id=""lCubesDiv"" href=""#cubelist"" title=""Information on all cubes in the namespace"">Cubes</a>",2)
	Do WriteLog("<a id=""lBuildSynchDiv"" href=""#buildsynchlist"" title=""Information on cube build and synchronization"">Build/Synch</a>",2)
	Do WriteLog("<a id=""lRegistryMapDiv"" href=""#cuberegistry"" title=""Cube registry defined by Cube Manager"">Cube Registry</a>",2)
	If (($D(cubeList)'=0) && (cubeList'="")) {
		Do WriteLog("<a id=""lCubeInfoDiv"" href=""#cubeinfo"" title=""Detailed information on cubes"">Cube Info</a>",2)
		Set cubeListLength=$ll(cubeList)
 		For i=1:1:cubeListLength{
			Set cube=$LG(cubeList,i)
			Do:cube'="" WriteLog("<a id=""lCubeInfoDiv"_cube_""" class=""cubelinks"" href=""#cubeinfo"_cube_""">"_cube_"</a>",2)
		}		
	}
	If getLogs{
		Do WriteLog("<a id=""lqueryLogMainDiv"" href=""#querylog"" onclick=""javascript:toggle('querylogdiv','querylogtoggle');"""_
		" title=""Last 5 MDX queries run by each users in the system"">Query Log</a>",2)
		Do WriteLog("<a id=""lDSLogMainDiv"" href=""#dslog"" onclick=""javascript:toggle('dslogdiv','dslogtoggle');"""_
		"title=""A log file with cube builds and errors occurred in the system"">DeepSee Logs</a>",2)
	}
	Do WriteLog("<a id=""lcpfMainDiv"" href=""#cpf"" onclick=""javascript:toggle('cpfdiv','cpftoggle');"""_
	            "title=""The Cach&eacute; Parameter File containing recording the Cach&eacute; configuration"">cache.cpf</a>",2)
	Do:getLogs WriteLog("<a id=""lcconsoleMainDiv"" href=""#cconsole"" onclick=""javascript:toggle('cconsolediv','cconsoletoggle');"""_
	            "title="""_$select(##class(%SYSTEM.Version).GetProduct()["IRIS":"messages.log",1:"cconsole.log")_" file containing general messages and errors"">"_$select(##class(%SYSTEM.Version).GetProduct()["IRIS":"messages.log",1:"cconsole.log")_"</a>",2)
  	Do WriteLog("<a id=""lmappingsDiv"" href=""#Mappings"" title=""Global mapppings defined for the "_namespace_" namespace"">Mappings</a>",2)
  	Do WriteLog("<a id=""lLocalDBDiv"" href=""#LocalDB"" title=""Local databases defined in the instance"">Local Databases</a>",2)  	
  	Do WriteLog("<a id=""lTaskscheduleDiv"" href=""#Taskschedule"" title=""Information on background tasks"">Task Schedule</a>",2)
  	Do WriteLog("<a id=""lJournalingDiv"" href=""#Journaling"" title=""Information on database journaling for the instance"">Journaling</a>",2)
  	Set colorclass=$S(numalerts: "red",1:"")
  	Do WriteLog("<a id=""lAlertsDiv"" class="""_colorclass_""" href=""#Alerts"" title=""Summary of all alerts found on the system"">Alerts ("_numalerts_")</a>",2)
  	Do WriteLog("</div>")
  	Quit
LogCloseBody
	Do WriteLog("</body>")
	Do WriteLog("</html>")
	Do WriteUpdate("DeepSeeButtons report saved to "_LogFile)
	Do:tracking WriteTrack("save","DeepSeeButtons report saved to ",LogFile)
	Do WriteUpdate("Done")
	Do:tracking WriteTrack("complete","Complete","")
	Quit
ValidateNamespace(namespace) [namespace]{
	Set namespace=$ZCONVERT(namespace, "U")
	Try {
		ZN namespace
		return namespace
	} Catch ex {
		Write !,namespace," is invalid.  Please enter a valid namespace."
		Set namespace=""
		Return namespace
	}
}
Init()
	//Sets routine-wide variables
	New i,LogFilePrefix,v,x
	Set PDev=$Principal
	Set CRLF=$Char(13,10)
	Set CmdOpenTimeOut=60
	Set CmdReadTimeOut=30
	Set FileOpenTimeOut=5
	Set FileReadTimeOut=30
	Set CacheVerStr=$ZVersion
	Set CacheVerNumber=$System.Version.GetNumber()
	Set HostName=$ZUtil(54,0)
	Set CacheDir=""
	Set IPAddr="unknown"
	Set FullHostName="unknown"
	Try {
		//$zversion(0) is a bit string that informs what features are enabled in cache'. 
		//It can fail behind a firewalls
		Set IPAddr=$s($zbitget($zversion(0)_$c(0,0,0,0),42):$SYSTEM.INetInfo.HostNameToAddr(HostName,0),1:$p($ZU(54,13,HostName),",",1))
		Set FullHostName=$s($zbitget($zversion(0)_$c(0,0,0,0),42):$SYSTEM.INetInfo.AddrToHostName($s($zbitget($zversion(0)_$c(0,0,0,0),42):$SYSTEM.INetInfo.TextAddrToBinary(IPAddr),1:$ZU(54,1,IPAddr))),1:$p($ZU(54,14,$s($zbitget($zversion(0)_$c(0,0,0,0),42):$SYSTEM.INetInfo.TextAddrToBinary(IPAddr),1:$ZU(54,1,IPAddr))),",",2))
	} Catch(ex) {
		Set tSC = ex.AsStatus()
		Set FullHostName="Unknown"
		Set IPAddr="unknown (due to "_$System.Status.GetErrorText(tSC)_")"
	}
	Set MgrDir=$ZUtil(12)
	Set MgrNsp=$$ST()
	Set CurDir=$ZUtil(12,"")
	Set CurNsp=$ZUtil(5)
	Set x=$ZUtil(86),ConfigFile=$Piece(x,"*",1),ConfigName=$Piece(x,"*",2)
	Set CurUser=$ZUtil(67,11,$Job)
	Set CustomerName=$System.License.KeyCustomerName()
	Set OrderNumber=$System.License.KeyOrderNumber()
	//Equivalent to $System.Version.GetCompBuildOS()
	//Get if Trak or HealthInsight
	Set isInsight=$$isHealthInsight(namespace) 	//Determine if this is a Health Insight namespace (1 if yes)
	Set isTrak=$$isTrak(namespace) 	//Determine if this is a Health Insight namespace (1 if yes)	
	Set nOverrides = "" 
 	Set:(isInsight || isTrak) nOverrides=$$CountNodes(namespace,"^DeepSee.Overrides") 
	Set v=$ZVersion,v=$ZConvert(v,"l")
	If v["windows" Set OS="WinNT" //Windows NT, 2000, XP or 2003 Server
	Else  If v["unix" Set OS="UNIX"
	Else  If v["openvms" Set OS="VMS"
	Else  Set OS="*** Unrecognized OS ***"
	If OS?1"***".e Quit
	If (OS?1"Win".e) {
		Set DirDelim="\"
		Set NullDev="//./nul"
		Do SetDirs
		Set KeyFile=MgrDir_DirDelim_"Cache.key"
		Set BinDir=CacheDir_DirDelim_"Bin"
	} ElseIf (OS="UNIX") {
		Set DirDelim="/"
		Set NullDev="/dev/null/"
		Do SetDirs
		Set KeyFile=MgrDir_DirDelim_"cache.key"
		Set BinDir=CacheDir_DirDelim_"bin"
	} ElseIf (OS="VMS") {
		Set DirDelim="."
		Set NullDev="NL:"
		Do SetDirs
		Set KeyFile=MgrDir_"CACHE.KEY"
		Set i=$Find(MgrDir,".MGR")
		Set BinDir=$Extract(MgrDir,1,i-$Length(".MGR")-1)_".BIN"_$Extract(MgrDir,i,*)
	}
	Quit
InitLogFile()
	Set LogFilePrefix=""
	Set FileOpenTimeOut=5
	Set CustomerName=$System.License.KeyCustomerName()
	If CustomerName'="" Set LogFilePrefix="DeepSeeButtons_"_$Piece(CustomerName," ",1)_"_"
	If LogFilePrefix'="",LogFilePrefix?1a.an,$Length(LogFilePrefix)<20
	Set:LogFile="" LogFile=$$NewFile(LogFilePrefix,"html")
	Quit LogFile
ST()
	//Sets the Manager's Namespace (also hardcoded in %ST)
	ZN "%SYS"
	New
	Do ^ST
	Set MgrNsp=%ST("MGRNSP")
	Quit MgrNsp
DialogCubes(namespace) {
	Set cubeString=""
	ZN namespace
	Do ##class(%DeepSee.Utils).%GetCubeList(.cubeList,,1)
	If '$D(cubeList){
		Write !,"There are no cubes in this namespace!"
		Set cubeList=""
		Quit cubeList
	}
	Do {
		Set cube=""
		Write !,"Give cube name for detailed cube info or press enter to continue: "
		Read cube
		Set:cube="?" cube=$$ListCubes()
		If (cube="")||(cube="QUIT")||(cube="Q") {
			Quit
		} ElseIf (cube'="") {
			If ($LISTFIND($LISTFROMSTRING(cubeString),$ZCONVERT(cube,"t"))'=0) {
				Write !,"Cube already selected"
				Set cube=""
			} ElseIf (cube="ALL") { //problem: it asks again
				Set cubeString=$$GetAllCubes(namespace)
				Set cube="QUIT" //prob useless
				Quit
			} ElseIf ##class(%DeepSee.Utils).%CubeExists(cube,.status)'=1 {
				Write !,cube," is an invalid cube selection: "
				Write !,"Enter '?' to see list of cubes in the "_namespace_" namespace",!
				//Set cube=""
			} Else {
				Set cube=$ZCONVERT(cube,"t")		//Make cube name uppercase to normalize names
				Set cubeString=cubeString_","_cube
			}
		}
	} While (cube'="")&&(cube'="QUIT")&&(cube'="Q")
	Set:$E(cubeString,0,1)="," cubeString=$p(cubeString,",",2,*)	//Eliminate leading comma
	Set cubeSelection=$LFS(cubeString,",")		//Create list
	ZN "%SYS"
	Quit cubeSelection
}
GetAllCubes(namespace)
	Set cubeString=""
	ZN namespace
	Do ##class(%DeepSee.Utils).%GetCubeList(.cubeList,,1)
	Set cubeString=""
	Set cubetmp=$Order(cubeList(""))			
	While (cubetmp'="") {
		Set cubeString=cubeString_","_cubetmp
		Set cubetmp=$Order(cubeList(cubetmp))
	}
	Set cubeString=$P(cubeString,",",2,*)
	ZN "%SYS"
	Quit cubeString
VerifyInputCubes(cubeList,namespace,tracking=0){
	Set len=$LISTLENGTH(cubeList)
	For i=1:1:len{
		Set cube=$LG(cubeList,i)
		Set cube=$ZCONVERT(cube, "U")
		ZN namespace
		If ##class(%DeepSee.Utils).%CubeExists(cube,.status)'=1 {
			Write !!, cube_": invalid cube selection. It will not be included in the report"
			//Do $system.OBJ.DisplayError(status)
			Do:tracking WriteTrack("warning","",cube,"invalid cube selection. It was not included in the report")
			Set cube=""
		}
		Set $LIST(cubeList,i)=cube	//Change element in list to uppercase version (or null if it didn't exist)
	}
	ZN "%SYS"
	Quit cubeList
}
SetDirs
	//Sets Cache Installation Directory
	New i,Dev,Dir
	If OS?1"Win".e!(OS="UNIX") Do
	.	If $Extract(MgrDir,$Length(MgrDir))=DirDelim Set MgrDir=$Extract(MgrDir,1,$Length(MgrDir)-1) //Remove trailing \ or /
	.	If $Extract(CurDir,$Length(CurDir))=DirDelim Set CurDir=$Extract(CurDir,1,$Length(CurDir)-1) //Remove trailing \ or /
	.	Quit
	Else  If OS="VMS" Do
	.	Set MgrDir=$$VMSCanonize(MgrDir)
	.	Set CurDir=$$VMSCanonize(CurDir)
	.	Quit
	If OS?1"Win".e!(OS="UNIX") Set i=$Length(MgrDir,DirDelim)-1,CacheDir=$Piece(MgrDir,DirDelim,1,i)
	Else  If OS="VMS" Do
	.	Set Dev=$Piece(MgrDir,":",1),Dir=$Piece(MgrDir,":",2,*)
	.	If $Extract(Dir,1)="[" Set Dir=$Extract(Dir,2,*)
	.	If $Extract(Dir,$Length(Dir))="]" Set Dir=$Extract(Dir,1,$Length(Dir)-1)
	.	Set Dir=$Piece(Dir,".",1,$Length(Dir,".")-1)
	.	Set Dir="["_Dir_"]"
	.	Set CacheDir=Dev_":"_Dir
	.	Quit
	Quit
ListCubes(){
	Do ##class(%DeepSee.Utils).%GetCubeList(.cubeList,,1)
	Write !, "Cubes in this namespace: ",!!
	Set cubetmp=""
	Set cubetmp=$order(cubeList(""))
	While (cubetmp'="") {
		Write cubetmp,!
		Set cubetmp=$order(cubeList(cubetmp))
	}
	Write "ALL",!
	Write !, "Give cube name for detailed cube info or press enter to continue: "
	Read cube
	Quit cube		//returns "" if no cube number entered
}
LongName(x)
	New (OS,x)
	Set x=$Get(x,"")
	If OS="VMS" Quit x
	Set Space=$Char(32),Quote=$Char(34)
	If x[Space Set x=Quote_x_Quote
	Quit x
VMSCanonize(Dir)
	New (Dir)
	Set Dev=$Piece(Dir,":",1),Dir=$Piece(Dir,":",2,*)
	Set Dir=$Translate(Dir,"<","[") //Replace < by [
	Set Dir=$Translate(Dir,">","]") //Replace > by ]
	Set i=$Length(Dir,"[")-1
	If i>1 Do  //Directory format is [DIR.][SUBDIR]...
	.	If $Extract(Dir,1)="[" Set Dir=$Extract(Dir,2,*)
	.	If $Extract(Dir,$Length(Dir))="]" Set Dir=$Extract(Dir,1,$Length(Dir)-1)
	.	For  Quit:$Piece(Dir,"[",2)=""  Set Dir=$Piece(Dir,"[",1)_$Piece(Dir,"[",2,*)
	.	For  Quit:$Piece(Dir,"]",2)=""  Set Dir=$Piece(Dir,"]",1)_$Piece(Dir,"]",2,*)
	.	Set Dir="["_Dir_"]"
	.	Quit
	Set Dir=Dev_":"_Dir
	Quit Dir
WriteLastStartup
	Try {
		Set timein=$ZHorolog\1, now=$Horolog
		Set timeup=timein
		Set days=timeup\86400
		Set timeup=timeup-(days*86400)
		Set hours=timeup\3600
		Set timeup=timeup-(hours*3600)
		Set minutes=timeup\60
		Set timeup=timeup-(minutes*60)
		Set seconds=timeup
		Set today=+now
		Set secs=$Piece(now,",",2)
		Set now=(today*86400)+secs
		Set then=now-timein
		Set odays=then\86400
		Set osecs=then-(odays*86400)
		Set oh=odays_","_osecs
		Do WriteLog("<p>"_$ZDATETIME(oh,3)_". As of this report Cach&eacute; has been up for "_days_" days "_hours_" hours "_minutes_" minutes "_seconds_" seconds"_"</p>",8)
	} Catch(ex) {		
		Set tSC = ex.AsStatus()
		Do WriteLog($System.Status.GetErrorText(tSC),10)
		Do:tracking WriteTrack("warning","","WriteLastStartup",$System.Status.GetErrorText(tSC))
	}
	Quit
isHealthInsight(namespace){
	Try{
		ZN namespace
		Set HealthShare=##class(%SYSTEM.License).GetFeature(12) 	//Look in license for HealthShare Foundation
		ZN "%SYS"
		Return HealthShare
	} Catch {
		ZN "%SYS"
		Return 0						//Method did not work so return 0
	}
}
isTrak(namespace){
	Try{
		ZN namespace
		Set BitTrakCare = ##class(%SYSTEM.License).GetFeature(6) 	//BitTrakCare
		ZN "%SYS"
		Return BitTrakCare
	} Catch {
		ZN "%SYS"
		Return 0						//Method did not work so return 0
	}
}
NLS
	Try {
		New LocCur,LocDesc,LocSrc,oLoc
		Do WriteHeader4("Current Locale",8)
		ZN "%SYS"		
		Set oLoc=##class(Config.NLS.Locales).OpenCurrent()
		If oLoc="" Set LocCur="Unknown",LocDesc="Unknown"
		Else  Set LocCur=oLoc.Name,LocDesc=oLoc.Description		
		Set LocSrc=$$ComputeFullDBDir^%SYS.API("Locale")
		Do WriteLog("<p>"_LocCur_" ("_LocDesc_")</p>",8)
	} Catch(ex) {		
		Set tSC = ex.AsStatus()
		Do WriteLog($System.Status.GetErrorText(tSC),10)
		Do:tracking WriteTrack("warning","","NLS",$System.Status.GetErrorText(tSC))
	}
	Quit
OSVer
	//This is almost the same as the OSVer function in ^Buttons
	Try {
		//Add the OS version to LogFile
		New Cmd,uname
		Do WriteHeader4("Operating System Version",8)
		Do WriteLog("<p>",8)
		If OS?1"Win".e Set Cmd="Ver"
		If OS="UNIX" Set Cmd="uname -a"
		If OS="VMS" Set Cmd="WRITE SYS$OUTPUT ""OpenVMS "",F$GETSYI(""VERSION"")"		
		Do ExternalCmd(Cmd)
		//Do ExternalCmd^Buttons(Cmd)
		If OS="UNIX" Set uname=$$uname()
		If ($D(uname) && (uname?1"AIX".e)) {
			Do WriteLog(" -- ",8)
			Do ExternalCmd("lsattr -El proc0")
			//Do ExternalCmd^Buttons("lsattr -El proc0")
		}
	} Catch(ex) {		
		Set tSC = ex.AsStatus()
		Do WriteLog($System.Status.GetErrorText(tSC),10)
		Do:tracking WriteTrack("warning","","OSVer",$System.Status.GetErrorText(tSC))
	}
	Do WriteLog("</p>",8)
	Quit
uname()
	New (CmdOpenTimeOut,CmdReadTimeOut,PDev)
	Set Cmd="uname -s"
	Open Cmd:"RQ":CmdOpenTimeOut
	If '$Test Quit ""
	Try {
		Use Cmd Read uname:CmdReadTimeOut Use PDev
	} Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Close Cmd
	Quit uname
RAM
	Do WriteHeader4("RAM",8)
	//First refresh CPU info
	Do $ZU(204,0)
	Do WriteLog("<p>Model: "_$ZU(204,2)_"</p>",8)
	Do WriteLog("<p>Chips: "_$ZU(204,6)_"</p>",8)
	Do WriteLog("<p>Cores: "_$ZU(204,5)_"</p>",8)
	Do WriteLog("<p>Threads: "_$ZU(204,4)_"</p>",8)	
	Do WriteLog("<p>Frequency: "_$ZU(204,11)_" MHz</p>",8)	
	Set temp = $ZU(190,18)
	Do WriteLog("<p>Total physical memory: "_$FNUMBER($P(temp,",",1)/1024,",",0)_" MB</p>",8)
	Do WriteLog("<p>Free physical memory: "_$FNUMBER($P(temp,",",2)/1024,",",0)_" MB</p>",8)
	Do WriteLog("<p>Total paging/swap space: "_$FNUMBER($P(temp,",",3)/1024,",",0)_" MB</p>",8)
	Do WriteLog("<p>Free paging/swap space: "_$FNUMBER($P(temp,",",4)/1024,",",0)_" MB</p>",8)
	Do WriteLog("",8)
	Quit
DiskSpace
	Do WriteHeader4("Disk space",8)
	Do ##class(%Library.File).DriveListExecute(.drivelist)
	For {
		Set st=##class(%Library.File).DriveListFetch(.drivelist,.drive,.AtEnd)
		Set drive = $LG(drive)
		Do ##class(%Library.File).GetDirectorySpace(drive,.free,.total,1)
		Do WriteLog("<p>Total space in """_drive_""" drive: "_$FNUMBER(total,",",0)_" MB</p>",8)
		Do WriteLog("<p>Free space in """_drive_""" drive:  "_$FNUMBER(free,",",0)_" MB</p>",8)
		Quit:AtEnd
	}	
	Quit
CountNodes(namespace,g){
	ZN namespace
	Return:'$D(@g) 0
	For count=$D(@g)#10:1 Set g=$Query(@g) Quit:g=""
	Return count
}
GetLastBuild(CubeEvent,cubename) [cubename,CubeEvent,cubekey,cubeevent,totaltime,cubesize,finishtime,factsupdated,SQLCODE] {
	new cubekey,totaltime,cubesize,finishtime,factsupdated,SQLCODE
	Set sql ="SELECT TOP 1 CubeKey,TotalTime,CubeSize,FinishTime,FactsUpdated " _
				"FROM %DeepSee_CubeManager.CubeEvent " _
				"WHERE CubeEvent='"_CubeEvent_"' "_ 
				$S($D(cubename):"AND CubeKey='"_cubename_"' ",1:"") _
				"ORDER BY FinishTime DESC"
	Set rs = ##class(%SQL.Statement).%ExecDirect(.S,sql)
	Set SQLCODE=""
	If rs.%Next() {
		Set cubekey = rs.%Get("CubeKey")
		Set totaltime = rs.%Get("TotalTime")
		Set cubesize = rs.%Get("CubeSize")
		Set finishtime = rs.%Get("FinishTime")
		Set factsupdated = rs.%Get("FactsUpdated")
		Set SQLCODE = rs.%SQLCODE
	}
	IF SQLCODE=0 {
		If CubeEvent="Synch"{
    		Set string=$FNUMBER(factsupdated,"O,")_" facts synched on "_finishtime_" in "_totaltime_" seconds"
		} ElseIf CubeEvent="Build"{
			Set string=$FNUMBER(cubesize,"O,")_" facts built on "_finishtime_" in "_totaltime_" seconds"
		} ElseIf CubeEvent="Update"{
			Set string="on "_finishtime
		} ElseIf CubeEvent="Repair"{
			Set string=$FNUMBER(cubesize,"O,")_" facts built on "_finishtime_" in "_totaltime_" seconds"
		} Else {			
			Set string=CubeEvent_" event on "_finishtime_" in "_totaltime
		}
		Set:'$D(cubename) string = string_" for the "_cubekey_" cube"
   	} ElseIf SQLCODE=100 {
	   	Set string = "Not found"
   	} Else {
	   	Set string = "SQL Error code: "_SQLCODE
   	}
   	Quit string
}
GetRelationships(cube){
	Quit:##class(%DeepSee.Utils).%IsCubeCompound(cube)	//Can't have a related, compound cube
	Set status=##class(%DeepSee.Utils).%GetDimensionList(cube,.dimlist)
	Set nodenum=$O(dimlist(""),-1)			//Get last node in dimlist
	Set count=0
	If status=1 {
		For {
			If $LG(dimlist(nodenum,0,0),1)="r"{			//If dimension is a relationship...
				Set count=count+1						//increment count
				Set dimname=$LG(dimlist(nodenum,0,0),2)	//Get name of relationship
				Set relationships(count)=##class(%DeepSee.Utils).%GetRelatedCube(cube,dimname)	//Related cube name
			}
			Quit:nodenum=0								//If no dimensions defined, first node will be 0
			Set nodenum=$O(dimlist(nodenum),-1)
			Quit:$LG(dimlist(nodenum,0,0),1)'="r"
		}
		If count=0 {
			Write " "
		} Else {
			For i=1:1:count {
				If $g(relationships(i),"null")'="null" {
					Write relationships(i)
					Write:(i'=count) ", "
				}
			}
		}
	}
	Quit
}
GetSourceClass(cube,type)[storageList, dataConnectorList]{
	Try {
		Set sourceClass=""
		If type="cube" {
			Set cubeObj=##class(%DeepSee.Utils).%GetModel(cube)
			If cubeObj=""{
				Set sourceClass = "Subject area class not compiled"
				Quit
			}
			Set sourceClass=cubeObj.sourceClass				//Source Class name
			If sourceClass=""&&isInsight{
				Set sourceClass=^DeepSee.Overrides(cube,"SOURCECLASS")	//Source class isn't part of cube object	
			}
			Set classObj=##class(%Dictionary.CompiledClass).%OpenId(sourceClass)
			Set storage=classObj.StorageStrategy
			Set super=classObj.Super
			If storage["SQLStorage"{
				Set $LIST(storageList,*+1)=cube
			}
			If super["%DeepSee.DataConnector"{
				Set $LIST(dataConnectorList,*+1)=cube
			}
		} ElseIf type="subjectArea" {
			Set basecube=##class(%DeepSee.Utils).%GetBaseCube(cube)
 			Do ##class(%DeepSee.Utils).%GetCubeList(.plist)
 			Set typebasecube = $LG(plist(basecube),4)
 			Set sourceClass = $$GetSourceClass(basecube,typebasecube)
		} Else {
 			Set sourceClass="Not available"
		}
	} catch {
		Set sourceClass = "Not available"
	}
	Quit sourceClass
}
GetCountStar(sqlclass){
	Try {
		Set FactCount=""
		Set SQLQuery="SELECT COUNT(*) As FactCount FROM "_sqlclass
		Set tStatement = ##class(%SQL.Statement).%New()
		Set st = tStatement.%Prepare(SQLQuery)
		If 'st {
			Set FactCount = $System.Status.DisplayError(st)
			Quit
		}
		Set rset = tStatement.%Execute()
		If (rset.%SQLCODE < 0) {
			Set FactCount = rset.%Message
			Quit
		}
		Do rset.%Next()
		Set FactCount = rset.FactCount
	} Catch(ex) {
		Set FactCount = ex.AsStatus()
		Do $System.Status.DisplayError(tSC)
	}
	Quit FactCount
}
GetDeepSeeAuditCode
	Kill auditcode,querycode
	Do WriteHeader4("Audit",8)
	Try {
		If $D(^[namespace]DeepSee.AuditCode){
			Set auditcode=$g(^[namespace]DeepSee.AuditCode)
			Do WriteLog("<p>DeepSee.AuditCode: "_auditcode_"</p>",8)
		} Else{
			Do WriteLog("<p>^DeepSee.AuditCode is undefined</p>",8)
		}
		If $D(^[namespace]DeepSee.AuditQueryCode){
			Set querycode=$g(^[namespace]DeepSee.AuditQueryCode)
			Do WriteLog("<p>DeepSee.AuditQueryCode: "_querycode_"</p>",8)
		} Else{
			Do WriteLog("<p>^DeepSee.AuditQueryCode is undefined</p>",8)
		}
	} Catch {
		Write "Not Available"
	}	
	Quit 
GetBuildTime(cube)
	[time,cube] PUBLIC{
	new time
	Set cube=$zconvert(cube,"u")
	Set sql ="SELECT TotalTime FROM %DeepSee_CubeManager.CubeEvent where cubekey='" _
			cube _ "' and cubeevent='Build' order by finishtime desc"
	Set rs = ##class(%SQL.Statement).%ExecDirect(.S,sql)
	If rs.%Next() {
		Quit rs.%Get("TotalTime")
	} Else{
		Quit ""
	}
}
FieldNameToSpec(pCubeName) {	
	Set tSC = 1
	Q:pCubeName=""
	Try {	
		Set tCube = $G(^DeepSee.Cubes("cubes",$zu(28,pCubeName,5),"indexName"),$zu(28,pCubeName,5))		
		//Loop over indD,indH,indL in ^DeepSee.Cubes("cubes",tCube,"mbr#",indD,indH,indL)
		 Set indD = $O(^DeepSee.Cubes("cubes",tCube,"mbr#",""))
		 While (indD '= "") {
		 	Set indH = $O(^DeepSee.Cubes("cubes",tCube,"mbr#",indD,""))
		 	While (indH '= "") {
		 		Set indL = $O(^DeepSee.Cubes("cubes",tCube,"mbr#",indD,indH,""))
		 		While (indL '= "") {
		 			Set list = ^DeepSee.Cubes("cubes",tCube,"mbr#",indD,indH,indL)
		 			Set type = $LG(list,1)
		 			Set tIndex = $LG(list,5)
		 			If ((tIndex'="") && ((type="l") || (type="m") || (type="r"))) { 
		 				Set tIndexName = $S($E(tIndex)="M":$G(^DeepSee.Cubes("cubes",tCube,"msr#",tIndex),tIndex),
							1:$G(^DeepSee.Cubes("cubes",tCube,"fact#",tIndex),tIndex))
						If ($D(^DeepSee.Cubes("cubes",tCube,"fact","prop",tIndexName,"alias"))) {
							Set tIndexName = ^DeepSee.Cubes("cubes",tCube,"fact","prop",tIndexName,"alias")
						}
						If ((type="l") && (tIndexName'="") && (tIndex>1)) { //Also skipping %Search with tIndex=1
			 				Set dimname = $LG(list,2)
			 				Set hiername = $LG(list,3)
			 				Set levelname = $LG(list,4)
			 				Set fieldname2spec(tIndexName) = "["_dimname_"].["_hiername_"].["_levelname_"]"
		 					Write !,?4,tIndexName,?41," ",fieldname2spec(tIndexName)
		 				} ElseIf ((type="m") && (tIndex'="")) { //e.g. COUNT has no tIndex 
		 					Set dimname = $LG(list,2) 	//this is always "Measures"
		 					Set measname = $LG(list,3)
		 					If '$D(fieldname2spec(tIndexName)) {
		 						Set fieldname2spec(tIndexName) = "["_dimname_"].["_measname_"]"
 							} Else {
	 							Set fieldname2spec(tIndexName) = fieldname2spec(tIndexName)_", ["_dimname_"].["_measname_"]"
							}
		 					Set fieldname2spec(tIndexName) = "["_dimname_"].["_measname_"]"
		 					Write !,?4,tIndexName,?41," ",fieldname2spec(tIndexName)
		 				} ElseIf (type="r") {
		 					Set dimname = $LG(list,2)
		 					Set fieldname2spec(tIndexName) = "["_dimname_"]"
		 					Write !,?4,tIndexName,?41," ",fieldname2spec(tIndexName)
		 				}
		 			}
		 			Set indL = $O(^DeepSee.Cubes("cubes",tCube,"mbr#",indD,indH,indL))
		 			} 		
		 		Set indH = $O(^DeepSee.Cubes("cubes",tCube,"mbr#",indD,indH))
		 	}	
			Set indD = $O(^DeepSee.Cubes("cubes",tCube,"mbr#",indD))
		}
		Set tSC = 1
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
}
MostRunQueries(numqueries)
 	//Show table with the most run queries
 	//Use $ZCRC(,7) to hash an MDX query, then create two arrays: 
 	//  queryarr(hashed MDX query) = frequency
 	//  crcarr(hashed MDX query) = MDX query
 	Set u = ""
 	Set i = ""
 	For {
	 	Set u = $O(^DeepSee.QueryLog(u))
	 	Quit:u=""
	 	For {
		 	Set i = $O(^DeepSee.QueryLog(u,i)) 
		 	Quit:i=""
		 	//Strip some patterns from MDX queries
		 	Set strippedquery = $ZSTRIP(^DeepSee.QueryLog(u,i),"*C") 	//strip control characters
		 	Set strippedquery = $REPLACE(strippedquery,", ",",")		//replace ", "
		 	Set strippedquery = $ZSTRIP(strippedquery,"<=>W")  			//strip leading, trailing, and repeating white spaces
		 	Set crc = $ZCRC(strippedquery,7)
		 	If $D(queryarr(crc)) {
			 	Set queryarr(crc) = $I(queryarr(crc))
		 	} Else {
		 		Set queryarr(crc) = 1
		 		Set crcarr(crc) = strippedquery
		 	}
		 }
	}
	//Reverse the queryarr array to get frequencies handy:
	//  freqarr(frequency, hashed MDX query) = MDX query
	Set c = ""
	For {
		Set c = $O(queryarr(c))
		Quit:c=""
		Set f = queryarr(c)
		Set freqarr(f,c) = crcarr(c)
	}
	//Print
	Do WriteLog("<table id=""FrequentQueriesTable"" cellpadding=""5"" cellspacing=""5"" class=""tableWithBorders"">",2)
	Do WriteLog("<tbody>",4)
	Do WriteLog("<tr>",6)
	Do WriteLog("<th onclick=""sortTable(this,0,0)"">#</th>",8)
	Do WriteLog("<th onclick=""sortTable(this,0,0)"">Frequency</th>",8)
	Do WriteLog("<th onclick=""sortTable(this,1,1)"">Query</th>",8)
	Do WriteLog("</tr>",6)
	Set freq = ""
	For n = 1:1:numqueries {
		Set freq = $O(freqarr(freq),-1)
		Quit:freq=""
		Do WriteLog("<tr>",6)
		Do WriteLog("<td>"_n_"</td>",8)
		Do WriteLog("<td>"_freq_"</td>",8)
		Do WriteLog("<td>",8)
		Set hashed=""
		Set counter = 0
		For {
			Set hashed=$O(freqarr(freq,hashed))
			Quit:hashed=""
			Do:counter=7 WriteLog("<p> ... </p>",10) //Show up to 6 queries per frequency
			Quit:counter=7
			Set query = freqarr(freq,hashed)
			Do WriteLog("<p>"_$$encode(query)_"</p>",10)
			Set counter= $I(counter)
		}
		Do WriteLog("</td>",8)
		Do WriteLog("</tr>",6)
	}
	Do WriteLog("</tbody>",4)
 	Do WriteLog("</table>",2)
 	Quit
lastNQueries(numqueries)
	Do WriteLog("<pre class=""wrapped"">",4)
	Set username=""
	For k=1:1 {
		Set numqueriesuser = numqueries
		Set username=$O(^DeepSee.QueryLog(username),1)
		If username="" Quit
		Set totqueries=$O(^DeepSee.QueryLog(username,""),-1)
		Set:totqueries<numqueriesuser numqueriesuser = totqueries
		Do WriteLog("Last "_numqueriesuser_" of "_totqueries_" MDX queries by User: "_username,6)
		Set counter=""
		For i=1:1:numqueriesuser {
			Quit:i>totqueries				//User has fewer than 5 queries
			Set counter=$O(^DeepSee.QueryLog(username,counter),-1)
			Set query=$Get(^DeepSee.QueryLog(username,counter))
			If query'=""{
				Do WriteLog( i_") "_$$encode(query),0)
			}
		}
	}
	Do WriteLog("</pre>",2)
	Quit
encode(string) {
	Quit $ZCVT(string,"O","HTML")
}
alertRoutineSize(RoutineSize,alerts) {
	Try {
		If (RoutineSize=0) {
			Set pre="title=""Routine buffers have the default ''0'' value and might need customization"">"
			Set alert = "Alert: Routine buffers have not been customized"
			Set alerts($I(alerts)) = pre_alert
			Do WriteLog("<p class=""red"" "_pre_alert_"</p>",8)
		}
		Set tSC = 1
	} Catch (ex) {
		Set tSC = ex.AsStatus()
		Do $System.Status.DisplayError(tSC)
	}
	Quit tSC
}
alertGlobalKSize(GlobalKSize,alerts) {
	Try {
		If (GlobalKSize="0,0,0,0,0,0") {
			Set pre="title=""Global buffers have the default ''0,0,0,0,0,0'' values and might need customization"">"
			Set alert = "Alert: Global buffers have not been customized"
			Set alerts($I(alerts)) = pre_alert
			Do WriteLog("<p class=""red"" "_pre_alert_"</p>",8)
		}
		Set tSC = 1
	} Catch (ex) {
		Set tSC = ex.AsStatus()
		Do $System.Status.DisplayError(tSC)
	}
	Quit tSC
}
alertDStimeRW(DSTimeMapFrom,alerts) {
	Try {
		ZN "%SYS"
		//Check if DB is Read-Write
		Set sc = ##class(Config.Databases).Get(DSTimeMapFrom, .prop)
		//If a remote DB is used we do not know
		If prop("Server")'="" {
			Set db=##Class(SYS.Database).%OpenId(prop("Directory"))
			Set readonly = db.ReadOnly
			If readonly {
				Set pre="title=""In Cach&eacute; versions including DevChange DTB422 ^OBJ.DSTIME and ^DeepSee.Update should be mapped to a Read-Write database"">"
				Set alert = "Alert: ^OBJ.DSTIME and/or ^DeepSee.Update are stored in the "_DSTimeMapFrom_" database, which should be Read-Write"
				Set alerts($I(alerts)) = pre_alert
				Do WriteLog("<p class=""red"" "_pre_alert_"</p>",8)
			}
		}
		Set tSC = 1
	} Catch (ex) {
		Set tSC = ex.AsStatus()
		Do $System.Status.DisplayError(tSC)
	}
	Quit tSC
}
alertAgentMappings(ns,alerts) {
	Try{
		// Loop through all NS and check agents global. Make sure # of NS = # of DBs
		ZN "%SYS"	
		Set tSC = 1
		// get list of NS
		Do ##class(%SYS.Namespace).ListAll(.nsarray,0)
		Set tempNS=$O(nsarray(""))
		While tempNS'="" {
			If $E(tempNS)="@" {
				Set tempNS=$O(nsarray(tempNS))
				continue
			}
			Set sysdir=##class(%SYS.Namespace).GetGlobalDest(tempNS,"^DeepSee.Agents")
			//sysdir is system^directory, but only the directory is needed for the following call
			Set DB=##class(SYS.Database).%OpenId($P(sysdir,"^",2))
			Do ##Class(Config.Databases).DatabasesByDirectory($P(sysdir,"^",1),$P(sysdir,"^",2),.listDB)
			Set DBname=$LISTTOSTRING(listDB,",") //In general I would expect one DB but there could be more
			Set dbArray(DBname)=$I(dbArray(DBname))
			Set dbArray(DBname,dbArray(DBname))=tempNS
			Set tempNS=$O(nsarray(tempNS))
		}
		Set dbName=$O(dbArray(""))
		While dbName'="" {
			If (dbArray(dbName)>1) {
				Set pre="title=""Agent globals can not be shared across namespaces"">"
				Set alert = "Alert: Database "_dbName_" has ^DeepSee.Agents mapped to it from multiple namespaces"
				Set alerts($I(alerts)) = pre_alert
				Do WriteLog("<p class=""red"" "_pre_alert_"</p>",8)
			}
			Set dbName=$O(dbArray(dbName))
		}
	} Catch (ex) {
		Set tSC = ex.AsStatus()
		Do WriteLog("<p class=""red"" "_$System.Status.GetErrorText(tSC)_"----ALE</p>",8)
	}
	Quit tSC
}
alertCacheMappings(ns,alerts) {
	Try {
		//Check if ^DeepSee.Cache.Results, .Axis, .Cells end up in a journaled DB
		ZN "%SYS"		
		Set tSC = 1
		Set DSCacheGlobals = $LB("DeepSee.Cache.Results","DeepSee.Cache.Axis","DeepSee.Cache.Cells")
		While 1 {
			Set cacheGlob=$LG(DSCacheGlobals,$I(i))
			Quit:(cacheGlob="")
			Set sysdir=##class(%SYS.Namespace).GetGlobalDest(ns,cacheGlob)
			//sysdir is system^directory, but only the directory is needed for the following call
			Set DB=##class(SYS.Database).%OpenId($P(sysdir,"^",2))
			If (DB.GlobalJournalState = 3) {
				Do ##Class(Config.Databases).DatabasesByDirectory($P(sysdir,"^",1),$P(sysdir,"^",2),.listDB)
				Set DBname=$LISTTOSTRING(listDB,",") //In general I would expect one DB but there could be more
				Set pre="title=""Journaling the DeepSee cache leads to problems with disk size and query performance"">"
				Set alert = "Alert: The DeepSee cache stored in the "_DBname_" database is journaled"
				Set alerts($I(alerts)) = pre_alert
				Do WriteLog("<p class=""red"" "_pre_alert_"</p>",8)
				Quit
			}	
		}
	} Catch (ex) {
		Set tSC = ex.AsStatus()
		Do WriteLog("<p class=""red"" "_$System.Status.GetErrorText(tSC)_"----ALE</p>",8)
	}
	Quit tSC
}
alertJoinIndexMappings(ns,alerts) {
	Try {
		//Check if ^DeepSee.JoinIndex ends up in a journaled DB. 
		//It should go with the cache but it is less bad than journaling ^DeepSee.Cache* globals. 
		//For this reason I keep this alert separate from alertCacheMappings
		ZN "%SYS"		
		Set tSC = 1
		Set cacheGlob = "DeepSee.JoinIndex"
		Set sysdir=##class(%SYS.Namespace).GetGlobalDest(ns,cacheGlob)
		//sysdir is system^directory, but only the directory is needed for the following call
		Set DB=##class(SYS.Database).%OpenId($P(sysdir,"^",2))
		If (DB.GlobalJournalState = 3) {
			Do ##Class(Config.Databases).DatabasesByDirectory($P(sysdir,"^",1),$P(sysdir,"^",2),.listDB)
			Set DBname=$LISTTOSTRING(listDB,",") //In general I would expect one DB but there could be more
			Set pre="title=""We suggest mapping the ^DeepSee.JoinIndex global together with the DeepSee cache to an unjournaled database"">"
			Set alert = "Alert: The ^DeepSee.JoinIndex global stored in the "_DBname_" database is journaled"
			Set alerts($I(alerts)) = pre_alert
			Do WriteLog("<p class=""red"" "_pre_alert_"</p>",8)
		}	
	} Catch (ex) {
		Set tSC = ex.AsStatus()
		Do WriteLog("<p class=""red"" "_tSC_"</p>",8)
	}
	Quit tSC
}
alertInitialBuildCubeManager(cube,msgrepair,msgbuild,alerts) {
	Try {
		Set alert=""
		Set pre="title=""Before you synchronize cubes from the Cube Manager, it is necessary to build the cubes at least once from the Cube Manager."">"
		If ((msgrepair="Not found") && (msgbuild="Not found")) {
			Set alert = "Alert: there is no record for the initial build of "_cube_" from Cube Manager. Check if the cube is updating"
			Set alerts($I(alerts)) = pre_alert
		}
		Set tSC = 1
	} Catch(ex) {
		Set tSC = ex.AsStatus()
		Set alert = tSC
		Set alerts($I(alerts)) = alert
	}
	Do WriteLog("<p class=""red"" "_pre_alert_"</p>",8)
}
alertTimeLevels(timeLevels,alerts) {
	Try {
		Set throwalert=0
		Set DimNo=$O(timeLevels(""))
		For {
			Quit:DimNo=""
			Set HierNo=$O(timeLevels(DimNo,""))
			For {
				Quit:HierNo=""
				Set groupparent = ""
				Set levelparent = ""	
				Set LevelNo=$O(timeLevels(DimNo,HierNo,""))
				For {
					Quit:LevelNo=""
					Set levelType = $LG(timeLevels(DimNo,HierNo,LevelNo),1)
					Set group = $S(levelType="%DeepSee.Time.Decade":"G1",
						levelType="%DeepSee.Time.Year":"G1",
						levelType="%DeepSee.Time.QuarterYear":"G1",
						levelType="%DeepSee.Time.MonthYear":"G1",
						levelType="%DeepSee.Time.DayMonthYear":"G1",
						levelType="%DeepSee.Time.WeekYear":"G2",
						levelType="%DeepSee.Time.WeekNumber":"G3",		
						levelType="%DeepSee.Time.QuarterNumber":"G4",
						levelType="%DeepSee.Time.MonthNumber":"G4",
						levelType="%DeepSee.Time.DayNumber":"G5",
						levelType="%DeepSee.Time.DayOfWeek":"G6",
						levelType="%DeepSee.Time.HourNumber":"G7",
						levelType="%DeepSee.Time.MinuteNumber":"G8",
						1:"custom")
					Set level = $S(levelType="%DeepSee.Time.Decade":9,
						levelType="%DeepSee.Time.Year":8,
						levelType="%DeepSee.Time.QuarterYear":7,
						levelType="%DeepSee.Time.MonthYear":6,
						levelType="%DeepSee.Time.DayMonthYear":3,
						levelType="%DeepSee.Time.WeekYear":5,
						levelType="%DeepSee.Time.WeekNumber":4,
						levelType="%DeepSee.Time.QuarterNumber":7,
						levelType="%DeepSee.Time.MonthNumber":6,
						levelType="%DeepSee.Time.DayNumber":3,
						levelType="%DeepSee.Time.DayOfWeek":3,
						levelType="%DeepSee.Time.HourNumber":2,
						levelType="%DeepSee.Time.MinuteNumber":1,
						1:"custom")
					//Start by excluding the custom time dimensions. 
					If (group="custom") || (groupparent="custom") {
						//Custom time levels. Good to go
					} ElseIf (groupparent = "") || (levelparent="") {
						//Top level. Good to go
					} ElseIf (level>levelparent) {
						// Levels can never be inverted
						Set throwalert = 1
					} ElseIf (group'=groupparent) {
						// Groups can never be mixed
						Set throwalert = 1
					}
 					If throwalert=1 {
	 					Set tl = timeLevels(DimNo,HierNo,LevelNo)
	 					Set pre="title=""Placing certain time levels such as Year of Month in the same hierarchy as a week level will lead to unexpected results"">"
	 					Set alert = "The "_$LG(tl,3)_"."_$LG(tl,4)_"."_$LG(tl,5)_" level in the "_$LG(tl,2)_
	 						" cube using the "_$LG(tl,1)_" time function is incompatible with other time levels in the same hierarchy"
	 					Set alerts($I(alerts)) = pre_alert
						Do WriteLog("<p class=""red"" "_pre_alert_"</p>",0)
						Set throwalert=0
	 					//Advance to next hierarchy, right?
	 					Quit
 					}
 					Set groupparent = group
 					Set levelparent = level
 					Set LevelNo=$O(timeLevels(DimNo,HierNo,LevelNo))
				}
				Set HierNo=$O(timeLevels(DimNo,HierNo))
			}
			Set DimNo=$O(timeLevels(DimNo))
		}
		Set tSC = 1
	} Catch (ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}
alertBadHierarchies(cube,alerts) {
	Set tSC=1
	Set tSC=##class(%DeepSee.Utils).%GetDimensionTables(cube,.tables)
	Set tTable=$O(tables(""))
	While tTable'="" {
		Try {
			Set tDimension=$Piece(tTable,".",3)
			Set:$Extract(tDimension,1,4)="Star" tDimension="Dx"_$Extract(tDimension,5,*)
			Set tSQL="SELECT COUNT(DISTINCT "_tDimension_") UniqueMembers, COUNT(*) TotalMembers FROM "_##class(%DeepSee.Utils).%GetSQLTableName(tTable)
			Set tSQLRS=##class(%SQL.Statement).%ExecDirect(,tSQL)
			Do tSQLRS.%Next()
			If tSQLRS.UniqueMembers'=tSQLRS.TotalMembers {
				// BAD HIERARCHY
				Set pre="title=""Bad Hierarchy"">"
				Set alert = "The "_tDimension_" star table in the "_cube_" cube contains members with non-unique parents"
				Set alerts($I(alerts)) = pre_alert
				Do WriteLog("<p class=""red"" "_pre_alert_"</p>",0)
			}
		} Catch {
		}
		Set tTable=$O(tables(tTable))
	}
	Quit tSC
}
WriteLog(string,spaces)
	//Adds a record to LogFile
	If string?1"***".e Quit
	Use LogFile
	If '$D(spaces) Set spaces=0
	Write !,?spaces,string
	Quit
WriteParagraph(name,title,flag)
	If '$D(flag) Set flag = 1
	Do:flag WriteLog("<hr noshade size=""4"">",2)
	Do WriteLog("<a name="""_name_"""></a>",2)
	Do WriteLog("<h2>"_title_"</h2>",2)
	Quit
WriteHeader4(header,spaces,title)
	Use LogFile
	If '$D(spaces) Set spaces=0
	If '$D(title) Set title=""
	Do WriteLog("<h4"_$S(title="":"",1:" title="""_title_"""")_">"_header_"</h4>",spaces)
	Quit
WriteUpdate(msg)
	New (msg, PDev, LogFile, tracking)
	Use PDev
	Write $C(13,27)_"[0J"_msg
	Use LogFile
	Quit
WriteTrack(phase,mgs="",details="",errors="")
	ZN namespace
	Set tStep = $Case(phase,"setup":1,"cubelog":2,"buildsynch":3,"cube":4,"getlogs":5,"databases":6,"tasks":7,"journal":8,"save":9,"warning":10,"complete":12,"error":13,:11)
	Set ^IRIS.Temp.DeepSeeButtonsTrack(+$J,tStep)=$LB(phase,mgs,details,errors)
	//If logging detail info on cubes or a warning, create a third node in the global
	Set:phase="cube" ^IRIS.Temp.DeepSeeButtonsTrack(+$J,tStep,details)=$LB(phase,mgs,details,errors)	
	Set:phase="warning" ^IRIS.Temp.DeepSeeButtonsTrack(+$J,tStep,details)=$LB(phase,mgs,details,errors)	
WriteAdhocPatch
	Try {
		Set patchvar=$Order(^%qPatch(""))
		While (patchvar'=""){
			Set data=^%qPatch(patchvar)
			Set patchvar2=$Order(^%qPatch(patchvar))			
			Do WriteLog("<p style=""margin-left:3em;"">Adhoc: "_$list(data)_"</p>",8)
			Do WriteLog("<p style=""margin-left:6em;"">Description: "_$list(data,2)_"</p>",8)
			Do WriteLog("<p style=""margin-left:6em;"">Created at: "_$list(data,5)_"</p>",8)
			Do WriteLog("<p style=""margin-left:6em;"">Created on $zv: "_$piece($list(data,6),")",1,2)_")"_"</p>",8)
			Do WriteLog("<p style=""margin-left:6em;"">Applied on: "_$list(data,7)_"</p>",8)
			Do WriteLog("<p style=""margin-left:6em;"">Applied by: "_$list(data,8)_"</p>",8)
			Do WriteLog("")
			Set patchvar=$Order(^%qPatch(patchvar))
		}
	} Catch(ex) {
		//Set tSC = ex.AsStatus()
		Do WriteLog("<p>An error occurred</p>",8)
	}
	Quit
PrintGlobal(namespace,glob,spaces){
	ZN namespace
	Quit:'$D(@glob)
	Quit:glob=""
	Set:$D(spaces) spaces = 0
	Set queryary=$QUERY(@glob@(""))
	Set res=@queryary
	Set quote=""
	Set:'(res=+res) quote=""""
	If $ListValid(res) {
		//This seems to provide good formatting for ^DeepSee.CalcMbrs
		Set res = "$lb("""_$REPLACE($LISTTOSTRING(res,"@"),"""","""""")_""")"
		Set res = $REPLACE(res,"@",""",""")
		Set quote=""
	}
	Do WriteLog("<p>"_queryary_" = "_quote_res_quote_"</p>",spaces)
	For   {
    Set queryary=$QUERY(@queryary) 
        Quit:queryary=""
        Set res=@queryary
		Set quote=""
		Set:'(res=+res) quote=""""
        Do WriteLog("<p>"_queryary_" = "_quote_res_quote_"</p>",spaces)
	}
}
NewFile(LogFilePrefix,LogFileSuffix)
	//Creates a new file with Date and Time added to the filename and opens it for Reading and Writing
	//File Name can be either "Cache" or "cstat"
	New Date,Dir,NewFile,Time
	Set:LogFileSuffix="" LogFileSuffix="html"
	Set Date=$TRANSLATE($ZD($H,3),"-","")
	Set Time=$TRANSLATE($ZT($P($H,",",2),2),":","")
	If (OS?1"Win".e) {
		Set LogFileSuffix=$ZConvert(LogFileSuffix,"l")
	} ElseIf (OS="UNIX") {
		Set LogFileSuffix=$ZConvert(LogFileSuffix,"l")
	} ElseIf (OS="VMS") {
		Set LogFileSuffix=$ZConvert(LogFileSuffix,"U")
	}
	Set Dir=MgrDir
	Set LogDirectory=$Get(LogDirectory,"")
	Set:LogDirectory'="" Dir=LogDirectory
	If (OS?1"Win".e) {
		Set NewFile=Dir_DirDelim_LogFilePrefix_Date_"_"_Time_"."_LogFileSuffix
	} ElseIf (OS="UNIX") {
		Set NewFile=Dir_DirDelim_LogFilePrefix_Date_"_"_Time_"."_LogFileSuffix
	} ElseIf (OS="VMS") {
		Set NewFile=Dir_$ZConvert(LogFilePrefix,"U")_Date_Time_"."_LogFileSuffix_";"
	}
 	//	Open NewFile:"RWNSK\UTF8\":FileOpenTimeOut
 	//	If '$Test Quit ""
	Quit NewFile
ExternalCmd(Command)
	//Executes an external program and adds its output to LogFile
	//Requires the full specification of the Exe file
	New PDev,x
	Set PDev=$Principal
	If OS="UNIX" Do ExtCmdPipe
	If OS?1"Win".e!(OS="VMS") Do ExtCmdFile
	Use PDev
	Quit
ExtCmdPipe
	//Executing an OS command through a pipe works on UNIX
	//It should also work on 32-bit Windows (NT, 2000 and XP), but I found inconsistent behavior on these platforms
	Open Command:"RQ":CmdOpenTimeOut
	If '$Test Quit
	Try {
		//Read timeout added to prevent the case where neither <ENDOFFILE> error nor $ZEOF terminate the loop
		For  Use Command Read x:CmdReadTimeOut Set ZEOF=$ZEof Use PDev Quit:'$Test!(ZEOF)  If x'="" Do WriteLog($ZConvert(x,"O","HTML"))
		Close Command
	} Catch(ex) {
		Set tSC = ex.AsStatus()
		Close Command
	}
	Quit
ExtCmdFile
	//Only to be executed when OS is Windows or VMS, when either pipes don't work or behave inconsistently
	New Date,File,Time
	Set Date=$TRANSLATE($ZD($H,3),"-","")
	Set Time=$TRANSLATE($ZT($H,2),":","")
	If OS?1"Win".e Do
	.	Set File=MgrDir_DirDelim_Date_Time_".$$$"
	.	Set Command=$Char(34)_Command_" > "_$$LongName(File)_$Char(34) //Cache will call "Cmd /c", which requires quotes surrounding the command
	.	Quit
	Else  If OS="VMS" Set File=MgrDir_Date_Time_".$$$"
	If OS?1"Win".e Set x=$ZF(-1,Command)
	Else  If OS="VMS" Set x=$ZF(-1,Command,File)
	Set $ZTrap="ExitCmdNoFile"
	Open File:"R":FileOpenTimeOut
	If '$Test Do WriteLog("Error: could not open file "_File) Quit
	Set $ZTrap="ExitCmdFileEOF"
	//Read timeout added to prevent the case where neither <ENDOFFILE> error nor $ZEOF terminate the loop
	For { 
		Use File
		Read x:FileReadTimeOut
		Set ZEOF=$ZEof
		Use PDev
		Quit:'$Test!(ZEOF)
		If x'="" Do WriteLog($ZConvert(x,"O","HTML"))
	}
	Set $ZTrap=""
	Set $ZError=""
	Close File
	If OS="VMS" Do
	.	If $Extract(File,$Length(File))'=";" Set File=File_";"
	.	Set File=File_"*"
	.	Quit
	Set x=$ZUtil(140,5,File) //Delete temporary scratch file
	Quit
ExitCmdFileEOF
	Set $ZTrap=""
	Set $ZError=""
	Close File
	If OS="VMS" Do
	.	If $Extract(File,$Length(File))'=";" Set File=File_";"
	.	Set File=File_"*"
	.	Quit
	Set x=$ZUtil(140,5,File) //Delete temporary scratch file
	Quit
ExitCmdNoFile
	Set $ZTrap=""
	Set $ZError=""
	Quit
CopyToLog(InputFile,Caption,SkipSize=0)
	//Appends a file to LogFile. Used for cconsole.log/messages.log
	//InputFile can be cconsole.log/messages.log, the generated cstat output file, inuse.dmp or dumpkeys.txt
	//SkipSize - Skip the first x number of bytes in the file to reduce size. Used by cconsole.log/messages.log
	//to keep it a reasonable size
	New %DAT,%TIM,x
	Do INT^%D,INT^%T
	Do WriteLog(Caption_" on "_%DAT_" at "_%TIM_":"),WriteLog("")
	Try {
		Open InputFile:"R":FileOpenTimeOut
		If '$Test Do WriteLog("File "_InputFile_" does not exist") Do WriteLog("</pre>") Use PDev Quit
		//Read timeout added to prevent the case where neither <ENDOFFILE> error nor $ZEOF terminate the loop
		If SkipSize>0 Do WriteLog("File "_InputFile_" is too large, skipping first "_SkipSize_" bytes"),WriteLog("")
		Set Size=0
		For { 
			Use InputFile 
			Read x:FileReadTimeOut 
			Set ZEOF=$ZEof 
			Use PDev 
			Quit:'$Test!(ZEOF)  
			Set Size=Size+$l(x) 
			Continue:SkipSize>Size  
			Use LogFile 
			Write $zconvert(x,"O","HTML"),CRLF 
			Use PDev
		}
	} Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Close InputFile
	Quit

EDITOR^INT^1^67214,47330
EDITOR ;
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
A s %A=$T(%)
 i ($zversion(1)=2) S %A=$T(%NT)
 s ^%=$P(%A," ;;",2,256)
 F %I=1:1 S %A=$T(%+%I),%T=$P(%A," "),%B=$P(%A," ;;",2,256) Q:%T="END"  I $L(%T) S ^%(%T)=%B
 G ^EDITOR1
 ; This and the other EDIT* routines set up the ^% and ^%RS globals by
 ; copying lines into them from within these routines themselves.  A
 ; line here with tag "x" is copied into ^%(x), for instance.  Untagged
 ; lines aren't copied, and therefore are comments.
%NT ;;S %NX=1 X ^%(0) X:'$D(^%IS($I,1)) ^%("CON") X:'$D(XY)&'$D(^%IS($I,1)) ^%("LAT") S XY=$G(XY) F  X ^%(%NX) I '$D(%NX) U 0:(:3) Q
% ;;S %NX=1 X ^%(0) X:'$D(^%IS($I,1)) ^%("LAT") S XY=$G(XY) F  X ^%(%NX) I '$D(%NX) U 0:0 Q
0 ;;S %SL=30,%RM=80 K:$G(XY)]"" XY I $D(^%IS($I,1)) S %A=$P(^(1),"^",3) I %A]"",$D(^%IS(0,"SUB",%A)) S %SL=$P(^(%A),"^",3)-1,%RM=+^(%A) U $I:(%RM:0) I '$D(XY) S XY=$P(^(%A),"^",5),DX=0,DY=%SL-1 X XY
1 ;;R !,"Edit: ",%X S %NX=$S(%X="":30,%X[$C(9):640,%X?1A.E&(%X[" "):500,%X?1"^".E:"GLO",%X?1".".E:600,%X="?":930,1:10)
10 ;;S %T=%X,%NX=999 X ^%("TAG") Q:%L=""  S %NX=1 W:%X'=%T " "_%T S %TG=%T X $S(XY]"":^("EDXY"),1:^("ED")) S %NX=19
ED ;;F  R " R ",%R Q:%R=""  X ^($S(%R="END":16,%R="end":16,%L[%R:14,%R["...":20,1:17))
14 ;;R " W ",%W S %L=$P(%L,%R)_%W_$P(%L,%R,2,$L(%L,%R))
15 ;;S %L=%LS W !,%L,!
16 ;;R " W ",%W S %L=%L_%W
17 ;;W " ???"
18 ;;ZR @%TG ZI:%L]"" %L S %A=$P($P(%L,"(")," "),%NX=1 S:%A]"" %TG=%A I XY="" W ! I %L]"" P @%TG
19 ;;X ^("LN1") S %NX=18 I %POP W !?5,"[Tag syntax]" X $S(XY]"":^("EDXY"),1:^("ED")) S %NX=19
20 ;;S %A=$P(%R,"..."),%B=$P(%R,"...",2,999),%J=$F(%L,%A),%C=%J-1-$L(%A),%D=$S(%B="":$L(%L)+1,1:$F(%L,%B,%J)) W:%C<0!(%D<1) " ???" Q:%C<0!(%D<1)  R " W ",%W S %L=$E(%L,1,%C)_%W_$E(%L,%D,*)
30 ;;S %X="*",%NX=10 ;S %NX=$S($D(%TG):31,1:999)
40 ;;S %X="+"_(%TG+%X),%NX=10
400 ;;S %NX=1 R "reak line: ",%X S %T=$S(%X]"":%X,$D(%TG):%TG,1:"") Q:%T=""  X ^("TAG") S %NX=999 I %L]"" S %NX=401 W:%X'=%T " "_%T S %TG=%T
401 ;;S %NX=1 R " after characters: ",%R I %R'="",%L[%R S %LS=$P(%L,%R,2,999),%LS=$E(" ",%LS'?1" ".E)_%LS,%L=$P(%L,%R)_%R ZR @%TG ZI %L,%LS W !,%L,!,%LS
500 ;;W ! S %NX=1 X %X
550 ;;R "oin line: ",%X S %T=$S(%X]"":%X,1:$G(%TG)) Q:%T=""  X ^("TAG") S %NX=999 I %L]"" S %NX=555 W:%T'=%X "  "_%T
555 ;;S %I=$P(%T,"+"),%J=$P(%T,"+",2),%C=$T(@%I+%J+1),%NX=999 W " and " I %C]"" W $S($E(%C)=" ":%I_"+"_(%J+1),1:$P($P(%C,"(")," ")) S %NX=560
560 ;;S %B=$T(@%I+%J),%NX=565 I $L(%B)+$L(%C)<510 ZR @(%T_":"_%T_"+1") ZI %B_" "_$P(%C," ",2,999) S %NX=1 W ! P @%T S %TG=%T
565 ;;W !,"The combined lines are toooooooooooooooooo long (over 510 characters)" S %NX=999
 ;dot command lead-in:
 ; .  = (601) end         .I = (620) insert     .C = (650) change every
 ; .S = (750) search      .R = (900) remove     .F = (800) file
 ; .M = (MV)  move        .B = (400) break      .J = (550) join
 ; .E = (690) screen edit .D = (***) display    .FX = (***) file/exit
 ; .G = (***) buffer get  .P = (***) buffer put
 ;
600 ;;S %A=$E(%X,2,*),%Z=$E(%A),%NX=$S(%A="":601,"Ii"[%Z:620,"Cc"[%Z:650,"Ss"[%Z:750,"Rr"[%Z:900,"Ff"[%Z:800,"Mm"[%Z:"MV","Bb"[%Z:400,"Jj"[%Z:550,"Ee"[%Z:690,"Dd"[%Z:"D00","Gg"[%Z:"G00","Pp"[%Z:"P00",1:999)
601 ;;K %NX,%Y,%S,%A,%B,%L,%R,%W,%C,%D,%F,%Z,%J,%I,%K,%T,%POP,%X,%IED,%GLO,%E,%CTG,%RM,%SL
620 ;;S %NX=1 R "nsert after: ",%X S %T=$S(%X]"":%X,1:$G(%TG)) Q:%T=""  X ^%("TAG") S %NX=999 I %L]"" W:%X'=%T " ",%T ZR @%T ZI %L S %NX=624,%TG=%T
624 ;;S %NX=630 R !,"Line: ",%L X:%L="?" ^(625) Q:%L=""  S %NX=624 X ^%("LN1") W:%POP *7,!,?5,"[Tag syntax]" I '%POP ZI %L S %A=$P($P(%L,"(")," "),$P(%TG,"+",2)=$P(%TG,"+",2)+1 I %A]"" S %TG=%A X ^%("EDTAG") S %NX=624
625 ;;W !,"Enter a line of Cache ObjectScript source code:",!?3,"[tag (if desired)] <SPACE> [Cache ObjectScript commands]" S %NX=624
630 ;;I $D(%TG) S %NX="EDTAG"
640 ;;S %NX=1,%L=$P(%X,$C(9))_" "_$P(%X,$C(9),2) X ("ZI %L:"_%TG) S $P(%TG,"+",2)=$P(%TG,"+",2)+1 S:$P(%L," ")]"" %TG=$P($P(%L," "),"(")
EDTAG ;;S %NX=1 ;I $P(%TG,"+")]"" S %NX=300,%X=";"_$P(%TG,"+") W !,%X F %IEE=0:0 X ^%(%NX) I %NX=1 Q
650 ;;S %NX=1 R "hange every: ",%R Q:%R=""  R " to: ",%W,! X ^("SELECT") S %D=$L(%W)-$L(%R),%NX=$S(%POP:999,1:655)
655 ;;S %NX=1 F %A=%A:1:%I S %L=$T(+%A),%F=$F(%L,%R),%X=%F X:%X>0 ^(656) S:$P(%L," ")]"" %B=$P($P(%L,"(")," "),%C=0,%T=%B S %T=$S(%C:%B_"+"_%C,1:%B) W:%X>0 !,%T,$P($P(%L," "),%T,2,99),?6," ",$P(%L," ",2,99) S %C=%C+1
656 ;;X ^(670) ZR +%A ZI %L
670 ;;F  S %L=$E(%L,0,%F-$L(%R)-1)_%W_$E(%L,%F,*),%F=$F(%L,%R,%F+%D) Q:%F<1
UC ;;S %=$zcvt(%,"u")
690 ;;X:$D(^%qce) ^%("%qce") S %NX=1
%qce ;;N ejob,file X ^%qce("ejob"),^%qce(1),^%qce(2) K ^mtemp(ejob)
END ;;

EDITOR1^INT^1^67214,47330
EDITOR1 ;(PTR,PK,ADF) EDIT SINGLE LINES
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 F %J=1:1 S %A=$T(%+%J),%T=$P(%A," "),%B=$P(%A," ;;",2,256) Q:%T="END"  I $L(%T) S ^%(%T)=%B
 G ^EDITOR2
% ;
GLO ;;S %NX=999 W:%X="^"&$D(%GLO) $E(%GLO,2,99) S:%X="^"&$D(%GLO) %X=%GLO Q:$E(%X,2)="("!(%X="^")  I $D(@%X)#2 S %GLO=%X,%L=@%X W:XY="" "  "_%L,! X $S(XY]"":^%("EDXY"),1:^%("ED")) S @%GLO=%L,%NX=1 W:XY="" !,%L
900 ;;W "emove lines:" X ^("SELECT") S %NX=999 Q:%POP  R !,"OK to remove lines? ",%R S %NX=$S("Yy"[$E(%R_"?"):910,1:905)
905 ;;S %NX=1 W " [no change]",!
910 ;;S %NX=920 F %IED=%A:1:%I S %B=$P($P($T(+%IED)," "),"(") I %B]"" K ^COMMENT($T(+0),%B)
920 ;;S %NX=1 ZR +%A:+%I W " ...deleted lines",!
999 ;;W " ??? " S %NX=1
EDXY ;;S %N="E0",$Y=250 U $I:(%RM:1) F  S %E=$D(%E(%N)) X:%E %E(%N) X:'%E ^(%N) Q:'$D(%N)
EXY ;;U $I:(%RM:0) S DX=0,DY=%EY X XY K %EX,%EY,%SY,DX,DY,%N Q
E0 ;;S %N="E1" I '$D(%E("E3")) F %A="E3","E4","EB","ES","EP","EEN","EE1","EE4" S %E(%A)=^(%A)
E1 ;;W ! S:$Y>%SL $Y=%SL S %SY=$Y W %L S %EX=$X,%EY=$Y,%N="E2",%A=1 I $Y>(%SL) S %SY=%SY+%SL-$Y,$Y=%SL,%EY=$Y
E2 ;;S DX=%A-1#%RM,DY=%A-1\%RM+%SY,%N="E3"
E3 ;;S %N="E4" X:DX'<%RM ^("ER") X XY
E4 ;;R *%X S %X=$S($C(%X)?1L:%X-32,1:%X),%N=$S(%X=69:"EE",%X=8:"EB",%X=13!(%X=10)!(%X=27):"EOL",%A>$L(%L):"E4",%X=32:"ES",%X=46:"EP",%X=127:"ERUB",%X=68:"EDEL",1:"E4")
EP ;;S %A=%A+1,DX=DX+1,%N="E3"
ES ;;S %N="E3" F %IED=%A:1:$L(%L) S %A=%A+1,DX=DX+1 Q:" ,"[$E(%L,%A)
EB ;;S %N="E3" Q:%A=1  S DX=DX-1,%A=%A-1 I DX=-1 S DX=%RM-1,DY=DY-1
ERUB ;;S %IED=%A+1,%N="EDEL2"
EDEL2 ;;W $E(%L,%IED,*) S %N="E4",%L=$E(%L,1,%A-1)_$E(%L,%IED,*) S %C=$X,%Y=$Y W:$Y<%EY ?%RM,! W ?%EX S %EY=%Y,%EX=%C X XY
EDEL ;;S %N="EDEL2" F %IED=%A+1:1 Q:" ,"[$E(%L,%IED)
EE ;;S %C=%A,%B=$E(%L,%A,*),%Y="",%D=0,%N="EEN"
EEN ;;R *%X S %N=$S(%X=127&%D:"EER",%X=13!(%X=10)!(%X=27):"EEE",$C(%X)?1C:"EEN",1:"EE1")
EE1 ;;W $C(%X) S DX=DX+1 X:DX'<%RM ^("ERE") W %B S %N=$S($Y>%SL:"EE2",$Y>%EY:"EE3",1:"EE4")
EE2 ;;S %N="EEN",%EY=%SL,%SY=%SY-$Y+%EY,%EX=$X,DY=DY-$Y+%EY,%D=%D+1,%Y=%Y_$C(%X) X XY
EE3 ;;S %N="EEN",%EY=$Y,%EX=$X,%D=%D+1,%Y=%Y_$C(%X) X XY
EE4 ;;S:($Y=%EY)&(%EX<$X) %EX=$X S %D=%D+1,%Y=%Y_$C(%X),%N="EEN" X XY
EEE ;;S %L=$E(%L,1,%A-1)_%Y_$E(%L,%C,*),%N="E2",%A=%A+$L(%Y) I $X>%EX,DY=%EY S %EX=$S(%RM>$X:$X,1:%RM)
EER ;;S %D=%D-1,%Y=$E(%Y,1,%D),%N=$S(DX:"EER1",1:"EER2")
EER1 ;;W $C(8)_%B_" " S DX=DX-1,%N="EEN" X XY
EER2 ;;S DX=%RM-1,DY=DY-1,%N="EEN" X XY W %B_" " X XY
ER ;;X ^("ER1"):DX'<%RM I DY>%SL S %EY=%SL,%SY=%SY+%EY-DY,DY=%EY,%EX=$X
ER1 ;;S DX=DX#%RM,DY=DY+1 I 'DX W !
EOL ;;S %N=$S(%A=1:"EXY",1:"E2"),%A=1
ERE ;;S DX=0,DY=DY+1 I DY>%SL S %EY=%SL,%SY=%SY+%EY-DY,DY=%EY,%EX=$X W ! S $Y=%SL
D00 ;;S %NX=1 W "isplay" X ^%("SELECT") S:%POP %NX=999 Q:%POP  W ! P +%A:+%I
G00 ;;S %NX=1 W "et from " X ^%("BUF") Q:%Z=""  S %NX="G01" I '$D(^mtemp1("buffer",%Z,1)) W "  <this buffer does not exist>",!?7,"G" S %NX="G00"
G01 ;;S %NX=1 R !?7,"Insert after line: ",%T Q:%T=""  X ^%("TAG") Q:%L=""  ZR @%T ZI %L F %IED=1:1 S %A=$G(^mtemp1("buffer",%Z,%IED)) ZI:%A]"" %A I %A="" W !,"(inserted)",! Q
P00 ;;S %NX=1 W "ut into " X ^%("BUF") Q:%Z=""  S %NX="P01"
P01 ;;S %NX="P02" I $D(^mtemp1("buffer",%Z)) R !,"This buffer exists.  Do you want to overwrite this buffer? No => ",% I "Yy"'[$E(%_"N") S %NX=1
P02 ;;S %NX=1 W !?6 X ^%("SELECT") S:%POP %NX=999 Q:%POP  K ^mtemp1("buffer",%Z) S ^(%Z)=$H_","_$J_","_$I,%IED=0 F %A=%A:1 S %IED=%IED+1,^mtemp1("buffer",%Z,%IED)=$T(+%A) I %A=%I W !,"(copied)",! Q
 ;BUF will allow selection of a buffer & allow listing them
BUF ;;S %X=$X X ^%("BUFC") F  R "buffer: ",% X ^%("UC") S %Z=% Q:%'["?"  W ! X ^%("BUFL") W !!?%X
BUFL ;;S (%,%Z)="" F  S %=$O(^mtemp1("buffer",%)) Q:%=""  I $D(^(%,1)) X ^%("BUFS")
BUFH ;;W !!,"Buffer    # lines   First line text" S %Z=1
BUFS ;;X:%Z="" ^%("BUFH") W !,$J(%,6)_"    ",$J($O(^mtemp1("buffer",%," "),-1),6)_"    ",$G(^(1))
BUFC ;;S %="" F  S %=$O(^mtemp1("buffer",%)) Q:%=""  I $G(^(%))-$H K ^(%)
END ;;

EDITOR2^INT^1^67214,47330
EDITOR2 ;(PTR,PK,ADF) CONTINUATION ROUTINE FOR THE EDITOR.
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 F %I=1:1 S %A=$T(%+%I),%T=$P(%A," "),%B=$P(%A," ;;",2,256) Q:%T="END"  I $L(%T) S ^%(%T)=%B
 G ^EDITOR3
 ; Check for syntax of tag as part of line.
% ;
750 ;;S %NX=1 R "earch for: ",%R Q:%R=""  X ^("SELECT") S %NX=$S(%POP:999,1:755)
755 ;;S %NX=1,%T=$S(%C:%B_"+"_%C,1:%B) F %A=%A:1:%I S %L=$T(+%A) S:$P(%L," ")]"" %B=$P($P(%L,"(")," "),%C=0,%T=%B W:%L[%R !,%T_$P($P(%L," "),%T,2,99),?6," "_$P(%L," ",2,999),! S %C=%C+1,%T=%B_"+"_%C
800 ;;S %NX=999 X:$ZN="" ^%(801) I $ZN]"" X ^%(808),^%(805)
801 ;;W !,"(no routine name has been specified)",!,*7
 ; line 601 forces an exit
805 ;;S %NX=1 ZS  W "ile "_$ZN I "Xx"[$E(%X_"???",3) S %NX=601
808 ;;X ^%(809) S %B=$T(+1),$P(%B," ;",3)=" "_$ZD($H,2,,4)_"  "_%C ZR +1 ZI %B
809 ;;S %A=$P($H,",",2)\60,%B=" AM" S:%A'<720 %A=%A-720,%B=" PM" S:%A<60 %A=%A+720 S %C=%A\60_":"_(%A#60\10)_(%A#10)_%B
TAG ;;X:%T?.1"%".8AN1"-".1N&(%T'?1"-".N) ^("TAGM") X:%T?1"*".E!(%T?1"+".N)!(%T?1"-".N)&$D(%TG) ^("TAGS") S:%T?1.""""1"+"1.N %T="+"_$P(%T,"+",2) S %L="",%D=$P(%T,"+"),%E=$P(%T,"+",2) Q:%D'?1.AN&(%D'?1"%".AN)&(%D]"")!(%E'?.N)  S %T=%D,%L="" S %F=%E,%E=-1 F %I=0:1:%F S %E=%E+1,%T=$S(%E:%D_"+"_%E,%D]"":%D,1:"+999"),@("%L=$T("_%T_")") I $P(%L," ")]"" S %D=$P($P(%L,"(")," "),%E=0,%T=%D
TAGM ;;I $T(@$P(%T,"-"))]"" S %TG=$P(%T,"-"),%T="-"_$P(%T,"-",2)
TAGS ;;S:$E(%T)="*" %T=$E(%T,2,9) S:%T="" %T="+0" S:%T?1P %T=%T_1 I "+-"[$E(%T),%T?1P.N S %T=$P(%TG,"+")_"+"_($P(%TG,"+",2)+%T) I %T["-" F %J=1:1 S %F=$T(+%J) Q:%F=""  I $P($P(%F,"(")," ")=$P(%T,"+") S %T="+"_(%J+$P(%T,"+",2)) Q
SELECT ;;S %POP=1 R " from line: BEG=> ",%T S:%T="" %T="""+1" X ^("TAG") Q:%L=""  S %B=%D,%C=%E X ^("SEL3") S %A=%I R " to line: END=> ",%T S (%D,%E)="" X ^("TAG"):%T]"" S %POP=%L=""&(%T]"") Q:%POP  X ^("SEL3") S %POP=%A>%I
 ;SEL3 F %I=1:1 S %L=$T(+%I) Q:%L=""  I $P($P(%L,"(")," ")=%D,%D]"" S %I=%I+%E Q
SEL3 ;;S %I=%E Q:(%D="")&(%E]"")  F %I=1:1 S %L=$T(+%I) Q:%L=""  I $P($P(%L,"(")," ")=%D,%D]"" S %I=%I+%E Q
LN1 ;;S:$P(%L," ")[$C(9) %L=$P(%L,$C(9))_" "_$P(%L,$C(9),2) S %A=$E(%L,1,32),%T=$P($P(%A,"(")," "),%POP=$S(%A="":0,%A[" ":0,%A["(":0,1:1) I '%POP,%T'?.N,%T'?1A.AN,%T'?1"%".AN S %POP=1
LCL ;;S %NX=999 S:$E(%X,2)'="" %LCL=$E(%X,2,99) Q:'$D(@%LCL)  S %L=@%LCL W !,%L,! X $S(XY]"":^%("EDXY"),1:^%("ED")) S @%LCL=%L,%NX=1 W !,%L
MV ;;W "ove lines in this routine" X ^%RS(1) ZR @(%BG_":"_%EN) X ^%RS(100) S %NX=1 W !,"(moved)"
COPY ;;W !,"Copyright 2017, InterSystems Corporation"
930 ;;S %NX=1 F %A=1000:0 S %A=$O(^%(%A)) Q:'%A  W !,^(%A)
1001 ;;Enter one of the following
1010 ;;.B   to break a line into two pieces
1015 ;;.C   to change all occurrences of a string
1020 ;;.D   to display s specific range of lines
1030 ;;.F   to file the routine
1035 ;;.FX  to file the routine and exit the editor
1040 ;;.G   to get lines that were put into in a buffer (see .P)
1045 ;;.I   to insert additional lines (or use the TAB key)
1050 ;;.J   to join a line with the next one
1055 ;;.M   to move lines within the routine
1060 ;;.P   to put lines into a buffer (see .G)
1065 ;;.R   to remove one or more lines
1070 ;;.S   to search for all occurrences of a string
1075 ;;tag OR tag+offset  to edit a line
1080 ;;+n   to move down n lines and edit
1085 ;;-n   to move up n lines and edit
1090 ;;""+n to edit the nth line of the program
1095 ;;^globalref  to edit a value stored in a global node
1100 ;;any line of Cache ObjectScript source code, to execute it
1105 ;;     (but if you call another routine before filing this one,
1110 ;;     it will wipe out any edits you have made).
1115 ;;"." use decimal point to move character by character on the current line
1120 ;;" " use space bar to move from space to space on the line
1125 ;;"e" to enter characters, use "." and " " to move to entry point,
1130 ;;    then press "e".  To get out of entry mode, press <RETURN>.
1135 ;;"d" to delete the characters to the end of the word the cursor is on
1140 ;;Backspace: Depending on your terminal settings, backspace will either move 
1145 ;;           back character by character, or delete the character at the cursor.
 ;NT Console device
CON ;;N A,X,I S I=$E($I,1,5),X=$D(^%IS(I,1)) X ^%($S(X:"CON3",1:"CON2"))
CON2 ;;I $D(^%IS("TERM",1)) S I="TERM" X ^%("CON3")
CON3 ;;S A=$P($G(^%IS(I,1)),"^",3) I A]"" S A=$G(^%IS(0,"SUB",A)) S %SL=$P(A,"^",3)-1,%RM=+A U $I:(%RM:0) I '$D(XY) S XY=$P(A,"^",5),DX=0,DY=%SL-1 X XY
 ;LAT and/or network device types
LAT ;;N A,X,I S I=$E($I,1,2)_"0:",X=$D(^%IS(I,1)) X ^%($S(X:"LAT3",1:"LAT2"))
LAT2 ;;I $D(^%IS("TERM",1)) S I="TERM" X ^%("LAT3")
LAT3 ;;S A=$P($G(^%IS(I,1)),"^",3) I A]"" S A=$G(^%IS(0,"SUB",A)) S %SL=$P(A,"^",3)-1,%RM=+A U $I:(%RM:0) I '$D(XY) S XY=$P(A,"^",5),DX=0,DY=%SL-1 X XY
END ;;

EDITOR3^INT^1^67214,47330
EDITOR3 ;(PTR,PK) Edit comments (nullified for M/VX)
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ;Comments are stored in
 ;      ^COMMENT(Routine Name, tag, offset, line number)
 ;                      ^(0) = # comment lines for this tag
 ;Presently, only offset 0 is permissible.
 ;The sequential line number of the tag is variable %I.
 ;M/VX includes comments in source code, so this can be bypassed
A F %I=1:1 S %A=$T(%+%I),%T=$P(%A," "),%B=$P(%A," ;;",2,256) Q:%T="END"  I $L(%T) S ^%(%T)=%B
 G ^EDITOR4
% ;
300 ;;S %NX=999,%A=$E(%X,2,*),%T=$S(%A]"":%A,$D(%TG):$P(%TG,"+"),$D(%CTG):%CTG,1:"") X ^%("TAG") Q:%L=""!%E  S %NX=$S($D(^COMMENT($T(+0),%T,0)):320,1:308),%CTG=%T W:%X=";" %T S:'$D(%TG) %TG=%T I $P(%TG,"+")'=%T S %TG=%T
 ;SEE IF THERE IS A LINE WITH WHICH TO ASSOCIATE THE TAG.
305 ;;S %I=^COMMENT($T(+0),%CTG,0,0)+1,%NX=310
307 ;;S %I=+%I,%L=^COMMENT($T(+0),%CTG,0,%I),%NX=328 X $S(XY]"":^%("EDXY"),1:^%("ED"))
308 ;;S %I=1,%NX=310
310 ;;S %NX=1 R !,"Insert Comment: ",%L Q:%L=""  S ^COMMENT($T(+0),%CTG,0,0)=%I,^(%I)=%L,%I=%I+1,%NX=310
 ;INSERT FIRST LINE OF TAG COMMENT.
320 ;;S %A=^COMMENT($T(+0),%CTG,0,0),%NX=321 W ! F %I=1:1:%A W "  ",%I,") ",^(%I),!
321 ;;W "Comment no.(" W:%A-1 "1-" W %A_" or I): " R %I S %NX=$S(%I="":1,%I="I"!(%A+1=%I):305,%I'?.N:999,%I<1:999,%I>%A:999,1:307)
322 ;;R " R ",%R S %NX=$S(%R="":328,%R="END":326,%L[%R:324,%R["...":330,1:327)
324 ;;S %NX=322 R " W ",%W S %L=$P(%L,%R)_%W_$P(%L,%R,2,999)
326 ;;S %NX=322 R " W ",%W S %L=%L_%W
327 ;;S %NX=322 W " ???"
328 ;;S %A=^COMMENT($T(+0),%CTG,0,0),%NX=$S(%L]"":321,1:329) S ^COMMENT($T(+0),%CTG,0,%I)=%L W:%L]""&(XY="") !,"  "_%I_")  "_%L W !
329 ;;S %NX=321 W " (deleted)",! I $D(^COMMENT($T(+0),%CTG,0,%I)) F %I=%I:1:%A S:%I<%A ^(%I)=^(%I+1) I %I=%A K ^(%A) S %A=%A-1,^(0)=%A I '%A K ^COMMENT($T(+0),%CTG,0) S %NX=1
330 ;;S %E=$P(%R,"..."),%B=$P(%R,"...",2,999),%J=$F(%L,%E),%C=%J-1-$L(%E),%D=$S(%B="":999,1:$F(%L,%B,%J)),%NX=$S(%C<0!(%D<0)&(%R'="..."):327,1:331)
331 ;;S %NX=322 R " W ",%W S %L=$E(%L,0,%C)_%W_$E(%L,%D,*) K %E
END ;;

EDITOR4^INT^1^67214,47330
EDITOR4 ;(PK) Transfer lines from one place to another
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 F %I=1:1 S %A=$T(%+%I),%T=$P(%A," "),%B=$P(%A," ;;",2,256) Q:%T="END"  I $L(%T) S ^%RS(%T)=%B
 Q
% ;
1 ;;N (%BG,%EN) S %POP=0 R !,"Begin: ",%T Q:%T=""  X ^%("TAG") Q:%L=""  S %K=$J K ^UPS(%K) S %BG=%T X ^%RS(2)
2 ;;R "   End: ",%EN S %A=$S(%EN="":3,1:20) X ^%RS(%A)
3 ;;S %J=1,%B=$P(%BG,"+"),%I=+$P(%BG,"+",2) F %I=%I:1 S %T=%B_"+"_%I,@("%L=$T("_%T_")") Q:%L=""  S %EN=%T,^UPS(%K,%J)=%L,%J=%J+1
20 ;;S %T=%EN X ^%("TAG") Q:%L=""  S %A=$P(%L," ")_" \*/ "_$P(%L," ",2,999) ZR @%T ZI %A X ^%RS(21)
21 ;;S %J=1,%B=$P(%BG,"+"),%I=$P(%BG,"+",2)+0 F %I=%I:1 S %T=%B_"+"_%I,@("%L=$T("_%T_")"),%C=$P(%L," ",2),%FI=%C="\*/"!(%L="") X:'%FI ^%RS(22) I %FI S %L=$P(%L," ")_" "_$P(%L," ",3,999) X ^%RS(22) ZR @%T ZI %L Q
22 ;;S ^UPS(%K,%J)=%L,%J=%J+1
100 ;;N (%BG,%EN) R !,"Insert after: ",%T I %T]"" X ^%("TAG") Q:%L=""  X ^%RS(101)
101 ;;S %K=$J I $D(^UPS(%K,1)) S %A=^(1) ZR @%T ZI %L F %J=1:1 Q:'$D(^UPS(%K,%J))  S %A=^(%J) ZI %A
END ;;

EMS^INT^1^67214,47330
EMS ; Enterprise Manager Managed Instance ;$Change: 7440104 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	; Revision: $Id: //iris/2024.1.3/databases/sys/rtn/sysconfig/ems.mac#1 $
	Quit
Unlock
	New instance,ns,error,sc,success
	Set instance=##class(EMS.Instance).Open()
	If instance="" Write !,"This instance is not configured as a Managed Instance." Quit
	Set ns=instance.Services.GetAt("Namespace")
	If ns="" Write !,"This instance is not managed for the Namespace Service." Quit
	If 'ns.SystemLock Write !,"The Namespace SystemLock flag is already clear." Quit
	Write !,"The Namespace SystemLock is set, which indicates that a Namespace change was"
	Write !,"ready to be activated but the system never got confirmation from the other"
	Write !,"Instances in the Enterprise Manager Group.",!
	Write !,"YOU SHOULD MAKE SURE THIS INSTANCE IS UP-TO-DATE WITH THE ENTERPRISE MANAGER"
	Write !,"GROUP BEFORE ALLOWING DATABASE ACCESS.",!
	Write !,"This will now clear the Namespace SystemLock flag and allow normal startup.",!
	If $$YN("Do you want to proceed","N")="N" {
		Write !,"Not unlocked."
		Quit
	}
	Set ns.SystemLock=0 Set sc=ns.%Save(0)
	If ('sc) Write !,"Unlock failed: ",$system.Status.DisplayError(sc) Quit
	Quit
	;
RESET(noPrompt) public {
	If ##class(Config.Databases).Exists("CACHEEMS"),##class(Config.Namespaces).Exists("EMS") {
		If $get(noPrompt) {
			Write !,"Error: RESET for managed Instance called on Enterprise Manager instance."
			Quit $$Error^%apiOBJ(1500,"RESET for managed Instance called on Enterprise Manager.")
		} Else {
			Write !,"RESET for managed Instance called on apparent Enterprise Manager instance."
			If $$YN("Are you SURE you want to do this, which will clear the EM security setup?","N")="N" {
				Write !,"Not reset"
				Quit 1
			}
		}
	}
	If '$get(noPrompt) {
		Write !,"This will reset the Managed Instance."
		If $$YN("Do you want to reset","N")="N" {
			Write !,"Not reset"
			Quit 1
		}
	}
 	Set sc=##class(EMS.LifeCycle).Uninstall()
	If (''sc) {
 		Set sc=##class(EMS.LifeCycle).Install()
 		If (''sc) {
		 	Write !,"Reset as a Managed Instance"
		} Else {
			Write "Install failed: ",!
		 	Write $system.Status.DisplayError(sc),!,!
	 	}
 	} Else {
		Write "Uninstall failed: ",!
	 	Write $system.Status.DisplayError(sc),!,!
 	}
 	Quit sc
}
YN(P,D) public {
	Set P=$get(P),D=$extract($get(D)_"?")
	Set D=$select("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
	For {
		Write !,P_"? "_D
		Read R
		Set X=R
		Set R=$tr($extract(R_D_"?"),"yn","YN")
 		If "^YN"[R Quit
	}
	Write $extract($select(R="N":"No",R="Y":"Yes",1:""),$length(X)+1,3) 
	Quit R
}
LOAD(loadCS=1,loadSMP=0) [ e ] public { ;
	If '$system.Security.Check("%Admin_Manage","USE"),
	   '$system.Security.Check("%Admin_Secure","USE") {
		   Write !,"EMS operation requires %Admin_Manage:U or %Admin_Secure resource."
		   Quit
	}
	Set sources=$get(^%SYS("SourceRoot","%SYS"),$get(^%SYS("SourceRoot"),"u:/"))
	Write !,"Loading from: ",sources
	If "\/"'[$e(sources,$l(sources)) s sources=sources_"/"
	Set StartTime=$zh
	Write !,"   Importing localize/Errors.xml"
	Do Import^%occMsgXML(sources_"databases/sys/localize/Errors.xml")
	Do GenerateInclude^%occMsgXML("%occErrors",1)
	Write !
	Set dups=$$GenerateObjectErrors^%occMsgXML()
	If dups'="" {
		Write "ERROR: Duplicate error name(s): "_dups,!
	}
	Write !,"   Importing localize/SystemMessages.xml"
	Do Import^%occMsgXML(sources_"databases/sys/localize/SystemMessages.xml")
	Kill e
	Write "Load %ems.inc ...",!
	Do $system.OBJ.Load(sources_"databases/sys/inc/_ems.inc","ck",.e)
	Do $system.OBJ.Load(sources_"databases/sys/inc/_syDataMove.inc","ck",.e)
	Write "Load ^EMS ...",!
	Do $system.OBJ.Load(sources_"databases/sys/rtn/sysconfig/ems.mac","ck",.e)
	Write !,"Load EMS classes ..."
	Do $system.OBJ.LoadDir(sources_"databases/sys/cls/EMS","ck",.e,1)
	w !,"Load %SYS.EMS and %SYS.Audit ..."
	Do $system.OBJ.Load(sources_"databases/sys/cls/SYS/EMS.xml","ck",.e)
	Do $system.OBJ.Load(sources_"databases/sys/cls/SYS/Audit.xml","ck",.e)
	Do $system.OBJ.Load(sources_"databases/sys/cls/SYS/EManager.xml","ck",.e)
	If loadCS {
		w !,"Load Config classes ..."
		Do $system.OBJ.LoadDir(sources_"databases/sys/cls/config","ck",.e,1)
		w !,"Load Security classes ..."
		Do $system.OBJ.LoadDir(sources_"databases/sys/cls/security","ck",.e,1)
		w !,"Load DataMove classes ..."
		Do $system.OBJ.LoadDir(sources_"databases/sys/cls/DataMove","ck",.e,1)
	}
	w !,"Load EMS UI ..."
	Do $system.OBJ.Load(sources_"databases/sys/cls/CSP/UI/Portal/EMS.xml","ck",.e)
	Do $system.OBJ.Load(sources_"databases/sys/cls/CSP/UI/Portal/EMSNotifications.xml","ck",.e)
	Do $system.OBJ.Load(sources_"databases/sys/cls/CSP/UI/Portal/EMSNotificationNew.xml","ck",.e)
	Do $system.OBJ.Load(sources_"databases/sys/cls/CSP/UI/Portal/Dialog/EMS.xml","ck",.e)
	if loadSMP {
		w !,"Load SMP classes ..."
		Do $system.OBJ.LoadDir(sources_"databases/sys/cls/ZEN/Portal","ck",.e,1)
		Do $system.OBJ.Load(sources_"databases/sys/cls/CSP/Portal/standardDialog.xml","ck",.e)
		Do $system.OBJ.LoadDir(sources_"databases/sys/cls/CSP/UI","ck",.e,1)
	}
	Write !!,"EMS load completed in "_($zh-StartTime)_" seconds with "_$case($get(e,0),0:"no",:e)_" errors."
	If $get(e,0) > 0  w !,"""zw e"" to see errors."
	Quit
}
DEV
	Write !!,"This will initialize a Cache instance for Enterprise Manager development."
	Write !,"It will create the EMS database and namespace, and load the EM Manager package,"
	Write !,"based on the Perforce pointer in ^%SYS(""SourceRoot"")."
	Write !!,"Do you want to proceed? <Y>" Read yn Set:yn="" yn="Y"
	If "Yy"'[ yn quit
	Set EMSDir=##class(%Library.File).SubDirectoryName($zu(12),"ems",1)
	If ##class(%Library.File).Exists(EMSDir_"IRIS"_".DAT") w !,"Database in "_EMSDir_" already exists." q
	If ##class(Config.Databases).Exists("CACHEEMS") w !,"Database "_"CACHEEMS"_" already exists." q
	Write !!,"Creating EM Database and Namespace ...",!
	If '##class(%Library.File).DirectoryExists(EMSDir) {
		If '##Class(%Library.File).CreateDirectory(EMSDir) w !,"Unable to create directory "_EMSDir q
 	}
	Set sc=##class(SYS.Database).CreateDatabase(EMSDir,,,,"%DB_IRISEMS",3)
	If ('sc) w !,"Error creating database: " zw sc q
	Set sc=##class(Config.Databases).Create("CACHEEMS",EMSDir)
	If ('sc) w !,"Error creating database Config: " zw sc q
	If ##class(Config.Namespaces).Exists("EMS",.namespaceObj) w !,"Namespace "_"EMS"_" already exists." q
	Kill Properties
	Set Properties("Globals")="CACHEEMS"
	Set sc=##class(Config.Namespaces).Create("EMS",.Properties )
	If ('sc) w !,"Error creating Namespace: " zw sc q
	Set perforce=^%SYS("SourceRoot")
	zn "EMS"
	do $system.OBJ.Load(perforce_"databases\ems\build\build.rtn","ck")
	do dev^build
	do RESET^EMS(1)
	Set ^ISC.EMS("ManagerSMP")=1
	Q
	;	
log(file,level,soap,marker,maxfilesize,daystokeep) public {
	if $get(file)="" set file=$zu(12)_"sys.log"
	do ##class(%Library.File).Delete(file)
	Set ^ISC.EMS("Log")=$get(level,4),^ISC.EMS("LogFile")=file
	Set ^ISC.EMS("LogFileMaxSize")=$get(maxfilesize,50)
	Set ^ISC.EMS("LogFileDaysToKeep")=$get(daystokeep,7)
	set soap=$get(soap,"ios")
	If soap'="" {
		set ^ISCSOAP("Log")=soap
		set ^ISCSOAP("LogFile")=file
	} else {
		kill ^ISCSOAP("Log"),^ISCSOAP("LogFile")
	}
	set ^ISC.EMS("LogMarker")=$get(marker,"##")
	quit
}
klog() public {
	Kill ^ISC.EMS("Log"),^ISC.EMS("LogFile"),^ISC.EMS("LogMarker"),^ISC.EMS("LogFileMaxSize"),^ISC.EMS("LogFileDaysToKeep")
	kill ^ISCSOAP("Log")
	kill ^ISCSOAP("LogFile")
	Kill ^ISC.EMS("LogFileMaxSize")
	Kill ^ISC.EMS("LogFileDaysToKeep")
	quit
}

ENVIRON^INT^1^67214,47330
ENVIRON ; Maintain global data for $ENVOPTION macro
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ; Intention: return 1 if we're in an environment supporting
 ; big strings (i.e. has the global BDATA type 12 blocks and
 ; the 0x81 GBIGTYPE nodes).
 ; Implementation: ASSUME we have big string support if we can
 ; build a local string of length > 510.         
MAIN N ERROR S ERROR=0         
 W !,"Feature",?15,"Compiled for",?40,"Actual (running now)"
 D environ0("NOLONGSTRINGS",0,$$NOLONGSTRINGS)   
 D environ0("NOWILDCARDS",0,$$NOWILDCARDS)
 D environ0("NOLONGNAMES",0,$$NOLONGNAMES)   
 D environ0("NOUSENEWCOL",0,$$NOUSENEWCOL)
 D environ0("NOSETEXTRACT",0,$$NOSETEXTRACT)
 D environ0("NONEWLICENSE",0,$$NONEWLICENSE)
 D environ0("USECLUSTER",1,$$USECLUSTER)
 D environ0("NONETTRANSPROC",0,$$NONETTRANSPROC)
 D environ0("NOUSESLM",0,$$NOUSESLM)
 D environ0("NOUSEUSTART",0,$$NOUSEUSTART)
 W:ERROR !!,*7,"BAD CONFIGURATION" W:'ERROR !!,"Configuration OK"
 Q
environ0(name,compile,run) 
 s $zt="environe"
 w !,$$basename(name),?15,$$no(name,compile),?40,$$no(name,run)
 s:compile'=run ERROR=1
 q
environe s $zt=""
 w !,$$basename(name),?15,$p($ze,">")_"> -- unknown status"
 q         
basename(name) n p s p=$p(name,"NO",2) q:p'="" p q name
no(name,v) 
 n no s no=$p(name,"NO",2)'="" s:v=0 no='no q:no "NO" q "YES" 
FEATURES() Q "NOLONGSTRINGS NOWILDCARDS NOLONGNAMES NOUSENEWCOL NOSETEXTRACT NONEWLICENSE USECLUSTER NONETTRANSPROC NOUSESLM NOUSEUSTART"
 ; Report compile-time settings
SHOW W !,$name(^mutil("ENVIRON"))," is set as follows:"
 D SHOW0($name(^mutil("ENVIRON")))
 Q
SHOW0(NODE) 
 N I,F,T,V
 W !!,"Status",?8,"Feature",?25,$name(^mutil("ENVIRON"))," setting"
 F I=1:1:$L($$FEATURES," ") S F=$P($$FEATURES," ",I) D
 . S V=$D(@NODE@(F))'=0
 . w !,$$no(F,V),?8,$$basename(F)
 . W ?25,$name(@NODE@(F))," ",$S(V:"defined",1:"undefined (default)")
 Q
SET ; Set compile-time settings
 N I,F,NODE,TEMP,V
 D SHOW S NODE=$name(^mutil("ENVIRON"))
 W !!,"New settings:",!
 F I=1:1:$L($$FEATURES," ") S F=$P($$FEATURES," ",I) D
 . I $$YN(F,"N")="Y" S TEMP(F)="" 
 D SHOW0("TEMP")
 I $$YN("Make the change")="Y" K @NODE M:$D(TEMP) @NODE=TEMP 
 Q
NOLONGSTRINGS() Q '$$LEGAL("$J(1,500)_$J(2,500)")
 ; $ZU(78,25,...) is a new function for NETTRANSPROC. Since we
 ; haven't opened a journal file we'll probably get a <NOTOPEN> error.
 ; If this isn't supported, we'll get a <FUNCTION> error
NONETTRANSPROC() ;
 s $ZT="NETTPERR"
 i $ZU(78,25,0) ; we expect <function> if not supported
 q 0  ; it is supported, return failure
NETTPERR ;
 s $ZT=""
 i $ZE["<NOTOPEN" q 0  ; it is supported, return failure
 q 1  ; most likely function error, return success, it isn't supported
 ; Returns maximum string length
MAXLEN() N N,STEP
 S N=512 F  Q:'$$legallen(2*N)  S N=2*N
 F  Q:$$legallen(N)  S N=N\2 ;In case N=256 was too big 
 S STEP=N 
 F  S STEP=STEP\2 S:$$legallen(N+STEP) N=N+STEP Q:STEP=1
 Q N
 ; Would just be Q $$LEGAL("$J($C(32),N)") if not for bug
legallen(N) Q:'$$LEGAL("$J($C(32),N)") 0
    N TEST S TEST=$J($C(32),N) Q $L(TEST)=N   ;Needed due to bug
NOWILDCARDS() Q '$$LEGAL("$ZU(90,0)")
NOLONGNAMES() N ABCDEFGH,ABCDEFGHI
 S ABCDEFGH=0,ABCDEFGHI=1
 Q ABCDEFGH=ABCDEFGHI
NOUSENEWCOL() Q '$$LEGAL("$ZU(23,0)")
USECLUSTER() Q $$LEGAL("$ZU(59)")
NOUSESLM() Q '$$LEGAL("$ZU(90,11,1,""ABC"")")
 ; $$LEGAL(EXPRESS) returns 1 if evaluating EXPRESS causes no error.
 ; E.g. $$LEGAL("$ZU(90,0)")
LEGAL(EXP) 
 N V,XEQEXP S XEQEXP="V="_EXP,$ZT="legal0",@XEQEXP Q 1
legal0 Q 0 
NOSETEXTRACT() N % S $ZT="NOSETERR" S $E(%)="" Q 0
NOSETERR Q 1
NONEWLICENSE() N % S $ZT="NOLICERR" S %=$ZU(200,15) Q 0
NOLICERR Q 1
NOUSEUSTART()
 s $ZT="USTARTERR"
 i $ZU(40,2,115) q 0  ; it is supported, return failure
USTARTERR
 q 1  
YN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YN"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"yn","YN") I "^YN"'[R W "  enter Yes or No, please"
 S POP=(R="^") W $E($S(R="N":"No",R="Y":"Yes",1:""),$L(X)+1,3) Q R

GBLOCKCOPY^INT^1^67214,47330
GBLOCKCOPY ; Fast global copy from database to namespace
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 n 
 i $p($g(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY")),"~",1)'="1.0" k ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY")
 i '$d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY")) s ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY")="1.0~"
 s POP=0
 w !,"This routine will do a fast global copy from a database to another database or"
 w !,"to a namespace. If a namespace is the destination, the global will follow any"
 w !,"mappings set up for the namespace."
 ; 
MENU ;
 w !
 w !,"1) Interactive copy"
 w !,"2) Batch copy"
 w !,"3) Exit"
 w !
 s Option=$$OPTION("Option? ",3,3)
 i Option=1 d INTERACTIVE g MENU
 i Option=2 d BATCH g MENU
 q
INTERACTIVE
 s POP=0
 s Name=$e($j,$l($j)-6,$l($j))
 k ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name)
 d BATCHSETUP q:POP
 s Interactive=1,Jobs=1,JobsDir=1
 d SETJOBS(Name,Jobs,JobsDir)
 d BATCHRUN1
 i +$g(POP)=1 k ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name)
 q
BATCH
 w !
 w !,"1) Manage Batches"
 w !,"2) Run a Batch"
 w !,"3) Restart a Batch"
 w !,"4) Add Processes to a running Batch"
 w !,"5) Stop a Running batch"
 w !,"6) Monitor Running Batch"
 w !,"7) Batch Report"
 w !,"8) Exit"
 w !
 s Option=$$OPTION("Option? ",8,8)
 i Option=1 d BATCHMANAGE g BATCH
 i Option=2 d BATCHRUN g BATCH
 i Option=3 d BATCHRESTART g BATCH
 i Option=4 d BATCHADDPROCESSES g BATCH
 i Option=5 d BATCHSTOP g BATCH
 i Option=6 d BATCHMONITOR g BATCH
 i Option=7 d BATCHREPORT g BATCH
 q
BATCHMANAGE
 w !
 w !,"1) Create a Batch"
 w !,"2) Edit a Batch"
 w !,"3) List Batches"
 w !,"4) Delete a Batch"
 w !,"5) Exit"
 w !
 s Option=$$OPTION("Option? ",5,5)
 i Option=1 d BATCHCREATE g BATCHMANAGE
 i Option=2 d BATCHEDIT g BATCHMANAGE
 i Option=3 d BATCHLIST g BATCHMANAGE
 i Option=4 d BATCHDELETE g BATCHMANAGE
 q
BATCHCREATE s $zt="BATCHE"
 s Name=$$GETNAME("Batch name to create? ",0,0) q:POP
 f  w !!,"Adding to batch: "_Name d BATCHSETUP q:POP
 g BATCHCREATE
BATCHEDIT   s $zt="BATCHE"
 s Name=$$GETNAME("Batch name to edit? ",1,0) q:POP
 s Status=$$GETSTATUS(Name,1)
 i $p(Status,"~",4)'="Queue" w !,"Batch "_Name_" has been run, please re-enter" g BATCHEDIT
 i $$YN("Do you want to add to the batch","Y")="Y" f  w !!,"Adding to batch: "_Name d BATCHSETUP q:POP
 i $$YN("Do you want to delete entries from batch "_Name,"N")="N" g BATCHEDIT
BATCHEDIT1
 d SUMMARYREPORT(Name,0)
 s Option=$$OPTION("Delete which entry? ",0,+$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,""),-1)) 
 i Option=0 g BATCHEDIT
 k ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Option)
 s Index="" s Count=0 f  s Index=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index)) q:Index=""  s Count=Count+1 i Count'=Index m ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Count)=^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index) k ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index)
 i $d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,1))=0 k ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name) g BATCHEDIT
 g BATCHEDIT1
BATCHLIST s $zt="BATCHE"
 s Name=$$GETNAME("Batch name to list (*=ALL)? ",1,1) q:POP
 i $$YN("Include Global list","N")="Y" s detail=1
 e  s detail=0
 d GETNAMEREPORT(Name,detail)
 g BATCHLIST
BATCHDELETE   s $zt="BATCHE"
 s Name=$$GETNAME("Batch name to delete? ",1,0) q:POP
 d GETJOBSTATUS(Name,0,0,.JobInfo)
 i JobInfo(0) w !,"Batch "_Name_" is currently running, Please re-enter" g BATCHDELETE
 i $$YN("Do you want to delete batch "_Name,"N")="N" g BATCHDELETE
 k ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name)
 w !,"Batch "_Name_" is deleted"
 g BATCHDELETE
BATCHRUN s $zt="BATCHE"
 s Name=$$GETNAME("Batch name to run? ",1,0) q:POP
 s Status=$$GETSTATUS(Name,1)
 i $p(Status,"~",4)'="Queue" w !,"Batch was already run, Please re-enter" g BATCHRUN
 s Index="",Count=0 f  s Index=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index)) q:Index=""  s Count=Count+1
 s Jobs=$$OPTION("How many copy processes do you want to run for all directories at once? "_Count_" => ",Count,999)
 i Jobs=0 g BATCHRUN
 s Count=Jobs\Count i Count=0 s Count=1
 s JobsDir=$$OPTION("How many of these copy processes do you want to run for each directory? "_Count_" => ",Count,Jobs)
 i JobsDir=0 g BATCHRUN
 d SETJOBS(Name,Jobs,JobsDir)
 s Interactive=0
BATCHRUN1
 s POP=0
 i $$YN("Confirm copy","Y")="N" s POP=1 q
 w !,"Verifying and renaming directories..."
 s Index="" f  s Index=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index)) q:Index=""  d  q:rc=0
 . s rc=$$RENAMEDB(Name,Index) q:rc=0
 . s srcdir=^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"SRCDIR")
 . s dstdir=^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"DSTDIR")
 . s rc=$s($e(srcdir,1,2)="^^":$$CHECKDIR(srcdir,0),1:$$CHECKNS(srcdir))
 . i rc=0 w !,$$NSMSG(srcdir,err) q
 . s rc=$s($e(dstdir,1,2)="^^":$$CHECKDIR(dstdir,0),1:$$CHECKNS(dstdir))
 . i rc=0 w !,$$NSMSG(dstdir,err) q
 q:rc=0
 w !,"Building work queues..."
 s Index="" f  s Index=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index)) q:Index=""  d  q:('rc)
 . s srcdir=^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"SRCDIR")
 . s dstdir=^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"DSTDIR")
 . s ConvertCollation=^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"CONVERTCOLLATION")
 . k glinfo set rc=$$GetGlobalDirectoryInfo^%SYS.DATABASE(srcdir,"glinfo")
 . If ('rc) w !,"Error getting directory information for ",srcdir q
 . k ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSQUEUED")
 . i $d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSLIST","*")) s glo="" f  s glo=$o(glinfo(glo),1,glinfo) q:glo=""  s COL=$$COLLATION(glinfo,ConvertCollation),^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSQUEUED",glo)=COL
 . i '$d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSLIST","*")) s glo="" f  s glo=$o(glinfo(glo),1,glinfo) q:glo=""  i $d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSLIST",glo)) s COL=$$COLLATION(glinfo,ConvertCollation),^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSQUEUED",glo)=COL
 . If $o(glinfo(""))="GbLoCk",$o(glinfo("GbLoCk"))="" s ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"EMPTYSOURCE")=1,empty=1
 . Else  k ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSQUEUED","GbLoCk")
 q:('rc)
 w !,"Creating destination globals..."
 s Index="" f  s Index=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index)) q:Index=""  d  q:('rc)
 . s srcdir=^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"SRCDIR")
 . s dstdir=^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"DSTDIR")
 . k glinfo set rc=$$GetGlobalDirectoryInfo^%SYS.DATABASE(srcdir,"glinfo")
 . s glo="" f  s glo=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSQUEUED",glo),1,COL) q:glo=""  d  q:('rc)
 . . s createglo=glo
 . . Set jrnval=$Case($Zboolean(+$p(glinfo(glo),"^",4),4,1),4:1,:0)
 . . Set keepval=$Case($Zboolean(+$p(glinfo(glo),"^",4),1,1),1:1,:0)
 . . If $g(empty) s rc=1
 . . Else  s rc=$$CreateGlobal^%SYS.DATABASE(dstdir,createglo,COL,$p(glinfo(glo),"^",1),jrnval,keepval)
 . . q:(''rc) ;i ($$$ISERR(rc)),($li($li($e(rc,3,$l(rc)),1),1)'=1) d  q
 . . i $SYSTEM.Status.GetErrorCodes(rc)'=333,$SYSTEM.Status.GetErrorCodes(rc)'=335 d  q
 . . . w !,"Unable to create global "_createglo_" in database "_dstdir_" skipped!"
 . . . k ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSQUEUED",glo) s rc=1
 . . s dstdirx=dstdir
 . . i $e(dstdir)'="^" s dstdirx=$$getdest^%SYS.GXLINF1(dstdir,createglo) s dstdirx="^"_dstdirx i dstdirx="^" d  s rc=1 q
 . . . k ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSQUEUED",glo)
 . . . w !,"Unable to determine the destination database for ^|""",dstdir,"""|",createglo
 . . . w !,"Global "_createglo_" in database "_dstdir_" skipped!"
 . . k dstglinfo set rc1=$$GetGlobalDirectoryInfo^%SYS.DATABASE(dstdirx,"dstglinfo")
 . . i '(''rc1) d  s rc=1 q
 . . . k ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSQUEUED",glo)
 . . . w !,"Unable to get destination directory info for global "_createglo
 . . . w !,"Global "_createglo_" in database "_dstdir_" skipped!"
 . . i '$d(dstglinfo(createglo)) s rc=1 q
 . . i $p(dstglinfo(createglo),"^",5)=$p(glinfo(glo),"^",5) s rc=1
 . . e  d
 . . . q:'Interactive
 . . . w !,"Unable to preserve the collation of global ^"_createglo_", destination already exists"
 . . . i $$YN("Skip","Y")="Y" q
 . . . s rc=1
 . . if ('rc) k ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSQUEUED",glo) w !,"Global "_createglo_" in database "_dstdir_" skipped!"
 . . s rc=1
 d STARTJOBS(Name,Interactive)
 i 'Interactive d MONITORREPORT(Name)
 q
BATCHRESTART
 s $zt="BATCHE"
 w !!,"This option will restart global copies which started and failed to complete"
 w !,"either because of an error while the global was being copied, or system crash."
 w !,"It will first add the globals back to the queue state, then restart copy"
 w !,"processes if necessary. You can also use this option to restart a copy"
 w !,"you used the STOP option on. You can also use this option to re-queue"
 w !,"a global which had an error even if other globals are still being copied"
 w !
BATCHRESTART1
 s Name=$$GETNAME("Batch name to restart? ",1,0) q:POP
 s Status=$$GETSTATUS(Name,1)
 i $p(Status,"~",4)="Queue" w !,"Batch "_Name_" has not been run, Please re-enter" g BATCHRESTART1
 d SUMMARYREPORT(Name,0)
BATCHRESTART2
 w ! i $$YN("Confirm restart of batch "_Name,"Y")="N" g BATCHRESTART
 s Index="" f  s Index=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index)) q:Index=""  d BATCHRESTARTGLO(Name,Index,$p(Status,"~",4))
 d STARTJOBS(Name,0)
 q
BATCHADDPROCESSES s $zt="BATCHE"
 s Name=$$GETNAME("Batch name to add processes to? ",1,0) q:POP
 d GETJOBSTATUS(Name,0,0,.JobInfo)
 i JobInfo(0)=0 w !,"Batch is not currently running, Please re-enter" g BATCHADDPROCESSES
 d GETJOBS(Name,.Jobs,.JobsDir)
 w !
 w !,"Batch "_Name_" currently has "_JobInfo(0)_" process(es) running of "_Jobs_" started"
 w !,"Each directory has "_JobsDir_" process(es) assigned to it"
 w !
 s NewJobs=$$OPTION("How many copy processes do you want to run at once? "_Jobs_" => ",Jobs,999)
 i NewJobs=0 g BATCHADDPROCESSES
 s NewJobsDir=$$OPTION("How many of these copy processes do you want to run for each directory? "_JobsDir_" => ",JobsDir,NewJobs)
 i NewJobsDir=0 g BATCHADDPROCESSES
 d SETJOBS(Name,NewJobs,NewJobsDir)
 d STARTJOBS(Name,0)
 q
BATCHSTOP s $zt="BATCHE"
 s Name=$$GETNAME("Batch name to stop? ",1,0) q:POP
 d GETJOBSTATUS(Name,0,0,.JobInfo)
 i JobInfo(0)=0 w !,"Batch "_Name_" is not currently running, Please re-enter" g BATCHSTOP
 w !
 w !,"1) Stop immediately"
 w !,"2) Stop after current global copies are finished"
 w !,"3) Exit"
 w !
 s Option=$$OPTION("Option? ",3,3) 
 i $$YN("Confirm stop of batch "_Name,"N")="N" g BATCHSTOP
 i (Option=0)!(Option=3) g BATCHSTOP
 s Index=""  f  s Index=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index)) q:Index=""  s ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"STOP")=Option
 g BATCHSTOP
BATCHE s $zt=""
 i $ze["<INTERRUPT>" q
 w !,"Error: "_$ZE
 q
BATCHMONITOR s $zt="BATCHE"
 s Name=$$GETNAME("Batch name to monitor (*=ALL)? ",1,1) q:POP
 d MONITORREPORT(Name)
 g BATCHMONITOR
BATCHREPORT s $zt="BATCHREPORTE"
 w !
 w !,"1) Summary report"
 w !,"2) Detail report"
 w !,"3) Exit"
 w !
 s Option=$$OPTION("Option? ",3,3) i (Option=0)!(Option=3) q
 s Name=$$GETNAME("Batch name (*=ALL)? ",1,1) i POP g BATCHREPORT
 i Option=1 d SUMMARY g BATCHREPORT
 i Option=2 d DETAIL g BATCHREPORT
 q
BATCHREPORTE s $zt=""
 i $d(IO) c:IO'=$P IO
 w !,"ERROR: "_$ze
 q
MONITORREPORT(InName) [] PUBLIC {
 D MONITORREPORT^GBLOCKCOPY1(InName)
}
BATCHSETUP
 w !
 w !,"1) Copy from Database to Database"
 w !,"2) Copy from Database to Namespace"
 w !,"3) Exit"
 w !
 s Option=$$OPTION("Option? ",3,3) i (Option=0)!(Option=3) s POP=1 q
 s srcdir=$$ASKDIR("Source",0) q:POP
 i $e(srcdir,1,2)="^^" {
    New blksiz Set blksiz=$Piece($zu(49,$p(srcdir,"^",3)),",",2)
    If blksiz=2048 {
       w !!,"Databases with 2K block size are no longer supported."
       w !!,"You must user version 2011.1 or earlier to convert them."
       s srcdir="",POP=1 Quit  
   }
 } 
 i Option=1 {
	s dstdir=$$ASKDIR("Destination",1) q:POP
	i $e(dstdir,1,2)="^^" {
		New blksiz Set blksiz=$Piece($zu(49,$p(dstdir,"^",3)),",",2)
    	If blksiz=2048 {
	        w !!,"Databases with 2K block size are no longer supported."
       		w !!,"You must user version 2011.1 or earlier to convert them."
       		s srcdir="",POP=1 Quit  
    	}
	}
 } 	
 i Option=2 s dstdir=$$ASKNS() q:POP
 i srcdir=dstdir w !,"Destination and source directories cannot be the same" g BATCHSETUP
 s rc=$$GETGLOBALS(srcdir,.GLOBALS) q:POP
 s journal=$$GETJOURNAL() q:POP
 s Index=$$GETINDEX(Name)
 s ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"SRCDIR")=srcdir
 s ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"SRCDIRTYPE")=$g(^|srcdir|GbLoCk,"IRIS"_".DAT")
 s ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"DSTDIR")=dstdir
 s ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"CONVERTCOLLATION")=$g(GLOBALS(0),1) k GLOBALS(0)
 s ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"JOURNAL")=journal
 s glo="" f  s glo=$o(GLOBALS(glo)) q:glo=""  s ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSLIST",glo)=""
 k GLOBALS
 q
BATCHRESTARTGLO(Name,Index,Status) [] PRIVATE {
 k ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"STOP")
 s glo="" f  s glo=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSSTARTED",glo),1,cvtdata) q:glo=""  d
 . i ($p(cvtdata,"~",9)'="")!(($p(cvtdata,"~",9)="")&(Status="Crash")) d
 . . s ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSQUEUED",glo)=""
 . . k ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"END")
 . . w !,"Re-queueing Batch "_Name_" entry "_Index_" global "_glo
 . . s ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"RESTART",glo)=$g(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"RESTART",glo))_$h_"~"_$p(cvtdata,"~",9)_"~"_$p(cvtdata,"~",10)_"*"
 q
}
SUMMARY i $$YN("Include Global list","N")="Y" s detail=1
 e  s detail=0
 s NameCount=0
 w !
 N IOMS s IOMS=$System.Device.GetRightMargin()
 d OUT^%IS q:POP
 u IO
 w !,$$CENTER("GBLOCKCOPY Summary Report at "_$ZDATETIME($h),80)
 i Name'="*" d SUMMARY1 
 i Name="*" s Name="" f  s Name=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name)) q:Name=""  d SUMMARY1
 U:$P=IO IO:/MAR=IOMS 
 c:IO'=$P IO
 q
SUMMARY1
 i NameCount'=0 k x s $p(x,"-",79)="-" w !!,x
 s NameCount=NameCount+1
 d SUMMARYREPORT(Name,detail)
 q
SUMMARYREPORT(Name,Detail) [] PUBLIC {
 d SUMMARYREPORT^GBLOCKCOPY1(Name,Detail)
}
DETAIL s detail=0,NameCount=0
 w !
 N IOMS s IOMS=$System.Device.GetRightMargin()
 d OUT^%IS q:POP
 u IO
 w !,$$CENTER("GBLOCKCOPY Detailed Report at "_$ZDATETIME($h),80)
 i Name'="*" {
	 d DETAIL1
 } else {
 	s Name="" f  s Name=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name)) q:Name=""  d DETAIL1
 }
 U:$P=IO IO:/MAR=IOMS 
 c:IO'=$P IO
 q
DETAIL1
 i NameCount'=0 k x s $p(x,"-",79)="-" w !!,x
 s NameCount=NameCount+1
 d DETAILREPORT(Name)
 q
DETAILREPORT(Name) [] PUBLIC {
 d DETAILREPORT^GBLOCKCOPY1(Name)
 q
}
STARTJOBS(Name,Interactive) [] PUBLIC 
 {
 i Interactive d  q
 . w !,"Starting copy"
 . w !!,"Global",?34,"Last Update",?46,"Blks Done",?57,"Blks ToDo",?67,"Status"
 . s ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,1,"STARTJOBS")=1
 . d START(Name,1,Interactive)
 w !,"Starting processes"
 k ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,1,"STARTJOBS")
 d GETJOBS(Name,.Jobs,.JobsDir)
 s (Count,ErrCount)=0 f  s Index=$$NEXTINDEX(Name) q:Index=0  d
 . j START^GBLOCKCOPY(Name,Index,Interactive)::5 i '$t s ErrCount=ErrCount+1 q
 . s Count=Count+1 w "."
 . f  d GETJOBSTATUS(Name,0,0,.JobInfo) q:Count'>JobInfo(0)  w "|" h 1
 w !,"Started "_Count_" copy processes"
 i ErrCount w !,"Failed to start "_ErrCount_" copy processes"
 s ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,1,"STARTJOBS")=1
 h 5
 q
 }
START(Name,Index,Interactive) 
 d SETJOBSTATUS(Name,$j,"Start",Index,"")
 s $zt="STARTE"
 f  q:$d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,1,"STARTJOBS"))  h 1
 f  {  
 	q:+Index=0
 	s srcdir=^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"SRCDIR")
 	s dstdir=^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"DSTDIR")
	l +^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index)
 	i $d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"START"))=0 d
 	. s ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"START")=$h
	. q:Interactive
	. If $extract(dstdir,1,2)="^^" s ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"MAPS")=$$CHANGEMAPS($e(dstdir,3,$l(dstdir)))
	l -^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index)
	s CURRENTJOURNALMODE=$$CURRENT^%SYS.NOJRN
	i +$g(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"JOURNAL")) d ##class(%SYS.ProcessQuery).EnableJournalInt()
	e  d ##class(%SYS.ProcessQuery).DisableJournalInt()
 	s oldns=$namespace
	s srcmounted=$s($e(srcdir,1,2)="^^":$$NeedMountDB($e(srcdir,3,*)),1:0)
	s dstmounted=$s($e(dstdir,1,2)="^^":$$NeedMountDB($e(dstdir,3,*)),1:0)
 	i $zu(5,srcdir)
 	s status=$$NEXTGLO(Name,Index,Interactive)
 	i $d(oldns) d $zu(5,oldns)
	if $g(srcmounted,0) s srcmounted=0 d $zu(3,srcdir)
	if $g(dstmounted,0) s dstmounted=0 d $zu(3,dstdir)
	i CURRENTJOURNALMODE d ##class(%SYS.ProcessQuery).EnableJournalInt()
	e  d ##class(%SYS.ProcessQuery).DisableJournalInt()
	q:$g(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"STOP"),100)<3
 	i '$d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSQUEUED")),'$d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSSTARTED")) d
 	. s ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"END")=$h
	. i $d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"MAPS")) d
	. . d RESTOREMAPS($e(dstdir,3,$l(dstdir)),^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"MAPS"))
 	i Interactive d  q
 	. i status d
 	. . w !!,"Copy of data has completed",!
 	. . i $$RENAME("Do you want to save statistics for later review",.Name) d
 	. . . w !,"Use the Summary or Detail option under Batch Copy for statistics"
 	. i 'status d
	. . w !!,"The previous copy operation was aborted. You can restart the copy operation"
	. . w !,"in the future as a batch copy if you want.",!
	. . i $$RENAME("Do you want to be able to restart the copy operation",.Name) d
	. . . w !,"Use the Restart option under Batch Copy to restart the copy"
	q:$g(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"STOP"),100)<4
 	s Index=$$NEXTINDEX(Name)
 }
 i Interactive,(Name="") q
 i (+Index'=0),$g(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,+Index,"STOP"),100)<4  d SETJOBSTATUS(Name,$j,"Stop",Index,"") 
 e  d SETJOBSTATUS(Name,$j,"Success",Index,"") 
 i Interactive,(status=0) d SETJOBSTATUS(Name,$j,$ze,Index,"")
 q
STARTE s $zt=""
 i $zu(5,"%SYS") 
 if $g(srcmounted,0) s srcmounted=0 d $zu(3,srcdir)
 if $g(dstmounted,0) s dstmounted=0 d $zu(3,dstdir)
 d SETJOBSTATUS(Name,$j,$ze,$g(Index),"") 
 d BACK^%ETN
 i $d(oldns) d $zu(5,oldns)
 q:Interactive
 h 60	; If we keep erroring, Don't fill the error trap
 k (Name,Index,Interactive)
 j START(Name,Index,Interactive)
 halt
SETJOBS(Name,Jobs,JobsDir) [] PUBLIC{
 i JobsDir>Jobs s JobsDir=Jobs
 s $p(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name),"~",1,2)=Jobs_"~"_JobsDir
 }
GETJOBS(Name,Jobs,JobsDir) [] PUBLIC{
 s Info=$g(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name))
 s Jobs=+$p(Info,"~",1),JobsDir=+$p(Info,"~",2)
 q
 }
SETJOBSTATUS(Name,Job,ze,Index,Glo) [] PRIVATE {
 s $zt="SETJOBSTATUSE"
 q:Name=""
 L +^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name)
 i ze="Start" s ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name)=^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name)_"~"_$j_"*"_$h_"***"_Index_"*"_Glo L -^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name) q
 s Jobs=$p(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name),"~",1,2)
 s Info=$p(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name),"~",3,10000)
 s x=0
 f i=1:1 s JobInfo=$p(Info,"~",i) q:JobInfo=""  i $p(JobInfo,"*",1)=Job s x=i
 i x'=0 s Data=$p(Info,"~",x),Data=$j_"*"_$p(Data,"*",2)_"*"_$h_"*"_ze_"*"_Index_"*"_Glo,$p(Info,"~",x)=Data
 s ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name)=Jobs_"~"_Info
SETJOBSTATUSE
 s $zt=""
 L -^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name)
 q
 }
GETJOBSTATUS(Name,Index,All,JobInfo) [] PUBLIC {
 k JobInfo
 s ExistsCount=0
 s Info=$p($g(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name)),"~",3,10000)
 i Info="" s JobInfo(0)=0 q
 f i=1:1 s x=$p(Info,"~",i) q:x=""  d
 . s Job=+$p(x,"*",1),Start=$p(x,"*",2),End=$p(x,"*",3),Error=$p(x,"*",4),ViewIndex=$p(x,"*",5),Glo=$p(x,"*",6)
 . i ($zu(67,0,Job)=2) s Exists=1 s:$j=Job Exists=0
 . e  s Exists=0
 . s Status=$s(Exists:"Run",Error="Success":"Done",Error="":"Crash",Error="Stop":"Stop",1:"Error")
 . s Error=$s((Status="Done")!(Status="Stop"):"",1:Error)
 . i All=0 q:'Exists
 . i Index'=0 q:Index'=ViewIndex
 . i Exists s ExistsCount=ExistsCount+1
 . s JobInfo(Job,$i(JobInfo(Job,0)))=Status_"~"_Start_"~"_End_"~"_ViewIndex_"~"_Glo_"~"_Error
 s JobInfo(0)=ExistsCount
}
NEXTGLO(Name,Index,Interactive) [] PRIVATE {
 s $zt="NEXTGLOE",status=1
 f  {
	L +^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index)
	s global=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSQUEUED",""))
	i global="" LOCK -^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index) q
	i '$d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSSTARTED",global)) s ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSSTARTED",global)=0_"~"_$h_"~0~"_$h_"~0~0~0~^"_global_"~~~"
	k ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSQUEUED",global)
	LOCK -^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index)
	s status=$$BLKSAVE(Name,Index,global,^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"DSTDIR"),Interactive)
	i Interactive,(status=0) q
	q:$g(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"STOP"),100)<3
 }
 q status
NEXTGLOE s $zt=""
 LOCK -^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index)
 i $zu(5,"%SYS") 
 d SETJOBSTATUS(Name,$j,$ze,Index,$g(global)) 
 d BACK^%ETN
 h 60	; If we keep erroring, Don't fill the error trap
 k (Name,Index,Interactive)
 j START(Name,Index,Interactive)
 halt
}
NEXTINDEX(Name) [] PUBLIC {
 s $zt="NEXTINDEXE"
 L +^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name)
 d GETJOBS(Name,.Jobs,.JobsDir)
 d GETJOBSTATUS(Name,0,0,.JobInfo)
 i Jobs=JobInfo(0) L -^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name) q 0
 s POP=0 s Index="" f  s Index=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index)) q:Index=""  d  q:POP
 . q:$d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSQUEUED"))=0
 . d GETJOBSTATUS(Name,Index,0,.JobInfo)
 . q:JobInfo(0)>(JobsDir-1)
 . s POP=1
 L -^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name)
 q +Index
NEXTINDEXE s $zt=""
 L -^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name)
 q 0
}
BLKSAVE(Name,Index,glo,destns,Interactive) [] PRIVATE
 {
BLKSAVE1
 s $zt="BLKSAVEE"
 d SETJOBSTATUS(Name,$j,"",Index,glo)
 s StartTime=$h,myrc=""
 s data=$g(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSSTARTED",glo)) 
 i +$p(data,"~",5)'=0 s Restart=1,savedatablk=+$p(data,"~",5),nblocks=$p(data,"~",6)-1,bigcnt=$p(data,"~",7),blockstocopy=$p(data,"~",11) s:nblocks=-1 nblocks=0
 e  s (Restart,datablk,nblocks,bigcnt,savedatablk,blockstocopy)=0,^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSSTARTED",glo)=$j_"~"_StartTime_"~0~"_$h_"~0~0~0~^"_glo_"~~~0"
 i $zcvt($namespace,"L")'=$zcvt(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"SRCDIR"),"L") s myrc="<NAMESPACE>,"_$namespace g BLKSAVEERROR
 Set bigdb=$Piece($zu(49,""),",",2)
 o 63
 i Interactive w !,"^"_glo,?34,$$DISPLAYDATE($h),?46,$j(nblocks,9),?56,$j(0,10),?67,"0%",$j("",80-$x),$c(13)
 i (glo=$c(255)) d  g BLKSAVEDONE
 . m ^|destns|rOBJ=@("^"_glo) 
 . s xglo="" f  s xglo=$o(@("^"_glo)@(xglo)) q:xglo=""  s nblocks=nblocks+1
 . s blockstocopy=nblocks
 i (glo="mMAC") d  g BLKSAVEDONE
 . m ^|destns|rMAC=@("^"_glo) 
 . s xglo="" f  s xglo=$o(@("^"_glo)@(xglo)) q:xglo=""  s nblocks=nblocks+1
 . s blockstocopy=nblocks
 i (glo="mMACSAVE") d  g BLKSAVEDONE
 . m ^|destns|rMACSAVE=@("^"_glo) 
 . s xglo="" f  s xglo=$o(@("^"_glo)@(xglo)) q:xglo=""  s nblocks=nblocks+1
 . s blockstocopy=nblocks
 i (glo="mINC") d  g BLKSAVEDONE
 . m ^|destns|rINC=@("^"_glo) 
 . s xglo="" f  s xglo=$o(@("^"_glo)@(xglo)) q:xglo=""  s nblocks=nblocks+1
 . s blockstocopy=nblocks
 i (glo="mINCSAVE") d  g BLKSAVEDONE
 . m ^|destns|rINCSAVE=@("^"_glo) 
 . s xglo="" f  s xglo=$o(@("^"_glo)@(xglo)) q:xglo=""  s nblocks=nblocks+1
 . s blockstocopy=nblocks
 i glo="GbLoCk" g BLKSAVEDONE
 If '$d(@("^|""^^""|"_glo)) g BLKSAVEDONE ; Set up global vector
 Set collate=$li($zu(208),2)
 Set myrc=$$GetGlobalPointers^%SYS.DATABASE("",glo,.topblk,.datablk)
 If ('myrc) s myrc=$select(+myrc:$$Error^%apiOBJ(54),1:$$AppendStatus^%occSystem(myrc,$$Error^%apiOBJ(54))) g BLKSAVEERROR
 Set length=$l(glo)+2,POP=0,nextblk=0,off=0,newio=0
 s zz=$zu(93,6,destns,glo,$case(bigdb,2048:1,:$case($Zutil(40,0,0),0:7,1:8)),0,collate)
 i Restart s datablk=savedatablk
 e  d
 . s ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSSTARTED",glo)=$j_"~"_StartTime_"~0~"_$h_"~"_0_"~"_nblocks_"~"_bigcnt_"~"_$$LASTREF(glo)_"~~~"_blockstocopy_"~Calc"
 . s blockstocopy=$$GSIZE(bigdb,topblk)
 . s ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSSTARTED",glo)=$j_"~"_StartTime_"~0~"_$h_"~"_datablk_"~"_nblocks_"~"_bigcnt_"~"_$$LASTREF(glo)_"~~~"_blockstocopy
 s myrc=""
 For  v datablk s nblocks=nblocks+1,nextblk=$case(bigdb,2048:$v(2040,0,"3O"),:$v($Zutil(40,32,4),0,4)),data=$zu(93,0,0),data1="" s:$l(data)=32767 data1=$zu(93,0,1) d $zu(93,7,data_data1) Set off=$Zutil(93,1,-1) d:('(nblocks#100))!(off'="")  Q:myrc'=""  s datablk=nextblk Q:'datablk
 . Set off2=1 For  Quit:off=""  Set off2=off2+$p(off,"^",2),ref=$View(off2,-6) d:$d(@("^|""^^""|"_$Extract($View(off2,-5),2,*)),val)#2 $Zutil(93,4,ref,val,collate,0) Set off2=off2+2,off=$Zutil(93,1,off) Set:savedatablk'=datablk bigcnt=bigcnt+1
 . i '(nblocks#100) s ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSSTARTED",glo)=$j_"~"_StartTime_"~0~"_$h_"~"_datablk_"~"_nblocks_"~"_bigcnt_"~"_$$LASTREF(glo)_"~~~"_blockstocopy,totalblocks=$i(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,1,"TOTALBLOCKS"),100) s:$g(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"STOP"),100)=1 myrc="<STOP>" i Interactive w "^"_glo,?34,$$DISPLAYDATE($h),?46,$j(nblocks,9),?56,$j(blockstocopy,10),?67 w:blockstocopy'=0 $p(((nblocks/blockstocopy)*100),".")_"%" w:blockstocopy=0 "0%" w $j("",80-$x),$c(13) h 0
BLKSAVEDONE ;
 If myrc'="" g BLKSAVEERROR
 i Interactive w "^"_glo,?34,$$DISPLAYDATE($h),?46,$j(nblocks,9),?56,$j(blockstocopy,10),?67,"Done",$j("",80-$x),$c(13) h 0
 s ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSENDED",glo)=$j_"~"_StartTime_"~"_$h_"~"_$h_"~"_datablk_"~"_nblocks_"~"_bigcnt_"~"_$$LASTREF(glo)_"~~~"_blockstocopy
 k ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSSTARTED",glo)
 q 1
BLKSAVEERROR ;
 i Interactive w "^"_glo,?34,$$DISPLAYDATE($h),?46,$j(nblocks,9),?56,$j(blockstocopy,10),?67,myrc,$j("",80-$x),$c(13)
 s ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSSTARTED",glo)=$j_"~"_StartTime_"~"_$h_"~"_$h_"~"_datablk_"~"_nblocks_"~"_bigcnt_"~"_$$LASTREF(glo)_"~"_myrc_"~0~"_blockstocopy
 i Interactive  w !!,"Copy aborted"
 q 0
BLKSAVEE S $ZT="" ; Prevent loops in error trapper.
 i $ze["<INTERRUPT>" s $ze="<STOP>"
 s ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSSTARTED",glo)=$j_"~"_StartTime_"~"_$h_"~"_$h_"~"_datablk_"~"_nblocks_"~"_bigcnt_"~"_$$LASTREF(glo)_"~"_$ze_"~~"_blockstocopy
 i Interactive d  w ! g:POP=0 BLKSAVE1 q 0
 . w "^"_glo,?34,$$DISPLAYDATE($h),?46,$j(nblocks,9),?56,$j(blockstocopy,10),?67,$ze,$j("",80-$x),! h 0
 . s POP=1 i $$YN("Do you really want to abort the copy","N")="N" s POP=0 q
 . w !!,"Copy aborted"
 s oldns=$namespace
 d $zu(5,"%SYS")
 l +^ERRORS("GBLOCKCOPY"):30
 d BACK^%ETN ; Save Error dump
 s $p(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSSTARTED",glo),"~",10)=$o(^ERRORS(+$h,""),-1)
 l -^ERRORS("GBLOCKCOPY")
 i $zu(5,oldns)
 q 0
 }
LASTREF(glo) [] PRIVATE {
 s $zt="LASTREFE"
 i '$d(@("^"_glo)) q "^"_glo
 s x=$v(1,-5)
 i $tr($p(x,"^",2)," ","")="" q "^"_glo
 q $tr(x,"~"," ")
LASTREFE s $zt=""
 i $ze["UNIMPLEMENTED" s $ze="" q "^"_glo
 q "^"_glo
}
RENAME(Prompt,Name) [POP] PRIVATE {
RENAME1 s $zt="RENAMEE"
 i $$YN(Prompt,"N")="N" k ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name) s Name="" q 0
 s NewName=$$GETNAME("Batch name to save information to? ",0,0)
 i POP g RENAME1
 m ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",NewName)=^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name)
 k ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name)
 w !,"Information saved to Batch name "_NewName
 s Name=NewName
 q 1
RENAMEE s $zt="" 
 k ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name) s Name=""
 w !,"ERROR: "_$ZE
 q 0
}
GETSTATUS(Name,Index) [glinfo,JobInfo] PUBLIC {
 s srcdir=^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"SRCDIR") s srcdir=$e(srcdir,3,$l(srcdir))
 s dstdir=^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"DSTDIR") i $e(dstdir,1,2)="^^" s dstdir=$e(dstdir,3,$l(dstdir))
 s dspdir=srcdir_"=>"_dstdir
 i $l(dspdir)>45 d
 . f i=1:1:10 s dspdir=$e(dspdir,2,$l(dspdir)) i $l(dspdir)<45 s dspdir="*"_dspdir q
 . q:$e(dspdir)="*"
 . i $l(dspdir)>44 d
 . . f  s dspdir=$e(dspdir,2,$l(dspdir)),dspdir=$p(dspdir,">",1)_">"_$e($p(dspdir,">",2),2,$l(dspdir))  q:$l(dspdir)<44
 . . s dspdir="*"_$p(dspdir,">",1)_">*"_$p(dspdir,">",2)
 s dspdir=$e(dspdir,1,45)
 i $d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSLIST","*")) s AllOrSelected="All"
 e  s AllOrSelected="Selected"
 s queglo=0
 s startedglo=0
 s endedglo=0
 s lastupdate=""
 s errors=0
 s status="Queue"
 i '$d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"START")) d  g GETSTATUSDONE
 . i $d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSLIST","*")) d  q
 . . k glinfo set rc=$$GetGlobalDirectoryInfo^%SYS.DATABASE("^^"_srcdir,"glinfo")
 . . s glo="" f  s glo=$o(glinfo(glo)) q:glo=""  s queglo=queglo+1
 . s glo="" f  s glo=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSLIST",glo)) q:glo=""  s queglo=queglo+1
 s glo="" f  s glo=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSQUEUED",glo)) q:glo=""  s queglo=queglo+1
 s glo="" f  s glo=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSSTARTED",glo),1,cvtdata) q:glo=""  s startedglo=startedglo+1,date=$p(cvtdata,"~",4),lastupdate=$s(+lastupdate>+date:lastupdate,+lastupdate<+date:date,+$p(lastupdate,",",2)>+$p(date,",",2):lastupdate,1:date) s:$p(cvtdata,"~",9)'="" errors=errors+1 
 s glo="" f  s glo=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSENDED",glo),1,cvtdata) q:glo=""  s endedglo=endedglo+1,date=$p(cvtdata,"~",4),lastupdate=$s(+lastupdate>+date:lastupdate,+lastupdate<+date:date,+$p(lastupdate,",",2)>+$p(date,",",2):lastupdate,1:date) s:$p(cvtdata,"~",9)'="" errors=errors+1 
 d GETJOBSTATUS(Name,0,0,.JobInfo)
 i startedglo'=0 s status="Run"
 i (startedglo'=0),(JobInfo(0)=0) s status="Crash"
 i $d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"END")) d
 . i startedglo=0 s status="Done" q
 . i (startedglo'=0) s status="Error" q
 i (JobInfo(0)=0),$d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"STOP")) s status="Stop"
GETSTATUSDONE
 q srcdir_"~"_dstdir_"~"_dspdir_"~"_status_"~"_AllOrSelected_"~"_queglo_"~"_startedglo_"~"_endedglo_"~"_lastupdate_"~"_errors
 }
GETNAMEREPORT(Name,Detail) [] PUBLIC {
 s $zt="GETNAMEREPORTE"
 w !
 w !,"Name",?7," #",?11,"Source DB=>Destination DB/NS",?62,"Globals",?71,"Status"
 w !,"----",?7," -",?11,"----------------------------",?62,"-------",?71,"------"
 i Name'="*" d GETNAMEREPORT1 q
 i Name="*" s Name="" f  s Name=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name)) q:Name=""  d GETNAMEREPORT1
 q
GETNAMEREPORT1
 w !,Name
 s Index="" f  s Index=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index)) q:Index=""  d  w !
 . s Status=$$GETSTATUS(Name,Index)
 . w ?7,$j(Index,2),?11,$p(Status,"~",3),?62
 . w $p(Status,"~",5) ; Selected or all
 . w ?71,$p(Status,"~",4)  ; Status
 . q:'Detail
 . i $d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSLIST","*")),'$d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"RENAME")) d  q
 . . s oldns=$namespace 
 . . d $zu(5,^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"SRCDIR")) 
 . . d ^%SYS.GLO
 . . s glo="0" f  s glo=$o(^||IRIS.TempUtil("GLO",glo)) q:glo=""  w !,?11,glo
 . . d $zu(5,oldns)
 . s glo="" f  s glo=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSLIST",glo)) q:glo=""  w !,?11,glo
 q
GETNAMEREPORTE s $zt=""
 d:$d(oldns) $zu(5,oldns)
 w !,"ERROR: "_$ZE
 }
ASKNS() [POP,err] PRIVATE
 {
 d List^%SYS.NAMESPACE(.nsplist,3)
 s nsplist="" f  s nsplist=$o(nsplist(nsplist)) q:nsplist=""  s nsplist($i(nsplist(0)))=nsplist k nsplist(nsplist)
ASK s $ZT="ASKNSE"
 s POP=0
 w !,"Destination Namespace for Copy (? for List)? "
 r dir 
 i dir="?" d  w ! g ASK
 . w !! f i=1:1:nsplist(0) d
 . . i $x+$l(nsplist(i))+4>79 w !
 . . w i_") "_nsplist(i)
 . . i ($x>40) w ! 
 . . e  w ?40
 i dir="^"||(dir="STOP") s POP=1 q
 i dir?1.4N i (dir<1)!(dir>nsplist(0)) w !,"Please enter a namespace or number between 1 and "_dirlist(0) g ASK
 i dir?1.4N w " ",nsplist(dir) s dir=nsplist(dir) 
 s rc=$s($e(dir,1,2)="^^":$$CHECKDIR(dir,0),1:$$CHECKNS(dir))
 i rc=0 w !,err g ASK
 q dir
ASKNSE S $ZT="ASKNSE1"
 s POP=1 
 i $ze["<INTERRUPT>" q ""
 w !,"Error: "_$ze 
 q ""
ASKNSE1 s $zt=""
 s POP=1
 w !,"Error: "_$ZE
 q ""
 }
CHECKNS(dir) [err] PRIVATE {
 s $zt="CHECKNSE"
 s olddir=$namespace
 i $zu(5,dir)
 d $zu(5,olddir)
 q 1
CHECKNSE s $zt=""
 i $d(olddir) d $zu(5,olddir)
 s err=$$NSMSG(dir,$ZE)
 q 0
 }
ASKDIR(Msg,Mode) [POP,err] PRIVATE
 { 
 s dir="" f  s dir=$$GetNextDatabaseByUCI^%SYS.CONFIG(dir) q:dir=""  s dirlist($i(dirlist(0)))=dir
ASK s $ZT="ASKDIRE"
 s POP=0
 w !,Msg_" Directory for Copy (? for List)? "
 r dir i dir="" s POP=1 q ""
 i dir="?" w !! d  w ! g ASK
 . f i=1:1:dirlist(0) d
 . . i $x+$l(dirlist(i))+4>79 w !
 . . w i_") "_dirlist(i)
 . . i ($x>40) w ! 
 . . e  w ?40
 i dir="^"||(dir="STOP") s POP=1 q ""
 i dir?1.4N i (dir<1)!(dir>dirlist(0)) w !,"Please enter a directory or number between 1 and "_dirlist(0) g ASK
 i dir?1.4N w " ",dirlist(dir) s dir=dirlist(dir) 
 s rc=$$CHECKDIR(.dir,1)
 i rc=1 q dir
 i (Mode=0),(rc=0) w !,err g ASK
 i (Mode=1),((rc=2)!(rc=3)) w !,err g ASK
 i Mode=0 d  g:dir="" ASK q dir
 . i rc=2 s File="CACHE.DAT"
 . w !,"A "_File_" database has been detected in "_$e(dir,3,$l(dir))
 . i $$YN("Do you want to rename it to "_"IRIS"_".DAT, then mount and use it","Y")="N" s dir="" q
 . i $$DBRENAME($e(dir,3,$l(dir))) s ^|dir|GbLoCk=$e(dir,3,$l(dir))_File
 . e  s dir=""
 i (Mode=1),(rc=0),(dir'="") d  g:dir="" ASK q dir
 . w !,"Database "_$e(dir,3,$l(dir))_" does not exist"
 . i $$YN("Do you want to create it","N")="N" s dir="" q
 . s Option=$$DBCREATE($e(dir,3,$l(dir)))
 . ;i $$$ISOK(Option) w !,"Database "_$e(dir,3,$l(dir))_" created" q
 . i (+Option) w !,"Database "_$e(dir,3,$l(dir))_" created" q
 . w !,"Error "_$$DecomposeStatus^%SYS.DATABASE(Option)_" creating database "_$e(dir,3,$l(dir)) s dir=""
 i rc=0 w !,err g ASK
 q dir
ASKDIRE S $ZT="ASKDIRE1"
 s POP=1 
 i $ze["<INTERRUPT>" q ""
 w !,"Error: "_$ze 
 q ""
ASKDIRE1 s $zt=""
 s POP=1
 w !,"Error: "_$ZE
 q ""
 }
CHECKDIR(dir,msg) [err] PRIVATE {
 s $zt="CHECKDIRE"
 i $e(dir,1,2)="^^" s dir=$e(dir,3,*)
 s dir=##class(%Library.File).NormalizeDirectory(dir)
 i (dir="")!'##class(%Library.File).DirectoryExists(dir) {
	s err="Invalid directory specification or directory does not exist" 
	i dir'="" s dir="^^"_dir
	q 0
 }
 s dir="^^"_dir
 s mounted=$$NeedMountDB($e(dir,3,*))
 O 63:dir
 s type=$g(^|dir|GbLoCk)
 i msg,(type["CACHE") w !,"Database "_$e(dir,3,$l(dir))_" was formerly a "_type_" database"
 c 63
 if $g(mounted,0) s mounted=0 d $zu(3,dir)
 q 1
CHECKDIRE s $zt="CHECKDIRE1"
 c 63
 if $g(mounted,0) s mounted=0 d $zu(3,dir)
 s err=$$NSMSG(dir,$ZE)
 i $zu(140,4,$e(dir,3,$l(dir))_"CACHE.DAT")=0 q 2
 q 0
CHECKDIRE1 s $zt=""
 c 63
 q 0
 }
NeedMountDB(dir) ;
 s $ZT="NeedMountDBErr"
 n zu49
 s zu49=$zu(49,dir)
 q:+$p(zu49,",",27)=0 0
 if (+zu49'=-1)&(+zu49'=$zu(40,0,41)) q 0
 q +$zu(17,dir)=1
NeedMountDBErr
 q 0
NSMSG(dir,ze)  [] PRIVATE {
 s x=$s(dir["^^":"Directory",1:"Namespace")
 i $e(dir,1,2)="^^" s dir=$e(dir,3,$l(dir))
 I ze["<FUNCTION>" q "Bad "_x_" name "_dir
 I ze["<DIRECTORY>" q x_" "_dir_" is not available"
 I ze["<NAMESPACE>" q x_" "_dir_" is not available."
 I ze["<PROTECT>" q "Insufficient privileges for "_x_" "_dir
 I ze["<NOTOPEN>" q "No database or database is dismounted in "_x_" "_dir
 q "Error: "_ze
 }
GETNAME(Prompt,Flag,Star) [POP] PRIVATE {
GETNAMEA ;
 s $zt="GETNAMEE"
 s POP=0
 w !!,Prompt
 r Name i Name="" s POP=1 q ""
 i Name="?" d  g GETNAMEA
 . s detail=0,Name="*"
 . d GETNAMEREPORT(Name,detail)
 i (Name="*"),(Star=1) q Name
 i (Name="*"),(Star=0) w !,"Invalid entry, please re-enter" g GETNAMEA
 i $l(Name)>6 w !,"Batch name must be 6 characters or less, please re-enter" g GETNAMEA
 s Name=$ZCVT(Name,"U")
 i Flag=2 q Name
 s Exists=$d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name))
 i (Flag=0)&&(Exists=0) q Name
 i (Flag=1)&&(Exists) q Name
 i Flag=0 w !,"Batch name already exists"
 e  w !,"Batch name does not exist"
 g GETNAMEA	 
GETNAMEE s $zt=""
 s POP=1 
 i $ze["<INTERRUPT>" q ""
 w !,"Error: "_$ze
 q ""
 }
GETGLOBALS(srcdir,&GLOBALS) [POP] PRIVATE {
    Set $zt="GETGLOBALSE"
    Set POP=0
    Kill GLOBALS
    // Pick up default directory and system,
    // also make sure that you can access this dataset or namespace
    Set oldns=$namespace
    Do $zu(5,srcdir)
    Set dirnam=$$defdir^%SYS.GLO($namespace)
    Set sysnam=$$defsys^%SYS.GLO($namespace)
    Do $zu(5,oldns)
    Kill oldns
    If '$$OPT^%GSET(,,,1,,dirnam,sysnam,,,0,1,.glolist,.gloutil) {
	Write !,"No globals selected"
	Set POP=1
	Quit 0
    }
    Set glo=""
    For {
	Set glo=$o(glolist(glo))
	Quit:glo=""
	Set GLOBALS(glo)=""
	Set Count=$g(Count)+1
	Set Col($p($g(gloutil(glo),"^^^^5"),"^",5))=""
    }
    If Count=gloutil(0,"PHYSICAL") {
	Kill GLOBALS
	Set GLOBALS("*")=""
    }
    Set GLOBALS(0)=1,Found=0
    Write !
    For Col=0,1,2,3,4,128,129 {
	If $d(Col(Col)) {
	    Write !,"Globals with a non standard collation of "_$$NAME^COLLATE(Col)_" detected"
	    Set Found=1
	}
    }
    Quit:'Found 1
    If $$YN("Would you like to change the collation to IRIS standard collation","Y")="N" {
	Set GLOBALS(0)=0
    }
    Quit 1
GETGLOBALSE Set $zt=""
    Do:$d(oldns) $zu(5,oldns)
    Set POP=1 
    Quit:$ze["<INTERRUPT>" ""
    Write !,"Error: "_$ze
    Quit 0
}
GETJOURNAL() [POP] PRIVATE {
 s $zt="GETJOURNALE"
 s POP=0
 i $$YN("Turn journaling off for this copy","Y")="Y" q 0
 q 1
GETJOURNALE s $zt=""
 s POP=1
 i $ze["<INTERRUPT>" q 0
 w !,"Error: "_$ze
 q 0
}
COLLATION(GloInfo,ConvertCollation) [] PRIVATE {
 s Col=$p(GloInfo,"^",5)
 i (Col>4),(Col<128) q Col
 i (Col=128)!(Col=129) q 133
 i (Col>129) q Col
 q:ConvertCollation=0 Col
 q 5
 }
GETINDEX(Name) [] PRIVATE
 {
 i '$d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name)) q 1
 q $o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,""),-1)+1
 }
CENTER(str,rm) [] PRIVATE {
 Q $J(str,$L(str)+rm\2)
}
DISPLAYDATE(Date) [] PRIVATE {
 i Date="" q Date
 s cvtdate=$zdatetime(Date)
 q $p(cvtdate,"/",1,2)_" "_$p($p(cvtdate," ",2),":",1,2)
 }
RENAMEDB(Name,Index) [] PRIVATE {
 s $zt="RENAMEDBE"
 q:'$d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"RENAME")) 1
 s record=^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"RENAME")
 s DB=$p(record,"~",1),srcdir=$p(record,"~",2),File=$p(record,"~",3)
 i '$$DBRENAMEMOVE(DB,srcdir) w !,"Error renaming database "_File_" to "_srcdir_"IRIS"_".DAT" q 0
 w !,"Database "_File_" renamed to "_srcdir_"IRIS"_".DAT"
 d LABEL(srcdir)
 s status=$$MOUNT(srcdir) i status<0 w !,"Unable to mount "_srcdir_"IRIS"_".DAT, "_$$Error^%apiOBJ(-status) q 0
 s ^|"^^"_srcdir|GbLoCk=File
 i '$$RENAMEMOVE(DB_"IRIS"_".NEW",DB_"IRIS"_".DAT") w !,"Unable to rename "_DB_"IRIS"_".NEW to "_DB_"IRIS"_".DAT" q 0
 d LABEL(DB)
 s status=$$MOUNT(DB) i status<0 w !,"Unable to mount "_DB_"IRIS"_".DAT, "_$$Error^%apiOBJ(-status) q 0
 k ^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"RENAME")
 q 1
RENAMEDBE s $zt=""
 w !,"ERROR: "_$ZE_" while performing rename of "_DB
 q 0
 }
DBRENAME(dir) [] PRIVATE {
 s $zt="DBRenErr"
 s dir=$zu(12,dir) q:dir=""  ; Canonicize directory name if we can
 d DBalter(dir,".DAT")
 s dblist(dir)="",next=$zu(36,dir,0,1)
 f  q:next=""!(next<0)  d
 . s next=$zu(12,next) q:next=""
 . q:$d(dblist(next))  d DBalter(next,".EXT")
 . s dblist(next)="",next=$zu(36,next,1,1)
 i $zu(17,dir)<0 w !,"Database renamed, but unable to mount it" q 0
 q 1
DBRenErr s $zt=""
 w !,"ERROR: "_$ze
 q 0
}
DBalter(dir,ext) [] PRIVATE {
 i ($zversion(1)=3) q:dir'?.e1"/"  ; N/A to raw disk partitions
 s new=dir_"IRIS"_ext q:$$DBtest(new)
 s done=0 f dbname="CACHE" d  q:done
 . s old=dir_dbname_ext i $$DBtest(old) d  s done=1 q
 . . i ($zversion(1)=2) s x=$zf(-1,"RENAME "_$zu(147,old)_" "_"IRIS"_ext) d:x
 . . . w !,"ERROR: rename failed with error code "_x
 . . i ($zversion(1)=3) s x=$zf(-1,"mv "_$zu(147,old)_" "_$zu(147,new)) d:x
 . . . w !,"ERROR: rename failed with error code "_x
 q  
}
DBRENAMEMOVE(dir,newdir) [] PRIVATE {
 s $zt="DBRenErr"
 s dir=$zu(12,dir) q:dir=""  ; Canonicize directory name if we can
 d DBalterMove(dir,newdir,".DAT")
 s dblist(dir)="",next=$zu(36,newdir,0,1)
 f  q:next=""!(next<0)  d
 . s next=$zu(12,next) q:next=""
 . q:$d(dblist(next))  d DBalter(next,".EXT")
 . s dblist(next)="",next=$zu(36,next,1,1)
 q 1
DBRenErr s $zt=""
 w !,"ERROR: "_$ze
 q 0
}
DBalterMove(dir,newdir,ext) [] PRIVATE {
 i ($zversion(1)=3) q:dir'?.e1"/"  ; N/A to raw disk partitions
 s new=newdir_"IRIS"_ext q:$$DBtest(new)
 s done=0 f dbname="CACHE" d  q:done
 . s old=dir_dbname_ext i $$DBtest(old) d  s done=1 q
 . . i ($zversion(1)=2) d
 . . . f i=1:1:10 s x=$zf(-1,"MOVE "_$zu(147,old)_" "_$zu(147,new)) q:x=0  h (i*.5)
 . . . i x w !,"ERROR: rename failed with error code "_x
 . . i ($zversion(1)=3) d
 . . . f i=1:1:10 s x=$zf(-1,"mv "_$zu(147,old)_" "_$zu(147,new)) q:x=0  h (i*.5)
 . . . i x w !,"ERROR: rename failed with error code "_x
 h 1
 q  
}
RENAMEMOVE(old,new) [] PRIVATE {
 s status=1
 i ($zversion(1)=2) d
 . f i=1:1:10 s x=$zf(-1,"MOVE "_$zu(147,old)_" "_$zu(147,new)) q:x=0  h (i*.5)
 . i x w !,"ERROR: rename failed with error code "_x s status=0
 i ($zversion(1)=3) d
 . f i=1:1:10 s x=$zf(-1,"mv "_$zu(147,old)_" "_$zu(147,new)) q:x=0  h (i*.5)
 . i x w !,"ERROR: rename failed with error code "_x s status=0
 h 1
 q status
}
DBtest(dbf) [] PRIVATE {
 s $zt="DBerr" o dbf:"RU":0 c dbf q $t
DBerr q 1 ; File exists but we have trouble opening it
}
DBCREATE(dir) [] PRIVATE {
 i $zu(140,9,dir)
 i +$zu(49,dir)=-1 q 1
 s x=$$CreateDatabase^%SYS.DATABASE(dir)
 q x
}
 ; 
CHANGEMAPS(dir) [] PRIVATE {
 s $zt="CHANGEMAPSE"
 s stat=$zu(49,dir),oldmaxmaps=$p(stat,",",6) d:oldmaxmaps
 . n %data s %data="$zu(1,"""_dir_""","_$p(stat,",",2,5)_",0,"_$p(stat,",",7,12)_")"
 . i @%data
 q oldmaxmaps
CHANGEMAPSE s $zt=""
 q oldmaxmaps
}
RESTOREMAPS(dir,oldmaxmaps) [] PRIVATE {
 s $zt="RESTOREMAPSE"
 d:oldmaxmaps
 . i $$QUIESCE^SWSET(4,"database expansion",30,0)
 . s stat=$zu(49,dir),newmaxmaps=$p(stat,",",4)
 . s:newmaxmaps<oldmaxmaps newmaxmaps=oldmaxmaps ;Current maps > old max?
 . n %data s %data="$zu(1,"""_dir_""","_$p(stat,",",2,5)_","_newmaxmaps_","_$p(stat,",",7,12)_")"
 . i @%data
 q
RESTOREMAPSE s $zt=""
 q
}
OPTION(prompt,default,max) [] PRIVATE {
 s $zt="OPTIONE"
OPTION1 w !,prompt
 r Option i Option="" q default
 i '(Option?.N)!(Option<1)!(Option>max) w !!,"Please enter a number between 1 and "_max,! g OPTION1
 q +Option
OPTIONE s $zt=""
 i $ze'["<INTERRUPT>" w !,"ERROR: "_$ZE
 q 0
}
GSIZE(bigdb,blk) [] PRIVATE {
 s $zt="GSIZERR"
 o 63
 s Count=0
 f  q:'blk  v blk s type=$case(bigdb,2048:$v(2043,0,1),:$v($Zutil(40,32,1),0,1)) q:(type=6!(type=70))  s blk=$v(2,-5)
 i blk d
 . f  q:'blk  v blk  d  s Count=Count+i-1 
 . . f i=1:1 s x=$v(i*2-1,-6) q:x=""
 . . s blk=$case(bigdb,2048:$v(2040,0,"3O"),:$v($Zutil(40,32,4),0,4))
 q Count
GSIZERR
 s $zt=""
 i $ze["UNIMPLEMENTED" s $ze="" q 0
 q 0
}
LABEL(Dir) [] PRIVATE {
 s $zt="LABELE"
 s Label=$zu(36,Dir,0,0)
 ;q:+Label<0  ; If $ZU(36) failed, stop here
 I +Label<0 q
 q:Label=Dir
 s Label=$zu(36,Dir,0,0,Dir)
 s NextDir=$zu(36,Dir,0,1)
 f  q:(NextDir="")!(NextDir<0)  d
 . d $zu(36,NextDir,1,0,Dir)
 . s NextDir=$zu(36,NextDir,1,1) 
 q
LABELE s $ZT=""
 q
}
DISMOUNT(db) [] PRIVATE {
 s $zt="DISMOUNTE"
 f i=1:1:20 s status=$zu(3,db) q:status>0  h 1
 h 1
 q status 
DISMOUNTE s $zt=""
 q -29
}
MOUNT(db) [] PRIVATE {
 f i=1:1:20 s status=$zu(17,db) q:status>0  h 1
 q status 
MOUNTE s $zt=""
 q -29
}
IsLongStringEnabled() q 1
ShowMessage(sc,device) [] PRIVATE {
    Do DecomposeStatus^%SYS.DATABASE(sc,.msglist,0,"")
    Do wrtmsg($C(13,10),device)
    For i=1:1:msglist {	Do wrtmsg(msglist(i)_$C(13,10),device) }
}
wrtmsg(msg,device) [] PRIVATE {
    Quit:'$L(msg)  ; Avoid argumentless writes...
    If device=-1 { Do $zu(9,"",msg,0,0) Quit }
    If $g(%UI,"CHUI")="CHUI" { Use device Write msg Quit }
    Do:$$IjcMsg^%Wprima("DI"_msg)="CANCEL"  ; Return value could be cancel message 
    . i $$IjcMsg^%Wprima("DI"_$C(13,10)_"Abort received!"_$C(13,10))
    . zt "Abort"
}
YN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YN"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"yn","YN") I "^YN"'[R W "  enter Yes or No, please"
 S POP=(R="^") W $E($S(R="N":"No",R="Y":"Yes",1:""),$L(X)+1,3) Q R

GBLOCKCOPY1^INT^1^67214,47330
GBLOCKCOPY1 ; GBLOCKCOPY reports
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
MONITORREPORT(InName) [] PUBLIC {
 s $zt="MONITORREPORTE"
 u 0::"^%X364"
 d CLEAR(1,24)
 s page=1,POP=0,Detail=1
 s totalblocks=+$g(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",InName,1,"TOTALBLOCKS"),0),totaltime=$zh,blkspersec=0
 f  d  i POP d CLEAR(1,24) q 
 . w /cup(1,1)
 . w $$CENTER("GBLOCKCOPY Monitor at "_$ZDATETIME($h),80)
 . w /cup(2,1)," #",?3,"Source DB=>Destination DB/NS",?40,"    Job#",?49,"Last Update",?61,"Done/ToDo/Err",?75,"State"
 . w /cup(3,1)," -",?3,"----------------------------",?40,"    ----",?49,"-----------",?61,"-------------",?75,"-----" h 0
 . k DISPLAY
 . i InName'="*" s Name=InName d MONITORREPORT1
 . i InName="*" s Name="" f  s Name=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name)) q:Name=""  d MONITORREPORT1 s DISPLAY($i(DISPLAY(0)))=$j("",80)
 . s Count=4
 . f i=page*20-19:1:page*20 d
 . . i $d(DISPLAY(i)) w /cup(Count,1),DISPLAY(i)
 . . e  w /cup(Count,1),$j("",80)
 . . s Count=Count+1
 . w /cup(24,1) w "(N)ext, (P)rev, (D)etail, (S)ummary, (R)efresh (Q)uit? Refresh => "
 . u 0:(:"+S")
 . r *x:10
 . u 0:(:"-S")
 . i (x=78)!(x=110) s page=page+1 i '$d(DISPLAY(page*20-19)) s page=page-1
 . i (x=80)!(x=112) s page=page-1 i page=0 s page=1
 . i (x=68)!(x=100) s Detail=1 q
 . i (x=83)!(x=115) s Detail=0
 . i (x=81)!(x=113) s POP=1
 q
MONITORREPORT1
 d GETJOBSTATUS^GBLOCKCOPY(Name,0,0,.JobInfo)
 d GETJOBS^GBLOCKCOPY(Name,.Jobs,.JobsDir)
 s line="Batch Name: "_Name_"  "_JobInfo(0)_" of "_Jobs_" Processes running, "_JobsDir_" per directory, "
 i $zh-totaltime>20 d
 . s ptotalblocks=totalblocks,totalblocks=+$g(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,1,"TOTALBLOCKS"),0),blocks=totalblocks-ptotalblocks
 . s ptotaltime=totaltime,totaltime=$zh,time=totaltime-ptotaltime
 . s blkspersec=$s(time=0:blocks,1:blocks\time)
 s line=line_blkspersec_" blocks/sec"
 s DISPLAY($i(DISPLAY(0)))=line_$j("",80-$l(line))
 s Index="" f  s Index=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index)) q:Index=""  d
 . s Status=$$GETSTATUS^GBLOCKCOPY(Name,Index)
 . s line=$j(Index,2)_" "_$$LJ($p(Status,"~",3),46)_$$LJ($$DISPLAYDATE($p(Status,"~",9)),12)
 . s line=line_$j($p(Status,"~",8),4)_"/"_$j(($p(Status,"~",6)+$p(Status,"~",7)+$p(Status,"~",8)),4)_"/"_$j($p(Status,"~",10),3)_" "_$$LJ($p(Status,"~",4),5)
 . s DISPLAY($i(DISPLAY(0)))=line_$j("",80-$l(line))
 . q:Detail=0
 . s glo="" f  s glo=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSSTARTED",glo),1,cvtdata) q:glo=""  d
 . . s Job=+$p(cvtdata,"~",1)
 . . s line="   "_$$LJ($p(cvtdata,"~",8),37)_$j(Job,8)_" "_$$LJ($$DISPLAYDATE($p(cvtdata,"~",4)),12)
 . . s nblocks=+$p(cvtdata,"~",6),blockstocopy=+$p(cvtdata,"~",11)
 . . s error=$p(cvtdata,"~",9) i error[">" s error=$p(error,">",1)_">"
 . . i error="" d
 . . . s pdone="0%"
 . . . s line=line_$j(nblocks,4)_"/"_$j(blockstocopy,4) i blockstocopy'=0 s pdone=$p((nblocks/blockstocopy*100),".")_"%"
 . . . s line=line_$j("",80-$l(line)-5)
 . . . i $e(line,*)'=" " s line=line_" "
 . . . i JobInfo(0)=0 s line=line_$$LJ("Crash",5) q
 . . . i $p(cvtdata,"~",12)'="" s line=line_$$LJ($p(cvtdata,"~",12),5) q
 . . . s line=line_$$LJ(pdone,5)    
 . . i error'="" s line=line_error
 . . s DISPLAY($i(DISPLAY(0)))=line_$j("",80-$l(line))
 q
MONITORREPORTE s $zt=""
 u 0:(:"+S")
 q:$ze["<INTERRUPT>"
 w !,"Error: "_$ze
 q
 }
SUMMARYREPORT(Name,Detail) [] PUBLIC {
 d GETJOBSTATUS^GBLOCKCOPY(Name,0,0,.JobInfo)
 d GETJOBS^GBLOCKCOPY(Name,.Jobs,.JobsDir)
 w !
 w !,"Batch Name: "_Name_"  "_JobInfo(0)_" of "_Jobs_" Processes running, "_JobsDir_" per directory"
 i Detail d
 . w !," #",?3,"Source DB=>Destination DB/NS",?40,"    Job#",?49,"Last Update",?61,"Done/ToDo/Err",?75,"State"
 . w !,"--",?3,"----------------------------",?40,"    ----",?49,"-----------",?61,"-------------",?75,"-----"
 i 'Detail d
 . w !," #",?3,"Source DB=>Destination DB/NS",?49,"Last Update",?61,"Done/ToDo/Err",?75,"State"
 . w !,"--",?3,"----------------------------",?49,"-----------",?61,"-------------",?75,"-----"
 s (grandnblocks,grandblockstocopy)=0
 s Index="" f  s Index=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index)) q:Index=""  d
 . s Status=$$GETSTATUS^GBLOCKCOPY(Name,Index)
 . w !,$j(Index,2),?3,$p(Status,"~",3)
 . w ?49,$$DISPLAYDATE($p(Status,"~",9)),?61,$j($p(Status,"~",8),4)_"/"_$j(($p(Status,"~",6)+$p(Status,"~",7)+$p(Status,"~",8)),4)_"/"_$j($p(Status,"~",10),3)
 . w ?75,$p(Status,"~",4)
 . q:'Detail
 . s (totnblocks,totblockstocopy)=0
 . If $d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"EMPTYSOURCE")) w !,?3,"The database is empty" q  
 . s glo="" f  s glo=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSENDED",glo),1,cvtdata) q:glo=""  d
 . . w !,?3,glo,?40,$j($p(cvtdata,"~",1),8),?49,$$DISPLAYDATE($p(cvtdata,"~",4))
 . . s error=$p(cvtdata,"~",9)
 . . s nblocks=$p(cvtdata,"~",6),blockstocopy=$p(cvtdata,"~",11),totnblocks=totnblocks+nblocks,totblockstocopy=totblockstocopy+blockstocopy 
 . . i error="" d
 . . . w ?61,$j(nblocks,4)_"/"_$j(blockstocopy,4) i nblocks'=blockstocopy w "<="
 . . i error'="" w ?61,error
 . . w ?75,"Done"
 . s glo="" f  s glo=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSSTARTED",glo),1,cvtdata) q:glo=""  d
 . . s Job=+$p(cvtdata,"~",1)
 . . w !,?3,$e($p(cvtdata,"~",8),1,36),?40,$j(Job,8),?49,$$DISPLAYDATE($p(cvtdata,"~",4))
 . . s error=$p(cvtdata,"~",9) i error[">" s error=$p(error,">",1)_">"
 . . s pdone="0%"
 . . s nblocks=$p(cvtdata,"~",6),blockstocopy=$p(cvtdata,"~",11),totnblocks=totnblocks+nblocks,totblockstocopy=totblockstocopy+blockstocopy 
 . . i error="" d
 . . . i blockstocopy'=0 s pdone=$p((nblocks/blockstocopy*100),".")_"%"
 . . . w ?61,$j(nblocks,4)_"/"_$j(blockstocopy,4) i nblocks'=blockstocopy w "<="
 . . i error'="" w ?61,error
 . . w ?75
 . . i $d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"STOP")) w "Stop"
 . . e  i error'="" w "Error"
 . . e  i JobInfo(0)=0 w "Crash"
 . . e  i $p(cvtdata,"~",12)'="" w $p(cvtdata,"~",12)
 . . e  w pdone
 . s glo="" f  s glo=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSQUEUED",glo),1,cvtdata) q:glo=""  d
 . . w !,?3,glo,?75,"Queue"
 . w !,"TOTAL",?61,$j(totnblocks,4)_"/"_$j(totblockstocopy,4) i totnblocks'=totblockstocopy w "<=",!
 . s grandnblocks=grandnblocks+totnblocks,grandblockstocopy=grandblockstocopy+totblockstocopy
 i Detail w !,"GRAND TOTAL",?61,$j(grandnblocks,4)_"/"_$j(grandblockstocopy,4) i grandnblocks'=grandblockstocopy w "<="
 q
 }
DETAILREPORT(Name) [glinfo] PUBLIC {
 w !!,"Batch Name: ",?17,Name
 s Time=$g(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,1,"START"))
 w !,"Start Time:  ",?17,$s(Time="":"Not Started",1:$zdatetime(Time))
 s Index="",lastupdate=0  f  s Index=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index)) q:Index=""  d  q:lastupdate="Running"
 . i '$d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"END")) s lastupdate="Running",elapsedtime=$h q
 . s date=^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"END")
 . s lastupdate=$s(+lastupdate>+date:lastupdate,+lastupdate<+date:date,+$p(lastupdate,",",2)>+$p(date,",",2):lastupdate,1:date)
 d GETJOBSTATUS^GBLOCKCOPY(Name,0,1,.JobInfo)
 i lastupdate'="Running" s elapsedtime=lastupdate,lastupdate=$zdatetime(lastupdate)
 e  i JobInfo(0)=0 s lastupdate="Crashed",elapsedtime=$h
 i $d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,1,"STOP")) s lastupdate="Stopped"
 i Time="" s lastupdate="",elapsedtime=""
 w !,"End Time: ",?17,lastupdate
 i elapsedtime'="" d
 . s elapsedtime=((elapsedtime*86400)+$p(elapsedtime,",",2))-((Time*86400)+$p(Time,",",2))
 . s h=(elapsedtime\3600),m=(elapsedtime#3600\60),s=(elapsedtime#3600#60)
 . s:$l(h)=1 h="0"_h s:$l(m)=1 m="0"_m s:$l(s)=1 s="0"_s
 . s elapsedtime=h_":"_m_":"_s
 w !,"Elapsed Time:",?17,elapsedtime
 d GETJOBS^GBLOCKCOPY(Name,.Jobs,.JobsDir)
 w !,"Jobs Scheduled: ",?17,Jobs
 w !,"Jobs/Directory: ",?17,JobsDir
 w !,"Jobs Running:   ",?17,JobInfo(0)
 w !,$j("Job #",8),?9,"Status",?17,"  #",?22,"Start Time",?34,"Global/EndTime/Error"
 s Job=0 f  s Job=$o(JobInfo(Job)) q:Job=""  d
 . s JobIndex=0 f  s JobIndex=$o(JobInfo(Job,JobIndex)) q:JobIndex=""  d
 . . s Status=$p(JobInfo(Job,JobIndex),"~",1)
 . . s Start=$$DISPLAYDATE($p(JobInfo(Job,JobIndex),"~",2))
 . . s Stop=$$DISPLAYDATE($p(JobInfo(Job,JobIndex),"~",3))
 . . s Index=$p(JobInfo(Job,JobIndex),"~",4)
 . . s Glo=$p(JobInfo(Job,JobIndex),"~",5)
 . . s Err=$p(JobInfo(Job,JobIndex),"~",6)
 . . w !,$j(Job,8),?9,Status,?17,$j(Index,3),?22,Start,?34
 . . i Glo'="" w Glo
 . . e  w Stop,"  ",Err
 s (grandnblocks,grandblockstocopy)=0
 s Index="" f  s Index=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index)) q:Index=""  d
 . d DETAILED2
 . s grandnblocks=grandnblocks+totnblocks,grandblockstocopy=grandblockstocopy+totblockstocopy
 i $g(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,1,"START")) d
 . s start=^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,1,"START")
 . s Index="",end=0,Index=""  f  s Index=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index)) q:Index=""  d
 . . i '$d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"END")) s end=$h q
 . . s date=^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"END")
 . . s end=$s(+end>+date:end,+end<+date:date,+$p(end,",",2)>+$p(date,",",2):end,1:date)
 . s elapsed=((end*86400)+$p(end,",",2))-((start*86400)+$p(start,",",2))
 . w !,"GRAND TOTAL",?32,$j(grandnblocks,7)_"/"_grandblockstocopy i grandnblocks'=grandblockstocopy w "<="
 . w ?73,$s(elapsed=0:(grandnblocks),1:+$p(((grandnblocks)/elapsed),".",1))
 q
DETAILED2
 w !!,"Batch Entry: ",?17,Index
 w !,"Source DB: ",?17,$e(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"SRCDIR"),3,*)
 s srcdirtype=$g(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"SRCDIRTYPE"),"IRIS"_".DAT")
 i srcdirtype'=("IRIS"_".DAT") w "  (formerly "_srcdirtype_")"
 s dstdir=^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"DSTDIR")
 i $e(dstdir,1,2)="^^" w !,"Destination DB: ",?17,$e(dstdir,3,*)
 e  w !,"Destination NS: ",?17,dstdir
 s Time=$g(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"START"))
 w !,"Start Time:",?17,$s(Time="":"Not Started",1:$zdatetime(Time))
 s Endtime=$g(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"END"))
 w !,"End Time:",?17,$s($d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,1,"STOP")):"Stopped",Endtime="":"",1:$zdatetime(Endtime))
 s Info=$$GETSTATUS^GBLOCKCOPY(Name,Index)
 w !,"Last Update:",?17 i $p(Info,"~",9)'="" w $zdatetime($p(Info,"~",9))
 i Time="" s elapsedtime=""
 i Endtime'="" s elapsedtime=Endtime
 e  s elapsedtime=$p(Info,"~",9)
 i elapsedtime'="" d
 . s elapsedtime=((elapsedtime*86400)+$p(elapsedtime,",",2))-((Time*86400)+$p(Time,",",2))
 . s h=elapsedtime\3600,m=elapsedtime#3600\60,s=elapsedtime#3600#60
 . s:$l(h)=1 h="0"_h s:$l(m)=1 m="0"_m s:$l(s)=1 s="0"_s
 . s elapsedtime=h_":"_m_":"_s
 w !,"Elapsed Time:",?17,elapsedtime
 w !,"Global List:",?17,$p(Info,"~",5)
 w !,"Journaling:",?17,$s($g(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"JOURNAL"))=1:"Enabled",1:"Disabled")
 w !,"Status:",?17,$p(Info,"~",4)
 w !,"Errors:",?17,$p(Info,"~",10)
 w !,"Completed:",?17,$p(Info,"~",8)_" of "_($p(Info,"~",8)+$p(Info,"~",6)+$p(Info,"~",7))
 w !,"Running:",?17,($p(Info,"~",7)-$p(Info,"~",10))
 w !,"Queued:",?17,$p(Info,"~",6)
 d GETJOBSTATUS^GBLOCKCOPY(Name,Index,0,.JobInfo)
 i JobInfo(0) d
 . w !,"Jobs Assigned: ",?17,JobInfo(0)
 . w !,$j("Job #",8),?9,"Status",?17,"Start Time",?29,"Global"
 . s Job=0 f  s Job=$o(JobInfo(Job)) q:Job=""  d
 . . s JobIndex=0 f  s JobIndex=$o(JobInfo(Job,JobIndex)) q:JobIndex=""  d
 . . . s Status=$p(JobInfo(Job,JobIndex),"~",1)
 . . . s Start=$$DISPLAYDATE($p(JobInfo(Job,JobIndex),"~",2))
 . . . s Glo=$p(JobInfo(Job,JobIndex),"~",5)
 . . . w !,$j(Job,8),?9,Status,?17,Start,?29,Glo
 i $p(Info,"~",10) d
 . w !!,"Globals with ERRORS:"
 . w !,"Global",?32,"Block #",?40,"%ETN #",?47,"Error/LastReference"
 . s glo="" f  s glo=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSSTARTED",glo),1,cvtdata) q:glo=""  d
 . . s error=$p(cvtdata,"~",9) q:error=""
 . . s errnum=$p(cvtdata,"~",10) s:+errnum=0 errnum=""
 . . w !,glo,?32,$j($p(cvtdata,"~",5),7),?40,$j(errnum,5)
 . . f  q:error=""  w ?47,$e(error,1,33) s error=$e(error,34,$l(error)) i error'="" w !
 . . s lastref=$p(cvtdata,"~",8)
 . . f  q:lastref=""  w !,?47,$e(lastref,1,33) s lastref=$e(lastref,34,$l(lastref))
 i $d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"RESTART")) d
 . w !!,"Globals which were RESTARTED:"
 . w !,"Global",?32,"Restart Time",?52,"Original error"
 . s glo="" f  s glo=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"RESTART",glo),1,Info) q:glo=""  d
 . . f i=1:1 s data=$p(Info,"*",i) q:data=""  d
 . . . s time=$zdatetime($p(data,"~",1))
 . . . s error=$p(data,"~",2) s:error="" error="Crash"
 . . . w !,glo,?32,time
 . . . f  q:error=""  w ?52,$e(error,1,27) s error=$e(error,28,$l(error)) i error'="" w !
 s (totnblocks,totblockstocopy)=0
 w !!,"Copy Statistics:"
 w !,"Global",?31,"Blk Done/ToDo",?49,"Start Time",?61,"Last Update",?73,"Blk/sec"
 i '$d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"START")) d  q
 . i $d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSLIST","*")) d  q
 . . k glinfo set rc=$$GetGlobalDirectoryInfo^%SYS.DATABASE(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"SRCDIR"),"glinfo")
 . . s glo="" f  s glo=$o(glinfo(glo)) q:glo=""  w !,glo
 . s glo="" f  s glo=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSLIST",glo)) q:glo=""  w !,glo
 If $d(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"EMPTYSOURCE")) w !,?3,"The database is empty" q  
 s glo="" f  s glo=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSENDED",glo),1,cvtdata) q:glo=""  d
 . s nblocks=$p(cvtdata,"~",6),blockstocopy=$p(cvtdata,"~",11),start=$p(cvtdata,"~",2),end=$p(cvtdata,"~",4),elapsed=((end*86400)+$p(end,",",2))-((start*86400)+$p(start,",",2))
 . w !,glo,?32,$j(nblocks,7)_"/"_blockstocopy i nblocks'=blockstocopy w "<="
 . w ?49,$$DISPLAYDATE(start),?61,$$DISPLAYDATE(end),?73,$s(elapsed=0:(nblocks),1:+$p((nblocks)/elapsed,".",1))
 . s totnblocks=totnblocks+nblocks,totblockstocopy=totblockstocopy+blockstocopy
 s glo="" f  s glo=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSSTARTED",glo),1,cvtdata) q:glo=""  d
 . s nblocks=$p(cvtdata,"~",6),blockstocopy=$p(cvtdata,"~",11),start=$p(cvtdata,"~",2),end=$p(cvtdata,"~",4),elapsed=((end*86400)+$p(end,",",2))-((start*86400)+$p(start,",",2))
 . w !,$e($p(cvtdata,"~",8),1,31),?32,$j(nblocks,7)_"/"_blockstocopy i nblocks'=blockstocopy w "<="
 . w ?49,$$DISPLAYDATE(start),?61,$$DISPLAYDATE(end),?73,$s(elapsed=0:(nblocks),1:+$p(((nblocks)/elapsed),".",1))
 . s totnblocks=totnblocks+nblocks,totblockstocopy=totblockstocopy+blockstocopy
 s glo="" f  s glo=$o(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"GLOBALSQUEUED",glo)) q:glo=""  d
 . w !,glo,?32,"Queue"
 s end=$g(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"END")) i end="" s end=$h
 s start=$g(^|"^^"_$zu(12)|%SYS("GBLOCKCOPY",Name,Index,"START"))
 s elapsed=((end*86400)+$p(end,",",2))-((start*86400)+$p(start,",",2))
 w !,"TOTAL",?32,$j(totnblocks,7)_"/"_totblockstocopy i totnblocks'=totblockstocopy w "<="
 w ?73,$s(elapsed=0:(totnblocks),1:+$p(((totnblocks)/elapsed),".",1))
 q
}
CENTER(str,rm) [] PRIVATE {
 Q $J(str,$L(str)+rm\2)
}
CLEAR(first,last) [] PRIVATE {
 s Blank=$j("",80)
 w /cup(first,1)
 f i=first:1:last w /cup(i,1),Blank
 w /cup(1,1)
 q
}
LJ(var,pad) [] PRIVATE {
 s $zt="LJE"
 s var=var_$j("",pad)
 q $e(var,1,pad)
LJE s $zt=""
 q var
}
DISPLAYDATE(Date) [] PRIVATE {
 i Date="" q Date
 s cvtdate=$zdatetime(Date)
 q $p(cvtdate,"/",1,2)_" "_$p($p(cvtdate," ",2),":",1,2)
 }

GCOMPACT^INT^1^67214,47330
GCOMPACT ; Global Compaction Utility
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ; GLOBAL COMPACTION UTILITY
 new FORCE
 s FORCE=0
TOP ; 
 w !,"*** Global Database Compaction and Relocation Utility ***",!!
 Write !,"This utility is deprecated in favor of ^DATABASE"
 Do COMPACT^DATABASE() q  
 n %ST,%TIM,%DAT,DEND,DIRINFO,DIRNAM,GD,NUMMAP,POP,RD
 New ABORT,counted,msg
 N %BatchMode
 New %A,%ANS,%G,%JO,IO,IOBS,IOF,IOM,IOPAR,IOSL,IOST,IOT,MSYS,NSPNAM,RMSDF,g,glo,totfrom,totto,x,mtemp1
 d ASK^%SYS.FILE q:DIRNAM=""  w !
 s DIRNAM=$ZU(12,DIRNAM)
 n otherglo s otherglo=0
 n blocks,fullness,gref,otherblks,otherfull
 ;After calling CheckGCOMPACTLimit (and it returns 1) you must exit
 ;through END so we decrement the in use count
 S %BatchMode=$ZU(68,25)  ; save batch process mode
 s counted=0
 s $ZT="errhand"
 s x=$$CheckGCOMPACTLimit(FORCE,DIRNAM,.msg) 
 i '+x {
	 if ('FORCE) {
		 w !,msg 
		 w !,"You can force GCOMPACT to run by calling FORCE^GCOMPACT but this"
		 w !,"   is not recommended"
		 g END
	 } else {
	    do $ZU(9,"","GCOMPACT forced to run with insufficient buffers")
	    w !,"WARNING: You are forcing GCOMPACT to run when it thinks there are"
	    w !,"         insufficient buffers. This may trigger a write daemon panic."
	    w !!
	 }
 }
 s counted=1  ;so we decrement the count of jobs at END
 w "Specify the names of all the globals for which recompaction of",!
 w "the entire global should occur: ",!
 I $ZU(5,"^^"_DIRNAM)
 D INT^%GSET  g askmore:'%G
    ; Specify how full the data blocks should be
 f  d  q:fullness
 .  r !,"How full do you want the database blocks for those globals? 90% => ",fullness,!
 .  i fullness="" s fullness=90 q
 .  s fullness=+fullness
 .  i fullness<50!(fullness>100)!(fullness\1'=fullness) w " [Must choose an integer between 50 and 100]",! s fullness=0
 n NSPNAM s NSPNAM="^^"_DIRNAM
 I %G=+^||IRIS.TempUtil("GLO",0) G device
    ; see if there's any globals for special requirements
askmore w !,"Now specify entries that require either a starting place other",!
 w "than the beginning of the global (in which case specify a global",!
 w "reference for a starting point) and/or for which you don't want to",!
 w "compact to the end of the global (in which case specify the",!
 w "number of data blocks to compact for that global) or for which",!
 w "you wish to specify a different fullness %.",!!
 w "Starting global reference",?30,"# blocks to compact",?52,"% fullness"
 f otherglo=1:1 d gref q:gref=""  d
 .  s otherglo(otherglo)=gref
 .  w ?30,"all=> " r x i x="" s otherblks(otherglo)=0
 .  e  s otherblks(otherglo)=+x i x<1!(x\1'=x)!(x>10000000) w !,"[Enter null for all blocks or enter an integer between 1 and 10000000]" s otherglo=otherglo-1 q
 .  w ?52,"90=> " r x i x="" s otherfull(otherglo)=90
 .  e  s otherfull(otherglo)=+x i x<50!(x\1'=x)!(x>100) w !,"[Enter null for 95% or enter an integer between 50 and 100]" s otherglo=otherglo-1
 .  q
 s otherglo=otherglo-1
 i 'otherglo,'%G w !,"No globals selected - Done" G END
device ;
 N IOMS s IOMS=$System.Device.GetRightMargin()
 D OUT^%IS G:POP END  ; ask for output device
 U IO D INT^%D,INT^%T W !,%DAT_" "_%TIM,!
 w ?24,"Compressed",?42,"To",!
 w "Global",?25,"Data Blks",?35,"Data Blks",?45,"End Time",?55,"Last Node",!
 s totfrom=0,totto=0
 do $ZU(68,25,1)  ;set batch process mode
 l +^|"^^"_DIRNAM|GCOMPACT:10
 i '$t w !,"Compaction already being run on database" g END
 set ABORT=0
    ; process complete globals
 s gref="" f  s gref=$o(^IRIS.TempJ(%JO,gref)) q:gref=""  s blocks=0 d compact Q:ABORT
    ; process special entries
 if 'ABORT f glo=1:1:otherglo do  quit:ABORT
 . s gref=otherglo(glo),blocks=otherblks(glo),fullness=otherfull(glo) 
 . d compact
 if ('ABORT) {
 	w ?25,"_________",?35,"_________",!
 	w ?25,$j(totfrom,9),?35,$j(totto,9)
 	i totfrom w " ",$j(totto*100/totfrom,5,1),"%"
 }
END ;STC450
 i counted do DecrementUserCount(DIRNAM) s counted=0
 w ! 
 I $D(IO),(IO=$P),$D(IOMS) U IO:/MAR=IOMS 
 i $D(IO),(IO'=$I) c:$L(IO) IO
 l -^|"^^"_DIRNAM|GCOMPACT
 I $ZU(5,"%SYS")
 S %BatchMode=$ZU(68,25,%BatchMode) ; restore original batch process mode
 q
errhand ;
	s $ZT=""
	w !,$ZE
	g END
FORCE ;
	new resp
	; Start here if you want to force GCOMPACT to run regardless
	; of whether it thinks there are sufficient global buffers to
	; run without triggering a write daemon panic. A write daemon
	; panic means that the rules of image journaling will be
	; violated in order to prevent the system from hanging. A crash
	; during a panic can result in database degradation.
	w !,"Are you sure you want to force GCOMPACT to run even"
	w !,"if this may exhaust the buffer pool and trigger a"
	w !,"write daemon panic condition? "
	r !,"Continue with GCOMPACT? <No> ",resp
	if "Yy"[$E(resp_"X") s FORCE=1 G TOP
	q
    ; compress and relocate this global
compact s $zt="comperr"
 w gref
 n NSPNAM s NSPNAM="^^"_DIRNAM
 s g="^["""_NSPNAM_"""]"_gref
 i '$d(@g) w ?25,"no data in global",! q  ;jfp034;get starting block
 s x=$zu(98,fullness,blocks)
 ;the return from $ZU(98) is status:<info> where status is 0 or 1
 if +x {
	 set x=$P(x,":",2)
 } else {
	 s x=+$P(x,":",2)
	 goto fatalerr
 }
 s totfrom=totfrom+x,totto=totto+$p(x,",",2)
 w ?25,$j(+x,9),?35,$j($p(x,",",2),9) D INT^%T w ?45,%TIM,?55
 i $p(x,",",3)="" w "finished global",!
 e  w $p(x,",",3,1000),!
 q
comperr w !,"Error processing this entry - skipping it",! q
fatalerr ;
 ;come here when $ZU(98) returns 0:<code> with x=<code>
 ;These are fatal errors, print an error message and exit
 new msg
 do GetZU98ErrMsg(x,.msg)
 w !,msg
 set ABORT=1
 quit
GetZU98ErrMsg(x,msg)
 if (x=1) {
	 s msg="GCOMPACT detected that there were insufficient free global"
	 s msg=msg_$C(13,10)_" buffers to start compacting a bottom pointer block."
	 s msg=msg_$C(13,10)_" Try again when the system is not so busy or increase the"
	 s msg=msg_$C(13,10)_" size of the global buffer pool."
 } elseif (x=2) {
	 s msg="GCOMPACT detected that a write daemon panic occurred while it"
	 s msg=msg_$C(13,10)_" was running. Try again when the system is not so busy."
 } else {
	 s msg="Unknown error code ("_x_") returned from $ZU(98)."
	 s msg=msg_$C(13,10)_"GCOMPACT aborted."
 }
 q
 ;
 ; specify a starting global reference
gref r !,gref i $e(gref)="^" s gref=$e(gref,2,*)
 q:gref=""
 i $e(gref)="[" w !,"[Do not include a directory specification]" g gref
 n NSPNAM s NSPNAM="^^"_DIRNAM
 i '$d(^||IRIS.TempUtil("GLO",$p(gref,"("))) w !,"[Must be a global in directory ",DIRNAM," ]" g gref
 i gref["(",gref'?.E1")" s gref=gref_")"
 s $zt="greferr" s g="^|"""_NSPNAM_"""|"_gref i $d(@g)
 q
greferr s $zt="" w !,"[Syntax error on global reference]" g gref
CheckGCOMPACTLimit(force,DIRNAM,errmsg) ;
	n NGLO,blksize,cnt,val,maxblks,bufpercopy,dbsize,realcnt,passtwo
	s passtwo=0
	s dbsize=$P($ZU(49,DIRNAM),",",2)
	s maxblks=dbsize/8  ;max # of pointers in a bottom pointer block
	s bufpercopy=maxblks*2  ;require a buffer pool at least 100% larger than this
	s val=$Case(dbsize,2048:0,4096:1,8192:2,16384:3,32768:4,:5)
	f  d  q:(NGLO)!(val=5)  s val=val+1
 	. s NGLO=$v($ZU(40,2,135)+(val*$ZU(40,0,1)),-2,$ZU(40,0,1))
	i ('NGLO) s cnt=0,blksize=dbsize g CGLerr  ;Shouldn't happen
	;Set blksize based on the size of the buffer we're going to use
	s blksize=$CASE(val,0:2048,1:4096,2:8192,3:16384,4:32768,:65536)
again ;
	s cnt=$I(^|"%SYS"|%SYS("GCOMPACT","USERCNT",val))
	;Take out the lock and return 1 if we can run.
	;The lock is just so we can reset the count of the # of users
	;if we think its out of sync.
	i ((cnt*bufpercopy)'>NGLO) L +%GCOMPACT(val,$J) quit 1  ;success
	;
	;Too many users...
	;
	if 'force {
	   s cnt=$I(^|"%SYS"|%SYS("GCOMPACT","USERCNT",val),-1)
	   if cnt,'passtwo s realcnt=$$ResetGCOMPACTUserCount(val) if realcnt'=cnt s passtwo=1 goto again
	}
	s bufpercopy=(bufpercopy*blksize)/(1024*1024) ;convert to MB
CGLerr ;
	i 'cnt {
		set errmsg="You do not have sufficient buffers configured to run GCOMPACT"
		set errmsg=errmsg_$C(13,10)_"in this database. A minimum of "_bufpercopy_"MB is required."
	} else {
		set errmsg=cnt_$S(+cnt=1:" copy of GCOMPACT is",1:" copies of GCOMPACT are")_" already running."
 		set errmsg=errmsg_$C(13,10)_"The buffer pool is not large enough to support any more."
 	   set errmsg=errmsg_$C(13,10)_"Each copy requires approximatly "_bufpercopy_"MB to avoid exhausting the "
 		set errmsg=errmsg_$C(13,10)_"buffer pool which would trigger a write daemon panic."
	}	
	quit 0
DecrementUserCount(DIRNAM) ;
 ;Call this to release the lock and decrement the count of the
 n NGLO,blksize,val
 s dbsize=$P($ZU(49,DIRNAM),",",2)
 s val=$Case(dbsize,2048:0,4096:1,8192:2,16384:3,32768:4,:5)
 f  d  q:(NGLO)!(val=5)  s val=val+1
 . s NGLO=$v($ZU(40,2,135)+(val*$ZU(40,0,1)),-2,$ZU(40,0,1))
 i ('NGLO) quit   ;Shouldn't happen
 ;# of jobs running GCOMPACT.
 set x=$I(^|"%SYS"|%SYS("GCOMPACT","USERCNT",val),-1)
 l -%GCOMPACT(val,$J)
 q
ResetGCOMPACTUserCount(val) ;
	;This shouldn't be needed but if the user count gets out of sync
	;this counts the # of locks on %GCOMPACT(...) to reset it. This is called
	;any time we think there are too many users, just to make sure.
	new name,cnt
	s name="%GCOMPACT("_val_")"
	for cnt=0:1 s name=$O(^$LOCK(name)) quit:(name="")!($QS(name,0)'="%GCOMPACT")!($QS(name,1)'=val)
	set ^|"%SYS"|%SYS("GCOMPACT","USERCNT",val)=cnt
	quit cnt

GETPPGINFO^INT^1^67214,47330
GETPPGINFO(inpid , options , outputfile ) 
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
    if $namespace'="%SYS" {
	w !,"Utility must be loaded and run in the %SYS namespace!"
	quit	
    }
    do Get2(.inpid, .options, .outputfile)
    q
Get2(inpid , options , outputfile )  [] PRIVATE {
    set inpid=$g(inpid) , outputfile = $g(outputfile) , options = $g(options)
    s:inpid="" inpid="*"
    if ($l(outputfile)) {
    	open outputfile:"WN":0
	if ('$T) {
	    w "Error, unable to open file "_outputfile,!
	    q
	} else {
	    try {
	    	use outputfile
		w $S($f(options,"T"):"JOB,BLOCKS",1:"JOB,PPGNAME,BLOCKS"),!
		use 0
	    } catch ex {
	    	use 0
	    }
	}
    }
    if (inpid'="*") {
	if +inpid'=inpid {
	    w !,"Invalid Process ID: "_inpid,!
	    quit 0	
	}	
	set good=0
	try {
	    set x = ##class(%SYS.ProcessQuery).Open(inpid)
	    s good=1
    	} catch err {
	    w "No such pid exists, sorry.",!
    	}
	kill x
	quit:'good 0
    }
    if inpid="*" {  ;All
	set maxjob = $zu(181)				// Maximum number of jobs
	do multipleProcs(1,maxjob,options,.outputfile)
    } else {
    	if ($f(options,"J")) {				// GGC742 If J option, we are specifying a job number
	    set job = inpid 
	} else {
	    set job=$zu(67,inpid)			// Convert process id to job number
	    q:job=0 1
	}
	d multipleProcs(job,job,options,.outputfile)
    }
    close:$l(outputfile) outputfile
    kill Rset 
    q 1
}
multipleProcs(jobnumberStart,jobnumberEnd,options,outputfile) [] PRIVATE {
    s filter="*"		// Look for all PPGs within a process
    s optionS=$f(options,"S"),	// Check the "S" option
      optionT=$f(options,"T"),	// Check the "T" option
      optionJ=$f(options,"J"),	// Check the "J" option
      optionMptr=$f(options,"M")	// Preserve the M option
    if (optionMptr) {
	    set optionM=""
    	while ($e(options,optionMptr)?1N) { s optionM=optionM_$e(options,optionMptr),optionMptr=optionMptr+1}
    } else {
	    s optionM=1  //Default = suppess processes with no PPGs
    }
    if ($f(options,"b")) {
    	set options="Nb" , optionB=1
    } else {
    	set options="NB" , optionB=0
    }
    for jobnumber = jobnumberStart:1:jobnumberEnd {
    	set pid = $zu(96,2,jobnumber)
	if (pid > 0) s joblist($S(optionJ>0:jobnumber,1:pid))=jobnumber_","_pid
    }
    s sfn=$ZU(173)
    q:sfn=$zu(40,0,41)  ; cachetemp isn't set up, ppgs will live in various current working directories
    set DIRNAM=$p($zu(49,sfn,3),"^",2)
    q:DIRNAM=""
    set info=$zu(49,DIRNAM)
    s dbsize=$p(info,",",2)
    set key=""
    for {
    	set key=$O(joblist(key),1,data)
		q:key=""
		set jobnumber = $p(data,",",1) , pid = $p(data,",",2)
		try {
			s blockcount = $zu(61,33,jobnumber)		// Retrieve the PPG count for this job number
			continue:((optionM>0)&&(blockcount<optionM))
			w:'optionS $S(optionJ=0:"Process ID: "_pid,1:"Job #: "_jobnumber)," --> Total PPG Block count "_blockcount,!
			if ((optionT)&&($l(outputfile))) {
				use outputfile
				w pid_","_blockcount,!
				use 0
			}
			if (('optionT)&&(+blockcount>0)) {
				k stack,res
				do PPGExecute^|"%SYS"|JOBEXAM(.stack , filter , pid , options )
				s processmaxblk=$LG($LG(stack(1),$LG(stack(0),5)),1)  ;global directory block #
				for {
					k res
					s res = $$PPGNext^|"%SYS"|JOBEXAM(.stack , .list )
					q:res  ;0 = good
					s gloname=$lg(list,1) , blocks = $lg(list,3)
					s maxblk=$lg(list,4)
					w:'optionS ?5,"^||",gloname," uses "_$$dispsize()," (maxblock #",maxblk,")",!
					if maxblk>processmaxblk s processmaxblk=maxblk
					if ($l(outputfile)) {
						s:optionB blocks = blocks \ dbsize 	// Remove the conversion from blocks to bytes
						use outputfile
						w pid_","_pid_".^||"_gloname_","_blocks_","_maxblk,!
						use 0
					}
				}
				w ?5,"Highest block #: ",processmaxblk,!
				if ($l(outputfile)) {
					use outputfile
					w ?5,"Highest block #: ",processmaxblk,!
					use 0
				}
			}
		} catch err {
			use 0
			w !,"Error inspecting process id "_pid,!
		}
	}
	use 0	// Just in case !
    q
dispsize()
    q:'optionB blocks_" block"_$case(blocks,1:"",:"s")
    s bytes=blocks,suffix=" bytes"
    if (bytes>(10*1048576)) {
		set bytes=(bytes/1048576*10)\1/10,suffix=" M"_suffix
    } elseif (bytes > 10240) {
		set bytes=(bytes/1024*10)\1/10,suffix=" K"_suffix
    }
    q $fnumber(bytes,",")_suffix
}

GLOBAL^INT^1^67214,47330
GLOBAL ;Manage globals
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 n
 d MENU()
 q
MENU() { 
 s $zt="ERROR"
 s List(1)="Create a global"
 s List(2)="Edit a global"
 s List(3)="Calculate size of a global"
 s List(4)="Compact a global"
 f  {
	s Directory=""
	s Flag=8+8192+512
 	s Status=##class(SYS.Database).GetDirectory("Database directory?",.Directory,,,,,Flag)
 	i (Status=0)||(Status=2)||(Directory="") q
	f  {
		s Value=""
		s Status=##Class(%Library.Prompt).GetMenu("Option?",.Value,.List,,8+128+512)
		i (Status=0)||(Status=2)||(Value="") q
		i Value=1 d CREATE(Directory) Continue
		i Value=2 d EDIT(Directory) Continue
		i Value=3 d GETSIZE(Directory) Continue
		i Value=4 d COMPACT(Directory) Continue
	}
 }
 q Status
ERROR s $zt=""
 i $ze["<INTERRUPT>" q 0
 ztrap $ze
}
CREATE(Directory) {
 s $zt="ERROR"
 f  {
	s Value=""
	s Flag=8+16384+512
 	s Status=##class(%Library.GlobalEdit).GetName(Directory,"Global name?",.Value,.Obj,,,,Flag)
 	i (Status=0)||(Status=2)||(Value="") q
	f  {
 		s Value=0
 		s Status=##Class(%Library.Prompt).GetYesNo("Change default global properties?",.Value,,8)
 		i (Status=2)||(Status=0) q
 		i Value=1 {
	 		s Status=##Class(%Library.Prompt).EditFields(.Obj,1)
 			i (Status=0)||(Status=2) q
 		}
 		s Value=1
 		s Status=##Class(%Library.Prompt).GetYesNo("Confirm creation of global "_Obj.Name_"?",.Value,,8)
		i (Status=2) Continue
 		i (Status=0) q
 		i Value {
			s Status=Obj.%Save()
			i ('Status) {
				w ! d $SYSTEM.Status.DisplayError(Status) w !
			} else {
				w !,"Global "_Obj.Name_" created"
	 		}
 		}
 		k Obj
 		q
	}
 }
 q Status
ERROR s $zt=""
 i $ze["<INTERRUPT>" q 0
 ztrap $ZE
}
EDIT(Directory) {
 s $zt="ERROR"
 f  {
	s Value=""
	s Flag=8+8192+512
 	s Status=##class(%Library.GlobalEdit).GetName(Directory,"Global name?",.Value,.Obj,,,,Flag)
 	i (Status=0)||(Status=2)||(Value="") q
  f  {
 	s Status=##Class(%Library.Prompt).EditFields(.Obj,0)
 	i (Status=0)||(Status=2) q
 	s Value=1
	i Obj.%IsModified()=0 q  
        s keepcheck=0 i Obj.IsKeepIsModified() s keepcheck=1
 	s Status=##Class(%Library.Prompt).GetYesNo("Confirm update of global "_Obj.Name_"?",.Value,,8)
 	i (Status=0) q
 	i (Status=2) Continue
 	i Value {
		s Status=Obj.%Save()
		i ('Status) {
			w !!,$SYSTEM.Status.DisplayError(Status)
		} else {
			w !,"Global "_Obj.Name_" updated"
	 	}
		i keepcheck,'Obj.IsKeep {
			s glob="^"_"|"_"""^^"_Directory_""""_"|"_Obj.Name
			i '$d(@glob) s @glob=1 k @glob
		}
 	}
 	q
  }
  i (Status=0) q
 }
 q Status
ERROR s $zt=""
 i $ze["<INTERRUPT>" q 0
 ztrap $ZE
}
GETSIZE(Directory) {
 s $zt="ERROR"
 f  {
	s Value=""
	s Flag=8+8192+512
 	s Status=##class(%Library.GlobalEdit).GetName(Directory,"Global name?",.Value,.Obj,,,,Flag)
 	i (Status=0)||(Status=2)||(Value="") q
	s Status=Obj.GetSize(.allocated,.used)
 	i (Status=0)||(Status=2) q
	u 0 w !,"Global ^",Obj.Name,":  ",allocated," MB Allocated",", "
        u 0 w used," MB Used"
 }
 q Status
ERROR s $zt=""
 i $ze["<INTERRUPT>" q 0
 ztrap $ZE
}
COMPACT(Directory) {
 s $zt="ERROR"
 f  {
	s Value=""
	s Flag=8+8192+512
 	s Status=##class(%Library.GlobalEdit).GetName(Directory,"Global name?",.Value,.Obj,,,,Flag)
 	i (Status=0)||(Status=2)||(Value="") q
	s Percent=90
	s Help="Enter the percentage of how full each data block should be, 50-100."
	s Status=##Class(%Library.Prompt).GetNumber("How Full of the data block (%)?",.Percent,50,100,.Help)
 	i (Status=2) Continue
 	i (+Status=0) q
	s Status=Obj.Compact(Percent,.cursize,.newsize,.last)
 	i (Status=0)||(Status=2) q
	u 0 w !,"Global ^",Obj.Name,":  Started with ",cursize," MB",", "
        u 0 w "Compressed to ",newsize," MB"
	u 0 w !,"Last global reference: ",last
 }
 q Status
ERROR s $zt=""
 i $ze["<INTERRUPT>" q 0
 ztrap $ZE
}

GLOBUFF^INT^1^67214,47330
GLOBUFF	; Analyze global buffers
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	;
	w !,"Find which globals are using the most buffers.",!
	w !,"Display the top <25>: " u 0 r n q:n="^"
	s n=+n s:n=0 n=25
	d display(n)
	q
 ; count and sort all buffers:
 ; pass 'return'=1 by reference to return the sorted array rather than print results
display(nbuff, return) PUBLIC {
	s gbfnum=$V($ZU(40,2,17),-2,$ZU(40,0,1)),total=0,PPG=0
	s quiet=($g(return)=1)
	; count all buffers for each global/sfn 
	f buff=0:1:gbfnum-1 {
		s info=$zu(190,16,buff)
		s sfn=$p(info,",",1),block=$p(info,",",2),type=$p(info,",",3),gbl=$p(info,",",4)
		; check for global names which contain "big string" blocks
		i gbl["*" {
			s gbl=$p(gbl,"*"),crc=$zcrc(gbl,7)
			i '$d(CRC(crc,sfn)) s CRC(crc,sfn)=gbl
			; just in case we find 2 globals with the same CRC-32
			e  i CRC(crc,sfn)'=gbl s CRC(crc,sfn)=""
		}
		if block'=-1 {
			i gbl="" s gbl="_Unknown_"
			i gbl="||" s gbl="||_Unknown_"
			s sub=gbl_"^"_sfn,total=total+1
			; for "big string" blocks, we'll try and match the CRC later
			i $ISVALIDNUM(gbl) s GLOBUFF("b",sub)=$g(GLOBUFF("b",sub))+1
			e  s CNT(sub)=$g(CNT(sub))+1
		}
		; count PPGs
		i $e(gbl,1,2)="||" s PPG=PPG+1
	}
	; find global names for big string blocks and add them to the parent global
	s sub=""
	f  {
		s sub=$order(GLOBUFF("b",sub),1,count) Quit:sub=""
		s crc=$p(sub,"^"),sfn=$p(sub,"^",2),gname=$g(CRC(crc,sfn))
		i gname="" s gname=$$gbig(sub)
		i gname]"" {
			s psub=gname_"^"_sfn
			s CNT(psub)=$g(CNT(psub))+count
			k GLOBUFF("b",sub) ; remove if found, we'll report leftovers
		}
	}
	; sort counts and calculate percentages
	s sub=""
	f  {
		s sub=$order(CNT(sub),1,count) Quit:sub=""
		s GLOBUFF("%",-count,sub)=count/total*100
	}
	; get a list of database names
	s rset=##class(%Library.ResultSet).%New("Config.Databases:List")
	d rset.Execute()
	while (rset.Next()) {
		s server=rset.Data("Server") s:server="" server=0
		s dbase(server,$zu(12,rset.Data("Directory")))=rset.Data("Name")
	}
	; display results
	s cnt="",num=1,tcnt=0
	i 'quiet {
		w !!,"Total buffers: ",gbfnum w:total'=gbfnum ?25," Buffers in use: ",total
		w ?50," PPG buffers: ",PPG i PPG w " (",$fn((PPG/total)*100,"",3),"%)"
		w !!,"Item  Global                             Database          Percentage (Count)",!
	}
	f  {
		s cnt=$order(GLOBUFF("%",cnt)) Quit:cnt=""
		s gbl=""
		f  {
			s gbl=$order(GLOBUFF("%",cnt,gbl),1,percent) Quit:gbl=""
			s name=$p(gbl,"^"),sfn=$p(gbl,"^",2)
			s zu49=$zu(49,+sfn,3),dir=$zu(12,$p(zu49,"^",2)),svr=$p(zu49,"^") s:svr'=0 svr=$zu(63,4,svr)
			s dbname=$g(dbase(svr,dir)) s:dbname="" dbname="SFN: "_sfn
			if 'quiet {
				w num,?6,name,?40," ",dbname,?60,$fnumber(percent,"",3)," (",-cnt,")",!
			} else {
				s return(num)=$lb(name,dbname,$fnumber(percent,"",3))
			}
			s num=num+1 q:num>nbuff
		}
		q:num>nbuff
	}
	; report any big string blocks we couldn't identify
	s sub=""
	i $order(GLOBUFF("b",sub))]"" {
		i 'quiet w !!,"No global name match for the following 'big string' blocks: ",!
	}
	f  {
		s sub=$order(GLOBUFF("b",sub),1,count) Quit:sub=""
		s crc=$p(sub,"^"),sfn=$p(sub,"^",2)
		s zu49=$zu(49,+sfn,3),dir=$zu(12,$p(zu49,"^",2)),svr=$p(zu49,"^") s:svr'=0 svr=$zu(63,4,svr)
		s dbname=$g(dbase(svr,dir)) s:dbname="" dbname="SFN: "_sfn
		i 'quiet w !,"CRC=",crc," in ",dbname," - ",count," blocks"
	}
	q
}
gbig(sub) PUBLIC {
	s crc=$p(sub,"^"),sfn=$p(sub,"^",2),dir=$p($zu(49,+sfn,3),"^",2)
	s fnd=0,gname=""
	s rset=##class(%Library.ResultSet).%New("%SYS.GlobalQuery:DirectoryList")
	d rset.Execute(dir,,,1,,1)
	while (rset.Next()) {
		i crc=$zcrc(rset.Data("Name"),7) {
			i 'fnd s gname=rset.Data("Name"),fnd=1
			e  s gname="" q
		}
	}
	q gname
}
noname ; list unknown global blocks
	n gbfnum,total,buff,info,sfn,block,type,gbl
	s gbfnum=$V($ZU(40,2,17),-2,$ZU(40,0,1)),total=0
	w !,"Buffer - SFN, Block, BlockType, Global"
	f buff=0:1:gbfnum-1 {
		s info=$zu(190,16,buff)
		s sfn=$p(info,",",1),block=$p(info,",",2),type=$p(info,",",3),gbl=$p(info,",",4)
		i block'=-1,(gbl="")||(gbl="||") w !,buff,?6," - ",info s total=total+1
	}
	w !!,total," buffers found with no global name"
	q
Dump(file,delay=30,length=3600,notemp=1) public {
	Set $ztrap="trap",sc=1,io=$IO
	If file'="" Open file:("NW":/GZIP=$case($zconvert($piece(file,".",*),"l"),"gz":1,"gzip":1,:0):/OBUFSIZE=32768:/NOXY=1):0 Else  Quit $$Error^%apiOBJ(5001,"Unable to open file "_file)
	Use:file'="" file
	Set gbfnum=$V($ZU(40,2,17),-2,$ZU(40,0,1))-1
	Write "Buffers:"_gbfnum,!
	Write "Period:"_delay,!
	Write "NoTemp:"_notemp,!
	For buff=0:1:gbfnum Set data(buff)="-1,-1",same(buff)=""
	Set start=$zh
	While $zh-start<length {
		Write "Timestamp:"_$horolog,!
		Set zh=$zh
		For buff=0:1:gbfnum {
			Set info=$zutil(190,16,buff)
			If notemp {
				If data(buff)=$piece(info,",",1,2) {
					If $data(same(buff)) {
						Continue
					} Else {
						Set same(buff)=""
					}
				} Else {
					Set data(buff)=$piece(info,",",1,2)
					Kill same(buff)
					Continue
				}
			} Else {
				If data(buff)=$piece(info,",",1,2) {
					Continue
				} Else {
					Set data(buff)=$piece(info,",",1,2)
				}
			}
			Set sfn=$p(info,",",1),block=$p(info,",",2)
			If block=-1 {
				Write buff_","_block_","_sfn,!
			} Else {
				Set type=$p(info,",",3),gbl=$p($p(info,",",4),"*")
				If type'=24 Continue
				If $isvalidnum(gbl) {
					If '$data(crclist(sfn)) Do findCRCFromSFN(sfn,.crclist)
					Set gbl=$get(crclist(sfn,gbl),gbl)
				}
				Write buff_","_block_","_sfn_","_type_","_gbl,!
			}
		}
		Write !
		Use io Write $zh-zh,! Use:file'="" file
		Hang delay-($zh-zh)
	}
exit	Close:file'="" file Use io
	Quit sc
trap	Set $ztrap=""
	If $zerror'["<INTERRUPT" Set sc=$$Error^%apiOBJ(5002,$zerror)
	Goto exit
}
findCRCFromSFN(sfn,list) {
	Set list(sfn)=""
	Set dir=$p($zu(49,+sfn,3),"^",2)
	Try {
		s rset=##class(%Library.ResultSet).%New("%SYS.GlobalQuery:DirectoryList")
		d rset.Execute(dir,,,1,,1)
		while (rset.Next()) {
			Set crc=$zcrc(rset.Data("Name"),7)
			If $data(list(sfn,crc),tmp) {
				Set list(sfn,crc)=tmp_","_rset.Data("Name")
			} Else {
				Set list(sfn,crc)=rset.Data("Name")
			}
		}
	} Catch {
		; Just ignore an error here and we will not lookup the big string
	}
}
Read(file) public {
	Quit 1
	Set $ztrap="trap",sc=1,io=$IO
	Open file:("RS":/GZIP=$case($zconvert($piece(file,".",*),"l"),"gz":1,"gzip":1,:0):/NOXY=1):0 Else  Quit $$Error^%apiOBJ(5001,"Unable to open file "_file)
	Use file
	Read line
	Set gbfnum=$piece(line,"Buffers:",2)
	If gbfnum="" Set sc=$$Error^%apiOBJ(5001,"Invalid file "_file) Goto exit
	Read line
	Set period=$piece(line,"Period:",2)
	If period="" Set sc=$$Error^%apiOBJ(5001,"Invalid file "_file) Goto exit
	Read line
	Set notemp=$piece(line,"NoTemp:",2)
	If notemp="" Set sc=$$Error^%apiOBJ(5001,"Invalid file "_file) Goto exit
	Set movav=60*10\period,movavtime=period*movav
	For buff=0:1:gbfnum Set data(buff)="-1,-1,0,"
	For iteration=0:1 {
		Read line If $zeof Goto exit
		Set time=$piece(line,"Timestamp:",2) If time="" Set sc=$$Error^%apiOBJ(5001,"No timestamp in "_file) Goto exit
		Use io Write "Time: ",$zdt(time,3),! Use file
		Set replaced=0
		For buffs=1:1 {
			Read line If $zeof Goto exit
			If line="" Quit
			Set buff=$piece(line,","),block=$piece(line,",",2),sfn=$piece(line,",",3),type=$piece(line,",",4),gbl=$piece(line,",",5)
			Set old=data(buff)
			If $piece(old,",")'=-1,block'=-1 Set replaced=replaced+1
			Set data(buff)=block_","_sfn_","_type_","_gbl
			If iteration>0 { Use io Write "Replaced block ",old," : ",data(buff),! Use file }
		}
		If iteration>0 {
			Set totalreplaced=totalreplaced+replaced
			Set replaced(iteration)=totalreplaced
			Set averagereplaced=totalreplaced/(period*iteration)
			Use io
			Write "Blocks replaced: ",replaced,"/",buffs-1,!
			Write "Average replacement rate/s: ",averagereplaced,!
			Write:averagereplaced>0 "Time to replace a block: ",gbfnum/averagereplaced,"s",!
			If iteration>movav {
				Set changed=totalreplaced-replaced(iteration-movav),averagereplaced=changed/movavtime
				Write "Ten minute replacement rate/s: ",averagereplaced,!
				Write:averagereplaced>0 "Ten minute av time to replace a block: ",gbfnum/averagereplaced,"s",!
			}
			Use file
		} Else {
			Set totalreplaced=0
		}
		Use io Write ! Use file
	}
exit	Close file Use io
	Quit sc
trap	Set $ztrap=""
	If $zerror["<ENDOFFILE>" Goto exit
	Set sc=$$Error^%apiOBJ(5002,$zerror)
	Goto exit
}
ClearBuffers() public {
	Set gbfnum=$V($ZU(40,2,17),-2,$ZU(40,0,1)),total=0
	For buff=0:1:gbfnum-1 {
		Set info=$zu(190,16,buff)
		Set sfn=$piece(info,",",1),block=$piece(info,",",2)
		If block'=-1 {
			Try {
				Do $zu(7,sfn,block)
				Set total=total+1
			} Catch {
			}
		}
	}
	Write "Removed ",total," blocks",!	
}

GLOREC^INT^1^67214,47330
GLOREC	Do LOG() Quit 
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	;
	; Log and Display utility for the GLORECORD table
	; 
	; External entry points:
	; 	LOG - prompts for filename and delay then jobs off GLOREC daemon
	; 	AUTOLOG - non-interactive, pass filename and delay values
	; 	STOP - signals GLOREC daemon to shutdown
	; 	
LOG() Public {
    Try {
		If '$zu(40,41,0) {
		    Write !,"GLORECORD feature not available in this build.",! quit
		}
		If $get(^%GLOREC)'="" {
			Set file=$list(^%GLOREC,2)
		    Write !,"Stopping GLORECORD" Do STOP
		    Set zh=$zh
			read !,"Display output <Y> ",display,!
			If display="" Set display="Y"
			If $zconvert(display,"l")'="y" Quit
			Hang (zh+1.1-$zh)
			Do DisplayLog(file,0)
			Quit
		}
		Read !,"File to log the GLORECORD table to: <glorec.grc>  ",file
		If file="" {
		    Set file="glorec.grc"
		}
		Read !,"Log records every <0.1> second(s)?  ",delay
		If delay="" {
		    Set delay=0.1
		}
		Read !,"Type of block information to record <16384> ",flags
		If flags="" Set flags=16384
		Do AUTOLOG(file,delay,flags)
    } Catch {
		Do BACK^%ETN
    }
}
	;
AUTOLOG(file,delay,flags) Public {	;	callable entry point
    Try {
		If '$zu(40,41,0) {
		    Write !,"GLORECORD feature not available in this build.",!
		    Quit
		}
		Job START(file,delay,$g(flags))
		Write !,"GLORECORD Log Deamon started with job number "_$j,!
    } Catch {
		Do BACK^%ETN
    }
}
	;
START(file,delay,flags) public {
    Do HIGH^%PRIO
    Try {
		If file="" { s file="glorec.grc" }
		If delay="" { s delay=0.1 }
		Open file:("WUNK\RAW\":/OBUFSIZE=32768:/NOXY=1):5
		Quit:'$T
		If $get(flags)="" Set flags=(2**14)
		Set grf=$ZU(40,2,134)
		View grf:-2:4:(flags)
		Set ^%GLOREC=$lb($J,file)
		Set maxrectab=$v($zu(40,2,140),-2,4)
		Set glorectab=$v($zu(40,2,142),-2,"C")
		Set recsize=$zu(40,41,0)
		Set endtab=glorectab+(maxrectab*recsize)
		Use file Write $zwc(recsize),$ZLCHAR(flags)
		Set pos=2
		Set end=$v($zu(40,2,141),-2,4)-1
		Set start=end,time=$h
		Set chunk=400,lastposoffset=glorectab+(maxrectab*recsize)
		For {
			For rec=start:chunk:end {
				Set endrec=rec+chunk-1 If endrec>end Set endrec=end
				Set offset=glorectab+(rec#maxrectab*recsize)
				If (rec\maxrectab)=(endrec\maxrectab) {
					Set size=(endrec-rec+1)*recsize
					Set data=$view(offset,-2,-size)
					If $l(data)=size {
						Write data
					} Else {
						If $increment(^%GLOREC(1)) {}
					}
				} Else {
					Set size=lastposoffset-offset
					Set data=$view(offset,-2,-size)
					If $length(data)=size {
						Write data
					} Else {
						If $increment(^%GLOREC(1)) {}
					}
					Set size=endrec#maxrectab+1*recsize
					Set data=$view(glorectab,-2,-size)
					If $length(data)=size {
						Write data
					} Else {
						If $increment(^%GLOREC(1)) {}
					}					
				}
			}
		    set start=end+1                 ; start with the next one
		    set end=$v($zu(40,2,141),-2,4)-1
		    If end-start>maxrectab {
				If $I(^%GLOREC(0)) {} ;Counter of wraparound
				Set start=end-maxrectab+2000
		    } ElseIf (start > (end-2000)) {
			    hang delay ; wait for more
			    set end=$v($zu(40,2,141),-2,4)-1
				If end-start>maxrectab {
					If $I(^%GLOREC(0)) {} ;Counter of wraparound
					Set start=end-maxrectab+2000
					Set delay=delay/10
			    }
		    }
			If time'=$h Set time=$h If $get(^%GLOREC)="" Quit
		}
    } Catch {
		Do BACK^%ETN
    }
    Close file
}
	;
STOP() Public { Set ^%GLOREC="" }
	;
DISPLAY() Public {
    Try {
		Read !!,"Enter the name of the file: <glorec.grc>  ",file
		If file="" { s file="glorec.grc" }
		Read !,"Show details? <no> ",x
		Set detail=$zcvt($e(x),"u")="Y"
		Read !,"Display all records? <yes> ",x
		If $zcvt($e(x),"u")'="N" {
		    Do DisplayLog(file,0,detail)
		} Else {
		    Read !,"Display records with pid: <all>  ",pid
		    For {
		        Read !,"Display records with action ('?' for a list):  <all>  ",code
			Quit:code'="?"
			Do listcodes
			Write !
		    }
		    Read !,"Display records with bdb: <all>  ",bdb
		    Read !,"Display records with sfn: <all>  ",sfn
		    Read !,"Display records with blk: <all>  ",blk
		    Write !
		    Do DisplayLog(file,1,detail,$lb(bdb,sfn,blk))
		}
    } Catch {
		Do BACK^%ETN
    }
}
	;
DisplayLog(file,check,detail,chk) [FF,IO,IOF,IOSL,IOST] {
	New FF,IO,IOF,IOSL,IOST
    Try {
		Do OUT^%IS
		Set FF="W "_IOF_" S $Y=0"
		Set SELF=($I=IO),CRT=(IOST?1"C".E)
		Set:'SELF CRT=0
		Close file
		Open file:("RUK\RAW\"):5
		Quit:'$T
		Use file Read recsize#2 Set recsize=$zwa(recsize) Use IO
		If recsize'=$zu(40,41,0) {
		    Write !,"File not compatible"
		    Quit
		}
		Use file Read flags#4 Set flags=$ZLASCII(flags) Use IO
		Set blocktype=$zboolean(flags,2**14,1)
		If blocktype Do BlockType(.blocktype)
		Do BlockType(.blocktype)
		Do Header
		For  {
		    Use file Read record#recsize
		    While $l(record)<recsize {
				Hang 0.1
				Use file Read left#(recsize-$l(record))
				Set record=record_left
		    }
		    Do Parse(record)
		    If check,'$$Check() {} Else { If $$Print() { Quit } }
		}
    } Catch {
		If $ze'["<ENDOFFILE>" { Do BACK^%ETN }
    }
    Close file
    Close:'CRT IO
    Quit
    ;
Parse(record) ;
    Set xtime=$zqa(record,1+$zu(40,41,1))
    Set xpid=$zla(record,1+$zu(40,41,3))
    Set xcode=$a(record,1+$zu(40,41,15))
    Set xfacilty=$a(record,1+$zu(40,41,16))
    Set xsfn=$zwa(record,1+$zu(40,41,9))
    Set xwdflags=$zla(record,1+$zu(40,41,10))
    Set xbdb=$zla(record,1+$zu(40,41,4))
    Set xblk=$zla(record,1+$zu(40,41,5))
    Set xflags=$zla(record,1+$zu(40,41,24))
    Set xotherflags=$zla(record,1+$zu(40,41,25))
    Set xextra=$zqa(record,1+$zu(40,41,2))
    If blocktype {
	    Set xdisk=xextra\65536,xextra=xextra#65536
	    Set xextra=$get(blocktype(xextra),xextra)
    }
    Quit
	;
Check()	;
    Quit 1
	;
Print() ;
    Use IO
    If CRT,($y+3)>IOSL {  
		Use 0 Read !!,"--more--",x
		Set x=$zconvert(x,"l")
		If x="q"||(x="n") Quit 1
		If x="c" Set CRT=0
		If x>0 Set IOSL=x
		Do Header
    }
    If xblk=4294967295 { Set xblk=-1 }
    If xsfn=15999 { Set xsfn="UND" }
    Use IO Write !,xtime,?16,$j(xpid,6),$j(xbdb,10),$j(xblk,10),$j(xsfn,5),$j(xextra,8)," ",$p($text(codes+xcode),";;",2)
    If blocktype,xdisk Write " x"
    Quit 0
}
BlockType(struct) {
	Set struct(1)="DIR"
	Set struct(2)="PNT"
	Set struct(6)="BPNT"
	Set struct(8)="DATA"
	Set struct(12)="BDATA"
	Set struct(16)="BITMAP"
	Set struct(32)="ARTREE"
	Set struct(9)="DIR4K"
	Set struct(24)="BIGDATA"
	Set struct(64)="TOPPNTBIT"
	Set struct(66)="TPNT"
	Set struct(70)="TBPNT"
	Set struct(17)="MIRBLK"
}
Header() [IO,FF] {
    Xecute FF
    Use IO
    Write !!,"Time/Counter",?16,$j("mypid",6),$j("bdb",10),$j("blk",10),$j("sfn",5),$j("extra",8)," action"
    Write !, "----------------",$j("-----",6),$j("---",10),$j("---",10),$j("---",5),$j("-----",8)," ------"
}
listcodes() {
    For i=1:1:163 {
		S txt=$p($text(codes+i),";;",2)
		If txt'="" {
		    Write !,i,?5,txt
		}
    }
}
codes	;;
	;;GBLKRD_S
	;;GBLKRD_X
	;;GKCLRIN_S
	;;GKCLRIN_X
   	;;AWAIT_S
   	;;AWAIT_X
   	;;AWAIT_W
   	;;AWAITANY
   	;;RECEIVE_X
   	;;RECEIVE_S
   	;;NORECEIVE
   	;;GRANT_X
   	;;GRANT_S
   	;;NOGRANT
   	;;GRANT_ANY
   	;;GWDQ
   	;;RELEASESHADOW
   	;;GSHADOWBLK
   	;;WDSEC
   	;;NEXTINWDQ_SHAD
   	;;EXTINWDQ_NOSHAD
   	;;WDCHKP
   	;;CHKP
   	;;PROCWDWKQ
   	;;GSET
   	;;GKILL
   	;;GINCREMENT
   	;;GGET
   	;;GORDER
   	;;GDEFINE
   	;;GDEFVAL
   	;;GXINUSE
   	;;NEXTINWDQ
   	;;GPNTCOL
   	;;GFREEBUF
   	;;GBLKPURGE
   	;;GBUFSET
   	;;GBUFLOC
   	;;GETBIGVAL
   	;;GSHADOWRET
   	;;GRELEASESHAD2
   	;;SWD_SKIPWRITE
   	;;GBSDQ
   	;;WDBUFONE
   	;;GLRUQEUE
   	;;GMRUQUEUE
   	;;GLRUDEQUEUE
   	;;GLRUENQUEUE
   	;;GALLOCCLBLK
   	;;CPR CLEARALL
   	;;GALLOCRSRVDCNT
   	;;GFREERSVRDBLKS
   	;;GFREERSVRDBLKS SAT
   	;;GTRYCNT
   	;;GTRYCNT SAT
   	;;CPR ADD GTRYCNT
   	;;GTRYMAP4K
   	;;GTRYMAP4K SAT
   	;;CPR ADD GTRYMAP4K
   	;;
   	;;
   	;;
   	;;CPR FREE DISMOUNT
   	;;CPR FREE DKFLUSH
   	;;GBCOL NEWBUF
   	;;GBCOL DEFERED
   	;;GBCOL SAT UPD
   	;;GBCOL SATERR
   	;;GBCOL FREE BLOCK
   	;;MAP ERROR
   	;;
   	;;
   	;;
   	;;
   	;;
   	;;GCCOL4K TOP
   	;;GCCOL4K PNT
   	;;GCCOL4K BPNT
   	;;GCCOL4K DATA
   	;;GCCOL4K ERR
   	;;GCOLLECT_1
   	;;GCOLLECT_2
   	;;
   	;;GKILLFROMTOP4K
   	;;
   	;;GDELNODES4K
   	;;
   	;;GBIGDEALLOC TOP
   	;;GBIGDEALLOC BOT
   	;;
   	;;CHKDELN 4K
   	;;C_ADDBLK_PRGND
   	;;C_PRG_SRVREQ
   	;;C_PRG_ADDBLK1
   	;;C_PRG_ADDBLK2
   	;;C_PRG_LISTPNT
   	;;C_PRG_LISTBLK
   	;;C_DELETEPNT
   	;;C_ADDBLK
   	;;C_NETCHKREQ_UPD
   	;;C_NETCHKREQ_PRG
   	;;C_PRGBLK_ADDPNT
   	;;S_SNDBLK
   	;;S_GBSDQ
   	;;S_NBIGDB_ALLOC
   	;;S_PRGBLK
   	;;S_QUEUEPRG
	;;
	;;GOFFLRUtoLRU
	;;GOFFLRUtoMRU
	;;SEIZE
	;;XSEIZE
	;;RELEASE
	;;XRELEASE
	;;JRNSWITCH
	;;JRNDAEMON
	;;JRNSYNCBLK
	;;JRNOUTSYNC
	;;JRNIOWAIT
	;;JRNDIRBLK
	;;MIRJRNWAITFAIL1
	;;MIRJRNWAITFAIL2
	;;MIRJRNWAITDONE
	;;MIRJRNDONEFAIL
	;;MIRJRNDONE
	;;SYNCWITHJRN
	;;PROCEXIT
	;;FBP_DCLOSE
	;;FBP_GBCOLLECT
	;;FBP_GALLO1
	;;FBP_GTRYMAP4K
	;;HIBERNATE
	;;WAKEUP
	;;WOKEUP
	;;WDQREM
	;;WDQREM2
	;;GWDQ2
	;;GWDQ3
	;;GCLRINUSFAST
	;;GCLRINUXFAST
	;;GBDB_GETS
	;;GBDB_GETX
	;;GSRCHLAST_GETS
	;;GSRCHLAST_GETX
	;;CLRSHADOWX
	;;GBUFLOCRETRY
	;;GBUFLOCXOWN
	;;GCONVSH2X
	;;WDDISMPURGE
	;;WDQ_ACTIVE_ADD
	;;WDINC_READBLK
	;;WDINC_WRITEBLK
	;;WDINC_READPRIV
	;;WDINC_WRITEPRIV
	;;WDINC_WRTPRIVFND
	;;WD_AVAILBUF
	;;GWDQ_STUCK
	;;GWDQ_WTREQ
	;;INMEMQREMActive
	;;INMEMQREMStuck
	;;REMActive
	;;LISTMOVE
	;;INMEMXFER

GLOSTAT^INT^1^67214,47330
GLOSTAT ;Global Statistics
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 New
 Set client=$D(^NET(2,$P($ZU(86),"*",2),"DV","ECPNET1"))
 Set dskbase=$ZU(40,2,86) ;zero -> no detailed disk stats
ask
 If dskbase {
    Read !,"Should detailed statistics be displayed for each block type? No =>",ans
    Set ans=$TR($e(ans),"ynq","YNQ") Goto quit:ans="Q"
    If "YN"'[ans Write !?5,"Please enter Yes, No or Quit",! Goto ask
    Set detail=ans="Y"
 } Else {
    Set detail=0
 }
 Write ! Do static
choice 
 Read !,"Continue (c), Timed Stats (# sec > 0), Quit (q)?  ",act
 If "Qq"'[act Goto action
quit Write ! Quit
action If "Cc"[act Do static Goto choice
 If act?1n.n,act>0 Do timing Goto choice
 Write " ???" Goto choice
static Write ! Do get,show(0)
 Quit
zero ;
Zero ;
 Quit
timing Write !!,"Counts per Second for ",act," Seconds...",!! Do get Hang act
 new gstats,dstats
 s gstats=$ZU(190,6,1) ; glostat data
 if dskbase {
    s dstats=$ZU(190,6,2) ; diskstats data
    Set logrd=counts(7)
    For i=1:1:23 Set counts(i)=$p(gstats,",",i)-counts(i)/act
    For i=0:1:20 s dsknow(i)=$P(dstats,",",i+1)
    For i=0:3:18 s dsknow(i)=dsknow(i)+dsknow(i+1)
    For i=0:1:20 s dskcounts(i)=dsknow(i)-dskcounts(i)/act
    Set cntnow(7)=0 
    For i=0:3:18 Set cntnow(7)=cntnow(7)+dsknow(i)
    Set blqnow=0 For i=2:3:20 Set blqnow=blqnow+dsknow(i)
    Set counts(7)=cntnow(7)-logrd/act
    Set blq=blqnow-blq/act
 } else {
    For i=1:1:23 Set counts(i)=$p(gstats,",",i)-counts(i)/act
 }
 Set ecpstats=$system.ECP.GetProperty("ClientStats")
 Set ecpreads=$piece(ecpstats,",",2)-ecpreads/act
 Set ecpnotmods=$piece(ecpstats,",",1)-ecpnotmods/act
 Do show(1)
 Quit
get ;
 n stats
 s stats=$ZU(190,6,1) ;glostats
 For i=1:1:23 Set counts(i)=$P(stats,",",i)
 If dskbase {
   s stats=$ZU(190,6,2) ;diskstats
   For i=0:1:20 Set dskcounts(i)=$P(stats,",",i+1)
   For i=0:3:18 Set dskcounts(i)=dskcounts(i)+dskcounts(i+1)
   Set counts(7)=0 
   For i=0:3:18 Set counts(7)=counts(7)+dskcounts(i)
   Set blq=0 For i=2:3:20 Set blq=blq+dskcounts(i)
 }
 Set ecpstats=$system.ECP.GetProperty("ClientStats")
 Set ecpreads=$piece(ecpstats,",",2)
 Set ecpnotmods=$piece(ecpstats,",",1)
 Quit
show(dec) New bl,blrl,blrr,blrt,effl,effr,i,indl,indr,indt,n,u1,u2,long,xlf
 ;32-bit platforms and timed stats need less space
 Set bl=$S(dec!($ZU(40,0,76)=4):15,1:26)
 Set counts(23+1)=counts(1)+counts(2)
 Set counts(23+2)=counts(3)+counts(4)
 Set counts(23+3)=counts(5)+counts(6)
 Set counts(23+4)=counts(10)+counts(11)
 Set blrl=counts(8),blrr=ecpreads,blrt=blrl+blrr
 Set long=0
 For i=1:1:23+4 s:counts(i)>long long=counts(i)
 For i=blrr,blrt s:i>long long=i
 If $l(long)<12 s bl=15
 For i=1:1:23+4 Set l(i)=$$justify(counts(i),bl,dec)
 If dskbase Set blq=$$justify(blq,bl,dec) For i=0:1:20 Set dcount(i)=$$justify(dskcounts(i),bl,dec)
 Set n=counts(8)+counts(9)
 Set effl=$S(n:$$justify(counts(5)/n,bl,dec),1:$J("no i/o",bl))
 Set n=ecpnotmods
 Set effr=$S(n:$J(counts(6)-counts(11)/n,bl,0),1:$J("no gets",bl))
 Set blrl=$$justify(blrl,bl,dec),blrr=$$justify(blrr,bl,dec),blrt=$$justify(blrt,bl,dec)
 Set indt=79-bl,indr=indt-bl-2,indl=indr-bl-2 Set xlf=$s(client&(bl>15):1,1:0)
 Set u1="",u2="",$P(u1,"-",15)="",$P(u2,"-",10)=""
 Write "Statistics" Write:dec " (per second)"
 If xlf {
	 Write:client ?indl,$J("Local",bl-$l("Statistics")),?indr,$J("Remote",bl) Write ?indt,$J("Total",bl),!
	 Write u1 Write:client ?indl,$J(u2,bl-$l(u1)),?indr,$J(u2,bl) Write ?indt,$J(u2,bl),!
 } Else {
	 Write:client ?indl,$J("Local",bl),?indr,$J("Remote",bl) Write ?indt,$J("Total",bl),!
	 Write u1 Write:client ?indl,$J(u2,bl),?indr,$J(u2,bl) Write ?indt,$J(u2,bl),!
 }
 Write "Global references (all):" w:xlf ! Write:client ?indl,l(5),?indr,l(6) Write ?indt,l(23+3),!
 Write "Global update references:" w:xlf ! Write:client ?indl,l(10),?indr,l(11) Write ?indt,l(23+4),!
 Write "Private global references:" w:xlf ! Write:client ?indl,l(20),?indr,$J("n/a",bl) Write ?indt,l(20),!
 Write "Private update references:" w:xlf ! Write:client ?indl,l(21),?indr,$J("n/a",bl) Write ?indt,l(21),!
 Write "Routine calls:" w:xlf ! Write:client ?indl,l(1),?indr,l(2) Write ?indt,l(23+1),!
 Write "Routine buffer loads & saves:" w:xlf ! Write:client ?indl,l(3),?indr,l(4) Write ?indt,l(23+2),!
 Write "Routine commands:" w:xlf ! Write ?indt,l(12),!
 Write "Routine not cached:" w:xlf ! Write ?indt,l(14),!
 If 'detail {
   Write "Logical block requests:" w:xlf ! Write:client ?indl,l(7),?indr,$J("n/a",bl) Write ?indt,l(7),!
   Write "Block reads:" w:xlf ! Write:client ?indl,blrl,?indr,blrr Write ?indt,blrt,!
   Write "Block writes:" w:xlf ! Write:client ?indl,l(9),?indr,$J("n/a",bl)  Write ?indt,l(9),!
   Write "WIJ writes:" w:xlf ! Write:client ?indl,l(13),?indr,$J("n/a",bl)  Write ?indt,l(13),!
 }
 Write "Cache Efficiency:" w:xlf ! Write:client ?indl,effl,?indr,effr,! Write:'client ?indt,effl,!
 Write "Journal Entries:" w:xlf ! Write:client ?indl,l(22),?indr,$J("n/a",bl) Write ?indt,l(22),!
 Write "Journal Block Writes:" w:xlf ! Write:client ?indl,l(23),?indr,$J("n/a",bl) Write ?indt,l(23),!
 If detail {
   Set rc=$s(bl>15:38,1:30)
   Write "Logical Block Requests",?rc,"Data:      ",dcount(9),!
   Write ?3,"Dir:  ",dcount(0),?rc,"Upper ptr: ",dcount(3),!
   Write ?3,"BData:",dcount(12),?rc,"Bottom ptr:",dcount(6),!
   Write ?3,"Map:  ",dcount(15),?rc,"Other:     ",dcount(18)
   Write:bl>15 ! Write ?indt,l(7),!
   Write "Physical Block Reads",?rc,"Data:      ",dcount(10),!
   Write ?3,"Dir:  ",dcount(1),?rc,"Upper ptr: ",dcount(4),!
   Write ?3,"BData:",dcount(13),?rc,"Bottom ptr:",dcount(7),!
   Write ?3,"Map:  ",dcount(16),?rc,"Other:     ",dcount(19)
   Write:bl>15 ! Write ?indt,l(8),!
   Write "Database Physical Block Writes",?indt,l(9),!
   Write "WIJ Physical Block Writes",?indt,l(13),!
   Write "Blocks Queued to be Written",?rc,"Data:      ",dcount(11),!
   Write ?3,"Dir:  ",dcount(2),?rc,"Upper ptr: ",dcount(5),!
   Write ?3,"BData:",dcount(14),?rc,"Bottom ptr:",dcount(8),!
   Write ?3,"Map:  ",dcount(17),?rc,"Other:     ",dcount(20)
   Write:bl>15 ! Write ?indt,blq,!
   Write "Object cache",!
   Write ?3,"Hit:  ",l(15),!
   Write ?3,"Miss: ",l(16),!
   Write ?3,"Load: ",l(17),!
   Write "Object references (OREFs)",!
   Write ?3,"Newed:",l(18),!
   Write ?3,"Del:  ",l(19),!
 }
 Quit
 ;
justify(num,len,dec) Quit $S(num:$J($FN(num,",",dec),len),1:$J("0",len))
GUIstat() ;
 New
 Set dskbase=$ZU(40,2,86)
 Do get
 Set counts(23+1)=counts(1)+counts(2)
 Set counts(23+2)=counts(3)+counts(4)
 Set counts(23+3)=counts(5)+counts(6)
 Set counts(23+4)=counts(10)+counts(11)
 Set blrl=counts(8),blrr=ecpreads,blrt=blrl+blrr
 Set del1="^",del2=";"
 Set ret=counts(5)_del2_counts(6)_del2_counts(23+3)_del1
 Set ret=ret_counts(10)_del2_counts(11)_del2_counts(23+4)_del1
 Set ret=ret_counts(1)_del2_counts(2)_del2_counts(23+1)_del1
 Set ret=ret_counts(3)_del2_counts(4)_del2_counts(23+2)_del1
 Set ret=ret_counts(7)_del2_"---"_del2_counts(7)_del1
 Set ret=ret_blrl_del2_blrr_del2_blrt_del1
 Set ret=ret_counts(9)_del2_"---"_del2_counts(9)_del1
 Set ret=ret_counts(13)_del2_"---"_del2_counts(13)_del1
 Set ret=ret_counts(22)_del2_"---"_del2_counts(22)_del1
 Set ret=ret_counts(23)_del2_"---"_del2_counts(23)_del1
 Set ret=ret_counts(12)_del2_"---"_del2_counts(12)_del1
 Set ret=ret_counts(14)_del2_"---"_del2_counts(14)_del1
 Quit ret
glostat(sel) ;
 n (sel)
 Set lines=0,d=$$del2^%Wprim
 Set base=$ZU(40,2,47)
 Set maxpid=$v($zu(40,2,118),-2,4)
 Set sw10='$SYSTEM.Util.CheckSwitch(10),sw10pid=""
 For i=1:1:maxpid-1 Set pid=$View($View($ZU(40,2,47)+((i\$zu(40,0,102))*$zu(40,0,25)),-2,$zu(40,0,25))+((i#$zu(40,0,102))*$s($ZBITGET($ZVERSION(0),40):$zu(40,28,79)*2,1:4)),-2,4) If pid Set lines=lines+$p($$getinfo^JOBEXAM(i,pid,-1,sw10),d,6)
 Set data=$$GUIstat,sel=$g(sel,2)+1
 Set ret=$P($h,",",2)_";9,1"                 ;time of day in seconds;# metrics,# special metrics (cache efficiency)
 Set ret=ret_";10238;"_$p($p(data,"^",4),";",sel)            ;routine loads and save
 Set ret=ret_";10244;"_$p($p(data,"^",1),";",sel)            ;global references
 Set ret=ret_";10247;"_$p($p(data,"^",2),";",sel)            ;global sets and kills
 Set ret=ret_";10239;"_$p($p(data,"^",5),";",sel)            ;logical block reads
 Set ret=ret_";10240;"_$p($p(data,"^",6),";",sel)            ;physical block reads
 Set ret=ret_";10241;"_$p($p(data,"^",7),";",sel)            ;block writes
 Set ret=ret_";10242;"_$p($p(data,"^",8),";",sel)              ;journal entries
 Set ret=ret_";10243;"_$p($p(data,"^",9),";",sel)             ;journal writes
 Set ret=ret_";2063;"_$p(lines_";---;"_lines,";",sel)          ;+each pid
 Set ret=ret_";10155;5|6|2"             ;cache efficiency (6+7/3)
 Quit ret        

INTEGRIT^INT^1^67214,47330
INTEGRIT ; DATABASE INTEGRITY CHECKER
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 If $zbitget($zversion(0),21) g ^Integrity
ALL(x) If $zbitget($zversion(0),21) d Silent^Integrity(x) q

Integrity^INT^1^67214,47330
Integrity ; Integrity Checker.
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
    Set $zt="errDM"
    New %A,%ANS,%I,%UI,DEND,DIRNAM,EVERY,GD,IO,IOBS,IOF,IOM,IOPAR,IOSL,IOST,
	IOT,MSYS,POP,R2,RMSDF,GLOBAL,IO,a,all,glo,glolist,mtemp1,rc,%UI,seldbs,ABORT,
	GLOALL,MULTIPLE,IOMS,%objlasterror,DIRSTAT,errs
    Set MULTIPLE=0,EVERY=0
    Set IOMS=$System.Device.GetRightMargin()
Start ;
    If '$SYSTEM.Security.Check("%Admin_Operate","USE") {
	Write !,"Operation requires %Admin_Operate:Use privilege"
	Quit
    }
    New %TIM,%startdirtime,datasize,dirbigblks,dirbigbytes,
	dirbigstrings,dirpntblks,dirpntbytes,dirtotblks,dirtotbytes,
	errdirtotal,errmaxpersys,errorreturn,errsystotal,globigblks,
	globigbytes,globigstrings,glopntblks,glopntbytes,glototblks,
	glototbytes,i,x,direrrors,freecount,baddir,errsum
    Set %UI="CHUI",ABORT=0
    If '$g(MULTIPLE) {
	Set seldbs=0,EVERY=0,GLOALL=0
	Write !,"This utility is used to check the integrity of a database",
	      !,"and the pointer structure of one or more globals.",
	      !!,"Output results on "
	Do OUT^%IS
	Quit:POP'=0
    }
    If $I'=IO {
	Use IO
	Write "Intersystems IRIS Database Integrity Check on "_$ZD($H,-1)_" at "_$zt($p($h,",",2),-1),
	      !,"System: "_$zu(110)_"  Configuration: "_$p($zu(86),"*",2),!,$ZV,!!
	Use 0
    }
    Read !,"Stop after any error?"
    Do NY
    Set errmaxpersys=$S($t:1,1:1000)
    Set errsystotal=0 ; start with no errors for the system
    If $g(MULTIPLE) { Set DIRNAM="" Goto EV0 }
    Read !,"Do you want to check all databases?"
    Do NY
    Write !
    Goto:$t EVERY
UCI Use 0 
    Do ASK^%SYS.FILE 
    Goto DONE1:(DIRNAM=""!($G(%A)="")) 
    Do UC1
    Set errsystotal=0
    Kill errsum ;tracks last MaxSumErrCnt errors
    Goto UCI
UC1 Set $Ztrap="errDM"
    If '$SYSTEM.Security.Check("%Admin_Operate","USE") {
	Do msgout($c(13,10)_"Operation requires %Admin_Operate:Use privilege")
	Quit
    }
    Do msgout($c(13,10)_"---Directory "_DIRNAM_"---"_$c(13,10))
    Set errdirtotal=0
    Set rc=$$GetDirGlobalsINTEG^%SYS.DATABASE(DIRNAM,.glolist,.errs)
    For i=1:1:errs {
	Set errsystotal=$Get(errsystotal)+1
	Set errdirtotal=$Get(errdirtotal)+1
	Do ReportError(DIRNAM,errs(i),IO)
    }
    If ('+rc) {
	Set errsystotal=$Get(errsystotal)+1
	Do ReportError(DIRNAM,rc,IO)
	Quit
    }
    If '$d(glolist) {
       Do msgout($c(13,10,13,10)_"No globals in this directory"_$c(13,10))
       Quit
    }
    If EVERY!GLOALL { Do allglo Quit }
    Use 0
    Read !,"All globals?"
    Do NY
    Write !
    If $t { Do allglo } Else { Do single }
    Quit
errDM ;
    Set $zt=""
    Do msgout($c(13,10)_"Error "_$ZE_$c(13,10))
    If $i'=IO { Use 0 Write !,"Error "_$ZE }
    Quit
allglo ;
    If '$SYSTEM.Security.Check("%Admin_Operate","USE") {
	Write !,"Operation requires %Admin_Operate:Use privilege"
	Quit
    }
    New dirinfo,bigdb,errorLogged
    Set dirinfo=$zu(49,DIRNAM)
    Set bigdb=$Piece(dirinfo,",",21)
    If 'bigdb {
	Write !,"2K databases no longer supported"
	Quit
    }
    Set %startdirtime=$zh
    Set rc=$$CheckFreeCount^%SYS.DATABASE(DIRNAM,.freecount)
    If ('+rc) {
	Set errsystotal=$Get(errsystotal)+1
	Set errdirtotal=$Get(errdirtotal)+1
	Do ReportError(DIRNAM,rc,IO)
    }
    Set rc=$$CheckMaps^%SYS.DATABASE(DIRNAM)
    If ('+rc) {
        Set errsystotal=$Get(errsystotal)+1,
	    errdirtotal=$Get(errdirtotal)+1
	Do ReportError(DIRNAM,rc,IO)
    }
    Set rc=$$CheckMIB^%SYS.DATABASE(DIRNAM)
    If ('+rc) {
        Set errsystotal=$Get(errsystotal)+1,
	    errdirtotal=$Get(errdirtotal)+1
	Do ReportError(DIRNAM,rc,IO)
    }
    Set errorreturn=0,
	dirpntbytes=0,
	dirtotbytes=0,
	dirpntblks=0,
	dirtotblks=0,
	dirbigbytes=0,
	dirbigblks=0,
	dirbigstrings=0
    Set errmaxpersys=$Get(errmaxpersys,1000)
    Set glo=""
    For {
	Set glo=$o(glolist(glo))
	Quit:glo=""
	Do msgout($C(13,10)_"Global: "_glo)
	Set rc=$$CheckIntegrity^%SYS.DATABASE(1,0,DIRNAM,,100,glo,.glolist,dirinfo,
		.glototblks,.glopntblks,.glototbytes,
		.glopntbytes,.globigblks,.globigbytes,.globigstrings,.datasize,1)
	Do ShowMessage(rc,IO)
	If ('+rc) {
	    Do RecordError(DIRNAM,rc)
	    Write:%UI="CHUI" *7,*7
	    Do msgout($C(13,10))
	    Set errdirtotal=errdirtotal+1,
		errsystotal=errsystotal+1
	    Set:errdirtotal'<500 errorreturn="abortdir"
	    Set:errsystotal'<errmaxpersys errorreturn="abortsys"
	}
	Set dirtotblks=dirtotblks+glototblks,
	    dirtotbytes=dirtotbytes+glototbytes,
	    dirpntblks=dirpntblks+glopntblks,
	    dirpntbytes=dirpntbytes+glopntbytes,
	    dirbigblks=dirbigblks+globigblks,
	    dirbigbytes=dirbigbytes+globigbytes,
	    dirbigstrings=dirbigstrings+globigstrings
	Quit:$g(errorreturn)="abortdir"
	Quit:$g(errorreturn)="abortsys"
    }
    Set:$g(errdirtotal)>0 direrrors(DIRNAM)=""
    Do:dirtotblks msgout($C(13,10)_"---Total for directory "_DIRNAM_"---"_$C(13,10)),writedirtotals
    Quit
single ;
    New errorLogged
    For {
	Use 0
	Read !,"Global: ^",glo,!
	Quit:glo=""
	If glo="?" {
	    Write ! Do listglo
	} ElseIf '$d(glolist(glo)) {
	    Write "Global does not exist",!
	} Else {
	    Do single1
	}
    }
    Quit
single1 ;
    Set rc=$$CheckIntegrity^%SYS.DATABASE(1,0,DIRNAM,,100,
		glo,.glolist,$zu(49,DIRNAM),
		.glototblks,.glopntblks,.glototbytes,.glopntbytes,
		.globigblks,.globigbytes,.globigstrings,.datasize)
    If ('+rc) {
	Use IO
	Write *7,*7,!
	Set errsystotal=$Get(errsystotal)+1,
	    errdirtotal=$Get(errdirtotal)+1
	Set direrrors(DIRNAM)=""
	Do RecordError(DIRNAM,rc)
    }
    If %UI="CHUI",IO'=$IO { Use IO Write !,"Global: ",glo,! }
    Do ShowMessage(rc,IO)
    Quit
listglo ;
    Set glo=""
    For {
	Set glo=$o(glolist(glo))
	Quit:glo=""
	Write glo
	If $x>60 { Write ! } Else { Write ?$x+11\12*12 }
    }
    Write !
    Quit
EVERY ;
    Use:%UI="CHUI" IO
    Set DIRNAM="",EVERY=1
    Kill direrrors
EV0 ;
    For {
	If seldbs {
	    Set PIECE=PIECE+1,DIRNAM=$P(SVDIRNAM,",",PIECE)
	} Else {
	    Set DIRNAM=$$GetNextDatabaseByUCI^%SYS.CONFIG(DIRNAM)
	}
	Quit:DIRNAM=""
	If %UI="CHUI",EVERY,($i'=IO) {
	    Use 0
	    Write !,"Checking "_DIRNAM_" at "_$zt($p($h,",",2),-1)
	}
	Set %A=DIRNAM
	Set DIRSTAT=$P($ZU(49,DIRNAM),",")
	If DIRSTAT<0 { Do ERR1 Continue }
	Do FILE
	Do:%A'="" UC1
	If ($g(errorreturn)="abortsys")||($ze["<ZAbor") {
	   Set ABORT=1
	   Quit
	}
    }
    Goto DONE
FILE ;
    Set $ZT="NOFILE^"_$ZN
    Goto INT^%SYS.FILE ; %FILE quits back to EV0
NOFILE ;
    Set %A=""
    Quit
ERR ;
    Set:$ZE?1"<ZAbor".E ABORT=1
DONE Close 63
    If %UI="GUI" {
	Do:'ABORT msgout($C(13,10)_"Integrity Check Completed at "_$zdt($h,-1))
	If $$IjcMsg^%Wprima("JS")
    }
    If errsystotal {
	Do msgout($c(13,10)_"*****ERRORS WERE FOUND *****"_$c(13,10))
	Set errsum=$G(errsum,0)  ;really should be defined by now
	If errsum>100 {
	    Do msgout($c(13,10)_"***** "_(100-errsum)_" overflowed the summary. See the report for the full list of errors *****")
	} ElseIf errsum {
	    Do msgout($c(13,10)_"***** The following errors were detected *****")
	}
	Set DIRNAM=""
	Set i=$O(errsum(""))
	While (i'="") {
	    If DIRNAM'=errsum(i,1) {
		Set DIRNAM=errsum(i,1)
		Kill direrrors(DIRNAM)
		Do msgout($C(13,10,10)_"************************************************")
		Do msgout($C(13,10)_"*** Errors in directory: "_DIRNAM_" ***")
		Do msgout($C(13,10)_"************************************************")
	    }
	    Do ShowMessage(errsum(i,2),IO)
	    Set i=$O(errsum(i))
	}
	If $D(direrrors) {
	    Do msgout($C(13,10,10)_"**** The following directories had errors not reported in the above summary ****")
	    Set baddir=$O(direrrors(""))
	    While (baddir'=""){
		Do msgout($c(13,10)_"Errors were found in directory "_baddir)
		Set baddir=$Order(direrrors(baddir)) 
	    }
	}
    }
    Do:'errsystotal msgout($c(13,10)_"No Errors were found."_$c(13,10))
    Do:$g(errorreturn)="abortdir" msgout($c(13,10)_"*****Checking was aborted because of too many errors ("_errdirtotal_") in directory "_DIRNAM)
    Do:$g(errorreturn)="abortsys" msgout($c(13,10)_"*****Checking was aborted because of too many errors ("_errsystotal_") on this system.")
DONE1 ;
	u 0
    If %UI="CHUI" {
	If $I'=IO {
	    Close IO
	} ElseIf $D(IOMS)=1 {
	    Use IO:/MAR=IOMS
	}
    }
    Quit
msgout(mess) [IO] { Do wrtmsg(mess,IO) }
NY  New X,A
    Set X=$X
NYQ Read "  No=> ",A
    Set A=$f("NnYy",$e(A))
    If 'A { Write !?X Goto NYQ }
    Set $T=(A'<4)
    Quit
writedirtotals ;
    New bytes,blksize,kb,mb
    Set blksize=$Piece(dirinfo,",",2)
    Do writesub("Pointer Level",dirpntblks,dirpntbytes,0)
    Do writesub("Data Level",dirtotblks-dirpntblks-dirbigblks,dirtotbytes-dirpntbytes-dirbigbytes,0)
    Do writesub("Big String",dirbigblks,dirbigbytes,1)
    Do writesub("Total",dirtotblks+$$getadditionalblocks(dirinfo,DIRNAM),dirtotbytes,0)
    Set kb=freecount*blksize\1024,mb=0
    Set:kb>10240 kb=kb\1024,mb=1
    Set a=$fn(freecount,","),a=$j("",10-$l(a))_a_" Free blocks"
    Set a=a_$j("",43),a=$e(a,1,43-$l(kb))_kb_$s(mb:"MB",1:"kb")
    Do msgout(a_$c(13,10))
    Do msgout($C(13,10)_"Elapsed time = "_$fn(($zh-%startdirtime),"",1)_" seconds "_$zdt($h,-1)_$C(13,10))
    If errdirtotal {
	Set errsum=$G(errsum,0)
	If errsum>100 {
	    Do msgout($c(13,10)_"***** "_(100-errsum)_" overflowed the summary. See the report for the full list of errors *****")
	} ElseIf errsum {
	    Do msgout($c(13,10)_"***** The following errors were detected *****")
	}
	Set i=$O(errsum(""))
	While (i'="") {
	    Set DIRNAM=errsum(i,1)
	    Kill direrrors(DIRNAM)
	    Do ShowMessage(errsum(i,2),IO)
	    Set i=$O(errsum(i))
	}
	Do:$D(direrrors) msgout("  *** "_errdirtotal_" ERROR"_$case(errdirtotal,1:"",:"S")_" ***")
    } Else {
	Do msgout($c(13,10)_"No Errors were found in this directory."_$c(13,10,13,10))
    }
    Quit
writesub(message,blks,bytes,bigflag) [datasize,blksize,dirbigstrings] PRIVATE {;
    Set a=$fn(blks,","),a=$j("",10-$l(a))_a_" "_message_" blocks"
    If blks {
	Set kb=blks*(blksize\1024),mb=0 ;s kb=bytes\1024
	Set:kb>10240 kb=kb\1024,mb=1
	Set a=a_$j("",43),a=$e(a,1,43-$l(kb))_kb_$s(mb:"MB",1:"kb")
	Set:blks a=a_" ("_(bytes\blks*100\datasize)_"% full)"
	If bigflag,dirbigstrings { Set a=a_" # = "_$fn(dirbigstrings,",") }
    }
    Do msgout(a_$C(13,10))
}
CheckPointer ;
    New %A,DEND,DIRNAM,GD,blk,errmaxperglobal,errmaxpersys,errsystotal,mtemp1,
	numblks,rc,x
    Do ASK^%SYS.FILE
    Quit:DIRNAM=""
    Open 63:("^^"_DIRNAM)
    Set errmaxperglobal=100
    Read !,"Stop after any error?"
    Do NY
    Set errmaxpersys=$S($T:1,1:1000)
    For {
	Read !!,"Pointer Block: ",blk,!
	Quit:blk=""
	Read "# pointer blocks to process: ",numblks,! q:numblks="stop"
	Set numblks=+numblks
	Set rc=$$CheckPointerIntegrity^%SYS.DATABASE(DIRNAM,blk,errmaxperglobal,numblks)
	Do ShowMessage(rc,$Get(IO,0))
	Do:('rc) RecordError(DIRNAM,rc)
    }
    Close 63
    Quit
getadditionalblocks(dirinfo,dirforgdircnt="") [] PRIVATE {
	Set bigdb=$Piece(dirinfo,",",21)
	Set nummaps=$p(dirinfo,",",24)
	Set contig=$Case(bigdb,0:0,1:16,2:8,3:4,4:2,5:1)
	Set maxsat=$Case(bigdb,1:5,2:2,3:1,4:1,5:1)
	Set addblks=2 ; for blocks 1 and 2
	If (dirforgdircnt'="") {
		Set glodirs=1
		Open 63:"^^"_dirforgdircnt
		Set gdir=3
		For {
			Try { View gdir } Catch { set readerr=1 }
			Quit:$get(readerr)
			Set gdirblks(gdir)=""
			Set gdir=$v($Zutil(40,32,4),0,4)
			If ('gdir) || $data(gdirblks(gdir)) Quit
			Set glodirs=glodirs+1
		}
		Set addblks=addblks+glodirs
	}
	For map=1:1:nummaps {
		If map=1 {
	    	Set addblks=addblks+12
		} ElseIf map=2 {
	    	Set addblks=addblks+($case(contig,1:1,:(contig-1))*6)+((maxsat-1)*6)
		} ElseIf map#contig=1 {
	    	Set addblks=addblks+(contig*6)
		}
    }
    Quit addblks
}
guiInteg(index) ;
    Set $zt="ERR1"
    Set %UI="GUI",ABORT=0,IO=$I
    Quit:'$$IjcOpen^%Wprima("Job")
    If $$IjcMsg^%Wprima("PD"_$J) ; Send a PID message to Message2
    Set parm=^IRIS.Temp(index)
    Set EVERY=$p(parm,";",1)
    Set DIRNAM=$p(parm,";",2)
    Set GLOALL=$P(parm,";",3)
    Set errsystotal=0 ; start with no errors for the system
    Set seldbs=0 i GLOALL,'EVERY s seldbs=1
    Do msgout("Intersystems IRIS Database Integrity Check on "_$ZD($H,-1)_" at "_$zt($p($h,",",2),-1)_$c(13,10))
    Do msgout("System: "_$zu(110)_"  Configuration: "_$p($zu(86),"*",2)_$c(13,10))
    Do msgout($zv_$c(13,10,13,10))
    Goto EVERY:EVERY ; All databases
SELDBS ; Selected multiple databases entry point
    New SVDIRNAM,PIECE
    Set SVDIRNAM=DIRNAM
    Set PIECE=0
    Goto EV0
Exclude ;
    If '$SYSTEM.Security.Check("%Admin_Operate","USE") {
	Write !,"Operation requires %Admin_Operate:Use privilege"
	Quit
    }
    New %A,%ANS,%I,%UI,DEND,DIRNAM,EVERY,GD,IO,IOBS,IOF,IOM,IOPAR,IOSL,IOST,
	IOT,MSYS,POP,R2,RMSDF,GLOBAL,IO,a,all,glo,glolist,mtemp1,rc,%UI,seldbs,ABORT,
	GLOALL,ans,di,dir,%UTILITY,DIRSTAT,MULTIPLE,PIECE,SVDIRNAM,IOMS
    Set MULTIPLE=1,seldbs=1,EVERY=0,GLOALL=1,PIECE=0
    Set IOMS=$System.Device.GetRightMargin()
    Write !,"Output results on "
    Do OUT^%IS
    Quit:POP'=0
    Write !,"Enter databases to exclude"
    Do ^DSET
    If '%UTILITY {
        Set seldbs=0,EVERY=1
	Goto Start
    }
    Set dir="",SVDIRNAM=""
   For {
	Set dir=$$GetNextDatabaseByUCI^%SYS.CONFIG(dir)
	Quit:dir=""
	Continue:$d(%UTILITY(dir))
	Set SVDIRNAM=SVDIRNAM_","_dir
    }
    Set:$e(SVDIRNAM)="," SVDIRNAM=$e(SVDIRNAM,2,*)
    Goto Start
Multiple ;
    If '$SYSTEM.Security.Check("%Admin_Operate","USE") {
	Write !,"Operation requires %Admin_Operate:Use privilege"
	Quit
    }
    New %A,%ANS,%I,%UI,DEND,DIRNAM,EVERY,GD,IO,IOBS,IOF,IOM,IOPAR,IOSL,IOST,
	IOT,MSYS,POP,R2,RMSDF,GLOBAL,IO,a,all,glo,glolist,mtemp1,rc,%UI,seldbs,ABORT,
	GLOALL,ans,di,dir,%UTILITY,DIRSTAT,MULTIPLE,PIECE,SVDIRNAM,IOMS
    Set MULTIPLE=1,seldbs=1,EVERY=0,GLOALL=0,PIECE=0
    Set IOMS=$System.Device.GetRightMargin()
    Write !,"Output results on "
    Do OUT^%IS
    Quit:POP'=0
    Read !,"Check all databases? Yes => ",ans
    If "Yy"[$e(ans) {
	Set seldbs=0,EVERY=1,GLOALL=1
	Goto Start
    }
    Do ^DSET
    Quit:%UTILITY=0
    Set dir="",SVDIRNAM=""
    For di=1:1:%UTILITY {
	Set dir=$O(%UTILITY(dir))
	Quit:dir=""
	Set SVDIRNAM=SVDIRNAM_","_dir
    }
    Set:$e(SVDIRNAM)="," SVDIRNAM=$e(SVDIRNAM,2,*)
    Set GLOALL=(%UTILITY'=1)
    Goto Start
ERR1 ;
    Set $zt=""
    If $ZE?1"<ZAbor".E {
	Set ABORT=1
	Goto DONE
    }
    If $g(DIRSTAT)=-1 {
	Do msgout($C(13,10)_"***** "_DIRNAM_" is dismounted *****"_$C(13,10))
	Quit
    }
    Set errsystotal=$g(errsystotal)+1,direrrors(DIRNAM)=""
    If $g(DIRSTAT)=-2 {
	Do msgout($C(13,10)_"***** "_DIRNAM_" does not exist *****"_$C(13,10))
    } ElseIf $ZE'="" {
	Do msgout($C(13,10)_"***** "_$ZE_" *****"_$C(13,10))
    }
    Quit
SilentGlobalCheck(filename,dir,gbllist,StopAfterAnyError) ;
    If '$SYSTEM.Security.Check("%Admin_Operate","USE") {
	Quit $$Error^%apiOBJ(921,"%Admin_Operate"_":"_"USE")
    }
    Quit:$g(gbllist)="" $$Error^%apiOBJ(52)
    Open filename:"WNS":3
    Quit:'$T $$Error^%apiOBJ(76)
    Close filename
    Kill ^IRIS.Temp("SilentIntegrityCheck",+$J)
    Job BackGlobalCheck^Integrity(filename,dir,gbllist,+$J,$g(StopAfterAnyError))::30
    Quit:'$T $$Error^%apiOBJ(205)
    While '$d(^IRIS.Temp("SilentIntegrityCheck",+$J)) { Hang 1 }
    Quit:^IRIS.Temp("SilentIntegrityCheck",+$J)=0 $$Error^%apiOBJ(76)
    Quit 1
BackGlobalCheck(filename,DIRNAM,gbllist,pid,StopAfterAnyError) ;
    Set:$G(pid)="" pid=+$J
    Set StopAfterAnyError=+$g(StopAfterAnyError)
    If '$SYSTEM.Security.Check("%Admin_Operate","USE") {
	Set IO=-1
	Do msgout("Operation requires %Admin_Operate:Use privilege")
	Set ^IRIS.Temp("SilentIntegrityCheck",pid)=0
	Quit
    }
    New (filename,DIRNAM,gbllist,pid)
    Set $Ztrap="errBackG"
    Set %UI="CHUI"
    Lock +^IRIS.Temp("SilentIntegrityCheck",pid)
    Open filename:"WNS":3
    If '$T {
	Set ^IRIS.Temp("SilentIntegrityCheck",pid)=0
	Set IO=-1
	Do msgout("Back^Integrity failed to open file "_filename)
 	Lock -^IRIS.Temp("SilentIntegrityCheck",pid)
 	Quit
    }
    Set ^IRIS.Temp("SilentIntegrityCheck",pid)=1
    Set IO=filename
    Do msgout("Intersystems IRIS Database Integrity Check on "_$ZD($H,-1)_" at "_$zt($p($h,",",2),-1)_$c(13,10))
    Do msgout("System: "_$zu(110)_"  Configuration: "_$p($zu(86),"*",2)_$c(13,10))
    Do msgout($zv_$c(13,10,13,10))
    Set errsystotal=0 ; start with no errors for the system
    Set errmaxpersys=$s($g(StopAfterAnyError):1,1:1000)
    For gindex=1:1:$listlength(gbllist) {
	Set glo=$li(gbllist,gindex)
	Set:$e(glo)="^" glo=$e(glo,2,*)
	Do msgout($c(13,10)_"Global: ^"_glo_$c(13,10))
	Do single1
    }
    If errsystotal {
	Do msgout($c(13,10)_"*****ERRORS WERE FOUND *****"_$c(13,10))
	Set errsum=$G(errsum,0)  ;really should be defined by now
	If errsum>100 {
	    Do msgout($c(13,10)_"***** "_(100-errsum)_" overflowed the summary. See the report for the full list of errors *****")
	} ElseIf errsum {
	    Do msgout($c(13,10)_"***** The following errors were detected *****")
	}
	Set DIRNAM=""
	Set i=$O(errsum(""))
	While (i'="") {
	    If DIRNAM'=errsum(i,1) {
		Set DIRNAM=errsum(i,1)
		Kill direrrors(DIRNAM)
		Do msgout($C(13,10,10)_"************************************************")
		Do msgout($C(13,10)_"*** Errors in directory: "_DIRNAM_" ***")
		Do msgout($C(13,10)_"************************************************")
	    }
	    Do ShowMessage(errsum(i,2),IO)
	    Set i=$O(errsum(i))
	}
	If $D(direrrors) {
	    Do msgout($C(13,10,10)_"**** The following directories had errors not reported in the above summary ****")
	    Set baddir=$O(direrrors(""))
	    While (baddir'=""){
		Do msgout($c(13,10)_"Errors were found in directory "_baddir)
		Set baddir=$Order(direrrors(baddir))
	    }
	}
    } Else {
	Do msgout($c(13,10)_"No Errors were found."_$c(13,10))
    }
errBackG
    Set $zt=""
    Close IO
    Lock -^IRIS.Temp("SilentIntegrityCheck",pid)
    Quit  
Silent(filename,dirlist,StopAfterAnyError)
    Quit:'$SYSTEM.Security.Check("%Admin_Operate","USE") $$Error^%apiOBJ(921,"%Admin_Operate"_":"_"USE")
    Open filename:"WNS":3
    Quit:'$T $$Error^%apiOBJ(76)
    Close filename
    Kill ^IRIS.Temp("SilentIntegrityCheck",+$J)
    Job Back^Integrity(filename,$g(dirlist),+$J,$g(StopAfterAnyError))::30
    If '$Test Quit $$Error^%apiOBJ(205)
    For  Quit:$d(^IRIS.Temp("SilentIntegrityCheck",+$J))  Hang 1
    Quit:^IRIS.Temp("SilentIntegrityCheck",+$J)=0 $$Error^%apiOBJ(76)
    Quit 1
Back(filename,dirlist,pid,StopAfterAnyError)
    Set:$G(pid)="" pid=+$J  ;Use $J if pid argument is omitted or passed as null
    i '$SYSTEM.Security.Check("%Admin_Operate","USE") s IO=-1 d msgout("Operation requires %Admin_Operate:Use privilege") s ^IRIS.Temp("SilentIntegrityCheck",pid)=0 q
    New (filename,dirlist,pid)
    Set $Ztrap="errBack"
    Set %UI="CHUI"
    Lock +^IRIS.Temp("SilentIntegrityCheck",pid)
    Open filename:"WNS":3
    If $T {
 	s ^IRIS.Temp("SilentIntegrityCheck",pid)=1
    } Else {
 	s ^IRIS.Temp("SilentIntegrityCheck",pid)=0
 	s IO=-1 d msgout("Back^Integrity failed to open file "_filename)
 	Lock -^IRIS.Temp("SilentIntegrityCheck",pid)
 	Quit
    }
    Set GLOALL=1,EVERY=($g(dirlist)="")
    Set errsystotal=0 ; start with no errors for the system
    Set errmaxpersys=$s($g(StopAfterAnyError):1,1:1000)
    Set seldbs=0
    Set silent=1
    Set IO=filename
    Do msgout("Intersystems IRIS Database Integrity Check on "_$ZD($H,-1)_" at "_$zt($p($h,",",2),-1)_$c(13,10))
    Do msgout("System: "_$zu(110)_"  Configuration: "_$p($zu(86),"*",2)_$c(13,10))
    Do msgout($zv_$c(13,10,13,10))
    If EVERY Do EVERY Goto errBack
    Set DIRNAM=""
    For idir=1:1:$ll(dirlist) s DIRNAM=$li(dirlist,idir) Do UC1
errBack
    Set $zt=""
    Close IO
    Lock -^IRIS.Temp("SilentIntegrityCheck",pid)
    Quit  
CheckList(outputglo,dirlist="",StopAfterAnyError,listofglolist="",maxproc,partialcheck=0) [] PUBLIC {
	New %exit,%queuedcnt,%donecnt,%globals,%errors,%globalscomplete,%weightedtotal,%weightedcomplete
	Set (%globals,%errors,%globalscomplete,%weightedtotal,%weightedcomplete)=0
	Quit:'$SYSTEM.Security.Check("%Admin_Operate","USE") $$Error^%apiOBJ(921,"%Admin_Operate"_":"_"USE")
	If $g(outputglo)="" {
		Set outputglo=$name(^IRIS.TempIntegrityOutput(+$J))
		Kill @outputglo
    }
	Set sc=1
	Set listofglolist=$g(listofglolist),listlen=$ll(listofglolist)
	If $g(dirlist)="" {
		Set dir="",dirlist=""
		For {
			Set dir=$$GetNextDatabaseByUCI^%SYS.CONFIG(dir) Quit:dir=""
			Set dirlist=dirlist_$lb(dir)
		}
	} Else {								; SJ2720+
		// Eliminate duplicate datasets, combine global lists if duplicate
		Set num=$ll(dirlist)
		Set outlist="",lglolist=""
		For i=1:1:num {
			Set dir=##class(%Library.File).NormalizeDirectory($lg(dirlist,i))
			If '$d(dir(dir),pos) {
				Set outlist=outlist_$lb(dir)
				Set:i'>listlen lglolist=lglolist_$li(listofglolist,i,i)
				Set dir(dir)=i
			} ElseIf i'>listlen {
				Set $li(lglolist,pos)=$lg(lglolist,pos)_$lg(listofglolist,i)
			}
		}
		Set listofglolist=lglolist,dirlist=outlist			; SJ2720-
	}
	Set num=$ll(dirlist)
	If 'partialcheck {
		Try { Set:$Get(^%SYS("Integrity","RangeDisabled")) partialcheck=-1 } Catch {}
	}
	Set maxproc=+$g(maxproc)
	Set cores=$system.Util.NumberOfCPUs()
	Set:maxproc<1 maxproc=$$GetNumJobs()
	Set:maxproc>cores maxproc=cores
	//Set bgutil=($system.BGUtil.GetInfo()'="")
	Try {
		If (maxproc=1) && 'partialcheck {
			For i=1:1:num {
				Set tmpsc=$$CheckDirIntegrity^%SYS.DATABASE($li(dirlist,i),outputglo,,,$Select($G(StopAfterAnyError):1,1:500),$lg(listofglolist,$s(i>listlen:listlen,1:i)))
				If ('tmpsc) {
					If $system.Status.GetErrorCodes(tmpsc)=267 {
						Set integcheckerror=1 
					} Else { 
						Set sc=$select(+sc:tmpsc,1:$$AppendStatus^%occSystem(sc,tmpsc))
					}
					ZT:$Get(StopAfterAnyError) "ABOR"
				}
			}
			Quit
		}
		Set queue=$system.WorkMgr.Initialize(,.sc,maxproc) 
		Quit:('sc)
		For dirlistelenum=1:1:num {
			Set dir=$List(dirlist,dirlistelenum)
			Kill @outputglo@(dir)
			Set dirinfo=$zu(49,dir)
			Set tmpsc=1
			If '$case($v($Piece(dirinfo,",",21)*$ZU(40,0,1)+$zu(40,2,128),-2,$ZU(40,0,1)),4294967295:0,:1) {
				Set tmpsc=$$Error^%apiOBJ(327,$Piece(dirinfo,",",2)\1024)
			} elseif +dirinfo<0 {
				Set tmpsc=$$Error^%apiOBJ($case(+dirinfo,-1:300,-2:6046,:314),dir)
			}
			If ('tmpsc) {
				Do addDirInfoToOutput(outputglo,dir,1,tmpsc)
				Set fatal(dir)=1
				Set sc=$select(+sc:tmpsc,1:$$AppendStatus^%occSystem(sc,tmpsc))
				Continue
			}
			Kill gloarray
			Set tmpsc=$$GetDirGlobalsINTEG^%SYS.DATABASE(dir,.gloarray,.errs,.numgdir)
			Set dirinfo=$zu(49,dir)  
			Set sfn=+$zu(49,dir)
			Set addblks=$$getadditionalblocks(dirinfo)
			If (sfn<0) || (sfn=$zu(40,0,41)) {
				Set fatal(dir)=1
				Set:(''tmpsc) tmpsc=$$Error^%apiOBJ(300,dir)
			} Else {
				If $d(dirarray(sfn)) {
					Set fatal(dir)=1
					Continue
				}
				Set dirarray(sfn)=$ListBuild(dir,dirinfo)
			}
			If ('tmpsc) {
				Do addDirInfoToOutput(outputglo,dir,1,tmpsc,,,,,,,,,,addblks,dirinfo,0,0)
				Set sc=$select(+sc:tmpsc,1:$$AppendStatus^%occSystem(sc,tmpsc))
				Continue
			}
			If errs {
				For i=1:1:errs { Do addDirInfoToOutput(outputglo,dir,1,errs(i)) }
				Set integcheckerror=1
			}
			Set globallist=$ListGet(listofglolist,$Select(dirlistelenum>listlen:listlen,1:dirlistelenum))
			If globallist'="" {
				Set numglo=$ListLength(globallist)
				For i=1:1:numglo {
					Set glo=$List(globallist,i)
					Set %globals(i,sfn)=$ListBuild(glo,gloarray(glo),i)
				}
			} Else {
				Set glo=""
				For i=1:1 { 
					Set glo=$Order(gloarray(glo)) Quit:glo=""  
					Set %globals(i,sfn)=$ListBuild(glo,gloarray(glo),i)
				}
				Set numglo=i-1
			}
			Set addblks=addblks+numgdir
			Do addDirInfoToOutput(outputglo,dir,0,,,,,,,,,,,addblks,dirinfo,numglo,0)
		}
		ZT:$Get(StopAfterAnyError)&&$Get(integcheckerror) "ABOR"
		Set %queuedcnt=0
		Set k="%globals"
		For {
			Set k=$Query(@k,1,gloinfo)
			Quit:k=""
			Set sfn=$QSubscript(k,2)
			Set $ListBuild(dir,dirinfo)=dirarray(sfn)
			Set tmpsc=queue.QueueCallback("$$CheckOneGlobal^Integrity",
			                              "$$CheckOneGlobalCallback^Integrity",
			                              outputglo,dir,dirinfo,gloinfo,partialcheck)
			If ('tmpsc) {
				Set sc=$select(+sc:tmpsc,1:$$AppendStatus^%occSystem(sc,tmpsc))
			} Else { 
				Set %queuedcnt=%queuedcnt+1
			}
		}
		Kill %globals
		Set %globals=%queuedcnt
		Set %weightedtotal=%queuedcnt + (num*4)
		Set %weightedcomplete=num*1
		//Do:bgutil postprogress
		For i=1:1:num {
			Set dir=$List(dirlist,i)
			Continue:$Data(fatal(dir))
			Set starttime=$ZH,direrrs=0,dirsc=1
			Set tmpsc=$$CheckFreeCount^%SYS.DATABASE(dir,.freecount)
			If ('tmpsc) { Set direrrs=direrrs+1,dirsc=$select(+dirsc:tmpsc,1:$$AppendStatus^%occSystem(dirsc,tmpsc)),integcheckerror=1 }
			Set tmpsc=$$CheckMaps^%SYS.DATABASE(dir)
			If ('tmpsc) { Set direrrs=direrrs+1,dirsc=$select(+dirsc:tmpsc,1:$$AppendStatus^%occSystem(dirsc,tmpsc)),integcheckerror=1 }
			Set tmpsc=$$CheckMIB^%SYS.DATABASE(dir)
			If ('tmpsc) { Set direrrs=direrrs+1,dirsc=$select(+dirsc:tmpsc,1:$$AppendStatus^%occSystem(dirsc,tmpsc)),integcheckerror=1 }
			Do addDirInfoToOutput(outputglo,dir,direrrs,dirsc,$ZH-starttime,freecount)
			Set %weightedcomplete=%weightedcomplete+3
			//Do:bgutil postprogress
		}
		ZT:$Get(StopAfterAnyError)&&$Get(integcheckerror) "ABOR"
		Set restrict=1,atend='%queuedcnt
		while ('atend) {
			Set tmpsc=queue.Wait(,.atend,2)
			If ('tmpsc) {
				If $system.Status.GetErrorCodes(tmpsc)=267 {
					Set integcheckerror=1 
				} Else { 
					Set sc=$select(+sc:tmpsc,1:$$AppendStatus^%occSystem(sc,tmpsc))
				}
				ZT:$Get(StopAfterAnyError) "ABOR"
			}
			//Do:bgutil postprogress ; check for pause/cancel if nothing else
			Continue:((%queuedcnt>queue.NumWorkers)||'$Data(%bigglobals))
			Set k=$Name(%bigglobals)
			While %queuedcnt<=(queue.NumWorkers*2) {
				Set k=$Query(@k,1,gloinfo)
				If k="" {
					Quit:'restrict
					Set restrict=0
					Set k=$Name(%bigglobals)
					Continue
				}
				Set sfn=$QSubscript(k,2)
				Set glo=$List(gloinfo,1)
				Continue:(restrict && ($Get(%queuedcnt(sfn,glo))>1))
				Set next=$ListGet(gloinfo,5)+1
				If next>$List(gloinfo,4) {
					Kill @k
					Continue
				}
				Set $List(gloinfo,5)=next,@k=gloinfo
				Set $ListBuild(dir,dirinfo)=dirarray(sfn)
				Set tmpsc=queue.QueueCallback("$$CheckOneRange^Integrity","$$CheckOneRangeCallback^Integrity",
				                              outputglo,$List(dirarray(sfn),1),$List(dirarray(sfn),2),gloinfo)
				If ('tmpsc) {
					Set sc=$select(+sc:tmpsc,1:$$AppendStatus^%occSystem(sc,tmpsc))
					Continue
				}
				Set %queuedcnt=%queuedcnt+1
				Set %queuedcnt(sfn,glo)=$Get(%queuedcnt(sfn,glo))+1
				Set atend=0
			}
		}
		ZT:%queuedcnt "QCNT"
	} catch err {
		If (err.Name="<ZABOR>") {
			Set errorreturn="abortsys"
		} Else {
			Set sc=$select(+sc:err.AsStatus(),1:$$AppendStatus^%occSystem(sc,err.AsStatus()))
		}
	}
	Try { Set @outputglo=$ListBuild("CheckList",sc,$Get(errorreturn),maxproc,partialcheck,listlen) }
	Catch err { Set sc=$select(+sc:err.AsStatus(),1:$$AppendStatus^%occSystem(sc,err.AsStatus())) }
	Set:$Get(integcheckerror) sc=$select(+sc:$$Error^%apiOBJ(267),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(267)))
	Quit sc
}
CheckOneGlobal(outputglo,dir,dirinfo,gloinfo,partialcheck) PUBLIC {
	Quit:$ListGet($Get(@outputglo@(dir)),5)'="" 1
	Set gloarray=dir
	Set glo=$List(gloinfo,1)
	Set:$ListData(gloinfo,2) gloarray(glo)=$List(gloinfo,2)
	Set sc=$$CheckIntegrity^%SYS.DATABASE($Select('partialcheck:"q",(partialcheck>0):"p",1:1),0,dir,,100,glo,.gloarray,dirinfo,
				.glototblks,.glopntblks,.glototbytes,.glopntbytes,.globigblks,.globigbytes,.globigstrings,.datasize,
				1,outputglo)
	Quit:(''sc) 1
	Quit:$Get(@outputglo@(dir,glo,"range"))&&($system.Status.GetErrorCodes(sc)=267) 1
	Quit sc
}
CheckOneGlobalCallback(outputglo,dir,dirinfo,gloinfo,partialcheck) PUBLIC {
	Set %exit=1
	Set %queuedcnt=%queuedcnt-1
	Set glo=$List(gloinfo,1)
	Set glodirindex=$List(gloinfo,3)
	Set howmany=$Get(@outputglo@(dir,glo,"range"))
	If howmany {
		Set sfn=+dirinfo
		Set %queuedcnt(sfn,glo)=0
		Set %bigglobals(glodirindex,sfn)=gloinfo_$ListBuild(howmany)
		Set %weightedtotal=%weightedtotal+howmany
	} Else {
		Do addDirInfoForGlo(outputglo,dir,glo,%status)
		Set %globalscomplete=%globalscomplete+1
	}
	Set %weightedcomplete=%weightedcomplete+1
	Quit 1
}
CheckOneRange(outputglo,dir,dirinfo,gloinfo) PUBLIC {
	Set gloarray=dir
	Set glo=$List(gloinfo,1)
	Set:$ListData(gloinfo,2) gloarray(glo)=$List(gloinfo,2)
	Set range=$List(gloinfo,5)
	Set sc=$$CheckIntegrity^%SYS.DATABASE("r",0,dir,range,100,glo,.gloarray,dirinfo,
				.glototblks,.glopntblks,.glototbytes,.glopntbytes,.globigblks,.globigbytes,.globigstrings,.datasize,
				1,outputglo)
	Quit:(''sc) 1
	Quit:$system.Status.GetErrorCodes(sc)=267 1
	Quit sc
}
CheckOneRangeCallback(outputglo,dir,dirinfo,gloinfo) PUBLIC {
	Set %exit=1
	Set sfn=+dirinfo
	Set glo=$List(gloinfo,1)
	Set %queuedcnt=%queuedcnt-1
	Set %queuedcnt(sfn,glo)=%queuedcnt(sfn,glo)-1
	Set %weightedcomplete=%weightedcomplete+1
	If $Increment(%donecnt(sfn,glo))=$List(gloinfo,4) {
		Set sc=$$CheckIntegrity^%SYS.DATABASE("a",,dir,,,glo,,dirinfo,,,,,,,,,1,outputglo)
		Do addDirInfoForGlo(outputglo,dir,glo,sc)
		Set %globalscomplete=%globalscomplete+1
		Quit sc
	}
	Quit 1
}
addDirInfoToOutput(outputglo,dir,numerrors,sc,elapsed,freecount,totblks,totbytes,pntblks,pntbytes,bigblks,bigbytes,bigstrings,addblks,newdirinfo,numglo,numglodone) PRIVATE {
	Set $ListBuild(errdirtotal,infolist,dirsc,dirinfo,,progress)=$get(@outputglo@(dir))
	Set $ListBuild(direlapsed,dirfreecount,dirtotblks,dirtotbytes,dirpntblks,dirpntbytes,dirbigblks,dirbigbytes,dirbigstrings,diraddblks)=$get(infolist)
	Set:$get(freecount)'="" dirfreecount=freecount
	Set:$get(newdirinfo)'="" dirinfo=newdirinfo
	Set:$get(numerrors)'="" errdirtotal=$get(errdirtotal)+numerrors
	Set:$get(elapsed)'="" direlapsed=$get(direlapsed)+elapsed
	Set:$get(totblks)'="" dirtotblks=$get(dirtotblks)+totblks
	Set:$get(totbytes)'="" dirtotbytes=$get(dirtotbytes)+totbytes
	Set:$get(pntblks)'="" dirpntblks=$get(dirpntblks)+pntblks
	Set:$get(pntbytes)'="" dirpntbytes=$get(dirpntbytes)+pntbytes
	Set:$get(bigblks)'="" dirbigblks=$get(dirbigblks)+bigblks
	Set:$get(bigbytes)'="" dirbigbytes=$get(dirbigbytes)+bigbytes
	Set:$get(bigstrings)'="" dirbigstrings=$get(dirbigstrings)+bigstrings
	Set:$get(addblks)'="" diraddblks=$get(diraddblks)+addblks
	Set:$get(numglo)'="" $list(progress,1)=$listget($get(progress),1)+numglo
	Set:$get(numglodone)'="" $list(progress,2)=$listget($get(progress),2)+numglodone
	If ($get(sc)'="") && ('sc) && ($system.Status.GetErrorCodes(sc)'=267) {
		If $get(dirsc)="" { Set dirsc=sc }
		Else { Set dirsc=$select(+"0 "_dirsc:sc,1:$$AppendStatus^%occSystem("0 "_dirsc,sc)) }
		Set dirsc=$e(dirsc,3,*)
	}
	If errdirtotal>=500 Set errorreturn="abortdir"
	Set @outputglo@(dir)=$ListBuild(errdirtotal,
	                                $ListBuild(direlapsed,dirfreecount,dirtotblks,dirtotbytes,dirpntblks,dirpntbytes,dirbigblks,dirbigbytes,dirbigstrings,diraddblks),
	                                dirsc,
	                                dirinfo,
	                                $Get(errorreturn),
									progress)
}
addDirInfoForGlo(outputglo,dir,glo,sc,mode) {
	Set $ListBuild(elapsed,level,glototblks,glototbytes,glopntblks,glopntbytes,globigblks,globigbytes,globigstrings)=$ListGet($Get(@outputglo@(dir,glo)),2)
	If $Get(mode)["s" {
		; Subtract block & error counts only
		Do addDirInfoToOutput(outputglo,dir,-1,,,,
		                      -$Get(glototblks),-$Get(glototbytes),-$Get(glopntblks),-$Get(glopntbytes),-$Get(globigblks),-$Get(globigbytes),-$Get(globigstrings))
	} ElseIf $Get(mode)["r" {
		; RetryErrors replace block counts only
		Do addDirInfoToOutput(outputglo,dir,('sc),sc,,,
		                      $Get(glototblks),$Get(glototbytes),$Get(glopntblks),$Get(glopntbytes),$Get(globigblks),$Get(globigbytes),$Get(globigstrings)) 
	} Else {
		; Normal addition first time, includes elapsed time and progress count
		Do addDirInfoToOutput(outputglo,dir,('sc),sc,$Get(elapsed),,
		                      $Get(glototblks),$Get(glototbytes),$Get(glopntblks),$Get(glopntbytes),$Get(globigblks),$Get(globigbytes),$Get(globigstrings),
							  ,,,1)
	}
}
Display(outputglo,flags,dirsum) [] PUBLIC {
	Set:$g(outputglo)="" outputglo=$name(^IRIS.TempIntegrityOutput(+$J))
	Set flags=+$g(flags)
	If '$d(@outputglo,tmp) {
		Write !,"Output global ",outputglo," is empty"
		Quit
	}
	Set $ListBuild(type,sc,errorreturn,maxproc,partialcheck)=$Get(tmp)
	Set dir=""
	For {
		Set infdir="",dir=$o(@outputglo@(dir),1,infdir)
		Quit:dir=""
		Continue:infdir=""
		Set cnt=$lg(infdir)
		Write !,"Directory: ",dir
		If cnt="" {
			Write ?60,"Unable to open"
			Continue
		}
		If cnt {
			W !,"Errors found in ",cnt," globals or supporting structures",!
		} Else {
			W !,"No errors found",!
		}
		Set err=$lg(infdir,3)
		If err'="" { Do ShowMessage("0 "_err,$i) }
		Set glo=""
		For {
			Set infglo="",glo=$o(@outputglo@(dir,glo),1,infglo)
			Quit:glo=""
			Continue:infglo=""
			Set msg=$g(@outputglo@(dir,glo,0)),war=$g(^(1)),err=$g(^(2))
			If err="",flags {
				Continue:war=""
				Continue:flags>1
			}
			Write !
			Write:err'="" "**** "
			Write "Global: ",glo,?60,$lg(infglo)," errors found"
			If war'="",flags<2 { Do ShowMessage("1 "_war,$i) }
			If err'="" { 
				Do ShowMessage("0 "_err,$i)
				Set retryresult = $g(@outputglo@(dir,glo,4))
				If retryresult=0 W !," When retried the errors in global "_glo_" remained unchanged",!
				If retryresult=1 W !," These errors in global "_glo_" differ from the errors prior to the retry",!
			}
			If msg'="" { Do ShowMessage("1 "_msg,$i) }
		}
		If +$g(dirsum) {
			Set errcnt=$lg(infdir),dircnts=$lg(infdir,2)
			Set dirinfo=$lg(infdir,4)
			Continue:(dirinfo="")||(dirinfo<0)
			Set diraddblks=$lg(dircnts,10)
			Set blksize=$p(dirinfo,",",2),datasize=$Case(blksize,2048:2036,:(blksize-$zu(40,32,10))),bigdb=$Piece(dirinfo,",",21)
			Set elapsedtime=$lg(dircnts,1),freecount=$lg(dircnts,2),dirtotblks=$lg(dircnts,3)
			Set dirtotbytes=$lg(dircnts,4),dirpntblks=$lg(dircnts,5),dirpntbytes=$lg(dircnts,6)
			Set dirbigblks=$lg(dircnts,7),dirbigbytes=$lg(dircnts,8),dirbigstrings=$lg(dircnts,9)
			Write !,"Summary of blocks in "_dir,!!
			Do writecount("Pointer Level",dirpntblks,dirpntbytes,0)
			Do writecount("Data Level",dirtotblks-dirpntblks-dirbigblks,dirtotbytes-dirpntbytes-dirbigbytes,0)
			Do writecount("Big String",dirbigblks,dirbigbytes,1)
			Do writecount("Total",dirtotblks+diraddblks,dirtotbytes,0)
			Set kb=freecount*blksize\1024,mb=0 Set:kb>10240 kb=kb\1024,mb=1
			Set a=$fn(freecount,","),a=$j("",10-$l(a))_a_" Free blocks"
			Set a=a_$j("",43),a=$e(a,1,43-$l(kb))_kb_$s(mb:"MB",1:"kb")
			Write a,!,!,"Elapsed time = "_$fn(elapsedtime,"",1)_" seconds.",!
		}
		If $ListGet(infdir,5)'="" { Do ShowMessage($$Error^%apiOBJ(181),$i) }
	}
	If $Get(errorreturn)'="" { Do ShowMessage($$Error^%apiOBJ(223),$i) }
	If ('$Get(sc,1)) { 
		Write !,"Results may be incomplete due to unexpected errors: "
		Do ShowMessage(sc,$i)
	}
	Quit
writecount(message,blks,bytes,bigflag)
	Set a=$fn(blks,","),a=$j("",10-$l(a))_a_" "_message_" blocks"
	If blks {
		Set kb=blks*(blksize\1024),mb=0 ;s kb=bytes\1024
		Set:kb>10240 kb=kb\1024,mb=1
		Set a=a_$j("",43),a=$e(a,1,43-$l(kb))_kb_$s(mb:"MB",1:"kb")
		Set:blks a=a_" ("_(bytes\blks*100\datasize)_"% full)"
		If bigflag,dirbigstrings { Set a=a_" # = "_$fn(dirbigstrings,",") }
	}
	Write a,!
	Quit
}
Errors(outputglo,flags) [] PUBLIC {
	Set (errors,warnings)=0
	Set:$g(outputglo)="" outputglo=$name(^IRIS.TempIntegrityOutput(+$J))
	Set flags=+$g(flags)
	If '$d(@outputglo) Quit $s(flags=0:0,1:"0,0")
	Set dir="",dirlist=""
	For {
		Set infdir="",dir=$o(@outputglo@(dir),1,infdir)
		Quit:dir=""
		Continue:infdir=""
		Set dberrors=$lg(infdir,1)
		Set glo="",dbwarnings=0
		If flags {
			For {
				Set glo=$o(@outputglo@(dir,glo),1,infglo)
				Quit:glo=""
				If $g(@outputglo@(dir,glo,1))'="" { Set dbwarnings=dbwarnings+1 }
			}
		}
		if (dberrors+dbwarnings) {
			set errors=errors+dberrors,warnings=warnings+dbwarnings
		}
	}
	Set sc=$ListGet($Get(@outputglo),2,1)
	Set:('sc) errors=errors+1
	If flags=0 q errors
	q errors_","_warnings
}
RetryErrors(outputglo,flags,sc) [] PUBLIC {
	New %out,%queuedcnt 
	Set:$Get(outputglo)="" outputglo=$Name(^IRIS.TempIntegrityOutput(+$J))
	Set flags=+$Get(flags)
	Set sc=1
	Set %out=outputglo
	Set $ListBuild(type,origsc,errorreturn,maxproc,partialcheck,listlen)=$Get(@outputglo)
	If $Get(errorreturn)'="" {
		Set sc=$$Error^%apiOBJ(225)
		Quit $$Errors(outputglo,flags)
	}
	Set:'$Get(partialcheck) partialcheck=-1
	Set queue=$system.WorkMgr.Initialize(,.sc,+$Get(maxproc)) 
	Quit:('sc) $$Errors(outputglo,flags)
	Set retryglo=$Name(^IRIS.TempIntegrityRetry(+$J))
	Kill @retryglo
	Set dir="",dirlist=""
	Try { 
		For {
			Set infdir="",dir=$Order(@outputglo@(dir),1,infdir)
			Quit:dir=""
			Continue:(infdir="")
			If $ListGet(infdir,5)'="" {	Set skippeddir=1 Continue }
			Set dirinfo=$zu(49,dir)
			Set sfn=+dirinfo
			Kill gloarray
			Set glo=""
			For {
				Set glo=$Order(@outputglo@(dir,glo),1,infglo)
				Quit:glo=""
				Continue:$Get(@outputglo@(dir,glo,2))=""
				If '$Data(gloarray) {
					Set tmpsc=$$GetDirGlobalsINTEG^%SYS.DATABASE(dir,.gloarray,.gdirerrs,.numgdir)
					If ('tmpsc) {
						Set sc=$select(+sc:tmpsc,1:$$AppendStatus^%occSystem(sc,tmpsc))
						Quit
					}
				}
				If '$Data(gloarray(glo)) && 'gdirerrs && 'listlen {
					Do addDirInfoForGlo(outputglo,dir,glo,,"s")
					Kill @outputglo@(dir,glo)
				}
				Set gloinfo=$ListBuild(glo,gloarray(glo))
				If '$Data(@outputglo@(dir,glo,"range"),ranges) {
					Set tmpsc=queue.QueueCallback("$$CheckOneGlobal^Integrity","$$RetryCallback^Integrity",retryglo,dir,dirinfo,gloinfo,partialcheck)
					Set:('tmpsc) sc=$select(+sc:tmpsc,1:$$AppendStatus^%occSystem(sc,tmpsc))
				} Else {
					Merge @retryglo@(dir,glo,"range")=@outputglo@(dir,glo,"range")
					For i=0:1:ranges {
						If $Get(@outputglo@(dir,glo,"range",i,2))'="" {
							Set $List(gloinfo,5)=i
							Set tmpsc=queue.QueueCallback("$$CheckOneRange^Integrity","$$RetryCallback^Integrity",retryglo,dir,dirinfo,gloinfo)
							If ('tmpsc) { Set sc=$select(+sc:tmpsc,1:$$AppendStatus^%occSystem(sc,tmpsc)) }
							Else { Set %queuedcnt(sfn,glo)=$Get(%queuedcnt(sfn,glo))+1 }
						}
					}
				}
			}
		}
		For {
			Set tmpsc=queue.Wait(,.atend,2)
			If ('tmpsc) && ($system.Status.GetErrorCodes(tmpsc)'=267) {
				Set sc=$select(+sc:tmpsc,1:$$AppendStatus^%occSystem(sc,tmpsc))
			}
			Quit:atend
		}
		Set:$Get(skippeddir)'="" sc=$select(+sc:$$Error^%apiOBJ(225),1:$$AppendStatus^%occSystem(sc,$$Error^%apiOBJ(225)))
		Kill @retryglo
	} Catch err {
		Kill @retryglo
		Set sc=$select(+sc:err.AsStatus(),1:$$AppendStatus^%occSystem(sc,err.AsStatus()))
	}
	Quit $$Errors(outputglo,flags)
}
RetryCallback(retryglo,dir,dirinfo,gloinfo,partialcheck) PUBLIC {
	Set %exit=1
	Set glo=$List(gloinfo,1)
	Set range=$ListGet(gloinfo,5)
	Set sfn=+dirinfo
	If range'="" {
		Quit:$increment(%queuedcnt(sfn,glo),-1) 1
		Set %status=$$CheckIntegrity^%SYS.DATABASE("a",,dir,,,glo,,dirinfo,,,,,,,,,,retryglo)
	}
	Set outsub=$Name(@%out@(dir,glo))
	Set newerrors=$Get(@retryglo@(dir,glo,2))
	If (''%status) {
		Set errormismatch=-1
	} ElseIf $system.Status.GetErrorCodes(%status)=267 {
		Set errormismatch=0
		Set savederrors=$Get(@outsub@(2))
		set newptr=0,saveptr=0,errormismatch=0
		While $ListNext(newerrors,newptr,onenewerror) {
			If '$ListNext(savederrors,saveptr,onesavederror) {
				// saved had fewer errors
			    Set errormismatch=1
			    Quit
			}
			If '$ListSame($List(onenewerror,1,9),$List(onesavederror,1,9)) {
			    Set errormismatch=1
			    Quit
			}
		}
		If 'errormismatch {
			Set @outsub@(4)=0
			Quit 1
		} Else { 
			Set @retryglo@(dir,glo,4)=1
		}
	} Else {
		Quit 1
	}
	Set origsc=$ListGet($Get(@%out),2)
	Set $List(@%out,2)=$select(+$$Error^%apiOBJ(224):origsc,1:$$AppendStatus^%occSystem($$Error^%apiOBJ(224),origsc))
	Do addDirInfoForGlo(%out,dir,glo,,"s")
	Kill @outsub
	Merge @outsub=@retryglo@(dir,glo)
	Do addDirInfoForGlo(%out,dir,glo,%status,"r")
	Set $List(@%out,2)=origsc
	Quit 1
}
Query(filename,outdevice) ;
    Set $Ztrap="errQuery"
    Open filename::10
    If '$Data(outdevice) { Set outdevice=0 }
    ElseIf outdevice {
	Open outdevice
	If '$Test Use 0 Write !,"Cannot open "_outdevice_"." Quit
    }
    For { Use filename Read line Use outdevice Write !,line }
    Close filename
    Close outdevice
    Quit
errQuery ;
    Close filename
    Close outdevice
    Quit:$Zerror["<ENDOFFILE>"
    Use 0
    Write !,"Error getting Integrity report is: ",$Zerror
    Quit
ReportError(dir,rc,IO) PRIVATE {
    Do ShowMessage(rc,IO) 
    Do:IO'=$I ShowMessage(rc,$I)
    Do RecordError(dir,rc)
}
RecordError(dir,rc) [errsum] PRIVATE {
    Set errsum=$G(errsum)+1
    Kill:errsum>100 errsum(errsum-100)
    Set errsum(errsum,1)=dir
    Set errsum(errsum,2)=rc
}
GetAsyncReadBuffers() [] PUBLIC {
    Set rb = $view($ZUTIL(40,2,171)+2,-2,2)
    Q $case(rb,0:8,:rb)
}
GetAsyncReadBufferSize() [] PUBLIC {
    q $view($ZUTIL(40,2,171)+0,-2,2)
}
SetAsyncReadBuffers(value) [] PUBLIC {
    if (+value<0) ! (+value > 128) {
	w !,"Value must be between 0 and 128",!
	Q
    }
    view $ZUTIL(40,2,171)+2:-2:2:+value 
    view $ZUTIL(40,2,171)+6:-2:2:+value
}
SetAsyncReadBufferSize(value) [] PUBLIC {
    if (+value<0) ! (+value > 512) {
	w !,"Value must be between 0 and 512",!
	Q
    }
    view $ZUTIL(40,2,171)+0:-2:2:+value 
    view $ZUTIL(40,2,171)+4:-2:2:+value
}
GetStrategy() [] PUBLIC {
    q +$get(^%SYS("Integrity","Strategy"))
}
SetStrategy(value) [] PUBLIC {
    set ^%SYS("Integrity","Strategy")=''value
}
GetNumJobs() [] PUBLIC {
	try {
		set num=+$get(^%SYS("Integrity","NumJobs"))
		set:num<1 num=8
	} catch {
		set num=8
	}
	quit num
}
SetNumJobs(value) [] PUBLIC {
    set ^%SYS("Integrity","NumJobs")=value
}
ShowMessage(sc,device) [] PRIVATE {
    Do DecomposeStatus^%SYS.DATABASE(sc,.msglist,0,"")
    Do wrtmsg($C(13,10),device)
    For i=1:1:msglist {	Do wrtmsg(msglist(i)_$C(13,10),device) }
}
wrtmsg(msg,device) [] PRIVATE {
    Quit:'$L(msg)  ; Avoid argumentless writes...
    If device=-1 { Do $zu(9,"",msg,0,0) Quit }
    If $g(%UI,"CHUI")="CHUI" { Use device Write msg Quit }
    Do:$$IjcMsg^%Wprima("DI"_msg)="CANCEL"  ; Return value could be cancel message 
    . i $$IjcMsg^%Wprima("DI"_$C(13,10)_"Abort received!"_$C(13,10))
    . zt "Abort"
}

JCONVERT^INT^1^67214,47330
JCONVERT ; Convert journal file to common format
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ;This routine will read a Cache journal file and convert it
 ;to a common format which can be read with the ^JREAD utility
 ;See the documentation in the ^JREAD utility for the output
 ;file format.
main new
INT ;
 s POP=0,notresto=0,IOSAVE=$I
 s $ZT="errloop"
 s vmode="Yes"
 s dirref="Yes"
 w !,"Journal Conversion Utility  [ IRIS Format --> Common Format ]"
 w !,"You can choose between the Enhanced Format, which supports long"
 w !,"strings but is incompatible with previous versions of ^%JREAD,"
 w !,"and the Compatible Format, which does NOT support long strings"
 w !,"but can be processed by previous versions of ^%JREAD."
 w !,"The default is the Enhanced Format."
 s Prompt="Use the Enhanced Format?"
 s Value=1
 s Status=##Class(%Library.Prompt).GetYesNo(Prompt,.Value,,8)
 i (+Status=0)||(Status=2) q
 i 'Value g OLD
NEW ;this creates the new format that supports long strings
 s POP=0,notresto=0,IOSAVE=$I
 s $ZT="errloop"
 s vmode="Yes"
 s dirref="Yes"
 w !,"Journal Conversion Utility (Enhanced Format)"
Loop0 ;w !
 s xlate="UTF8"
 s fmode1="UVL" ;Undefined mode with Variable Length field (2 or 4 bytes)
 w !
 w !,"Globals in the journal file are stored with a specific directory reference"
 w !,"appended to the global reference. You can choose either to include"
 w !,"the directory reference in the converted file, or exclude it. Note that"
 w !,"if you include it, you can always filter it out or change it later during"
 w !,"the JREAD procedure.  The directory reference determines where ^JREAD sets"
 w !,"the global on the target system.  If the directory reference is not included,"
 w !,"all sets are made to the current directory.  If the directory reference is"
 w !,"included, sets will be made to the same directory as on the source system"
 w !,"unless translated by a ^%ZJREAD program you supply.  If the target system"
 w !,"is on a different operating system or the databases reside in different"
 w !,"directories on the target system, the ^%ZJREAD program must be used to"
 w !,"translate the directory reference."
 w !
Loop05 w !,"Include the directory reference? <",dirref,"> "
 r x
 i x="" s x=dirref
 g:x="^" Loop0
 i $zcvt($e(x),"u")="Y" s includedir=1,dirref="Yes"
 e  s includedir=0,dirref="No"
 w !     
Loop1 w !,"Enter common journal file name:  "
 r x i x="" g Loop1
 g:x="^" Loop05
 s file2=x
 ;Don't allow overwriting of existing file
 s x=$zu(140,4,file2)
 i x=0 w !,"File "_file2_" already exists",! g Loop1
 ; Now see if the device and directory are good
 o file2:("WNU":/IOT=xlate):1  
 i '$t w !,"Unable to open file ",file2,! g Loop1
 w !
 w !,"Common journal file: ",file2
 w !,"Character translation: ",xlate
 w !,"Directory reference: ",dirref
 w !
 ; Write the header out
 u file2
 w "JCVTUVL"
 d wuvl^JRNRESTB(xlate)
 d wuvl^JRNRESTB($h)
 w includedir ;0 or 1
 u $p
 d convert
 c file2
 q
OLD ;this creates the old format, compatible with old version of the utility
 s POP=0,notresto=0,IOSAVE=$I
 s $ZT="errloop"
 s vmode="Yes"
 s dirref="Yes"
 w !,"Journal Conversion Utility (Compatible Format)"
loop w !
 w !
 w !,"The converted file will be in variable record format."
 W !,"The default character translation UTF8 is compatible with current ^%JREAD"
 W !,"on all platforms and can be moved among platforms with binary FTP."
 W !,"If you answer NO, no character translation will be applied."
 W !
loop0 w !,"Use UTF8 character translation? <Yes> "
 r x g:x="^" loop
 i $zcvt($e(x),"U")="N" { ;no translation
   s xlate="RAW"
 } elseif x["/" {
   s x=$p(x,"/",2) 
   i x'="" s xlate=x
 } else {
   s xlate="UTF8"
 }
 s recsep=1
 s fmode1="V"
 s fmode="WN"_fmode1_"K\RAW\"
 w !
 w !,"Globals in the journal file are stored with a specific directory reference"
 w !,"appended to the global reference. You can choose either to include"
 w !,"the directory reference in the converted file, or exclude it. Note that"
 w !,"if you include it, you can always filter it out or change it later during"
 w !,"the JREAD procedure.  The directory reference determines where ^JREAD sets"
 w !,"the global on the target system.  If the directory reference is not included,"
 w !,"all sets are made to the current directory.  If the directory reference is"
 w !,"included, sets will be made to the same directory as on the source system"
 w !,"unless translated by a ^%ZJREAD program you supply.  If the target system"
 w !,"is on a different operating system or the databases reside in different"
 w !,"directories on the target system, the ^%ZJREAD program must be used to"
 w !,"translate the directory reference."
 w !
loop05 w !,"Include the directory reference? <",dirref,"> "
 r x
 i x="" s x=dirref
 g:x="^" loop0
 i $zcvt($e(x),"u")="Y" s includedir=1,dirref="Yes"
 e  s includedir=0,dirref="No"
 w !     
loop1 w !,"Enter common journal file name:  "
 r x i x="" g loop1
 g:x="^" loop05
 s file2=x
 ;Don't allow overwriting of existing file
 s x=$zu(140,4,file2)
 i x=0 w !,"File "_file2_" already exists",! g loop1
 ; Now see if the device and directory are good
 o file2:(fmode):1  
 i '$t w !,"Unable to open file ",file2,! g loop1
 w !
 w !,"Common journal file: ",file2
 w !,"Record separator: "
 d
 . i recsep=1 w "Variable" q
 . i recsep=2 w "OpenVMS" q
 . w "$CHAR(" f i=1:1:$l(recsep) w:i>1 "," w $a(recsep,i)
 . w ")"
 w !,"Character translation: ",xlate
 w !,"Directory reference: ",dirref
 w !
 ; Write the header out
 s recsep=$zcvt(recsep,"O",xlate)
 u file2
 d wvar^JRNRESTB("JCONVERT")
 d wvar^JRNRESTB(xlate)
 d wvar^JRNRESTB($h)
 d wvar^JRNRESTB(includedir)
 u $p
 d convert
 c file2
 u 0
 if POP!notresto d  I POP g loop
 . ; POP means the user wants to back up to the prior prompt and
 . ; notresto means we hit a problem and aborted. In both cases
 . ; delete the output file
 . s x=$zu(140,5,file2)
 . i notresto w !,"Conversion did not complete."
 q
 ;
convert ;
  s fromrest=8 ;tell restore^JRNRESTB to create common format jrn file
  s reccnt=0  ;incremented in restore^JRNRESTB
  s POP=0  ; set if the user wants to return to the prior prompt
  D INT^JRNRESTO
  q:POP!notresto
  w !,"Converted "_reccnt_" journal records"
  q
errloop s $ZT=""
 u 0
 i $d(file2) c file2
 i $ZE["INTERRUPT" q
 w !!,"Error:  ",$ze
 d BACK^%ETN
 q    

JOURNAL^INT^1^67214,47330
JOURNAL ;(PTR,PK) JOURNAL UTILITIES ; ;$Change: 7440104 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	; Revision: $Id: //iris/2024.1.3/databases/sys/rtn/journal/journal.mac#1 $
 d MENU()
 q
MENU() PUBLIC { 
 s $zt="ERROR"
 s List(1)="Begin Journaling (^JRNSTART)"
 s List(2)="Stop Journaling (^JRNSTOP)"
 s List(3)="Switch Journal File (^JRNSWTCH)"
 s List(4)="Restore Globals From Journal (^JRNRESTO)"
 s List(5)="Display Journal File (^JRNDUMP)"
 s List(6)="Purge Journal Files (PURGE^JOURNAL)"
 s List(7)="Edit Journal Properties (^JRNOPTS)"
 s List(8)="Activate or Deactivate Journal Encryption (ENCRYPT^JOURNAL())"
 s List(9)="Display Journal status (Status^JOURNAL)"
 k active,pending
 do getTransactionStatus^JRNROLL(.active,.pending)
 i $S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0) {
	 s List(10)="Cluster Journal Restore (CLUMENU^JRNRESTO)"
 } else {
	 /* unfortunatly we can't omit option #'s so if we need to
		include Manage^JRNROLL, we need to have something here */
	 s List(10)="-not available-"
	 s Action(10)="NA^JOURNAL"
 } 
 if (active || pending) {
	 s List(11)="Manage pending or in progress transaction rollback (Manage^JRNROLL)"
 } else {
	 s List(11)="-not available-"
	 s Action(11)="NA^JOURNAL"
 }
	 s List(12)="Journal catch-up for mirrored databases (MirrorCatchup^JRNRESTO)"
 s i="" f  s i=$o(List(i)) q:i=""  i $g(Action(i))="" s msg=List(i),act=$p(msg,"(",2,$l(msg)),Action(i)=$e(act,1,$l(act)-1)
 f  {
	s msg=$$GetSWDIRoption(),act=$p(msg,"(",2,$l(msg))
	s List(13)=msg,Action(13)=$e(act,1,$l(act)-1)
 	s Value=""
	s Status=##Class(%Library.Prompt).GetMenu("Option?",.Value,.List,,8+128+4)
 	i (+Status=0)||(Status=2)||(Value="") q
	i Value=13,List(13)'=$$GetSWDIRoption() {
		w !,"Journal settings have changed. Please try again."
		continue
	}
	s tagrtn=Action(Value) i $g(tagrtn)="" q  ;an "impossible" case
	d @tagrtn
 }
 q Status
ERROR s $zt=""
 i $ze["<INTERRUPT>" q 0
 ztrap $ze
}
NA() PUBLIC {
	w !,"Option not available"
	quit 	
}
GetSWDIRoption() PUBLIC {
 s Status=##class(%SYS.Journal.System).GetTheOtherDirectory(,.Type)
 i Type=2 {
   q "Switch Journaling to Secondary Directory (SWDIR^JOURNAL)"
 } elseif Type=1 {
   q "Switch Journaling Back to Primary Directory (SWDIR^JOURNAL)"
 } else { ;Type=0 means no other directory to switch to
   q "-not available-"
 }
}
SWDIR() PUBLIC { ;switch journaling from current directory to alternate one
 s rc=##class(%SYS.Journal.System).SwitchDirectory()
 i rc w !,"Journaling to ",$zu(78,3)
}
ENCRYPT() PUBLIC {
 i $p($zu(78,22,$zu(78,3),5),",",2) {
 	w !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"435129403"),"Current journal file is encrypted")
	s Value=1
 	s Status=##Class(%Library.Prompt).GetYesNo("Deactivate journal encryption?",.Value,,8)
 	i (Status=2)||(+Status=0)||'Value q Status
	s Status=##class(%SYS.Journal.System).DeactivateEncryption()
	i Status w !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"4174399136"),"Journal encryption deactivated") i 1
	e  d $System.Status.DisplayError(Status)
 } else {
 	w !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1439851791"),"Current journal file is NOT encrypted")
	Set DBEncKeyIDList=$System.Security.System.GetDBEncKeyIDList()
	If DBEncKeyIDList="" {
 	   s err=$System.Status.GetErrorText($$Error^%apiOBJ(1201))
	   w !,$p($p(err,"["),": ",2) ;strip off error code and tag
	   q
	}
	s Value=1
 	s Status=##Class(%Library.Prompt).GetYesNo("Activate journal encryption?",.Value,,8)
 	i (Status=2)||(+Status=0)||'Value q Status
	s Status=##class(%SYS.Journal.System).ActivateEncryption()
	i Status w !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3985593845"),"Journal encryption activated") i 1
	e  d $System.Status.DisplayError(Status)
 }
 q Status
}
Status() PUBLIC {
	d ##class(%SYS.Journal.System).GetDefaults(.curdir,.altdir,.maxsize,.expqty,.prefix,.shortnam)
	w !
	i $d(curdir) d
	.w !,"Primary journal directory:  ",curdir
	.s x=$zu(140,13,curdir)
	.w !,"Primary journal directory free space (KB):  ",$p(x,",",2)*$p(x,",",4)/1024
	i $d(altdir),$g(altdir)'=$g(curdir) d  i 1
	.w !,"Secondary journal directory:  ",altdir
	.s x=$zu(140,13,altdir)
	.w !,"Secondary journal directory free space (KB): ",$p(x,",",2)*$p(x,",",4)/1024
	e  w !,"Secondary journal directory: [same as primary]"
	s curfile=##class(%SYS.Journal.System).GetCurrentFileName()
	s $zt="istests"
	i $l(curfile) d
	. s dir=$$basename(curfile)
	. w !,"Current journal file:  ",curfile
	. i $d(altdir),$g(altdir)'=$g(curdir) d 
	. . w !,"                       in ",$s($zu(12,dir)=$zu(12,curdir):"primary",1:"secondary")," journal directory" 
	.s n=$P($ZU(78,22,curfile,3),",",2) w !,"Current journal file maximum size:" s x=$x w ?(x+1)," ",$J(n,12)
	.s n=$p($zu(78,4)_","_$zu(78,3),",",1) w !,"Current journal file space used:  ",?(x+1)," ",$J(n,12)
istests	;
	i '$p($zu(78,22),"^") W !,"Journaling is disabled." g procs
	i $p($zu(78,22),"^",3) W !,"Journaling is disabled due to I/O error." g procs
	i $p($zu(78,22),"^",5) W !,",Journaling is frozen due to I/O error." g procs
	i $p($zu(78,22),"^",2) W !,"Journal switch in progress." g procs
	i $p($zu(78,22),"^") W !,"Journaling is enabled."
procs	;
	s JRNSTART=+$g(^%SYS("JOURNAL","PROCESS","JRNSTART"))
	I JRNSTART d
	.s rtn=$zu(67,5,JRNSTART)
	.i rtn'="JRNSTART",rtn'="JRNUTIL" s text=" running ^JRNSTART exited abnormally"
	.e  s text=" running ^JRNSTART."
	.w !,"Process ",JRNSTART,text
	s JRNSTOP=+$g(^%SYS("JOURNAL","PROCESS","JRNSTOP"))
	I JRNSTOP d
	.s rtn=$zu(67,5,JRNSTOP)
	.i rtn'="JRNSTART",rtn'="JRNUTIL",rtn'="JRNSTOP" s text=" running ^JRNSTOP exited abnormally"
	.e  s text=" running ^JRNSTOP."
	.w !,"Process ",JRNSTOP,text
	s JRNSWTCH=+$g(^%SYS("JOURNAL","PROCESS","JRNSWTCH"))
	I JRNSWTCH d
	.s rtn=$zu(67,5,JRNSWTCH)
	.i rtn'="JRNSTART",rtn'="JRNUTIL",rtn'="JRNSWTCH" s text=" running ^JRNSWTCH exited abnormally"
	.e  s text=" running ^JRNSWTCH."
	.w !,"Process ",JRNSWTCH,text
	k curdir,altdir,curfile,expqty,jrnall,maxsize,prefix,shortnam,rc
}
PURGE() PUBLIC {
 i $p($g(^%SYS("JOURNAL","LIFESPAN","FILE")),",",3) {
	s Help(1)=$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"5214352"),"If Yes, files that have been copied to archive are purged")
	s Help(2)=$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1138263693"),"Files are NOT purged if they are still needed by the system")
	s Help(3)=$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3450203644"),"(for crash recovery, mirroring, etc.).")
	s Value=0
 	s Status=##Class(%Library.Prompt).GetYesNo("Purge archived journal files NOT needed by the system?",.Value,.Help,8)
 	i (Status=2)||(+Status=0)||'Value q Status
	s Status=##class(%SYS.Journal.File).PurgeAll() ;always "OK"
	d ShowPurged()
 	q
 }
 s Option(1)="Purge any journal NOT required for transaction rollback or crash recovery"
 s criteria=$g(^%SYS("JOURNAL","LIFESPAN","FILE"))
 s KeepByDays=+criteria_" days"
 s KeepByBaks=+$p(criteria,",",2)_" backups"
 i KeepByDays,KeepByBaks s criteria=KeepByDays_" or "_KeepByBaks
 e  i KeepByBaks s criteria=KeepByBaks
 e  i KeepByDays s criteria=KeepByDays
 e  s criteria="NEVER PURGE"  ;no journal file will be purged
 s Option(2)="Purge journals based on existing criteria ("_criteria_")"
 f  {
 	s Value=""
	s Status=##Class(%Library.Prompt).GetMenu("Option?",.Value,.Option,,8+128+4)
 	i (+Status=0)||(Status=2)||(Value="") q
	i Value=1 {
	   s Status=##class(%SYS.Journal.File).PurgeAll() ;always "OK"
	}
	i Value=2 {
	   d PURGE^JRNUTIL
	}
	d ShowPurged()
	q   ;back to main menu
 }
}
ShowPurged() PUBLIC {
	s purged=0
	i $g(^||%ISC.PurgedJrnFiles) {
	  s purged=1
	  w !
	  w !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1471174535"),"The following journal files have been purged (listed from latest to oldest): "),!
	  s index="" f  s index=$o(^||%ISC.PurgedJrnFiles(index),-1,purgedfile) q:index=""  w !,index,". ",purgedfile
	}
	i $d(^||%ISC.PurgedMirJrnFiles) {
	  s mirpurged=0
	  s mirror="" f  {
	    s mirror=$o(^||%ISC.PurgedMirJrnFiles(mirror)) q:mirror=""
	    i 'mirpurged,$d(^||%ISC.PurgedMirJrnFiles(mirror))>1 {
	      w !
	      w !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3650447038"),"The following mirror journal files have been purged: "),!
	      s mirpurged=1
	    }
	    w !
	    s index="" f  s index=$o(^||%ISC.PurgedMirJrnFiles(mirror,index),-1,purgedfile) q:index=""  w !,index,". ",purgedfile s purged=1
	  }
	}
	i 'purged w !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3903454434"),"None purged")
}
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/FILEINC.inc#1 $ ($Change: 7440104 $) */
 ; BITWISE.INC
FIXDIR(dir) ;procedure, dir is passed by reference
 Q:dir=""
 Q:$A(dir,$L(dir))=$A($s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""))
 s dir=dir_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")
 Q
fixdir(dir) ;function
 Q:dir="" ""
 Q:$A(dir,$L(dir))=$A($s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")) dir
 Q dir_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")
basename(f) ;similar to basename on UNIX
 Q $P(f,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""),1,$L(f,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""))-1)_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")
appdir(d1,d2) ;use $zu(12,d2) to append d2 to canonic dir
 S d1=d1_d2
 Q d1
VALIDIR(dir) ;validate directory dir and create it if dir doesn't exist
 new flag
 s flag=1
 g vdir2
validir(dir,flag) ;validate directory dir and optionally create it if it
vdir2 ; VALIDIR(dir) comes here with flag set to 1
 quit:$$ChkDirOrSpecEXISTS(dir)'="" 1   ; dir is valid and exists
 quit:$$ChkDirVALID(dir)="" 0    ; dir is not valid
 i flag'=1 q 0  ; flag says don't create, return failure
 new x
 set x=$$mkdir(dir)  ; returns 0 for success, 1 for failure
 q:x=1 0  ; failed to create
 quit:$$ChkDirOrSpecEXISTS(dir)="" 0   ; it doesn't we failed
 q 1  ; success
mkdir(dir) ;create a new directory
 q '##class(%Library.File).CreateDirectoryChain(dir)
jrnshort(jf,short) ;get/set short form of a journal file name FIXME HYY1999
         N (jf,short)
         S len=$L($P(jf,";"))
         Q:$G(short)="" $E(jf,len-11,len) ;"GET" form
         S $E(jf,len-11,len)=short ;"SET" form
         Q jf
GJrnPrefix(jf) ;extract prefix from the journal file name jf
         N (jf)
         S fname=$P(jf,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""),$L(jf,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")))       
         Q $e(fname,1,$l($p(fname,"."))-8)
GetJrnFileName(path) { 
	i $f(path,"/") q $p(path,"/",$l(path,"/")) ;presumably a Unix path
	if $f(path,"\") q $p(path,"\",$l(path,"\")) ;presumably a Windows path
	s vmsfile=$p(path,"]",2) i vmsfile="" q path ;a name only, not a path
	q $p(vmsfile,";") ;return name from a VMS path without trailing ";"
}
dirinvalidmsg(dir1,dir2) 
 n valid1,valid2,cnt,msg
 s valid1=$$VALIDIR(dir1),valid2=$$VALIDIR(dir2)
 s cnt=valid1+valid2 ; cnt = 0 if both invalid, 1 if one is valid
 s msg="The following journaling "
 s:cnt msg=msg_"directory is" 
 s:'cnt msg=msg_"directories are"
 s msg=msg_" not valid"_$C(13,10)
 s:'valid1 msg=msg_"     "_dir1_$C(13,10)
 s:'valid2 msg=msg_"     "_dir2_$C(13,10)
 q msg
ChkDirVALID(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,1)
ChkDirEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkDirOrSpecEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,3)
ChkDir(R) N N S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkBad S $ZT="" W !,"<"_$P($P($ZE,"<",2),">")_"> error -- invalid directory"
 Q ""

JRNARC^INT^1^67214,47330
JRNARC ;Archive journal files
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/FILEINC.inc#1 $ ($Change: 7440104 $) */
 /*	s val=$$CHECK(val)  ; val starts as 0 and then the return value
                        ; is passed into the next call
	The archiving parameters are taken from ^SYS("JRNARC") as followed:
  		^SYS("JRNARC","loglevel") ;controls the messages generated
	This routine keeps track of the the most recent file # checked for archiving
	    in ^SYS("JRNARC","lastchecked") and ^SYS("JRNARC","lastchecked",<mirname>")
	    On each run it finds the most recent file that is eligible for archiving (local
	    file which is closed/mirror files that's not the last) and works forward from where it
	    left off (lastchecked) until it gets to the target end point. Then it repeats the
	    process to see if more files became eligble for archiving while it was working.
		For mirror files we store the mirjrnfilecnt, for local files we store the shortname.
    The return value is a count which is the sum of all the journal file counts 
    	from the files being created. This is passed in so we can quickly check
    	whether we should scan for new files to archive or not. Files retrieved
    	via the agent are archived (if needed) after they are received.
     CHECK is designed not to wait so it can be called by a process which is
     	responsible for other things as well. CHECK() jobs SCAN() if there is work
     	to do.
 */
 /* The following are values for ^SYS("JRNARC","loglevel"). */
CHECK(oldcnt) PUBLIC { 
	s $zt="err"
	i $g(^%SYS("JOURNAL","ARCHIVE"))="" q oldcnt ;no journal archiving 
	if $G(^SYS("JRNARC","pid"))'="",$D(^$LOCK("^%JRNARCCHKSCAN")) {
		quit oldcnt
	}
    	s cnt=$ZU(78,26)
	s oldcnt=$g(^SYS("JRNARC","active"))
	s needscan=0
    	i cnt-oldcnt {
		s needscan=1
	} elseif $SYSTEM.Mirror.IsMember()&&'$SYSTEM.Mirror.IsPrimary() {
		s mirnames=$SYSTEM.Mirror.GetMirrorNames()
		s mircnt=$LL(mirnames)
		for i=1:1:mircnt {
			s name=$LG(mirnames,i)
			s idx=$SYSTEM.Mirror.MirrorNameToIndex(name)
			i idx>-1 {
				s mirfcnt=+$SYSTEM.Mirror.GetInfo(2,idx)
				i mirfcnt'=$g(^SYS("JRNARC","active",name)) s needscan=1 q
			}
		}
	}
	i $g(^%ISCLOG("JRNARC")) {	;HYY000+
		i needscan {
			d $zu(9,"","JRNARC CHECK: "_cnt_","_oldcnt_$s($g(name)="":"",1:","_name_":"_$g(mirfcnt)_","_$g(^SYS("JRNARC","active",name))))
			s ^%ISCLOG("JRNARC")=2
		} elseif ^%ISCLOG("JRNARC")>1 {
			s ^%ISCLOG("JRNARC")=1
		}
	}	;HYY000-
	i needscan {
		i $g(^SYS("JRNARC","sleep")) {
		  d SCAN(oldcnt)
		} else {
		j SCAN(oldcnt)::5
		if '$T {
			d $zu(9,"","Failed to start SCAN^"_$ZN_" to archive journal files",1 /* broadcast and log message*/,1  /* Warning */)
		}
		}
	} elseif $p($g(^%SYS("JOURNAL","LIFESPAN","FILE")),",",3) {
		;to purge files that have been archived and are no longer required for recovery
		d Purge()
	}
	quit cnt
err ;
	s $zt=""
	s lastref=$zr
	if $G(^SYS("JRNARC",":errors:","CHECK"))'=+$ZTS {
		s ^SYS("JRNARC",":errors:","CHECK")=+$ZTS
		d BACK^%ETN
	}
	d $zu(9,"","Journal Archiving: "_"CHECK^"_$ZN_" caught "_$ZE,1 /* broadcast and log message*/,2  /* Severe error */)
	quit 0
}
 /* SCAN() is jobbed off by CHECK() when CHECK() thinks
    there are files to archive. It can also be called
    directly. A lock is used to prevent two copies from 
    running at the same time. The lock does not conflict 
    with ^%JRNARCCHK which is used to coordinate archiving 
    files and processing the pending delete list
    SCAN may wait (forever) if it cannot acquire the lock to
    check for journal files which need archiving. It waits
    because RECEIVE won't start a new scan until a new journal file.
    SCAN calls main() to check for journal files from various
    sources. With "" main checks for local journal files. SCAN
    also calls main(<mirname>) for any mirrors we're a member of
 */
SCAN(oldcnt) public {
	s $ZT="err"
	l +^%JRNARCCHKSCAN:5
	if '$T {
		s failcnt=$I(^SYS("JRNARC","runlockfail"))
		if failcnt>1 quit
		s ^SYS("JRNARC","runlockfail","starttime")=$zts
		do {
			if '(failcnt#60) {  ;60 = 300 seconds/5 seconds/try - every 5 minutes
			   s last=$zts
			   s elapsed=$$elapsedSec($G(^SYS("JRNARC","runlockfail","starttime")),last)
			   s elapsed=elapsed/60
			   s msg="SCAN^"_$ZN_" failed to acquire run lock for "_$FN(elapsed+0.5,,0)_" minutes. "
			   s msg=msg_"Check status of process "_$G(^SYS("JRNARC","pid"),^$LOCK("^%JRNARCCHKSCAN","OWNER"))
			   d $zu(9,"",msg,1 /* broadcast and log message*/,1  /* Warning */)
			}
			s failcnt=failcnt+1
			l +^%JRNARCCHKSCAN:5
		} while ('$T)	
		zk ^SYS("JRNARC","runlockfail","starttime")
		s ^SYS("JRNARC","runlockfail")=0
	    d $zu(9,"","SCAN^"_$ZN_" run lock acquired",0,0  /* Informational message */)
	}
	s ^SYS("JRNARC","pid")=$J
	s loglevel=+$G(^SYS("JRNARC","loglevel"),1)
	; It's possible RECEIVE daemon has to adjust oldcnt back to match
	; that of JRNZIP in case JRNARC delays archiving some files that
	; have yet to be compressed. Kill the "active" nodes to force
	; scanning files up to the last checkpoints.
	; this should not happen anymore as we set "active" to "lastchecked"
	i oldcnt<$g(^SYS("JRNARC","active")) k ^SYS("JRNARC","active") 
	f  {
		s done=1
    		s curfilecnt=$ZU(78,26)
		i $SYSTEM.Mirror.IsPrimary() {
    			i curfilecnt'=+$G(^SYS("JRNARC","active")) {
				s done=0
				i $$Primary() {
					s ^SYS("JRNARC","active")=curfilecnt
				} else { ;not a primary? or some files yet to be archived
					h 1  ;to prevent a tight loop
				}
				continue
			}
			;to purge files that have been archived and are no longer needed for recovery
			i $p($g(^%SYS("JOURNAL","LIFESPAN","FILE")),",",3) d Purge()
			q
		}
		;First deal with the local non-mirror file that we created.
	        i $g(^%ISCLOG("JRNARC")) d $zu(9,"","JRNARC SCAN: "_curfilecnt_","_$G(^SYS("JRNARC","active"))) ;HYY000
    		i curfilecnt'=+$G(^SYS("JRNARC","active")) {
			s done=0
    			i $$locMain() s ^SYS("JRNARC","active")=curfilecnt
    		}
    		;Now deal with journal files from mirrors of which we're a member
		s mirnames=$SYSTEM.Mirror.GetMirrorNames()
		s mircnt=$LL(mirnames)
		for i=1:1:mircnt {
			s name=$LG(mirnames,i)
			s idx=$SYSTEM.Mirror.MirrorNameToIndex(name)
			if (idx > -1) {
				s curfilecnt=+$SYSTEM.Mirror.GetInfo(2,idx)
				if curfilecnt'=+$G(^SYS("JRNARC","active",name)) {
					s done=0
					i $$mirMain(name) s ^SYS("JRNARC","active",name)=curfilecnt
				}
			}
		}
		i done { ;no new files have been archived in this round
		  ;to purge files that have been archived and are no longer needed for recovery
		  i $p($g(^%SYS("JOURNAL","LIFESPAN","FILE")),",",3) d Purge()
		  q
		}
		h 1 ;to prevent a tight loop
	}
done ;
    	zk ^SYS("JRNARC","pid")
	l -^%JRNARCCHKSCAN
	quit
err ;
	s $zt=""
	s lastref=$zr
	if $G(^SYS("JRNARC",":errors:","SCAN"))'=+$ZTS {
		s ^SYS("JRNARC",":errors:","SCAN")=+$ZTS
		d BACK^%ETN
	}
	d $zu(9,"","Journal Archiving: "_"SCAN^"_$ZN_" caught "_$ZE,1 /* broadcast and log message*/,2  /* Severe error */)
	goto done
}
Purge() public {
  	d Purge^JRNUTIL(-1)
	q
}
PurgeDaemon() public { 
	L +^%JRNARCPURGEDMN:5
	i '$T { ;daemon running
		i $i(^SYS("JRNARC","PURGE")) ;poke the running daemon
		q
	}
	try {
		d $zu(9,"","JRNARC PurgeDaemon Started",0,0  /* Informational message */)
		f  {
			k ^SYS("JRNARC","PURGE")
			; all purge requests queued so far will be met
			d PurgeArchivedFiles()
			f  q:$g(^SYS("JRNARC","PURGE"))  h 1
		}
	} catch {
		d $zu(9,"","JRNARC PurgeDaemon Exit: "_$ze,1 /* broadcast and log message*/,1  /* Warning */)
	}
	L -^%JRNARCPURGEDMN
	q
}
PurgeArchivedFiles() {
	s fileid=$o(^%SYS("JOURNAL","ARCHIVED","-",""),-1,info)
	i fileid {
	  s phyfile=$p(info,",")
	  i $e(phyfile,*)="z" s file=$e(phyfile,1,*-1)
	  e  s file=phyfile
	  i $ZU(78,22,file) g startPurge
	}
	s sub="" f  {
	  s sub=$o(^%SYS("JOURNAL","ARCHIVED",sub))
	  i sub="" q
	  i $e(sub)="-" continue  ;skip "-" and "--" non-mirror entries
	  i $e(sub,*)'="-" continue  ;get mirname"-" entries for mirfilecnt
	  s mirfilecnt=$o(^%SYS("JOURNAL","ARCHIVED",sub,""),-1,fileidsize)
	  i 'mirfilecnt continue
	  s mirname=$e(sub,1,*-1) ;remove the trailing "-"
	  ; fileidsiz = fileid,filesiz
	  s info=^%SYS("JOURNAL","ARCHIVED",mirname,+fileidsize)
	  s phyfile=$p(info,",",2) ;1st field is mirfilecnt
	  i $e(file,*)="z" s file=$e(file,1,*-1)
	  e  s file=phyfile
	  i $ZU(78,22,file) q  ;g startPurge
	}
startPurge ;
  	d Purge^JRNUTIL(-1)
	q
}
 /* Find the latest file that has been compressed 
    input: 
      jrnfile = the latest file to check
      lastcheckedfid = file id of the oldest file to stop checking with
            file id = mirfilecnt,shortname = ^SYS("JRNARC","lastchecked")
    return: 1 = success, 0[...] = not found or error
    output: jrnfile, the latest file that has been compressed on success
 */
getLastCompressed(jrnfile,lastcheckedfid) {
	s rc=0 ;whether a compressed file is found before lastcheckedfid
	f  {
		s info=$zu(78,22,jrnfile,13)
		i info<=0 s rc=0 q  ;jrnfile is nonexistent or invalid journal
		s fileid=$p(info,",",2)_","_$case($ZBITGET($ZVERSION(0),46),0:$case($f(jrnfile,";"),0:$e(jrnfile,*-8-$l($p(jrnfile,".",$l(jrnfile,"."))),*-$case($e(jrnfile,*)="z",0:0,1:1)),:$e(jrnfile,*-8-$l($p(jrnfile,".",$l(jrnfile,"."))),$f(jrnfile,";")-2)),:jrnfile)
		i fileid=lastcheckedfid s rc=0 q  ;done with local file stream
		i $zu(140,1,jrnfile_"z")>0 s rc=1 q  ;jrnfile compressed
	        s rc=##class(%SYS.Journal.File).GetPrev(jrnfile,.prevfile)
		i ('rc) {
			d $zu(9,"","Journal Archiving: "_"error "_$$Format^%qcr(rc,1)_" finding prior journal file from "_jrnfile,1 /* broadcast and log message*/,1  /* Warning */)
			q
		}
		s jrnfile=prevfile
	}
	q rc
}
jrnfilecnt() public {
	; returns the sum of all the jrncnt values for the current
	; journal file and any mirror journal files we're creating.
	; we only add the low 32 bits so that n!=n+1 in our sum
	; (we could use up to 58 bits but 32 is fine).
	s mask=+$ZH("FFFFFFFF")  ;use the low 32 bits of each value
	s cnt=$ZBOOLEAN(+$ZU(78,26),mask,1) ;a&b
	s state=$SYSTEM.Mirror.IsMember() ;0=no, 1=failover, 2=async
	if state=0 quit cnt  ;not a member
	if $SYSTEM.Mirror.IsPrimary() quit cnt ;cnt reflects the primary's active file
	;
	; add in the mirror journal file counts. the point is to get a # that
	; changes to tell us that we should call SCAN again()
	s mirnames=$SYSTEM.Mirror.GetMirrorNames()
	s mircnt=$LL(mirnames)
	s mircntstr=""
	for i=1:1:mircnt {
		s name=$LG(mirnames,i)
		s idx=$SYSTEM.Mirror.MirrorNameToIndex(name)
		if (idx > -1) {
			s info=+$SYSTEM.Mirror.GetInfo(2,idx)
			s cnt=cnt+$ZBOOLEAN(info,mask,1)
			s mircntstr=mircntstr_","_$ZBOOLEAN(info,mask,1)
		}
	}
	s cnt=cnt_mircntstr
	quit cnt
}
 /* locMain does the work of finding the non-mirror journal file
    from the local system. The latest file archived is tracked in 
    ^SYS("JRNARC","lastchecked") so that we know how far back we have 
    to check on the next pass. 
    Searching for local files is handled here and mirror files are in
    the mirMain() subroutine. ##class(%SYS.Journal.File).GetPrev() is
    used to locate journal files in the chain. Then we filter in only the
    non-mirror ones, a la BuildPurgeList^JRNUTIL.
    For local files we walk the chain of journal files from the prev
    journal file field in each file. This lets us walk across the local
    journal file stream and the files created when the system was the 
    primary (if a file doesn't have a previous file listed we use the
    local journal.log to find the prior file). Journal file #'s can reset
    across system starts but the names are unique.
    In mirMain() we can use the mirror journal file count to track where
    we are/find the prior file. mirMain() is used when we're a mirror member
    of any type.
    We walk backwards building a list of files to archive and then we
    process them oldest->newest. If we archive them from newest->oldest it
    creates odd pattern in which files are archived/which aren't.
    Return 1 if no error is encountered and ^SYS("JRNARC","lastchecked") has 
    been updated, in which case the caller (SCAN()) would set 
    ^SYS("JRNARC","active") to current file count.
 */
locMain() PUBLIC  {
	s $ZT="err"
	s loglevel=+$G(^SYS("JRNARC","loglevel"),1)
	; This section handles our local (non-mirrored) journal files
	; lastcheckedfid = mirfilecnt,local file short name
	s lastcheckedfid=$G(^SYS("JRNARC","lastchecked")) 
	s curfile=$zu(78,3) 
	i curfile="" {
		s prevfile=##class(%SYS.Journal.System).GetLastFileName() 
	} else {
		try {
			if $ZU(78,4)  ;current journal offset or <NOTOPEN> error
			;journaling is enabled, back up to the prior file
			s rc=##class(%SYS.Journal.File).GetPrev(curfile,.prevfile)
			i ('rc) {
				d $zu(9,"","Journal Archiving: "_"error "_$$Format^%qcr(rc,1)_" finding prior journal file for "_curfile,1 /* broadcast and log message*/,1  /* Warning */)
				return 0
			}
		} catch {
			s prevfile=curfile
		}
	}
	if prevfile=""||($ZU(78,22,prevfile)<=0) {
		if loglevel>=2 {d $zu(9,"","Journal Archiving: "_"no journal files found prior to "_curfile,0,0  /* Informational message */)}
		q 1
	}
	; The file names here are expected to be the logical ones, w/o the
	; trailing 'z's, even if they are compressed.
	s jrnzip=$zu(69,86) 
	s shortname=$case($ZBITGET($ZVERSION(0),46),0:$case($f(prevfile,";"),0:$e(prevfile,*-8-$l($p(prevfile,".",$l(prevfile,"."))),*-$case($e(prevfile,*)="z",0:0,1:1)),:$e(prevfile,*-8-$l($p(prevfile,".",$l(prevfile,"."))),$f(prevfile,";")-2)),:prevfile)
	; it's possible to have mirror files in local stream if it was the
	; primary before.
	s startmirfilecnt=(+$P($ZU(78,22,prevfile,13),",",2)) ;>0 if a mirror file
	s startfileid=startmirfilecnt_","_shortname
	s filecnt=0
	s errcnt=0
	s fileid=startfileid
	k ^ISC("JRNARC","worklist")
	f  {
		q:fileid=lastcheckedfid  ;done with local file stream
		; use the canonical form consistent with ArchiveOne()
		s jrnfile=$zu(12,prevfile,0,4) 
		; skip the file if it is a mirror file (to be handled by
		; mirMain()) or has been archived.
		i 'fileid,$g(^%SYS("JOURNAL","ARCHIVED","-",($p(shortname,".")_$e(10000000000+$p(shortname,".",2),2,11))))="" {
		    	s ^ISC("JRNARC","worklist",$i(filecnt))=jrnfile
			i loglevel>=2 {
				d $zu(9,"","Journal Archiving: "_"to archive #"_filecnt_"=/"_jrnfile_"/",0,0  /* Informational message */)
			}
		}
	        s rc=##class(%SYS.Journal.File).GetPrev(jrnfile,.prevfile)
		i ('rc) {
			d $zu(9,"","Journal Archiving: "_"error "_$$Format^%qcr(rc,1)_" finding prior journal file from "_jrnfile,1 /* broadcast and log message*/,1  /* Warning */)
			s errcnt=errcnt+1
			q
		}
		s info=$zu(78,22,prevfile,13)
		i info<=0 q  ;nonexistent or invalid journal
		s mirfilecnt=$p(info,",",2)
		s shortname=$case($ZBITGET($ZVERSION(0),46),0:$case($f(prevfile,";"),0:$e(prevfile,*-8-$l($p(prevfile,".",$l(prevfile,"."))),*-$case($e(prevfile,*)="z",0:0,1:1)),:$e(prevfile,*-8-$l($p(prevfile,".",$l(prevfile,"."))),$f(prevfile,";")-2)),:prevfile)
		s fileid=mirfilecnt_","_shortname
	}
	; now archive the non-mirror files from oldest to latest
	s zipsuffix=$s(jrnzip:"z",1:"")
	s prevfile="",filecnt="" f  { ;filecnt is NOT actual filecnt, w/ 1 for the latest file
		s filecnt=$o(^ISC("JRNARC","worklist",filecnt),-1,jrnfile)
		i filecnt="" q
		; if jrnfile doesn't exist in compressed form, it's an error
		; that would prevent a new checkpoint from being created so
		; that we can come back to try again next time.
		s filecntstatus=$zu(78,22,jrnfile,12) ;7,jrnfilecnt
		if filecntstatus {
			if ($zu(140,1,jrnfile_zipsuffix)<0)||($$ArchiveOne(jrnfile_zipsuffix)<=0) {
				;Either jrnfile hasn't been compressed when compression is on
				;or ArchiveOne() has logged a message about the failure
				s errcnt=errcnt+1
				i $g(prevfile)'="" {
					s ^SYS("JRNARC","lastchecked")="0,"_$case($ZBITGET($ZVERSION(0),46),0:$case($f(prevfile,";"),0:$e(prevfile,*-8-$l($p(prevfile,".",$l(prevfile,"."))),*-$case($e(prevfile,*)="z",0:0,1:1)),:$e(prevfile,*-8-$l($p(prevfile,".",$l(prevfile,"."))),$f(prevfile,";")-2)),:prevfile)
				}
				q
			}
			s prevfile=jrnfile
		}
	}
	if 'errcnt {
		; if we got back to the file we last checked or if lastchecked
		; wasn't defined, then record where we started as the new
		; target and we won't recheck these files again
		s ^SYS("JRNARC","lastchecked")=startfileid
	   	if loglevel>=2 {d $zu(9,"","Journal Archiving: "_" lastchecked set to /"_startfileid_"/",0,0  /* Informational message */)}
	}
	k ^ISC("JRNARC","worklist")
	q 'errcnt
err ;
	s $zt=""
	s lastref=$zr
	if $G(^SYS("JRNARC",":errors:","locMain"))'=+$ZTS {
		s ^SYS("JRNARC",":errors:","locMain")=+$ZTS
		D BACK^%ETN
	}
	d $zu(9,"","Journal Archiving: "_"locMain^"_$ZN_" caught "_$ZE,1 /* broadcast and log message*/,2  /* Severe error */)
	q -1
}
Primary() PUBLIC  {
	s $ZT="err"
	s loglevel=+$G(^SYS("JRNARC","loglevel"),1)
	s mirname=$P($G(^SYS("MIRRORSET")),"^",2)
	i mirname="" {
		d $zu(9,"","Journal Archiving: "_"unable to determine mirrorset name on primary",1 /* broadcast and log message*/,1  /* Warning */)
		q -1
	}
	s lastcheckedmfc=$G(^SYS("JRNARC","lastchecked",mirname)) ;mirfilecnt
	s lastcheckedfid=$G(^SYS("JRNARC","lastchecked")) ;mirfilecnt,shortname
	; mirfilecnt in lastcheckedfid could be 0
	s curfile=$zu(78,3) 
	i curfile="" { ;should not happen on a primary
		d $zu(9,"","Journal Archiving: "_"journaling disabled on primary",1 /* broadcast and log message*/,1  /* Warning */)
		q -1
	}
	try {
		if $ZU(78,4)  ;current journal offset or <NOTOPEN> error
		;journaling is enabled, back up to the prior file
		s rc=##class(%SYS.Journal.File).GetPrev(curfile,.prevfile)
		i ('rc) {
			d $zu(9,"","Journal Archiving: "_"error "_$$Format^%qcr(rc,1)_" finding prior journal file for "_curfile,1 /* broadcast and log message*/,1  /* Warning */)
			return -1
		}
	} catch {
		; <NOTOPEN> from $zu(78,4) when journaling is off,
		; which should not happen on a primary
		;s prevfile=curfile 
		d $zu(9,"","Journal Archiving: "_"error "_$ze_" on primary",1 /* broadcast and log message*/,1  /* Warning */)
		return -1
	}
	if prevfile=""||($ZU(78,22,prevfile)<=0) {
		i loglevel>=2 {d $zu(9,"","Journal Archiving: "_"no journal files found prior to  "_curfile,0,0  /* Informational message */)}
		q 1
	}
	; The file names here are expected to be the logical ones, w/o the
	; trailing 'z's, even if they are compressed.
	s jrnzip=$zu(69,86) 
	s shortname=$case($ZBITGET($ZVERSION(0),46),0:$case($f(prevfile,";"),0:$e(prevfile,*-8-$l($p(prevfile,".",$l(prevfile,"."))),*-$case($e(prevfile,*)="z",0:0,1:1)),:$e(prevfile,*-8-$l($p(prevfile,".",$l(prevfile,"."))),$f(prevfile,";")-2)),:prevfile)
	s startmirfilecnt=(+$P($ZU(78,22,prevfile,13),",",2)) ;>0 if a mirror file
	s startfileid=startmirfilecnt_","_shortname
	s minmirfcnt=startmirfilecnt ;to compare it with lastcheckedmfc later
	s filecnt=0
	s errcnt=0
	s fileid=startfileid
	k ^ISC("JRNARC","worklist")
	; first collect local mirror journal files in current session if any
	; and find the latest non-mirror journal file if any
	i startmirfilecnt { ;prevfile is a mirror file
		f  {
			q:fileid=lastcheckedfid  ;done
			; use the canonical form consistent with ArchiveOne()
			s jrnfile=$zu(12,prevfile,0,4) 
			; fileid = mirfilecnt_","_shortname; +fileid = mirfilecnt
			i $g(^%SYS("JOURNAL","ARCHIVED",mirname_"-",+fileid))="" {
			    	s ^ISC("JRNARC","worklist",+fileid)=jrnfile
				i loglevel>=2 { d $zu(9,"","Journal Archiving: "_"to archive #"_filecnt_"=/"_jrnfile_"/",0,0  /* Informational message */) }
			}
		        s rc=##class(%SYS.Journal.File).GetPrev(jrnfile,.prevfile)
			i ('rc) {
				d $zu(9,"","Journal Archiving: "_"error "_$$Format^%qcr(rc,1)_" finding prior journal file from "_jrnfile,1 /* broadcast and log message*/,1  /* Warning */)
				s errcnt=errcnt+1
				q
			}
			s info=$zu(78,22,prevfile,13)
			i info<=0 q  ;nonexistent or invalid journal
			s mirfilecnt=$p(info,",",2)
			; fileid and shortnam are needed below even if prevfile is not a mirror file
			s shortname=$case($ZBITGET($ZVERSION(0),46),0:$case($f(prevfile,";"),0:$e(prevfile,*-8-$l($p(prevfile,".",$l(prevfile,"."))),*-$case($e(prevfile,*)="z",0:0,1:1)),:$e(prevfile,*-8-$l($p(prevfile,".",$l(prevfile,"."))),$f(prevfile,";")-2)),:prevfile)
			s fileid=mirfilecnt_","_shortname
			i 'mirfilecnt q  ;prevfile is NOT a mirror file
			s minmirfcnt=mirfilecnt
		}
	} else { ;get the last mirfilecnt from previous mirror session
		; covering the case where minmirfcnt is 0
		s mirfilecnt=$p($zu(78,22,curfile,13),",",2)
		i 'mirfilecnt { ;should not happen on a primary
			d $zu(9,"","Journal Archiving: "_"no mirror file on primary",1 /* broadcast and log message*/,1  /* Warning */)
			q -1
		}
		s startmirfilecnt=mirfilecnt-1 ;the new "lastchecked" filecnt
		s minmirfcnt=mirfilecnt
		i loglevel>=2 { d $zu(9,"","Journal Archiving: "_"minmirfcnt="_minmirfcnt_",startmirfilecnt="_startmirfilecnt,0,0  /* Informational message */) }
	}
	;minmirfcnt is the mirfilecnt of the oldest mirror file in current session
	;minmirfcnt-1 is the mirfilecnt of the last mirror file from previous session
	; minmirfcnt is the least mirror file count on the local file stream
	; after lastcheckedfid. Get all mirror files, if any, on non-local 
	; mirror stream between minmirfcnt-1 and lastcheckedmfc+1 (inclusive).
	; note that minmirfcnt-1 < current mirfilecnt.
	; Do NOT modify fileid, prevfile or shortnam, which will be used later.
	i loglevel>=2 { d $zu(9,"","Journal Archiving: "_"mirfcnt="_($g(minmirfcnt)-1)_":-1:"_($g(lastcheckedmfc)+1),0,0  /* Informational message */) }
	f mirfcnt=(minmirfcnt-1):-1:(lastcheckedmfc+1) {
		s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(mirfcnt,mirname)
		i rc<=0 {
			i loglevel>=2 { d $zu(9,"","Journal Archiving: "_"mirfcnt "_mirfcnt_"="_rc,0,0  /* Informational message */) }
			q
		}
		s jrnfile=$P(rc,",",2)
		;skip nonexistent or invalid journal files
	        i $ZU(78,22,jrnfile)<=0 {
			i loglevel>=2 { d $zu(9,"","Journal Archiving: "_"skip "_jrnfile,0,0  /* Informational message */) }
			continue  
		}
		; skip the file if it has been archived (see ArchiveOne())
		i $g(^%SYS("JOURNAL","ARCHIVED",mirname_"-",mirfcnt))="" {
		    	s ^ISC("JRNARC","worklist",mirfcnt)=jrnfile
			i loglevel>=2 {
				d $zu(9,"","Journal Archiving: "_"to archive #"_filecnt_"=/"_jrnfile_"/",0,0  /* Informational message */)
			}
		}
	}
	;now collect local non-mirror journal files from previous sessions
	; use fileid, prevfile and shortnam values
	i 'fileid { ;prevfile is a non-mirror file
		f  {
			q:fileid=lastcheckedfid  ;done with local file stream
			; use the canonical form consistent with ArchiveOne()
			s jrnfile=$zu(12,prevfile,0,4) 
			; skip the file if it has been archived (see ArchiveOne())
			i $g(^%SYS("JOURNAL","ARCHIVED","-",($p(shortname,".")_$e(10000000000+$p(shortname,".",2),2,11))))="" {
				;non-mirror files have <0 indices, preceding all mirror files
			    	s ^ISC("JRNARC","worklist",$i(filecnt,-1))=jrnfile
				i loglevel>=2 { d $zu(9,"","Journal Archiving: "_"to archive #("_filecnt_")=/"_jrnfile_"/",0,0  /* Informational message */) }
			}
			f  {
			        s rc=##class(%SYS.Journal.File).GetPrev(jrnfile,.prevfile)
				i ('rc) {
					d $zu(9,"","Journal Archiving: "_"error "_$$Format^%qcr(rc,1)_" finding prior journal file from "_jrnfile,1 /* broadcast and log message*/,1  /* Warning */)
					s errcnt=errcnt+1
					q
				}
				s rc=$zu(78,22,prevfile,13)
				i rc<=0 q  ;nonexistent or invalid journal
				i '$p(rc,",",2) q  ;prevfile is a non-mirror file
				s jrnfile=prevfile
			}
			i rc<=0 q  ;error or nonexistent/invalid journal
			s shortname=$case($ZBITGET($ZVERSION(0),46),0:$case($f(prevfile,";"),0:$e(prevfile,*-8-$l($p(prevfile,".",$l(prevfile,"."))),*-$case($e(prevfile,*)="z",0:0,1:1)),:$e(prevfile,*-8-$l($p(prevfile,".",$l(prevfile,"."))),$f(prevfile,";")-2)),:prevfile)
			s fileid="0,"_shortname
		}
	}
	; now archive the files, non-mirror ones followed by mirror ones, 
	; from oldest to latest within non-mirror and mirror ones (resp.)
	s zipsuffix=$s(jrnzip:"z",1:"")
	s filecnt="" 
	f  {
		s filecnt=$o(^ISC("JRNARC","worklist",filecnt),1,jrnfile)
		i filecnt>=0 q  ;stop on "" (=0) or the first mirror file (>0)
		i $zu(140,1,jrnfile_zipsuffix)<0||($$ArchiveOne(jrnfile_zipsuffix)<=0) {
			;Either jrnfile hasn't been compressed or 
			;ArchiveOne() has logged a message about the failure
			s errcnt=errcnt+1
			i loglevel>=2,$zu(140,1,jrnfile_zipsuffix)<0 {d $zu(9,"","Journal Archiving: "_jrnfile_zipsuffix_" not available yet",0,0  /* Informational message */)}
			s filecnt=$o(^ISC("JRNARC","worklist",filecnt),-1,jrnfile) 
			i filecnt'="" { ;last archived non-mirror file
				s ^SYS("JRNARC","lastchecked")="0,"_$case($ZBITGET($ZVERSION(0),46),0:$case($f(jrnfile,";"),0:$e(jrnfile,*-8-$l($p(jrnfile,".",$l(jrnfile,"."))),*-$case($e(jrnfile,*)="z",0:0,1:1)),:$e(jrnfile,*-8-$l($p(jrnfile,".",$l(jrnfile,"."))),$f(jrnfile,";")-2)),:jrnfile)
			}
			g exit
		}
	}
	s filecnt=0 ; for mirror filecnt > 0
	f  { ;filecnt is actual mirror filecnt
		s filecnt=$o(^ISC("JRNARC","worklist",filecnt),1,jrnfile) 
		i filecnt="" q
		i $zu(140,1,jrnfile_zipsuffix)<0||($$ArchiveOne(jrnfile_zipsuffix,mirname)<=0) {
			;Either jrnfile hasn't been compressed or 
			;ArchiveOne() has logged a message about the failure
			s errcnt=errcnt+1
			i loglevel>=2,$zu(140,1,jrnfile_zipsuffix)<0 {d $zu(9,"","Journal Archiving: "_" "_mirname_" "_jrnfile_zipsuffix_" not available yet",0,0  /* Informational message */)}
			s filecnt=$o(^ISC("JRNARC","worklist",filecnt),-1,jrnfile) 
			i filecnt>0 { ;last archived mirror file
		        	s ^SYS("JRNARC","lastchecked",mirname)=filecnt
				s ^SYS("JRNARC","lastchecked")=filecnt_","_$case($ZBITGET($ZVERSION(0),46),0:$case($f(jrnfile,";"),0:$e(jrnfile,*-8-$l($p(jrnfile,".",$l(jrnfile,"."))),*-$case($e(jrnfile,*)="z",0:0,1:1)),:$e(jrnfile,*-8-$l($p(jrnfile,".",$l(jrnfile,"."))),$f(jrnfile,";")-2)),:jrnfile)
			}
			q
		}
	}
	if 'errcnt {
		; if we got back to the file we last checked or if lastchecked
		; wasn't defined, then record where we started as the new
		; target and we won't recheck these files again
		s ^SYS("JRNARC","lastchecked")=startfileid
		s ^SYS("JRNARC","lastchecked",mirname)=startmirfilecnt
	   	i loglevel>=2 {d $zu(9,"","Journal Archiving: "_"lastchecked set to /"_startfileid_"/ for local and /"_startmirfilecnt_"/ for /"_mirname_"/",0,0  /* Informational message */)}
	}
exit ;
	k ^ISC("JRNARC","worklist")
	q 'errcnt
err ;
	s $zt=""
	s lastref=$zr
	if $G(^SYS("JRNARC",":errors:","Primary"))'=+$ZTS {
		s ^SYS("JRNARC",":errors:","Primary")=+$ZTS
		D BACK^%ETN
	}
	d $zu(9,"","Journal Archiving: "_"Primary^"_$ZN_" caught "_$ZE,1 /* broadcast and log message*/,2  /* Severe error */)
	k ^ISC("JRNARC","worklist")
	q -1
}
mirMain(mirname) PUBLIC {
	s $zt="err"
	s loglevel=+$G(^SYS("JRNARC","loglevel"),1)
	s mirname=$zcvt(mirname,"U")
	s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)
	if +rc<=0 {
	    if $G(^SYS("JRNARC","MirrorWarn",mirname))'=+$ZTS {
			d $zu(9,"","Journal Archiving: "_"failed to read last mirror journal file from log for "_mirname,1 /* broadcast and log message*/,1  /* Warning */)
			s ^SYS("JRNARC","MirrorWarn",mirname)=+$ZTS 
	    }
		quit -1
	}
	s lastchecked=+$G(^SYS("JRNARC","lastchecked",mirname)) ;mirfilecnt
	s filecnt=+rc
	s jrnfile=$P(rc,",",2)
	s validend=+$p($zu(78,22,jrnfile,99),",",16+1)
	while rc>0,'validend {
		s filecnt=filecnt-1
		s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)		
		s jrnfile=$P(rc,",",2)
		s validend=+$p($zu(78,22,jrnfile,99),",",16+1)
	}
	q:filecnt=lastchecked 1
	if rc<=0 {
		if loglevel>=2 {
			d $zu(9,"","Journal Archiving: "_"Did not find any journal files with a valid end for "_mirname,0,0  /* Informational message */)
		}
		quit -1
	}
	;filecnt is the last mirror file with valid end 
	;the one prior to it must be complete and is the latest file to archive
	;note that filecnt'=lastchecked
	s jrnzip=$zu(69,86) 
	s startfilecnt=filecnt,filecnt=filecnt+1 ;to make up for -1 below
	; Collect a list of the files to archive from latest to oldest
	k ^ISC("JRNARC","worklist")
	s errcnt=0
	f  {
		s filecnt=filecnt-1
		i filecnt=lastchecked q
		s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)		
		i rc<=0 q
		s jrnfile=$P(rc,",",2)
		;skip nonexistent or invalid journal files
	        i $ZU(78,22,jrnfile)<=0 continue  
		; skip the file if it has been archived (see ArchiveOne())
		i $g(^%SYS("JOURNAL","ARCHIVED",mirname_"-",filecnt))="" {
		    	s ^ISC("JRNARC","worklist",filecnt)=jrnfile
			i loglevel>=2 {
				d $zu(9,"","Journal Archiving: "_"to archive #"_filecnt_"=/"_jrnfile_"/",0,0  /* Informational message */)
			}
		}
	}
	; Archive the files from oldest to latest
	s zipsuffix=$s(jrnzip:"z",1:"")
	s prevfilecnt="",filecnt="" 
	f  { ;filecnt is actual mirror filecnt
		s filecnt=$o(^ISC("JRNARC","worklist",filecnt),1,jrnfile) 
		i filecnt="" q
		i $zu(140,1,jrnfile_zipsuffix)<0||($$ArchiveOne(jrnfile_zipsuffix,mirname)<=0) {
			;Either jrnfile hasn't been compressed or 
			;ArchiveOne() has logged a message about the failure
			i loglevel>=2,$zu(140,1,jrnfile_zipsuffix)<0 {d $zu(9,"","Journal Archiving: "_" "_mirname_" "_jrnfile_zipsuffix_" not available yet",0,0  /* Informational message */)}
			s errcnt=errcnt+1
		        s ^SYS("JRNARC","lastchecked",mirname)=filecnt-1 ;last archived
			q
		}
	}
	i 'errcnt {
		s ^SYS("JRNARC","lastchecked",mirname)=startfilecnt
	   	i loglevel>=2 {d $zu(9,"","Journal Archiving: "_" "_mirname_" lastchecked set to /"_startfilecnt_"/",0,0  /* Informational message */)}
	}
	k ^ISC("JRNARC","worklist")
	quit 'errcnt
err ;
	s $zt=""
	s lastref=$zr
	if $G(^SYS("JRNARC",":errors:","mirMain"))'=+$ZTS {
		s ^SYS("JRNARC",":errors:","mirMain")=+$ZTS
		d BACK^%ETN
	}
	d $zu(9,"","Journal Archiving: "_"mirMain^"_$ZN_" caught "_$ZE,1 /* broadcast and log message*/,2  /* Severe error */)
	quit -1
}
elapsedSec(st,end) {
	s std=+st,sts=$P(st,",",2)
	s endd=+end,ends=$P(end,",",2)
	; 86400 = 24*60*60
	s sec=(endd-std)*86400 + (ends - sts)
	quit sec
}
ArchiveOne(file,mirname) PUBLIC {
 i $ZU(78,22,file)'>0 q 0  ;file is gone (JRNCHECK() covers compressed file)
 i $e(file,*)="z" {  ;to archive a compressed file
   s phyfile=$zu(12,file,0,4)
   s file=$e(file,1,*-1)
   s filesize=$zu(140,1,phyfile) 
   i filesize<0 {
       d $zu(9,"","Journal Archiving: "_phyfile_" doesn't exist",1 /* broadcast and log message*/,2  /* Severe error */)
       q 0 
   }
 } else { ;to archive the file, compressed or not
   ; test whether the file is in its compressed form, since the file exists
   ; assuming jrnzip is blocked at the moment
   s file=$zu(12,file,0,4) ;ensure consistent file path stored in "ARCHIVED"
   s phyfile=file ;physical file path
   s filesize=$zu(140,1,phyfile) 
   i filesize<0 {
     s phyfile=file_"z" ;must be a compressed file
     s filesize=$zu(140,1,phyfile) 
     i filesize<0 {
       d $zu(9,"","Journal Archiving: "_file_" doesn't exist",1 /* broadcast and log message*/,2  /* Severe error */)
       q 0 
     }
   }
 }
 s mirfilecnt=(+$P($ZU(78,22,file,13),",",2))
 s rc=##class(SYS.ArchiveManager).PutFile(phyfile,$g(^%SYS("JOURNAL","ARCHIVE")),.option)
 i ('rc) {
   s errmsg=$System.Status.GetErrorText(rc) 
   d $zu(9,"","Journal Archiving: "_errmsg,1 /* broadcast and log message*/,2  /* Severe error */)
   q 0
 }
 s shortname=$case($ZBITGET($ZVERSION(0),46),0:$case($f(file,";"),0:$e(file,*-8-$l($p(file,".",$l(file,"."))),*-$case($e(file,*)="z",0:0,1:1)),:$e(file,*-8-$l($p(file,".",$l(file,"."))),$f(file,";")-2)),:file)
 s id=($p(shortname,".")_$e(10000000000+$p(shortname,".",2),2,11))
 ; mirname="" or "-" are treated as non-mirror
 i $g(mirname,"-")="-" {
   s ^%SYS("JOURNAL","ARCHIVED","-",id)=phyfile_","_option
   s ^%SYS("JOURNAL","ARCHIVED","--",file)=id
   d $zu(9,"","ARCHIVE: "_phyfile,(0>0),0)
 } else {
   s ^%SYS("JOURNAL","ARCHIVED",mirname,id)=mirfilecnt_","_phyfile_","_option
   s ^%SYS("JOURNAL","ARCHIVED",mirname_"-",mirfilecnt)=id_","_filesize
   d $zu(9,"","[MIRRORING] ARCHIVE: "_phyfile,(0>0),0)
 }
 q 1
}

JRNRESTB^INT^1^67214,47330
JRNRESTB ;Restore Journal from a File, Part II ;$Change: 7440104 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	; Revision: $Id: //iris/2024.1.3/databases/sys/rtn/journal/jrnrestb.mac#1 $
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/_syMirror.inc#1 $ ($Change: 7440104 $) */
        /* Initializing is the state a member has at startup until it
           gets to wait^MIRRORMGR for the 1st time. At that point it has 
           either become the backup or primary or we set the role to null
           to indicate that it is up and running as opposed to still getting
           started */
				    /* Arbiter failover rules are in effect */
				    /* Agent contact is required */
					/* IsOtherNodeDown^ZMIRROR */
				/* The client supports the arbiter */
			 	/* This system is connected to the arbiter */
		  		/* The other failover member is connected to the arbiter */
		  		/* Either the QOSTimeout changed or the arbiter address changed.
		  		   we should look up the current values and use them */
				/* Arbiter job shoud close the connection and exit. The
				   retry routine can restart the arbiter if conditions
				   warrent. Generally used with clearing ArbiterSupported
				   when the backup is removed or demoted. Cleared when
				   the arbiter exits (eg. its a one time flag). */
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/FILEINC.inc#1 $ ($Change: 7440104 $) */
INT(RestTime,jrnlist,dejrn,restopt,disjrn,ROLLJRN,ZJRNUSE,PriorList,DISMDB,LocalJrn,JrnDirList,StartOffset) ;
 n (RestTime,jrnlist,dejrn,restopt,disjrn,ROLLJRN,ZJRNUSE,PriorList,DISMDB,LocalJrn,JrnDirList,StartOffset) 
 s $zt="INTerr"
 i $g(RestTime)="" s RestTime=$zdt($h,8)
 s QUIETMODE=1,notresto=0,jrnstop=0
 s ALL='$d(dejrn)
 i $o(jrnlist(""),1,firstfile)
 i $o(jrnlist(""),-1,lastfile)
 s djfirst=$case($ZBITGET($ZVERSION(0),46),0:$case($f(firstfile,";"),0:$e(firstfile,*-8-$l($p(firstfile,".",$l(firstfile,"."))),*-$case($e(firstfile,*)="z",0:0,1:1)),:$e(firstfile,*-8-$l($p(firstfile,".",$l(firstfile,"."))),$f(firstfile,";")-2)),:firstfile) ;used in nextfileopen (can be removed??)
 s djlast=$case($ZBITGET($ZVERSION(0),46),0:$case($f(lastfile,";"),0:$e(lastfile,*-8-$l($p(lastfile,".",$l(lastfile,"."))),*-$case($e(lastfile,*)="z",0:0,1:1)),:$e(lastfile,*-8-$l($p(lastfile,".",$l(lastfile,"."))),$f(lastfile,";")-2)),:lastfile)
 i $g(StartOffset) s DEJRNSTART=StartOffset_","_firstfile
 s nojrn=$s($g(disjrn):$$STOP^%SYS.NOJRN(),1:0)
 s checkerr=1 ; **** set to 0 during debugging
 s nullsubstat=$zu(68,1,1) 
 s prompt=0
 i $g(ROLLJRN) d ScanForOpenTrans
 s jrnlist="" ;important to nextfile
 s restopt(1)=""
 s restopt(2)=""
 d restore^JRNRESTF(.fastrest) 
 i 'fastrest {
   i '$$InitSort() {
     s disablesort=1,(cachetempmaxblks,sortchunklimit)=0
     d logmsg("Sorting is disabled",0,1)
   }
   s numrestjobs=$System.Util.NumberOfCPUs() ;# of concurrent restore jobs, limited by # of CPUs
   s %UI="CHUI" ;used in output^%Wprim in COS-styled dejournaling
   d multrest
 }
 d ROLLBACK
 q ""
INTerr s $zt=""
 i $g(jrnstat) d ENABLE^%SYS.NOJRN
 q $ze
main ;
 i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
 n checkerr,%jrnfile,%curfile,nojrn,disjrn
 n clu,adr,type,ALL,tranopen,lastindex,badtran
 n PriorList,ScanList ;a list of journal files prior to the 1st processed file
 n LocalJrn,JrnFileList
 n nextadr,lastadr,cnt,prefstrategy,sizmod,rc,sfn
 n r,dir,new,cd,glo,gnode,dirnam,nomount,canonic,zjrnerr,zjrnerrmsg
 n dbcol  ;stores collations of the databases involved
 n globname,sortcnt ;sortcnt(globname): # of sorted SETs per global
 n numrestjobs s numrestjobs=$System.Util.NumberOfCPUs() ;# of concurrent restore jobs, limited by # of CPUs
 n percentdone ;percentage of restoring done by a job
 n disablesort ;disable sorting so that sets/kills are NOT applied out of order
 n shrid ;if set, use fast dejournaling instead of sorting and multi-daemon
 n fastrest ;=1 or 2, with 2 probably faster than 1
 n clrsw10 ;whether to clear switch 10 (fastrest requires switch 10 OFF)
 n cachetempblksiz,cachetempmaxblks,sortchunklimit
 n resterr ;error message generated by caller of ztrap and passed upward
 n sorterr,sortbegerr,sortenderr,globerr 
 s (sorterr,sortbegerr,sortenderr,globerr)=0
 n restopt s restopt="" ;behavior of restore daemons in certain error events
 n clumember,numclu,minseq,maxseq,maxclumstart,private
 n newref,oldref
 n colseq,curcol,x,djid,clutrans
 i $G(fromrest)'=1,'$G(QUIETMODE) n dejrn,global
 n dejrnNodup
 n jrnstop s jrnstop=0
 s nojrn=0
 s checkerr=1 ; **** set to 0 during debugging
 i '$d(%UI) n %UI s %UI="CHUI"
 n JrnDirList,statnode,trannode,i,err,savedisablesort,xOS,a
 i checkerr s $ze="",$zt="exitmain"
 n nullsubstat s nullsubstat=$zu(68,1,1) 
 i '$$what^JRNRESTD() q  ;  determine what should be dejournalled
 s %curfile=$$curfile() ; current journal file, or "" if none enabled
 N curfile,jrnfile,djfirst,djlast,prompt,curdir,altdir,prefix,lookpath   
 n tempnode,promptnode,Tempnode ;for prompt=1 & fastrest=2, passing jrnlist
 N ROLLJRN,dj,notresto,maxsize,shortnam,expqty
 n jrnlist ;a number-index array of the journal files to be processed
 S dj=0,ROLLJRN=0,notresto=0 ;HYY035
 n RestTime s RestTime=$zdt($h,8)
 n RestCount s RestCount=0
 L +^SYS("RESTORE","JOURNAL"):10 e  w:'$g(QUIETMODE) !,*7,"Acquiring lock on "_$name(^SYS("RESTORE","JOURNAL"))_" timed out",!,"Warning on concurrent journal restores is disabled" g postwarnconcur
 i $g(^SYS("RESTORE","JOURNAL")) d  i 'RestCount L -^SYS("RESTORE","JOURNAL") g exitmain
 . i $g(QUIETMODE) d $zu(9,"","WARNING: Multiple copies of journal restores appear to be running simultaneously. (If that is incorrect, reset "_$name(^SYS("RESTORE","JOURNAL"))_" to 0 after restore completes.)",(0>0),0) i 1
 . e  d  i $$YN("Continue","N")="N" q
 . . w !,?7,"***WARNING: Another journal restore appears to be going on"
 . . w !,"or perhaps a previous journal restore was terminated improperly."
 . . w !,"In the latter case, you may issue the command"
 . . w !?5,"SET "_$name(^SYS("RESTORE","JOURNAL"))_"=0"
 . . w !,"after this restore operation completes."
 . s RestCount=$i(^SYS("RESTORE","JOURNAL")),$p(^SYS("RESTORE","JOURNAL"),",",RestCount)=RestTime,$p(^SYS("RESTORE","JOURNAL"),":")=RestCount
 i '$g(^SYS("RESTORE","JOURNAL")) {
   s RestCount=1
   i (fromrest=8)&&$$CURRENT^%SYS.NOJRN() {
     d DISABLE^%SYS.NOJRN
     s ^SYS("RESTORE","JOURNAL")="1:"_RestTime
     d ENABLE^%SYS.NOJRN
   } else {
     s ^SYS("RESTORE","JOURNAL")="1:"_RestTime
   }
 }
 L -^SYS("RESTORE","JOURNAL")
postwarnconcur ;
    ; restore one or more journal files
 i $g(QUIETMODE) s CHATTY=0,RC=$$nextquiet^JRNRESTO
 e  D
 . S curfile=$case($ZBITGET($ZVERSION(0),46),0:$case($f(%curfile,";"),0:$e(%curfile,*-8-$l($p(%curfile,".",$l(%curfile,"."))),*-$case($e(%curfile,*)="z",0:0,1:1)),:$e(%curfile,*-8-$l($p(%curfile,".",$l(%curfile,"."))),$f(%curfile,";")-2)),:%curfile)
 . D SETUP^JRNRESTO Q:$G(notresto)  ;HYY073
 . D:jrnstop  
 . . S %curfile=$ZU(78,3),curfile=$case($ZBITGET($ZVERSION(0),46),0:$case($f(%curfile,";"),0:$e(%curfile,*-8-$l($p(%curfile,".",$l(%curfile,"."))),*-$case($e(%curfile,*)="z",0:0,1:1)),:$e(%curfile,*-8-$l($p(%curfile,".",$l(%curfile,"."))),$f(%curfile,";")-2)),:%curfile)
 . . ; prepare for INT^JRNSTART call when we are done
 . . ; curdir, altdir, and prefix are defined in SETUP
 . . S shortnam=curfile,expqty=0,maxsize=$P($ZU(78,22,%curfile,3),",",2)
 . i $g(QUIETMODE),'$g(ROLLJRN) ;don't roll back open transactions
 . e  i $g(fromrest)'=8,'$d(clujrn) d ScanForOpenTrans q:$g(notresto)
 . i $g(fromrest)=8 s fastrest=0 
 . e  d restore^JRNRESTF(.fastrest) i fastrest q
 . e  i '$$InitSort() d  i '($$yesno("Do you want to continue","Y")="Y") s notresto=1 q 
 . . s disablesort=1,(cachetempmaxblks,sortchunklimit)=0
 . . d logmsg("Sorting is disabled",0,1)
 . e  d multrest q
 . d onejobrest
 ; dejrn (or ALL) is used in above restoration. It is not clear to
 ; me whether rolling back partial open transactions is desirable.
 ; For now we ignore dejrn. Maybe we should give the user an option?
ROLLBACK ;
 i 'notresto,$D(tranopen)!$D(badtran) d
 . i $g(QUIETMODE) q:'$g(ROLLJRN)  i 1  ;in QUIETMODE, ROLLJRN decides rollback
 . e  i $$YN("Rollback incomplete transactions",$s($g(ROLLJRN):"Y",1:"N"))="N" q
 . N i s i="" f  s i=$o(^SYS("RESTORE","JOURNAL",RestTime,"Files",i),1,dj) q:i=""  s dj(i)=$p(dj,",")
 . m dj=ScanList 
 . s dj=$g(^SYS("RESTORE","JOURNAL",RestTime,"Files"))_","_$g(ScanList) ;# of files
 . s i=$g(ScanList)
 . ;see if we can find the missing TSTARTs; otherwise we will not
 . ;roll back bad transactions.
 . n a,b,d,d1,d2,f,kill,limit,logmessage
 . n lognewval,logoldval,oldadr
 . i $D(clujrn),$D(tranopen) d
 . . ; If this was a cluster restore then build the dj() array out
 . . ; of the list of open transactions and the clumember(id,"rest")
 . . ; arrays. In a cluster a tranopen() entry has the form:
 . . ;                   adr,shortname,id
 . . ; where id is the cluster member #.
 . . n pid,remsys,line,index,id,transjrn,cnt,jcur,jlast
 . . ;
 . . s pid="" f  s pid=$O(tranopen(pid)) q:pid=""  d
 . . . s remsys="" f  s remsys=$O(tranopen(pid,remsys)) q:remsys=""  d
 . . . . s line=tranopen(pid,remsys)
 . . . . s index=$P(line,",",2)_"J",id=$P(line,",",3)
 . . . . s transjrn(id,index)=""
 . . . . s index=$p($p(line,",",2),":",2)  ;get journal short name
 . . . . s $p(tranopen(pid,remsys),",",2)=index
 . . . . s clutrans(id,pid,remsys)=tranopen(pid,remsys)
 . . ; Now transjrn() contains the list of journal files that contain
 . . ; open transactions for each cluster member. We use the 1st and
 . . ; last journal file in this list to build the list of journal
 . . ; files to process during transaction rollback.
 . . k dj
 . . s dj=0
 . . s id="" f  s id=$O(transjrn(id)) q:id=""  d
 . . . ; combine all restored and unrestored jrn files into one place
 . . . merge clumember(id,"rest")=clumember(id,"files")
 . . . ; get 1st and last journal files for transaction rollback
 . . . s jcur=$O(transjrn(id,"")),jlast=$O(transjrn(id,""),-1)
 . . . ; setup dj(cnt.....cnt+n)=journal files in range of jcur:jlast
 . . . ; transaction rollback runs cnt+n.....cnt so store them 1st->last
 . . . f  d  q:jcur=jlast  s jcur=$O(clumember(id,"rest",jcur)) q:jcur=""
 . . . . s line=clumember(id,"rest",jcur)
 . . . . s dj=dj+1,dj(dj)=$P(clumember(id,"rest",jcur),"^")
 . . . . s djid(dj)=id  ; djid() tracks the id for dj() entries
 . I $D(badtran) D
 . . W !,"There are some open transactions with TSTARTs missing!",! 
 . . i $D(clujrn) d  q
 . . . w !,"This was a cluster restore so we cannot search back for"
 . . . w !,"the corresponding TSTART records. These transactions will"
 . . . w !,"not be rolled back."
 . . Q:$$YN("Look back for missing TSTARTs","N")="N"
 . . D ASKSET("Look back up to file (YYYYMMDD.NNN):",.djfirst)
 . . S %jrnfile="",jrnfile=$case($ZBITGET($ZVERSION(0),46),0:$case($f(dj(1),";"),0:$e(dj(1),*-8-$l($p(dj(1),".",$l(dj(1),"."))),*-$case($e(dj(1),*)="z",0:0,1:1)),:$e(dj(1),*-8-$l($p(dj(1),".",$l(dj(1),"."))),$f(dj(1),";")-2)),:dj(1))
 . . F  Q:'(($p(jrnfile,".")>$p(djfirst,"."))||(($p(jrnfile,".")=$p(djfirst,"."))&&(+$p(jrnfile,".",2)>+$p(djfirst,".",2))))  D
 . . . S %jrnfile=$$FINDPREV(.jrnfile) Q:%jrnfile=""
 . . . D open Q:adr=-1
 . . . D SCANBJRN(jrnfile,.badtran,.tranopen)
 . . . D close
 . . . S i=i-1,dj(i)=%jrnfile
 . . . I '$D(badtran) S jrnfile=djfirst Q
 . S $P(dj,",",2)=i
 . ; since a process cannot have an open transaction and a bad
 . ; transaction (TSTART missing) at the same time, merging badtran
 . ; into tranopen should be OK. Merging makes rollback easier.
 . ;M tranopen=badtran
 . ; For clustered systems we make sure that the tranopen array
 . ; only reflects the open transactions for the cluster member
 . ; who's journal we're restoring. The clumember() array has the
 . ; contents of transopen() organized by cluster member. We use
 . ; the scalar version of djid to track which cluster member is
 . ; currently loaded into transopen. When djid(dj) differs from
 . ; djid we kill off transopen and reload it with clutrans from
 . ; the correct cluster member.
 . i $D(clujrn) s djid=-1 ; there isn't a cluster member #-1
 . n dir s dir="" f  s dir=$o(dejrn(dir)) q:dir=""  s dejrn(dir)=$p(dejrn(dir),",",2,$l(dejrn(dir))) i dejrn(dir)="" s dejrn(dir)=dir
 . k ^||ISC.ROLLBACK.bitset
 . s i="" f  s i=$o(dj(i),-1) q:i=""  d
 . . i $D(clujrn),djid'=djid(i) d
 . . . k tranopen 
 . . . merge tranopen=clutrans(djid(i))
 . . . k clutrans(djid(i))
 . . . s djid=djid(i)
 . . q:'$D(tranopen)
 . . S %jrnfile=dj(i),jrnfile=$case($ZBITGET($ZVERSION(0),46),0:$case($f(%jrnfile,";"),0:$e(%jrnfile,*-8-$l($p(%jrnfile,".",$l(%jrnfile,"."))),*-$case($e(%jrnfile,*)="z",0:0,1:1)),:$e(%jrnfile,*-8-$l($p(%jrnfile,".",$l(%jrnfile,"."))),$f(%jrnfile,";")-2)),:%jrnfile)
 . . d open q:adr=-1
 . . S adr=$zu(78,18,0)
 . . d start^ROLLBACK(.tranopen,adr_","_jrnfile,-1,checkerr,1,.dejrn,"RESTORE")
 . . D close
 . . D CLEAN(jrnfile,.tranopen)
 . K i 
 n tdir,mntst,dismnt
 m nomount=^SYS("RESTORE","JOURNAL",RestTime,"SkipDB")
 i $d(nomount)>1,'$g(QUIETMODE)||$g(DISMDB) { ;DISMDB set via INT()
   s tdir="" f  {
     s tdir=$o(nomount(tdir),1,mntst) q:tdir=""
     i mntst=1 { ;found at least one mounted database that failed to be updated
       s dismnt(tdir)=""
       f  s tdir=$o(nomount(tdir),1,mntst) q:tdir=""  s:mntst=1 dismnt(tdir)=""
       i '$g(QUIETMODE) {
	 d msgout("Some updates of the following database(s) were skipped during journal restore, due to errors. The database(s) might be in an inconsistent state.")
         s tdir="" f  s tdir=$o(dismnt(tdir)) q:tdir=""  d msgout(tdir,4)
         i $$YN("Do you want to dismount the above database(s) (yes/no)")="N" q
       }
       s tdir="" f  s tdir=$o(dismnt(tdir)) q:tdir=""  i $zu(3,tdir)>0 d logmsg(tdir_" dismounted",$g(QUIETMODE),2)
       q
     }
   }
 }
exitmain ;
 k ^||ISC.ROLLBACK.bitset
 s $zt="exitmain1"
 i '$g(zjrnerr),$ze]"" d resterrlog($ze)
 d sortflush()
exitmain1 s $zt=""
     ; restart journaling if we stopped it
 I jrnstop d  ; restart journaling to a new file
 . n curfile,STU,lastfile,jrnall,jrnflag,expqty,maxsize,altdir
 . n curdir,prefix,shortnam,jrnflag,jrninfo,started,err
 . D init^JRNSTART
 . D INT^JRNSTART(curdir,altdir,shortnam,prefix,maxsize,expqty,jrnall,.err)
 . I $G(err)'="" D $zu(9,"","ERROR: "_err,(0>0),0)
 i nojrn d ENABLE^%SYS.NOJRN ; reenable journaling if necessary
 i $g(ZJRNUSE),'$g(zjrnerr) d 
 . i $$YN("Do you want to rename your journal filter","")="Y" d 
 . . x "zl ZJRNFILT zs XJRNFILT zr  zs ZJRNFILT"
 . . w !,"Journal filter ZJRNFILT renamed to XJRNFILT",!
 . . s (ZJRNUSE,ZJRNUSEMARK)=0
 . e  d  
 . . i $$YN("Do you want to delete your journal filter","")="Y" d
 . . . x "zl ZJRNFILT zr  zs ZJRNFILT"
 . . . w !,"Journal filter ZJRNFILT deleted",!
 . . . s (ZJRNUSE,ZJRNUSEMARK)=0
 i $zu(68,1,nullsubstat)  ;restore null subscript setting
 i '$g(RestCount) g exitmain2
 L +^SYS("RESTORE","JOURNAL"):10 e  w:'$g(QUIETMODE) !,*7,"Acquiring lock on "_$name(^SYS("RESTORE","JOURNAL"))_" timed out",!,$name(^SYS("RESTORE","JOURNAL"))_" was NOT updated",! g exitmain2
 i RestCount=1 s ^SYS("RESTORE","JOURNAL")=0
 e  d   ;RestCount>1
 . i '$g(QUIETMODE) d  i $$YN("Reset the count of journal restore to 0")="Y" s ^SYS("RESTORE","JOURNAL")=0 q
 . . w !,"INFO: There appears to be another journal restore going on"
 . . w !,"If NO journal restore is going on, you may fix the count by resetting"
 . s $p(^SYS("RESTORE","JOURNAL"),",",RestCount)=""
 . s $p(^SYS("RESTORE","JOURNAL"),":")=^SYS("RESTORE","JOURNAL")-1
 L -^SYS("RESTORE","JOURNAL")
exitmain2 ;
 q
InitSort() ;
 n cachetempsfn s cachetempsfn=$zu(173) ;sfn of CACHETEMP database
 n cachetempinfo s cachetempinfo=$zu(49,cachetempsfn)
 i +cachetempinfo'=cachetempsfn d logmsg("IRIS"_"TEMP unavailable",0,1) q 0
 s cachetempmaxblks=$p($zu(49,cachetempsfn),",",6) ;max size in blocks
 i 'cachetempmaxblks q 1 ;max size unlimited: sortlimit not used; sorting is ON
 n rc,freeMB,cachetempdir s cachetempdir=$p($zu(49,cachetempsfn,3),"^",2) 
 s rc=##class(SYS.Database).GetDatabaseFreeSpace(cachetempdir,.freeMB)
 i 'rc d logmsg($System.Status.GetErrorText(rc),0,1) q 0 ;disable sorting on err
 s cachetempblksiz=$p($zu(49,cachetempsfn),",",2)
 s freeMB=cachetempmaxblks-$p(cachetempinfo,",",22)*cachetempblksiz/(1024*1024)+freeMB\1
 n sortlimitKB s sortlimitKB=freeMB*1024\4 ;limit for *all* sort jobs, in KBs
 n sortsizeKB s sortsizeKB=$case($v($zu(40,1,31),-1,4),0:1024,:$v($zu(40,1,31),-1,4)) ;memory size for sorting, in KBs
 n numsort s numsort=sortlimitKB\sortsizeKB
 i 'numsort d  q 0 ;not enough free space for even one sort job; disable sorting
 . d logmsg("Insufficient free space ("_freeMB_"MB) in "_"IRIS"_"TEMP for sorting size "_(sortsize\1024)_"MB -- additional "_(sortsizeKB\1024*4-freeMB+1)_"MB free space is required",0,1)
 i numsort<numrestjobs s numrestjobs=numsort
 s sortchunklimit=sortlimitKB*1024\$ZU(40,0,20)
 q 1
ScanForOpenTrans ;
 n firstpath,lastpath,jrnfilecnt,minxfilecnt,minxfileoff,name
 i $d(JrnDirList) m lookpath=JrnDirList ;need it to locate files on PriorList
 s $zt="ErrorScanForOpenTrans"
 i $d(jrnlist) {
   i $o(jrnlist(""),-1,lastpath)
   i $o(jrnlist(""),1,firstpath)
 } elseif $d(JrnFileList) { ;we have a list of source journal files to restore
   i $o(JrnFileList(""),1,firstpath)
   s name=$$GetJrnFileName(firstpath)
   s firstpath=$$FULLPATH(name)
   i firstpath="" w !,*7,"*** Unable to locate journal file ",name,! zt "FILE"
   i $o(JrnFileList(""),-1,lastpath)
   s name=$$GetJrnFileName(lastpath)
   s lastpath=$$FULLPATH(name)
   i lastpath="" w !,*7,"*** Unable to locate journal file ",name,! zt "FILE"
 } else {
   s lastpath=$$FULLPATH(djlast)
   s firstpath=$$FULLPATH(djfirst)
 }
 s minxfilecnt=$zu(78,22,lastpath,18)
 i minxfilecnt<=0 w !,*7,"*** ",lastpath_$case(+minxfilecnt,0:" does not exist",:" is not a journal file"),! zt "FILE"
 s minxfilecnt=$p(minxfilecnt,",",2)
 s jrnfilecnt=$zu(78,22,firstpath,12)
 i jrnfilecnt<=0 w !,*7,"*** ",firstpath_$case(+jrnfilecnt,0:" does not exist",:" is not a journal file"),! zt "FILE"
 s jrnfilecnt=$p(jrnfilecnt,",",2)
 i minxfilecnt>jrnfilecnt q  ;no open trans prior to the 1st file
 i minxfilecnt=jrnfilecnt {
   i '$g(DEJRNSTART) q  ;no open trans prior to the 1st file
   ;i $p(DEJRNSTART,",",2)=firstpath (sanity check??)
   s minxfileoff=$zu(78,22,lastpath,19)
   i minxfileoff<=0 w !,*7,"*** ",lastpath_$case(+minxfileoff,0:" does not exist",:" is not a journal file"),! zt "FILE"
   s minxfileoff=$p(minxfileoff,",",2)
   i minxfileoff>=DEJRNSTART q  ;no open trans prior to the start of restore
   w !,"To scan the first journal file for open transactions --"
   d ScanOneJrnForOpenTrans($p(DEJRNSTART,",",2),+DEJRNSTART)
   q
 } 
 n index,jrnfpath,curfilecnt,jrnstop
 i $d(PriorList) {
   s index="" f  {
     s index=$o(PriorList(index),-1,jrnfpath) 
     i index="" w !,*7,"*** Missing previous ",jrnfilecnt-minxfilecnt," files that may contain TSTARTs",! zt "FILE"
     i $d(JrnDirList) {
       s name=$$GetJrnFileName(jrnfpath)
       s jrnfpath=$$FULLPATH(name)
       i jrnfpath="" w !,*7,"*** Unable to locate journal file ",name," that may contain TSTARTs",! zt "FILE"
     }
     s curfilecnt=jrnfilecnt
     s jrnfilecnt=$zu(78,22,jrnfpath,12)
     i jrnfilecnt<=0 w !,*7,"*** ",jrnfpath_$case(+jrnfilecnt,0:" does not exist",:" is not a journal file"),! zt "FILE"
     s jrnfilecnt=$p(jrnfilecnt,",",2)
     i jrnfilecnt<minxfilecnt w !,*7,"*** Missing ",curfilecnt-minxfilecnt," files that may contain TSTARTs",! zt "FILE"
     s ScanList($i(ScanList,-1))=jrnfpath ;jrnfilecnt>=minxfilecnt
     i jrnfilecnt=minxfilecnt q
   }
 } else {
   s jrnfpath=firstpath
   f  {
     s jrnfpath=$$findprev(jrnfpath,.jrnstop) i $g(jrnstop) q
     i jrnfpath="" w !,*7,"*** Missing previous ",jrnfilecnt-minxfilecnt," files that may contain TSTARTs",! zt "FILE"
     s curfilecnt=jrnfilecnt
     s jrnfilecnt=$zu(78,22,jrnfpath,12)
     i jrnfilecnt<=0 w !,*7,"*** ",jrnfpath_$case(+jrnfilecnt,0:" does not exist",:" is not a journal file"),! zt "FILE"
     s jrnfilecnt=$p(jrnfilecnt,",",2)
     i jrnfilecnt<minxfilecnt w !,*7,"*** Missing ",curfilecnt-minxfilecnt," files that may contain TSTARTs",! zt "FILE"
     s ScanList($i(ScanList,-1))=jrnfpath ;jrnfilecnt>=minxfilecnt
     i jrnfilecnt=minxfilecnt q
   }
 }
 i $d(ScanList) w !,"To scan older journal files for open transactions --"
 s index="" f  {
   s index=$o(ScanList(index),1,jrnfpath) q:index=""
   d ScanOneJrnForOpenTrans(jrnfpath)
 }
 i '$d(tranopen) k ScanList
 i $g(DEJRNSTART) {
   w:'$d(ScanList) !,"To scan the first journal file for open transactions --"
   d ScanOneJrnForOpenTrans($p(DEJRNSTART,",",2),+DEJRNSTART)
 }
 q
ErrorScanForOpenTrans s $zt=""
 i $ze["<INTERRUPT>" { ;CTRL-C by user to abort scanning
   w !,"User aborted scanning older journal files for open transactions.",!
   w "Tranactions started in those files might remain open after the restore.",!
   s $ze=""
   q
 }
 w !,"ERROR: ",$ze,!
 w !,"There is a problem with searching for open transactions in older files."
 i $g(QUIETMODE) {
   w !,"Restore will continue, but transactions started in files earlier than"
   w !,"the first one to be restored might remain open after the restore."
 } else {
   w !,"If you decide to continue, transactions started in files earlier than"
   w !,"the first one to be restored might remain open after the restore."
   i ($$yesno("Do you want to abort","Y")="Y") s notresto=1
 }
 i '$d(tranopen) k ScanList
 s $ze=""
 q 
ScanOneJrnForOpenTrans(jrnfpath,endaddr) ;
 n dev,addr,next,type,name
 s dev=$zu(78,5,jrnfpath,0) 
 i dev<0 w !,*7,"*** Unable to open ",jrnfpath,! zt "OPEN"
 s $zt="ErrScanOneJrn",$ze=""
 d $zu(78,6,dev)
 i $zu(78,104,4*1024*1024,-1) ;enable large reads for forward scanning
 s name=$case($ZBITGET($ZVERSION(0),46),0:$case($f(jrnfpath,";"),0:$e(jrnfpath,*-8-$l($p(jrnfpath,".",$l(jrnfpath,"."))),*-$case($e(jrnfpath,*)="z",0:0,1:1)),:$e(jrnfpath,*-8-$l($p(jrnfpath,".",$l(jrnfpath,"."))),$f(jrnfpath,";")-2)),:jrnfpath)
 w !,"Scanning ",jrnfpath,$s($g(endaddr):" up to "_endaddr,1:"")," ..."
 s addr="" f  {
   s next=$zu(78,17,addr) q:next'>0  i $g(endaddr),next>endaddr q
   s addr=next
   s type=$zu(78,8,addr)
   i type=4 {
     s tranopen($zu(78,10,addr),$ZU(78,25,addr))=addr_","_name
   } elseif type=5 {
     k tranopen($zu(78,10,addr),$ZU(78,25,addr))
   }
 }
 d $zu(78,7,dev)
 q
ErrScanOneJrn s $zt="" 
 d $zu(78,7,dev)
 ztrap $ze
SCANBJRN(jf,bad,opn) ;scan backward journal file jf to find TSTARTs
 N (jf,bad,opn)
 S adr=$zu(78,18,0) 
 F  S adr=$zu(78,18,adr) Q:adr'>0  D:$zu(78,8,adr)=4
 . Q:'$D(bad($zu(78,10,adr),$ZU(78,25,adr)))
 . K bad($zu(78,10,adr),$ZU(78,25,adr))
 . S opn($zu(78,10,adr),$ZU(78,25,adr))=adr_","_jf
 Q
 ; input: 
 ;       opn: tranopen
 ;       jf: journal file name (short)
CLEAN(jf,opn) ;clears opn entries with jf as 2nd data field 
 N (opn,jf)
 S pid=""
 F  S pid=$O(opn(pid)) Q:pid=""  D
 . S remsysid="" 
 . F  S remsysid=$O(opn(pid,remsysid)) Q:remsysid=""  D
 . . I $P(opn(pid,remsysid),",",2)=jf K opn(pid,remsysid)
 Q
nextfileE s $zt=""
 i $g(clu)]"",clu'<0 d close s clu=-1 ;close any open file
 i $g(zjrnerr) ztrap $ze 
jrnfileE s $zt=""  ;this entry point is shared with nxtcluupd/nxtclufile
 i $ze["<Z" d logmsg($g(resterr),0,2) i 1
 e  d logmsg("Error processing journal file "_$g(%jrnfile)_": "_$ze,0,2)
 i $d(restopt(2)) s zjrnerr=(restopt'[2) i 1 
 e  i $g(CHATTY) d
 . w !,"It is recommended that you abort dejournaling at this point. However,"
 . w !,"if you want to continue, we will have to skip this file."
 . s zjrnerr='($$yesno("Do you want to continue","N")="Y")
 i $g(zjrnerr) ztrap $ze
 d logmsg("Skipping journal file "_$g(%jrnfile),0,0)
 s $ze=""
 q
nextfile ;
 s $zt="nextfileE"
 n currfile s currfile=jrnfile
 N a,b,findnexterr
 i $d(jrnlist) d  g nextfileopen ;HYY1500
 . i jrnfile="" ztrap:$g(jrnlist) "JLST" i 1 ;expect jrnfile="" => jrnlist=""
 . e  i '$g(jrnlist) ztrap "JLST" ;expect jrnlist="" => jrnfile=""
 . e  i $case($ZBITGET($ZVERSION(0),46),0:$case($f(jrnlist(jrnlist),";"),0:$e(jrnlist(jrnlist),*-8-$l($p(jrnlist(jrnlist),".",$l(jrnlist(jrnlist),"."))),*-$case($e(jrnlist(jrnlist),*)="z",0:0,1:1)),:$e(jrnlist(jrnlist),*-8-$l($p(jrnlist(jrnlist),".",$l(jrnlist(jrnlist),"."))),$f(jrnlist(jrnlist),";")-2)),:jrnlist(jrnlist))'=jrnfile ztrap "JLST"
 . s jrnlist=$o(jrnlist($g(jrnlist)),1,%jrnfile) ;$g(jrnlist) is the index
 . i jrnlist,%jrnfile]"" s jrnfile=$case($ZBITGET($ZVERSION(0),46),0:$case($f(%jrnfile,";"),0:$e(%jrnfile,*-8-$l($p(%jrnfile,".",$l(%jrnfile,"."))),*-$case($e(%jrnfile,*)="z",0:0,1:1)),:$e(%jrnfile,*-8-$l($p(%jrnfile,".",$l(%jrnfile,"."))),$f(%jrnfile,";")-2)),:%jrnfile) q
 . d logmsg("Unable to continue further due to an error locating the file following "_$g(prefix)_currfile,0,2) s zjrnerr=1 ztrap "FILE"
 e  i $d(JrnFileList) d  g nextfileopen 
 . i jrnfile="" ztrap:$g(JrnFileList) "JLST" i 1 ;expect jrnfile="" => JrnFileList=""
 . e  i '$g(JrnFileList) ztrap "JLST" ;expect JrnFileList="" => jrnfile=""
 . e  i $case($ZBITGET($ZVERSION(0),46),0:$case($f(JrnFileList(JrnFileList),";"),0:$e(JrnFileList(JrnFileList),*-8-$l($p(JrnFileList(JrnFileList),".",$l(JrnFileList(JrnFileList),"."))),*-$case($e(JrnFileList(JrnFileList),*)="z",0:0,1:1)),:$e(JrnFileList(JrnFileList),*-8-$l($p(JrnFileList(JrnFileList),".",$l(JrnFileList(JrnFileList),"."))),$f(JrnFileList(JrnFileList),";")-2)),:JrnFileList(JrnFileList))'=jrnfile ztrap "JLST"
 . s JrnFileList=$o(JrnFileList($g(JrnFileList)),1,%jrnfile) ;$g(JrnFileList) is the index
 . i 'JrnFileList||(%jrnfile="") d  q  ;shouldn't be here
 . . d logmsg("Unable to continue further due to an error locating the "_$s(currfile="":"first file",1:"file following ")_$g(prefix)_currfile,0,2) 
 . . s zjrnerr=1 ztrap "FILE"
 . s jrnfilename=$$GFILE^SHDWCBLK(%jrnfile) ;jrnfilename contains prefix if any
 . s jrnfile=$case($ZBITGET($ZVERSION(0),46),0:$case($f(%jrnfile,";"),0:$e(%jrnfile,*-8-$l($p(%jrnfile,".",$l(%jrnfile,"."))),*-$case($e(%jrnfile,*)="z",0:0,1:1)),:$e(%jrnfile,*-8-$l($p(%jrnfile,".",$l(%jrnfile,"."))),$f(%jrnfile,";")-2)),:%jrnfile) ;jrnfile doesn't contain any prefix
 . s i="" f  s i=$o(lookpath(i)) q:i=""  s %jrnfile=lookpath(i)_jrnfilename i $ZU(78,22,%jrnfile)>0 q
 . i i="" d logmsg("Unable to continue further due to an error locating the file "_jrnfilename_" in given directories",0,2) s zjrnerr=1 ztrap "FILE"
 e  i jrnfile="" S jrnfile=djfirst,%jrnfile=$$FULLPATH(djfirst) i 1
 e  s %jrnfile=$$FINDNEXT(.jrnfile,.findnexterr)
 i prompt {
   s b=%jrnfile
   f  {
     i $g(CHATTY) { ;interactive job
       W !!,"Restore From Journal File: ",jrnfile," =>" R a,!
     } else {  ;fastrest=2
       k @promptnode@("input")
       s @promptnode@("default")=jrnfile
       s a=0 f  {
         i $d(@promptnode@("input")) q
	 h .01
	 i $i(a)#1000=0 { ;generate a message every 10 seconds
	   d logmsg("Waiting for user input on next file to restore",1,0)
	 }
       }
       s a=@promptnode@("input")
       k @promptnode@("default")
     }
     i (a="")||(a=jrnfile) q  ;use jrnfile and %jrnfile we have got
     I $$STOP(a) s zjrnerr=1 ztrap "FILE"
     S b=%jrnfile,%jrnfile=$$FULLPATH(a) 
     i %jrnfile'="" q
     i $g(CHATTY) { ;interactive job
       W "Cannot locate the file",! 
     } else {
       s @promptnode@("error")="Cannot locate the file"
     }
     s %jrnfile=b
   }
   s @promptnode@("error")=""
   i a'="",a'=jrnfile s jrnfile=a
   i (($p(jrnfile,".")>$p(djlast,"."))||(($p(jrnfile,".")=$p(djlast,"."))&&(+$p(jrnfile,".",2)>+$p(djlast,".",2)))) q
 }
 i (($p(jrnfile,".")>$p(djlast,"."))||(($p(jrnfile,".")=$p(djlast,"."))&&(+$p(jrnfile,".",2)>+$p(djlast,".",2)))) d  q
 . s clu=-1 
 . d logmsg("Unable to continue further due to the missing file following "_$g(prefix)_currfile,0,2) s zjrnerr=1 ztrap "FILE"
 i %jrnfile="" d  s %jrnfile=$$FULLPATH(jrnfile) ;to continue on to open
 . s clu=-1 
 . i $g(findnexterr)'="" d logmsg(findnexterr,0,2) s zjrnerr=1 ztrap "FILE"
 . i $$FULLPATH(jrnfile)="" d logmsg("Unable to continue further due to the missing file "_$g(prefix)_jrnfile,0,2) s zjrnerr=1 ztrap "FILE"
 . i currfile=jrnfile d logmsg("Unable to continue further due to an error locating the file following "_$g(prefix)_currfile,0,2) s zjrnerr=1 ztrap "FILE"
 . s $zt="nextfileE"
 . s resterr="File(s) missing between '"_$g(prefix)_currfile_"' and '"_$g(prefix)_jrnfile_"' " 
 . ztrap "FILE"
nextfileopen ;HYY1500
 d open i adr=-1 q
 i +$g(DEJRNSTART),$p(DEJRNSTART,",",2)=%jrnfile s adr=+DEJRNSTART
 n i s i=$i(^SYS("RESTORE","JOURNAL",RestTime,"Files"))
 s ^SYS("RESTORE","JOURNAL",RestTime,"Files",i)=%jrnfile_","_$zdt($h,8)
 s:adr ^SYS("RESTORE","JOURNAL",RestTime,"Files",i,"StartAddress")=adr
 i fastrest {
   d finish ;DejrnFile will open it again
   i jrnfile=djfirst d $zu(78,53,shrid,1,0,adr,%jrnfile)
   s clu=$$DejrnFile^JRNRESTF(%jrnfile,adr,shrid)
   i fastrest>1 q
 } else { 
   s $zt="nextfileE" i '($e($roles,1,$l("%All"))="%All") { n $ET,$roles s $ET="",$roles=$roles_","_"%All"} ; verified 9/26/16 STC
 }
 W !        
     ;
begin ;begin recovering from JOURNAL
 d output^%Wprim($c(13,10)_%jrnfile)
 w ! ;given the above output^%Wprim, a new line is all we need
 n count s lastindex=$zu(78,18,0)
   ; find next record to restore and restore it
   ; after every #num restores, print the % of file processed
 N num S num=$$InitDispCount(lastindex)
 s lastindex=$zu(78,18,lastindex) ;used in nextupd, consistent with restoreone (cf. findfiles^JRNRESTC2)
 i lastindex s count=0 f  d nextupd q:type=-1  d restore q:$g(zjrnerr)=1  i $i(count)>num w $j(adr*100/lastindex,7,2)_"%" s count=0,percentdone=(adr*100/lastindex)_","_%jrnfile i $g(cachetempmaxblks) d sortlimit ;s rc=##class(SYS.Database).GetDatabaseFreeSpace("iristemp",.freeMB) w $j(freeMB,4,1),$j($$$GetpSortChunks,4)
 s lastindex=$zu(78,18,0) ;probably not needed
 d sortflush()
 i '$g(zjrnerr) w $j(100,6,2)_"%" d output^%Wprim("***Journal file finished at "_$ztime($p($h,",",2)))
finish s a=$zu(78,7,clu),clu=-1
clo2 i $g(ZJRNUSE)=1,'$g(zjrnerr) d
 . i $$YN("Do you want to rename your journal filter","")="Y" d
 . . x "zl ZJRNFILT zs XJRNFILT zr  zs ZJRNFILT"
 . . w !,"Journal filter ZJRNFILT renamed to XJRNFILT",!
 . . s (ZJRNUSE,ZJRNUSEMARK)=0
 . e  d
 . . i $$YN("Do you want to delete your journal filter","")="Y" d
 . . . x "zl ZJRNFILT zr  zs ZJRNFILT"
 . . . w !,"Journal filter ZJRNFILT deleted",!
 . . . s (ZJRNUSE,ZJRNUSEMARK)=0
 q
Error s $zt=""
 ztrap $ze
InitDispCount(lastindex) ;
 n num s num=lastindex\10000 S:num<100 num=100 ;minimum check count 
 i $g(cachetempmaxblks),num*2>sortchunklimit s num=sortchunklimit\2
 q num
findprev(jrnfpath,jrnstop) ;find the journal file preceding jrnfpath
 n prev,name,path
 s jrnstop=0 ;if jrnstop=0, returning "" is considered an error by caller
 s prev=$P($zu(78,22,jrnfpath,1),",",2) ;jrnfpath is assumed a valid journal file
 i prev="" s jrnstop=1 q "" ;we have reached JRNSTOP
 i $g(prefix)="" {
   s name=$$GetJrnFileName(prev) ;name may or may not contain a prefix
 } else {
   s name=$case($ZBITGET($ZVERSION(0),46),0:$case($f(prev,";"),0:$e(prev,*-8-$l($p(prev,".",$l(prev,"."))),*-$case($e(prev,*)="z",0:0,1:1)),:$e(prev,*-8-$l($p(prev,".",$l(prev,"."))),$f(prev,";")-2)),:prev) ;name only, excluding directory and prefix
 }
 s path=$$FULLPATH(name) ;match name with files in given directories
 q path ;found previous file if path'=""
FINDPREV(jf) ;find the journal file preceding jf
 N date,seq,pjf,days,days0
 S date=$P(jf,".",1),seq=$P(jf,".",2),pjf=""
 I seq>1 D  Q:pjf'="" pjf
 . S jf=date_"."_$s((seq)<101:$e((seq)-1+1000,2,4),1:(seq)-1)
 . S pjf=$$FULLPATH(jf)
 ;pjf="" so far
 S days=$zdh(date,8),days0=$zdh($P(djfirst,".",1),8)        
 F  D  Q:days<days0  S pjf=$$FULLPATH(jf) Q:pjf'=""  
 . S days=days-1 
 . S jf=$zd(days,8)_".001"
 Q pjf
FINDNEXT(jf,err) ;find the journal file following jf; err (if any) on return
 N date,seq,pjf,days,curdays,date1
 n jrnfpath s jrnfpath=$$FULLPATH(jf) i jrnfpath="" q ""  ;error condition
 n nextjrnf s nextjrnf=$P($zu(78,22,jrnfpath,2),",",2) 
 i nextjrnf]"" {
   n jrnfilename,nextprefix 
   s jrnfilename=$$GetJrnFileName(nextjrnf) ;with prefix if any
   s nextprefix=$$GJrnPrefix(jrnfilename)
   i $g(prefix)'=nextprefix {
     s err="Unable to continue as the file following '"_jrnfpath_"' has a different prefix '"_nextprefix_"'"
     q ""
   }
   s jf=$case($ZBITGET($ZVERSION(0),46),0:$case($f(jrnfilename,";"),0:$e(jrnfilename,*-8-$l($p(jrnfilename,".",$l(jrnfilename,"."))),*-$case($e(jrnfilename,*)="z",0:0,1:1)),:$e(jrnfilename,*-8-$l($p(jrnfilename,".",$l(jrnfilename,"."))),$f(jrnfilename,";")-2)),:jrnfilename) ;without prefix
   s nextjrnf=$$FULLPATH(jf) q nextjrnf
 }
 S date=$P(jf,".",1),seq=$P(jf,".",2),pjf=""
 I seq<(2**31-1) D  i pjf]"" g verify
 . S jf=date_"."_$s((seq)<99:$e((seq)+1001,2,4),1:(seq)+1)
 . S pjf=$$FULLPATH(jf)
 ;pjf="" so far
 S days=$zdh(date,8),curdays=$P($H,",",1)        
 F  D  Q:days>curdays  S pjf=$$FULLPATH(jf) Q:pjf'=""  
 . S days=days+1 
 . s jf=$zd(days,8)_".001"
 i pjf="" q ""
verify ;
 n prevjrnf s prevjrnf=$P($zu(78,22,pjf,1),",",2) i prevjrnf]"",$case($ZBITGET($ZVERSION(0),46),0:$case($f(prevjrnf,";"),0:$e(prevjrnf,*-8-$l($p(prevjrnf,".",$l(prevjrnf,"."))),*-$case($e(prevjrnf,*)="z",0:0,1:1)),:$e(prevjrnf,*-8-$l($p(prevjrnf,".",$l(prevjrnf,"."))),$f(prevjrnf,";")-2)),:prevjrnf)'=$case($ZBITGET($ZVERSION(0),46),0:$case($f(jrnfpath,";"),0:$e(jrnfpath,*-8-$l($p(jrnfpath,".",$l(jrnfpath,"."))),*-$case($e(jrnfpath,*)="z",0:0,1:1)),:$e(jrnfpath,*-8-$l($p(jrnfpath,".",$l(jrnfpath,"."))),$f(jrnfpath,";")-2)),:jrnfpath) q ""
 Q pjf
 ;
 ; input:
 ;       jf,prefix,lookpath
FULLPATH(jf) ;returns the full name of jf if it exists; otherwise, ""
 N f,i
 S i=1
 if $ZBITGET($ZVERSION(0),46) {
	 ; for USEDSONLY, there are no short names and long names
	 if $ZU(78,22,f) {
		 quit f
	 }
	 quit ""
 }
 F  S f=lookpath(i)_$G(prefix)_jf Q:$ZU(78,22,f)>0  S i=i+1 Q:i>lookpath
 Q:i>lookpath ""
 Q f
STURestore ;Restore loop for STU^JRNRESTO
 n colseq,curcol
 n lastindex s lastindex=$zu(78,18,$zu(78,18,0))
 f  d nextupd q:type=-1  d restore ;HYY073
 q
restoreone(id,index) ;
 ; Called from JRNCLUREST2.
 ; 
 ; This is a journal file from a system that was not part of
 ; the cluster at the time so just use the standard journal
 ; restore code to process it.
 ; 
 ; Many of the following variables are from JRNRESTO/JRNRESTB
 n line,%jrnfile,adr,num,count,lastindex,type,a,clu,zjrnerr,zjrnerrmsg,jrnfile
 n cd,gnode,r,glo,new,zpid,zdir,zglo,ztype,zremsys,restmode
 n colseq,curcol,x
 ;         
 s clu=-1
 s $ZT="restoneerr"
 ;
 s line=clumember(id,"files",index)
 k clumember(id,"files",index)  ; we're restoring this so remove it
 ;
 ; jrnfile is recorded in badtrans/transopen where as %jrnfile is
 ; the actual journal file name.
 ;
 s %jrnfile=$P(line,"^",1)
 s jrnfile=$e(index,1,$L(index)-1)_","_id
 s lastindex=$P(line,"^",6)
 s num=$$InitDispCount(lastindex)
 w !,"Restoring: ",%jrnfile," from cluster member #",id
 w !
 d open^JRNRESTO d:adr=-1 openerr^JRNRESTO
 i lastindex s count=0 f  d nextupd q:type=-1  d restore q:$g(zjrnerr)=1  i $i(count)>num w $j(adr*100/lastindex,7,2)_"%" s count=0,percentdone=(adr*100/lastindex)_","_%jrnfile i $g(cachetempmaxblks) d sortlimit
 w $j("100",7,2),"%"
 s a=$zu(78,7,clu),clu=-1
 ; We restored this journal so record that here
 s clumember(id,"rest",index)=line
 q
restoneerr ;
 s chan=clu  ; resterr expects the open channel in "chan"
 d resterr^JRNCLUREST
 q
 ;
clurestore(maxseq) ;
 ; Called from JRNCLUREST.
 ; 
 ; Perform the cluster restore starting with the journal records
 ; loaded into jrnseq(). The format of jrnseq() (from cluopen) is:
 ;     jrnseq(seq,chan)=offset^type^id^index
 ; If maxseq is not 0, then this is the highest sequence # that we
 ; want to restore. Once we reach that sequence number we don't restore
 ; any more records from any journal files for that cluster member.
 ;
 n seq,chan,line,adr,a,id,index,nxtseq,recseq,num,count
 n colseq,curcol
 n bitpos,newbitval
 ;
 ; totbytes is the total # of bytes being restored for this run
 ; sumbytes is the # of bytes in the journal files we've finished
 ;   with so far.
 ;
 ; Add up the # of bytes being restored during this cluster mstart
 s progmsg="    completed processing "
 s totbytes=0,sumbytes=0
 i fastrest d  ;to reopen the files with shrid
 . n newchan,addr,jrnf
 . s seq="" f  s seq=$O(jrnseq(seq)) q:seq=""  d
 . . n jrnchan m jrnchan=jrnseq(seq) k jrnseq(seq)
 . . s chan="" f  s chan=$O(jrnchan(chan)) q:chan=""  d
 . . . s line=jrnchan(chan),id=$P(line,"^",3),index=$P(line,"^",4)
 . . . s jrnf=$P(clumember(id,"files",index),"^"),addr=+line
 . . . d $zu(78,7,chan) 
 . . . s newchan=$$DejrnFile^JRNRESTF(jrnf,addr,shrid) 
 . . . s jrnseq(seq,newchan)=line
 s seq="" f  s seq=$O(jrnseq(seq)) q:seq=""  s chan=""  d
 . f  s chan=$O(jrnseq(seq,chan)) q:chan=""  d
 . . s line=jrnseq(seq,chan),id=$P(line,"^",3),index=$P(line,"^",4)
 . . s sumbytes=sumbytes+$P(line,"^")
 . . s line=clumember(id,"files",index)
 . . f  d  q:index=""  
 . . . s totbytes=totbytes+$P(line,"^",6)
 . . . s index=$O(clumember(id,"files",index))
 . . . q:index=""
 . . . s line=clumember(id,"files",index)
 . . . i $P(line,"^",9)'=tstamp s index=""  ; we're done
 w !,"Processing cluster start: "
 s a=$zdth(tstamp,-2) w $ZD(a)," ",$ZT($P(a,",",2),4)
 s num=totbytes\10000 s:num<100 num=100,adr=0
 w !,?5 W $j("0",6,2),"% "
 s count=0
 f  s seq=$O(jrnseq("")) q:seq=""  d
 . f  s chan=$O(jrnseq(seq,"")) q:chan=""  s line=jrnseq(seq,chan) d
 . . k jrnseq(seq,chan)
 . . s a=$zu(78,6,chan)
 . . s adr=$P(line,"^"),type=$P(line,"^",2),id=$P(line,"^",3)
 . . s index=$P(line,"^",4)
 . . i maxseq&(seq>maxseq) d  q
 . . . s clumember(id,"rest",index)=clumember(id,"files",index)
 . . . k clumember(id,"files")
 . . . s a=$zu(78,7,chan),chan=-1
 . . s sumbytes=sumbytes-adr
 . . s nxtseq=$O(jrnseq(""))
 . . i maxseq&(nxtseq=""!(nxtseq>maxseq)) s nxtseq=maxseq
 . . ; jrnfile is used in transopen/badtrans along with the address
 . . ; for tracking transactions during the journal restore
 . . s %jrnfile=$P(clumember(id,"files",index),"^",1)
 . . s jrnfile=$E(index,1,$L(index)-1)_","_id
 . . s recseq=seq f  d restore:(recseq'<seq),nxtcluupd q:type=-1  s recseq=$zu(78,11,adr) q:nxtseq'=""&(recseq>nxtseq)  s count=count+1 d:count'<num dispcnt
 . . s:type'=-1 sumbytes=sumbytes+adr
 . . ; If we stopped because we reached the end of the journal files
 . . ; from this system for this cluster mstart then nxtclufile closed
 . . ; the journal and updated the clumember() array. If we stopped
 . . ; because maxseq is defined, and we've restored that sequence
 . . ; number, then kill off the rest of clumember(id,"files")
 . . ; because we just restored the last journal file for this cluster
 . . ; member.
 . . i (type'=-1)&maxseq&(nxtseq=maxseq) d  q
 . . . s clumember(id,"rest",index)=clumember(id,"files",index)
 . . . k clumember(id,"files")
 . . . s a=$zu(78,7,chan),chan=-1
 . . . s type=-1,adr=-1,jrnfile=""
 . . ; If there are more journal records to restore for this cluster
 . . ; member, create a new jrnseq() entry for it.
 . . s:type'=-1 jrnseq(recseq,chan)=adr_"^"_type_"^"_id_"^"_index
 w:$X>70 ! w:'$X ?5 w $J(100,6,2),"%"
 ;
 q
dispcnt ;
 w:$X>70 !
 w:'$X ?5
 w $J((adr+sumbytes)*100/totbytes,6,2),"% "
 s count=0
 s percentdone=((adr+sumbytes)*100/totbytes)_","_$g(tstamp)
 i $g(cachetempmaxblks) d sortlimit
 q
 ;
nxtcluupd ;
 ; Called to get the next adr to restore from this cluster member.
 ; If we reach the end of a journal file for this cluster member
 ; we move it from clumember(id,"files") to clumember(id,"rest")
 s nextadr=$zu(78,17,adr) g nxtclufile:'nextadr s adr=nextadr
 s type=$zu(78,8,adr)
 ;if it is SET/KILL, check to see if we care. If we do, leave it to
 ;restore; otherwise, skip to the next record
 i (type=6)!(type=7)!(type=9)!(type=14)!(type=22)!(type=24)!(type=25)!(type=26) D  Q:$G(modify)!ALL  g nxtcluupd
 . D:'ALL check
 . Q:'$zu(78,9,adr)  ;optimized for (modify!ALL)&`jrntrans
 . D:($G(modify)!ALL)
 . . ;make sure it is not already in either tranopen or badtran
 . . Q:$D(tranopen($zu(78,10,adr),$ZU(78,25,adr)))
 . . Q:$D(badtran($zu(78,10,adr),$ZU(78,25,adr)))
 . . S badtran($zu(78,10,adr),$ZU(78,25,adr))=adr_","_jrnfile
 ;restore does not care about TSTART/TCOMMIT.
 ;if 2nd TSTART for the same pid appears, 1st one will be forgotten or
 ;ignored. it would be better if tranopen and badtran are combined 
 ;into one.
 i type=4 d  g nxtcluupd
 . s tranopen($zu(78,10,adr),$ZU(78,25,adr))=adr_","_jrnfile
 . K badtran($zu(78,10,adr),$ZU(78,25,adr))
 i type=5 d  g nxtcluupd
 . k tranopen($zu(78,10,adr),$ZU(78,25,adr))
 . K badtran($zu(78,10,adr),$ZU(78,25,adr))
 g:type'=-1 nxtcluupd
nxtclufile ;
 s lastadr=$zu(78,18,$zu(78,18,0)) i adr<lastadr d
 . s $zt="jrnfileE"
 . s resterr="Journal "_$g(%jrnfile)_" ends unexpectedly at "_adr_" (end expected at "_lastadr_") - possible corruption in the journal" 
 . ztrap "JEND"  
 ; We reached the end of this file, see if there's another journal
 ; file from this cluster member for this cluster start
 ;
 s n=$zu(78,7,chan),chan=-1 ; close this journal file
 s n=clumember(id,"files",index)
 w:$X !
 w progmsg,$case($ZBITGET($ZVERSION(0),46),0:$case($f($P(n,"^"),";"),0:$e($P(n,"^"),*-8-$l($p($P(n,"^"),".",$l($P(n,"^"),"."))),*-$case($e($P(n,"^"),*)="z",0:0,1:1)),:$e($P(n,"^"),*-8-$l($p($P(n,"^"),".",$l($P(n,"^"),"."))),$f($P(n,"^"),";")-2)),:$P(n,"^"))," for cluster member #",id,!
 s sumbytes=sumbytes+$P(n,"^",6)
 s clumember(id,"rest",index)=clumember(id,"files",index)
nxtcfile2 ;
 k clumember(id,"files",index)
 s index=$O(clumember(id,"files",index))
 g:index="" nxtcfiledone
 s line=clumember(id,"files",index)
 i $P(line,"^",9)=tstamp d  g:chan=-1 nxtcfile2 g nxtcluupd
 . s %jrnfile=$P(line,"^",1)
 . s chan=$zu(78,5,%jrnfile,0)
 . i chan=-1 d openerr^JRNCLUREST q
 . s n=$zu(78,6,chan)
 . s adr=0
 . i fastrest d  ;i fastrest>1 q  ;fastrest=2 doesn't work with cluster restore
 . . d $zu(78,7,chan) s chan=-1 
 . . s chan=$$DejrnFile^JRNRESTF(%jrnfile,adr,shrid) 
 . s jrnfile=$e(index,1,$L(index)-1)_","_id
nxtcfiledone ;
 s type=-1,adr=-1,jrnfile=""
 q
 ;
cluadjstartpos ;
 s seq="" 
 f  s seq=$O(jrnseq(seq)) q:seq=""!(seq'<minseq)  d
 . i 'flag d
 . . s flag=1 
 . . w !,"Discarding records prior to sequence #",minseq
 . . s progmsg="   skipped journal file "
 . s chan="" f  s chan=$O(jrnseq(seq,chan)) q:chan=""  d
 . . s line=jrnseq(seq,chan)
 . . k jrnseq(seq,chan)
 . . s n=$zu(78,6,chan)
 . . s adr=$P(line,"^"),type=$P(line,"^",2),id=$P(line,"^",3)
 . . s index=$P(line,"^",4)
 . . f  d nxtcluupd q:type=-1  s recseq=$zu(78,11,adr) q:recseq'<minseq
 . . s:type'=-1 jrnseq(recseq,chan)=adr_"^"_type_"^"_id_"^"_index
 q
   ;
   ; restore the current record if its directory is mountable
   ; input variables: type,adr
   ; get directory and make sure it is mounted
   ; HYY419: curcol should be loaded with the current collation
   ;             sequence. On exit, the current collation sequence for
   ;             the process may have changed and the caller should save
   ;             and restore the original if so desired.
restore i checkerr s $zt="skiprec"
 i type=13 d:$g(ZJRNUSEMARK)  q  ;skip journal marker record
 . s $zt="ZJRNERR",x=$ZU(78,35,adr) 
 . d MARKER^ZJRNFILT(adr,%jrnfile,$p(x,","),$p(x,",",2),$p(x,",",3),$p(x,",",4,$l(x)))
 S dir=$zu(78,12,adr),new=dir I 'ALL S new=$G(dejrn(dir)),new=$P(new,",",2,$L(new)) S:'$L(new) new=dir
 ;1st time for each directory, check if it can't be mounted...
 if ($G(fromrest)'=8),'$D(dir(new)) Q:$D(nomount(new))  Q:'$$mount(new,adr,%jrnfile)
 ;
 n zt,zremsys,zpid,zdir,zglo,ztype,restmode
 i $g(ZJRNUSE) d  q:'restmode
 . s zpid=$zu(78,10,adr),zdir=$zu(12,$zu(78,12,adr)),zglo=$zu(78,13,adr),zglo="^"_$p(zglo,"]",2,$l(zglo))
 . i type=6 s ztype="S"
 . i type=14 s ztype="s"
 . i type=25 s ztype="VS"
 . i type=26 s ztype="VK"
 . i type=7 s ztype="K"
 . s zremsys=$ZU(78,25,adr) 
 . i zremsys s zpid=zpid_","_zremsys
 . i type=9 s ztype="ZK"
 . i type=22 s ztype="S"
 . i type=24 s ztype="ZK"
 . s zt=$zt,$zt="ZJRNERR",restmode=0 
 . d ^ZJRNFILT(zpid,zdir,zglo,ztype,.restmode,adr,$zu(78,24,adr))
 . s $zt=zt
 if $G(fromrest)=8 d  q  ; This is a JCONVERT operation
 . s gref=$zu(78,13,adr)
 . i 'includedir s gref="^"_$p(gref,"]",$l($qs(gref,-1),"]")+1,999) ; strip dir
 . i type=6!(type=22) s value=$zu(78,15,adr) 
 . e  i type=14 s value=$zu(78,36,adr)_","_$zu(78,37,adr)
 . e  i type=25 s value=$ZU(78,122,adr)_","_$ZU(78,123,adr)_","_$zu(78,15,adr)
 . e  i type=26 s value=$ZU(78,122,adr)
 . e  s value=""
 . i fmode1="UVL" d  i 1 ;write out type, gref and value of the record
 . . u file2
 . . d wuvl(type)
 . . d wuvl(gref)
 . . d wuvl(value)
 . e  d
 . . n xval s xval=$zcvt(value,"O",xlate)
 . . i (fmode1="V")||((fmode1="U")&&(recsep=+recsep)),$l(xval)>65534 d
 . . . d $zu(9,"","Value length "_$l(xval)_" exceeds limit",(0>0),0)
 . . . d $zu(96,0,5) ;generate a <MAXSTRING> error to be trapped by skiprec
 . . u file2
 . . d wvar(type)
 . . d wvar(gref)
 . . d wvar(xval)
 . u IOSAVE
 . s reccnt=reccnt+1  ;for displaying when we're done in ^JCONVERT
 i fastrest=1 {	// read journal in COS and queue record in C
   s stat=$zu(78,47,adr,adr)
   i stat<0 ztrap "STAT"  ;???
   d $zu(78,54,adr) ;@FIXME@ should be done in nextupd and nxtcluupd
   q
 }
 I type=6!(type=22) DO  Q  ;for SET and QADD
 . s newref=$zu(78,13,adr) i dir'=new s $p(newref,"""",2)="^^"_new
 . s globname=$p(newref,"(",1,$l(new,"(")) i '$g(sortcnt(globname)) d
 . . s colseq=$ZU(78,27,adr) i colseq'=dbcol(new),('$d(@($p(newref,"(",1,$l(new,"("))))),$zu(178,"^^"_new,$qs(newref,0),colseq)
 . . d sortbeg 
 . s @newref=$zu(78,15,adr) ;i $i(sortcnt(globname))
 If type=14 DO  Q   ;for SET $BIT
 . s newref=$zu(78,13,adr) i dir'=new s $p(newref,"""",2)="^^"_new
 . s globname=$p(newref,"(",1,$l(new,"(")) i $g(sortcnt(globname)) d sortend i 1
 . e  s colseq=$ZU(78,27,adr) i colseq'=dbcol(new),('$d(@($p(newref,"(",1,$l(new,"("))))),$zu(178,"^^"_new,$qs(newref,0),colseq)
 . s $Bit(@newref,$zu(78,36,adr))=$zu(78,37,adr)
 If type=25 DO  Q   ;for SET $VECTOR
 . s newref=$zu(78,13,adr) i dir'=new s $p(newref,"""",2)="^^"_new
 . s globname=$p(newref,"(",1,$l(new,"(")) i $g(sortcnt(globname)) d sortend i 1
 . e  s colseq=$ZU(78,27,adr) i colseq'=dbcol(new),('$d(@($p(newref,"(",1,$l(new,"("))))),$zu(178,"^^"_new,$qs(newref,0),colseq)
 . set $vector(@newref,$ZU(78,122,adr),$ZU(78,123,adr))=$zu(78,15,adr)
 If type=26 DO  Q   ;for KILL $VECTOR
 . s newref=$zu(78,13,adr) i dir'=new s $p(newref,"""",2)="^^"_new
 . d:$g(sortcnt(globname)) sortend kill $vector(@newref,$ZU(78,122,adr))
 ;
 I type=7 DO  Q  ;for KILL
 . s newref=$zu(78,13,adr) i dir'=new s $p(newref,"""",2)="^^"_new
 . s globname=$p(newref,"(",1,$l(new,"(")) d:$g(sortcnt(globname)) sortend K @newref
 I type=9!(type=24) DO  Q  ;for ZKILL and JRNQREM
 . s newref=$zu(78,13,adr) i dir'=new s $p(newref,"""",2)="^^"_new
 . s globname=$p(newref,"(",1,$l(new,"(")) d:$g(sortcnt(globname)) sortend ZKILL @newref 
 Q
skiprec S $zt="skiprec1"
 d:checkerr=2
 . ; for checkerr=2 we record errors in the errlist array. 
 . n i,dirname,new
 . i $g(fastrest) s adr=$g(fastaddr),dirname=$s($g(targetdir)="":"<unknown>",1:targetdir) i 1
 . e  s dirname=$S($G(adr):$zu(78,12,adr),1:"<unknown>")
 . s errlist=$G(errlist)+1
 . s errlist("all",errlist)=$LISTBUILD($G(%jrnfile),$G(adr),$ZE)  ;all errors in order
 . s ^SYS("STUJRNERRLIST")=errlist
 . s ^SYS("STUJRNERRLIST","all",errlist)=errlist("all",errlist)
 . ; if this is the 1st error for this directory then count another db err
 . if '$G(errlist("db",dirname)) s i=$I(errlist("db")),errlist("db",i)=dirname,^SYS("STUJRNERRLIST","db")=i,^SYS("STUJRNERRLIST","db",i)=dirname  ;databases with errors
 . s i=$I(errlist("db",dirname))
 . s errlist("db",dirname,i)=$LISTBUILD($G(%jrnfile),$G(adr),$ZE)
 . s ^SYS("STUJRNERRLIST","db",dirname)=i
 . s ^SYS("STUJRNERRLIST","db",dirname,i)=errlist("db",dirname,i)
 . i $g(fastrest) d $zu(9,"","Error in JRNRESTB: "_$ZE_$C(10,13)_"     "_%jrnfile_" addr="_$g(adr)_$C(10,13)_"     "_$g(globref),(0>0),0) i 1
 . e  d $zu(9,"","Error in JRNRESTB: "_$ZE_$C(10,13)_"     "_%jrnfile_" addr="_$g(adr)_$C(10,13)_"     "_$zu(78,13,adr),(0>0),0) q:'$L(dirname)!('$G(adr))  ;if dir is "<unknown>" or "" then stop here
 . d:i>$G(errmax)  ; stop restoring this db if the max # of errors/db is exceeded
 . . ; If we remove dir(new) and set nomount(new) to true then restore will
 . . ; stop writing records to this database. We also dismount it now so that
 . . ; in case something goes wrong and the system lets users on, its dismounted.
 . . s new=dirname I '$g(fastrest),'ALL S new=$G(dejrn(dirname)),new=$P(new,",",2,$L(new)) S:'$L(new) new=dirname
 . . d:'$L(new)
 . . . d $zu(9,"","Cannot locate directory name for offset "_adr_" in "_%jrnfile_". Not dismounted",(0>0),0)
 . . d:$L(new)
 . . . k dir(new)
 . . . s nomount(new)=1
 . . . do $ZU(3,new)
 . . . d $zu(9,"","Too many errors restoring to "_new_"."_$C(10,13)_" Dismounting and skipping subsequent records",(0>0),0)
 . . . s errlist("db",dirname)=errlist("db",dirname)_"^1"  ;flag we skipped the rest
 . . . s ^SYS("STUJRNERRLIST","db",dirname)=errlist("db",dirname)
skiprec1 ;
 S $zt="skiprec2"
 ;checkerr=2 logs the message up higher so that it comes before the note
 ;that subsequent records are skipped when the max error count is exceeded.
 g:checkerr=2 skiprec2 
 i $g(zjrnerr) ztrap $ze 
 n ze s ze=$ze 
 i $g(fastrest) s adr=$g(fastaddr)
 e  d  
 . s $zt="skiprec2"
 . s globref=$zu(78,13,adr),globnam=$p(globref,"(",1,$l($qs(globref,-1),"("))
 s $ze=ze
 if $g(globnam)="" {
   i $i(globerr($ze))>1 s $ze="" g skipdir ;and quit skiprec
   s errmsg="Failed to process update at offset "_$g(adr)_" of file "_$g(%jrnfile)_": "_$ze
   d logmsg(errmsg,0,2)
   d logmsg("Future messages of error "_$ze_" will be suppressed",0,0)
   s ^SYS("RESTORE","JOURNAL",RestTime,"Errors",$i(^SYS("RESTORE","JOURNAL",RestTime,"Errors")))=errmsg
 } else {
   s errmsg="Failed to process update of global node "_globref_" at offset "_$g(adr)_" of file "_$g(%jrnfile)_": "_$ze
   d logmsg(errmsg,0,2)
   s ^SYS("RESTORE","JOURNAL",RestTime,"Errors",$i(^SYS("RESTORE","JOURNAL",RestTime,"Errors")))=errmsg
 }
 d skipdir
 i $d(restopt(1)) s zjrnerr=(restopt[1) i 1
 e  i $g(CHATTY),'$g(globerr) d
 . i '($$yesno("Do you want to continue","Y")="Y") s zjrnerr=1 q
 . s globerr=($$yesno("Always continue on future occurrences of similar problems","Y")="Y")
skiprec2 s $zt=""
 i $g(zjrnerr) ztrap $ze
 s $ze="" 
 q
skipdir s $zt="skipdirE"
 i $g(targetdir)]"",$i(globerr(targetdir)) { ;skip dir on its 1st error
   k dir(targetdir)
   s nomount(targetdir)=1
   s errmsg="Error restoring to database "_targetdir_" from journal file "_$g(%jrnfile)_". Skipping subsequent updates to the database"
   d logmsg(errmsg,0,2)
   s ^SYS("RESTORE","JOURNAL",RestTime,"Errors",$i(^SYS("RESTORE","JOURNAL",RestTime,"Errors")))=errmsg
   s ^SYS("RESTORE","JOURNAL",RestTime,"SkipDB",targetdir)=1_","_%jrnfile ;same as nomount()
 }
 q
skipdirE s $zt=""  d logmsg($ze,0,1) s $ze="" q
 ; we haven't dejournalled from this directory - see if its mounted
 ; adr/jrnfile is the current position in case we want to remember
 ;   this to recovery a non-recovered db later
mount(mdir,adr,jrnfile)
 n a
 n dbattrib,nojrnbit,mirrorbit,mirrorstate  ;JO2141 
trymnt i checkerr s $zt="nomnt"
 s $ze="" ;clear $ze so that nomnt can tell whether it is a real error
 s a=$zu(49,mdir) i (a=-2)!(a=-3) g nomnt
 s dbattrib=+$p(a,",",17),nojrnbit=+$zu(40,8,23)
 s mirrorbit=+$ZU(40,8,28)
 if $zb(dbattrib,mirrorbit,1) {
	s dbstatus=$p(a,",",18),failoverdbbit=$$getfailoverdb()
    if '$SYSTEM.Mirror.IsPrimary()&&$zb(+dbstatus,+failoverdbbit,1) {
	   ; you can't write to a mirrored database if this isn't the primary
	   ; this also covers skipping mirrored db's at startup
	   s nomount(mdir)=2
 	   d logmsg("Not restoring "_mdir_" because mirrored databases can only be restored on the primary",0,1)
  	   i $d(restopt(1)) {
	  	  s zjrnerr=(restopt[1)
  	   } elseif $g(CHATTY),'($d(nomount)#10) {
	 	  use 0
 	      i '($$yesno("Do you want to continue","Y")="Y") {
	 	      s zjrnerr=1
 	      } else {
 		     w !,"Journal records for ",mdir," will be ignored"
 	         s nomount=($$yesno("Always continue on future occurrences of similar problems","Y")="Y")
 	      }
 	   }
	   q:'$g(zjrnerr) 0 
	   s $ze="" 
	   ztrap $ze    
	}
 }
 i $zb(dbattrib,nojrnbit,1) d  q:'$g(zjrnerr) 0 s $ze="" ztrap $ze
 . s nomount(mdir)=2
 . i $g(STU)="S" d  i 1
 . . i $zu(173)=+a q  ;cachetemp
 . . s dbres=$p($p(a,",",25),"_",2)
 . . i dbres'="IRISLOCALDATA",dbres'="IRISLIB",dbres'="IRISTEMP" d logmsg("Not restoring "_mdir_" because the database is not journaled",0,1)
 . e  d logmsg("Not restoring "_mdir_" because the database is not journaled",0,1)
 . i $d(restopt(1)) s zjrnerr=(restopt[1) q
 . i $g(CHATTY),'($d(nomount)#10) u 0 d
 . . i '($$yesno("Do you want to continue","Y")="Y") s zjrnerr=1 q
 . . w !,"Journal records for ",mdir," will be ignored"
 . . s nomount=($$yesno("Always continue on future occurrences of similar problems","Y")="Y")
 i -1<a,a<$zu(40,0,41) s dir(mdir)=0,dbcol(mdir)=$Piece($zu(49,mdir),",",13) q 1
   ; 1st try to mount privately, then clustered
 s a=$zu(17,mdir,0) i a'<0 s dir(mdir)=1,dbcol(mdir)=$Piece($zu(49,mdir),",",13) q 1 ; private mount
 s a=$zu(17,mdir,1) i a'<0 s dir(mdir)=2,dbcol(mdir)=$Piece($zu(49,mdir),",",13) q 1 ; cluster mount
 s $ze=""
nomnt i checkerr s $zt="" ; Handle failure to mount directory
 s ze=$ze
 i checkerr=2 {
   s a=$$CheckErrMntRequired^ROLLBACK(mdir,.errlist)
   i +a=-2 {
     i $l(a,",")>1 d logmsg($p(a,",",2,$l(a)),0,2)
     d logmsg("Failed to mount required database "_mdir_$s(ze]"":": "_ze,1:""),0,2)
     s zjrnerr=1,$ze="" ztrap $ze
   }
 }
 d logmsg("Failed to mount database "_mdir_$s(ze]"":": "_ze,1:""),0,2)
 i $d(restopt(1)),(restopt[1) s zjrnerr=1,$ze="" ztrap $ze
 i '$g(CHATTY) g errmnt ; Skip Q&A if dialog not allowed
 i $$YN("Do you want to retry the mount","")="Y" w ! g trymnt
 w !,"Journal records for ",mdir," will be ignored"
 i '($$yesno("Do you want to continue","")="Y") s zjrnerr=1 ztrap $ze
errmnt s $ze="",nomount(mdir)=2 q 0_","_a ; Problems
getfailoverdb()
 n x
 try {
	 s x=$zu(40,8,33)
 } catch {
	 s x=$zh("80000")
 }
 q x
nextupd i checkerr s $zt="nxterr"
 s nextadr=$zu(78,17,adr) g nxtdone:'nextadr s adr=nextadr
 s type=$zu(78,8,adr)
 i type=13 q
 ;if it is SET/KILL, check to see if we care. If we do, leave it to
 ;restore; otherwise, skip to the next record
 i (type=6)!(type=7)!(type=9)!(type=14)!(type=22)!(type=24)!(type=25)!(type=26) D  Q:$G(modify)!ALL  g nextupd
 . D:'ALL check
 . Q:'$zu(78,9,adr)  ;optimized for (modify!ALL)&`jrntrans
 . D:($G(modify)!ALL)
 . . ;make sure it is not already in either tranopen or badtran
 . . Q:$D(tranopen($zu(78,10,adr),$ZU(78,25,adr)))
 . . Q:$D(badtran($zu(78,10,adr),$ZU(78,25,adr)))
 . . S badtran($zu(78,10,adr),$ZU(78,25,adr))=adr_","_jrnfile
 ;restore does not care about TSTART/TCOMMIT.
 ;if 2nd TSTART for the same pid appears, 1st one will be forgotten or
 ;ignored. it would be better if tranopen and badtran are combined 
 ;into one.
 i type=4 d  g nextupd
 . s tranopen($zu(78,10,adr),$ZU(78,25,adr))=adr_","_jrnfile
 . K badtran($zu(78,10,adr),$ZU(78,25,adr))
 i type=5 d  g nextupd
 . k tranopen($zu(78,10,adr),$ZU(78,25,adr))
 . K badtran($zu(78,10,adr),$ZU(78,25,adr))
 i type=-1 g nxtdone
 g nextupd
nxterr S $ZT="" 
 i $g(zjrnerr) ztrap $ze 
 i $ze["<Z",$g(resterr)]"" d logmsg(resterr,0,2) i 1
 e  d logmsg("Error processing journal record at offset "_$g(adr)_" of file "_$g(%jrnfile)_": "_$ze,0,2)
 d:checkerr=2
 . ; for checkerr=2 we record errors in the errlist array. Here we
 . ; have a problem with an entire journal file. These are recorded in
 . ; the "misc" (as opposed to "db") subnode. adr is set to NULL since it
 . ; doesn't apply here.
 . n index
 . s errlist=$G(errlist)+1
 . s errlist("all",errlist)=$LISTBUILD($G(%jrnfile),"",$ZE)
 . s index=$I(errlist("misc"))
 . s errlist("misc",index)=$LISTBUILD($G(%jrnfile),"",$ZE)
 i $d(restopt(2)) s zjrnerr=(restopt'[2) i 1
 e  i $g(CHATTY) d
 . w !,"It is recommended that you abort dejournaling at this point. However,"
 . w !,"if you decide to continue, we will have to skip the rest of the file."
 . s zjrnerr='($$yesno("Do you want to continue","N")="Y")
 i $g(zjrnerr) ztrap $ze
 d logmsg("Skipping the rest of the journal file",0,0)
 s $ze=""
 s type=-1,adr=0 q
nxtdone ;
 i adr'<lastindex s type=-1,adr=0 q
 s resterr="Journal "_$g(%jrnfile)_" ends unexpectedly at "_adr_" (end expected at "_lastindex_") - possible corruption in the journal" 
 ztrap "JEND"
 ;
check ;
 s dir=$zu(78,12,adr)
 S cd=$G(dirnam(dir)) I cd="" S (cd,dirnam(dir))=$S($G(xOS)||(dir[":mirror:"):dir,1:$ZU(12,dir)) i $d(dejrnNodup),'$d(dejrnNodup(cd)) s dejrn(cd)=1 s @statnode@(cd)=$j ;consider hashing on restore daemon number to spread these out.
 I $G(dejrn(cd)) S modify=1 Q  ;entire directory is valid
 i '$D(dejrn(cd)) s modify=0 q  ; not dejournaling this directory
   ; no - see if global is valid
 s gnode=$zu(78,13,adr)
 s glo=$e($qs(gnode,0),2,512)
 S modify=0 I $D(dejrn(cd,glo)) S modify=1 Q  ;specified global
 N pat,g S g="" F  S g=$O(dejrn(cd,g)) Q:g=""  DO  Q:modify
 . S pat=dejrn(cd,g) I pat="" S pat=$$PATRN(g),dejrn(cd,g)=pat
 . I glo?@pat S modify=1 ;global matches requested pattern
 Q  ;modify=1 if matches one of the patterns
open i checkerr s $zt="openend"
 s clu=$zu(78,5,%jrnfile,0)
 i clu<0 s resterr="ERROR OPENING JOURNAL FILE "_%jrnfile ztrap "OPEN"
 s a=$zu(78,6,clu),adr=0
 q
openend S $ZT="" s adr=-1 g nextfileE
close I checkerr S $ZT="etclose"
 S a=$zu(78,7,clu),clu=-1
 Q
etclose S adr=-1 Q
 ;
   ; $$curfile()
   ; returns current journal file name, if any, else ""
curfile() s $zt="curfile1" q $p($zu(78,4)_","_$zu(78,3),",",2)
curfile1 q ""
 ; 
ZJRNERR d $zu(9,"",$ze_" error during journal filter",(1>0),1)
 d $zu(9,"","***Restore is aborted***",(1>0),1) s zjrnerr=1,$ze="" zq 1 g @$zt
 ;
 ; Input: globname
 ; Modified (sortend only): sortcnt
sortbeg q:$g(disablesort)  s $zt="sortbegE" x "i $sortbegin("_globname_"),$i(sortcnt(globname))" q
sortbegE s $zt="" 
 i $i(sortbegerr(globname,$ze))>1 s $ze="" q  
 d logmsg("Error starting sorting on global "_globname_": "_$ze,0,2)
 i $d(restopt(1)) s zjrnerr=(restopt[1) i 1
 e  i $g(CHATTY),'$g(sortbegerr) d
 . w !,"If you decide to continue, updates of the global may be applied" 
 . w !,"without being sorted first."
 . i '($$yesno("Do you want to continue","Y")="Y") s zjrnerr=1 q
 . s sortbegerr=($$yesno("Always continue on future occurrences of similar problems","Y")="Y")
 i $g(zjrnerr) ztrap $ze
 s $ze=""
 q
sortend q:$g(disablesort)  s $zt="sortendE" x "ztrap:$sortend("_globname_")<0 ""SORT""" k sortcnt(globname) q
sortabort q:$g(disablesort)  s $zt="sortendE" x "ztrap:$sortend("_globname_",0)<0 ""SORT""" k sortcnt(globname) q
sortendE s $zt=""
 i $i(sortenderr(globname,$ze))>1 s $ze="" q  
 d logmsg($s($g(abortflush):"Discarding",1:"Applying")_" updates of global "_globname_" failed"_$s($ze["<NAMESPACE>":" due to namespace change",1:"")_": "_$ze,0,2)
 i $g(flushonerr) k sortcnt(globname) q
 i $d(restopt(1)) s zjrnerr=(restopt[1) i 1
 e  i $g(CHATTY),'$g(sortenderr) d
 . w !,"Updates to the global ",globname," have been lost."
 . w !,"You can either complete this journal restore and then re-run it for "
 . w !,"only this global, or you can abort the journal restore and restart it"
 . w !,"for all globals."
 . i ($$yesno("Do you want to abort","Y")="Y") s zjrnerr=1
 i $g(zjrnerr) k sortcnt(globname) ztrap $ze
 s $ze=""
 q
 ; 
sortlimit ;
 q:$g(disablesort)
 s $zt="sorterr"
 i $v($zu(40,1,55),-1,4)<sortchunklimit q  
 n globname
 s globname="" f  s globname=$o(sortcnt(globname)) q:globname=""  d sortend
 q
sortflush(abortflush) ;flush all sorted SETs to databases or abort sorting
 s $zt="sorterr"
 q:$g(disablesort)
 n flushonerr
 i $g(zjrnerr) s flushonerr=1
 e  s flushonerr=0
 i $g(abortflush) d  q
 . s globname="" f  s globname=$o(sortcnt(globname)) q:globname=""  d sortabort
 n totalcnt,globcnt,cnt 
 s totalcnt=0,globname="" f  s globname=$o(sortcnt(globname)) q:globname=""  s totalcnt=totalcnt+sortcnt(globname) i $i(globcnt)
 i 'totalcnt q  ;nothing to flush
 i $g(STU)="S" d $zu(9,"","Journal reads completed. Applying changes to databases...",(0>0),0) i 1
 e  w !!,"Journal reads completed. Applying changes to databases...",!
 s cnt=0,globname="" f  s globname=$o(sortcnt(globname)) q:globname=""  s cnt=cnt+sortcnt(globname) d sortend w:$g(STU)'="S" $j(cnt/totalcnt*100,7,2),"%"
 q
sorterr s $zt="" 
 i $g(zjrnerr),'$g(flushonerr) ztrap $ze ;pass error from sortend
 i '$d(sortcnt) d logmsg($ze_", but no global appears affected",0,1) q
 d logmsg("Failed to "_$s($g(abort):"discard",1:"apply")_" updates: "_$ze,0,2)
 d logmsg("The following globals are affected and should be restored again",0,0)
 n globname s globname="" f  s globname=$o(sortcnt(globname)) q:globname=""  d logmsg(globname,0,0)
 i $d(flushonerr) k sortcnt
 i $g(flushonerr) q
 i $d(restopt(1)) s zjrnerr=(restopt[1) i 1
 e  i $g(CHATTY),'$g(sorterr) d
 . i '($$yesno("Do you want to continue","N")="Y") s zjrnerr=1 q
 . s sorterr=($$yesno("Always continue on future occurrences of similar problems","Y")="Y")
 i $g(zjrnerr) ztrap $ze
 s $ze=""
 q
ClearSwitch10() ;
 i $g(clrsw10)]"" q clrsw10 ;it has been asked before, so leave it
 i '$SYSTEM.Util.GetSwitch(10) q 1 ;switch 10 is CLEAR/OFF
 i '$g(CHATTY) s clrsw10=0 q 0 ;leave switch 10 ON in non-interative mode
 w !?5,"** WARNING ** Switch 10 is set, preventing multi-job journal restore"
 w !?5,"Will restore in single job mode if switch 10 is not cleared"
 i $$YN("Clear switch 10 to start multi-job restore","N")="N" s clrsw10=0
 e  i $System.Util.SetSwitch(10,0) s clrsw10=1
 e  d resterrlog("Unable to clear switch 10") s clrsw10=0
 q clrsw10
 ; 
 ; Purpose: perform concurrent restore whenever possible
 ; Input: numrestjobs, dejrn
multrest ;single-system or cluster restore with concurrent job support
 s $zt="multrestE"
 ; CHATTY, QUIETMODE: whether to allow user input (CHATTY=1, QUIETMODE=0)
 ;                    [no user input allowed in jobbed jobs] 
 n i
 n dir ;source database directory
 n targ ;target database directory
 n target ;(targ): array of database redirections, indexed by target databases
 n restjob ;(i,targ): array of jobbed jobs' PIDs & associated target databases
 n stat ;(i): array of jobbed jobs' status (success/failure/percentdone)
 n statnode ;the global node for restore job to set success/failure upon exit
 n statnodebase ;the base of statnode
 n percentdone ;(pid): percentage of restore done by a job, indexed by PIDs
 n trannode ;transaction info from restore jobs: ("open") or ("bad")
 n abort ;1 to abort concurrent restore (may continue to single job restore)
 n pid
 s (statnode,statnodebase)=$name(^SYS("RESTORE","JOURNAL",RestTime,"Status"))
 s trannode=$name(^SYS("RESTORE","JOURNAL",RestTime,"transactions"))
 i numrestjobs=1 d onejobrest q  ;no concurrent restore on SP machines
 ; Distribute workload by target databases. It is possible, although unlikely,
 ; that multiple source databases are redirected to one target database.
 i '$d(dejrn) d GetDirList(.numrestjobs,.dejrn,.dejrnNodup) i numrestjobs=1 k dejrn,dejrnNodup d onejobrest q  ;one job to restore ALL databases
 s dir="" f  s dir=$o(dejrn(dir)) q:dir=""  S targ=$G(dejrn(dir)),targ=$P(targ,",",2,$L(targ)) S:'$L(targ) targ=dir m target(targ,dir)=dejrn(dir)
 ; count # of targ databases and assign them to available CPUs
 s targ="" f i=0:1 s targ=$o(target(targ)) q:targ=""  s restjob(i#numrestjobs,targ)=""
 i i<2 s numrestjobs=1 d onejobrest q  ;only one database to restore
 i '$$ClearSwitch10() s numrestjobs=1 d onejobrest q 
 i i<numrestjobs s numrestjobs=i ;not enough target databases to use all CPUs
 i $g(cachetempmaxblks) s sortchunklimit=sortchunklimit\numrestjobs ;per-job threshold
 i $g(restopt)'["0" d getrestopts(.restopt,numrestjobs)
 i $d(ALL) n SaveAll s SaveALL=ALL,ALL=0
 w !! s abort=0 f i=0:1:(numrestjobs-1) d  q:abort  ;i = pseudo CPU#
 . ;fix dejrn info and statnode before passing them on to the jobbed job
 . ;note that the original dejrn and statnode remain intact as we NEW them here
 . n statnode s statnode=$name(@statnodebase@(i))
 . n dejrn s targ="" f  s targ=$o(restjob(i,targ)) q:targ=""  m dejrn=target(targ) s @statnode@(targ)=""
 . s Tempnode=$name(^IRIS.Temp($i(^IRIS.Temp))) s ^|"%SYS"|IRIS.TempNodes($a($zcrc($p($j,":"),9)),$p($j,":"),"gbl",$name(@Tempnode))=$lb($zutil(99),$username,$namespace)
 . m @Tempnode@(1)=jrnlist
 . m @Tempnode@(2)=JrnFileList
 . n jrnlist,JrnFileList
 . j onejobrest:(:(1+2)):10 e  d  q  ;may abort concurrent restore
 . . d restjobfail(i)
 . . k @Tempnode
 . . k ^|"%SYS"|IRIS.TempNodes($a($zcrc($p($j,":"),9)),$p($j,":"),"gbl",$name(@Tempnode))
 . k dejrnNodup
 . s restjob(i)=$zc d restjobok(i)
 ; optionally run single-job restore if concurrent restore has been aborted
 i $d(SaveALL) s ALL=SaveALL
 k Tempnode
 i abort d  q  
 . i $g(CHATTY),$$YN("Restore in single job mode","Y")="N" q  ;no restore
 . k restopt s restopt=""
 . d onejobrest
 k jrnlist,JrnFileList
 ; periodically check the status of each remaining restore job; print progress
 d MONITOR(RestTime,''$d(clujrn),10,1) q:abort
 w !!,"[Journal restore completed]"
 ; prepare for transaction rollback (to be done by caller) if necessary
 m tranopen=@trannode@("open"),badtran=@trannode@("bad")
 q
multrestE ;
 s $zt=""
 i $g(zjrnerr) ztrap $ze
 i $ze'["INTERRUPT" d resterrlog($ze),BACK^%ETN
 ; offer an option to monitor progress of restoring if current job ("monitor")
 ; quits without aborting existing restor jobs
 i $d(restjob) d restfail i 'abort w !!,"To monitor or manage existing restor jobs, ",!,?8,"DO MONITOR^JRNRESTB(""",RestTime,"""",$s($d(clujrn):",1",1:""),")",!
 q
GetDirList(numrestjobs,dejrn,dejrnNodup) public {
 s rset=##class(%Library.ResultSet).%New("SYS.Database:List")
 d rset.Execute()
 while rset.Next() {
	 s t=rset.GetData(1),dejrn(t)=1
 }
 k rset
 s rset=##class(%Library.ResultSet).%New("Config.Databases:List")
 d rset.Execute()
 while rset.Next() {
	 s t=##class(%Library.File).ComputeFullDBDir(rset.GetData(2)),dejrn($zu(12,t))=1
 }
 k rset
 s n=0,d="" f  s d=$o(dejrn(d)) q:d=""  d
 .s x=$zu(49,d) i +x<0 k dejrn(d) q
 .s t=$zb(+$p(x,",",17),+$zu(40,8,23),1)
 .i 't s n=n+1 q
 .k dejrn(d) q
 m dejrnNodup=dejrn
 i n<numrestjobs s numrestjobs=n
 q n
}
resterrlog(msg) w !,*7,"[***ERROR: ",$g(msg),"]",! q 
 ; Input: restjob
 ; i: pseudo CPU#, index of restjob and stat arrays
restjobfail(i) ;
 w !,*7,"***ERROR: Failed to job off a job to apply journal to "
 s targ="" f  s targ=$o(restjob(i,targ)) q:targ=""  w !,?8,targ 
 k restjob(i)
 d restfail
 q
 ; Input: restjob, statnodebase
 ; i: pseudo CPU#, index of restjob and stat arrays
restjobok(i) ;
 w !,"Restore Job #",i," (PID ",restjob(i),") applying journal to "
 s targ="" f  s targ=$o(restjob(i,targ)) q:targ=""  w !,?8,targ s @statnodebase@(i,targ)=restjob(i)
 q
restfail ;
 i $g(CHATTY),$$YN("Abort concurrent restore and terminate existing restore jobs (if any)","Y")="N" q
 s i="" f  s i=$o(restjob(i)) q:i=""  i $g(restjob(i)),'$zu(4,restjob(i)) d resterrlog("Failed to kill job of PID "_restjob(i))
 w !!,"[Concurrent journal restore aborted]",!
 k restjob
 s abort=1
 q
 ; Input: restjob
 ; Return: >0 (completion time) - restore completed
 ;         -1,error - restore failed
 ;         0,percentdone - ongoing restore 
reststat(i) ;
 n pid,stat
 s pid=restjob(i),stat=$g(@statnodebase@(i)) i stat q stat  ;success or failure
 i $zu(67,0,pid)<2 s stat=$g(@statnodebase@(i)) s:'stat stat="-1,Job terminated abnormally"  q stat
 q "0,"_$$restpercent(pid)
 ;
 ; Purpose: Show completion time (on success) or error message (on failure)
 ; Input: 
 ;   restjob, stat
 ;   i - pseudo CPU#, index of restjob and stat arrays
showstat(i) ;
 n pid s pid=restjob(i)
 i stat(i)>0 w !,"[Restore Job #"_i_" (PID ",pid,") completed restore at ",stat,"]",! q
 d resterrlog("Restore Job #"_i_" (PID "_pid_"): "_$p(stat(i),",",2,$l(stat(i))))
 q
 ;
 ; Return percentage done by job 'pid' or "" if job (temporarily?) unavailable
restpercent(pid) ;
 s $zt="restpercentE"
 q $zu(88,2,pid,"percentdone") ;$zu(88) may get spurious <NOJOB> errors
restpercentE s $zt="" d:$ze'["<NOJOB>" BACK^%ETN q ""
 ;
 ; Show 'percentdone' values of existing restore jobs in columns (CPU#)
 ; if pid is specified, show 'percentdone' value of one job
 ; Input: stat, restjob, numrestjobs, isclujrn
 ; Input/Output: percentdone
showpercent(i) ;
 i $d(i) d  q
 . s percentdone=$p(stat(i),",",2,$l(stat(i)))
 . i $p(percentdone,",",2)'=$p($g(percentdone(i)),",",2) d  i 1
 . . n info s info=$p(percentdone,",",2) 
 . . w !,"Restore Job #",i," restoring "
 . . i info?1.N,$g(isclujrn) n a s a=$zdth(info,-2) w "cluster start: ",$ZD(a)," ",$ZT($P(a,",",2),4) i 1
 . . e  w "journal ",info ;may apply to cluster restore (cf. restoreone)
 . . w !
 . . s percentdone(i)=percentdone
 . e  i +percentdone>$g(percentdone(i)) s percentdone(i)=percentdone
 . e  s percentdone=+$g(percentdone(i))
 . w ?(i*8),$j(percentdone,7,2),"%"
 s i="" f  s i=$o(restjob(i)) q:i=""  s stat(i)=$g(stat(i)) q:$p(stat(i),",",2,$l(stat(i)))'=$g(percentdone(i))
 i i="" w "." q  ;no progress so far; just print a dot on the same line
 ; there is some progress; print the percentages on a new line, in columns
 w ! f i=0:1:(numrestjobs-1) i $g(restjob(i)) d showpercent(i)
 q
onejobrest ;one job restore (perhaps a jobbed off job)
 s $zt="resterr"
 i $g(Tempnode)'="" {
   s $zstorage=2**31-1 ;max value
   m jrnlist=@Tempnode@(1)
   m JrnFileList=@Tempnode@(2)
   k @Tempnode k ^|"%SYS"|IRIS.TempNodes($a($zcrc($p($j,":"),9)),$p($j,":"),"gbl",$name(@Tempnode))
   k Tempnode ;to avoid coming back here again (just in case)
 }
 i $g(shrid,-1)'<0 {
   i $zu(78,51,shrid,0,0) ;job designated as journal reader
   s tempnode=$$InitTempNode^JRNRESTF($name(^SYS("RESTORE","JOURNAL",RestTime)),shrid)
   i fastrest=2 {
     s promptnode=$name(@tempnode@("Prompt"))
     s @promptnode=prompt
   }
 }
 i '$g(disablesort) s disablesort=1,cachetempmaxblks=0
 i $zj\2#2=0,$g(restopt)'["0" d getrestopts(.restopt,0)
 i $zu(68,1,1)
 i $zj\2#2=0 k trannode 
 e  s CHATTY=0,QUIETMODE=1 D:$g(disjrn) DISABLE^%SYS.NOJRN
 ; If we're restoring clustered directories then go off to cluster restore
 i $S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0),$d(clujrn) s:fastrest fastrest=1 d restore^JRNCLUREST i 1
 e  d sysrest ;otherwise, perform a single-system restore
 d sortflush()
 k sortcnt 
 d restdone
 q
sysrest ;single-system restore (as opposed to clu restore, restore^JRNCLUREST)
 s $zt="sysrestE"
 ;the post-"d nextfile" jrnfile is the one dejournalled in nextfile
 ;make sure djlast is no greater than %curfile (<=current date)
 ;DEJRNSTART is valid for the first file to dejournal only
 S jrnfile="",%jrnfile="" f  d nextfile q:+$g(zjrnerr)  q:'(($p(djlast,".")>$p(jrnfile,"."))||(($p(djlast,".")=$p(jrnfile,"."))&&(+$p(djlast,".",2)>+$p(jrnfile,".",2))))  k DEJRNSTART
 q
sysrestE ;similar to resterr^JRNCLUREST
 S $ZT=""
 i '$$askabort() q
 i $g(clu)]"",clu'<0 s clu=$zu(78,7,clu),clu=-1
 ztrap $ze
resterr s $zt="resterr1"
 n ze i $$askabort() s ze=$ze 
 i $d(sortcnt) d  ;do this only if there are sorted, not-yet-applied updates
 . n abort s abort=0
 . i '$g(zjrnerr) s abort=0 ;always apply sorted updates if we are NOT aborting
 . e  i $g(CHATTY) s abort=($$YN("Apply updates to databases before aborting restore","N")="N") i 1
 . e  i $d(restopt(3)) s abort=(restopt[3)
 . d sortflush($g(abort))
 . k sortcnt 
 i $g(shrid,-1)'<0 d FreeShare^JRNRESTF(RestTime)
 i '$g(zjrnerr) s $ze="" q
 i $d(ze) s $ze=ze 
resterr1 s $zt="",zjrnerr=1
 i $g(statnode)]"" s @statnode="-1,"_$ze_","_$g(zjrnerrmsg)
 i $zj\2#2 d logmsg("journal operation aborted",1,2) i 1
 e  w !!,"[journal operation aborted]",!
 ztrap $ze
askabort() s $zt=""
 u 0
 i $g(zjrnerr) q 1
 d logmsg($ze,0,2) 
 i $g(CHATTY),$$YN("Continue","NO")="Y" s $ze="" q 0 ;continue rather than abort
 s zjrnerr=1
 q 1
restdone ;after a successful restore...
 i $g(shrid,-1)'<0 {
   i $zu(78,49,shrid)<0 ztrap "SYNC"
   s sfnupd=$zu(78,76,shrid,-3)
   s i=0 f  {
     s i=$f(sfnupd,1,i) q:'i
     s sfn=i-2
     s ^SYS("RESTORE","JOURNAL",RestTime,"DB",sfn)=$p($zu(49,sfn,3),"^",2)
   }
   d FreeShare^JRNRESTF(RestTime)
 }
 m ^SYS("RESTORE","JOURNAL",RestTime,"NomntDB")=nomount
 w !!,"[journal operation completed]"
 i $g(statnode)]"" s @statnode=$zdt($h,8) ;completion time (>0), incl. flushing
 ; trannode is defined iff ROLLJRN=1 and $zj\2#2=1 (jobbed job)
 ; tranopen and badtran arrays should be identical among complete restore jobs
 ; thus, one copy is enough.
 i $g(trannode)]"" l +@trannode m:'$d(@trannode) @trannode@("open")=tranopen,@trannode@("bad")=badtran l -@trannode
 q
MONITOR(RestTime,isclujrn,interval,passthru) ;
 i '$g(passthru) n (RestTime,isclujrn,interval,passthru) d monini q:abort  s $zt="multrestE"
 w ! f  q:'$d(restjob)  d showpercent() h interval s i="" f  s i=$o(restjob(i)) q:i=""  s (stat,stat(i))=$$reststat(i) i stat d showstat(i) k restjob(i) i stat<0 d restfail q:abort
 q
monini ;
 s CHATTY=1,QUIETMODE=0
 i '$d(RestTime) w "Invalid parameter ",RestTime,! q
 s statnodebase=$name(^SYS("RESTORE","JOURNAL",RestTime,"Status"))
 m restjob=@statnodebase
 i '$d(restjob) w "Not available for monitoring",! q
 s numrestjobs=$o(restjob(""),-1)+1,isclujrn=+$g(isclujrn) i isclujrn s clujrn=1
 s abort=0,interval=$g(interval,10) ;default interval 10 seconds
 s i="" f  s i=$o(restjob(i)) q:i=""  d  q:abort
 . s targ=$o(restjob(i,"")) i targ="" k restjob(i) q  ;something unexpected
 . s (stat,stat(i))=$g(restjob(i)),restjob(i)=restjob(i,targ) ;PID
 . i stat d showstat(i) k restjob(i) i stat<0 d restfail
 k stat  ;showpercent() assumption
 q
wuvl(str) ;write a str in Undefined mode, Variable Length field (2 or 4 bytes)
 n len
 s len=$l(str)
 i len<32768 w $zwc(len),str q
 i len>=(2**31) {
   d $zu(9,"","Value length "_$l(str)_" exceeds limit",(0>0),0)
   d $zu(96,0,5) ;generate a <MAXSTRING> error to be trapped by skiprec
 }
 w $zwc(len\65536+32768),$zwc(len#65536),str
 q
wvar(s)	;s s=$zcvt(s,"O",xlate) ;caller passed in 's' in translated form
 i fmode1'="U" w s w:fmode1="S" ! q
 i recsep=+recsep s l=$l(s) w $zwc(l),s w:recsep=2&(l#2) $c(0) q
 w s,recsep
 q
logmsg(msg,quietly,severity) ;
 i '$g(quietly),$g(CHATTY) d
 . i $g(severity) u 0 w !,*7,"***",$s(severity>1:"ERROR",1:"WARNING"),": ",msg,!
 . e  u 0 w !,msg,!
 i $zu(9,"","[JOURNAL RESTORE] "_msg,0,severity)
 i severity>1 s zjrnerrmsg=msg
 q
msgout(msg,indent) ;
 n off,i,word 
 s indent=+$g(indent) u 0 w !?indent 
 f i=1:1:$l(msg," ") s word=$p(msg," ",i) w:($x+$l(word)>78) !?indent w word," "
 q
yesno(prompt,default) ;
 n ans u 0 w ! s ans=$$YN(prompt,$g(default)) w ! q ans
getrestopts(restopt,multi) [disablesort,zjrnerr] PUBLIC {
 s restopt(1,(""[1))="Continue despite database-related problems (e.g., a target database cannot be mounted, error applying an update, etc.), skipping updates to that database. Affected database(s) may not be self-consistent and will need to be recovered separately"
 s restopt(1,'(""[1))="Abort if an update would have to be skipped due to a database-related problem (e.g., a target database cannot be mounted, error applying an update, etc.). Databases will be left in a self-consistent state as of the record that caused the restore to be aborted. Parallel dejournaling will be disabled with this setting"
 s restopt(2,'(""'[2))="Abort if an update would have to be skipped due to a journal-related problem (e.g., journal corruption, some cases of missing journal files, etc.)" 
 s restopt(2,(""'[2))="Continue despite journal-related problems (e.g., journal corruption, some missing journal files, etc.), skipping affected updates"
 i '$g(disablesort) {
   s restopt(3,(""[3))="Apply sorted updates to databases before aborting"
   s restopt(3,'(""[3))="Discard sorted, not-yet-applied updates before aborting (faster)"
 }
 s restopt="0" ;initial values, all defaults, + indicate questions asked.
 s multi=+$g(multi)
 i multi d
 . w !,"Before we job off restore daemons, you may tailor the behavior of a"
 . w !,"restore daemon in certain events by choosing from the options below:"
 . s i="" f  s i=$o(restopt(i)) q:i=""  w ! d msgout("DEFAULT:    "_restopt(i,0),5) w ! d msgout("ALTERNATE:  "_restopt(i,1),5)
 i 'multi d
 . w !,"You may tailor the response to errors by choosing between the alternative"
 . w !,"actions described below.  Otherwise you will be asked to select an action"
 . w !,"at the time an error actually occurs." 
 . s i="" f  s i=$o(restopt(i)) q:i=""  w ! d msgout("Either "_restopt(i,0),5) w ! d msgout("or     "_restopt(i,1),5)
 i multi s yn=$$yesno("Would you like to change the default actions","N")
 i 'multi d
 .s yn=$$yesno("Would you like to specify error actions now","N")
 .i yn="N" k restopt
 i yn="N" g confirm  ;use defaults
 d get1restopt(.restopt,1)
 d get1restopt(.restopt,2)
 i '$g(disablesort) d get1restopt(.restopt,3)
 i multi w !,"Based on your selection, a restore daemon will",!
 e  w !,"Based on your selection, this restore will",!
 s i="" f  s i=$o(restopt(i)) q:i=""  d msgout("** "_restopt(i,restopt[i)) w !
confirm ;
 i $$yesno("Start the restore","Y")="N" s notresto=1,zjrnerr=1 ztrap "STOP"
 q
}
get1restopt(restopt,i) PUBLIC {
get1restoptask	;
 w ! d msgout(1_".  "_restopt(i,0),5) w ! d msgout(2_".  "_restopt(i,1),5)
 r !!,"Select option [1 or 2]:  ",option
 i option=1 q
 i option=2 s restopt=restopt_i q
 g get1restoptask
}
IsLongStringEnabled() PUBLIC {
  q 1
}
STOP(x) S x=$zconvert($E(x,1,4),"U") Q (x["EXIT")!(x["STOP")!(x["QUIT")!(x["HALT")!($E(x)="^")
YN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YN"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"yn","YN") I "^YN"'[R W "  enter Yes or No, please"
 S POP=(R="^") W $E($S(R="N":"No",R="Y":"Yes",1:""),$L(X)+1,3) Q R
YNN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No/Never w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ","Vv"[D:"Never => ",1:"") ;Yes, No, Never, or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YNV"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"ynv","YNV") I "^YNV"'[R W "  enter Yes or No, or V for Never, please"
 S POP=(R="^") W *8,$E($S(R="N":"No",R="Y":"Yes",R="V":"Never",1:""),$L(X),5) Q R
PATRN(X) N q,i,x,c S q=0,x="" F i=1:1:$L(X) S c=$E(X,i) S:c="""" c=c_c DO
 . I "*?&#"'[c S x=x_$S(q:c,1:"1"""_c),q=1 Q  ;simple text -- no pattern
 . S x=x_$E("""",q)_$S(c="&":"1A",c="#":"1N",c="*":".E",1:"1E"),q=0 Q
 S:q x=x_"""" S X=$P($P($P($P(X,"?"),"#"),"&"),"*") Q x ;return ?@x
HasFile(f) Q ''$zu(78,22,f) ;1: file exists 0: not
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/FILEINC.inc#1 $ ($Change: 7440104 $) */
 ; BITWISE.INC
FIXDIR(dir) ;procedure, dir is passed by reference
 Q:dir=""
 Q:$A(dir,$L(dir))=$A($s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""))
 s dir=dir_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")
 Q
fixdir(dir) ;function
 Q:dir="" ""
 Q:$A(dir,$L(dir))=$A($s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")) dir
 Q dir_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")
basename(f) ;similar to basename on UNIX
 Q $P(f,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""),1,$L(f,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""))-1)_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")
appdir(d1,d2) ;use $zu(12,d2) to append d2 to canonic dir
 S d1=d1_d2
 Q d1
VALIDIR(dir) ;validate directory dir and create it if dir doesn't exist
 new flag
 s flag=1
 g vdir2
validir(dir,flag) ;validate directory dir and optionally create it if it
vdir2 ; VALIDIR(dir) comes here with flag set to 1
 quit:$$ChkDirOrSpecEXISTS(dir)'="" 1   ; dir is valid and exists
 quit:$$ChkDirVALID(dir)="" 0    ; dir is not valid
 i flag'=1 q 0  ; flag says don't create, return failure
 new x
 set x=$$mkdir(dir)  ; returns 0 for success, 1 for failure
 q:x=1 0  ; failed to create
 quit:$$ChkDirOrSpecEXISTS(dir)="" 0   ; it doesn't we failed
 q 1  ; success
mkdir(dir) ;create a new directory
 q '##class(%Library.File).CreateDirectoryChain(dir)
jrnshort(jf,short) ;get/set short form of a journal file name FIXME HYY1999
         N (jf,short)
         S len=$L($P(jf,";"))
         Q:$G(short)="" $E(jf,len-11,len) ;"GET" form
         S $E(jf,len-11,len)=short ;"SET" form
         Q jf
GJrnPrefix(jf) ;extract prefix from the journal file name jf
         N (jf)
         S fname=$P(jf,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""),$L(jf,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")))       
         Q $e(fname,1,$l($p(fname,"."))-8)
GetJrnFileName(path) { 
	i $f(path,"/") q $p(path,"/",$l(path,"/")) ;presumably a Unix path
	if $f(path,"\") q $p(path,"\",$l(path,"\")) ;presumably a Windows path
	s vmsfile=$p(path,"]",2) i vmsfile="" q path ;a name only, not a path
	q $p(vmsfile,";") ;return name from a VMS path without trailing ";"
}
dirinvalidmsg(dir1,dir2) 
 n valid1,valid2,cnt,msg
 s valid1=$$VALIDIR(dir1),valid2=$$VALIDIR(dir2)
 s cnt=valid1+valid2 ; cnt = 0 if both invalid, 1 if one is valid
 s msg="The following journaling "
 s:cnt msg=msg_"directory is" 
 s:'cnt msg=msg_"directories are"
 s msg=msg_" not valid"_$C(13,10)
 s:'valid1 msg=msg_"     "_dir1_$C(13,10)
 s:'valid2 msg=msg_"     "_dir2_$C(13,10)
 q msg
ChkDirVALID(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,1)
ChkDirEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkDirOrSpecEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,3)
ChkDir(R) N N S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkBad S $ZT="" W !,"<"_$P($P($ZE,"<",2),">")_"> error -- invalid directory"
 Q ""
ASKSET(prompt,val,backup,help,pattern) ;procedure
 N x,done,def,enahelp,helpavail,backupavail
 s done=0
 s def=$G(val)
 s backup=$G(backup,0) 
 s enabackup=$S(backup=-1:0,1:1)
 s backupavail=$S(backup=1:1,1:0)
 s help=$G(help)
 s enahelp=$S(help="*":0,1:1) ;there might not be any help though
 s helpavail=$s(enahelp&($L(help)!($D(help)>1)):1,1:0)
 if 'enabackup n POP
 s POP=0
 f  d  q:done!POP
 . W !,$G(prompt)
 . w:($X+$L(def))>65 !,?5
 . w:$L(def) " <",def,">"
 . if helpavail!backupavail do
 . . w " [" w:helpavail "?" w:backupavail "^" w "]"
 . w:(($X+$L(def))>75) !,?5
 . W " => " 
 . R x,!
 . if x="^" d  q
 . . if 'enabackup s done=1 q
 . . if backupavail s POP=1 q
 . . w "...backup not available here"
 . if enabackup,x="""^""" s x="^",done=1 q
 . ;
 . if x="?" d  q
 . . if 'enahelp s done=1 q
 . . if 'helpavail w "...help not available here" q
 . . if $D(help)=1 w !?5,help q
 . . s x="" f  s x=$O(help(x)) q:x=""  w !,?5,help(x)
 . . w !
 . if enahelp,x="""?""" s x="?",done=1 q
 . i x]"",$g(pattern)]"",x'?@pattern w !?5,$s(helpavail:help,1:"[bad format]") q
 . s:'$L(x) x=val 
 . s done=1
 s:'POP val=x
 q

JRNRESTC^INT^1^67214,47330
JRNRESTC ;Cluster Restore Journal from a File, ;$Change: 7440104 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	; Revision: $Id: //iris/2024.1.3/databases/sys/rtn/journal/jrnrestc.mac#1 $
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/FILEINC.inc#1 $ ($Change: 7440104 $) */
 ; BITWISE.INC
 ;
DecodeDejrnBeg(beg) ;
 n code s code=+beg
 i code=0 q "the beginning of cluster session <"_$p(beg,",",2)_">"
 i code=1 q "the end of last restored backup "_$p(beg,",",3)
 i code=2 q "the journal marker located at"
 i code=3 q "the beginning of the cluster journal log"
 i code=4 q "the end of last journal restore"
 i code=5 s beg=$P(beg,",",2) q "the "_$P(beg,";",3)_" backup at "_$P(beg,";",2)_" "_$P(beg,";")
 q ""
DecodeDejrnEnd(end) ;
 n code s code=+end
 i code=0 q "the end of cluster session <"_$p(end,",",2)_">"
 i code=1 q "current journal location"
 i code=2 q "the journal marker located at"
 i code=3 q "the end of the cluster journal log"
 i code=5 s end=$P(end,",",2) q "the "_$P(end,";",3)_" backup at "_$P(end,";",2)_" "_$P(end,";")
 q ""
 ;variables:
 ; jrnlogdef - default cluster journal log on current system
 ; jrnlog - cluster journal log to use
 ;   jrnlog(i)=csn,jrnf : the i-th line of the log
 ; jrnlogr - cluster journal log with redirection (jrnredir) applied to
 ; jrnredir - 1 if there is redirection
 ;   jrnredir(olddir)=newdir or "" if not redirected
 ; dejrnbeg,dejrnend - range of journal restore
 ;   format of dejrnbeg and dejrnend: code,parameter(s)
 ;   format of dejrnbeg/dejrnend subscript level: dejrnbeg/end(jrnf)=addr
 ;
 ;   [dejrnbeg] code (meanings)		parameters		subscript level
 ;              ---------------------------------------------------------------
 ;                 0 (beg of session)	CluSesID		N/A
 ;                 1 (end of backup)	RestoreTime,BackupDev	jrnmark loc	
 ;                 2 (journal marker)	N/A			jrnmark loc
 ;                 3 (beg of jrnlog)	N/A			N/A
 ;                 4 (end of jrnrest)	RestoreTime		jrnmark loc
 ;                 5 (end of backup)	jrnmark text jrnmark loc        [JO1728]
 ;
 ;   [dejrnend] code (meanings)		parameters		subscript level
 ;              ---------------------------------------------------------------
 ;                 0 (end of session)	CluSesID		N/A
 ;                 1 (cur journal loc)	N/A			jrnmark loc	
 ;                 2 (journal marker)	N/A			jrnmark loc
 ;                 3 (end of jrnlog)	N/A			N/A
 ;                 5 (start of backup)	jrnmark text jrnmark loc        [JO1728]
 ;
ShowMenuSetupMain ;
 w !
 w !,"Cluster Journal Restore - Setup - Main Settings"
 w !,"1. Start restore at ",$$DecodeDejrnBeg(dejrnbeg)
 d ShowJrnMarkLoc(.dejrnbeg,1)
 w !,"   End restore at ",$$DecodeDejrnEnd(dejrnend)
 d ShowJrnMarkLoc(.dejrnend,1)
 w !,"2. Locate journal files using cluster journal log"
 w !,?6,jrnlog
 w !,?3,"with",$s('$g(jrnredir):" NO",1:"") w " redirections of journal files"
 i $g(jrnredir) d ShowJrndir
 q
 ;caller: SETUP^JRNRESTO
 ;callees:
 ; SetJrnlog - set cluster journal log (jrnlog)
 ; SetDejrnDef - set default range of journal restore (dejrnbeg,dejrnend)
 ; SetDejrn - set upper & lower bound of the range of journal restore 
 ;           (dejrnbeg/dejrnend)
 ; ShowMenuSetupMain
 ; convert ?
 ;output:
 ; nojrn - journaling disabled (and to be re-enabled after restore)
 ; notresto - 1 => abort journal restore
 ; clujrn - '$d(clujrn) => abort cluster journal restore
SETUP ;
 n dejrnswt,dejrndis,jrnlog,jrnlogr,jrnlogdef,jrnredir,dejrnbeg,dejrnend,jrninfo
 n rc,key
 n jrnmarklog,jrnmarkinfo,jrnmarklogdef
 s $zt="etSETUP",rc=0
 ; There is no reason the user has to switch journal files any more so
 ; the default is now no. In the past to end a restore at the end of the
 ; current journal file while you were journaling the restore required that
 ; you switch journal files to create an endpoint. Now when you choose end
 ; at the end of the current journal file we put a marker down and end there.
 s dejrnswt=0,dejrndis=0 ;default
 s (jrnlog,jrnlogdef)=$s($S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0):$p($zu(78,20),",",2),1:"") ;"" if not a clustered system
 s (jrnmarklog,jrnmarklogdef)=$s($S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0):$p($zu(78,20),",",3),1:"")  ;"" if not a clustered system
 i jrnlog]"" d
 . i $$ImportJrnlog(.jrnlog)<0 d errout(("Unable to open "_jrnlog)) s jrnlog="" q
 . d ImportJrndir,SetDejrnDef
 i jrnlog="" s rc=$$SetJrnlog() i rc<0 g Abort
 if $L(jrnlog),$L($g(jrnmarklog)),'$D(jrnmarkinfo) d  ;i rc<0 g Abort
 . s rc=$$ImportJrnMarklog(jrnmarklog,.jrnmarkinfo) 
 . i rc<0 d errout(("Unable to open "_jrnmarklog_". Start/End restore at backup not available.")) k jrnmarkinfo s jrnmarklog=""
 ; There are some special values of fromrest set by CLUMENU^JRNRESTO which
 ; change how we select the input file.
 ;    fromrest=6 is a restore based on backup 
 ;    fromrest=7 is a restore following a cache backup restore
 ; These are evaluated by SetDejrn() but we start with a call to SetDejrn()
 ; rather than displaying the main menu first.
 s rc=0
 if (fromrest=6)!(fromrest=7) s rc=$$SetDejrn() s:((rc=0)&(fromrest=7)) rc=-1 d  g:rc'=1 Abort g autodejrn
 . i rc<1 W !!,"Not able to establish a proper Start or Stop point. Aborting Recovery."
 . i rc>0 d switjrnfiletrans s:rc>0 rc=$$ConfirmDone() s:rc>0 rc=$$Convert()
goback ; 
 s key="" f  d  q:rc<0  d:rc>0 switjrnfiletrans s:rc>0 rc=$$ConfirmDone() q:rc>0
 . i $d(key) d ShowMenuSetupMain 
 . w !!,"Select an item to modify ([Q]uit or ENTER to accept and continue)/[?][H]elp: " r key
 . i key="" s rc=$$Convert() q
 . i ("Hh"[key)!(key="?") s rc=$$SetupmainHelp^JRNRESTCHELP() q
 . i "Qq"[key d  q
 . . w ! i $$YN("Are you sure you want to Quit the cluster journal restore","N")="Y" s rc=-1 q
 . i key=1 s rc=$$SetDejrn() q 
 . i key=2 s rc=$$SetJrnlog() q
 . w !,*7,"Invalid option ",key s rc=0 q
 i rc<0 g Abort
autodejrn ;path for options 1 and 2 to avoid main menu
 i +dejrnend=1!(+dejrnend=3) s ROLLJRN=1
 ; RestTime is set at the beginning of main^JRNRESTB
 s ^SYS("RESTORE","JOURNAL",RestTime,"Jrnlog")=jrnlog
 m:$d(jrnredir) ^SYS("RESTORE","JOURNAL",RestTime,"JrnRedir")=jrnredir
 m ^SYS("RESTORE","JOURNAL",RestTime,"RangeEnd")=dejrnend
 m ^SYS("RESTORE","JOURNAL",RestTime,"RangeBegin")=dejrnbeg
 n csn s csn="" f  s csn=$o(clumember(csn)) q:csn=""  m ^SYS("RESTORE","JOURNAL",RestTime,"Files",csn)=clumember(csn,"files")
 s ^SYS("RESTORE","JOURNAL",RestTime,"SeqFirst")=$g(minseq)_$s($g(minclumstart)="":"",1:","_minclumstart)
 s ^SYS("RESTORE","JOURNAL",RestTime,"SeqLast")=$g(maxseq)_$s($g(maxclumsart)="":"",1:","_maxclumstart)
 i $zu(78,22) d  g:((fromrest=6)!(fromrest-7))&(rc=0) Abort g:rc=0 goback
 . i dejrnswt,'$zu(78,1,"","","",0,5) d errout("Failed to switch journal file") d  
 . . s rc=$$YN("Do you wish to continue (Y/N) ","N")="Y" w !!
 . i 'dejrndis i $$CURRENT^%SYS.NOJRN() d DISABLE^%SYS.NOJRN s nojrn=1
 q
 ;purpose
 ;to allow user to switch journal file before journal restore and 
 ;to journal the dejournaled transactions
 ; dejrnswt - if 1, switch journal file before dejournaling
 ; dejrndis - if 1, disable journaling (process only) before dejournaling
switjrnfiletrans
 i $zu(78,22) d  
 . w !!,"---------------------------------------------------------"
 . s dejrnswt=$$YN("Switch journal file before journal restore (Y/N)","N")
 . i dejrnswt="^" s dejrnswt=0 s rc=0 q
 . s dejrnswt=$s(dejrnswt="N":0,1:1)
 . w !!,*7,"Journal file WILL "_$s(dejrnswt:"BE",1:"NOT BE")_" switched before journal restore" 
 . w !!!,"---------------------------------------------------------"
 . s dejrndis=$$YN("Journal the dejournaled transactions (Y/N)","N") 
 . i dejrndis="^" s dejrndis=0 s rc=0 q
 . s dejrndis=$s(dejrndis="N":0,1:1)
 . s disjrn='dejrndis
 . w !!,*7,"Dejournaled transactions WILL "_$s(dejrndis:"BE",1:"NOT BE")_" Journaled"
 . w !!,"---------------------------------------------------------"
 q
etSETUP ;
 s $zt=""
 i $e($ze,1,11)="<INTERRUPT>" d errout("Journal restore aborted") ZQ $ST q
 u 0 d errout(("Error: "_$ze)) d BACK^%ETN
 ZQ $ST
 q
Abort ;
 k clujrn 
 s notresto=$S($G(CLURESTORE):1,1:($$YN("Run private journal restore instead")="N"))
 i notresto d errout("Journal restore aborted")
 s POP=0
 q
ConfirmDone() ;
 ;show the first and last couple of journal files to dejournal?
 q ($$YN("Start journal restore? (Y/N)")="Y")
 ;purpose:
 ; specify cluster journal log and journal file redirections
 ;input:
 ; jrnlog, jrnlogdef
ShowMenuSetupJrnlog ;
 w !
 w !,"Cluster Journal Restore - Setup - Journal File Info"
 w !,"[I]dentify an existing cluster journal log to use for the restore"
 i jrnlog]"" w !,?3,"Current: ",jrnlog d
 . i jrnlog'=jrnlogdef w !,"[R]edirect journal files in ",jrnlog 
 w !, "  - OR -"
 w !,"[C]reate a cluster journal log by specifying where journal files are" 
 q
 ;caller: SETUP
 ;callees:
 ; SetJrnlogUse - new jrnlog
 ; SetJrnlogNew - new jrnlog
 ; SetJrnlogRedir - redirect journal files in jrnlog
 ; ShowMenuSetupJrnlog
 ;modified:
 ; jrnlog, jrnlogr, jrnredir, dejrnbeg, dejrnend
 ;return:
 ; rc - 0 on success, -1 to quit cluster restore
SetJrnlog() ;
 n rc,key
 s rc=0 f  d ShowMenuSetupJrnlog w !!,"Selection"_$S(jrnlog]"":" (<ENTER> if no change)",1:"")_" (^ to backup, Q to quit restore)/[?][H]elp: " r key d  q:key=""  q:rc<0
 . i key="" d:jrnlog=""  q
 . . w ! i $$YN("No cluster journal log specified. Quit cluster journal restore")="Y" s rc=-1 q
 . . s key=0 ;retry
 . i "Qq"[key d  q
 . . w ! i $$YN("Are you sure you want to Quit the cluster journal restore","N")="Y" s rc=-1 q
 . i key="^" s rc=0,key="" q
 . i ("hH"[key)!(key="?") s rc=$$SetjrnlogHelp^JRNRESTCHELP() q
 . i "Ii"[key d SetJrnlogUse q
 . i "Rr"[key,jrnlog]"",jrnlog'=jrnlogdef d SetJrnlogRedir q
 . i "Cc"[key s rc=$$SetJrnlogNew q
 q rc
 ;purpose: specify an existing journal log to use
 ;caller: SetJrnlog
 ;callees:
 ; ImportJrnlog - jrnlog
 ; ImportJrndir - jrnredir
 ; SetDejrnDef - dejrnbeg,dejrnend
 ; SetJrnlogWarning
 ;modified (if the given one different from current):
 ; jrnlog,jrnredir,dejrnbeg,dejrnend (see above) and jrnlogr (killed)
SetJrnlogUse ;
 n path,rc
 i jrnlog]"" d SetJrnlogWarning
 w !,"Enter the name of the cluster journal log (<ENTER> if no change)"
 r !,"=> ",path
 i path="" w "(no change)",! q
 i path="^" q
 s path=$zu(12,path) i path=jrnlog w "(no change)",! q  ;no change
 s rc=$$ImportJrnlog(.path) i rc<0 d errout(("Unable to open "_path)) q
 k jrnlog,jrnredir,jrnlogr,dejrnbeg,dejrnend,dejrnbegr,dejrnendr,jrninfo
 m jrnlog=path d ImportJrndir,SetDejrnDef
 k jrnmarkinfo s jrnmarklog=""
 if $L(jrnmarklogdef) d
 . ; Create the filename for the marker log out of the path for the journal
 . ; log file. If there is no default marker log then we don't do this.
 . n tmp,logfname
 . s logfname=$p(jrnmarklogdef,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""),*)
 . s tmp=$p(path,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""),*)
 . s jrnmarklog=$E(path,1,$l(path)-$L(tmp))_logfname
 . s rc=$$ImportJrnMarklog(jrnmarklog,.jrnmarkinfo) 
 . i rc<0 d errout(("Unable to open "_jrnmarklog_". Start/End restore at backup not available.")) k jrnmarkinfo s jrnmarklog=""
 q
 ;purpose: create a new journal log to use
 ;caller: SetJrnlog
 ;callees:
 ; CreateJrnlog - jrnlog
 ; ImportJrndir - jrnredir
 ; SetDejrnDef - dejrnbeg,dejrnend
 ; SetJrnlogWarning
 ;modified:
 ; jrnlog,jrnredir,dejrnbeg,dejrnend (see above) and jrnlogr (killed)
SetJrnlogNew() ;
 n rc,path
 i jrnlog]"" d SetJrnlogWarning
Redo w !,"Enter the name of the cluster journal log to create (^ to go back to menu)"
 r !,"=> ",path
 i (path="")!(path="^") s jrnlog=jrnlogdef q 0
 s path=$zu(12,path,0) o path:"r":0 i $t c path w !,"This file, "_path_", already exists!" i $$YN("Overwrite it")'="Y" g Redo
 s rc=$$CreateJrnlog(.path) i rc<0 q:($p(rc,",",2)="") -1 d errout($p(rc,",",2,$l(rc))) q -1
 k jrnlog,jrnredir,jrnlogr,dejrnbeg,dejrnend,dejrnbegr,dejrnendr,jrninfo
 ; When the user creates a journal log file there is no corresponding support
 ; for creating a marker log file but that's ok as they can enter the markers
 ; by journal file + offset if that's what they want.
 k jrnmarkinfo s jrnmarklog=""
 m jrnlog=path d ImportJrndir,SetDejrnDef
 q 0
SetJrnlogWarning ;
 w !!,*7,?30,"*** WARNING ***"
 w !,?8,"If you specify a cluster journal log different from current one, you"
 w !,?8,"may need to reenter info on journal redirection, restore range, etc."
 w !
 q
 ;purpose: redirect journal files in jrnlog
 ;caller: SetJrnlog
 ;callees:
 ; SetJrnlogRedirHelp^JRNRESTCHELP
 ; ImportJrndir - jrnredir
 ; RedirJrnlog - create jrnlogr by applying jrnredir to jrnlog
 ; RedirDejrnRange - applying jrnredir to dejrnbeg and dejrnend
 ;modified:
 ; jrnredir - 1 if redirection on
 ; jrnlogr,dejrnbegr,dejrnendr
SetJrnlogRedir ;
 n dir,src,dest,len
 w !,"Journal directories in ",jrnlog 
 i $g(jrnredir) w !,"... and current redirections (->)"
 d ShowJrndir
 i $g(jrnredir),$$YN("Keep current redirections")="N" k jrnredir d ImportJrndir
 w !,"Enter the original and current locations of journal files (? for help)"
 f  w !,"Journal files originally from (enter to quit)(? for help):",!,"---> " r src q:src=""  d
 . i src="?" d SetJrnlogRedirHelp^JRNRESTCHELP q
 . w !,"are currently located in (enter to quit-no change)(? for help):",!,"---> " r dest i dest="" w !,?4,"<no change>" q
 . i dest="?" d SetJrnlogRedirHelp^JRNRESTCHELP q
 . s src=$zu(12,src) i '$d(jrnredir(src)) w *7,!!,"Source directory not found in journal log!",! q 
 . s dest=$zu(12,dest) i dest'=jrnredir(src) s jrnredir(src)=dest,jrnredir=1 w !,?4,src," -> ",dest q
 . s dir=src,len=$l(src) f  s dir=$o(jrnredir(dir)) q:$e(dir,1,len)'=src  s dst=dest_$e(dir,len+1,$l(dir)) i jrnredir(dir)'=dst s jrnredir(dir)=dst,jrnredir=1 w !,?4,dir," -> ",jrnredir(dir)
 i $g(jrnredir) d RedirJrnlog,RedirDejrnRange
 q
 ;purpose:
 ; create a journal log by asking for journal file locations, load it to memory
 ;(version # should be the first line)
 ;input/output: jrnlog
 ;return:
 ; 0 on success, -1 if unable to open, -9 on other errors
CreateJrnlog(jrnlog) ;
 n i,j,dir,jrnf,prefix,wildcard
 n shortname
 s rc=0
 o jrnlog:"wns":0 e  q -1_","_("Unable to open "_jrnlog) 
 s $ze="",$zt="CreateJrnlogE"
 f  r !,"How many cluster members were involved? (^ to go back) => ",numclu q:numclu'<1  q:numclu="^"
 i numclu="^" c jrnlog s jrnlog=jrnlogdef k numclu q 0
 w !,"For each cluster member, enter the location(s) and name prefix (if any) of the journal files to restore --"
 w !!,*7,"Caution: Any entry errors will require an ABORT.  Enter Q to Abort the restore at any time",!
 s i=jrnlog k jrnlog s jrnlog=i  ;clears subnodes of jrnlog
 s wildcard="*.*" f i=0:1:(numclu-1) d  q:rc<0
 . f  w !,"Cluster member #",i r ?40,"Journal File Name Prefix: ",prefix d:((prefix'="")&("qQ"[prefix)!(prefix="^"))  q:rc<0  i (prefix="")!((prefix'="^")&("qQ"'[prefix)) q
 . . w ! i $$YN("Are you sure you want to Quit the cluster journal restore","N")="Y" s rc=-1
 . i rc<0 q
 . k jrnf f  r !,?2,"Directory: ",dir q:dir=""  d:((dir'="")&("qQ"[dir))  q:rc<0  s dir=$zu(12,dir),jrnf=$zse(dir_prefix_wildcard) f  q:jrnf=""  i $ZU(78,22,jrnf)=1 {s:$F(jrnf,"z;") $E(jrnf,$F(jrnf,"z;")-2)="" s shortname=$case($ZBITGET($ZVERSION(0),46),0:$case($f(jrnf,";"),0:$e(jrnf,*-8-$l($p(jrnf,".",$l(jrnf,"."))),*-$case($e(jrnf,*)="z",0:0,1:1)),:$e(jrnf,*-8-$l($p(jrnf,".",$l(jrnf,"."))),$f(jrnf,";")-2)),:jrnf),jrnf($s($l(shortname)<(20-1):$p(shortname,".")_$e(10000000000+$p(shortname,".",2),2,11),1:shortname)_"J")=jrnf} s jrnf=$zse("")
 . . w ! i $$YN("Are you sure you want to Quit the cluster journal restore","N")="Y" s rc=-1
 . i rc<0 q
 . s jrnf="" f j=1+$o(jrnlog(""),-1):1 s jrnf=$o(jrnf(jrnf)) q:jrnf=""  s jrnlog(j)=i_","_jrnf(jrnf)
 i rc<0 c jrnlog s jrnlog=jrnlogdef k numclu q -1
 i $d(jrnlog)=1 c jrnlog s jrnlog=jrnlogdef,rc=-1 w !!,"No entries selected" q -1
 i $d(jrnlog)=11 s rc=$$REFINEJRNLOGLIST(.path,.jrnlog)
 u jrnlog s i="" f  s i=$o(jrnlog(i)) q:i=""  w jrnlog(i),!
CreateJrnlogE ;
 s $zt=""
 c jrnlog i $ze]"",$ze'["<Z" d BACK^%ETN q -9_","_("Error: "_$ze)
 q 0
 ;purpose
 ;allow user to extract journal files from list prior to restore
REFINEJRNLOGLIST(path,jrnlog)
 n log,exclude,i,j,log1,log2,k,path1,jrnlogsave
 m jrnlogsave=jrnlog
 w !!,*7,*7,"WARNING: Removing files from the list could cause data inconsistencies since"
 w !,?9,"journal files are sequential in nature."
 w !!,"<<<enter>>> to continue...",*7,*7 r x
REFINEJRN1 w !!,"Review the list and select those numbers that are to be EXCLUDED from the list"
 s i="" f  s i=$o(path(i)) q:i=""  s log=path(i) w !,i,".",?5,log 
 w !!,"Enter numbers to be EXCLUDED"
 w !,?5,"separate numbers by a comma or use a dash for a range (ie. 1-5)"
 w !,"(Q) to Quit this editing, lose any changes and accept the original list"
 w !,"(R) to restore original list and begin editing list again"
 w !,"(A) to accept changes and file the new list"
 r !,"==> ",exclude
 i exclude="" W "Please enter numbers or Q, R or A" g REFINEJRN1
 i "Qq"[exclude k jrnlog m jrnlog=jrnlogsave q 0
 i "Rr"[exclude k path m path=jrnlogsave g REFINEJRN1 
 i "Aa"[exclude d  q 0
 . k path1 s i=0,log="" f  s log=$o(path(log)) q:log=""  s i=i+1,path1(i)=path(log)
 . s path1=jrnlog
 . k jrnlog,path m jrnlog=path1
 i '+exclude W "Please enter numbers or Q, R or A" g REFINEJRN1
 i exclude=+exclude k path(exclude) g REFINEJRN1
 i exclude["," s j="",log="" f j=1:1 s log=$p(exclude,",",j) g:log="" REFINEJRN1 d  
 . i +log=log k path(log) q
 . i log["-" s log1=$p(log,"-",1),log2=$p(log,"-",2) d  q
 . . f k=log1:1:log2 k path(k)
 i exclude["-" s log1=$p(exclude,"-",1),log2=$p(exclude,"-",2) d  g REFINEJRN1
 . f k=log1:1:log2 k path(k)
 q 0
 ;purpose:
 ; read journal log from disk into local array jrnlog
 ;do version checking here (major version - backward, minor - forward)
 ;input/output: jrnlog
 ;return:
 ; 0 on success, -1 if unable to open, -2 on version mismatch
ImportJrnlog(jrnlog,ver) ;
 n savemode,line,i o jrnlog:"r":0 e  q -1 
 s savemode=$zu(68,40,1) u jrnlog f i=1:1 r line q:line=""  s jrnlog(i)=line
 c jrnlog i $zu(68,40,savemode)
 q 0
 ;purpose:
 ; read journal marker log from disk into passed local array
 ;input: fname = name of file to open
 ;output: infoarray(1..n) = data from file in order read,
 ;        infoarray("index",marker id,<yyyymmdd hh:mm>)=1..n
 ;          where <yyyymmdd hh:mm> is the $H timestamp from the log file entry
 ;          marker id = -1 is a backup. ID's > 0 are user defined. There are no
 ;          other system defined markers at the moment (eg. < 0)
 ;return:
 ; 0 on success, -1 if unable to open
ImportJrnMarklog(fname,infoarray) ;
 n savemode,line,i,markerid,ds
 o fname:"r":0 e  q -1 
 s savemode=$zu(68,40,1) 
 u fname f i=1:1 r line q:line=""  d
 . s infoarray(i)=line
 . s markerid=+$P(line,"^",4)
 . s ds=$ZDATETIME($P(line,"^"),8) ;$H timestamp of log entry
 . s infoarray("index",markerid,ds)=i
 c fname
 i $zu(68,40,savemode)
 q 0
 ;purpose: extract journal directory info from jrnlog into jrnredir
 ;callers:
 ; SetJrnlogUse
 ; SetJrnlogNew
 ; SetJrnlogRedir
 ;input: jrnlog
 ;output: jrnredir
ImportJrndir ;
 n i,slash,jrnf,dir
 s slash=$s(($zversion(1)=3):"/",1:"\")
 s i="" f  s i=$o(jrnlog(i)) q:i=""  s jrnf=$p(jrnlog(i),",",2),dir=$p(jrnf,slash,1,$l(jrnf,slash)-1)_slash,jrnredir(dir)=$g(jrnredir(dir))
 q
 ;purpose: create jrnlogr by applying journal redirection info to jrnlog 
 ;caller: SetJrnlogRedir
 ;input: jrnlog
 ;output: jrnlogr, jrninfo (killed as it is derived from jrnlogr)
RedirJrnlog ;
 n i,slash,jrnf,dir
 s slash=$s(($zversion(1)=3):"/",1:"\") k jrnlogr,jrninfo
 s i="" f  s i=$o(jrnlog(i)) q:i=""  s jrnf=$p(jrnlog(i),",",2),dir=$p(jrnf,slash,1,$l(jrnf,slash)-1)_slash i jrnredir(dir)]"" s $e(jrnf,1,$l(dir))=jrnredir(dir),jrnlogr(i)=+jrnlog(i)_","_jrnf
 q
 ;caller: SetJrnlogRedir
RedirDejrnRange d RedirDejrn(.dejrnbeg,.dejrnbegr),RedirDejrn(.dejrnend,.dejrnendr) q
 ;callers:
 ; RedirDejrnRange
 ; SetDejrnBegBck
 ; SetDejrnBegOth
 ; SetDejrnEndOth
 ;input: loc (dejrnbeg or dejrnend) 
 ;output: cur (dejrnbegr or dejrnendr)
 ;perhaps we should verify (newf,addr) is a valid journal record??
RedirDejrn(loc,cur) ;
 n slash,jrnf,dir,newf
 i $d(loc)\10=0 q  ;no specific location
 s slash=$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"") k cur
 s jrnf="" f  s jrnf=$o(loc(jrnf)) q:jrnf=""  s dir=$p(jrnf,slash,1,$l(jrnf,slash)-1)_slash i jrnredir(dir)]"" s newf=jrnredir(dir)_$e(jrnf,$l(dir)+1,$l(jrnf)),cur(newf)=loc(jrnf)
 q
 ;Given a file in its original path, return the location it is redirected to
RedirFile(path) ;
 n dir,slash 
 s slash=$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""),dir=$p(path,slash,1,$l(path,slash)-1)_slash i jrnredir(dir)="" q path
 q jrnredir(dir)_$e(path,$l(dir)+1,$l(path))
ShowJrnMarkLoc(loc,showredir) ;
 n f 
 s f="" f  s f=$o(loc(f)) q:f=""  w !,$j(loc(f),12),",",f i $g(jrnredir),$d(showredir) w !,$j("->",12)," ",$$RedirFile(f)
 q
ShowJrndir ;
 n dir 
 s dir="" f  s dir=$o(jrnredir(dir)) q:dir=""  w !,?6,dir i jrnredir(dir)]"" w " -> ",jrnredir(dir)
 q
errout(err) w !!,*7,"[",err,"]",! q
ImportJrninfo(log) ;
 n i,csn,jrnf,gseq,seqinfo,gseq
 i '$d(log) q:$d(jrnlogr) $$ImportJrninfo(.jrnlogr) q $$ImportJrninfo(.jrnlog)
 n index s index=$$initjrninfo^JRNINFO() 
 s gseq=jrninfo s i="" f  s i=$o(log(i)) q:i=""  d
 . s csn=+$p(log(i),","),jrnf=$p(log(i),",",2),jrninfo(1,csn,i)=jrnf
 . s jrninfo(-1,jrnf)=csn_","_i_","_$$updseqinfo^JRNINFO(jrnf,csn,i)
 m jrninfo(0)=@seqinfo
 d killjrninfo^JRNINFO(index)
 q 0
 ;purpose:
 ; set default range of journal restore 
 ;algorithm:
 ; default beg: where backup ends (journal marker) or 
 ;              beginning of current session (on own system) or journal log
 ;   [Advanced] begin from last journal restore if jrnlog matches
 ; default end: current location (on own system) or end of log
 ;callers:
 ; SETUP
 ; SetJrnlogUse
 ; SetJrnlogNew
 ;callee: IsInJrnlog
 ;input: jrnlog, jrnlogdef, ^SYS("RESTORE")
 ;output: dejrnbeg, dejrnend
 ;NB: jrnf of dejrnbeg should match what is in jrnlog (redirected or not)
SetDejrnDef d SetDejrnDefBeg,SetDejrnDefEnd q
SetDejrnDefBeg ;
 n dbrestime,dejrntime,node,jrnf
 k dejrnbeg,dejrnbegr
 s dbrestime=$o(^SYS("RESTORE","BACKUP",""),-1)
 ;locate last cluster journal restore, if any
 s dejrntime="" f  s dejrntime=$o(^SYS("RESTORE","JOURNAL",dejrntime),-1) q:dejrntime=""  q:$g(^SYS("RESTORE","JOURNAL",dejrntime,"Jrnlog"))]""
 ;Continue from prior journal restore only if it
 ;  1. was performed after last backup; AND
 ;  2. used the same journal log as current; AND
 ;  3. ended at a journal marker (a limitation for now)
 i dejrntime]dbrestime,^SYS("RESTORE","JOURNAL",dejrntime,"Jrnlog")=jrnlog,$d(^SYS("RESTORE","JOURNAL",dejrntime,"RangeEnd"))'<10 m dejrnbeg=^SYS("RESTORE","JOURNAL",dejrntime,"RangeEnd") s dejrnbeg=("4,"_dejrntime)
 e  i dbrestime]"" s node=$name(^SYS("RESTORE","BACKUP",dbrestime)),dejrnbeg=("1,"_dbrestime_","_@node@("device")),node=$name(@node@("jrnmarker")) s i="" f  s i=$o(@node@(i)) q:i=""  s jrnf=$p(@node@(i),",",2),dejrnbeg(jrnf)=+@node@(i) i '$$IsInJrnlog(.jrnf) k dejrnbeg q
 i '$d(dejrnbeg) s dejrnbeg=$s(jrnlog=jrnlogdef:("0,"_$zdt($zdth($ZU(78,30,0),-2),8)),1:"3,10000101")
 q
SetDejrnDefEnd ;
 k dejrnend,dejrnendr
 i jrnlog=jrnlogdef,$zu(78,22) s dejrnend=("1,"_""_","_"")
 e  s dejrnend="3,30000101"
 q
 ;input: jrnf
 ;return: if jrnf is in jrnlog, index of jrnf in jrnlog; 0 otherwise
IsInJrnlog(jrnf) ;
 ;i $d(jrninfo) q $d(jrninfo(-1,jrnf))
 s jrnf=$zu(12,jrnf)
 n i s i="" f  s i=$o(jrnlog(i)) q:i=""  q:jrnf=$p(jrnlog(i),",",2)
 q $s(i="":0,1:i)
IsInJrnlogRedir(jrnf) ;
 n i s i="" i $d(jrnlogr) f  s i=$o(jrnlogr(i)) q:i=""  q:jrnf=$p(jrnlogr(i),",",2)
 q $s(i="":0,1:i)
 ;Q: Are beg and end journal markers specifed in original or current locations?
 ;A: beg and end are always specified in original locations.
 ;Specify where to start journal restore
ShowMenuSetupDejrnBeg() ;
 n okopt
 s okopt="12"  ;these options are always valid
 n time,device
 w !!,"Cluster Journal Restore - Setup - Where to Start Restore"
 w ! w:+$g(dejrnbeg)=0 "*" w ?2,"1. At the beginning of a cluster session "
 i +$g(dejrnbeg)=0 w ": <",$p(dejrnbeg,",",2),">"
 w ! w:+$g(dejrnbeg)=2 "*" w ?2,"2. At a specific journal marker "
 i +$g(dejrnbeg)=2 w ":" d ShowJrnMarkLoc(.dejrnbeg)
 i +$g(dejrnbeg)=1 d  i 1
 . s time=$p(dejrnbeg,",",2),device=$p(dejrnbeg,",",3) 
 . w !,"*",?2,"3. Following the restore of backup ",device
 . w !,"     i.e., at the journal marker located at" d ShowJrnMarkLoc(.dejrnbeg)
 . s okopt=okopt_"3"
 e  s time=$o(^SYS("RESTORE","BACKUP",""),-1) d:time]"" 
 . w !,?2,"3. Following the restore of backup ",$g(^SYS("RESTORE","BACKUP",time,"device"),"???")
 . s okopt=okopt_"3"
 i +$g(dejrnbeg)=4 d  i 1
 . w !,"*",?2,"4. Following the journal restore ended at ",$p(dejrnbeg,",",2)
 . w !,"     i.e., at the journal marker located at" d ShowJrnMarkLoc(.dejrnbeg)
 . s okopt=okopt_"4"
 e  s time=$o(^SYS("RESTORE","JOURNAL",""),-1) d:time]""
 . w !,?2,"4. Following the journal restore ended at ",time
 . s okopt=okopt_"4"
 i +$g(dejrnbeg)=5 d  i 1
 . n text,type,date,time 
 . s text=$P(dejrnbeg,",",2),type=$P(text,";",3),date=$P(text,";"),time=$P(text,";",2)
 . w !,"*",?2,"5. Following the ",type," backup at ",time," on ",date
 . s okopt=okopt_"5"
 e  d:($O(jrnmarkinfo("index",-1,""))'="")
 . w !,?2,"5. Based on a journal marker from a Cache' backup"
 . s okopt=okopt_"5"
 q okopt
 ; SetDejrn()
 ; Purpose: Allow the user to change the upper/lower bounds for the
 ;          restore
 ; Input: fromrest
 ;    There are some special values of fromrest set by CLUMENU^JRNRESTO which
 ;    change how we select the starting/ending point.
 ;       fromrest=6 is a restore based on backup 
 ;       fromrest=7 is a restore following a cache backup restore
 ; Returns: 0 (no change), -1 (error), 1 (changed)
 ;          dejrnbeg & dejrnend set to describe where to start/stop
SetDejrn() ;
 n rc,key,okopt
 s rc=0
top ;
 if fromrest=6 s rc=$$SetDejrnBegBck() g:rc=0 top i rc>0 d  q rc
 . i +$g(dejrnbeg)=5 d  
 . . n text,type,date,time 
 . . s text=$P(dejrnbeg,",",2),type=$P(text,";",3),date=$P(text,";"),time=$P(text,";",2)
 . . w !!,"--------------------------------------------------------------"
 . . w !,"Start: Following the ",type," backup at ",time," on ",date
 . . w !,"---------------------------------------------------------------"
 . w !,"And to Stop at the current journal location."
 if fromrest=7 s rc=$$SetDejrnBegRestore() i rc>0 d  q rc
 . w !,"And to Stop at the current journal location."
 f  s okopt=$$ShowMenuSetupDejrnBeg() w !!,"Option with (*) is Current Start position - <ENTER> to accept",!!,"Selection (<ENTER> if no change)",!,"(^ to backup, Q to quit restore)/[?][H]elp: " r key d  q:rc  q:((key="")!(key="^"))
 . i (okopt'[key)&("qQhH?"'[key)&(key'="^") w !,*7,"Invalid option ",key q
 . i key="^" q
 . i key="" q
 . i "Qq"[key d  q
 . . w ! i $$YN("Are you sure you want to Quit the cluster journal restore","N")="Y" s rc=-1 q
 . i ("Hh"[key)!(key="?") s rc=$$SetdejrnstartHelp^JRNRESTCHELP() q
 . i key=1 w "  working......" s rc=$$SetDejrnBegClu() q:rc=1  k:rc<0 jrninfo s rc=0 q
 . i key=2 s rc=$$SetDejrnBegOth() q:rc=1  s rc=0 q
 . i key=3 s rc=$$SetDejrnBegRestore() q:rc=1  s rc=0 q
 . i key=4 s rc=$$SetDejrnBegJrn() q:rc=1  s rc=0 q
 . i key=5 s rc=$$SetDejrnBegBck() d:rc=1  q:rc=1  s rc=0 q
 . . i +$g(dejrnbeg)=5 d  
 . . . n text,type,date,time 
 . . . s text=$P(dejrnbeg,",",2),type=$P(text,";",3),date=$P(text,";"),time=$P(text,";",2)
 . . . w !!,"--------------------------------------------------------------"
 . . . w !,"Start: Following the ",type," backup at ",time," on ",date
 . . . w !,"---------------------------------------------------------------"
 q:rc<0 -1
 i $d(key),key="^" q 0  
 s rc=0
 f  s okopt=$$ShowMenuSetupDejrnEnd() w !!,"Option with (*) is Current Stop position - <ENTER> to accept",!!,"Selection (<ENTER> if no change)",!,"(^ to backup, Q to quit restore)/[?][H]elp: " r key d  q:rc  i (key="")!(key="^") q  
 . i (okopt'[key)&(key'="^")&("QqhH?"'[key) w !,*7,"Invalid option ",key q
 . i key="" q
 . i key="^" q
 . i "Qq"[key d  q
 . . w ! i $$YN("Are you sure you want to Quit the cluster journal restore","N")="Y" s rc=-1 q
 . i ("Hh"[key)!(key="?") s rc=$$SetdejrnstopHelp^JRNRESTCHELP() q
 . i key=1 w "  working......" s rc=$$SetDejrnEndClu() q:rc=1  k:rc<0 jrninfo s rc=0 q
 . i key=3 s rc=$$SetDejrnEndOth() q:rc=1  s rc=0 q
 . i key=4 s rc=$$SetDejrnEndBck() d:rc=1  q:rc=1  s rc=0 q
 . . if $O(jrnmarkinfo("index",-1,""))'="" d  
 . . . i +$g(dejrnend)=5 d  
 . . . . n text,type,date,time 
 . . . . s text=$P(dejrnend,",",2),type=$P(text,";",3),date=$P(text,";"),time=$P(text,";",2)
 . . . . w !!,"-----------------------------------------------------------------------"
 . . . . w !,"Stop: At a Cache' backup: <",type," backup at ",time," on ",date,">"
 . . . . w !,"------------------------------------------------------------------------"
 . q:key'=2 
 . i jrnlog=jrnlogdef,$zu(78,22) s rc=$$SetDejrnEndCur(0) q:rc=1  s rc=0 d  q
 . .w !!,*7,"[Not able to change, already set at the current end of the journal]"
 . s rc=$$SetDejrnEndLog()
 if key="^" s rc=0,key="",okopt="" q:fromrest=7 0 g top
 q:rc<0 -1
 q 0 ;success
 ;purpose: start restore at the beginning of a cluster session
 ;callee: ImportJrninfo
 ;input/output: jrninfo
 ;output: dejrnbeg
 ;return:
 ; 0 (no change), -1 (error), 1 (changed)
SetDejrnBegClu() ;
 n i,cst,n,key
 i '$d(jrninfo),$$ImportJrninfo()
 s cst="",i=0 f  s cst=$o(jrninfo(0,cst)) q:cst=""  s cst($i(i))=$zdt($zdth(cst,-2),8) 
 i 'i w !!,*7,"[No cluster session found. Is journal log or redirection given correctly?]" q -1
 s n=i ;# of cluster sessions
 f  d   r !!,"=> ",key q:key=""  q:"Qq"[key  s key=key\1 i 0<key,key<(n+1) q
 . w !!,"To start journal restore at the beginning of cluster session ..."
 . f i=1:1:n w !,i,". ",cst(i)
 i key=""!("Qq"[key) q 0
 k dejrnbeg,dejrnbegr s dejrnbeg=("0,"_cst(key\1))
 q 1
 ;return:
 ; 0 (no change), -1 (error), 1 (changed)
SetDejrnBegBck() ;
 n index,line,jrnf,addr,text
 ;Begin following a backup using the information in the journal
 ;marker log to select the journal marker for the backup to start with.
 if $g(jrnmarklog)="" d errout("There is no cluster journal marker log to locate the backup information") q 0
 if '$D(jrnmarkinfo("index",-1)) d errout("The cluster journal marker log does not contain any backup information") q 0
 s index=$$getrestore("start")
 i index=0 q 0
 i index=-1 q -1
 s line=jrnmarkinfo(index)
 s addr=$P(line,"^",2),jrnf=$P(line,"^",3),text=$P(line,"^",5)
 i '$$IsInJrnlog(.jrnf) d errout((jrnf_" is not found in journal log "_jrnlog)) q -1
 k dejrnbeg,dejrnendr 
 s dejrnbeg(jrnf)=addr
 s dejrnbeg=("5,"_text)
 d RedirDejrn(.dejrnbeg,.dejrnbegr)
 q 1
SetDejrnBegRestore() ;
 ;Begin at the end of a backup restore which has been performed
 ;on this system so it is recorded in ^SYS("RESTORE")
 n i,time,node,beg,jrnf,addr
 s time=$o(^SYS("RESTORE","BACKUP",""),-1)
 i time="" d errout("No backup has been restored on this system") q 0
 s node=$name(^SYS("RESTORE","BACKUP",time))
 s i="" f  s i=$o(@node@("jrnmarker",i)) q:i=""  d  q:('$d(beg))
 . s jrnf=$p(@node@("jrnmarker",i),",",2),addr=+@node@("jrnmarker",i),beg(jrnf)=addr
 . i '$$IsInJrnlog(.jrnf) d errout((jrnf_" is not found in journal log "_jrnlog)) k beg q
 . w !!,"You have chosen to start journal restore at",!,$j(addr,12),",",jrnf
 i '$d(beg) q -1
 w !,"the journal location by the end of backup. ",@node@("device")
 k dejrnbeg m dejrnbeg=beg s dejrnbeg=("1,"_time_","_@node@("device"))
 d RedirDejrn(.dejrnbeg,.dejrnbegr)
 q 1
 ;return:
 ; 0 (no change), -1 (error), 1 (changed)
SetDejrnBegJrn() ;
 n i,time,node,beg,jrnf,addr
 s time="" f  s time=$o(^SYS("RESTORE","JOURNAL",time),-1) q:time=""  q:$g(^SYS("RESTORE","JOURNAL",time,"Jrnlog"))]""
 i time="" d errout("No cluster journal restore has been done on this system") q 0
 s node=$name(^SYS("RESTORE","JOURNAL",time))
 w !!,"You have chosen to start journal restore at the end of last journal restore:"
 i $d(@node@("RangeEnd"))<10 d errout("Last journal restore didn't end at a journal marker") q 0
 m beg=@node@("RangeEnd") s jrnf="" f  s jrnf=$o(beg(jrnf)) q:jrnf=""  s addr=beg(jrnf) w !,$j(addr,12),",",jrnf i '$$IsInJrnlog(.jrnf) d errout((jrnf_" is not found in journal log "_jrnlog)) k beg q
 i '$d(beg) q -1
 k dejrnbeg m dejrnbeg=beg s dejrnbeg=("4,"_time)
 d RedirDejrn(.dejrnbeg,.dejrnbegr)
 q 1
 ;return:
 ; 0 (no change), -1 (error), 1 (changed)
SetDejrnBegOth() ;
 n jrnf,addr
 w !!,"To start restore at a journal marker location (in original form)"
 r !,"journal file (^ or <ENTER> if no change): ",jrnf i (jrnf="")!(jrnf="^") w !!,"[no change]" q 0
 i '$$IsInJrnlog(.jrnf) d errout((jrnf_" is not found in journal log "_jrnlog)) q -1
 r !,"offset: ",addr i addr="" w !!,"[1st marker: not implemented]" q 0
 ;should verify address here and in SetDejrnBegBck??
 k dejrnbeg,dejrnendr s dejrnbeg=2,dejrnbeg(jrnf)=addr 
 d RedirDejrn(.dejrnbeg,.dejrnbegr)
 q 1
 ;Specify where to stop journal restore
ShowMenuSetupDejrnEnd() ;
 n okopt
 s okopt="123"  ; these are always valid options
 w !!,"Cluster Journal Restore - Setup - Where to Stop Restore"
 w ! w:+$g(dejrnend)=0 "*" w ?2,"1. At the end of a cluster session"
 i +$g(dejrnend)=0 w "<",$p(dejrnend,",",2),">"
 w ! w:+$g(dejrnend)=1 "*" w ?2,"2. " 
 i jrnlogdef=jrnlog,$zu(78,22) w "At current journal location"
 e  w "At the end of "_jrnlog
 w ! w:+$g(dejrnend)=2 "*" w ?2,"3. At a specific journal marker"
 i +$g(dejrnend)=2 w ":" d ShowJrnMarkLoc(.dejrnend)
 if $O(jrnmarkinfo("index",-1,""))'="" d  s okopt=okopt_4
 . w ! w:+$g(dejrnend)=5 "*" w ?2,"4. At a Cache' backup"
 . i +$g(dejrnend)=5 d  i 1
 . . n text,type,date,time 
 . . s text=$P(dejrnend,",",2),type=$P(text,";",3),date=$P(text,";"),time=$P(text,";",2)
 . . w ": <",type," backup at ",time," on ",date,">"
 q okopt
SetDejrnEndClu() ;
 n i,cst,n,m,key
 i '$d(jrninfo),$$ImportJrninfo()
 s cst="",i=0 f  s cst=$o(jrninfo(0,cst)) q:cst=""  s cst($i(i))=$zdt($zdth(cst,-2),8) 
 i 'i w !!,*7,"[No cluster session found. Is journal log or redirection given correctly?]" q -1
 s n=i ;# of cluster sessions
 s m=1,cst=$p(dejrnbeg,",") i cst f  q:cst']cst(m)  q:m'<n  s m=m+1
 f  d   r !!,"=> ",key q:key=""  q:"Qq"[key  s key=key\1 i (m-1)<key,key<(n+1) q
 . w !!,"To stop restore at the end of cluster session"
 . f i=m:1:n w !,i,". ",cst(i)
 i key=""!("Qq"[key) q 0
 k dejrnend,dejrnendr s dejrnend=("0,"_cst(key\1))
 q 1
SetDejrnEndCur(finalflag) ;
 ; finalflag = 1 if we're called from Convert when the user
 ; is done making selections or 0 if we're called from the
 ; main menu (option 2) to set the end of the restore at the
 ; current end of the journal. We don't put a marker into the
 ; journal file until finalflag = 1.
 if 'finalflag q:$G(dejrnend)=("1,"_""_","_"") 0 k dejrnend,dejrnendr s dejrnend=("1,"_""_","_"") q 1
 n rc,jrnf,addr
 s rc=$$CLUSET^JRNMARK(-2,$zdt($g(dejrntim,$h),8))
 i rc'>0 d errout(("Error marking current journal location - "_$p(rc,",",2,$l(rc)))) q rc
 s addr=+rc,jrnf=$p(rc,",",2)
 w !!,"Setting journal marker at offset ",addr," in "
 w !,?5,jrnf
 w !,"as the end point for this restore."
 w !
 k dejrnend,dejrnendr s dejrnend=("1,"_jrnf_","_addr),dejrnend(jrnf)=addr
 q 1
SetDejrnEndLog() ;
 k dejrnend,dejrnendr s dejrnend="3,30000101"
 q 1
SetDejrnEndBck() ;
 n index,line,jrnf,addr,text
 ;End at the start of a backup using the information in the journal
 ;marker log to select the journal marker for the backup to restore up to
 if $g(jrnmarklog)="" d errout("There is no cluster journal marker log to locate the backup information") q 0
 if '$D(jrnmarkinfo("index",-1)) d errout("The cluster journal marker log does not contain any backup information") q 0
 s index=$$getrestore("end")
 if index=0 q 0
 s line=jrnmarkinfo(index)
 s addr=$P(line,"^",2),jrnf=$P(line,"^",3),text=$P(line,"^",5)
 i '$$IsInJrnlog(.jrnf) d errout((jrnf_" is not found in journal log "_jrnlog)) q -1
 k dejrnend,dejrnendr 
 s dejrnend=("5,"_text)
 s dejrnend(jrnf)=addr
 d RedirDejrn(.dejrnend,.dejrnendr)
 q 1
SetDejrnEndOth() ;
 n jrnf,addr
 w !!,"To stop restore at a journal marker location (in original form)"
 r !,"journal file (^ or <ENTER> if no change): ",jrnf i (jrnf="")!(jrnf="^") w !!,"[no change]" q 0
 i '$$IsInJrnlog(.jrnf) d errout((jrnf_" is not found in journal log "_jrnlog)) q -1
 r !,"offset: ",addr i addr="" w !!,"[last marker: not implemented]" q 0
 ;should verify address here and in SetDejrnEndBck??
 k dejrnend,dejrnendr s dejrnend=2,dejrnend(jrnf)=addr 
 d RedirDejrn(.dejrnend,.dejrnendr)
 q 1
curloc(jrnf,addr,cst,seq) ;
 n dev
 s jrnf=$zu(78,3),dev=$zu(78,5,jrnf,0)
 i dev<0 q "-1,unable to open current journal file "_jrnf
 i $zu(78,6,dev)
 s addr=$zu(78,18,$zu(78,18,0))
 s cst=$zdt($ZU(78,30,1),8),seq=$zu(78,41,0)
 i $zu(78,7,dev)
 q 0
getrestore(optext)	;
	; called from SetDejrnBegBck()/SetDejrnEndBck() to display a list 
	; of choices for which backup to start or end the restore at and
	; get an answer from the user.
	n i,index,list,x,restdate,date,choice,resp,done,type,text,OK,mmyyyy
	s index=$O(jrnmarkinfo("index",-1,""),-1)
	if '$L(index) q 0  ;shouldn't happen, we already checked for this  
	;format of index is "yyyymmdd hh:mm:ss"
	s restdate=$ZDATE($ZDATEH(+index,8),1)_" "_$P(index," ",2)
	s text=$P(jrnmarkinfo(jrnmarkinfo("index",-1,index)),"^",5)
	s type=$P(text,";",3)
	w !!,"The most recent backup was a ",type," backup run on ",restdate," UTC"
	i fromrest'=6 s x=$$YN("Is this where you want to "_optext_" the journal restore (^ to backup)","Y")
	i fromrest=6 s x=$$YN("Is this where you want to "_optext_" the journal restore (^ to Abort)","Y")
	i x="^" s POP=0,rc=0 d:fromrest=6  q rc
	. w ! i $$YN("Are you sure you want to Quit the cluster journal restore","N")="Y" s rc=-1 q
	i x="Y" q jrnmarkinfo("index",-1,index)
	s resp="L",choice=0,mmyyyy=0
	f  d  q:choice!(resp="Q")
	. w !,"Choose the journal files to restore based on"
	. do ASKSET("(B)ackup date, (L)ist all, (Q)uit ",.resp)
	. k list
	. i "BbLlQq"'[$E(resp_"X") d  q  
	. . w ?40,"Invalid selection - ",resp,". Use Q to quit",!
	. i "Bb"[$E(resp_"X") d  
	. . set date="",OK=0,resp=""
	. . f  d  q:OK  q:resp="Q"
	. . . D ASKSET("Date (mm/dd/yyyy or mm/yyyy) the backup was performed (Q to Quit) ",.date)
	. . . i date'="","qQ"[date s resp="Q" q
	. . . i date'?1.2N1"/".1(1.2N1"/")4N w !,"...invalid date, year must be 4 digits - ",date s date="" q
	. . . i date?1.2N1"/"4N d
	. . . . s x=$f(date,"/")-1
	. . . . s $e(date,x,x)="/01/",mmyyyy=1  ;add in "day" for $ZDATEH()
	. . . i $p(date,"/",3)<1900 w !,"...date out of range year must be 4 digits and greater than 1900 - ",date s date="" q
	. . . i date?1.2N1"/"1.2N1"/"4N d
	. . . . s OK=$ZDATEH(date,1,,,,,,,-1)
	. . . . i OK=-1 w !,"...invalid date - ",date s date="",OK=0 q
	. . . . i mmyyyy s x=$E($ZDATE($ZDATEH(date,1),8),1,6)  ;convert to yyyymm
	. . . . i 'mmyyyy s x=$ZDATE($ZDATEH(date,1),8)   ;convert to yyyymmdd
	. . . . s done=0,OK=1
	. . . . s index=x_" "  ;add the trailing space so its a string not a number
	. . . . f  s index=$O(jrnmarkinfo("index",-1,index)) q:(index="")!done  d
	. . . . . i $e(index,1,$l(x))'=x s done=1 q
	. . . . . s list("xref",$I(list))=index
	. . . . . s list(index)=jrnmarkinfo("index",-1,index)
	. . i resp="Q" q
	. i "Ll"[$E(resp_"X") do
	. . s index=""
	. . f  s index=$O(jrnmarkinfo("index",-1,index)) q:index=""  d
	. . . s list("xref",$I(list))=index
	. . . s list(index)=jrnmarkinfo("index",-1,index)
	. i "Qq^"[$E(resp_"X") s choice=0,resp="Q" quit
	. i '$G(list) d  quit  ;repeat choice selection
	. .  w !,"No backups were found that match your criteria - Try again"
	. s choice=$$choosebackup(optext,.list)
	i 'choice q 0
	q jrnmarkinfo("index",-1,choice)
choosebackup(optext,list)
	; takes a list of possibilities (could be only one) which match
	; what the user asked for and asks them to pick one. Returns 0
	; if they don't pick any or the index into list (yyyymmmdd subscript
	; into ^jrnmarkinfo("index",-1,...)) of the one they want.
	; 
	n index,backdate,x,more,choice,type,text
	if list=1 d  q:x="Y" index  q 0
	. s index=list("xref",1)
	. s backdate=$ZDATE($ZDATEH(+index,8),1)_" "_$P(index," ",2)
	. s text=$P(jrnmarkinfo(jrnmarkinfo("index",-1,index)),"^",5)
	. s type=$P(text,";",3)
	. w !,"There is one backup matching your criteria: "
	. w !,"  ",type," backup made on ",backdate," UTC"
	. w !
	. s x=$$YN("Is this where you want to "_optext_" the journal restore","Y")
	;
listdisplay
	w !,"There are ",list," backups listed"
	w !,"Choice",?10,"Date of backup (new->old)",?35,"Backup type"
	s more=1
	f i=1:1:list d  q:'more
	. s index=list("xref",list-i+1)  ;display choices in reverse order
	. s backdate=$ZDATE($ZDATEH(+index,8),1)_" "_$P(index," ",2)
	. s text=$P(jrnmarkinfo(jrnmarkinfo("index",-1,index)),"^",5)
	. s type=$P(text,";",3)
	. w !,$J(i,4)," ",?10,backdate," UTC ",?35,type
	. if '(i#20) r !,"...more (n to stop)",x if "Nn"[$E(x_"X") s more=0
	s choice=1
	w !
	do ASKSET("Enter choice: (0 for none) ",.choice)
	s choice=+choice
	if (choice<0)!(choice>i) w !,"Invalid selection - try again" g listdisplay
	q:'choice 0
	quit list("xref",list-choice+1)
 ;input:
 ; jrnlog/r, dejrnbeg/r, dejrnend/r
 ;return:
 ;  1, successful conversion, continue to cluster restore
 ;  0, fail to convert, retry setup of cluster restore
 ; -1, quit cluster restore
Convert() ;
 n beg,end,log,rc,err
 i dejrnend=("1,"_""_","_""),$$SetDejrnEndCur(1)<0 q 0
 i $d(jrnlogr) m log=jrnlogr s log=$g(jrnlog)
 e  m log=jrnlog
 i +$g(dejrnbeg)=+("0,"_"") s beg=$p(dejrnbeg,",",2)
 e  i $g(dejrnbeg)="3,10000101" s beg=$p(dejrnbeg,",",2)
 e  s rc=$$ConvertDejrn(.dejrnbeg,.beg) i rc<0 q 0
 i +$g(dejrnend)=+("0,"_"") s end=$p(dejrnend,",",2)
 e  i $g(dejrnend)="3,30000101" s end=$p(dejrnend,",",2)
 e  s rc=$$ConvertDejrn(.dejrnend,.end) i rc<0 q 0
 s rc=$$convert(.beg,.end,.log,.err) i rc<0 d errout($p(rc,",",2,$l(rc))) q 0
 i $g(err)]"" d errout(err) i $$YN("Continue despite the warning")="N" q 0
 ;print out the first and last journal files and seq #s to restore
 q 1
ConvertDejrn(loc,cur) ;
 i '$g(jrnredir) m cur=loc zk cur
 e  d RedirDejrn(.loc,.cur)
 q $$ConvertJrnoff(.cur)
 ;purpose:
 ; convert a journal location to a sequence point
 ; NB: currently applicable to one journal location only
ConvertJrnoff(loc) ;
 n jrnf,addr,dev,cst,seq
 ;i $p($g(loc),",")]"" q 0  ;already use sequence point
 s jrnf=$o(loc("")) i jrnf'=$o(loc(""),-1) q 0  ;more than one locations given
 s dev=$zu(78,5,jrnf,0) i dev<0 d errout(("Invalid journal file "_jrnf)) q -1
 i $zu(78,6,dev)
 s cst=$ZU(78,30,0) i 'cst d errout((jrnf_" doesn't belong to a clustered system")),jrnclose(dev) q -1
 s addr=loc(jrnf),seq=$zu(78,11,addr) 
 i $zu(78,7,dev)
 i seq'>0 d errout(("Invalid sequence # at offset "_addr_" of "_jrnf)) q -1
 s $p(loc,",",1,2)=$zdt($zdth(cst,-2),8)_","_seq
 q 0
 ;purpose: 
 ; Convert restore begin/end & jrnlog to values restore^JRNCLUREST understands
 ;input:
 ; beg - where to begin (cluster sequence point or journal marker location)
 ;   beg=cluster sequence point, OR
 ;   beg(jrnf)=addr (journal marker location)
 ; end - where to end (similar to beg), inclusive (i.e., end is restored)
 ;   end=cluster sequence point or "(END OF CLUSTER JOURNAL LOG)", OR
 ;   end(jrnf)=addr (journal marker location)
 ; log - an array of csn,jrnf, imported from cluster journal log line by line
 ;output:
 ; (minclumstart,)minseq - first cluster sequence point to restore
 ; (maxclumstart,)maxseq - last cluster sequence point to restore
 ; numclu - # of cluster members - 1
 ; clumember(csn,n), n=0,1,...
 ; clumember(csn,"files",00..0n:YYYYMMDD.NNNJ)
 ;return:
 ; 0 (success), <0 (error)
convert(beg,end,log,err) ;
 n rc
 s $zt="convertE",rc=0
 k clumember ;we'll reinitialize this
 i $g(beg) s rc=$$convertbegseq(.beg,.log) q:rc<0 rc i 1
 e  s rc=$$convertbegjrn(.beg,.log) q:rc<0 rc s err=$p(rc,",",2)
 i $g(end) s rc=$$convertendseq(.end) q:rc<0 rc i 1
 e  s rc=$$convertendjrn(.end) q:rc<0 rc
 s rc=$$convertjrninfo(.beg,.end)
 s minseq=$g(minseq),maxseq=$g(maxseq)
 i rc<0 q rc
 q $$CheckJournalIntegrity()
CheckJournalIntegrity() ;
 n rc,csn,index,dev,jrnf,prevjrnf,jrnend,prevend
 s $zt="convertE"
 s csn="" f  s csn=$o(clumember(csn)) q:csn=""  d
 . s prevjrnf=""
 . s index="" f  s index=$o(clumember(csn,index),1,jrnf) q:index=""  d:index=+index
 . . s dev=$zu(78,5,jrnf,0) 
 . . i dev<0 s rc="-1,"_("Invalid journal file "_jrnf) ztrap "OPEN" 
 . . i $g(prevjrnf)]"" d
 . . . s prevend=$p($zu(78,22,jrnf,99),",",11+1)
 . . . i prevend,prevend>jrnend s rc="-1,"_("Corruption in "_prevjrnf_": The last reachable journal record ends @ offset "_jrnend_", different from the journal end offset "_prevend) ztrap "JEND"
 . . i $zu(78,6,dev)
 . . s jrnend=$zu(78,18,0),prevjrnf=jrnf
 . . d $zu(78,7,dev) s dev=-1
 q +$g(rc)
 ;purpose:
 ; create a clumember(csn,"files") entry for every journal file to restore
 ;input:
 ; beg(jrnf)=addr, an array of journal locations to begin restore at
 ; end(jrnf)=addr, an array of journal locations to end restore at
 ; clumember(csn,i) - a list of journal files to restore per csn
 ;input/output:
 ; clumember(csn)=firstfile^lastfile(^prefix)
 ;  NB: prefix (or even the whole entry) is not used by restore^JRNCLUREST
 ;output:
 ; clumember(csn,"files") - journal file info per file per csn
 ;return:
 ; 0 (success), <0 (error)
convertjrninfo(beg,end) ;
 n i,n,csn,jrnf,addr,dev,cst,seq,shortnam
 s $zt="convertE"
 s csn="" f  s csn=$o(clumember(csn)) q:csn=""  d
 . s n=clumember(csn) i n="" k clumember(csn) q
 . s clumember(csn)=$case($ZBITGET($ZVERSION(0),46),0:$case($f($p(clumember(csn,0),"^"),";"),0:$e($p(clumember(csn,0),"^"),*-8-$l($p($p(clumember(csn,0),"^"),".",$l($p(clumember(csn,0),"^"),"."))),*-$case($e($p(clumember(csn,0),"^"),*)="z",0:0,1:1)),:$e($p(clumember(csn,0),"^"),*-8-$l($p($p(clumember(csn,0),"^"),".",$l($p(clumember(csn,0),"^"),"."))),$f($p(clumember(csn,0),"^"),";")-2)),:$p(clumember(csn,0),"^"))_"^"_$case($ZBITGET($ZVERSION(0),46),0:$case($f($p(clumember(csn,n),"^"),";"),0:$e($p(clumember(csn,n),"^"),*-8-$l($p($p(clumember(csn,n),"^"),".",$l($p(clumember(csn,n),"^"),"."))),*-$case($e($p(clumember(csn,n),"^"),*)="z",0:0,1:1)),:$e($p(clumember(csn,n),"^"),*-8-$l($p($p(clumember(csn,n),"^"),".",$l($p(clumember(csn,n),"^"),"."))),$f($p(clumember(csn,n),"^"),";")-2)),:$p(clumember(csn,n),"^"))
 . s i="" f  s i=$o(clumember(csn,i)) q:i=""  d
 . . s jrnf=clumember(csn,i),dev=$zu(78,5,jrnf,0) 
 . . i dev<0 s rc="-1,"_("Invalid journal file "_jrnf) ztrap "CNVT" 
 . . i $zu(78,6,dev)
 . . s shortnam=$case($ZBITGET($ZVERSION(0),46),0:$case($f(jrnf,";"),0:$e(jrnf,*-8-$l($p(jrnf,".",$l(jrnf,"."))),*-$case($e(jrnf,*)="z",0:0,1:1)),:$e(jrnf,*-8-$l($p(jrnf,".",$l(jrnf,"."))),$f(jrnf,";")-2)),:jrnf)_"J"
 . . s shortnam=$e(10000000000+(i),2,11)_":"_shortnam,jrnf(shortnam)=jrnf
 . . i $d(beg(jrnf)) s $p(jrnf(shortnam),"^",3)=beg(jrnf)
 . . e  s $p(jrnf(shortnam),"^",3)=$zu(78,17,0)
 . . i $d(end(jrnf)) s $p(jrnf(shortnam),"^",6)=end(jrnf)
 . . e  s $p(jrnf(shortnam),"^",6)=$zu(78,18,$zu(78,18,0))
 . . s $p(jrnf(shortnam),"^",9)=$ZU(78,30,0)
 . . i $zu(78,7,dev) k dev
 . ;don't want "files" entries to interfere $o() on i
 . zk jrnf m clumember(csn,"files")=jrnf k jrnf
 s numclu=$o(clumember(""),-1)
 q 0
 ;purpose:
 ; Collect journal files for each cluster member in the journal log
 ; that do not entirely predate the sequence point beg
 ;assumption:
 ; journal file entries in jrnlog are chronically ordered per csn
 ;input:
 ; beg - cluster session ID (YYYYMMDD HH:MM:SS),sequence #
 ; log - an array of csn,jrnf (from journal log)
 ;output:
 ; (minclumstart,)minseq - sequence point corresponding to beg
 ;   NB: restore^JRNCLUREST ignores minclumstart, assuming 1st jrnf is the one
 ; clumember(csn),clumember(csn,i) - a list of journal files to restore
 ;return:
 ; 0 (success), <0 (error)
convertbegseq(beg,log) ;
 n i,csn,jrnf,addr,dev,cst,seq
 s $zt="convertE"
 s minclumstart=$$cvtclustime^SHDWX($p(beg,",")),minseq=$p(beg,",",2) 
 s i="" f  s i=$o(log(i)) q:i=""  d  d jrnclose(.dev)
 . s csn=+log(i),jrnf=$p(log(i),",",2)
 . i +$g(clumember(csn)) s clumember(csn,$i(clumember(csn))-1)=jrnf q
 . s dev=$zu(78,5,jrnf,0) q:dev<0  i $zu(78,6,dev)
 . s cst=$ZU(78,30,0) i cst<minclumstart q
 . i cst>minclumstart s addr=$zu(78,17,0) s:addr>0 clumember(csn,0)=jrnf,clumember(csn)=1,beg(jrnf)=addr q
 . s addr=$zu(78,18,0) f  s addr=$zu(78,18,addr) q:addr'>0  s seq=$zu(78,11,addr) q:seq>0
 . q:addr'>0  q:seq<minseq  ;jrnf predates beg
 . s addr="" f  s addr=$zu(78,17,addr) q:addr'>0  q:$zu(78,11,addr)'<minseq
 . s clumember(csn,0)=jrnf,clumember(csn)=1,beg(jrnf)=addr
 q 0
 ;purpose:
 ; Collect journal files for each cluster member in the journal log
 ; that do not predate the journal files in beg
 ;caveat: 
 ; There may be fewer journal markers than # of cluster members in the
 ; log (some members may not have joined the cluster when the marker
 ; was set), thus we still need to get a max sequence point of the
 ; markers -- any node joining after the marker was set must have got a
 ; bigger seq -- conversely, if the last journal file of a node ends
 ; with a seq smaller than the max and the node does not have a marker,
 ; then the node must have died before the marker was set and thus is
 ; irrelevant to the restore. (We assume journal markers are set properly,
 ; of course.) 
 ;input:
 ; beg(jrnf)=addr, an array of journal locations
 ; log - an array of csn,jrnf
 ;output:
 ; clumember(csn,i) - a list of journal files to restore per csn
 ;return:
 ; 0 (success), <0 (error)
convertbegjrn(beg,log) ;
 n i,rc,csn,jrnf,addr,dev,cst,seq,min,mincst
 s $zt="convertE",rc=0
 s i="" f  s i=$o(log(i)) q:i=""  d
 . s csn=+log(i),jrnf=$p(log(i),",",2)
 . i +$g(clumember(csn)) s clumember(csn,$i(clumember(csn))-1)=jrnf q
 . i '$d(beg(jrnf)) s clumember(csn)="" q  ;jrnf predates beg or missing member
 . s dev=$zu(78,5,jrnf,0) i dev<0 s rc=("-1,"_("Invalid journal file "_jrnf)) ztrap "CNVT"
 . i $zu(78,6,dev)
 . s cst=$ZU(78,30,0),addr=beg(jrnf)
 . i $zu(78,8,addr)<0 s rc=("-2,"_("Invalid offset "_addr_" of journal file "_jrnf)) ztrap "CNVT"
 . s seq(jrnf)=$zu(78,11,addr) ;what if seq<0?? should we enforce jrnmark?
 . i $zu(78,7,dev)
 . s clumember(csn,0)=jrnf,clumember(csn)=1
 ;see if the journal marker missed any cluster member (clumember(csn)="")
 s csn="" f  s csn=$o(clumember(csn)) q:csn=""  q:'clumember(csn)
 i csn="" q rc ;none missing and we are done
 ;find the greatest sequence # of all given journal markers
 s (min,mincst,csn)="" f  s csn=$o(clumember(csn)) q:csn=""  d:+clumember(csn)
 . s jrnf=clumember(csn,0),addr=beg(jrnf),seq=seq(jrnf)
 . s cst=$p(clumember(csn,"files",$e(10000000000+(0),2,11)_":"_$case($ZBITGET($ZVERSION(0),46),0:$case($f(jrnf,";"),0:$e(jrnf,*-8-$l($p(jrnf,".",$l(jrnf,"."))),*-$case($e(jrnf,*)="z",0:0,1:1)),:$e(jrnf,*-8-$l($p(jrnf,".",$l(jrnf,"."))),$f(jrnf,";")-2)),:jrnf)_"J"),"^",9) 
 . i mincst="" s mincst=cst
 . i cst'=mincst s rc="0,ignore cluster members without the journal marker because journal markers are in different cluster sessions" ztrap "CNVT"
 . i seq'>0 s rc=("0,ignore cluster members without the journal marker because the record at offset "_addr_" of "_jrnf_" doesn't have a valid cluster journal sequence") ztrap "CNVT"
 . i seq>min s min=seq
 ;see if a missing cluster member has journal files with seq > min
 s i="" f  s i=$o(log(i)) q:i=""  k:clumember(csn) log(i)
 s rc=$$convertbegseq(mincst_","_seq,.log) k minclumstart,minseq
 q rc
 ;nothing more to do if we are to restore to the end of the log
convertendlog(log) ;
 q 0
 ;purpose:
 ; delist journal files that are past the ending sequence point
 ;input:
 ; end - cluster session ID (YYYYMMDD HH:MM:SS),sequence #
 ;  NB: if sequence # is "" (not 0!), then defaults to end of session
 ;input/output:
 ; clumember(csn),clumember(csn,i) - a list of journal files to restore
 ;output:
 ; (maxclumstart,)maxseq - sequence point corresponding to end
 ;  NB: maxclumstart is implied, rather than used explicitly, by restore
 ;  as the last cluster session among the list of journal files.
 ;return:
 ; 0 (success), <0 (error)
 ;question: is it an error if we cannot open a file?
convertendseq(end) ;
 n i,rc,csn,jrnf,addr,dev,cst,seq
 s $zt="convertE",rc=0
 s maxclumstart=$$cvtclustime^SHDWX($p(end,",")),maxseq=$p(end,",",2) 
 i maxseq="" s maxseq=2**64 ;end of cluster session
 s csn="" f  s csn=$o(clumember(csn)) q:csn=""  d  i $d(clumember(csn))=1 s clumember(csn)=""
 . s i="" f  s i=$o(clumember(csn,i),-1) q:i=""  d  d jrnclose(.dev) q:i=""
 . . s jrnf=clumember(csn,i),dev=$zu(78,5,jrnf,0) q:dev<0  i $zu(78,6,dev)
 . . s cst=$ZU(78,30,0) i cst>maxclumstart k clumember(csn,i) q
 . . i cst<maxclumstart s clumember(csn)=i,i="" q
 . . s addr=0 f  s addr=$zu(78,17,addr) q:addr'>0  s seq=$zu(78,11,addr) q:seq>0
 . . i addr>0,seq'>maxseq s clumember(csn)=i,i="" q
 . . k clumember(csn,i)
 q rc
 ;restore^JRNCLUREST doesn't really look at the ending offsets, thus we have to
 ;convert them to an ending sequence point (unless restore is changed).
convertendjrn(end) ;
 n i,rc,csn,jrnf,addr,dev,cst,seq
 s $zt="convertE",(rc,maxseq,maxclumstart)=0
 ;delist journal files that are past the end
 s csn="" f  s csn=$o(clumember(csn)) q:csn=""  d
 . s n="" f  s n=$o(clumember(csn,n),-1) q:n=""  d  q:n=""
 . . s jrnf=clumember(csn,n)
 . . i $d(end(jrnf)) s clumember(csn)=n,n="" 
 . . e  k clumember(csn,n)
 ;calculate the lowest upper bound sequence point
 s jrnf="" f  s jrnf=$o(end(jrnf)) q:jrnf=""  d  d jrnclose(.dev)
 . s dev=$zu(78,5,jrnf,0) i dev<0 s rc="-1,unable to open "_jrnf ztrap "CNVT"
 . i $zu(78,6,dev)
 . s cst=$ZU(78,30,0) i cst<maxclumstart q
 . f  s seq=$zu(78,11,addr) q:seq>0  s addr=$zu(78,18,addr) q:addr'>0 
 . i cst>maxclumstart s maxclumstart=cst,maxseq=seq
 . i seq>maxseq s seq=maxseq
 ;filter remaining journal files using the sequence point
 q $$convertendseq($zdt($zdth(maxclumstart,-2),8)_","_maxseq)
convertE ;
 s $zt=""
 i $ze'["<Z" d $zu(9,"","ERROR: "_$ze,(1>0),1),BACK^%ETN s rc="-99,"_$ze
 d jrnclose(.dev)
 q $g(rc)
jrnclose(dev) ;
 i $g(dev)]"",dev'<0,$zu(78,7,dev)
 k dev q
YN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YN"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"yn","YN") I "^YN"'[R W "  enter Yes or No, please"
 S POP=(R="^") W $E($S(R="N":"No",R="Y":"Yes",1:""),$L(X)+1,3) Q R
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/FILEINC.inc#1 $ ($Change: 7440104 $) */
FIXDIR(dir) ;procedure, dir is passed by reference
 Q:dir=""
 Q:$A(dir,$L(dir))=$A($s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""))
 s dir=dir_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")
 Q
fixdir(dir) ;function
 Q:dir="" ""
 Q:$A(dir,$L(dir))=$A($s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")) dir
 Q dir_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")
basename(f) ;similar to basename on UNIX
 Q $P(f,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""),1,$L(f,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""))-1)_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")
appdir(d1,d2) ;use $zu(12,d2) to append d2 to canonic dir
 S d1=d1_d2
 Q d1
VALIDIR(dir) ;validate directory dir and create it if dir doesn't exist
 new flag
 s flag=1
 g vdir2
validir(dir,flag) ;validate directory dir and optionally create it if it
vdir2 ; VALIDIR(dir) comes here with flag set to 1
 quit:$$ChkDirOrSpecEXISTS(dir)'="" 1   ; dir is valid and exists
 quit:$$ChkDirVALID(dir)="" 0    ; dir is not valid
 i flag'=1 q 0  ; flag says don't create, return failure
 new x
 set x=$$mkdir(dir)  ; returns 0 for success, 1 for failure
 q:x=1 0  ; failed to create
 quit:$$ChkDirOrSpecEXISTS(dir)="" 0   ; it doesn't we failed
 q 1  ; success
mkdir(dir) ;create a new directory
 q '##class(%Library.File).CreateDirectoryChain(dir)
jrnshort(jf,short) ;get/set short form of a journal file name FIXME HYY1999
         N (jf,short)
         S len=$L($P(jf,";"))
         Q:$G(short)="" $E(jf,len-11,len) ;"GET" form
         S $E(jf,len-11,len)=short ;"SET" form
         Q jf
GJrnPrefix(jf) ;extract prefix from the journal file name jf
         N (jf)
         S fname=$P(jf,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""),$L(jf,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")))       
         Q $e(fname,1,$l($p(fname,"."))-8)
GetJrnFileName(path) { 
	i $f(path,"/") q $p(path,"/",$l(path,"/")) ;presumably a Unix path
	if $f(path,"\") q $p(path,"\",$l(path,"\")) ;presumably a Windows path
	s vmsfile=$p(path,"]",2) i vmsfile="" q path ;a name only, not a path
	q $p(vmsfile,";") ;return name from a VMS path without trailing ";"
}
dirinvalidmsg(dir1,dir2) 
 n valid1,valid2,cnt,msg
 s valid1=$$VALIDIR(dir1),valid2=$$VALIDIR(dir2)
 s cnt=valid1+valid2 ; cnt = 0 if both invalid, 1 if one is valid
 s msg="The following journaling "
 s:cnt msg=msg_"directory is" 
 s:'cnt msg=msg_"directories are"
 s msg=msg_" not valid"_$C(13,10)
 s:'valid1 msg=msg_"     "_dir1_$C(13,10)
 s:'valid2 msg=msg_"     "_dir2_$C(13,10)
 q msg
ChkDirVALID(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,1)
ChkDirEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkDirOrSpecEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,3)
ChkDir(R) N N S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkBad S $ZT="" W !,"<"_$P($P($ZE,"<",2),">")_"> error -- invalid directory"
 Q ""
ASKSET(prompt,val,backup,help,pattern) ;procedure
 N x,done,def,enahelp,helpavail,backupavail
 s done=0
 s def=$G(val)
 s backup=$G(backup,0) 
 s enabackup=$S(backup=-1:0,1:1)
 s backupavail=$S(backup=1:1,1:0)
 s help=$G(help)
 s enahelp=$S(help="*":0,1:1) ;there might not be any help though
 s helpavail=$s(enahelp&($L(help)!($D(help)>1)):1,1:0)
 if 'enabackup n POP
 s POP=0
 f  d  q:done!POP
 . W !,$G(prompt)
 . w:($X+$L(def))>65 !,?5
 . w:$L(def) " <",def,">"
 . if helpavail!backupavail do
 . . w " [" w:helpavail "?" w:backupavail "^" w "]"
 . w:(($X+$L(def))>75) !,?5
 . W " => " 
 . R x,!
 . if x="^" d  q
 . . if 'enabackup s done=1 q
 . . if backupavail s POP=1 q
 . . w "...backup not available here"
 . if enabackup,x="""^""" s x="^",done=1 q
 . ;
 . if x="?" d  q
 . . if 'enahelp s done=1 q
 . . if 'helpavail w "...help not available here" q
 . . if $D(help)=1 w !?5,help q
 . . s x="" f  s x=$O(help(x)) q:x=""  w !,?5,help(x)
 . . w !
 . if enahelp,x="""?""" s x="?",done=1 q
 . i x]"",$g(pattern)]"",x'?@pattern w !?5,$s(helpavail:help,1:"[bad format]") q
 . s:'$L(x) x=val 
 . s done=1
 s:'POP val=x
 q

JRNRESTC2^INT^1^67214,47330
JRNRESTC2 ;Cluster Restore Journal from a File, subrs
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/FILEINC.inc#1 $ ($Change: 7440104 $) */
 ; BITWISE.INC
 ;
 ; This module contains subroutines for JRNRESTC. JRNRESTC got too
 ; big for the editor.
 ;
showdata ;
 ; This routine displays the clumember() information that will be
 ; used to restore the journal.
 ;
 n id,ref,i,ret
 w !,"Cluster journal restore file list"
 d showhead
 s ret=0
 f id=0:1:numclu d
 . w !,"Member #",id
 . s ref=$NAME(clumember(id,"files"))
 . s i=$$showone(ref)
 . s ret=($ZBOOLEAN(+(ret),+(i),7))
 d showfooter(ret)
 w !
 q
showhead ;
 ; Print the header for the data displayed by showone()
 ;
 w !,"                      "
 w "_______First Record________   ________Last Record________"
 w !,"   Filename        "
 f i=1:1:2 w " Sequence #    Date     Time  "
 w !,"   ----------------"
 f i=1:1:2 w " ---------- ---------- -------"
 q
showfooter(value) 
 ; takes the return of $$showone() and generates the correct
 ; footer. 
 ;       Bit #1 = we suspect one or more journal files are missing
 ;       Bit #2 = journal files span a cluster restart
 ;       Bit #4 = a journal file wasn't part of the cluster
 ;       Bit #8 = a journal file wasn't part of the cluster but a
 ;                prior and subsequent journal file are from the same
 ;                cluster (eg. the system was shutdown, restarted and
 ;                didn't immediatly join the cluster).
 ;
 w !,"st: indicates that journal file was generated by a jrnstart"
 w !,"          as opposed to a jrnswitch"
 ;
 i ($ZBOOLEAN(+(value),+(1),1)) d
 . w !,"<missing> indicates that the system thinks that at least "
 . w !,"          one journal file that should be present is missing"
 i ($ZBOOLEAN(+(value),+(2),1)) d
 . w !,"<cluster start: date time> indicates that this system joined"
 . w !,"          the cluster at some point during this journal file."
 . w !,"          The cluster sequence numbers are reset to 0 because"
 . w !,"          the cluster was restarted at some point."
 i ($ZBOOLEAN(+(value),+(4),1)) d
 . w !,"n/a for a sequence number indicates that the machine was never"
 . w !,"          part of the cluster for the 'life' of that journal"
 . w !,"          file."
 i ($ZBOOLEAN(+(value),+(8),1)) d
 . w !,"* for a sequence number means that this system was not part of"
 . w !,"          a cluster for the 'life' of the journal file but the"
 . w !,"          system was part of the same cluster before and after"
 . w !,"          this file. This file will be restored as if all its"
 . w !,"          records have the last sequence number from the prior"
 . w !,"          journal file from when the system was in the cluster."
 w !
 q
showone(ref) ;
 ; ref = a local array reference containing the "root" of the
 ; data for a system. This is typically either "dirlist" which
 ; is the output from findfiles or clumember(id,"files") which
 ; is where we accumulate the data for all of the cluster members.
 ;
 ; Returns the value to pass to showfooter(ret). The value we return
 ; is a bit field describing what elements of the key need to
 ; be explained. 
 ;    Bit #1 = we suspect one or more journal files are missing
 ;    Bit #2 = we detected a cluster restart across one or more
 ;                journal files
 ;    Bit #4 = we found a journal file from when the system wasn't
 ;                in the cluster so we displayed a sequence # of n/a
 ;    Bit #8 = a journal file wasn't part of the cluster but a
 ;                prior and subsequent journal file are from the same
 ;                cluster (eg. the system was shutdown, restarted and
 ;                didn't immediatly join the cluster).
 ; This is a bit field so that the results of multiple calls to
 ; showone can be ORed together to produce a single footer.
 ;
 n i,fname,line,seq,tstamp,missing,last,notinclu1,notinclu2
 n prevfile,retval,lastclumstart,clumstart,restartflag
 s missing=0,restartflag=1,notinclu1=0,notinclu2=0
 s index="",last=""
 s index=$O(@ref@(index))
 i index="" d  q 0
 . w !,?5,"<No journal files found for this cluster member>",!
 s line=@ref@(index),lastclumstart=$zdth($P(line,"^",9),-2)
 i lastclumstart d
 . w !,"   <cluster start: "
 . w $ZD(lastclumstart)," ",$ZT($P(lastclumstart,",",2),4)
 . w ">"
 f  d  s last=index,index=$O(@ref@(index)) q:index=""  
 . s line=@ref@(index)
 . w !
 . ; When clumstart from this file differs from the last value we've
 . ; seen it indicates the cluster restarted. A clumstart value of 0
 . ; indicates this system was not part of the cluster while it was
 . ; using that journal file. If we encounter a clumstart value of 0
 . ; we delay reporting that a cluster restart occurred until we see
 . ; a non-zero clumstart value (because a value of 0 doesn't mean
 . ; that the cluster restarted, it means that we didn't join the
 . ; cluster).
 . s clumstart=$zdth($P(line,"^",9),-2)
 . i clumstart,lastclumstart'=clumstart d
 . . w "   <cluster start: "
 . . w $ZD(clumstart)," ",$ZT($P(clumstart,",",2),4)
 . . w ">",!
 . . s lastclumstart=clumstart
 . . s restartflag=1
 . ;
 . s prevfile=$case($ZBITGET($ZVERSION(0),46),0:$case($f($P(line,"^",2),";"),0:$e($P(line,"^",2),*-8-$l($p($P(line,"^",2),".",$l($P(line,"^",2),"."))),*-$case($e($P(line,"^",2),*)="z",0:0,1:1)),:$e($P(line,"^",2),*-8-$l($p($P(line,"^",2),".",$l($P(line,"^",2),"."))),$f($P(line,"^",2),";")-2)),:$P(line,"^",2))
 . i prevfile="" w "st:"  ; null prior file means jrnstart
 . e  i last=""  ;do nothing since this is the first file selected
 . e  i prevfile=$E(last,1,$L(last)-1) w "   "  ; the normal case
 . e  w "   ",prevfile,"   <missing>",!,"   " s missing=1 
 . ;
 . w $case($ZBITGET($ZVERSION(0),46),0:$case($f($P(line,"^"),";"),0:$e($P(line,"^"),*-8-$l($p($P(line,"^"),".",$l($P(line,"^"),"."))),*-$case($e($P(line,"^"),*)="z",0:0,1:1)),:$e($P(line,"^"),*-8-$l($p($P(line,"^"),".",$l($P(line,"^"),"."))),$f($P(line,"^"),";")-2)),:$P(line,"^")),"    "
 . i '$P(line,"^",6) w "<empty>" q  ; lastoffset = 0
 . f i=4,7 d  ; sequence #'s are pieces 4 and 7
 . . i clumstart s seq=$P(line,"^",i)
 . . e  s seq="n/a",notinclu1=1
 . . i seq="*" s notinclu2=1 
 . . s tstamp=$P(line,"^",i+1)
 . . ; tstamp is in $H format
 . . w " ",$J(seq,10)
 . . w " ",$ZDATE(tstamp)," ",$ZTIME($P(tstamp,",",2),4)
 ; Form the retval bitmask. 
 ;    Bit #1 = we suspect one or more journal files are missing
 ;    Bit #2 = we detected a cluster restart across one or more
 ;                journal files
 s retval=0
 i missing s retval=($ZBOOLEAN(+(retval),+(1),7))
 i restartflag s retval=($ZBOOLEAN(+(retval),+(2),7))
 i notinclu1 s retval=($ZBOOLEAN(+(retval),+(4),7))
 i notinclu2 s retval=($ZBOOLEAN(+(retval),+(8),7))
 w !
 q retval
 ;
findfiles(id,jffirst,jflast,begloc) ;
 s begloc=$g(begloc) ;the location of the first record to dejournal
 ; This routine locates all the journal files for cluster system
 ; #id that span the range of time specified by the jffirst and jflast
 ; journal files. jffirst and jflast are either the journal files from
 ; the primary system or the user has specified a first and last for
 ; this system. These are in $$$JRNSHORTNAME form. If jflast is
 ; null we get all the jounal files from jffirst for this system.
 ;
 ; First build a list of all of the journal files from all of the
 ; source directories for this system
 ;
 ; Inputs:
 ;    clumember() structure
 ;    id = id # index into clumember() structure
 ;    jffirst = $$$JRNSHORTNAME of 1st journal file we want to find
 ;              for this system. If this is null we start with the
 ;              1st journal file we can find. If we can't find this
 ;              file exactly we find the file prior to it as our 
 ;              1st one.
 ;    jflast = $$$JRNSHORTNAME of the last journal file we want to
 ;              find for this system. If this is null we find all
 ;              journal files. If we can't find this journal file
 ;              exactly, we find the one which comes immediatly after
 ;              it.
 ; Output:
 ;    err indicates an error was encounterd and we should ask the
 ;        user if they want to abort or continue
 ;    For each journal file we think we need to restore we set:
 ;       dirlist(<shortname>_"J") =
 ;           <fullfilename>^
 ;           <prev jrnfile read from the journal file>^
 ;           <journal offset of the 1st journal record>^
 ;           <cluster sequence # of 1st journal offset>^
 ;           <timestamp on block containing 1st journal record>^
 ;           <journal offset of the last journal record>^
 ;           <cluster sequence # of last journal offset>^
 ;           <timestamp on block containing last journal record>^
 ;           <clumstarttime in integer format (time(0))>
 ;    
 n i,numpath,path,fspec,file,shortname,chan,n,index
 n firstcseq,lastcseq,firstadr,lastadr,firsttime,lasttime
 n prevjrn,str,d,next,header,d,next,clumstart,adr
 n tmpshort
 ;
 k dirlist  ; reset this
 s chan=-1  ; when chan is not negative, a journal file is open
 s $ZT="findfilesER"
 s numpath=clumember(id,"path")
 ;
 ; we find all the files in all of the directories. We then extract
 ; the portion that would be a "short journal file" name and if it
 ; matches the form nnnnnnnn.nnn we consider it a journal file
 ;
 ; This routine finds all of the journal files it can in
 ; clumember(id,"path",...) and for each journal file it finds it
 ; generates a dirlist(<shortname>) entry of the form described
 ; above.
 ;
 f i=1:1:numpath d
 . s path=clumember(id,"path",i)
 . s fspec=path_$P(clumember(id),"^",3)_"*.*"  ; 3rd piece = prefix
 . w !,"This routine has not been ported to this o/s. Fix DIRLOOK"
 . w !,"loop in findfiles^JRNRESTC2"
 . s $ZE="<UNIMPLEMENTED>findfiles+<n>^JRNRESTC2" 
 . g ^%ET
 ;
 ; Run through dirlist() looking for journal files that don't have
 ; a cluster timestamp (eg. the system wasn't in the cluster) but 
 ; where the prior and subsequent cluster timestamps are the same.
 ; This indicates a system restarted but didn't join the cluster 
 ; immediatly. These files are restored as if they were from the 
 ; cluster with the sequence number of the prior journal file. If
 ; all prior journal files from the cluster start are eliminated by
 ; elimfiles, these are changed back to "non-clustered" journals.
 ;
 s clumstart=""
 s index=$O(dirlist("")) q:index=""
 f  d  q:index=""
 . s n=$P(dirlist(index),"^",9) ;clumstart time
 . i n s clumstart=n,index=$O(dirlist(index)) q
 . ; This file doesn't have a cluster start time, find the next
 . ; cluster start time
 . s d=index ; remember where we started
 . f  s index=$O(dirlist(index)) q:index=""  q:$P(dirlist(index),"^",9)
 . q:index=""
 . s n=$P(dirlist(index),"^",9)
 . i n'=clumstart s clumstart=n,index=$O(dirlist(index)) q
 . ; Ok, we've found a range of journal files that don't have a cluster
 . ; timestamp but the prior and subsequent journal files that do
 . ; have cluster timestamps, have the same timestamp. Force these 
 . ; journal files to be considered part of the cluster. Set the
 . ; sequence number to '*' (interpreted as 0) so that we'll tell the
 . ; user what's happened.
 . f  d  s d=$O(dirlist(d)) q:d=index
 . . s $P(dirlist(d),"^",4)="*",$P(dirlist(d),"^",7)="*"
 . . s $P(dirlist(d),"^",9)=clumstart
 . s index=$O(dirlist(index))
 ;
 d elimfiles(jffirst,jflast)
 ;
 ; Finally, go through dirlist() and validate the journal file back
 ; pointers. The 2nd piece of each entry is the prior journal file
 ; we got from that journal file's header. This should match the
 ; prior subscript in the dirlist() array. 
 ; 
 s header=0
 s d=$O(dirlist("")),next=$O(dirlist(d))
 f  q:next=""  d  s d=next,next=$O(dirlist(d))
 . s prevjrn=$P(dirlist(next),"^",2)
 . q:prevjrn=""  ; there isn't a stored prior journal name, that's ok
 . s prevjrn=$case($ZBITGET($ZVERSION(0),46),0:$case($f(prevjrn,";"),0:$e(prevjrn,*-8-$l($p(prevjrn,".",$l(prevjrn,"."))),*-$case($e(prevjrn,*)="z",0:0,1:1)),:$e(prevjrn,*-8-$l($p(prevjrn,".",$l(prevjrn,"."))),$f(prevjrn,";")-2)),:prevjrn)
 . q:$E(d,1,$L(d)-1)=prevjrn
 . s err=1
 . i 'header d
 . . w !,"Apparent missing journal file(s) for cluster system #",id
 . . w !,"We located journal files: "
 . . s header=1
 . e  w !,"additionally, we located journal files: "
 . w !,?5,$P(dirlist(d),"^")
 . w !,?5,$P(dirlist(next),"^")
 . w !,"but it appears that at least one intervening journal file"
 . w !,?5,$P(dirlist(next),"^",2)," is missing."
 ;
 Q
elimfiles(jffirst,jflast) 
 ;
 ; Impose the limits of jffirst and jflast on the contents
 ; of dirlist() discarding files outside of the limits. jffirst and
 ; jflast represent the 1st and last journal files we want to
 ; restore. If we remove any journal files then check for journal
 ; files that have a sequence # of '*' at the start or end of the
 ; list and if there are any, set the sequence #'s and the cluster
 ; mstart time to 0 because these are no longer "surrounded" by 
 ; journal files from the same cluster start.
 ;
 n d,next
 q:'$D(dirlist)  ; its empty, nothing to do
 ;
 i jffirst'="" d
 . s jffirst=jffirst_"J"
 . s d=$O(dirlist(jffirst),-1)
 . f  q:d=""  s next=$O(dirlist(d),-1) k dirlist(d) s d=next
 . s d=""
 . f  s d=$O(dirlist(d)) q:d=""  q:$P(dirlist(d),"^",4)'="*"  d
 . . s $P(dirlist(d),"^",4)=0,$P(dirlist(d),"^",7)=0
 . . s $P(dirlist(d),"^",9)=0
 ;
 ; If dirlist(jflast) exists then delete all subsequent entries
 ; if it doesn't exist then delete all entries AFTER
 ; $O(dirlist(jflast))
 ;
 i jflast'="" d
 . s jflast=jflast_"J"
 . s d=$O(dirlist(jflast))
 . f  q:d=""  s next=$O(dirlist(d)) k dirlist(d) s d=next
 . s d=""
 . f  s d=$O(dirlist(d),-1) q:d=""  q:$P(dirlist(d),"^",4)'="*"  d
 . . s $P(dirlist(d),"^",4)=0,$P(dirlist(d),"^",7)=0
 . . s $P(dirlist(d),"^",9)=0
 q
findfilesER ;
 s $ZT=""
 s err=1
 i chan>0,$zu(78,7,chan)
 w !,"Error ",$ZE," encountered locating files for system #",id
 q
storejrnpath(id) ;
 ; Input: prefix and lookpath
 ; Stores info in the clumember(id) array. id #0 is the 
 ; "primary" system which is driving the restore
 n i
 s $P(clumember(id),"^",3)=prefix
 s clumember(id,"path")=lookpath
 f i=1:1:lookpath s clumember(id,"path",i)=lookpath(i)
 q
 ;
SETCLULOOKPATH ;
 ; set look path in which journal files are searched for
 N x
 K lookpath 
 S lookpath=0
 F  r !,"     Directory to look for the files in? ",x Q:x=""  D
 . D FIXDIR^JRNRESTO(.x) 
 . S lookpath=lookpath+1,lookpath(lookpath)=x
 i 'lookpath d  g SETCLULOOKPATH
 . w !,"     You must enter at least one directory for each cluster"
 . w " member"
 Q
 ;
LOADCLUPARAM(config) ;
 ; Opens the file <config> and loads the journal file prefix and
 ; the list of directories they are located in. Returns 1 if
 ; we're successful, 0 if there's an error.
 ;
 ; The file has the format:
 ;      journal prefix
 ;      journal file directory #1
 ;      journal file directory #2
 ;      journal file directory #3
 ;           .
 ;           .
 ;      journal file directory #n
 ;      journal file directory #1
 ;      *END*  <- the text "*END"
 n line
 s $ZT="CONFIGERR"
 k lookpath
 s lookpath=0
 s prefix=""
 o config::10 e  w !,"     failed to open ",config q 0
 u config 
 r line
 G:$ZEOF CONFIGEOF
 g:$E(line,1,4)="*END" CONFIGDONE
 s prefix=line
 f  r line g:$ZEOF CONFIGEOF q:line="*END"  d
 . D FIXDIR(.line) 
 . S lookpath=lookpath+1,lookpath(lookpath)=line
 ;
CONFIGDONE ;
 use 0
 c config
 i 'lookpath q 0  ; lookpath must be at least one
 q 1 ; success
CONFIGEOF ;
 s $ZE="<ENDOFFILE>" ;Come here when $ZEOF is set
CONFIGERR ;
 s $ZT=""
 u 0
 ; If we hit an end of file error and we've read the 
 ; prefix and at least one journal file destination, treat this
 ; as success
 i $ZE["<ENDOFFILE" g CONFIGDONE
 w !,"     Error ",$ZE," reading config file ",config 
 c config 
 q 0
YN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YN"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"yn","YN") I "^YN"'[R W "  enter Yes or No, please"
 S POP=(R="^") W $E($S(R="N":"No",R="Y":"Yes",1:""),$L(X)+1,3) Q R
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/FILEINC.inc#1 $ ($Change: 7440104 $) */
FIXDIR(dir) ;procedure, dir is passed by reference
 Q:dir=""
 Q:$A(dir,$L(dir))=$A($s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""))
 s dir=dir_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")
 Q
fixdir(dir) ;function
 Q:dir="" ""
 Q:$A(dir,$L(dir))=$A($s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")) dir
 Q dir_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")
basename(f) ;similar to basename on UNIX
 Q $P(f,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""),1,$L(f,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""))-1)_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")
appdir(d1,d2) ;use $zu(12,d2) to append d2 to canonic dir
 S d1=d1_d2
 Q d1
VALIDIR(dir) ;validate directory dir and create it if dir doesn't exist
 new flag
 s flag=1
 g vdir2
validir(dir,flag) ;validate directory dir and optionally create it if it
vdir2 ; VALIDIR(dir) comes here with flag set to 1
 quit:$$ChkDirOrSpecEXISTS(dir)'="" 1   ; dir is valid and exists
 quit:$$ChkDirVALID(dir)="" 0    ; dir is not valid
 i flag'=1 q 0  ; flag says don't create, return failure
 new x
 set x=$$mkdir(dir)  ; returns 0 for success, 1 for failure
 q:x=1 0  ; failed to create
 quit:$$ChkDirOrSpecEXISTS(dir)="" 0   ; it doesn't we failed
 q 1  ; success
mkdir(dir) ;create a new directory
 q '##class(%Library.File).CreateDirectoryChain(dir)
jrnshort(jf,short) ;get/set short form of a journal file name FIXME HYY1999
         N (jf,short)
         S len=$L($P(jf,";"))
         Q:$G(short)="" $E(jf,len-11,len) ;"GET" form
         S $E(jf,len-11,len)=short ;"SET" form
         Q jf
GJrnPrefix(jf) ;extract prefix from the journal file name jf
         N (jf)
         S fname=$P(jf,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""),$L(jf,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")))       
         Q $e(fname,1,$l($p(fname,"."))-8)
GetJrnFileName(path) { 
	i $f(path,"/") q $p(path,"/",$l(path,"/")) ;presumably a Unix path
	if $f(path,"\") q $p(path,"\",$l(path,"\")) ;presumably a Windows path
	s vmsfile=$p(path,"]",2) i vmsfile="" q path ;a name only, not a path
	q $p(vmsfile,";") ;return name from a VMS path without trailing ";"
}
dirinvalidmsg(dir1,dir2) 
 n valid1,valid2,cnt,msg
 s valid1=$$VALIDIR(dir1),valid2=$$VALIDIR(dir2)
 s cnt=valid1+valid2 ; cnt = 0 if both invalid, 1 if one is valid
 s msg="The following journaling "
 s:cnt msg=msg_"directory is" 
 s:'cnt msg=msg_"directories are"
 s msg=msg_" not valid"_$C(13,10)
 s:'valid1 msg=msg_"     "_dir1_$C(13,10)
 s:'valid2 msg=msg_"     "_dir2_$C(13,10)
 q msg
ChkDirVALID(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,1)
ChkDirEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkDirOrSpecEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,3)
ChkDir(R) N N S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkBad S $ZT="" W !,"<"_$P($P($ZE,"<",2),">")_"> error -- invalid directory"
 Q ""

JRNRESTCHELP^INT^1^67214,47330
JRNRESTCHELP ;Cluster Restore Journal HELP ON MENUS
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ;
 ;
SetupmainHelp() ; Help for Main SetUp Menu in JRNRESTC
 n rc,resp
 w !!,"Information on the Main menu options:"
 w !,"Option 1: Selecting this option will allow the user to specify a different start"
 w !,?5,"and stop combination other than what is currently displayed."
 w !,"Option 2: This option allows the user to Identify a list of journals to be"
 w !,?5,"dejournaled other than the list contained in the default IRISJRN.LOG."
 w !,?5,"It also allows the user to Redirect the journal files in a specific list if"
 w !,?5,"those files are not in their original locations, as specified in the"
 w !,?5,"cluster journal log. And finally option 4 allows the user to Create a new"
 w !,?5,"log and specify the journal files that will be used by selecting the"
 w !,?5,"journal file directories.  The user will be allowed to edit this list."
 r !!,"Press <enter> continue",resp
 q 0
 ;
SetdejrnstartHelp() ; Help for Start SetUp Menu in JRNRESTC
 n rc,resp
 w !!,"Information on the Start menu options:"
 w !,"Option 1: System will search for cluster session ID's in the journal files for"
 w !,?5,"cluster session begin. It displays choices of where to start journal"
 w !,?5,"restore from which the user can select."
 w !,"Option 2: User is prompted to enter a journal file and its directory path.  The"
 w !,?5,"system will check to see if the file is in the IRISJRN.LOG. If it is, the"
 w !,?5,"user will be prompted to enter a specific journal marker offset from which"
 w !,?5,"to start the restore."
 w !,"Option 3: If a Backup restore has occurred (stored in ^SYS(""RESTORE"")) the"
 w !,?5,"system will display the backup and the specific journal marker from which"
 w !,?5,"it will start the restore.  Selection of this option then will only confirm"
 w !,?5,"the user's choice of what the system has displayed."
 w !,"Option 5: Will display the date and time of the most recent backup and give the"
 w !,?5,"user the option to select that backup.  If the user wants a different"
 w !,?5,"backup, then the selection of which backup to start the restore can be"
 w !,?5,"made by date or by a list of available backups."
 r !!,"Press <enter> continue",resp
 q 0 
 ;
SetdejrnstopHelp() ; Help for Stop SetUp Menu in JRNRESTC
 n rc,resp
 w !!,"Information on the Stop menu options:"
 w !,"Option 1: System will search for cluster session ID's in the journal files for"
 w !,?5,"cluster session end. It displays choices of where to stop journal restore"
 w !,?5,"from which the user can select."
 w !,"Option 2: Two options can occur.  First if the user is using the IRISJRN.LOG"
 w !,?5,"and the Restore Stop is at the current journal location in that log then"
 w !,?5,"no changes can be made.  In this case the option will read"
 w !,?5,"""At current journal location"".  If the user has selected a different"
 w !,?5,"list of journal files and is not using IRISJRN.LOG,then the option will"
 w !,?5,"read ""At the end of <directory path /log file name>""."
 w !,"Option 3: User is prompted to enter a journal file and its directory path.  The"
 w !,?5,"system will check to see if the file is in the IRISJRN.LOG. If it is, the"
 w !,?5,"user will be prompted to enter a specific journal marker offset from which"
 w !,?5,"to stop the restore"
 w !,"Option 4: Will display the date and time of the most recent backup and give the"
 w !,?5,"user the option to select that backup.  If the user wants a different"
 w !,?5,"backup, then the selection of which backup to stop the restore can be"
 w !,?5,"made by date or by a list of available backups."
 r !!,"Press <enter> continue",resp
 q 0 
 ;
SetjrnlogHelp() ; Help for SetUp Journal Log Menu in JRNRESTC
 n rc,resp
 w !!,"Information on the Setup - Journal File Info menu options:"
 w !,"[I]dentify Option: User is prompted to enter a cluster journal log that is"
 w !,?5,"different than the one displayed.  Note: a full directory reference"
 w !,?5,"may be necessary. If the IRISJRNMARK.LOG is not in that directory"
 w !,?5,"and therefore cannot be found, then Start/End restore at backup will"
 w !,?5,"not be available."
 w !,?5,"A warning will also be issued that if a different cluster journal log from"
 w !,?5,"the current one is specified, the user may need to re-enter information on"
 w !,?5,"journal redirection, restore, and range."
 w !,"[R]edirect Option: This option is only available if a different journal log is"
 w !,?5,"being used other than the one originally displayed in the [I]dentify"
 w !,?5,"Option.  If selected the user will be asked for the original location"
 w !,?5,"of journal files and the new location of journal files."
 w !,"[C]reate Option: The user will be asked to create a new cluster journal log or"
 w !,?5,"write over an existing one.  The user must then specify how many cluster"
 w !,?5,"members are involved. The next section is critical.  The user must enter"
 w !,?5,"a Prefix (if used) and directory location(s) for each cluster member."
 w !,?5,"There is no way to back out during this section other than an abort of the"
 w !,?5,"dejournal process. It is important that the user use caution."
 w !,?5,"At the end of this process, all of the journal files will be displayed and"
 w !,?5,"the cluster member to which they belong. It is at this time that the user"
 w !,?5,"may EXCLUDE some of the journal files from the list by selecting their"
 w !,?5,"number(s). This section will accept an undo or quit without requiring an"
 w !,?5,"abort of the dejournal process."
 w !,?5,"The create option also issues the warning that if a different cluster"
 w !,?5,"journal log from the current one is specified, the user may need to"
 w !,?5,"re-enter information on journal redirection, restore, and range."
 r !!,"Press <enter> continue",resp
 q 0 
 ;
SetJrnlogRedirHelp ;
 w !
 w !,"	Redirecting journal files is necessary if journal files to be"
 w !,"	restored are not in their original locations, as specified in"
 w !,"	the cluster journal log. To redirect journal files, provide"
 w !,"	their original and current locations when prompted. You may"
 w !,"	give a full or partial directory name as an original location."
 w !,"	If a partial name is given, then all original locations whose"
 w !,"	*leading* characters match the partial name will have the"
 w !,"	partial name replaced with the new location you specified."
 w !
 q

JRNRESTD^INT^1^67214,47330
JRNRESTD ; define journal restoration params
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/FILEINC.inc#1 $ ($Change: 7440104 $) */
   ; $$what()   determine what should be restored
   ; input: fromrest
   ;        fromrest=1  => use directories listed in yesdir(dir)=1
   ;                =2  => all directories
   ;                =3  => ask which directories should be restored
   ;                =8  => JCONVERT, dirs don't have to exis and don't
   ;                       ask for redirection target [JO1726]
   ; return: 1 => dejournaling should proceed, 0 => nothing selected
   ;         ALL = 1 means restore all journaled globals in all dir
   ;     else setups arrays 'global' and 'yesdir'
   ; dejrn(directory) = ALL_GLOBALS_FLAG,new directory name
   ;					ALL_GLOBALS_FLAG = 1 means restore all globals in this db, 0 means no.
   ; dejrn(directory, global) = individual global to restore
   ; clujrn(directory) = "Y" if directory was cluster-mounted 
what()  
 s $zt="whaterr"
 n zt s zt=$zt
 i $g(QUIETMODE) g ZJRNERR  ;if called thro non-interactive restore
                            ;don't use user-defined filter at all
 s zt=$zt,$zt="ZJRNERR"
 s ZJRNUSE=0 x "zl ZJRNFILT"
 s ZJRNUSE=($$YN("Use current journal filter (ZJRNFILT)")="Y")
 s ZJRNUSEMARK=($$YN("Use journal marker filter (MARKER^ZJRNFILT)")="Y")
 i ZJRNUSE,$$YN("Apply filter to every selected file","Y")="Y" s ZJRNUSE=2
ZJRNERR s $zt=zt,$ze=""
 ;
 ; Set up clujrn() based on CLSTATE
 K clujrn
 i $S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0),$D(CLSTATE) d
 . n d s d=""
 . f  s d=$O(dejrn(d)) q:d=""  i $G(CLSTATE(d))="C" s clujrn(d)="Y"
 s private=1  ; Set to 0 if a cluster restore
 ; DBREST puts the db's to dejournal in dejrn(). Just return
 i fromrest=1 s ALL=0,Q="""" q 1
 I fromrest=2 s ALL=1 Q 1 ;all directories
 I fromrest=3 s ALL=0
 i $g(QUIETMODE) d REVIEW
 i $g(QUIETMODE),'$D(dejrn) w !,"***Journal Restore Canceled***",! q 0
 i $g(QUIETMODE) q 1
 i $S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0) do 
 . if $g(CLURESTORE) s private=0 q
 . s private=($$YN("Cluster journal operation")="N")
 i 'private s ALL=0
 e  i fromrest'=3 S ALL=($$YN("Process all journaled globals in all directories")="Y")
 I ALL Q 1 ;all directories
 K dejrn
 S xOS=($$YN("Are journal files imported from a different operating system","N")="Y")
 D GETDIR ;get a list of directories to restore
 D REVIEW ;make sure it is what you want
 I '$D(dejrn) W !,"*** Journal Restore Cancelled***",! Q 0
 Q 1 ;dejrn() now contains journal restoration directives
whaterr ;
 s $zt=""
 i $ze'["INTERRUPT" u 0 w !,$ze,!
 s $ze=""
 q 0
 ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
GETDIR ;get dejrn() definitions
 N DIR,redir,def,R,X,NEW,A,ALL,W,status
DIR ;
 ; $$$GetDir(x,y,-1) means don't check director for valid or exists.
 ;                0) means its ok if it doesn't exist
 ;                1) means its not ok if it doesn't exist
 i $zversion(1)=1 d  
 . W !!,*7,"If restoring from a different instance please review HELP before proceeding"
 W ! S R=$$GetDir("Directory to restore [? for help]","",$S(fromrest=8:-1,(+$g(xOS)):-1,1:0))
 i R="",$d(dejrn) { 
   s status=$$CheckGlobalSelection(.dejrn,1)
   i 'status {
     i $$YN("Change database redirections/global selections","Y")="Y" g DIR
     K dejrn
     q
   }
 }
 Q:R=""  I $E(R)="^" K dejrn Q
 I R="?" W ! DO  G DIR
 . W !?4,"Enter a directory which is in the journal; you will"
 . W !?4,"then be given the option to process all or some of the"
 . W !?4,"globals which were journaled from that directory.",!
 . if fromrest'=8 d
 . . W !?4,"Note that you will also be given the chance to re-direct"
 . . W !?4,"the contents of this directory to another directory."
 . i $zversion(1)=1 d  
 . . w !!,"Note: If you are restoring from a different instance use the following as a" 
 . . w !,?6,"guide when entering the original directory path:"
 . . w !,?6,"1. Make sure that no logicals are used in the path name."
 . . w !,?6,"2. You must specify the full canonized path - including VMS underscore (_)"
 . . w !,?9,"(i.e.) _$1$dga1:[systembase.xxxa01]",!
 I $E(R)="?" W ! DO  G DIR
 . I $O(dejrn(""))="" W !?4,"no directories selected" Q
 . W !?4,"Directory                      All?"
 . w:fromrest'=8 "     Redirected to:"
 . S DIR="" F  S DIR=$O(dejrn(DIR)) Q:DIR=""  DO
 . . S X=dejrn(DIR) W !?4,$$LJ(DIR,30),$S(X:" Yes",1:"  No")
 . . q:fromrest=8  ;no redirection for JCONVERT
 . . S X=$P(X,",",2,$L(X)) I X]"",X'=DIR W ?43," "_X
 i xOS {
   s DIR=R ;Do not check or normalize source directory from a different OS
 } else {
   S DIR=$$ChkDirOrSpecEXISTS(R) 
   i DIR="" s DIR=$ZU(12,R)
   I DIR'=R W "  "_DIR ;resolve ref
 }
 I "^?"[$E(DIR) W *7 G DIR ;special case
 ;
 if fromrest=8 s NEW=DIR g GETGLOTOP ;skip redirect for JCONVERT 
 S X=+$$STAT(DIR),redir=0 ;get some status information
 I X<-1 DO  S redir=1 ;redirection is REQUIRED
 . W "??",!,"No database exists in that directory."
 . W !,"(you will be required to redirect to another directory)"
NEW S W=$P($G(dejrn(DIR)),",",2,999) S:W="" W=DIR
 W !,"Redirect to Directory: "_W,!," => " R R S:R="" R=W G DIR:$E(R)="^"
 I $zconvert(R,"U")="*DEL" K dejrn(DIR) W "ETED" G DIR
 I $E(R)="?" W ! DO  W ! G NEW
 . W !?4,"Enter the name of the directory where the dejournaled"
 . W !?4,"globals of this directory should be placed.  If this"
 . W !?4,"should be the same directory, enter '.' here."
 . W !?4,"Enter '*DEL' to delete the entry if it was previously specified."
 . W !?4,"Enter '^' to return to the prior prompt."
 . I 'redir Q  ;redirection is not required
 . W !?4,"Note that you MUST select another directory here because"
 . W !?4,"the indicated directory is not currently mountable."
 I R="." S R=DIR ;shorthand
 i ($e(R,1,8)=":mirror:") s NEW=$$GetMirDBPath(R) i 1
 e  S NEW=$$ChkDirOrSpecEXISTS(R) 
 I NEW="" W *7," invalid directory!" G NEW
 I redir,NEW=DIR W *7," *must* be a different directory" G NEW
 ;
 S X=+$$STAT(NEW) I X=-2 W *7," not a valid database!" G NEW
 i (X<0)!(X=$zu(40,0,41)) do  i (X<0)!(X=$zu(40,0,41)) g NEW
 . W *7,!,"        ...not mounted...mounting..."
 . S X=+$$MOUNT(NEW) I X'<0 W " ok!" Q
 . W "??",!,"Mounting ",NEW," failed."
 . i NEW=DIR s redir=1 d
 . . w !,"You must redirect the restore to another dataset."
 if $Case($zb(+$p($ZU(49,NEW),",",17),$zu(40,8,28),1),0:0,:1) d  g NEW
 . w !,NEW_" is a mirrored database. Journal restore is not allowed."
 . w !,"You need to abort this operation and run MirrorCatchup^JRNRESTO"
 . w !,"to restore journal records to mirrored databases."
 ;
 W:$X+$L(NEW)>74 !?70-$L(NEW) W "--> "_NEW
 ;
GETGLOTOP	;JO1726
 i private s def="N"
 e  s def="Y"
 I $G(dejrn(DIR)) W !,"Currently set to process ALL globals" S def="Y"
 S ALL=$$YN("Process all globals in "_DIR,def) G DIR:POP
 ;
 I ALL="Y" K dejrn(DIR) S dejrn(DIR)="1,"_NEW
 I ALL="N" S dejrn(DIR)="0,"_NEW D GETGLO ;get a list of globals
 i 'private s clujrn(DIR)="Y"
 G DIR
 ;-=-=-=-=
GETGLO ;allow the specification of globals (and global patterns)
 W ! I $D(dejrn(DIR))\10 DO  ;list existing globals
 . N glo W !,"The following globals are currently selected:"
 . S glo="" F  S glo=$O(dejrn(DIR,glo)) Q:glo=""   DO
 . . W !?10,$$LJ(glo,10) I (glo["*")!(glo["?") W "  (pattern)"
GLO R !,"Global ^",R I R="" Q
 I R="?" W ! DO  W ! G GLO
 . W !?4,"Select the name of a global which you specifically wish"
 . W !?4,"to be processed."
 . W !?4,"You may select patterns of globals by using the wild-card"
 . W !?4,"characters '*' and '?' ('*' matches any number of characters"
 . W !?4,"while '?' matches any single characters)."
 . W !?4,"Enter ?L to list the currently selected list of globals"
 I $E(R)="?" W ! DO  G GETGLO
 . I $D(dejrn(DIR))\10=0 W !,"No globals selected.",!
 I R="*" W *7," you may not select all globals this way!" G GLO
 i $e(R)'="*",$e(R)'?1A,$e(R)'="%" W *7," that is not a valid global name!" g GLO
 e  i $tr($e(R,2,$l(R)),"*?.","")'?.AN W *7," that is not a valid global name!"  g GLO
 I $D(dejrn(DIR,R)) DO  G GLO
 . W "  already exists -- rem" K dejrn(DIR,R) W "oved"
 S dejrn(DIR,R)=$$PATRN(R)
 i $tr(R,"*?&#")'=R s dejrn=1 ;selected globals with patterns
 G GLO
GLOLST ;list the selected globals/global patterns
 W !,"The following globals are currently selected:"
 S glo="" F  S glo=$O(dejrn(DIR,glo)) Q:glo=""   DO
 . W !?10,$$LJ(glo,10) I (glo["*")!(glo["?") W "  (pattern)"
 W ! Q
 ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
REVIEW ;review the directories/globals selected and confirm
 I '$D(dejrn) Q  ;no specs!
 W !!,"Processing globals from the following"
 i 'private w " clustered"
 w " datasets:"
 N dir,glo,x,a,cnt
 S cnt=0,dir="" F  S dir=$O(dejrn(dir)) Q:dir=""  S cnt=cnt+1 DO
 . S x=$G(dejrn(dir)),a=+x,x=$P(x,",",2,$L(x))
 . W !,$J(cnt,2)_". "_$$LJ(dir,20)_"   "
 . W $S(a:"All",1:"Selected")_" Globals"_$S(a:"",1:":")
 . I x]"",x'=dir W !?4,"(Redirect to: "_x_")"
 . I $O(dejrn(dir,""))="" DO:'a  Q  ;no globals selected
 . . W !?4,"*** No globals selected for this directory! ***",!
 . . K dejrn(dir) ;remove it!
 . I a DO  S x=dejrn(dir) K dejrn(dir) S dejrn(dir)=x Q
 . . W !?4,"*** globals specified for an inclusive directory? ***"
 . S glo="" W !?10 F  S glo=$O(dejrn(dir,glo)) Q:glo=""  DO  ;globals
 . . W:$X>65 !?10 W $$LJ("^"_glo,12)
 W !
 Q:$g(QUIETMODE)            ; Quit if quiet mode
 I $$YN("Specifications correct","Y")="N" K dejrn
 Q
 ;-=-=-=-=
CheckGlobalSelection(dejrn,verbose) ;
 n dejrnr,glo,gnxt,dir,src,target,match
 s $zt="CheckGlobalSelectionErr"
 s dir="" f  {
   s dir=$o(dejrn(dir),1,target) q:dir=""
   s target=$p(target,",",2,*) ;target database
   i $g(dejrnr(target))="" { ;a new target
     s dejrnr(target)=dir
   } else { ;target is shared with another source db
     s src=dejrnr(target)
     i dejrn(src)'=dejrn(dir) {
       i $g(verbose) {
         w !!,*7,"Currently set to process -- "
	 w !,$s(dejrn(dir):"all",1:"selected")," globals in ",src
	 w !,$s(dejrn(src):"all",1:"selected")," globals in ",dir
       } else {
         q  ;return an error status to the caller
       }
     } elseif +dejrn(src)=1 { ;to process all globals
       continue
     } else { ;to process selected globals
       s match=0,glo="" f  {  ;compare dejrn(src) with dejrn(dir)
	   s gnxt=$o(dejrn(src,glo))
	   i $o(dejrn(dir,glo))'=gnxt q  ;no match
	   s glo=gnxt
	   i glo="" s match=1 q  ;done (all nodes matching)
	   i dejrn(src,glo)'=dejrn(dir,glo) q  ;no match
       }
       i match continue
       i $g(verbose) {
         w !!,*7,"Currently set to process -- "
	 w !,"the following globals in ",src,":"
         S glo="" F  {
	   S glo=$O(dejrn(src,glo)) Q:glo=""
           W !?10,$$LJ(glo,10) I (glo["*")!(glo["?") W "  (pattern)"
	 }
	 w !,"the following globals in ",dir,":"
         S glo="" F  {
	   S glo=$O(dejrn(dir,glo)) Q:glo=""
           W !?10,$$LJ(glo,10) I (glo["*")!(glo["?") W "  (pattern)"
	 }
       } else {
         q  ;return an error status to the caller
       }
     }
     w !,"*** Inconsistent global selections for two databases that are"
     w !,"redirected to the same target ",R,!
     w !,"You must change database redirections/global selections to"
     w !,"eliminate the inconsistency or journal restore will be cancelled."
     q
   }
 }
 i dir="" q 1
 q $$Error^%apiOBJ(8407,dir,$g(src),$g(target))
CheckGlobalSelectionErr ;
 s $zt=""
 q $$Error^%apiOBJ(5002,$ze)
GetMirDBPath(mdn) ;
 n sfn,jrnf,dev,path
 s $zt="ErrGetMirDBPath"
 s jrnf=$zu(78,3) i jrnf="" q ""
 s dev=$zu(78,5,jrnf,0) i dev<0 q ""
 try {
   d $zu(78,6,dev)
   s sfn=$zu(78,31,mdn_":",2) 
   s path=$zu(78,31,sfn)
 } catch {
   s path=""
 }
 d $zu(78,7,dev)
 q path
ErrGetMirDBPath s $zt="",$ze="" q ""
StatMirDBName(mdn) ;
 n sfn,jrnf,dev 
 S $ZT="STERR" 
 s jrnf=$zu(78,3) i jrnf="" q -2
 s dev=$zu(78,5,jrnf,0) i dev<0 q -2
 try {
   d $zu(78,6,dev)
   s sfn=$zu(78,31,mdn_":",2) 
   i sfn<0 s sfn=-2
 } catch {
   s sfn=-2
 }
 d $zu(78,7,dev)
 q sfn
STAT(DIR) I (DIR<0)!(DIR="") Q -2 ;handle special case; bad directory name...
 i ($e(DIR,1,8)=":mirror:") q $$StatMirDBName(DIR) 
 S $ZT="STERR" Q $ZU(49,DIR) ;could fail, so...
STERR S $ZT="",$ZE="" Q -2 ;return null: CACHE.DAT, but bad label
MOUNT(DIR) ;remount it (if it was dismounted or not mounted)
 N x,retmsg
 s $ZT="MNTERR2^"_$ZN
 s x=$$mount^JRNRESTB(DIR)
 i 'x d  q retmsg
 . s x=$P(x,",",2)  ; pick up $ZU(17) return code
 . s retmsg="-1,Could not mount '"_DIR_"' because "_$$Error^%apiOBJ(-x)
 q $$STAT(DIR)
MNTERR2 S $ZT="" i $g(zjrnerr) zq 1 g @$zt
 Q ("Could not mount '"_DIR_"'")
CLUSETUP ;
 ; Ask the user to tell us:
 ;   a) how many cluster members there are
 ;   b) the journal file prefix for each cluster member
 ;   c) where to find the journal files for each cluster member
 ; Once we have this information build a list of journal files for
 ; each cluster member, including the primary system, and lookup
 ; the starting/ending sequence number in each file. For each journal
 ; file we also associate with it a cluster restart number. This number
 ; starts at 1 and it increases each time we detect that the cluster
 ; was restarted.
 ;
 ; Inputs (from SETUP^JRNRESTO):
 ;    prefix = journal prefix for the primary system
 ;    djfirst = 1st journal file to restore for the primary system
 ;    djlast = last journal file to restore for the primary system
 ;    lookpath() = list of directories to search for the primary system
 ;    clujrn() = array of clustered databases
 ;    %curfile = current journal file if journaling is enabled else
 ;               null string (full file name)
 ;    curfile = shortname of %curfile
 ;
 ; Returns the following:
 ;    notresto - if defined and non-zero means abort the restore
 ;    numclu = # of cluster members in addition to primary system
 ;    minseq = lowest sequence # to be restored
 ;    maxseq = highest sequence # to be restored
 ;    maxclumstart = highest cluster mstart value. maxseq applies
 ;        only to journal files that have this clumstart value
 ;    clumember(id)=djfirst^djlast^prefix
 ;    clumember(id,n)=<journal file name>^1st seq^last seq^clustartcnt
 ;       where id = integer running from 0 to numclu
 ;       n runs from 0 to the # of journal files
 ;       clustartcnt is the cluster restart counter
 ;    For each journal file we think we need to restore we set:
 ;    clumember(id,"files",(<shortname>) =
 ;           <fullfilename>^
 ;           <prev jrnfile read from the journal file>^
 ;           <journal offset of the 1st journal record>^
 ;           <cluster sequence # of 1st journal offset>^
 ;           <timestamp on block containing 1st journal record>^
 ;           <journal offset of the last journal record>^
 ;           <cluster sequence # of last journal offset>^
 ;           <timestamp on block containing last journal record>^
 ;           <clumstarttime in integer format (time(0))>
 ;
 s $ZT="CLUSETUPER^"_$ZN
 k numclu,clumember
 q:'$S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0)!'$D(clujrn)  ; not a cluster restore
 n i,config,jfirst,jlast,x,dirlist,minclumstart,clumstart,id,index
 n err
 ;
 ; store journal prefix and lookpath for primary system (id #0)
 ; and then locate its journal files
 d storejrnpath^JRNRESTC2(0)
 d findfiles^JRNRESTC2(0,djfirst,djlast,$g(DEJRNSTART))  ; loads dirlist 
 d elimfiles^JRNRESTC2(djfirst,djlast)   ;this is probably unnecessary
 i $D(dirlist) merge clumember(0,"files")=dirlist
 i $G(err),$$YN("Abort restore")="Y" s notresto=1 q
 ;
 w !!,"How many other cluster members are there to restore from? "
 r numclu
 f  q:-1<numclu&(numclu<14)  d  
 . w !,"Invalid response. Must be between 0 and ",MAXCLUMEM-1
 . w !,"How many other cluster members are there to restore from? "
 . r numclu
 i 'numclu s notresto=1 d  q
 . w !!,?5,"If there are no other cluster members then do not specify"
 . w !,?5,"that this is a restore of clustered datasets. Perform a "
 . w !,?5,"simple journal restore for non-clustered systems"
 . w !,"[Restore aborted]"
 ;
 w !,?5,"We need to know how to locate the journal files for the"
 W !,?5,"other cluster members. This information can be stored in"
 w !,?5,"a flat file, one file per cluster member, or it can be"
 w !,?5,"entered by hand. If you wish to enter information from a "
 w !,?5,"file enter the filename when asked for a parameter file."
 w !,?5,"Otherwise, skip this question and you will be asked to "
 w !,?5,"provide the journal file prefix and their location(s)"
 w !
 w !,?5,"Additionally for each system you may specify the first and"
 w !,?5,"last journal file to be restored or you can allow the system"
 w !,?5,"to calculate this for you. When specifying the first and last"
 w !,?5,"journal files manually if you leave 'from:' blank that means"
 w !,?5,"we will use the first journal file we can find and leaving"
 w !,?5,"'last:' blank means we will use the last journal file we can "
 w !,?5,"find. Leaving both blank means we'll use all the journal"
 w !,?5,"files we can find. If you enter a ? for the 'from:' prompt the"
 w !,?5,"system display the list of journal files that it can find for"
 w !,?5,"that system."
 w !
 w !,?5,"When all the information has been gathered it will be "
 w !,?5,"displayed and you will be asked to confirm it."
 w !
 s err=0
 f id=1:1:numclu d  q:$G(notresto)
 . w !,"Journal file attributes for cluster member #",id
 . s config=""
 . D ASKSET^JRNRESTO("     Parameter file? ",.config)
 . i config'="" f  q:$$LOADCLUPARAM^JRNRESTC2(config)  d  q:config=""
 . . s config=""
 . . D ASKSET^JRNRESTO("     Parameter file? ",.config)
 . i config="" d
 . . D ASKSET^JRNRESTO("     Journal File Prefix:",.prefix)
 . . d SETCLULOOKPATH^JRNRESTC2 ;ask where to find jrnl files
 . d storejrnpath^JRNRESTC2(id)
 . ; djfirst and djlast are the 1st and last journal files from the
 . ; primary system. We use those dates as the default for the other
 . ; systems but to start with we include all journal files from the
 . ; other systems for those dates.
 . s jfirst=djfirst,$P(jfirst,".",2)="001"
 . i djlast=curfile s jlast=$ZD($H,8)_".999"
 . e  s jlast=djlast,$P(jlast,".",2)="999"
 . k dirlist
 . n defjfirst,jrndir s defjfirst="" i $d(DEJRNSTART) d
 . . s x="" f  s x=$o(clumember(id,"path",x)) q:x=""  s jrndir($zu(12,clumember(id,"path",x)))=""
 . . s x=$$seldjstart^JRNRESTO(.jrndir) i x="" q  ;no suitable journal location to dejournal from
 . . s defjfirst=x,jfirst=$case($ZBITGET($ZVERSION(0),46),0:$case($f($p(DEJRNSTART(x),",",2),";"),0:$e($p(DEJRNSTART(x),",",2),*-8-$l($p($p(DEJRNSTART(x),",",2),".",$l($p(DEJRNSTART(x),",",2),"."))),*-$case($e($p(DEJRNSTART(x),",",2),*)="z",0:0,1:1)),:$e($p(DEJRNSTART(x),",",2),*-8-$l($p($p(DEJRNSTART(x),",",2),".",$l($p(DEJRNSTART(x),",",2),"."))),$f($p(DEJRNSTART(x),",",2),";")-2)),:$p(DEJRNSTART(x),",",2))
 . . d ASKSET^JRNRESTO("The last journal file (in YYYYMMDD.NNN form) to dejournal:",.jlast)
 . i defjfirst="",$$YN("     Do you want to specify the first and last journal files")="Y" d 
 . . d ASKSET^JRNRESTO("     from: ",.jfirst)
 . . i jfirst="?" f  d  q:jfirst'="?"
 . . . d findfiles^JRNRESTC2(id,"","")
 . . . d showhead^JRNRESTC2
 . . . d showfooter^JRNRESTC2($$showone^JRNRESTC2("dirlist"))
 . . . s jfirst=djfirst,$P(jfirst,".",2)="001"
 . . . d ASKSET^JRNRESTO("     from: ",.jfirst)
 . . d ASKSET^JRNRESTO("       to: ",.jlast)
 . ; generate the list of journal files for this cluster member
 . ; if dirlist() is defined then the user entered ? to display the
 . ; journal files for this system so we don't have to call
 . ; findfiles(), we just eliminate the ones they don't want
 . i defjfirst]"" d  i 1
 . . d findfiles^JRNRESTC2(id,jfirst,jlast,$g(DEJRNSTART(defjfirst)))
 . . k DEJRNSTART(defjfirst) ;prevent it from being reused by other systems
 . e  i '$D(dirlist) d findfiles^JRNRESTC2(id,jfirst,jlast) i 1
 . e  d elimfiles^JRNRESTC2(jfirst,jlast)
 . i $D(dirlist) merge clumember(id,"files")=dirlist
 . e  w !,"Warning, no files selected for cluster member #",id
 . i err,$$YN("An error was encountered. Continue")="N" s notresto=1
 ;
 ; Now display the information we have and ask the user to
 ; specify a starting/ending sequence # for the restore and to
 ; confirm the operation.
 ;
 d showdata^JRNRESTC2
 s x=$$YN("Is the above list correct (NO will abort the restore)")
 i x="N" w !!," [Not restored]",! S notresto=1 q
 ;
 ; we could put code here to let them perform simple edits such
 ; as specifying additional journal files or removing journal files
 ; from the restore.
 ;
 ; Run through the list of journal files and calculate the minimum
 ; and maximum cluster mstart times.
 s minclumstart=$ZH("FFFFFFFF"),maxclumstart=0
 f id=0:1:numclu d
 . s index="" f  s index=$O(clumember(id,"files",index)) q:index=""  d
 . . s clumstart=$P(clumember(id,"files",index),"^",9)
 . . i clumstart d  ; ignore clumstart=0
 . . . i clumstart<minclumstart s minclumstart=clumstart
 . . . i clumstart>maxclumstart s maxclumstart=clumstart
 w !!,"Specify the first and last sequence numbers to be used in "
 w !,"selecting records to be restored (these are inclusive). Using "
 w !,"the defaults will restore all sequence numbers in the journal "
 w !,"file(s)." 
 i minclumstart'=maxclumstart d
 . w !,?5,"The journal files you have selected span a cluster shutdown"
 . w !,?5,"and sequence numbers are reset to 0 following a shutdown"
 . w !,?5,"If you specify an ending sequence number it will be applied"
 . w !,?5,"only to journal files from the last time the cluster was"
 . w !,?5,"started and if you specify a beginning sequence number it"
 . w !,?5,"will only be applied to journal files from the first time"
 . w !,?5,"the cluster was started."
 ;
 W !,"Starting sequence number to restore: First => "
 R minseq S minseq=$TR(minseq," ,") s:minseq="" minseq=0
 W !,"Ending sequence number to restore: Last => "
 R maxseq S maxseq=$TR(maxseq," ,") s:maxseq="" maxseq=$ZH("FFFFFFFF")
 ;
 I $$YN("Perform the restore (no to abort)")="N" d
 . w !!," [Not restored]",!
 . S notresto=1
 q
CLUSETUPER ;  Handle unexpected errors and abort restore
 s $ZT=""
 u 0
 s notresto=1  ; abort restore
 w !,"Unexpected error occurred: ",$ZE,!,"[Restore aborted]",!
 d BACK^%ETN ; log the error
 q
 ;-=-=-=-=
GetDir(prompt,defdir,exists,quit) ;ask for a directory, allow defaults
GetDirLoop ; Loop until we get something valid or exit
 s $zt="GetDirE"
 n exist,dir,x
 s exist=+$g(exists,1) ; default is to check if exists
 w !,prompt_": "_$s($g(defdir)'="":$g(defdir)_" => ",1:"") r dir s:dir="" dir=$g(defdir)
 i $$STOP(dir) Set quit=1 Q ""
 i $E(dir)="?" Q dir ;pass-on request for elaboration
 q:exist<0 dir ;exist<0 means don't check valid or exists
 s x=$S(exist:$$ChkDirOrSpecEXISTS(dir),1:$$ChkDirVALID(dir)) 
 i x="" W *7,"  "_$s(exist:"Directory '"_dir_"' does not exist",1:"Invalid directory specification '"_dir_"'") G:exist GetDirLoop d  g:x="N" GetDirLoop
 . s x=$$YN("Use this directory anyway","N")
 i x="^" s quit=1 Quit ""
 q dir
GetDirE S $ZT=""
 i $ze["<INTERRUPT>" q ""
 w !,"Error: "_$ZE
 zquit 1 i $ZT'="" G @$ZT
 q ""
Touch(D)
 q
ChkDirVALID(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,1)
ChkDirEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkDirOrSpecEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,3)
ChkDir(R) N N S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkBad S $ZT="" W !,"<"_$P($P($ZE,"<",2),">")_"> error -- invalid directory"
 Q ""
YN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YN"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"yn","YN") I "^YN"'[R W "  enter Yes or No, please"
 S POP=(R="^") W $E($S(R="N":"No",R="Y":"Yes",1:""),$L(X)+1,3) Q R
STOP(x) S x=$zconvert($E(x,1,4),"U") Q (x["EXIT")!(x["STOP")!(x["QUIT")!(x["HALT")!($E(x)="^")
LJ(x,n) Q ($E(x_$J("",n),1,n)_$E(x,n+1,$L(x))) ;left justify text to n chars
PATRN(X) N q,i,x,c S q=0,x="" F i=1:1:$L(X) S c=$E(X,i) S:c="""" c=c_c DO
 . I "*?&#"'[c S x=x_$S(q:c,1:"1"""_c),q=1 Q  ;simple text -- no pattern
 . S x=x_$E("""",q)_$S(c="&":"1A",c="#":"1N",c="*":".E",1:"1E"),q=0 Q
 S:q x=x_"""" S X=$P($P($P($P(X,"?"),"#"),"&"),"*") Q x ;return ?@x

JRNRESTF^INT^1^67214,47330
JRNRESTF ;Restore Database from Journal Files (Fast!) ;$Change: 7440104 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	; Revision: $Id: //iris/2024.1.3/databases/sys/rtn/journal/jrnrestf.mac#1 $
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/FILEINC.inc#1 $ ($Change: 7440104 $) */
restore(fastrest) ;
 s fastrest=+$g(^SYS("RESTORE","JOURNAL.FAST"),2) i 'fastrest q
 i '$$ClearSwitch10^JRNRESTB() s fastrest=0 q  
 i $g(ZJRNUSE)||$g(ZJRNUSEMARK)||$g(dejrn) s fastrest=1
 i $S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0),$d(clujrn) s fastrest=1
 s savedisablesort=$g(disablesort),disablesort=1
 i $g(restopt)'["0" d getrestopts^JRNRESTB(.restopt,1) s restopt=restopt_"0"
 s shrid=$$InitShare(RestTime,.err) ;defines shrid
 i $g(err)]"" d resterrlog^JRNRESTB(err)
 i shrid<0 s fastrest=0 s:$g(savedisablesort)]"" disablesort=savedisablesort q  
 s statnode=$name(^SYS("RESTORE","JOURNAL",RestTime,"Status"))
 s trannode=$name(^SYS("RESTORE","JOURNAL",RestTime,"transactions"))
 i fastrest=2 {
   s Tempnode=$name(^IRIS.Temp($i(^IRIS.Temp))) s ^|"%SYS"|IRIS.TempNodes($a($zcrc($p($j,":"),9)),$p($j,":"),"gbl",$name(@Tempnode))=$lb($zutil(99),$username,$namespace)
   m @Tempnode@(1)=jrnlist
   m @Tempnode@(2)=JrnFileList
   k jrnlist,JrnFileList 
   j restore2:(:3):10 e  d resterrlog^JRNRESTB("unable to job off restore2") s fastrest=1
 }
 i fastrest=1 d onejobrest^JRNRESTB q  ;onejobrest will call FreeShare() upon exit
 d MONITOR(RestTime)
 m tranopen=@trannode@("open"),badtran=@trannode@("bad")
 q
restore2 ;
 s CHATTY=0 ;a non-interative job
 s srcdir="" f  s srcdir=$o(dejrn(srcdir),1,AllGlo) q:srcdir=""  d:'AllGlo
 . s target=$p(AllGlo,",",2,$l(AllGlo))
 . i target="" s target=srcdir
 . i $g(nomount(target)) k dejrn(srcdir) ;ignore updates to this database
 . e  i '$$mount^JRNRESTB(target) k dejrn(srcdir) ;ignore updates to this database 
 . s targetsfn=$zu(49,target) ;>=0
 . s global="" f  s global=$o(dejrn(srcdir,global)) q:global=""  s gloidx=$zu(78,74,targetsfn,global) 
 d onejobrest^JRNRESTB ;onejobrest will call FreeShare() upon exit
 q
DejrnFile(jrnf,addr,shrid) ;
 s $zt="DejrnFileErr"
 d $zu(78,92,shrid,jrnf)
 s dev=$zu(78,5,jrnf,0,shrid) i dev<0 ztrap "FILE"
 i $zu(78,6,dev)
 i fastrest=1 d DejrnRedirSetup(.dejrn) q dev
 i '$$DejrnRedirSetup(.dejrn) g closejrnf 
 d ##class(%SYS.Journal.System).GetDejournalReaderSettings(.cachesize,.readahead,.disableaio)
 s rc=$zu(78,104,cachesize,1,readahead,disableaio)
 f  s last=$zu(78,47,addr),addr=$p(last,",",2),stat=+last q:stat'>0  d
 . i stat=5 k tranopen($zu(78,10,addr),$ZU(78,25,addr)) i 1
 . e  i stat=4 s pid=$zu(78,10,addr),sys=$ZU(78,25,addr),tranopen(pid,sys)=addr_","_jrnf,tranopen(pid,sys,"cp")=-1 
 s sfnskip=$zu(78,76,shrid,-2)
 s sfn=0 f  {
   s sfn=$f(sfnskip,1,sfn) q:'sfn  ;look for '1's, which indicate bad db's
   s targetdir=$g(mounted(sfn-2)) 
   i targetdir'="",'$g(nomount(targetdir)) { ;the bad db is new
     s nomount(targetdir)=1 k dir(targetdir) 
     i $zu(9,"","[JOURNAL RESTORE] Database "_targetdir_" skipped")
   }
 }
 s jrnend=$zu(78,18,0),lastaddr=$zu(78,18,jrnend)
 i stat<0 {
   s resterr="Abort dejournaling "_jrnf_" on error "_stat
   ztrap "JABORT"
 }
 i 'stat,addr<lastaddr d
 . s resterr="Journal "_$g(jrnf)_" ends unexpectedly at "_addr_" (end expected at "_lastaddr_") - possible corruption in the journal" 
 . ztrap "JEND"
closejrnf ;
 d $zu(78,7,dev) s dev=-1
 i $zu(78,53,shrid,0,0)
 q dev
DejrnFileErr s $zt=""
 d nxterr^JRNRESTB
 g closejrnf
DejrnRedirSetup(redir) ;
 i $g(ALL) q $$DejrnAllSetup()
 n srcdir,info,sfn,cnt,target
 s srcdir="" f  {
   s srcdir=$o(RedirAdd(srcdir),1,sdir) q:srcdir=""
   k redir(sdir) ;sdir and srcdir may not be an item anymore
 }
 k RedirAdd
 s srcdir="",cnt=0 f  {
   s srcdir=$o(redir(srcdir),1,target) q:srcdir=""
   i ($e(srcdir,1,8)=":mirror:") {
     s sfn=$zu(78,31,srcdir_":",2)
   } else {
     s sfn=$zu(78,31,srcdir,1)
   }
   i sfn<0 continue  ;skip directory that is not in journal
   s target=$p(target,",",2,$l(target))
   i target="" s target=srcdir
   i $g(nomount(target))||'$$mount^JRNRESTB(target) k redir(srcdir) continue 
   s info=$zu(49,target) 
   d $zu(78,46,sfn,+info,$p(info,",",13)) 
   s cnt=cnt+1,mounted(+info)=target
   s sdir=$ZU(78,31,sfn) ;as what's to be retrieved from journal record
   i sdir'=srcdir s RedirAdd(srcdir)=sdir
 }
 s srcdir="" f  {
   s srcdir=$o(RedirAdd(srcdir),1,sdir) q:srcdir=""
   m redir(sdir)=redir(srcdir)
 }
 q cnt
DejrnAllSetup() ;restore everything to their original locations
 n sfn,info,target,cnt
 s cnt=0 f sfn=0:1:$zu(40,0,41)-1 s target=$ZU(78,31,sfn) i target]"",'$g(nomount(target)) d
 . i '$$mount^JRNRESTB(target) ;ignore updates to this database 
 . e  s info=$zu(49,target) d $zu(78,46,sfn,+info,$p(info,",",13)) s cnt=cnt+1,mounted(sfn)=target q
 q cnt
InitShare(JrnRestID,err) ;
 n shrid,defpref,prefetch,minpagestouse,freegmhpages,maxpagestouse,pagestouse
 n defquesiz,quesiz,stksiz,flag59,UpdaterPID,numupd
 n rangemax,maxpref,dstdir,dest,srcdir
 s err="",shrid=-1,$zt="InitShareErr"
 s minpagestouse=5 ;one for redir table, two for queue, two for stack
 s freegmhpages=$v($zu(40,2,150),-2,$ZU(40,0,1)) ;# of free gmheap pages
 s maxpagestouse=freegmhpages\2
 i maxpagestouse<minpagestouse s maxpagestouse=minpagestouse
 s pagestouse=maxpagestouse
 s defquesiz=(pagestouse-1)\2 ;in pages
 If ($g(STU)="S")||'$g(disjrn)||($g(restopt)[1) {
   d ##class(%SYS.Journal.System).GetDejournalSettings("jrnrest1","",.prefetch,.quesiz,.stksiz,.sizmod,.numupd,.rangemax,.maxpref)
 } else {
   i '$g(ALL) {
     s srcdir="" f  {
       s srcdir=$o(dejrn(srcdir),1,dest) q:srcdir="" 
       s dstdir=$p(dest,",",2,*)
       i dstdir="" s dstdir=srcdir
       s dest(dstdir)=""
     }
     s numupd=0,dstdir="" f  s dstdir=$o(dest(dstdir)) q:dstdir=""  i $i(numupd)
   }
   d ##class(%SYS.Journal.System).GetDejournalSettings("jrnrest","",.prefetch,.quesiz,.stksiz,.sizmod,.numupd,.rangemax,.maxpref)
 }
 If quesiz<0 Set quesiz=defquesiz
 If stksiz<0 Set stksiz=defquesiz
 Set shrid=$zu(78,50,sizmod,quesiz,stksiz)
 i shrid<0 s err="Error "_shrid_" in allocating memory" q "-2,"_err
 s ^SYS("RESTORE","JOURNAL",JrnRestID,"share")=shrid
 s flag59=$zu(68,59)
 d $zu(78,111,shrid,numupd,rangemax) ;set # of updaters that are actually jobbed off
 s i=0 f  {
   j DejrnSetkill(shrid,i,$g(disjrn),flag59,checkerr,JrnRestID,$d(restopt(1))&&(restopt[1)):(:2):10
   i '$zc {
     i i d $zu(9,"","Unable to job off Update Daemon #"_i)
     q
   }
   s UpdaterPID=$zc
   s ^SYS("RESTORE","JOURNAL",JrnRestID,"setkill",UpdaterPID)=0
   i $i(i)=numupd q  ;done
 }
 i 'i q "-3,Unable to job off Update Daemon"
 d $zu(78,111,shrid,i,rangemax) ;set # of updaters that are actually jobbed off
 i prefetch {
   d $zu(78,70,shrid,prefetch,maxpref) 
   s prefstrategy=$g(^SYS("RESTORE","JOURNAL.FAST","prefetch","strategy"),-10000)
   s rc=$zu(78,90,shrid,prefstrategy) 
   f i=0:1:(prefetch-1) {
     j DejrnDbfetch(shrid,0,flag59):(:2):10 
     i '$zc s err="Unable to job off Prefetching Daemon #"_i
   }
 }
 h 1
 q shrid  
InitShareErr ;
 s $zt=""
 i $ze'["INTERRUPT" d BACK^%ETN s err=$ze,$ze="" 
 i shrid'<0 d FreeShare(JrnRestID)
 q "-9,"_err
FreeShare(JrnRestID,force) ;
 i $g(shrid)'=$g(^SYS("RESTORE","JOURNAL",JrnRestID,"share")) d resterrlog^JRNRESTB("shrid="_$g(shrid)_" not matching "_$g(^SYS("RESTORE","JOURNAL",JrnRestID,"share"))_", the one associated with "_JrnRestID) q
 d FreeTempNode($name(^SYS("RESTORE","JOURNAL",JrnRestID)))
 i '$g(force) d $zu(78,51,-1,0,-1) s shrid=-1,^SYS("RESTORE","JOURNAL",JrnRestID,"share")=-1 q
 q
InitTempNode(IdNode,shrid) ;
 s $zt="InitTempNodeErr"
 n tmpnode,pid,index
 s tmpnode=$g(@IdNode@("TempNode")),pid=$j
 i tmpnode="" {
   s index=$i(^IRIS.Temp),tmpnode=$name(^IRIS.Temp(index))
   s ^|"%SYS"|IRIS.TempNodes($a($zcrc($p($j,":"),9)),$p($j,":"),"gbl",$name(^IRIS.Temp(index)))=$lb($zutil(99),$username,$namespace)
 }
 s @tmpnode=$lb(IdNode,pid)
 i $zu(78,71,shrid,tmpnode)
 q tmpnode
InitTempNodeErr s $zt="" d BACK^%ETN ztrap $ze
FreeTempNode(IdNode) ;
 n tmpnode,pid,shrid
 s $zt="FreeTempNodeErr" 
 s tmpnode=$g(@IdNode@("TempNode")) 
 i tmpnode="" {
   s shrid=$g(@IdNode@("share"),-1) i +shrid'=shrid ztrap "SHARE"
   s tmpnode=$zu(78,71,shrid)
   i tmpnode=""  ;should we log something here??
   e  s pid=$li(@tmpnode,2) k @tmpnode k ^|"%SYS"|IRIS.TempNodes($a($zcrc($p($j,":"),9)),$p($j,":"),"gbl",$name(@tmpnode))
 } else {
   k @tmpnode
 }
 q 1
FreeTempNodeErr s $zt="" d $zu(9,"",$ze,(1>0),1) s $ze="" q 0
DejrnSetkill(shrid,que,disjrn,flag59,checkerr,RestTime,AbortOnDBErr) ;
 s $zt="DejrnSetkillExit" i '($e($roles,1,$l("%All"))="%All") { n $ET,$roles s $ET="",$roles=$roles_","_"%All"} ; Verified 9/26/16 STC
 d $zu(68,59,$g(flag59))
 i $zu(68,1,1)
 i $g(disjrn) d DISABLE^%SYS.NOJRN
 i $zu(78,51,shrid,que,3) 
 f skiprec=0:1 q:'$$DejrnSetkillSub()
DejrnSetkillExit s $zt="^%ETN"
 i $zu(78,53,shrid,0,1)
 i $zu(78,51,-1,0,-1)
 i $ze]"",'$g(zjrnerr) d BACK^%ETN
 q
DejrnSetkillSub() ;
 s $zt="DejrnSetkillErr"
 k adr ;affecting skiprec
 s fastrest=2 ;for skiprec to set adr to fastaddr
 i $zu(78,51,shrid,skiprec,1) 
 q 0 ;exit restore
DejrnSetkillErr s $zt=""
 s querecinf=$zu(78,53,shrid,8) ;sfn,gcol,gref
 s fastaddr=+querecinf
 s targetsfn=+$p(querecinf,",",2)
 s targetdir=$p($zu(49,+targetsfn,3),"^",2) 
 s globcoll=$p(querecinf,",",3)
 s globnodelen=$p(querecinf,",",4)
 s globnodeoff=$p(querecinf,",",5)
 s globnode=$p(querecinf,",",6,$l(querecinf))
 Try {
   s globref="^"_$zu(70,4,$e(globnode,1,*-1),$zu(70,1,globcoll)) 
   s globnam=$qs(globref,0) ;
 } Catch {
   s globref="",globnam=""
 }
 s %jrnfile=$zu(78,111,shrid,-1) ;journal file being applied
 s zesave=$ze ;skiprec clears $ze upon return
 d skiprec^JRNRESTB 
 i $g(AbortOnDBErr) {
   s $ze=zesave
   ztrap $ze
 }
 i $g(nomount(targetdir)),$zu(78,76,shrid,targetsfn)
 q 1 ;not aborting
DejrnDbfetch(shrid,que,flag59) ;
 s $zt="DejrnDbfetchExit"
 d $zu(68,59,$g(flag59))
 i $zu(68,1,1)
 i $zu(78,51,shrid,que,2)
DejrnDbfetchExit s $zt="^%ETN"
 i $zu(78,51,-1,0,-1)
 i $ze]"" d BACK^%ETN
 q
MONITOR(JrnRestID,interval) ;
 s $zt="MONITORerr"
 n JrnRestNode,addrcur,dejrnstat,dup,filepath,filesize,glo,ii
 n jrnfcur,jrnfnum,jrnfprv,rc,sharid
 s jrnfprv="",jrnfnum=0,filesize=0,dejrnstat=0
 s JrnRestNode=$name(^SYS("RESTORE","JOURNAL",JrnRestID))
 s sharid=$g(@JrnRestNode@("share"))
 i sharid<0 {
   w !,"[Journal restore has ended]",!
   q 0
 }
 n erridx d ShowErr(JrnRestID,.erridx)
 n jrnfile,a,tempnode,promptnode,prompt
 n jrnfupd,curjrnfupd ;the journal file being processed by the slowest updater
 s tempnode=$g(@JrnRestNode@("TempNode"))
 i tempnode="" {
   try {
     f  s tempnode=$zu(78,71,sharid) q:tempnode'=""  h .01
   } catch {
     s $ze=""
   }
   i tempnode="" {
     w !,"[Journal restore has ended]",!
     q 0
   }
 }
 s promptnode=$name(@tempnode@("Prompt"))
 s prompt=$g(@promptnode)
 s interval=$g(interval,10)
 for  {
     i $$Stat(sharid,0,.dejrnstat) q  ;restore completed or aborted
     i dejrnstat]"" {
       s jrnfcur=$p(dejrnstat,",",1)
       s addrcur=$p(dejrnstat,",",3)
       i jrnfprv'=jrnfcur {	// dejournaling a different file now
	 i jrnfprv'="" w $j(100,6,2)_"%" ;indicate file completely dejournaled
	 f  {
	   s filepath=$g(@JrnRestNode@("Files",$i(jrnfnum)))
	   i filepath="" q  ;presumably the file being processed
	   s filepath=$zu(12,$p(filepath,","),0)
	   i filepath=jrnfcur q  ;by now jrnfnum matches jrnfcur
	   w !,filepath,!,$j(100,6,2)_"%" ;indicate file completely dejournaled
	 }
         s jrnfupd=$zu(78,111,sharid,-1)
	 i jrnfupd'=$g(curjrnfupd) w !,"Journal file being applied: ",jrnfupd
	 w !,jrnfcur,! 
	 s filesize=$S($ZU(78,22,jrnfcur):$p($zu(78,22,jrnfcur,99),",",31+1),1:-1) 
	 i filesize'>0 d resterrlog^JRNRESTB("Error: file size = "_filesize)
	 s jrnfprv=jrnfcur 
       }
       i filesize>0 w $j(addrcur/filesize*100,6,2)_"% "
     }
     d ShowErr(JrnRestID,.erridx)
     i prompt {
       s a=1 f  {
         i $d(@promptnode@("default")) q
	 i $i(a)>(interval*100) q
	 h .01
       }
       i '$d(@promptnode@("default")) continue  ;no prompt for user
       i jrnfprv'="" w $j(100,6,2)_"%" ;indicate file completely dejournaled
       s jrnfprv=""
       f  {
         s jrnfile=$g(@promptnode@("default"))
         W !!,"Restore From Journal File: ",jrnfile," =>" R a,!
         k @promptnode@("error")
         s @promptnode@("input")=a
         s a=0 f  {
           i $d(@promptnode@("error")) q
           i $i(a)#100=1,$$Stat(sharid,0,.dejrnstat) q  ;restore completed or aborted
           h .01
         }
         i $g(@promptnode@("error"))="" q  ;user input accepted
         W @promptnode@("error"),! ;error message about user input 
       }
       h 1
       continue
     }
     h $g(interval,10)
 }
 i dejrnstat>0 {
   i jrnfprv'="" w $j(100,6,2)_"%" ;indicate file completely dejournaled
   f  s jrnfnum=$o(@JrnRestNode@("Files",jrnfnum),1,filepath) q:jrnfnum=""  w !,$p(filepath,","),!,$j(100,6,2)_"%" ;indicate file completely dejournaled
   w !,"[Journal restore completed at ",dejrnstat,"]",!
   i $d(@JrnRestNode@("DB")) {
     w !,"The following databases have been updated:",!
     s sfn="",cnt=0 f  {
       s sfn=$o(@JrnRestNode@("DB",sfn),1,dir) q:sfn=""  
       w !,$i(cnt),". ",dir
     }
     w !
   } else {
     w !,"No database has been updated",!
   }
   i $d(@JrnRestNode@("SkipDB")) {
     w !,"The following databases have been skipped and should be restored from the respective journal files and on:",!
     s dir="",cnt=0 f  {
       s dir=$o(@JrnRestNode@("SkipDB",dir),1,rc) q:dir=""  
       w !,$i(cnt),". ",dir,", ",$p(rc,",",2,*)
     }
     w !
   }
   d ShowErr(JrnRestID,.erridx)
 } else {
   d resterrlog^JRNRESTB("[Journal restore aborted: "_$p(dejrnstat,",",2,$l(dejrnstat)))
 }
 q dejrnstat ;normal exit: journal restore either completed or aborted
MONITORerr s $zt="" 
 n ze s ze=$ze,$ze="" ;since it is just monitoring, no need to pass $ze up
 i ze["<INTERRUPT>" {
   w !!,"To monitor journal restore progress, ",!,?8,"DO MONITOR^JRNRESTF(""",JrnRestID,""",",$g(interval,10),")",!
   q 0 ;monitoring aborted by user 
 }
 d resterrlog^JRNRESTB("Monitoring aborted on unexpected error "_ze)
 q "0,"_ze ;error exit: abort monitoring on unexpected error
ShowErr(JrnRestID,erridx) ;
 n JrnRestNode,numerr,i,errmsg,ans
 s JrnRestNode=$name(^SYS("RESTORE","JOURNAL",JrnRestID))
 s erridx=+$g(erridx)
 i $g(@JrnRestNode@("Errors"))>erridx {
   w !!,*7,"[*** ERRORS ***]"
   s numerr=@JrnRestNode@("Errors")
   s i=erridx f  {
     s i=$o(@JrnRestNode@("Errors",i),1,errmsg) q:i=""  q:i>numerr
     w !,$j(i,$l(numerr)+1),". ",errmsg
     i i#23=0 {
       r !,"--More-- ['Q' to quit or any other key to continue]",ans
       i "qQ"[$e(ans) q
     }
   }
   s erridx=numerr
   w !!
 }
 q
Stat(sharid,sys,stat) ;
 s $zt="StatErr"
 s stat=$zu(78,53,sharid,1,sys)
 i stat="" {
   s stat=$g(^SYS("RESTORE","JOURNAL",JrnRestID,"Status"))
   i stat q stat ;restore completed or aborted
 }
 q 0
StatErr s $zt=""
 i $ze'["<FUNCTION>" ztrap $ze ;abort on unexpected error or INTERRUPT
 s $ze=""
 s stat=$g(^SYS("RESTORE","JOURNAL",JrnRestID,"Status"))
 i stat q stat ;restore completed or aborted
 s stat="" q 0 ;<FUNCTION> due to other cause
TranslateCount(count) { ;q $$TranslateCount^SHDWSTAT(count)
 i count<10000 q count
 s count=count/1000
 i count<10000 q $j(count,1,4-$l(count\1))_"K"
 s count=count/1000
 i count<10000 q $j(count,1,4-$l(count\1))_"M"
 q $j(count/1000,1,4-$l(count/1000\1))_"G"
}
TranslateSize(bytesize) q $$TranslateSize^SHDWSTAT(bytesize)
TranslateTime(secs) q $$TranslateTime^SHDWSTAT(secs)
TranslateTimeRange(timelo,timehi) q $$TranslateTimeRange^SHDWSTAT(timelo,timehi)
TranslateRate(rate) { ;rate is presumed to have decimal point
 i rate<10000 q $j(rate,1,4-$l(rate\1))_" " ;to avoid mixing with next field
 s rate=rate/1000
 i rate<10000 q $j(rate,1,4-$l(rate\1))_"K"
 s rate=rate/1000
 i rate<10000 q $j(rate,1,4-$l(rate\1))_"M"
 q $j(rate/1000,1,4-$l(rate/1000\1))_"G"
}
SelectDejrnTask() [] public { ;
 s dejrnmax=$zu(78,53) ;max # of dejournaling tasks
 f id=1:1:dejrnmax { ;1-based id for GetMenu()
   s type=$zu(78,53,id-1) ;0-based sharid as input
   i type'="",type'="s" { ;excluding shadow ("s")
     s tasks(id)=$case(type,1:"Mirror CatchupDB",2:"Mirror DejournalProcessFile",3:"Mirror DejournalReader",/*0*/:"Journal Restore")
   }
 }
 i '$d(tasks) w !,"No dejournaling task currently running",! q -1
 s Flag=8+128
 s Prompt="Dejournal Task to Monitor: "
 s id=$o(tasks("")) ;the first (and perhaps the only) one as default
 s Status=##Class(%Library.Prompt).GetMenu(Prompt,.id,.tasks,,Flag)
 i (+Status=0)||(Status=2)||(id="") {
   s $ze="" 
   q -1
 }
 q (id-1) ;converted back to 0-based sharid
}
Monitor(sharid,interval,raw) [] public {
 s $zt="Error"
 i $g(sharid)="" {
   s sharid=$$SelectDejrnTask()
   i sharid<-1 q  ;none running or selected
 }
 i $g(raw) {
   f  {
     s waitstat=$zu(78,68,sharid)
     s gupdstat=$zu(78,73,sharid,2) ;glob stat of updaters
     s grefstat=$zu(78,73,sharid,3) ;glob stat of prefetchers
     s jrnfpath=$p($zu(78,53,sharid,1,0),",")
     s time=$h
     s readstat=$p(waitstat,"^",2,*)
     w !,$zdt(time,3),",",jrnfpath,",",$tr(readstat,"^",","),","
     w $p(gupdstat,","),":",$tr($p(waitstat,";"),",",":")
     s numupds=$l(gupdstat,",") ;# of updaters
     f u=2:1:numupds {
       w ",",$p(gupdstat,",",u),":",$tr($p(waitstat,";",u),",",":")
     }
     w ";",grefstat
     h $g(interval,10)
   }
   q  
 }
 s gcntprv=0,bufhitprv=0,logrdprv=0,lastaddprv=0,findblkprv=0
 s sys=0,dejrnstat=$zu(78,53,sharid,1,sys)
 s jrnfprv=$p(dejrnstat,",",1)
 s queoff0=$p(dejrnstat,",",3),queoffprv=queoff0
 s dejrnstat=$zu(78,53,sharid,4)
 s quecnt0=+dejrnstat,quecntprv=quecnt0
 s updstat=$p(dejrnstat,",",2,*)
 s zhtime0=$zh,(zhtime,zhtimq0)=zhtime0 
 f i=1:1:$l(updstat,",") {
   s appoff0(i)=$p(updstat,",",i),appcnt0(i)=$p(appoff0(i),":",2)
   s appoffprv(i)=appoff0(i),appcntprv(i)=appcnt0(i)
   s zhtima0(i)=zhtime0
 }
 for  {
     w !,$zdt($h,3)
     s gupdstat=$zu(78,73,sharid,2) ;glob stat of updaters
     s numupds=$l(gupdstat,",") 
     s grefstat=$zu(78,73,sharid,3) ;glob stat of prefetchers
     i grefstat="" s numpref=0
     e  s numpref=$l(grefstat,",")
     s perfstat=$zu(78,68,sharid)
     s readwaitcnt=$p(perfstat,"^",3)
     s readwaittim=$p(perfstat,"^",2)/1000 ;converted to sec from msec
     s readwaitmax=$p(perfstat,"^",4)/1000 ;converted to sec from msec
     w !,$j("QueueWaitTime: ",16),"max=",$$TranslateTime(readwaitmax)
     i readwaitcnt w ", avg=",$$TranslateTime(readwaittim/readwaitcnt)," (",readwaittim,"/",readwaitcnt,")"
     s stkswwaitcnt=$p(perfstat,"^",6)
     s stkswwaittim=$p(perfstat,"^",5)/1000 ;converted to sec from msec
     s stkswwaitmax=$p(perfstat,"^",7)/1000 ;converted to sec from msec
     w !,$j("StackWaitTime: ",16),"max=",$$TranslateTime(stkswwaitmax)
     i stkswwaitcnt w ", avg=",$$TranslateTime(stkswwaittim/stkswwaitcnt)," (",stkswwaittim,"/",stkswwaitcnt,")"
     f q=1:1:numupds {
       s updstat=$p(perfstat,";",q)
       s waittim=$p(updstat,",")/1000 ;converted to sec from msec
       s waitmax=$p(updstat,",",2)/1000 ;converted to sec from msec
       s convoycnt=$p(updstat,",",3)
       s convoymax=$p(updstat,",",4)
       s updatecnt=$p(updstat,",",5)
       w !,"UD",q,$j("ConvoySize: ",13),"max=",convoymax
       i convoycnt w ", avg=",$j(updatecnt/convoycnt,0,2)," (",updatecnt,"/",convoycnt,")"
       w !,"UD",q,$j("WaitTime: ",13),"max=",$$TranslateTime(waitmax)
       i convoycnt w ", avg=",$$TranslateTime(waittim/convoycnt)," (",waittim,"/",convoycnt,")"
     }
     s sys=0,dejrnstat=$zu(78,53,sharid,1,sys)
     s jrnfcur=$p(dejrnstat,",",1)
     s queoff=$p(dejrnstat,",",3)
     s dejrnstat=$zu(78,53,sharid,2)
     s sizecur=$p(dejrnstat,",",1)
     s timecur=$p(dejrnstat,",",2)
     i timecur {
       w !,$j("PrvFilesRdRate: ",16)
       w $$TranslateRate(sizecur/timecur),"Bps (",sizecur,"/",timecur,")"
     }
     s quecnt=$zu(78,53,sharid,4)
     s updstat=$p(quecnt,",",2,*),quecnt=+quecnt,numupds=$l(updstat,",")
     s zhtimeprv=zhtime,zhtime=$zh,zhtimeincr=zhtime-zhtimeprv
     i jrnfcur=jrnfprv {
       s queoffincr=queoff-queoffprv,queoffprv=queoff,queoffcumu=queoff-queoff0
     } else {	;file has switched -- reset byte counts and file timer
       s (queoffprv,queoffincr,queoffcumu,queoff0)=queoff
       s zhtimq0=zhtime
       s jrnfprv=jrnfcur
     }
     s zhtimecumu=zhtime-zhtime0,zhtimecumq=zhtime-zhtimq0
     f i=1:1:numupds {
       s appoff(i)=$p(updstat,",",i),appcnt(i)=$p(appoff(i),":",2)
       s appcntincr(i)=appcnt(i)-appcntprv(i),appcntprv(i)=appcnt(i),appcntcumu(i)=appcnt(i)-appcnt0(i)
       s quecntincr=quecnt-quecntprv,quecntprv=quecnt,quecntcumu=quecnt-quecnt0
       s appoff(i)=+appoff(i)
       i appoff(i)>=appoffprv(i) { 
         s appoffincr(i)=appoff(i)-appoffprv(i),appoffprv(i)=appoff(i),appoffcumu(i)=appoff(i)-appoff0(i)
       } else { ;must be processing entries from a different file now
         s (appoffprv(i),appoffincr(i),appoffcumu(i),appoff0(i))=appoff(i)
         s zhtima0(i)=zhtime
       }
       s zhtimecuma(i)=zhtime-zhtima0(i)
     }
     w !,"===== MonRec/",$j(zhtimecumu,1,4-$l(zhtimecumu\1))
     w ?(21-2),"FileByte/",$j(zhtimecumq,1,4-$l(zhtimecumq\1)) ;,"|",$$$FMTNUMDEC5(zhtimecuma(i))
     w ?41,$j("TotRec",10),":+/",$j(zhtimeincr,1,4-$l(zhtimeincr\1))
     w ?61,$case($ZBITGET($ZVERSION(0),46),0:$case($f(jrnfcur,";"),0:$e(jrnfcur,*-8-$l($p(jrnfcur,".",$l(jrnfcur,"."))),*-$case($e(jrnfcur,*)="z",0:0,1:1)),:$e(jrnfcur,*-8-$l($p(jrnfcur,".",$l(jrnfcur,"."))),$f(jrnfcur,";")-2)),:jrnfcur),":+/",$j(zhtimeincr,1,0)
     w !,"RD"
     i 'zhtimecumu w $j(quecntcumu,12),":N/A"
     e  w $j(quecntcumu,12),":",$$TranslateRate(quecntcumu/zhtimecumu)
     i 'zhtimecumq w $j(queoffcumu,12),":N/A"
     e  w ?21,$j(queoffcumu,12),":",$$TranslateRate(queoffcumu/zhtimecumq)
     w ?41,$j(quecnt,12),":",$$TranslateRate(quecntincr/zhtimeincr)
     w ?61,$j(queoff,12),":",$$TranslateRate(queoffincr/zhtimeincr)
     f i=1:1:numupds {
       w !,"UD",i
       i 'zhtimecumu w $j(appcntcumu(i),12),":N/A"
       e  w $j(appcntcumu(i),12),":",$$TranslateRate(appcntcumu(i)/zhtimecumu)
       i 'zhtimecuma(i) w $j(appoffcumu(i),12),":N/A"
       e  w ?21,$j(appoffcumu(i),12),":",$$TranslateRate(appoffcumu(i)/zhtimecuma(i))
       w ?41,$j(appcnt(i),12),":",$$TranslateRate(appcntincr(i)/zhtimeincr)
       w ?61,$j(appoff(i),12),":",$$TranslateRate(appoffincr(i)/zhtimeincr)
     }
     w !,"===== Job# "
     w ?12,$j("+",10),":gcnt"
     w ?29,$j("+",10),":addfnd"
     w ?46,$j("+",10),":logrd"
     w ?63,$j("+",10),":bufhit"
     f q=1:1:numupds {
       s gstat=$p(gupdstat,",",q)
       s jobnum=$p(gstat,":")
       s gcnt=$p(gstat,":",2),gcntinc=gcnt-$g(gcntprv(jobnum)),gcntprv(jobnum)=gcnt
       s bufhit=$p(gstat,":",3),bufhitinc=bufhit-$g(bufhitprv(jobnum)),bufhitprv(jobnum)=bufhit
       s logrd=$p(gstat,":",5),logrdinc=logrd-$g(logrdprv(jobnum)),logrdprv(jobnum)=logrd
       s lastadd=$p(gstat,":",6),lastaddinc=lastadd-$g(lastaddprv(jobnum)),lastaddprv(jobnum)=lastadd
       w !,"UD",q,?6,jobnum
       w ?12,$j(gcntinc,10),":",$$TranslateRate(gcnt)
       w ?29,$j(lastaddinc,10),":",$$TranslateRate(lastadd)
       w ?46,$j(logrdinc,10),":",$$TranslateRate(logrd)
       w ?63,$j(bufhitinc,10),":",$$TranslateRate(bufhit)
     }
     f p=1:1:numpref d
     . s gstat=$p(grefstat,",",p)
     . s jobnum=$p(gstat,":")
     . s gcnt=$p(gstat,":",2),gcntinc=gcnt-$g(gcntprv(jobnum)),gcntprv(jobnum)=gcnt
     . s bufhit=$p(gstat,":",3),bufhitinc=bufhit-$g(bufhitprv(jobnum)),bufhitprv(jobnum)=bufhit
     . s logrd=$p(gstat,":",5),logrdinc=logrd-$g(logrdprv(jobnum)),logrdprv(jobnum)=logrd
     . s findblk=$p(gstat,":",6),findblkinc=findblk-$g(findblkprv(jobnum)),findblkprv(jobnum)=findblk
     . w !,"PD",p,?6,jobnum
     . w ?12,$j(gcntinc,10),":",$$TranslateRate(gcnt)
     . w ?29,$j(findblkinc,10),":",$$TranslateRate(findblk)
     . w ?46,$j(logrdinc,10),":",$$TranslateRate(logrd)
     . w ?63,$j(bufhitinc,10),":",$$TranslateRate(bufhit)
     w !
     h $g(interval,10)
 }
Error s $zt="" 
 i $ze["INTERRUPT" q
 i $zu(78,53,sharid)'="" { ;Has the dejournaling task ended?
   d $zu(9,"","Monitor^JRNRESTF exited on "_$ze) 
   w !,$ze,!
 }
 q
}
STOP(x) S x=$zconvert($E(x,1,4),"U") Q (x["EXIT")!(x["STOP")!(x["QUIT")!(x["HALT")!($E(x)="^")
YN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YN"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"yn","YN") I "^YN"'[R W "  enter Yes or No, please"
 S POP=(R="^") W $E($S(R="N":"No",R="Y":"Yes",1:""),$L(X)+1,3) Q R
YNN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No/Never w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ","Vv"[D:"Never => ",1:"") ;Yes, No, Never, or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YNV"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"ynv","YNV") I "^YNV"'[R W "  enter Yes or No, or V for Never, please"
 S POP=(R="^") W *8,$E($S(R="N":"No",R="Y":"Yes",R="V":"Never",1:""),$L(X),5) Q R
PATRN(X) N q,i,x,c S q=0,x="" F i=1:1:$L(X) S c=$E(X,i) S:c="""" c=c_c DO
 . I "*?&#"'[c S x=x_$S(q:c,1:"1"""_c),q=1 Q  ;simple text -- no pattern
 . S x=x_$E("""",q)_$S(c="&":"1A",c="#":"1N",c="*":".E",1:"1E"),q=0 Q
 S:q x=x_"""" S X=$P($P($P($P(X,"?"),"#"),"&"),"*") Q x ;return ?@x
HasFile(f) Q ''$zu(78,22,f) ;1: file exists 0: not
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/FILEINC.inc#1 $ ($Change: 7440104 $) */
 ; BITWISE.INC
FIXDIR(dir) ;procedure, dir is passed by reference
 Q:dir=""
 Q:$A(dir,$L(dir))=$A($s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""))
 s dir=dir_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")
 Q
fixdir(dir) ;function
 Q:dir="" ""
 Q:$A(dir,$L(dir))=$A($s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")) dir
 Q dir_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")
basename(f) ;similar to basename on UNIX
 Q $P(f,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""),1,$L(f,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""))-1)_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")
appdir(d1,d2) ;use $zu(12,d2) to append d2 to canonic dir
 S d1=d1_d2
 Q d1
VALIDIR(dir) ;validate directory dir and create it if dir doesn't exist
 new flag
 s flag=1
 g vdir2
validir(dir,flag) ;validate directory dir and optionally create it if it
vdir2 ; VALIDIR(dir) comes here with flag set to 1
 quit:$$ChkDirOrSpecEXISTS(dir)'="" 1   ; dir is valid and exists
 quit:$$ChkDirVALID(dir)="" 0    ; dir is not valid
 i flag'=1 q 0  ; flag says don't create, return failure
 new x
 set x=$$mkdir(dir)  ; returns 0 for success, 1 for failure
 q:x=1 0  ; failed to create
 quit:$$ChkDirOrSpecEXISTS(dir)="" 0   ; it doesn't we failed
 q 1  ; success
mkdir(dir) ;create a new directory
 q '##class(%Library.File).CreateDirectoryChain(dir)
jrnshort(jf,short) ;get/set short form of a journal file name FIXME HYY1999
         N (jf,short)
         S len=$L($P(jf,";"))
         Q:$G(short)="" $E(jf,len-11,len) ;"GET" form
         S $E(jf,len-11,len)=short ;"SET" form
         Q jf
GJrnPrefix(jf) ;extract prefix from the journal file name jf
         N (jf)
         S fname=$P(jf,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""),$L(jf,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")))       
         Q $e(fname,1,$l($p(fname,"."))-8)
GetJrnFileName(path) { 
	i $f(path,"/") q $p(path,"/",$l(path,"/")) ;presumably a Unix path
	if $f(path,"\") q $p(path,"\",$l(path,"\")) ;presumably a Windows path
	s vmsfile=$p(path,"]",2) i vmsfile="" q path ;a name only, not a path
	q $p(vmsfile,";") ;return name from a VMS path without trailing ";"
}
dirinvalidmsg(dir1,dir2) 
 n valid1,valid2,cnt,msg
 s valid1=$$VALIDIR(dir1),valid2=$$VALIDIR(dir2)
 s cnt=valid1+valid2 ; cnt = 0 if both invalid, 1 if one is valid
 s msg="The following journaling "
 s:cnt msg=msg_"directory is" 
 s:'cnt msg=msg_"directories are"
 s msg=msg_" not valid"_$C(13,10)
 s:'valid1 msg=msg_"     "_dir1_$C(13,10)
 s:'valid2 msg=msg_"     "_dir2_$C(13,10)
 q msg
ChkDirVALID(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,1)
ChkDirEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkDirOrSpecEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,3)
ChkDir(R) N N S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkBad S $ZT="" W !,"<"_$P($P($ZE,"<",2),">")_"> error -- invalid directory"
 Q ""
ASKSET(prompt,val,backup,help,pattern) ;procedure
 N x,done,def,enahelp,helpavail,backupavail
 s done=0
 s def=$G(val)
 s backup=$G(backup,0) 
 s enabackup=$S(backup=-1:0,1:1)
 s backupavail=$S(backup=1:1,1:0)
 s help=$G(help)
 s enahelp=$S(help="*":0,1:1) ;there might not be any help though
 s helpavail=$s(enahelp&($L(help)!($D(help)>1)):1,1:0)
 if 'enabackup n POP
 s POP=0
 f  d  q:done!POP
 . W !,$G(prompt)
 . w:($X+$L(def))>65 !,?5
 . w:$L(def) " <",def,">"
 . if helpavail!backupavail do
 . . w " [" w:helpavail "?" w:backupavail "^" w "]"
 . w:(($X+$L(def))>75) !,?5
 . W " => " 
 . R x,!
 . if x="^" d  q
 . . if 'enabackup s done=1 q
 . . if backupavail s POP=1 q
 . . w "...backup not available here"
 . if enabackup,x="""^""" s x="^",done=1 q
 . ;
 . if x="?" d  q
 . . if 'enahelp s done=1 q
 . . if 'helpavail w "...help not available here" q
 . . if $D(help)=1 w !?5,help q
 . . s x="" f  s x=$O(help(x)) q:x=""  w !,?5,help(x)
 . . w !
 . if enahelp,x="""?""" s x="?",done=1 q
 . i x]"",$g(pattern)]"",x'?@pattern w !?5,$s(helpavail:help,1:"[bad format]") q
 . s:'$L(x) x=val 
 . s done=1
 s:'POP val=x
 q

JRNRESTO^INT^1^67214,47330
JRNRESTO ;Restore Journal from a File, Part I ;;$Change: 7440104 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	; Revision: $Id: //iris/2024.1.3/databases/sys/rtn/journal/jrnresto.mac#1 $
 ;        
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/FILEINC.inc#1 $ ($Change: 7440104 $) */
 ; %curfile = current journal file if enabled when JRNRESTO called
 ;            else "" if journaling not enabled when called
 ; jrnstop = 1 means we had to disable journaling system-wide
 ;           and it should be reenabled later, else 0
 ; nojrn = 1 means we disabled journaling process-wide with %SYS.NOJRN 
 ;           and should restore it when we exit
     ; normal entry point
     ; fromrest=0  => ask which directories should be restored
 n fromrest
 n clujrn,ZJRNUSE,POP
 n CLURESTORE 
 s fromrest=0
 i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
 W !,"This utility uses the contents of journal files"
 W !,"to bring globals up to date from a backup.",!
 I $$YN("Restore the Journal","Y")="Y" {
	 if $D(^SYS("MIRRORSET")) || $D(^SYS("LASTMIRRORSET")) {
		 if $$YN("Catch-up mirrored databases","N")="Y" {
			 do MirrorCatchup()
			 quit
		 }
	 }
	 g INT
 }
 q
     ;
     ; INT
     ; entrypoint from DBREST database restore utility
     ; fromrest=1  => use directories listed in +dejrn(dir)=1
     ;         =2  => all directories
     ;         =3  => ask which directories should be restored
INT n CHATTY
 s CHATTY=1 ; Q&A dialog is allowed
 n zsvalsav s zsvalsav=$zstorage
 s $zstorage=2**31-1 ;max value
 try {
   d 
   . n zsvalsav
   . d main^JRNRESTB
 } catch {
   d $zu(9,"","[JOURNAL RESTORE] "_$ze)
   w !,"[JOURNAL RESTORE] ",$ze,!
 }
 s $zstorage=zsvalsav
 q
     ;
     ;
     ; STU
     ; entrypoint used by STU to just restore from the journal
     ;   address stored in .IMJ file
     ;  It doesn't rollback open transactions
     ;                                                       [JO1666+]
     ;  noterm is set when this is invoked from STURECOV. This tells
     ;  jrnerrhand to return rather than terminating with $ZU(4)
     ;                                                       [JO1666-]
STU n fromrest,stu,nojrn
 n checkerr,%jrnfile,index
 n clu,adr,type,ALL,a,ZJRNUSE
 i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
 new i
 n CLURESTORE 
 s ZJRNUSE=0  ; Do not use journal filter if called from STU
 ;checkerr=2 means collect error data in errlist and stop restoring
 ;a database when it throws more than errmax errors.
 s checkerr=2 ; ******** set to 0 when debugging
 N r,dir,cd,glo,gnode,dirnam,nomount,global,canonic
 i checkerr s $zt="studone"
   ; see if .IMJ indicates there's anything to restore
 s a=$zu(78,21)
 s %jrnfile=$p(a,",",2)
 s index=+$P(a,",",1) 
 i %jrnfile="" {
 	 k ^%SYS("JOURNAL","WIJFILE")
	 if '$D(^SYS("SHUTDOWN","JRNCLEAN"),a) {
	 	if $p(a,",",3) {
	          d $zu(9,"","JRNSTOP override, journal restore not required at startup",(0>0),0) 
		} else {
		  ; When errlist is non-zero, STUCNFG will not allow logins.
		  s a="WIJ does not contain journaling information and system does not appear to have shutdown normally"
		  s errlist=$i(errlist)
		  s r=$i(errlist("other"))
		  s errlist("other",r)=a
		  do $zu(9,"",a,(1>0),1)
		}
	 } else {
		s a=$P(a,"^",2)  ;$ztimestamp_"^"_facility
		if a="SHUTDOWN" {
	       d $zu(9,"","Graceful system shutdown, journal restore not required",(0>0),0) 
		} elseif a="CLURECOV" {
	       d $zu(9,"","System recovered during cluster recovery, journal restore not required",(0>0),0)
		} else {
		   ;currently the other choice is a="STURECOV" where the user has
		   ;declared that its ok to start the system
	       d $zu(9,"",a_" override, journal restore not required at startup",(0>0),0) 
		}
	 }
	 q  ;return to STU
 }
 n jrnfcnt s jrnfcnt=$p(a,",",3)
 s ^%SYS("JOURNAL","WIJFILE")=%jrnfile_","_jrnfcnt_","_$p($zu(78,22,%jrnfile,99),",",10+1)
 q:'index  ; nothing to do
   ; open the file and backup to the previous address
 d open
 if adr<0 {
	if ('$D(^SYS("SHUTDOWN","JRNCLEAN"),a)) {
		s a="Missing journal file listed in the WIJ and system does not appear to have shutdown normally"
		s errlist=$i(errlist)
		s r=$i(errlist("other"))
		s errlist("other",r)=a
		do $zu(9,"",a,(1>0),1)
	} else {
		s a=$P(a,"^",2)  ;$ztimestamp_"^"_facility
		if a="SHUTDOWN" {
	       d $zu(9,"","Graceful system shutdown, journal restore not required",(0>0),0) 
		} else {
		   ;currently the other choice is a="STURECOV" where the user has
		   ;declared that its ok to start the system
	       d $zu(9,"",a_" override, journal restore not required at startup",(0>0),0) 
		}
	}
 quit
 }
 n nullsubstat s nullsubstat=$zu(68,1,1)
 n RestTime s RestTime=$zdt($h,8)
 i checkerr s $zt="stuclose"
 s adr=$zu(78,18,index)
    ; also disable journaling (probably isn't even started yet)
 s nojrn=$$STOP^%SYS.NOJRN()
 s ALL=1 ; all directories
   ; open journal file stored in .IMJ
   ; find next record to restore and restore it
 N file,jrnfile 
 n disablesort s disablesort=1
 n shrid ;if set, use fast dejournaling instead of sorting and multi-daemon
 n fastrest ;
 i checkerr s $ze="",$zt="sturestdone"
 s fastrest=+$g(^SYS("RESTORE","JOURNAL.FAST"),2) 
 i fastrest d 
 . n err s shrid=$$InitShare^JRNRESTF(RestTime,.err) ;defines shrid
 . i $g(err)]"" d $zu(9,"",err,(2>0),2) 
 . i shrid<0 s fastrest=0
 . e  d 
 . . s disablesort=1 i $zu(78,51,shrid,0,0) ;fastrest=1 or 2
 . . s tempnode=$$InitTempNode^JRNRESTF($name(^SYS("RESTORE","JOURNAL",RestTime)),shrid)
 ; Job off a process which will report on the progress of the
 ; journal restore if it takes a substantial amount of 
 ; time (minutes).
 S ^SYS("JOURNAL","MONITOR",$J)=""  ;Uses our PID for the global node
 j stumonitor(RestTime,$s(fastrest=2:shrid,1:-1))::5 
 s monpid=$S($T:$ZChild,1:0) 
 f i=1:1:5 q:$G(^SYS("JOURNAL","MONITOR",$J))="RUNNING"  h 1
 if $G(^SYS("JOURNAL","MONITOR",$J))'="RUNNING" do $ZU(9,"","Journal restore monitor failed to start after 5 seconds",0)
 n jrnend,prevend ;for comparing journal ends to detect journal corruption
 n sturestzemsg ;supplemental info for <Z*> error, to be logged in sturestdone
 k ^SYS("STUJRNERRLIST") 
 F  D  Q:%jrnfile=""  d open i adr<0 s sturestzemsg="Failed to open "_%jrnfile ztrap "FILE" 
 . S jrnfile=$case($ZBITGET($ZVERSION(0),46),0:$case($f(%jrnfile,";"),0:$e(%jrnfile,*-8-$l($p(%jrnfile,".",$l(%jrnfile,"."))),*-$case($e(%jrnfile,*)="z",0:0,1:1)),:$e(%jrnfile,*-8-$l($p(%jrnfile,".",$l(%jrnfile,"."))),$f(%jrnfile,";")-2)),:%jrnfile)
 . n i,rc s i=$i(^SYS("RESTORE","JOURNAL",RestTime,"Files"))
 . s ^SYS("RESTORE","JOURNAL",RestTime,"Files",i)=%jrnfile
 . s:adr ^SYS("RESTORE","JOURNAL",RestTime,"Files",i,"StartAddress")=adr
 . d $zu(9,"","Restoring from journal "_%jrnfile,(0>0),0)
 . s jrnend=$zu(78,18,0) ;for comparison below
 . s lastaddr=$zu(78,18,jrnend)
 . i adr<lastaddr d
 . . i fastrest d
 . . . d $zu(78,7,clu) s clu=-1 
 . . . s clu=$$DejrnFile^JRNRESTF(%jrnfile,adr,shrid) 
 . . i fastrest<2 d
 . . . d STURestore^JRNRESTB
 . . . s rc=$zu(78,7,clu),clu=-1 ;done dejournaling %jrnfile
 . e  s rc=$zu(78,7,clu),clu=-1 ;done dejournaling %jrnfile
 . s rc=0,file=%jrnfile,%jrnfile=$$NEXTJRN0^JRNUTIL(file,,,.rc)
 . i rc<0 s sturestzemsg=rc ztrap "FILE"
 . i %jrnfile="" q
 . s prevend=$p($zu(78,22,%jrnfile,99),",",11+1)
 . i prevend,prevend>jrnend s sturestzemsg="Inconsistency in "_file_": The last reachable journal record ends @ offset "_jrnend_", different from the journal end offset "_prevend ztrap "JEND"
 . i $i(jrnfcnt) ;journal file count of the new %jrnfile, which is NOT ""!!
 s ^%SYS("JOURNAL","WIJFILE")=file_","_jrnfcnt_","_jrnend
sturestdone s $zt="" i $ze]"" d sturesterrlog($ze_","_$g(sturestzemsg))
 i $g(fastrest) {
   i $zu(78,49,shrid)<0 d sturesterrlog("Failed to restore all updates")
   d FreeShare^JRNRESTF(RestTime)
 }
 m errlist("db")=^SYS("STUJRNERRLIST","db")
 s i="" f  {
   s i=$o(^SYS("STUJRNERRLIST","all",i),1,a)
   i i="" q
   s errlist("all",$i(errlist))=a
 }
 d sortflush^JRNRESTB()  ;should we abort sorting on error instead of flushing to db's??
 k ^SYS("JOURNAL","MONITOR",$J)  ;Shut down monitor
 I $G(^%SYS("JOURNAL","LAST"))="" S ^%SYS("JOURNAL","LAST")="1^"_$G(file)
 E  S $P(^%SYS("JOURNAL","LAST"),"^",2)=$G(file)
 i nojrn d ENABLE^%SYS.NOJRN
stuclose ;
 s $zt="" i $zu(68,1,nullsubstat)  ;restore null subscript setting
 i clu'<0 s a=$zu(78,7,clu)
studone q
sturesterrlog(msg) ;add an error to errlist and log it in messages.log
 i $i(errlist)
 s msg=$g(msg),errlist("other",$i(errlist("other")))=msg
 d $zu(9,"",msg,(2>0),2)
 q
CLUMENU	;
	;Entry point to display a menu of cluster journal restore
	;options. These turn into different "fromrest" values and then
	;call INT^JRNRESTO. These are not needed on a non-clustered
	;system because the journal restores are not as complicated.
	n menu,opt,fromrest,notresto,maxopt,POP,resp,restdate
	n LastRestoreTime,node,CLSTATE,dir,BACKH,CLUBACKUP,DEJRNSTART,dejrn
	n %00000,ALLGLO,DIR,QUIETMODE,R,X,jinfo
	n clujrn,ZJRNUSE,POP
   n CLURESTORE 
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
menudisp	;
	w !!,"Cluster Journal Restore Menu"
	w !,"--------------------------------------------------------------"
	w !,"1) Cluster journal restore after backup restore"
	w !,"2) Cluster journal restore corresponding to Cache backups"
	w !,"3) ADVANCED: Cluster journal restore"
	w !,"4) Generate common journal file from specific journal files"
	w !,"--------------------------------------------------------------"
	w !,"H) Display Help"
	w !,"E) Exit this utility"
	w !,"--------------------------------------------------------------"
	s maxopt=4
	;
	w !!,"Enter choice (1-",maxopt,") or [E]xit/[H]elp? "
	r resp
	; "^" also exits and "?" also displays help
	if "^Ee"[$E(resp_"x") w !,"Exiting" q
	if "?Hh"[$E(resp_"x") d menuusage g menudisp
	s opt=+resp
	if (opt'=resp)!(opt<1)!(opt>maxopt) d  g menudisp
	. w !,*7,"Invalid choice - ",resp
	. w !,"Choose an option from 1 to ",maxopt," or enter E to exit or"
	. w " H for help"
	;
	s notresto=0
	s POP=0   ;TCS004, set means redisplay menu, clear means we're done
	if opt=1 d backrestore    ;jrn restore following backup restore
	if opt=2 d postbackup   ;jrn restore following backup
	if opt=3 s fromrest=0,CLURESTORE=1 d INT
	if opt=4 d clujconvert   ;cluster JCONVERT
	g:POP menudisp  ;TCS004
	q
menuusage	;
	n resp
	w !,"--------------------------------------------------------------"
	w !,"This entry point exists for compatability with prior versions. The"
	w !,"functionality here can also be accessed by running either ^JCONVERT"
	w !,"to create a common format journal file or ^JRNRESTO to perform a"
	w !,"cluster journal restore."
	w !
	w !,"In all options you will be asked to describe the databases to be retored,"
	w !,"if you wish to redirect them to another directory and globals to process."
	w !!,"Option 1: This is used to restore the journal files after restoring a"
	w !,?5,"Cache backup. This is the same as the restore performed by ^DBREST after"
	w !,?5,"the backup is restored. It starts with the markers recorded in the "
	w !,?5,"journal files by the backup and ends with the end of the journal data."
	w !,?5,"Note: There are no other Start/Stop options with this choice."
	w !,"Option 2: This is used to restore the journal files using the journal"
	w !,?5,"markers added by a Cache backup to specify the starting point and"
	w !,?5,"ends with the end of the journal data."
	w !,?5,"Note: The user is allowed to specify which backup to use as a Starting"
	w !,?5,"point, but is not allowed to change the Stop point."
	w !,"Option 3: CAUTION: This is an ADVANCED USER OPTION."
	w !,?5,"It is the same as running ^JRNRESTO and saying YES for cluster journal"
	w !,?5,"restore. You will be asked to specify the starting and ending points"
	w !,?5,"of the restore. The starting and ending points can be based on a backup,"
	w !,?5,"on a set of journal markers, at a cluster start or any arbitrary point"
	w !,?5,"in the journal."
	w !,"Option 4: This option does not restore the journal files.  Instead it"
	w !,?5,"produces a common format journal file that can be read with ^JREAD"
	w !,?5,"on a Cache system which does not support cluster journal restores"
	w !,?5,"or on another platform such as DSM. ^JCONVERT provides the same"
	w !,?5,"functionality if you say YES to the Cluster Journal Convert question."
	w !,?5,"Note: You will be asked to provide starting and ending points."
	r !!,"Press <enter> continue",resp
	q
backrestore ;
	; option 1 = journal restore after backup restore
	w !!,"Cluster journal restore following a Cache backup restore"
	w !,"---------------------------------------------------------"
	if $o(^SYS("RESTORE","BACKUP",""),-1)="" d  S POP=1 q
	. w !,"No backups have been restored on this system"
	s QUIETMODE=0,CLURESTORE=1,fromrest=7 
	d INT^JRNRESTO
	q
postbackup ;
	; option 2 = journal restore after backup restore
	w !!,"Cluster journal restore based on Cache backup"
	w !,"---------------------------------------------------------"
	s QUIETMODE=0,CLURESTORE=1,fromrest=6
	d INT^JRNRESTO
	q
clujconvert	;
	new   ;main^JCONVERT does an argumentless new
	s fromrest=8,CLURESTORE=1 
	d INT^JCONVERT
	q
 ; input:
 ;       jrnstop,%curfile,curfile
 ; output:
 ;       nojrn,djfirst,djlast,prompt,curdir,altdir,prefix,notresto 
SETUPOLD ;
 n helptext,pattern
 s helptext="Enter a file name in YYYYMMDD.NNN format, e.g., 20041231.001"
 s pattern="8N1"".""3.10N0.1""z"""
 S djlast=$ZU(78,3),djfirst="" n jrndir,x
 i $d(DEJRNSTART) d  g:djfirst]"" askprompt  ;dejournal after having restored DBs from a backup...
 . i +$g(DEJRNSTART) d  i 1  ;non-cluster restore
 . . w !,"The earliest journal entry since the backup was made is at" 
 . . w !,"offset ",+DEJRNSTART," in ",$p(DEJRNSTART,",",2),!
 . . i $$YN("Do you want to start from that location","Y")="N" k DEJRNSTART q
 . . s FirstFile=$p(DEJRNSTART,",",2)
 . . s djfirst=$case($ZBITGET($ZVERSION(0),46),0:$case($f($p(DEJRNSTART,",",2),";"),0:$e($p(DEJRNSTART,",",2),*-8-$l($p($p(DEJRNSTART,",",2),".",$l($p(DEJRNSTART,",",2),"."))),*-$case($e($p(DEJRNSTART,",",2),*)="z",0:0,1:1)),:$e($p(DEJRNSTART,",",2),*-8-$l($p($p(DEJRNSTART,",",2),".",$l($p(DEJRNSTART,",",2),"."))),$f($p(DEJRNSTART,",",2),";")-2)),:$p(DEJRNSTART,",",2))
 . e  d  ; cluster journal restore (on primary system)
 . . s jrndir($$basename(djlast))="" ;directory in canonical form
 . . s x=$$seldjstart(.jrndir) i x="" q
 . . s DEJRNSTART=DEJRNSTART(x) k DEJRNSTART(x) 
 . . s FirstFile=$p(DEJRNSTART,",",2)
 . . s djfirst=$case($ZBITGET($ZVERSION(0),46),0:$case($f($p(DEJRNSTART,",",2),";"),0:$e($p(DEJRNSTART,",",2),*-8-$l($p($p(DEJRNSTART,",",2),".",$l($p(DEJRNSTART,",",2),"."))),*-$case($e($p(DEJRNSTART,",",2),*)="z",0:0,1:1)),:$e($p(DEJRNSTART,",",2),*-8-$l($p($p(DEJRNSTART,",",2),".",$l($p(DEJRNSTART,",",2),"."))),$f($p(DEJRNSTART,",",2),";")-2)),:$p(DEJRNSTART,",",2))
 . i djfirst="" q 
 . s LastFile=djlast
 . s (x,djlast)=$case($ZBITGET($ZVERSION(0),46),0:$case($f(djlast,";"),0:$e(djlast,*-8-$l($p(djlast,".",$l(djlast,"."))),*-$case($e(djlast,*)="z",0:0,1:1)),:$e(djlast,*-8-$l($p(djlast,".",$l(djlast,"."))),$f(djlast,";")-2)),:djlast)
 . d ASKSET("Final file to process (name in YYYYMMDD.NNN format):",.x,,helptext,pattern)
 . i '(($p(x,".")>$p(djlast,"."))||(($p(x,".")=$p(djlast,"."))&&(+$p(x,".",2)>+$p(djlast,".",2)))) s djlast=x
 . e  w !,"The journal file name is out of range; reset to current journal file ",djlast,!
 W !,"Specify range of files to process (names in YYYYMMDD.NNN format)",!
 S djlast=$ZU(78,3),djfirst=djlast 
 I $$GSTARTJRN(.djfirst) ;don't care about the status 
 S djlast=$case($ZBITGET($ZVERSION(0),46),0:$case($f(djlast,";"),0:$e(djlast,*-8-$l($p(djlast,".",$l(djlast,"."))),*-$case($e(djlast,*)="z",0:0,1:1)),:$e(djlast,*-8-$l($p(djlast,".",$l(djlast,"."))),$f(djlast,";")-2)),:djlast),djfirst=$case($ZBITGET($ZVERSION(0),46),0:$case($f(djfirst,";"),0:$e(djfirst,*-8-$l($p(djfirst,".",$l(djfirst,"."))),*-$case($e(djfirst,*)="z",0:0,1:1)),:$e(djfirst,*-8-$l($p(djfirst,".",$l(djfirst,"."))),$f(djfirst,";")-2)),:djfirst)
 D ASKSET("from:    ",.djfirst,,helptext,pattern)
 D ASKSET("through: ",.djlast,,helptext,pattern)
 i djlast="^" f  q:djlast'="^"  d
 . s djlast=$ZU(78,3),djfirst=djlast,djlast=$case($ZBITGET($ZVERSION(0),46),0:$case($f(djlast,";"),0:$e(djlast,*-8-$l($p(djlast,".",$l(djlast,"."))),*-$case($e(djlast,*)="z",0:0,1:1)),:$e(djlast,*-8-$l($p(djlast,".",$l(djlast,"."))),$f(djlast,";")-2)),:djlast)
 . i $$GSTARTJRN(.djfirst)
 . s djfirst=$case($ZBITGET($ZVERSION(0),46),0:$case($f(djfirst,";"),0:$e(djfirst,*-8-$l($p(djfirst,".",$l(djfirst,"."))),*-$case($e(djfirst,*)="z",0:0,1:1)),:$e(djfirst,*-8-$l($p(djfirst,".",$l(djfirst,"."))),$f(djfirst,";")-2)),:djfirst)
 . D ASKSET("from: ",.djfirst,,helptext,pattern)
 . D ASKSET("through: ",.djlast,,helptext,pattern)
askprompt ;
 i $d(clujrn) s prompt=0  ; don't ask for cluster restores
 S prefix=$G(^%SYS("JOURNAL","PREFIX"))
 S curdir=$G(^%SYS("JOURNAL","CURDIR"))
 S altdir=$G(^%SYS("JOURNAL","ALTDIR"))        
 i curdir'="" s curdir=$ZU(12,curdir)
 i altdir'="" s altdir=$ZU(12,altdir)
 i curdir=altdir s altdir=""
 W !!,"Provide or confirm the following configuration settings:",!
 s x="Journal File Prefix:"
 i prefix'="" s x=x_" (. for none)"
 s prefixhelp="Enter an alphanumeric string ('_' allowed) or . to reset prefix to null"
 D ASKSET(x,.prefix,0,prefixhelp)
 i prefix="." s prefix=""  ; no journal file prefix
 D SETLOOKPATH ;ask where to find journal files
 q
SETUP ;set up initial parameters
 S $ZT="etSETUP"
 ; if SETUP^JRNRESTC returns with $d(clujrn)=0, run private journal restore
 i $S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0),$D(clujrn) d SETUP^JRNRESTC q:$g(notresto)  q:$d(clujrn)
 n FirstFile,LastFile
 d GetJrnList
 i '$d(JrnFileList) d SETUPOLD i 1
 e  i ($g(FirstFile)="")||($g(LastFile)="") w !!," [Not restored]",! S notresto=1 q
 e  s djfirst=$case($ZBITGET($ZVERSION(0),46),0:$case($f(FirstFile,";"),0:$e(FirstFile,*-8-$l($p(FirstFile,".",$l(FirstFile,"."))),*-$case($e(FirstFile,*)="z",0:0,1:1)),:$e(FirstFile,*-8-$l($p(FirstFile,".",$l(FirstFile,"."))),$f(FirstFile,";")-2)),:FirstFile),djlast=$case($ZBITGET($ZVERSION(0),46),0:$case($f(LastFile,";"),0:$e(LastFile,*-8-$l($p(LastFile,".",$l(LastFile,"."))),*-$case($e(LastFile,*)="z",0:0,1:1)),:$e(LastFile,*-8-$l($p(LastFile,".",$l(LastFile,"."))),$f(LastFile,";")-2)),:LastFile)
 s prompt=($$YN("Prompt for name of the next file to process","N")="Y")
 i '$$CheckInput() w !!," [Not restored]",! S notresto=1 q
 ; For clusters call GETCLUINFO^JRNRESTC to get the list of journal
 ; files from the other cluster members that we need to restore.
 ; See GETCLUINFO for documentation on the data is returned.
 ;
 i $S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0),$D(clujrn) d  q:$G(notresto)
 . d CLUSETUP^JRNRESTD
 if fromrest=8 g SKIPSTOPJRN  ;JCONVERT doesn't require that you switch/stop journaling
 i curfile="" w !!,"Journaling is NOT on. Updates will NOT be journaled" q
 i 'LocalJrn d AskJrnUpdate q
 i $g(LastFile)]"" { 
   i LastFile'=$zu(78,3) d AskJrnUpdate q  ;long form
 } else { ;from SETUPOLD
   i (($p(curfile,".")>$p(djlast,"."))||(($p(curfile,".")=$p(djlast,"."))&&(+$p(curfile,".",2)>+$p(djlast,".",2)))) d AskJrnUpdate q  ;short form
 }
 ; 
 ; If the restore includes the current journal file we need to either
 ; switch or stop journaling so that the restore eventually completes.
 W !,"The journal restore includes the current journal file."
 w !,"You cannot do that unless you stop journaling or switch"
 w !,"     journaling to another file."
 i $$YN("Do you want to switch journaling","Y")="Y" d  i a d AskJrnUpdate q
 . s ROLLJRN=1,a=$zu(78,1,"","","",0,5)
 . i 'a w !,"[Jounal switched failed]" q
 . w !,"Journaling switched to ",$P($zu(78,4)_","_$zu(78,3),",",2)
 I $$YN("Do you want to stop journaling system wide","Y")="N" D  Q
 . w !!," [Not restored]",!
 . S notresto=1
 s ROLLJRN=1,jrnstop=1,a=$zu(78,2,1)
 w !!,"Journaling is NOT on. Updates will NOT be journaled" q
SKIPSTOPJRN ;JO1726
 Q
etSETUP ;
 S $ZT=""
 i $ze'["INTERRUPT" W !,"Error occurs: ",$ZE,!
 w !!," [Not restored]",!
 s notresto=1
 Q   
 ;ask user whether to disable journaling and set nojrn=1 if YES
AskJrnUpdate ;
 n x
 w !!,"You may disable journaling of updates for faster restore for all"
 w !,"databases other than mirrored databases. You may not want to do this"
 w !,"if a database to restore is being shadowed as the shadow will not"
 w !,"receive the updates."
 s x=$$YN("Do you want to disable journaling the updates","Y")
 s disjrn=(x="Y")
 i x="Y",$$CURRENT^%SYS.NOJRN() d DISABLE^%SYS.NOJRN s nojrn=1
 i '$$CURRENT^%SYS.NOJRN() d 
 . w:x="N" !,"Journaling not enabled for the job."
 . w !,"Updates will NOT be journaled"
 . s nojrn=1
 e  d
 . w:x="Y" !,"Unable to disable journaling for the job."
 . w !,"Updates will be journaled (subject to other common conditions)"
 . s nojrn=0
 q
seldjstart(dir) ;
 n d,x,match,y
 s (x,match)="" w ! 
 w !,"The earliest journal entry since the backup was made might be at one of" 
 w !,"the following journal locations, with the most likely candidate (could "
 w !,"be none) given as the default:",! 
 f  s x=$o(DEJRNSTART(x)) q:x=""  d
 . w x,": ","offset "_+DEJRNSTART(x)_" in "_$p(DEJRNSTART(x),",",2),! q:match]""
 . s d="",y=$$basename($p(DEJRNSTART(x),",",2)) f  s d=$o(dir(d)) q:d=""  q:y=d
 . i d]"" s match=x
 f  s x=match d ASKSET("From the list above select (by number) a journal location to dejournal from "_$c(13,10)_"or hit ENTER to accept the default or type 'N' to choose none:",.x) q:x=""  q:$d(DEJRNSTART(x))#10  i x="N"!(x="n") s x="" q
 i x]"" w !,"You have chosen to start dejournaling at ","offset "_+DEJRNSTART(x)_" in "_$p(DEJRNSTART(x),",",2),! 
 q x 
RemovePurgedFiles() [JrnDirList, JrnFileList] {
 i $d(JrnDirList) {	;non-native journal files in specified directories
   i $o(JrnFileList(""),-1,LastPath)
   i $f(LastPath,"/") s delimiter="/" ;Unix
   e  i $f(LastPath,"\") s delimiter="\" ;Windows
   e  s delimiter="]" ;VMS
   s i="",n=0,b=$zh f  {
     s i=$o(JrnFileList(i),1,jrnf) q:i=""
     s filename=$p($p(jrnf,delimiter,*),";") ;VMS file name may contain a trailing ";"
     s j="" f  {
       s j=$o(JrnDirList(j),1,jrndir) q:j=""
       i $ZU(78,22,jrndir_filename) q  ;jrnf exists
     }
     i j'="" q  ;jrnf exists
     k JrnFileList(i) ;remove nonexistent file from the display list
     i i#1000=0,$zh-b>2 w:'n !,"...collecting a list of journal files.." w "." s b=$zh,n=1
   }
 } else {	;native journal files in their original directories
   s i="",n=0,b=$zh f  {
     s i=$o(JrnFileList(i),1,jrnf) q:i=""
     i $ZU(78,22,jrnf) q  ;jrnf exists
     k JrnFileList(i) ;remove nonexistent file from the display list
     i i#1000=0,$zh-b>2 w:'n !,"...collecting a list of journal files.." w "." s b=$zh,n=1
   }
 }
 i $o(JrnFileList(""))=1 q  ;none removed
 s oldi="",newi=0 f  {
   s oldi=$o(JrnFileList(oldi)) q:oldi=""
   s JrnFileList($i(newi))=JrnFileList(oldi)
 }
 s JrnFileList=newi ;updated # of journal files on the list
 s oldi=newi f  {
   s oldi=$o(JrnFileList(oldi)) q:oldi=""
   k JrnFileList(oldi)
 }
}
GetJrnList ;
 n JrnLogPath,Flag,Prompt,Status,zeofset,i
 s LocalJrn=($$YN^JRNRESTO("Are journal files created by this InterSystems IRIS instance and located"_$c(13,10)_"in their original paths? (Uses journal.log to locate journals)")="Y")
 s $zt="GetJrnListErr1" n jrnf,logline,loglocked ;1 if log file is locked
 i LocalJrn {
   s JrnLogPath=$zu(12)_"journal.log"
   d $zu(78,79,0,1,0) ;log file locked (must be released upon exit)
   s loglocked=1
 } else {
   w !,"If you have a copy of the journal history log file from the Cache or IRIS"
   w !,"instance where the journal files were created, enter its full path below;" 
   w !,"otherwise, press ENTER and continue."
   s Flag=8 
   s Prompt="Journal history log: "
   s Status=##Class(%Library.Prompt).GetString(Prompt,.JrnLogPath,,,,Flag)
   i (+Status=0)||(Status=2)||(JrnLogPath="") q 0
   d GetJrnDirs
 }
 o JrnLogPath:("r":/IOT="UTF8"):0 i '$t {
   i $g(loglocked) d $zu(78,79,0,0,0)
   s Status="failed to open journal log "_JrnLogPath
   d logmsg^JRNRESTB(Status,0,1) ;a warning, as we will try an alternative way
   q
 }
 n mirrorlog
 s mirrorlog=$s($zcvt(JrnLogPath,"U")["MIRRORJRN-":1,1:0)
 s Status=##class(%SYS.Journal.System).GetHistoryHeader(JrnLogPath,,mirrorlog) ;skip header
 i 'Status {
   c JrnLogPath
   i $g(loglocked) d $zu(78,79,0,0,0)
   d logmsg^JRNRESTB("failed to read journal log header:"_Status,0,1) ;a warning
   q 
 }
 s zeofset=$zu(68,40,1)
 k JrnFileList s JrnFileList=0 ;# of journal files
 f  {
    u JrnLogPath r logline 
    i $ZEOF { ;end of log
      i $g(loglocked) d $zu(78,79,0,0,0)
      d:'zeofset $zu(68,40,0) k zeofset ;restore original $ZEOF mode
      c JrnLogPath
      q  
    }
    i ($tr(logline,$c(13,10))="") continue  ;skip blank lines
    s JrnFileList($i(JrnFileList))=$p(logline,",",$s(mirrorlog:1,1:2))
 }
 i '$d(JrnFileList) q 0
 s $zt="GetJrnListErr2"
 i +$g(DEJRNSTART) {  ;dejournal after having restored DBs from a backup...
   w !,"The earliest journal entry since the backup was made is at" 
   w !,"offset ",+DEJRNSTART," in ",$p(DEJRNSTART,",",2),!
   i $$YN("Do you want to start from that location","Y")="N" {
     k DEJRNSTART
   } else {
     s FirstFile=$p(DEJRNSTART,",",2)
     s PriorList="",i="" f  s i=$o(JrnFileList(i)) q:i=""  q:JrnFileList(i)=FirstFile  s PriorList(i)=JrnFileList(i) k JrnFileList(i)
     i i="" {
       w !,FirstFile," is NOT in journal history log ",JrnLogPath
       w !,"You might have specified a wrong journal history log"
       q
     }
   }
   w !,"Enter ? for a list of journal files to select the final file from"
 } 
 i '$g(DEJRNSTART) {  ;
   w !,"Specify range of files to process",!
   d RemovePurgedFiles w !
   w "Enter ? for a list of journal files to select the first and last files from"
   s Flag=8+64
   s Prompt="First file to process: "
   s Status=##Class(%Library.Prompt).GetArray(Prompt,.FirstFile,.JrnFileList,,,,Flag)
   i (+Status=0)||(Status=2)||(FirstFile="") s $ze="" q 0
   s PriorList="",i="" f  s i=$o(JrnFileList(i),1,jrnf) q:i=""  q:jrnf=FirstFile  s PriorList(i)=JrnFileList(i) k JrnFileList(i)
 }
 s Flag=8+64
 s Prompt="Final file to process: "
 i $o(JrnFileList(""),-1,LastFile) ;process up to the last file by default
 n JrnFileArray,j s i="" f j=1:1 s i=$o(JrnFileList(i)) q:i=""  s JrnFileArray(j)=JrnFileList(i)
 s Status=##Class(%Library.Prompt).GetArray(Prompt,.LastFile,.JrnFileArray,,,,Flag)
 i (+Status=0)||(Status=2)||(LastFile="") s $ze="" q 0
 s i="" f  s i=$o(JrnFileList(i),-1,jrnf) q:i=""  q:jrnf=LastFile  k JrnFileList(i)
 q
GetJrnListErr1 s $zt="GetJrnListErr2"
 i $g(loglocked) d $zu(78,79,0,0,0)
 i $g(zeofset)]"" d $zu(68,40,zeofset) ;restore original $ZEOF mode
 i $g(JrnLogPath)]"" c JrnLogPath 
GetJrnListErr2 s $zt="" zt $ze
GetJrnDirs ;replacing SETLOOKPATH
 w !!,"Specify the location of the journal files to be processed"
 s Flag=8+512
 s Prompt="Directory of the journal files: "
 n JrnDirPath
 f {
   s JrnDirPath=""
   s Status=##Class(%Library.Prompt).GetString(Prompt,.JrnDirPath,,,,,Flag)
   i (+Status=0)||(Status=2)||(JrnDirPath="") q
   s JrnDirPath=$zu(12,JrnDirPath,2)
   i JrnDirPath="" w !,"directory is invalid or doesn't exist"
   e  s JrnDirList($i(JrnDirList))=JrnDirPath
 }
 w !
 q
 ; input: lookpath, curdir, altdir
SETLOOKPATH ;set look path in which dejournaled files are searched for
 N x
 K lookpath S lookpath=0
 i curdir="",altdir="" g askdirs
 w !,"Files to dejournal will be looked for in: "
 i curdir]"" s lookpath($i(lookpath))=curdir w !?5,curdir
 i altdir]"",altdir'=curdir s lookpath($i(lookpath))=altdir w !?5,altdir
 w !,"in addition to any directories you are going to specify below, UNLESS"
 w !,"you enter a minus sign ('-' without quotes) at the prompt below," 
 w !,"in which case ONLY directories given subsequently will be searched",!
askdirs ;
 F  R !,"Directory to search: <return when done> ",x Q:x=""  D
 . i x="-" k lookpath s lookpath=0 w !?5,"[Directory search list is emptied]" q
 . D FIXDIR(.x) s lookpath($i(lookpath))=x
 i 'lookpath w !,*7,"** WARNING ** Directory search list must NOT be empty",! g askdirs
 w !,"Here is a list of directories in the order they will be searched for files:"
 s x="" f  s x=$o(lookpath(x)) q:x=""  w !?5,lookpath(x)
 Q
 ; return values may have several meanings:
 ;   if jf or some file preceding it is illegal or does not exist
 ;   on disk, we return the last one that is still on disk
 ; return value is stored in parameter and status is returned
GSTARTJRN(jf) ;get the starting jrn file that eventually runs down to jf
 n p
 F  S p=$ZU(78,22,jf,1) Q:+p'=1  S p=$P(p,",",2) Q:p=""  S jf=p
 Q $S(p'="":0,1:1) 
   ; nextquiet
   ; This subroutine is used to for non-interactive restore from
   ; journal file. Used only by non-interactive DBREST right now.
nextquiet() 
 ; Use user-suppied journal file if any, else look for default
 ; or current journal file
 s %jrnfile=restjrn
 s:%jrnfile="" %jrnfile=$P($G(^%SYS("JOURNAL","DEFAULT")),"^",2,999)
 s:%jrnfile="" %jrnfile=%curfile
 i %jrnfile="" q -6
 s %jrnfile=$ZU(12,%jrnfile,0)  ; canonic name
 d open i adr=-1 w !,"Journal file can't be opened",! q -6
 I %curfile=%jrnfile,'jrnstop d
 .  W !,"You are attempting to restore from the current journal file."
 .  w !,"Journaling will be disabled temporarily.",!
 .  s jrnstop=1,a=$zu(78,2,1) q
 ; If journaling is currently occurring, these journal entries
 ; will be added to the current journal
 s jrnfile=$case($ZBITGET($ZVERSION(0),46),0:$case($f(%jrnfile,";"),0:$e(%jrnfile,*-8-$l($p(%jrnfile,".",$l(%jrnfile,"."))),*-$case($e(%jrnfile,*)="z",0:0,1:1)),:$e(%jrnfile,*-8-$l($p(%jrnfile,".",$l(%jrnfile,"."))),$f(%jrnfile,";")-2)),:%jrnfile)
 s fastrest=0
 d begin^JRNRESTB ;HYY073
 q 1
open i checkerr s $zt="openend"
 s clu=$zu(78,5,%jrnfile,0)
 i clu<0 d $zu(9,"","[ERROR OPENING JOURNAL FILE "_%jrnfile_" ]",(1>0),1) s adr=-1 q
 s a=$zu(78,6,clu),adr=0
 q
openend S $ZT="" s adr=-1 q
close I checkerr S $ZT="etclose"
 S a=$zu(78,7,clu)
 Q
etclose S adr=-1 Q
gui(restjrn,dirs) ;gui entry point
 New (restjrn,dirs)
 Set $ze="",$zt="guiErr"
 i '$SYSTEM.Security.Check("%Admin_Manage","USE") Quit 0_$c(22,35,1)_"Operation requires %Admin_Manage:Use privilege"
 Set QUIETMODE=1,fromrest=1
 For i=1:1 Set dir=$p(dirs,$c(22,35,1),i) Quit:dir=""  Set dejrn(dir)=1
 d main^JRNRESTB
 Quit 1
guiErr Quit 0_$c(22,35,1)_"Unable to dejournal."_$s($ZE'="":$c(13,10)_"$ze="_$ZE,1:"")
stumonitor(JrnRestID,shrid) ;
 ; This is jobbed off during STU journal restore to watch the
 ; restore and periodically report the progress. This routine
 ; exits when the restore is no longer running. This depends on knowing
 ; the names of the variables in the JRNRESTB loop, %jrnfile is the full
 ; journal file name and adr is the current record address.
 ; 
 n parent,sleep,jfile,adr,origsleep
 s parent=$ZParent
 S ^SYS("JOURNAL","MONITOR",parent)="RUNNING"
 s sleep=$G(^SYS("JOURNAL","MONITOR","INTERVAL"),300)
 if sleep<=0 {
	 do $ZU(9,"","Journal restore monitor not running per-user request."_$s(($zversion(1)=2):$c(13,10),1:$c(10))_"^SYS(""JOURNAL"",""MONITOR"",""INTERVAL"") set to "_sleep)
	 quit
 }
 if sleep<30 {
	 ; 30 seconds is pretty frequent for the monitor to report. We don't
	 ; want it to report too often (the default is 5 minutes) as writing
	 ; to the console log too often can slow down journal restore.
	 s origsleep=sleep
	 s sleep=30
 }
 s $zt="stumonerr"
 ; Wait one interval before doing anything. If the journal restore
 ; is done at that point, just exit
 h sleep
 q:$G(^SYS("JOURNAL","MONITOR",parent))'="RUNNING"
 do $ZU(9,"","Monitoring journal restore process pid "_parent)
 if $G(origsleep) do $zu(9,"","Monitor interval increased from "_origsleep_" seconds to "_sleep_" seconds",0)
 while ($G(^SYS("JOURNAL","MONITOR",parent))="RUNNING") {
	 if (shrid<0) {
	   s jfile=$ZU(88,2,parent,"%jrnfile")
	   s adr=$ZU(88,2,parent,"adr")
	 } elseif $$Stat^JRNRESTF(shrid,0,.dejrnstat) {
	   q  ;restore completed or aborted
	 } else {
           s jfile=$p(dejrnstat,",",1)
           s adr=$p(dejrnstat,",",3)
	 }
	 if $L(jfile),$L(adr) {
	    do $ZU(9,"","Journal restore progress."_$s(($zversion(1)=2):$c(13,10),1:$c(10))_"     File: "_jfile_" Address: "_adr,0)
	 }
	 h sleep
 }
 do $ZU(9,"","Journal restore monitor exiting",0)
 quit
stumonerr ;
 s $zt=""
 ; nojob errors can occur if the parent exits. This is ok unless
 ; we haven't been told to exit.
 if ($ZE'["<NOJOB")!($G(^SYS("JOURNAL","MONITOR",parent))="RUNNING") {
    do $ZU(9,"","Journal restore monitor encountered unexpected error: "_$ZE,0)
    d BACK^%ETN
 }
 q
 ;
CheckInput() ;
 s $zt="CheckInputErr"
 w !!,"The following actions will be performed if you answer YES below:",!
 w !,"* Listing journal files in the order they will be processed"
 w !,"* Checking for any missing journal file on the list (""a broken chain"")"
 w !!,"The basic assumption is that the files to be processed are all"
 w !,"currently accessible. If that is not the case, e.g., if you plan to" 
 w !,"load journal files from tapes on demand, you should answer NO below."
 k jrnlist
 i $$YN("Check for missing journal files",$s($g(prompt):"N",1:"Y"))="N" {
   i $d(JrnFileList) {
     i '$d(JrnDirList) {
       m jrnlist=JrnFileList
       s jrnlist="" ;important to nextfile
     } else {
       k lookpath
       m lookpath=JrnDirList
       s JrnFileList="" ;important to nextfile
     }
   }
   q 1 
 }
 n rc,num,i,j,fname,fpath,status,jrnf,jrndir,currend,jrninfo
 i $d(JrnFileList) {
   s rc=1,num=0 ;need to re-numbering the files
   w !!,"Journal files in the order they will be processed:"
   i '$d(JrnDirList) {
     s num=0,i="" f  {
       s i=$o(JrnFileList(i),1,jrnf) q:i=""
       s status=$zu(78,22,jrnf,99) ;=status,hdrinfo
       i status>0 {
         w !,$i(num),". ",jrnf s jrnlist(i)=jrnf
	 s jrninfo(i)=$p(status,",",2,$l(status))
       } else {
         w !,"*** Missing journal file ",jrnf,! s rc=0
       }
     }
   } else {
     s num=0,i="" f  {
       s i=$o(JrnFileList(i),1,jrnf) q:i=""
       s fname=$$GFILE^SHDWCBLK(jrnf) ;jrnf may have come from a different OS
       s j="" f  {
         s j=$o(JrnDirList(j),1,jrndir) q:j=""
	 s fpath=jrndir_fname
	 s status=$zu(78,22,fpath,99) ;=status,hdrinfo
	 i status>0 {
	   s jrnlist(i)=fpath  
	   s jrninfo(i)=$p(status,",",2,$l(status))
	   q  ;found the file
	 }
       }
       i $g(jrnlist(i))="" w !,"*** Missing journal file ",fname,! s rc=0
       e  w !,$i(num),". ",jrnlist(i)
     }
   }
 } else {
   s rc=$$ShowJournalRange(.jrnlist,djfirst,djlast,.jrninfo)
 }
 i 'rc d  i ($$yesno^JRNRESTB("Do you want to abort","Y")="Y") q 0 ;abort
 . w !!,"There is one or more problems with the chain of journal files"
 . w !,"If you decide to continue, journal restore will skip missing files"
 s jrnlist="" ;important to nextfile
 w !!,"While the actual journal restore will detect a journal integrity problem"
 w !,"when running into it, you have the option to check the integrity now"
 w !,"before performing the journal restore. The integrity checker works by"
 w !,"scanning journal files, which may take a while depending on file sizes."
 n scan,num,path,jrnsrcdir
 s scan=($$YN("Check journal integrity","N")="Y") 
 s jrnsrcdir='ALL ;ALL=1 <=> jrnsrcdir=0 (disable collecting journal databases)
 n curguid
 s num="" for  {
   s num=$o(jrnlist(num)) q:num=""
   s path=$g(jrnlist(num)) i path="" k jrnlist(num) q  ;should not happen with ShowJournalRange()
   s currend=$p(jrninfo(num),",",10)
   i 'currend,$g(jrnlist(num+1))]"" {
     s curguid=$p(jrninfo(num),",",7)
     i curguid'="" {
       i curguid=$p(jrninfo(num+1),",",6) {
         s currend=$p(jrninfo(num+1),",",11)
       }
     } else { ;curguid="", an unlikely scenario
       s jrnf=$p(jrninfo(num+1),",",1)
       i $$GetJrnFileName(jrnf)=$p(path,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""),$l(path,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""))) {
         s currend=$p(jrninfo(num+1),",",11)
       }
     }
   }
   i '$$CheckJournalFile(path,currend,scan,.jrnsrcdir),($$yesno^JRNRESTB("Do you want to abort","Y")="Y") q
 }
 i num]"" q 0 ;abort
 i scan w !!,"No error was found in the journal files",!
 n dir,err s dir="" f  s dir=$o(dejrn(dir)) q:dir=""  i '$d(jrnsrcdir(dir)) w !,"***WARNING*** ",dir,!,?8,"A specified source database is not in journal files - check its spelling" i $i(err)
 i $g(err) w !,"There are warnings about selected source databases" i ($$yesno^JRNRESTB("Do you want to abort","Y")="Y") q 0
 q 1
CheckInputErr s $zt="" d BACK^%ETN w !,$ze,! 
 i ($$yesno^JRNRESTB("Do you want to abort","Y")="Y") k jrnlist q 0
 q 1
ShowJournalRange(files,from,upto,fileinfo) [lookpath, prefix] {
 w !!,"Journal files in the order they will be processed:"
 s name=from,path=$$FULLPATH^JRNRESTB(name),prevname="",rc=0 ;error return by default
 for  {
   i path="" {
     i $g(findnexterr)'="" d logmsg^JRNRESTB(findnexterr,0,2) q
     i $$FULLPATH^JRNRESTB(name)="" d logmsg^JRNRESTB("Missing file "_prefix_name,0,2) q
     i prevname=name d logmsg^JRNRESTB("Error locating the file following "_prefix_prevname,0,2) q
     d logmsg^JRNRESTB("Missing file(s) between '"_prefix_prevname_"' and '"_prefix_name_"' ",0,2) 
     q
   }
   s files($i(files))=path
   s info=$zu(78,22,path,99),fileinfo(files)=$p(info,",",2,$l(info))
   w !,files,". ",path
   i name=upto s rc=1 q  ;Done - the only successful exit of the for-loop
   k findnexterr s prevname=name,path=$$FINDNEXT^JRNRESTB(.name,.findnexterr)
   i (($p(name,".")>$p(upto,"."))||(($p(name,".")=$p(upto,"."))&&(+$p(name,".",2)>+$p(upto,".",2)))) d logmsg^JRNRESTB("Missing file following "_prefix_prevname,0,2) q
 }
 q rc
}
GetJournalRange(files,from,upto,lookpath) public {
 s $zt="GetJournalRangeErr"
 s diri="" f  {
   s diri=$o(lookpath(diri),1,jdir) q:diri=""
   s path=$zse(jdir_"*.*") f  {
     i path="" q
     s bare=$case($ZBITGET($ZVERSION(0),46),0:$case($f(path,";"),0:$e(path,*-8-$l($p(path,".",$l(path,"."))),*-$case($e(path,*)="z",0:0,1:1)),:$e(path,*-8-$l($p(path,".",$l(path,"."))),$f(path,";")-2)),:path) i bare'?8N1"."3.10N0.1"z" { ;not a journal name
       s path=$zse("")
       continue 
     }
     s info=$zu(78,22,path,99) i info'>0 { ;not a journal file
       s path=$zse("")
       continue 
     }
     s path=$zu(12,path) 
     s pref=$$GJrnPrefix(path) ;prefix if any (could be "")
	 s:$E(path,*)="z" $e(path,*)=""
     s ^||ISC.JrnRestFile(pref_bare,diri)=path
     i pref'="" s ^||ISC.JrnRestFile(bare,diri,pref)=path
     s info=$p(info,",",2,$l(info)),guid=$p(info,",",7)
     s ^||ISC.JrnRestInfo(path)=info
     i guid'="" s ^||ISC.JrnRestGUID(guid)=path
     s path=$zse("")
   }
 }
 s status=$$GetJrnFilePath(from,.frompath,.fromname,.fromguid)
 i 'status q status
 s frompref=$$GJrnPrefix(fromname)
 s status=$$GetJrnFilePath(upto,.path,.currname,.guid)
 i 'status q status
 k files s files(-$i(files))=path ;going backwards
getprev ;
 i currname=fromname {
   k ^||ISC.JrnRestFile
   q 1 ;Done!
 }
 s info=^||ISC.JrnRestInfo(path)
 s prev=$p(info,",",1) ;full path of previous file (could be "")
 i prev'="" { ;there is a backward pointer to the previous file
   s guid=$p(info,",",6)
   i guid="" { ;journal files of older versions have no GUID fields
     s prevname=$$GetJrnFileName(prev) ;prevname includes prefix if there is one
     s status=$$GetJrnFilePath(prevname,.path,.currname,.guid)
     i 'status q status
   } else {
     s path=$g(^||ISC.JrnRestGUID(guid))
     i $g(path)="" q $$Error^%apiOBJ(8400,guid)
     s currname=$$GetJrnFileName(path) ;currname includes prefix if there is one
   }
   s files(-$i(files))=path ;going backwards
   g getprev
 }
 s bare=$case($ZBITGET($ZVERSION(0),46),0:$case($f(currname,";"),0:$e(currname,*-8-$l($p(currname,".",$l(currname,"."))),*-$case($e(currname,*)="z",0:0,1:1)),:$e(currname,*-8-$l($p(currname,".",$l(currname,"."))),$f(currname,";")-2)),:currname) ;name without prefix
 s pref=$$GJrnPrefix(currname)
 s seq=$p(bare,",",2)
 i seq>1 {
   s prevseq=$s((seq)<101:$e((seq)-1+1000,2,4),1:(seq)-1)
   s $p(bare,".",2)=prevseq
   s name1=pref_bare
   k path1 s diri1=$o(^||ISC.JrnRestFile(name1,""),1,path1)
   k path2 i pref'=frompref {
     s name2=frompref_bare
     s diri2=$o(^||ISC.JrnRestFile(name2,""),1,path2)
   }
   i $g(path1)="" {
     i $g(path2)="" {
       i pref=frompref q $$Error^%apiOBJ(8405,currname)
       e  q $$Error^%apiOBJ(8406,currname,frompref)
     }
     s path=path2,currname=name2,diri=diri2
   } elseif $g(path2)="" { ;path1'=""
     s path=path1,currname=name1,diri=diri1
   } else { ;path1'="",path2'="" (path1'=path2 because pref=frompref => path2="")
     q $$Error^%apiOBJ(8403,bare)
   }
   i $o(^||ISC.JrnRestFile(currname,diri))'="" q $$Error^%apiOBJ(8403,currname)
   s info=^||ISC.JrnRestInfo(path)
   s guid=$p(info,",",7)
   s files(-$i(files))=path ;going backwards
   g getprev  
 }
 s name1=currname
 k path1 s prev1=$o(^||ISC.JrnRestFile(name1))
 i prev1'="",$$GJrnPrefix(prev1)=pref { ;the only place where path1 is set
   s diri="" f  {
     s diri=$o(^||ISC.JrnRestFile(prev1,diri),1,path1) q:diri=""  
     i path1'="" q
   }
 }
 k path2 i frompref'=pref {
   s name2=frompref_bare
   s prev2=$o(^||ISC.JrnRestFile(name2))
   i prev2'="",$$GJrnPrefix(prev2)=pref { ;the only place where path2 is set
     s diri="" f  {
       s diri=$o(^||ISC.JrnRestFile(prev2,diri),1,path2) q:diri=""  
       i path2'="" q
     }
   }
 }
 i $g(path1)="" {
   i $g(path2)="" {
     i pref=frompref q $$Error^%apiOBJ(8405,currname)
     e  q $$Error^%apiOBJ(8406,currname,frompref)
   }
   s path=path2,currname=prev2,diri=diri2
 } elseif $g(path2)="" { ;path1'=""
   s path=path1,currname=prev1,diri=diri1
 } else { ;path1'="",path2'="" (path1'=path2 because pref=frompref => path2="")
   s bare1=$case($ZBITGET($ZVERSION(0),46),0:$case($f(prev1,";"),0:$e(prev1,*-8-$l($p(prev1,".",$l(prev1,"."))),*-$case($e(prev1,*)="z",0:0,1:1)),:$e(prev1,*-8-$l($p(prev1,".",$l(prev1,"."))),$f(prev1,";")-2)),:prev1)
   s bare2=$case($ZBITGET($ZVERSION(0),46),0:$case($f(prev2,";"),0:$e(prev2,*-8-$l($p(prev2,".",$l(prev2,"."))),*-$case($e(prev2,*)="z",0:0,1:1)),:$e(prev2,*-8-$l($p(prev2,".",$l(prev2,"."))),$f(prev2,";")-2)),:prev2)
   i pref=frompref {
     s path=path1,currname=prev1,diri=diri1
   } elseif (($p(bare1,".")>$p(bare2,"."))||(($p(bare1,".")=$p(bare2,"."))&&(+$p(bare1,".",2)>+$p(bare2,".",2)))) {
     s path=path1,currname=prev1,diri=diri1
   } elseif (($p(bare2,".")>$p(bare1,"."))||(($p(bare2,".")=$p(bare1,"."))&&(+$p(bare2,".",2)>+$p(bare1,".",2)))) {
     s path=path2,currname=prev2,diri=diri2
   } else {
     q $$Error^%apiOBJ(8403,bare1)
   }
 }
 i $o(^||ISC.JrnRestFile(currname,diri))'="" q $$Error^%apiOBJ(8403,currname)
 s info=^||ISC.JrnRestInfo(path)
 s guid=$p(info,",",7)
 s files(-$i(files))=path ;going backwards
 g getprev  
GetJournalRangeErr s $zt="" q $$Error^%apiOBJ(5002,$ze)
}
GetJrnFilePath(spec,path,name,guid) {
 s $zt="GetJrnFilePathErr"
 s bare=$case($ZBITGET($ZVERSION(0),46),0:$case($f(spec,";"),0:$e(spec,*-8-$l($p(spec,".",$l(spec,"."))),*-$case($e(spec,*)="z",0:0,1:1)),:$e(spec,*-8-$l($p(spec,".",$l(spec,"."))),$f(spec,";")-2)),:spec) 
 i bare'?8N1"."3.10N0.1"z" { ;'spec' must be a GUID
   s guid=$zcvt(spec,"U")
   s path=$g(^||ISC.JrnRestGUID(guid))
   i path="" q $$Error^%apiOBJ(8400,guid)
   s name=$$GetJrnFileName(path)
   q 1 ;spec is a GUID
 }
 s name=$$GetJrnFileName(spec)
 i name'=spec { ;'spec' is a path (local or remote), not necessarily canonic
   s path=$zu(12,spec)
   i path'="",$d(^||ISC.JrnRestInfo(path)) { ;a local path
     s name=$$GetJrnFileName(path) ;set it to canonic form (mainly the prefix)
     s info=^||ISC.JrnRestInfo(path)
     s guid=$p(info,",",7)
     q 1 ;'spec' is a path
   }
 }
 i name'=bare { ;'spec' is a full name with a non-null prefix 
   i ($zversion(1)=2) s name=$zcvt(name,"L")
   k path s diri=$o(^||ISC.JrnRestFile(name,""),1,path)
   i $g(path)="" q $$Error^%apiOBJ(8401,name)
   i $o(^||ISC.JrnRestFile(name,diri))'="" q $$Error^%apiOBJ(8403,name)
   s info=^||ISC.JrnRestInfo(path)
   s guid=$p(info,",",7)
   q 1 ;'spec' is a full name
 }
 s cnt=0,diri="" f  {
   s diri=$o(^||ISC.JrnRestFile(name,diri),1,path) 
   i diri="" q
   i $i(cnt)
   i $g(path)'="" q
 }
 i 'cnt q $$Error^%apiOBJ(8401,name)
 i $g(path)'="" {
   s info=^||ISC.JrnRestInfo(path)
   s guid=$p(info,",",7)
   q 1 ;'spec' is a full name (with null prefix)
 }
 i cnt>1 q $$Error^%apiOBJ(8403,name) ;'name' in multiple directories
 s diri=$o(^||ISC.JrnRestFile(bare,"")) ;diri'="" given cnt=1
 s pref=$o(^||ISC.JrnRestFile(bare,diri,""),1,path)
 i $g(path)="" q $$Error^%apiOBJ(8402,bare,$g(lookpath(diri)))
 i $o(^||ISC.JrnRestFile(bare,diri,pref))'="" q $$Error^%apiOBJ(8404,bare,$g(lookpath(diri)))
 s name=pref_bare
 s info=^||ISC.JrnRestInfo(path)
 s guid=$p(info,",",7)
 q 1 ;'spec' is a bare name
GetJrnFilePathErr s $zt="" q $$Error^%apiOBJ(5002,$ze)
}
CheckJournalFile(path,jrnend,scan,jrnsrcdir,quietly) ;
 q ##class(%SYS.Journal.File).CheckIntegrityOne(path,scan,jrnend,.jrnsrcdir,$g(quietly))
MirrorCatchup() PUBLIC {
	s $ZT="err"
	s curjrnfile=$zu(78,3)
	if curjrnfile="" {
		w !,"Journaling must be initialized to run catchup on mirrored databases"
		r !,"Ok to start journaling now? ",resp
		while "YyNn"'[$E(resp_"X") {
			w !,"Please answer yes or no"
			r !,"Ok to start journaling now? ",resp
		}
		if "Nn"[$E(resp_"X") {
			w !,"Not started - catch-up aborted"
			quit
		}
		d ^JRNSTART		
	}
	s cls=##Class(Config.MirrorMember).Open()
	s HasMirrorConfig=(cls.SystemName'="")
	s cls=""
	if 'HasMirrorConfig {
		s rc=##class(%Library.File).Delete($zu(12)_"mirrorjrn-*.log")
		w !,"This system is not configured for mirror, you need to specify"
		w !,"the location of the mirror journal files to be restored to the"
		w !,"mirrored databases."
		w !,"A null string location indicates the journal path of the local system."
		r !,"Mirror journal files location? ",loc
		s:loc'="" loc=$lb(loc)
	} elseif $SYSTEM.Mirror.GetInfo()'["DEFINED" {
		w !,"The mirror definition needs to be loaded in order to run"
		w !,"mirror database catch up"
		r !,"Ok to load mirror configuration from .cpf file? ",resp
		while "YyNn"'[$E(resp_"X") {
			w !,"Please answer yes or no"
			r !,"Ok to load mirror configuration from .cpf file? ",resp
		}
		if "Nn"[$E(resp_"X") {
			w !,"Not loaded - catch-up aborted"
			quit
		}
		s rc=##class(Config.MirrorMember).Load()
		if $SYSTEM.Mirror.GetInfo()'["DEFINED" {
			s txt="Failed to load mirror definition"
			if ('rc) {
				s txt=txt_": "
				Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
				For i=1:1:err s:i>1 txt=txt_", " s txt=txt_err(i)
			}
			w !,txt
			quit
		}
		For i=0:1:($v($zu(40,2,176),-2,4)-1) {
			Set x=$Zutil(49,i,3)
			if +x'=0 continue ;A remote server
			Set dir=$zu(12,$Piece(x,"^",2))
			If dir'="" {
				s info=$ZU(49,dir)
				s Mirrored=$Case($zb(+$p(info,",",17),$zu(40,8,28),1),0:0,:1)
				if Mirrored {
					w !,?5,"remounting mirrored database: ",dir
					s x=$ZU(3,dir)
					s x=$ZU(17,dir)
				}
			}
		}
	}
	/* Build a list of mirrored databsaes which require catchup */
	For i=0:1:($v($zu(40,2,176),-2,4)-1) {
		Set x=$Zutil(49,i,3)
		if +x'=0 continue ;A remote server
		Set dir=$zu(12,$Piece(x,"^",2))
		If dir'="" {
			do addMirroredDir(dir,.dblist,HasMirrorConfig)
		}
	}
	/* Since we may not have run STU, check the databases in the config
	   as well */
	try {
		s rs=##class(%Library.ResultSet).%New("Config.Databases:List")
		if $isobject(rs), rs.Execute() {
			while (rs.Next()) {
				s sys=rs.Data("Server")
				if sys="" {
					s dir=rs.Data("Directory")
					s dir=$ZU(12,dir)
					If dir'="" {
						do addMirroredDir(dir,.dblist,HasMirrorConfig)
					}
				}
			}
		}
		s rs=""
	} catch {
		; Ignore problems running the query if STU hasn't run yet
	}
	w !,"Specify the list of mirrored databases you want to catch-up."
	k catchuplist
	for  {
		w !,"Enter database"
		w:$D(dblist) ", * for all, ? for a list"
		w " or <return> to end list? "
		read resp
		q:resp=""
		if resp="?" {
			if '$D(dblist) {
				w !,"Could not find any mirrored databases which require catch-up"
				continue
			}
			w !,"The following mirrored databases appear to need catch-up"
			s dir=""
			for  {
				s dir=$O(dblist(dir))
				q:dir=""
				w !,?5,dir
			}
			continue
		}
		if resp="*" {
			merge catchuplist=dblist
			k dblist  ;these are already accounted for
			continue
		}
		; validate user's choice
		s dir=$ZU(12,resp)
		if dir=""  {
			w !,"Unknown directory :",dir
			continue
		}
		s info=$ZU(49,dir)
		if info<0 {
			do $ZU(17,dir)  ;in case it is dismounted
			s info=$ZU(49,dir)
		}
		if info<0 {
			w !,"Database ",dir," does not appear to exist"
			continue
		}
		s Mirrored=$Case($zb(+$p(info,",",17),$zu(40,8,28),1),0:0,:1)
		s InActiveMirror=$Case($zb(+$p(info,",",18),$zu(40,8,29),1),0:0,:1)
		s ReadOnly=$Case($zb(+$p(info,",",17),$zu(40,8,13),1),0:0,:1)
		if 'Mirrored {
			w !,"Database ",dir
			w !,?5," is not mirrored. Use standard journal restore"
			continue
		}
		if InActiveMirror {
			w !,"Database ",dir
			w !,?5," is part of the active mirror, catch-up is not required"
			continue
		}
		if ReadOnly {
			w !,"Database ",dir
			w !,?5," is marked read-only, cannot be caught up"
			continue
		}
		s catchuplist(dir)=+info  ;add directory+sfn to catchup list
	}		
	if '$D(catchuplist) {
		w !,"No directories specified for catch-up"
		quit
	}
	s dir=""
	s sfnlist=""
	w !,"Starting catch-up for the following mirrored database(s):"
	for  {
		s dir=$O(catchuplist(dir),1,sfn)
		quit:dir=""
		w !,?5,"sfn #",sfn,": ",dir
		s sfnlist=sfnlist_$LB(sfn)
	}
	if sfnlist="" {
		s $ZE="<LOGERR>MirrorCatchup+n^JRNRESTO" 
		d BACK^%ETN
		w !,"Failed to generate sfn list for catch-up operation"
		quit
	}
	s x=##class(SYS.Mirror).CatchupDB(sfnlist,$G(loc),.errlist)
	if 'x {
		w !,"Catch-up databases failed - see messages.log for details"
	} else {
		if '$LL($G(errlist)) {
			w !,"Catch-up succeeded."
		} else {
			w !,"Catch-up succeeded for the following databases"
			k sfnarray
			f i=1:1:$LL(sfnlist) s sfnarray($LG(sfnlist,i))=""
			f i=1:1:$LL(errlist) k sfnarray($LG(errlist,i))
			s sfn=""
			for  {
				s sfn=$O(sfnarray(sfn))
				q:sfn=""
				w !,?5,$P($ZU(49,+sfn,3),"^",2)
			}
			w !,"The following databases were not successfully restored"
			f i=1:1:$LL(errlist) {
				s sfn=$LG(errlist,i)
				w !,?5,$P($ZU(49,+sfn,3),"^",2)
			}
		}
	}
	quit
err ;
	s $ZT=""
	d BACK^%ETN
	w !,"Catch-up caught unexpected error: ",$ZE
	quit		
} 
addMirroredDir(dir,dblist,HasMirrorConfig) {
	/* Given a database name, if its mirrored and its neither part of the
       active mirror nor marked as read-only then add it to the list of 
       possible choices for catch-up. We will mount the db if necessary
       in order to get an sfn */
	s info=$ZU(49,dir)
	s Mirrored=$Case($zb(+$p(info,",",17),$zu(40,8,28),1),0:0,:1)
	quit:'Mirrored
	s sfn=+info 
	if (sfn<0) || (sfn=$ZU(40,0,41)) {
		s rc=$ZU(17,dir)
		s info=$ZU(49,dir)
		s sfn=+info
		if (sfn<0) || (sfn=$ZU(40,0,41)) {
			w !,"...failed to mount ",dir," rc = ",rc
			quit  ; can't be mounted
		}
	}
	s InActiveMirror=$Case($zb(+$p(info,",",18),$zu(40,8,29),1),0:0,:1)
	s ReadOnly=$Case($zb(+$p(info,",",17),$zu(40,8,13),1),0:0,:1)
	s MirrorNoWrite=$Case($zb(+$p(info,",",18),$zu(40,8,30),1),0:0,:1)
	s MirrorActivationRequired=$Case($zb(+$p(info,",",18),$zu(40,8,32),1),0:0,:1)
	if 'HasMirrorConfig||'(InActiveMirror||MirrorActivationRequired||MirrorNoWrite) {
		s dblist(dir)=sfn
	}
}
STOP(x) S x=$zconvert($E(x,1,4),"U") Q (x["EXIT")!(x["STOP")!(x["QUIT")!(x["HALT")!($E(x)="^")
YN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YN"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"yn","YN") I "^YN"'[R W "  enter Yes or No, please"
 S POP=(R="^") W $E($S(R="N":"No",R="Y":"Yes",1:""),$L(X)+1,3) Q R
PATRN(X) N q,i,x,c S q=0,x="" F i=1:1:$L(X) S c=$E(X,i) S:c="""" c=c_c DO
 . I "*?&#"'[c S x=x_$S(q:c,1:"1"""_c),q=1 Q  ;simple text -- no pattern
 . S x=x_$E("""",q)_$S(c="&":"1A",c="#":"1N",c="*":".E",1:"1E"),q=0 Q
 S:q x=x_"""" S X=$P($P($P($P(X,"?"),"#"),"&"),"*") Q x ;return ?@x
HasFile(f) Q ''$zu(78,22,f) ;1: file exists 0: not
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/FILEINC.inc#1 $ ($Change: 7440104 $) */
 ; BITWISE.INC
FIXDIR(dir) ;procedure, dir is passed by reference
 Q:dir=""
 Q:$A(dir,$L(dir))=$A($s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""))
 s dir=dir_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")
 Q
fixdir(dir) ;function
 Q:dir="" ""
 Q:$A(dir,$L(dir))=$A($s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")) dir
 Q dir_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")
basename(f) ;similar to basename on UNIX
 Q $P(f,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""),1,$L(f,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""))-1)_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")
appdir(d1,d2) ;use $zu(12,d2) to append d2 to canonic dir
 S d1=d1_d2
 Q d1
VALIDIR(dir) ;validate directory dir and create it if dir doesn't exist
 new flag
 s flag=1
 g vdir2
validir(dir,flag) ;validate directory dir and optionally create it if it
vdir2 ; VALIDIR(dir) comes here with flag set to 1
 quit:$$ChkDirOrSpecEXISTS(dir)'="" 1   ; dir is valid and exists
 quit:$$ChkDirVALID(dir)="" 0    ; dir is not valid
 i flag'=1 q 0  ; flag says don't create, return failure
 new x
 set x=$$mkdir(dir)  ; returns 0 for success, 1 for failure
 q:x=1 0  ; failed to create
 quit:$$ChkDirOrSpecEXISTS(dir)="" 0   ; it doesn't we failed
 q 1  ; success
mkdir(dir) ;create a new directory
 q '##class(%Library.File).CreateDirectoryChain(dir)
jrnshort(jf,short) ;get/set short form of a journal file name FIXME HYY1999
         N (jf,short)
         S len=$L($P(jf,";"))
         Q:$G(short)="" $E(jf,len-11,len) ;"GET" form
         S $E(jf,len-11,len)=short ;"SET" form
         Q jf
GJrnPrefix(jf) ;extract prefix from the journal file name jf
         N (jf)
         S fname=$P(jf,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""),$L(jf,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")))       
         Q $e(fname,1,$l($p(fname,"."))-8)
GetJrnFileName(path) { 
	i $f(path,"/") q $p(path,"/",$l(path,"/")) ;presumably a Unix path
	if $f(path,"\") q $p(path,"\",$l(path,"\")) ;presumably a Windows path
	s vmsfile=$p(path,"]",2) i vmsfile="" q path ;a name only, not a path
	q $p(vmsfile,";") ;return name from a VMS path without trailing ";"
}
dirinvalidmsg(dir1,dir2) 
 n valid1,valid2,cnt,msg
 s valid1=$$VALIDIR(dir1),valid2=$$VALIDIR(dir2)
 s cnt=valid1+valid2 ; cnt = 0 if both invalid, 1 if one is valid
 s msg="The following journaling "
 s:cnt msg=msg_"directory is" 
 s:'cnt msg=msg_"directories are"
 s msg=msg_" not valid"_$C(13,10)
 s:'valid1 msg=msg_"     "_dir1_$C(13,10)
 s:'valid2 msg=msg_"     "_dir2_$C(13,10)
 q msg
ChkDirVALID(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,1)
ChkDirEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkDirOrSpecEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,3)
ChkDir(R) N N S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkBad S $ZT="" W !,"<"_$P($P($ZE,"<",2),">")_"> error -- invalid directory"
 Q ""
ASKSET(prompt,val,backup,help,pattern) ;procedure
 N x,done,def,enahelp,helpavail,backupavail
 s done=0
 s def=$G(val)
 s backup=$G(backup,0) 
 s enabackup=$S(backup=-1:0,1:1)
 s backupavail=$S(backup=1:1,1:0)
 s help=$G(help)
 s enahelp=$S(help="*":0,1:1) ;there might not be any help though
 s helpavail=$s(enahelp&($L(help)!($D(help)>1)):1,1:0)
 if 'enabackup n POP
 s POP=0
 f  d  q:done!POP
 . W !,$G(prompt)
 . w:($X+$L(def))>65 !,?5
 . w:$L(def) " <",def,">"
 . if helpavail!backupavail do
 . . w " [" w:helpavail "?" w:backupavail "^" w "]"
 . w:(($X+$L(def))>75) !,?5
 . W " => " 
 . R x,!
 . if x="^" d  q
 . . if 'enabackup s done=1 q
 . . if backupavail s POP=1 q
 . . w "...backup not available here"
 . if enabackup,x="""^""" s x="^",done=1 q
 . ;
 . if x="?" d  q
 . . if 'enahelp s done=1 q
 . . if 'helpavail w "...help not available here" q
 . . if $D(help)=1 w !?5,help q
 . . s x="" f  s x=$O(help(x)) q:x=""  w !,?5,help(x)
 . . w !
 . if enahelp,x="""?""" s x="?",done=1 q
 . i x]"",$g(pattern)]"",x'?@pattern w !?5,$s(helpavail:help,1:"[bad format]") q
 . s:'$L(x) x=val 
 . s done=1
 s:'POP val=x
 q

JRNROLL^INT^1^67214,47330
JRNROLL ;rollback incomplete transactions ;$Change: 7440104 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	; Revision: $Id: //iris/2024.1.3/databases/sys/rtn/journal/jrnroll.mac#1 $
	/* There are five entry points in this module:
	       INT - invoked by d ^JRNROLL for interactive rollback
	       THISONE - called from STU during system startup and
	                 by INT for interactive rollback
	       CLUSTER - called from STU during cluster startup recovery
	                 and from RCVRYDMN during cluster failover
	       MIRROR - called from ECPRecovery as part of becoming
	                the primary mirror member
	       MIRRORCatchup - called from SYS.Mirror.CatchupDB() as
	       			 part of catching up a mirrored databases so it
	       			 can be activated.
	*/
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/FILEINC.inc#1 $ ($Change: 7440104 $) */
	; 
    ; Interactactive entry point to rollback partial transactions 
    ; for a given journal file stream.
    ; checkerr=1 -> use error trapping
    ; reporterr=1 -> report errors to terminal 
    do INT(1,1)  ;checkerr=1, use error trapping, 
    quit
INT(checkerr,reporterr) PUBLIC {
	W !,"This utility is used to rollback any partially completed"
	W !,"transactions for records in the journal.",!
 	I $$YN("Do you want to unwind partial transactions","Y")="N" {
		W !,"Not unwound.",!
 	} else {
	 	k errlist
	 	do THISONE("",checkerr,reporterr,.errlist)  ;STU=""
	 	if +$G(errlist) {
		 	w !,errlist," errors reported during rollback"
	 	}
 	}
 	q
}
THISONE(STU,checkerr,reporterr,errlist) PUBLIC {
	s STU=$G(STU)
	s QUIETLY=+$S(STU="S":1,1:0) ;quietly is yes except when called from STU
	s checkerr=+$G(checkerr,1)
	s reporterr=+$G(reporterr,0)
	;
	s jrnstop=0 ; 1 => disabled journaling
	i checkerr {
		s $zt="err"
	}
	s %curfile=$$curfile ; current journal file, or "" if journaling isn't enabled
	I %curfile'="" {
		W !,"You cannot rollback all open transactions from the"
		w !,"current journal file unless you disable journaling.",!
		i ($$YN("Do you want to disable journaling","Y")="N") {
			w " [Not rolled back]",!
			quit  ;we're done
		}
		S jrnstop=1 ;we'll start journaling when we're done
		D INT^JRNSTOP()
		S %curfile=$ZU(78,3)
		s shortnam=$case($ZBITGET($ZVERSION(0),46),0:$case($f(%curfile,";"),0:$e(%curfile,*-8-$l($p(%curfile,".",$l(%curfile,"."))),*-$case($e(%curfile,*)="z",0:0,1:1)),:$e(%curfile,*-8-$l($p(%curfile,".",$l(%curfile,"."))),$f(%curfile,";")-2)),:%curfile)
		S expqty=0
		s maxsize=$P($ZU(78,22,%curfile,3),",",2)
			S altdir=$G(^%SYS("JOURNAL","ALTDIR"),$ZU(12,"journal"))
			S curdir=$G(^%SYS("JOURNAL","CURDIR"),$ZU(12,"journal"))
		S prefix=$ZU(78,93)  ;journal prefix from memory
	}
    ; Locate journal end for our computer
    ; else open our directory and rollback its transactions
    S deffile=%curfile
    ;  we determine the latest journal file this way:
    ;  $zu(78,3) (as in %curfile), if $zu(78,3)="" then
    ;  (journaling must be off) $$$JRNINDEX (as stored in WIJ file)
    I (deffile="") {
	    S a=$zu(78,21)
	    s deffile=$p(a,",",2)
    }
GN ;Come back here if we need to get a new starting filename
 	i STU="S" {
	 	s JN=deffile
 	} else {
		w !,"Journal file name: ",$ZU(12,deffile,0)," =>" 
			r JN:300 
					}
 	I $E(JN)="?" {
	 	W ! 
		W !?4,"Specify the name of the directory and file where the"
		W !?4,"existing journal is located.  <return> will select"
		W !?4,"the current default file ("_deffile_")."
		W !?4,"Enter '^' or 'STOP' to quit this utility."
		W ! 
		G GN
 	}
 	I ($E(JN)="^")!($zconvert(JN,"U")="STOP") {
	 	W !," [Not rolled back]",! 
	 	Q
 	}
 	S:JN="" JN=deffile 
 	S %jrnfile=$ZU(12,JN,0)
 	; jrfilecnt: the journal file index of the "current" journal file.
	; xfcnt: the counter of the file where the earliest open trans is
	; jrcnt: how many journal files to search back through to find the
	;        earliest open transaction
	;        jrcnt <0 means go all the way back to JRNSTARTed file
	; jroff: the offset of the earliest open transaction
	;        0 => earliest open transaction not known
	; these two are mainly used in startup.
 	I JN'="" {
		I STU'="S" {
			S jrcnt=-1,jroff=0,jrfilecnt=0 
		} else {
			S wijinfo=$zu(78,21) ;wijinfo="jrnoff,jfnam,jfcnt,minxfcnt,minxoff"
			S jroff=$P(wijinfo,",",5)
			S xfcnt=$P(wijinfo,",",4)
			S curfilename=$P(wijinfo,",",2)
			S jrninfo=$zu(78,22,curfilename,99)
			if +jrninfo'=1 {
				d othererrlog(.errlist,"Failed to open current journal file "_curfilename)
				Quit
			}
			if (+$p(jrninfo,",",13+1)'=0) {
				while (+$p(jrninfo,",",12+1)>xfcnt) {
					s curfilename=$p(jrninfo,",",1+1)
					S jrninfo=$zu(78,22,curfilename,99)
					Quit:+jrninfo'=1||(+$p(jrninfo,",",13+1)=0)
				}
				if +jrninfo'=1 {
					d othererrlog(.errlist,"Failed to open journal file "_curfilename_" while walking backwards.")
					Quit
				}
				if +$p(jrninfo,",",13+1)=0,xfcnt<$P(jrninfo,",",18+1) {
					S jroff=$P(jrninfo,",",19+1)
					S xfcnt=$P(jrninfo,",",18+1)
					d $zu(9,"","JRNROLL: Reset rollback point to "_xfcnt_"/"_jroff_" for local databases",0,0  /* Informational message */)
				}
			}
			i $D(^NET("TPLOG")) {
				s remsysid=""
				f  {
					s remsysid=$O(^NET("TPLOG",remsysid)) 
					q:remsysid=""
					s dmn=""
					f  {
						s dmn=$O(^NET("TPLOG",remsysid,dmn),1,transid) 
						q:dmn=""
						;transid=^NET("TPLOG",remsysid,dmn)
						S transfc=$P(transid,"^",2)
						if (transfc<xfcnt) {
							s xfcnt=transfc
							S jroff=+transid
						} elseif (transfc=xfcnt) && (+transid<jroff) {
							s jroff=+transid 
						}
					}
				}
			}
			I JN=$P(wijinfo,",",2) {
				S jrfilecnt=$P(wijinfo,",",3)
			} else {
				S jrfilecnt=$ZU(78,26)  ;JN must be "current"
			}
			s jrcnt=jrfilecnt-xfcnt
		}
		do ROLL(STU,QUIETLY,JN,jrfilecnt,jrcnt,jroff,,,checkerr,reporterr,.errlist,"")
		if STU="S" {
			K ^NET("TPLOG")  ; HYY120
		} 
	}
    ; restart journaling if we stopped it
 	;set shortnam to its next one, then start journaling on it
	I jrnstop {
 		s shortnam=$$nextname^JRNSTART(shortnam)
		k err
 		D INT^JRNSTART(curdir,altdir,shortnam,prefix,maxsize,expqty,$P($G(^%SYS("JOURNAL","CURRENT")),"^")\2#2,.err,0)
 		I $G(err)'="" {
	 		D $zu(9,"","ERROR: "_err,(0>0),0)
 		}
	}
	quit
err ;
	s $ZT=""
    d miscerrlog(checkerr,reporterr,.errlist)
	i $D(mount) {
		s n=""
		for  {
			s n=$O(mount(n))
			quit:n=""
			if $ZU(3,n)  ;dismount database
		}
		k mount
	}
	q
 }
   ;
   ; MIRROR(latest jrnfilename, lastest jrnfile seq #, min jrnfile seq #,
   ;					 min jrnfile index,errlist)
   ; Invoked from ECPRecovery when a backup is taking over for the primary
   ; to rollback any open "local" transactions on the primary and build the
   ; list of ECP transactions to be handled by ECP recovery. The journal file
   ; seq #'s are "mirror journal file seq #'s".
   ;
   ; errlist = passed by reference gets loaded with any errors detected.
   ;      $G(errlist) is the count of all errors
   ;      some errors are added to errlist(n), some are only added when
   ;      checkerr=2
   ;
MIRROR(mirname,lastjrnfilecnt,minxjrnfilecnt,minxindex,errlist) PUBLIC {
    if 'minxjrnfilecnt {
	    ; zero is an invalid value so bump it up to one
	    s minxjrnfilecnt=1
	    s minxindex=65536*2
	    if minxjrnfilecnt>lastjrnfilecnt {
		    quit 1  ;nothing to do
	    }
    }
    s QUIETLY=1
    s CHATTY=0  ;This is for ^ROLLBACK to supress input
	s $zt="mirrorerr"
    s checkerr=2  ;check for errors. ROLLBACK reports errors in tranerror & errlist
    s reporterr=0
    s STU="M"  ; Indicate that this is mirror takeover
   	; ROLL takes as input:
   	;  When STU="M", mirfilelist(1..n) are the journal files we want
   	;      ROLL to use for transaction rollback in newest->oldest order
   	;      as otherwise we have to flip the list in ROLL. 
   	;  jroff is where to start in the mirfilelist(1) file.
   	s mirfilelist=0
   	for i=lastjrnfilecnt:-1:minxjrnfilecnt {
  	   s JN=$SYSTEM.Mirror.GetJournalFileByMjrncnt(i,mirname)
	   if '+JN {
		   do othererrlog(.errlist,"Failed to locate mirror journal file #"_i_" as part of mirror recovery")
		   s JN=""
		   quit 
	   }
	   s JN=$P(JN,",",2)
	   s mirfilelist=mirfilelist+1
	   s mirfilelist(mirfilelist)=JN
    }
    if JN="" quit 0  ;failed
 	s jroff=minxindex
	s errcnt=$G(errlist,0)
	do ROLL(STU,QUIETLY,JN,,,jroff,,.mirfilelist,checkerr,reporterr,.errlist,"") 
	s errcnt=$G(errlist,0)-errcnt
 	if errcnt q 0  ;new errors
    q 1  ; succeeded
mirrorerr ;
   s $zt=""
   d miscerrlog(checkerr,reporterr,.errlist)
   quit 0  ;failed
}
   ;
   ; MIRRORCatchup(.dblist,latest jrnfilename, lastest jrnfile seq #, min jrnfile seq #,
   ;					 min jrnfile index,errlist)
   ; Invoked from CatchupDBTRollback^MIRRORMGR when we're the active primary and
   ; we've finished "catching up" some databases which were out of sync with
   ; the active mirror (presumably they were restored from backups) and we need
   ; to rollback all open transactions (ECP and non-ECP) so we can make the
   ; databases active again. The passed journal file seq #'s are "mirror journal file seq #'s".
   ; We're careful not to roll back any open transactions which are still active
   ; on the local system. If a database is dismounted for instance with SWITCH 10
   ; set, we might be running catchup when it is re-mounted but there are local
   ; processes with transactions still in progress that shouldn't be rolled back.
   ;
   ; errlist = passed by reference gets loaded with any errors detected.
   ;      $G(errlist) is the count of all errors
   ;      some errors are added to errlist(n), some are only added when
   ;      checkerr=2
MIRRORCatchup(mirname,dblist,lastjrnfilecnt,minxjrnfilecnt,minxindex,errlist) PUBLIC {
    s QUIETLY=1
    s CHATTY=0  ;This is for ROLLBACK to supress input
	s $zt="mirrorcatchuperr"
    s checkerr=2  ;check for errors. ROLLBACK reports errors in tranerror & errlist
    s reporterr=0
    s STU="MC"  ; Indicate that this is mirror takeover
   	; ROLL takes as input:
   	;  When STU="MC", mirfilelist(1..n) are the journal files we want
   	;      ROLL to use for transaction rollback in oldest->newest order
   	;      and dblist() contains the list of databases we want recovered.
   	;      dblist() is passed as the redirection list to START^ROLLBACK().
   	;  jroff is where to start in the mirfilelist(1) file.
   	s mirfilelist=0
   	for i=lastjrnfilecnt:-1:minxjrnfilecnt {
  	   s JN=$SYSTEM.Mirror.GetJournalFileByMjrncnt(i,mirname)
	   if 'JN {
		   do othererrlog(.errlist,"Failed to locate mirror journal file #"_i_" as part of mirror recovery")
		   s JN=""
		   quit
	   }
	   s JN=$P(JN,",",2)
	   s mirfilelist=mirfilelist+1
	   s mirfilelist(mirfilelist)=JN
    }
    if JN="" quit 0  ;failed
 	s jroff=minxindex
	; dblist() was passed by reference and its the redirection list
	; which dorollback passes to start^ROLLBACK()
	s errcnt=$G(errlist,0)
	do ROLL(STU,QUIETLY,JN,,,jroff,,.mirfilelist,checkerr,reporterr,.errlist,"") 
	s errcnt=$G(errlist,0)-errcnt
 	if errcnt q 0  ;new errors
    q 1  ; succeeded
mirrorcatchuperr ;
   s $zt=""
   d miscerrlog(checkerr,reporterr,.errlist)  ;miscerrlog will report the error with $$$LOGMSG()
   quit 0  ;failed
}
   ;
   ; CLUSTER(crashcsn,checkerr,reporterr)
   ; External entry point to rollback all open transactions for one or
   ;   all clustered databases.  Called from STU for cluster recovery at
   ;   startup to recover open transactions across all cluster members and
   ;   by RCVRYDMN during cluster recovery to recovery open transactions from
   ;   a single failed cluster member.
   ;
   ; crashcsn = cluster system number of crashed system if we
   ;      only want to rollback all transactions for that one system
   ;      else = 0
   ; checkerr = 1 if want to use error trapping (always 1 except
   ;          when debugging)
   ; reporterr = 1 if want errors reported on terminal (probably want 0)
   ; errlist = passed by reference gets loaded with any errors detected.
   ;      $G(errlist) is the count of all errors
   ;      some errors are added to errlist(n), some are only added when
   ;      checkerr=2
CLUSTER(crashcsn,checkerr,reporterr,errlist) PUBLIC {
 	s checkerr=+$G(checkerr,1)
 	s reporterr=+$G(reporterr,0)
 	;
	s QUIETLY=1
	i checkerr s $zt="clustererr"
 	s clujrnstat=0
 	s STU=""
	;clujrnstat tracks what we need to do when we're done. For startup
	;when crashcsn is 0 we enable journaling if its stopped, enable journaling
	;of all globals and make sure journaling is enabled for this process.
	;For cluster failover we disable replication and disable journaling for this
	;process. The flags are:
	;   1 = we started journaling
	;   2 = we enabled journaling of all globals
	;   4 = we enabled journaling for this process
 	if '$zu(78,22) {
    	;enable journaling all globals, otherwise quit. Before starting journaling
		;set up ^%SYS("JOURNAL","WIJFILE") for this system's last journal so that
		;we continue the journal file count sequence numbers.
		S wijinfo=$zu(78,21)
		s ^%SYS("JOURNAL","WIJFILE")=$P(wijinfo,",",2)_","_$P(wijinfo,",",3)
		s clujrnstat='($zu(78,22)) 
		i clujrnstat {
			s jrnfile=$P(wijinfo,",",2)
			s jrnfilecnt=$P(wijinfo,",",3)
			f  {
				s nextfile=$$NEXTJRN0^JRNUTIL(jrnfile) 
				q:nextfile=""  
				s jrnfile=nextfile 
				i $i(jrnfilecnt)
			}
			s ^%SYS("JOURNAL","WIJFILE")=jrnfile_","_jrnfilecnt
			d ^JRNSTART
			i '($zu(78,22)) {
				d $zu(9,"","Unable to roll back open transactions with journaling off",(1>0),1) 
				q  ;abort
			}
		}
		i '$$CURRENT^%SYS.NOJRN() {
			s clujrnstat=clujrnstat+4 
			d ENABLE^%SYS.NOJRN
		}
		s STU="C" ; prevents rollback^JRNROLL from playing with journaling
	}
 	if (STU="C") {
		Set Directory=$p($zu(59),",",13)
		Set sc=##class(SYS.Database).MountDatabase(Directory,0,0) ;; dir,<readonly flag>,<cluster flag>
		if (('sc)) {
			Do $zu(9,"","Failed to mount Cluster common DB!! : "_$System.Status.GetErrorText(sc),(0>0),0)
			Set nocludb=1
		}
	}
	; Establish open of each cluster journal file
	; CSNs are 0 based so if crashcsn is non-zero, set thiscsn to
	; crashcsn-1. crashcsn=0 is a flag to tell us to rollback open
	; transactions all the cluster members.
	i crashcsn {
		s thiscsn=crashcsn-1 
		d nextclu
	} else {
		f thiscsn=0:1:14-1 {
			d nextclu
		}
	}
clucleanup ; clustererr comes here to restore journaling state
	s $zt="err"
	i clujrnstat\4 {
		d DISABLE^%SYS.NOJRN 
		s clujrnstat=clujrnstat#4
	}
	i clujrnstat {
		d INT^JRNSTOP()
	}
	if (STU="C") {
		d:('$d(nocludb)) $ZU(3,Directory)
	}
	q
clustererr ;
	d miscerrlog(checkerr,reporterr,.errlist)
	s $ZT="err"
	i $D(mount) {
		s n=""
		f  {
			s n=$O(mount(n)) 
			q:n=""  
			do $ZU(3,n)
		}
		k mount
	}
	g clucleanup
   ; If there is a journal for this cluster, open it and
   ; restore its open transactions
nextclu ;subroutine of CLUSTER, thiscsn is the csn to process
	i checkerr s $zt="err"
   	; see if there is a csn with this number
	; minoff = offset of the earliest open transaction. 0 = not known
	; minfile = journal file # of file corresponding to minoff
	; jrcnt = how many journal files to search back through to find
	;         open transactions. -1 = search back to the prior JRNSTART
	;
	; $$$JRNLOOKUP(csn) returns: 
	;     imjrnoff,jrnfilespec,jrnfcnt,transfcnt,transindex,mgr dirspec
	s wijinfo=$zu(78,20,thiscsn)
	s %jrnfile=$p(wijinfo,",",2) q:%jrnfile=""
	s minoff=+$P(wijinfo,",",5)  ; jrnoffset of earliest open transaction
	s minfile=+$P(wijinfo,",",4) ; corresponding jrnfilecnt value
	; NB: $P(a,",",$$$JLMGRDIR) is the manager's directory spec for this 
	;     system as the journal file name must not contain any commas
	s mgrdir=$P(wijinfo,",",9)  ; dir spec of the manager's database
	s mgrns="^^"_mgrdir
	;
	; Look in this computer's manager directory for a transaction
	; log from remote TP servers. If we find one then scan it to find
	; the earliest journaling index we must scan back to in order to
	; rollback open transactions on this system
	;
	k firstindex
	try {
		; quick mount of directory if it isn't mounted (usually isn't)
		s n=$ZU(49,mgrdir)
		i (n<0)!(n'<$zu(40,0,41)) {
			s mount(mgrdir)=""
			s n=$ZU(17,mgrdir)
		}
		i $D(^[mgrns]NET("TPLOG")) {
			s remsysid=""
			f  {
				s remsysid=$O(^[mgrns]NET("TPLOG",remsysid)) 
				q:remsysid=""
			 	s dmn=""
				f  {
					s dmn=$O(^[mgrns]NET("TPLOG",remsysid,dmn),1,transid) 
					q:dmn=""
					;transid=^[mgrns]NET("TPLOG",remsysid,dmn)
					s transfile=+$P(transid,"^",2)
					s transid=+transid
					i transfile<minfile {
						s minfile=transfile,minoff=transid
					} elseif (transfile=minfile),(transid<minoff) {
						s minoff=transid
					}
				}
			}
		}
	} catch {
		d miscerrlog(checkerr,reporterr,.errlist)
		; ignore the error and attempt to restore transactions anyway
	}
	; 3rd piece of wijinfo is the value of jrnfilecnt that corresponds
	; to the journal file in the 2nd piece. The difference between 
	; this value and the value of minfile is the # of journal files we
	; need to scan as part of transaction rollback
	s jrfilecnt=$p(wijinfo,",",3)
	s jrcnt=jrfilecnt-minfile
 	; ROLL takes as input:
	;  jrfilecnt = the journal file index of the "current" journal file. (HYY655)
	;         JN = "current" journal file name
	;      jrcnt = # of journal files we need to search back through to
	;              find the earliest open transaction or negative
	;              means go back to the last JRNSTART
	;      jroff = offset in earliest journal file we need to start at
	;      mgrdir = dirspec of manager's dataset
	;	   crashcsn = csn of crashed system used when STU is not "C"
	s JN=%jrnfile
	s jroff=minoff
	s errcnt=$G(errlist,0)
	do ROLL(STU,QUIETLY,JN,jrfilecnt,jrcnt,jroff,mgrdir,,checkerr,reporterr,.errlist,crashcsn)
	if errcnt=$G(errlist,0) {
		; Only clean up the TPLOG and ECP registry if there were
		; no errors restoring this system. errlist is a running count
		; of all errors.
		k ^[mgrns]NET("TPLOG")
		/* Leave a mark in the mgr directory indicating transaction rollback
		   occured so when that system starts it doesn't complain if there
		   isn't a journal directory listed in the WIJ */
		s ^[mgrns]SYS("SHUTDOWN","TPCLEAN")=$ztimestamp_"^"_"CLURECOV"
	}
	; dismount amy manager directories we mounted
	i $D(mount) {
		s n="" 
		f  {
			s n=$O(mount(n)) 
			q:n=""  
			i $ZU(3,n)
		}
		k mount
	}
	q
err ;
	d miscerrlog(checkerr,reporterr,.errlist)
	s $ZT=""
	i $D(mount) {
		s n=""
		f  {
			s n=$O(mount(n)) 
			q:n=""  
			i $ZU(3,n)
		}
		k mount
	}
	q
}  ; end of CLUSTER()
 ; ROLL() inputs:
 ;   JN = "current" journal file name
 ;   jrfilecnt = Journal file index of that journal file name
 ;   jrcnt = # of journal files we need to process. When negative
 ;           we need to go back to the "JRNSTART" journal file.
 ;   jroff = offset in earliest journal file we need to start at
 ;           if jroff is 0 we have to start at the beginning of that
 ;           file.
 ;   mgrdir = only specified by CLUSTER^JRNROLL, this is the manager's
 ;			 directory spec of the system we're rolling back. If undefined 
 ;           it defaults to  our system. If it is defined then it must
 ;           already be mounted.
 ;   checkerr = 2 if we want to track errors in errlist
 ;   repoterr = 1 if we want to display errors on the terminal
 ;   errlist is passed by reference. This accumulates the count of the
 ;          # of errors and, when checkerr=2, contains the detail for
 ;          the individual errors
 ;	 mirfilelist is passed by reference when STU="M" or "MC" and is
 ;          the list of journal files we need processed. All other
 ;          STU values build the file list below from the set of local
 ;          journal files
 ;	 crashcsn is passed from CLUSTER^JRNROLL when STU is not "C". STU is
 ;          "C" for cluster startup recovery. STU is "" and crashcsn is
 ;          not "" when CLUSTER^JRNROLL is called from RCVRYDMN
 ; output:
 ;	 errlist is passed by reference and contains a list of errors
 ;       encountered during rollback. The node value is the count
 ;       of the # of errors and the errors are listed in the array.
 ; callers:
 ;	   ROLL() is only called by entry points inside JRNROLL. It is
 ;       declared public so that errors are reported as offsets from
 ;       ROLL rather than the nearest public tag.
 ;
 ;the main part of JRNROLL is done in this order:
 ;  1. find all journal files after "JN"
 ;  2. trace journal files from JN back to the JRNSTARTed one
 ;  3. gather open transactions by walking down file/record list
 ;  4. walking up file list, call start^%ROLLBACK for each file
 ;we assume no open transactions cross JRNSTART
ROLL(STU,QUIETLY,JN,jrfilecnt,jrcnt,jroff,mgrdir,mirfilelist,checkerr,reporterr,errlist,crashcsn) [tranerror] PUBLIC {
	n tranerror ; Public variable set by start^ROLLBACK
	;"ROLLBACK" global is used only for startup rollback to avoid conflict with 
	;other failover rollbacks (e.g., during cluster failover, etc.)
	Set saveecptrans=1
	s runguid=""
	s logprogress=0
	s jrnstat=0
	s abortquit=0
	s $ze=""
	s $zt="exitroll"
	s cluconfig=$S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0)  ; GK1410,GK335-
	If (($S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0)) & (STU'="M") & (STU'="MC") & ($E(STU)'="R")) {
		Set clustat=$zu(59)
		Set cludbdir=$zu(12,$p(clustat,",",13))
		Set sc=$zu(49,cludbdir) 
		Set:(sc<=-2) cludbdir="" ; If DB doesnt exist
		if (STU="S") {
			s ECPStateNS="" ; %SYS/mgr DB
		} elseif (STU="C") {
			s ECPStateNS="^^"_cludbdir ; Clu Comm DB
		} elseif ($g(crashcsn)'="") {
			s ECPStateNS="^^"_cludbdir  ; Clu Comm DB
		} else {
			d $zu(9,"","ECP Open trasactions will be rolled back .. system is not in recovery mode",(0>0),0)
			s saveecptrans= 0
		}
	} elseif STU="M" {
		merge filelist=mirfilelist
		s jrfilecnt=$P($ZU(78,22,filelist(1),12),",",2)
		; set jrcnt to 0 because filelist contains the exact list of
		; files we have to search. jrcnt is the # of prior files which 
		; need to be located & added to filelist before rollback.
		s jrcnt=0
		s ECPStateNS="" ; %SYS/mgr DB
	} elseif STU="MC" {
		merge filelist=mirfilelist
		s jrfilecnt=$P($ZU(78,22,filelist(1),12),",",2)
		; set jrcnt to 0 because filelist contains the exact list of
		; files we have to search. jrcnt is the # of prior files which 
		; need to be located & added to filelist before rollback.
		s jrcnt=0
		s ECPStateNS="" ; %SYS/mgr DB
		s saveecptrans= 0
	} elseif $E(STU)="R" {
		s tindex=$P(STU,"^",2)
		if '$D(^SYS("ROLLBACK","PENDING",tindex)) {
			do othererrlog(.errlist,"No pending transaction listed for index #"_tindex)
			quit
		}
	 	l +^SYS("ROLLBACK","PENDING",tindex):5
	 	if '$T {
		 	s owner=^$LOCK($name(^SYS("ROLLBACK","PENDING",tindex)),"OWNER")
			do othererrlog(.errlist,"Pending transaction #"_tindex_" current locked by process: "_owner)
			quit
		}
		;
		s origSTU=$g(^SYS("ROLLBACK","PENDING",tindex,"STU"))
		if $E(origSTU)="R" {
			s origSTU=$E(origSTU,2,*)  ;should be M or S
		}
		s phase=$G(^SYS("ROLLBACK","PENDING",tindex,"Phase"))
		s fileindex=$G(^SYS("ROLLBACK","PENDING",tindex,"LastIndexProcessed"))  ;last file processed
		m filelist=^SYS("ROLLBACK","PENDING",tindex,"FileList")
		m filesize=^SYS("ROLLBACK","PENDING",tindex,"FileSize")
		m tranopen=^SYS("ROLLBACK","PENDING",tindex,"OpenTransaction")
		m jrfilecnt=^SYS("ROLLBACK","PENDING",tindex,"Jrfilecnt")
		m transsys=^SYS("ROLLBACK","PENDING",tindex,"TransSys")
		m transbufnum=^SYS("ROLLBACK","PENDING",tindex,"TransBufnum")
		m nnRecs=^SYS("ROLLBACK","PENDING",tindex,"nnRecs")
		; STU will be either M or S
		IF (origSTU'="M") && (origSTU'="S") {
			do othererrlog(.errlist,"Unknown STU value ("_origSTU_") for pending transaction #"_tindex)
	 		l -^SYS("ROLLBACK","PENDING",tindex)
	 		quit
		}
		if (phase'="scan") && (phase '= "rollback") {
			do othererrlog(.errlist,"Unknown phase ("_phase_") for pending transaction #"_tindex)
	 		l -^SYS("ROLLBACK","PENDING",tindex)
	 		quit
		}
	 	k ^SYS("ROLLBACK","PENDING",tindex)
	 	l -^SYS("ROLLBACK","PENDING",tindex)
	 	d $zu(9,"","Restarting processing of pending transaction rollback #"_tindex,0,0  /* Informational message */)
	 	; start with the file preceeding the one we left off with (we're
	 	; running backwards)
		s STU="R"_origSTU  ;STU is now RM or RS (retry+mirrored or retry+startup)
		s jroff=0
		s ECPStateNS="" ; always "" for STU="M" or "S"
	 	do setupProgressReporting
	 	if (phase="scan") {
		 	goto bldxopen
	 	}
	 	; must be phase="rollback"
	 	goto dorollback
	} else {
		s ECPStateNS="" ; %SYS/mgr DB
	}
	i $g(^%SYS("JOURNAL","ROLLBACK")) { 
		If STU="S" g rollback  ;Start up again where we left off.
		; If not during STU, must start again from scratch.
		Kill ^%SYS("JOURNAL","ROLLBACK")
	}
	Kill ^%SYS("JOURNAL","WIJFILE") ;PWC640 (WIJFILE is only valid once we create it)
	; Before locating earlier journal files, locate any subsequent 
	; journal files
	;
	i $G(mgrdir)="" {
		s mgrdir=$ZU(12)
	}
	if (STU'="M") && (STU'="MC") {
		; Note: chronically filelist(filelist) is the oldest and 
		; filelist(1) is the newest. Keep this in mind.
		; (for mirrors, M and MC, filelist is already new->old)
		;
		; 1. build filelist
		s filelist=1
		s p=JN
		s filelist(filelist)=p
		f  {
			s JN=$$NEXTJRN0^JRNUTIL(JN,mgrdir,,.rc) 
			q:JN=""  
			s filelist($i(filelist))=JN
		}
		i (rc<0) && (STU="S") {
			if '$D(^SYS("SHUTDOWN","TPCLEAN"),x) {
				do othererrlog(.errlist,"Failed to find all journal files and there appear to have been open transactions when the system shut down")
			} else {
				s x=$P(x,"^",2)  ;$ztimestamp_"^"_facility
				if x="SHUTDOWN" {
					d $zu(9,"","Graceful system shutdown, transaction rollback not required",(0>0),0) 
				} else {
					d $zu(9,"",x_" override, transaction rollback not required at startup",(0>0),0) 
				}
			}
			quit  ;rollback not possible or not required
		}
		i filelist>1 {
			; Now filelist() contains the list of journal files from the
			; original JN to the most current one. However, they are in
			; reverse order so invert the list
			f i=1:1:filelist s temp(i)=filelist(i)
			; now copy temp back to filelist, inverting the order
			f i=1:1:filelist s filelist(filelist-i+1)=temp(i)
			k temp  ;erase temp list
		}
		; Now we know the latest journal file from before the crash.
		s jrfilecnt=(jrfilecnt+filelist-1) ; Now jrfilecnt corresponds to filelist(1)
		If STU="S" {
			s jrnend=$p($zu(78,22,filelist(1),99),",",10+1)
			i jrnend="" {
				s dev=$zu(78,5,filelist(1),0) 
				i dev'<0 {
					d $zu(78,6,dev) 
					s jrnend=$zu(78,18,0) 
					i $zu(78,7,dev)
				}
			}
			s ^%SYS("JOURNAL","WIJFILE")=filelist(1)_","_jrfilecnt_","_jrnend
		}
	}  /* STU'="M" && STU '= "MC" */	
	;
	; jrcnt is the # of journal files we need to trace back to find the
	; earliest open transaction. If this is < 0 then we go back until
	; we find a journal file created by JRNSTART
	i jrcnt {
		s jroff=0  ; if we open prior files then we start at the 
		;          ; beginning of them when we search for open transactions
		;explaining p=$zu(78,22,p,1):
		;  p as parameter has the form /directory/yyyymmdd.nnn
		;  p as return value has the form 1,nextjrnfilename if parameter p
		;    is a journal file; otherwise p would be -1. 
		;  nextjrnfilename has the same form as parameter p or "" 
		;    if parameter p is JRNSTARTed file.
		F  {
			S p=$ZU(78,22,p,1) 
			Q:+p'=1  
			S p=$P(p,",",2) 
			Q:p=""  
			S jrcnt=jrcnt-1
			S filelist=filelist+1
			s filelist(filelist)=p
			q:'jrcnt  ;done, found the last file we need
		}
		; handle two exits of above loop: normal (p="") or error (p'=1)
		I jrcnt,p'="",+p'=1 {
			W !,filelist(filelist)," does not exist or is not a valid journal file!"
			W !,"Due to that, we cannot trace back to the file containing the start of the open transactions.",!
			I STU'="S",'QUIETLY,$$YN("Abort rollback","Y")="N" {
				S filelist=filelist-1
			} else {
				W !,"Rollback is aborted.",! 
				i STU="S",'$D(^SYS("SHUTDOWN","TPCLEAN")) {
					d othererrlog(.errlist,"Failed to open journal file "_filelist(filelist)_" and there appear to have been open transactions when the system shut down") i 1
				}
				quit  ;abort rollback
			}
		}
	}
	// Convert filelist(1/newest) -> filelist(filelist/oldest) to journal file #
	// filelist(jrnfiecnt-filelist/oldest) -> filelist(jrfilecnt/newest)
	// Note: filelist order is changing here - filelist(smallest #) is the oldest, 
	//       and the filelist(jrfilecnt) is the newest jrn file!!
	set temp=filelist
	F i=1:1:filelist {
		set temp((jrfilecnt-i)+1)=filelist(i)
	}
	kill filelist
	merge filelist=temp
	kill temp
	do setupProgressReporting ;sets logprogress and other variables
bldxopen ; 2. build tranopen list
 	; filelist() should be the journal files from the JRNSTART to last
	;   (eg. ($o(filelist(""))) is the oldest file we need to search for an open transaction)
	; jroff is the offset in filelist($o(filelist("")))) that we should start
	;   searching from. This is 0 if we should start at the beginning
	;   of that file
	; filelist(jrfilecnt) is the newest journal file
	s lastjrnseqnum=0
	s:'$d(cluconfig) cluconfig=$S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0)
	s abortquit=0  ;JO2241
	if $E(STU)="R" {
		; fileindex is the value of i after the last call to scanfile
		; so we start with the file after this one, if there is one.
		s i=fileindex
	} else {
		s i=""
	}
	// Scan for open transactions, from the oldest->newest jrn file
	k origfilelist
	merge origfilelist=filelist
	F  {
		set i=$o(filelist(i))
		quit:(i="")
		S chan=$zu(78,5,filelist(i),0) 
 		 ; PWCDEBUG
		I chan=-1 {
			W !,filelist(i)," is either nonexistent or not a journal file!"
			W !,"Due to that, we cannot use this file for rollback.",! 
			if STU="S" {
				if '$D(^SYS("SHUTDOWN","TPCLEAN"),x) {
					do othererrlog(.errlist,"Failed to open journal file "_filelist(i)_" and there appear to have been open transactions when the system shut down") i 1
				} else {
					; If there were no transactions open during shutdown, we're all set
					; x=^SYS("SHUTDOWN","TPCLEAN")
					s x=$P(x,"^",2)  ;$ztimestamp_"^"_facility
					if x="SHUTDOWN" {
						d $zu(9,"","Graceful system shutdown, transaction rollback not required",(0>0),0) 
					} else {
						d $zu(9,"",x_" override, transaction rollback not required at startup",(0>0),0)
					}
				}
			}
			/* Mirroring aborts, other rollbacks continue, going on to the next file */ 
			if (STU="M") || (STU="MC") {
				;othererrlog bumps errcnt which causes MIRROR^JRNROLL to report failure
				do othererrlog(.errlist,"Mirror Transaction rollback aborted - Missing jrnfile: "_filelist(i))
				s abortquit=1
				quit  ;exit for loop and then we'll return because abortquit is set 
			} else {
				K filelist(i)
				s jroff=0
			}
		} else {
			do scanfile  ;build the transopen/transsys/etc arrays for the open journal file
			             ;returns with lastaddr=last record checked in this jrnfile
			S x=$zu(78,7,chan)
			I addr<0 {  
				W !,"Record error in ",filelist(i)
				W !,"Due to that, we cannot use this file for rollback.",! 
				K filelist(i)
			}   
		}
		if STU="M" {
			do $SYSTEM.Mirror.UpdateTransitionTime()
		}
		if logprogress {
			s sizeProcessed=sizeProcessed+filesize(i)
			if (sizeProcessed >= nextMsg) {
				s trancnt=0
				s tranid=""
				for  {
					s tranid=$O(tranopen(tranid))
					q:tranid=""
					s trancnt=trancnt+1
				}
				d $zu(9,"","Scanning for transactions processed "_$FN(sizeProcessed/1000,"",2)_"GB ("_$FN(sizeProcessed/filesize*100,"",0)_"%) of journal data, "_trancnt_" open transaction(s) exist.",0,0  /* Informational message */)
				do { 
					s nextMsg=nextMsg + msgInterval
				} while (sizeProcessed >= nextMsg)
			}
			s abortquit=$$recordProgress("scan",runguid,STU,i,.filesize,.origfilelist,
							.tranopen,.jrfilecnt,.transsys,.transbufnum,.nnRecs)
			quit:abortquit
		}
	}
 	quit:abortquit  ;If there was an error during mirror rollback, stop here (JO2141)
 	If ((cluconfig) && (lastjrnseqnum > ($zu(78,41,0)))) {
	 	d $zu(78,41,0,lastjrnseqnum+1)
 	}
 	if STU="MC",$D(tranopen) {
		s pid=""
		For  {
			S pid=$O(tranopen(pid)) 
			Quit:pid=""
			s remsysid=""
			For  {
				s remsysid=$O(tranopen(pid,remsysid),1,info) ;info= addr,jrnfilename,jrnfilecnt
				q:remsysid=""
			 	s ecpsysid=+$zu(34,22,remsysid)
			 	s tindex=+$P(info,",",1)
			 	s tfilecnt=+$P(info,",",3)
			 	if ecpsysid=0 {
			 	   s opentindex=+$ZU(67,19,pid)
			 	   if opentindex {
				 	   s opentfile=+$ZU(67,18,pid)
				 	   if (tindex=opentindex) && (tfilecnt=opentfile) {
					 	   k tranopen(pid,remsysid)
				 	   }
			 	   }
			 	} else {
				 	; pass remsysid here so we include the pid v. jobtype flag
 					if $ZU(34,26,remsysid,pid,tindex,tfilecnt) {
	 					k tranopen(pid,remsysid)
 					}
			 	}
		 	}
	 	}
	 	; Now that we've filtered out the currently open transactions, check the
	 	; journal file from wher we ended last time (lastaddr) through the current
	 	; end to see if any of the open transactions have been closed.
		if $D(tranopen) {
			s chan=$zu(78,5,filelist(jrfilecnt),0)
			I chan=-1 {
				W !,"Failed to reopen ",filelist(jrfilecnt)," to check for subsequent commits!"
				do othererrlog(.errlist,"Mirror Transaction rollback aborted - Failed to reopen jrnfile: "_filelist(jrfilecnt))
				quit  ;return
			}
			; lastaddr is where we left off at the last scan
			s jroff=lastaddr
			s i=jrfilecnt
			do scanfile
			S x=$zu(78,7,chan)
		}
		; At this point, anything left in tranopen() should be rolled back
 	}
 	if (STU="M") || (STU="MC") {
		s servicetype="ECPMIRs"
 	} else {
		s servicetype="ECP"
 	}
 	s x=""
	f  {
		s x=$O(^[ECPStateNS]%SYS("SERVICE",servicetype,x))  ;JO2141
		q:(x="") 
		if ($d(transbufnum(x))) {
			s $list(^[ECPStateNS]%SYS("SERVICE",servicetype,x),3)=transbufnum(x)  ;JO2141
		}
	}
	if ('$D(tranopen) && ($o(nnRecs(""))="")) {	;HYY1440,JO2141,GK243+
		d $zu(9,"","No open transactions to roll back",(0>0),0)
		If ('+$g(^[ECPStateNS]%SYS("JOURNAL","ROLLBACK","ECPRecover"),0)) {
			m ^[ECPStateNS]%SYS("JOURNAL","ROLLBACK","transsys")=transsys
			m ^[ECPStateNS]%SYS("JOURNAL","ROLLBACK","transbufnum")=transbufnum
			if (+$O(^[ECPStateNS]%SYS("SERVICE",servicetype,""))&&$d(transsys)&&$d(transbufnum)) {  ;JO2141
				set ^[ECPStateNS]%SYS("JOURNAL","ROLLBACK","ECPRecover")=1
				merge ^[ECPStateNS]%SYS("JOURNAL","ROLLBACK","filelist")=filelist
				set ^[ECPStateNS]%SYS("JOURNAL","ROLLBACK","jrfilecnt")=jrfilecnt
				Merge ^[ECPStateNS]%SYS("JOURNAL","ROLLBACK","nnRecs")=nnRecs
			}
		} else {
			  ;JO2141
		}
		goto exitroll  ;perform any necessary cleanup
	}
 	I STU'="S",'QUIETLY {
	 	if $$YN("We are to roll back open transactions. Continue","Y")="N" {
			goto exitroll  ;perform any necessary cleanup
	 	}
 	} 
rollback ; 3. Start rolling back open transactions, with everything journaled
	if $G(servicetype)="" {
		;STU="S" can come here skipping bldxopen and service type is
		; undefined so set it to ECP (because we know it isn't mirror
		; recovery)
		s servicetype="ECP"
	}
 	;jrnstat: bit 0 (start journaling), 1 (journal all), 2 (enable in process)
	if STU="C" {
		;STU="C" is cluster recovery at startup. Journaling is started by
		;CLUSTER^JRNROLL instead of here because ROLL will be called for each
		;cluster member that requires rollback. We don't want to start and
		;stop journaling each time through.
		s jrnstat=0  ;the exit code enables journaling if jrnstat=0
	} elseif $ZBITGET($ZVERSION(0),46) {
		s jrnstat=0
	} else {
		;enable journaling all globals, otherwise abort
		s jrnstat='($zu(78,22))
		i jrnstat {
			d ^JRNSTART 
			i '($zu(78,22)) {
				s $ze="[Failed to start journaling]" 
				d miscerrlog(checkerr,reporterr,.errlist)
				quit  ;abort
			}
		}
		i '$$CURRENT^%SYS.NOJRN() {
			s jrnstat=jrnstat+4 
			d ENABLE^%SYS.NOJRN
		}
	}
	i $G(^%SYS("JOURNAL","ROLLBACK")) { ;continue from last aborted rollback
 		m filelist=^%SYS("JOURNAL","ROLLBACK","filelist")
 		m tranopen=^%SYS("JOURNAL","ROLLBACK","tranopen")
		m transsys=^%SYS("JOURNAL","ROLLBACK","transsys")
		m transbufnum=^%SYS("JOURNAL","ROLLBACK","transbufnum")
		m nnRecs=^%SYS("JOURNAL","ROLLBACK","nnRecs")
	} elseif STU="S" { ;skip logging in globals in cluster failover, etc.
		m ^%SYS("JOURNAL","ROLLBACK","filelist")=filelist
		m ^%SYS("JOURNAL","ROLLBACK","tranopen")=tranopen
		m ^%SYS("JOURNAL","ROLLBACK","transsys")=transsys
		m ^%SYS("JOURNAL","ROLLBACK","transbufnum")=transbufnum
		m ^%SYS("JOURNAL","ROLLBACK","nnRecs")=nnRecs
		Set ^%SYS("JOURNAL","ROLLBACK")=1
	}
netdelay  ; Step 3.1 -- Build a list of delayed transactions and find the oldest one.
 	s delayfcnt=jrfilecnt+1,delayindex=0,delayed=0
 	// Update jrnfilecnt and delayindex with the first NN record we need to
 	// save for possible rescan for $inc
 	d getecpNNjrnpos()
	; Only delay during startup, not during cluster failover
	if (saveecptrans) {
		if ($d(tranopen) && +$o(transsys(0))) {
			do $zu(9,"","Delaying resolution of ECP transactions until ECP Recovery",(0>0),0)
		}
		s pid=""
		For  {
			S pid=$O(tranopen(pid)) 
			Quit:pid=""
			s remsysid=""
			For  {
				s remsysid=$O(tranopen(pid,remsysid)),ecpsysid=$zu(34,22,remsysid)
				Quit:remsysid=""
				If (ecpsysid) {
				    if ('$$netdelayIncludeECPTrans(STU,ecpsysid,pid)) {
				    } else {
					 ;PWCDEBUG
					Set ^[ECPStateNS]%SYS("JOURNAL","ROLLBACK","ECPTransactionsTmp",remsysid,pid)=tranopen(pid,remsysid)
					s delayed=1
					s i=+$p(tranopen(pid,remsysid),",",3)
					If (i<delayfcnt) {
						s delayfcnt=i
						s delayindex=+$p(tranopen(pid,remsysid),",")
					} elseif (i=delayfcnt) {
						If (+$p(tranopen(pid,remsysid),",")<delayindex) {
							s delayindex=+$p(tranopen(pid,remsysid),",")
						}
					}
					I $D(translevel(remsysid,pid)) {
						Merge ^[ECPStateNS]%SYS("JOURNAL","ROLLBACK","ECPTransactionsTmp",remsysid,pid)=translevel(remsysid,pid)
						Kill translevel(remsysid,pid)
					}
					Kill tranopen(pid,remsysid) ; This transaction no longer needs rollback
				    }
				}	/* End If (remsysid&&....) */
			}	/* End For  { s remsysid=... } */
		}	/* End For  { s pid=...} */
	}	/* End If (saveecptrans) */
 	If ('+$g(^[ECPStateNS]%SYS("JOURNAL","ROLLBACK","ECPRecover"),0)) {
		If (delayed) {
			Kill ^[ECPStateNS]%SYS("JOURNAL","ROLLBACK","ECPTransactions")
			Set ^[ECPStateNS]%SYS("JOURNAL","ROLLBACK","ECPJrnIndex")=delayindex_","_delayfcnt_","_##Class(%SYS.System).InstanceGUID()
			Merge ^[ECPStateNS]%SYS("JOURNAL","ROLLBACK","filelist")=filelist
			Merge ^[ECPStateNS]%SYS("JOURNAL","ROLLBACK","jrfilecnt")=jrfilecnt
			Merge ^[ECPStateNS]%SYS("JOURNAL","ROLLBACK","transsys")=transsys
			Merge ^[ECPStateNS]%SYS("JOURNAL","ROLLBACK","transbufnum")=transbufnum
			Merge ^[ECPStateNS]%SYS("JOURNAL","ROLLBACK","ECPTransactions")=^[ECPStateNS]%SYS("JOURNAL","ROLLBACK","ECPTransactionsTmp")
			Merge ^[ECPStateNS]%SYS("JOURNAL","ROLLBACK","nnRecs")=nnRecs
			Kill ^[ECPStateNS]%SYS("JOURNAL","ROLLBACK","ECPTransactionsTmp")
			Set:($S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0)) ^[ECPStateNS]%SYS("JOURNAL","ROLLBACK","JrnSeqNum")=$zu(78,41,0)
			Set ^[ECPStateNS]%SYS("JOURNAL","ROLLBACK","ECPRecover")=1
		} else {
			Merge ^[ECPStateNS]%SYS("JOURNAL","ROLLBACK","transsys")=transsys
			Merge ^[ECPStateNS]%SYS("JOURNAL","ROLLBACK","transbufnum")=transbufnum
			if (+$O(^[ECPStateNS]%SYS("SERVICE",servicetype,""))&&$d(transsys)&&$d(transbufnum)) {
				Merge ^[ECPStateNS]%SYS("JOURNAL","ROLLBACK","filelist")=filelist
				Merge ^[ECPStateNS]%SYS("JOURNAL","ROLLBACK","nnRecs")=nnRecs
				set ^[ECPStateNS]%SYS("JOURNAL","ROLLBACK","jrfilecnt")=jrfilecnt
				set ^[ECPStateNS]%SYS("JOURNAL","ROLLBACK","ECPRecover")=1   
			}
		}
	} else {
		Kill ^[ECPStateNS]%SYS("JOURNAL","ROLLBACK","ECPTransactionsTmp")
	}
	if $L($O(^[ECPStateNS]%SYS("JOURNAL","ROLLBACK","ECPTransactions",""))) {
		if (STU'="M") && (STU'="MC") {
			;The following will prevent STU from letting users in if we fail
			;to establish the context required to support delaying transaction
			;rollback.
			S ^STU("required","ECPTRANS")=""
		}
	}
	 ;; GK332
dorollback ; Step 3.3 -- rollback the non-delayed transactions
	m transave=tranopen
 	d $zu(9,"","Rolling back transactions ...",(0>0),0)
 	; NB: we assume the job is not doing TP on behalf of other jobs at the moment,
 	; thus when we are done, we simply reset ($zu(34,9,0,0)) rather than save/`.
	s rolltype=$CASE(STU,"M":"MIRRORRESTORE",
							"MC":"MIRRORRESTORE",
							"RM":"MIRRORRESTORE",
							"C":"CLUSTERRECOVERY",
							:"RESTORE")
	if STU="",$g(crashcsn)'="" {
	    s rolltype="CLUSTERRECOVERY"
	}
	k ^||ISC.ROLLBACK.bitset
	if logprogress {
		s nextMsg=msgInterval
		s sizeProcessed=0
		if runguid'="" {
			k ^SYS("ROLLBACK","TMP",runguid,"OpenTransaction")
			merge ^SYS("ROLLBACK","TMP",runguid,"OpenTransaction")=tranopen
		}
	}
	if $E(STU)="R",$G(phase)="rollback" {
		; for retry, fileindex is the last file we processed so start
		; with the next one (it was the value of i after we returned from
		; start^ROLLBACK).
		s i=fileindex
	} elseif STU="S" {
		s chkpntlmt=1000
		i $g(^SYS("ROLLBACK","CHKPNT"))="" { ;no prior checkpoint 
			s i="" // start from the newest jrn file
			s ^SYS("ROLLBACK","CHKPNT")=","
			s ^SYS("ROLLBACK","CHKPNT","FILE")=""
		} else {
			s chkpntoff=^SYS("ROLLBACK","CHKPNT")
			i chkpntoff { ;chkpntoff is just an offset
				s i=$g(^SYS("ROLLBACK","CHKPNT","FILE"))
				s jrnoffmsg="offset "_(+chkpntoff)_" of "
			} else { ;chkpntoff has the form of ","_i
				s i=$p(chkpntoff,",",2)
				s jrnoffmsg=""
			}
			i $o(filelist(i),-1,jrnf)'="" d $zu(9,"","Continuing from "_jrnoffmsg_$g(jrnf),(0>0),0)
			s logskiprb=0 ;suppress initial "skip rollback" msgs
		}
	} else {
		S i="" 
	}
	do {
		S i=$O(filelist(i),-1,%jrnfile)
		Q:i=""
		s chan=$zu(78,5,%jrnfile,0)
		if chan=-1 {
			do othererrlog(.errlist,"Failed to open "_%jrnfile_" during rollback")
			quit  ;abort rollback
		}
		do $zu(78,6,chan)
		i $g(chkpntoff) {
			s addr=+$g(chkpntoff)_","_$case($ZBITGET($ZVERSION(0),46),0:$case($f(%jrnfile,";"),0:$e(%jrnfile,*-8-$l($p(%jrnfile,".",$l(%jrnfile,"."))),*-$case($e(%jrnfile,*)="z",0:0,1:1)),:$e(%jrnfile,*-8-$l($p(%jrnfile,".",$l(%jrnfile,"."))),$f(%jrnfile,";")-2)),:%jrnfile)
			k chkpntoff ;use chkpntoff only the 1st time around
		} else {
			s addr=$zu(78,18,0)_","_$case($ZBITGET($ZVERSION(0),46),0:$case($f(%jrnfile,";"),0:$e(%jrnfile,*-8-$l($p(%jrnfile,".",$l(%jrnfile,"."))),*-$case($e(%jrnfile,*)="z",0:0,1:1)),:$e(%jrnfile,*-8-$l($p(%jrnfile,".",$l(%jrnfile,"."))),$f(%jrnfile,";")-2)),:%jrnfile)
		}
		Q:+addr'>0  ;abort rollback
		if STU="MC" {
			do start^ROLLBACK(.tranopen,addr,-1,checkerr,1,.dblist,rolltype,,.chkpntlmt,.logskiprb)
		} else {
			do start^ROLLBACK(.tranopen,addr,-1,checkerr,1,,rolltype,,.chkpntlmt,.logskiprb)
		}
		i chkpntlmt {
			s ^SYS("ROLLBACK","CHKPNT")=","_i
			s ^SYS("ROLLBACK","CHKPNT","FILE")=i
		}
		do $zu(78,7,chan)
		; close transactions that have been completely rolled back. Don't remove
		; the ^%SYS() data or commit any transaction which is listed in the 
		; tranerror() array
		s pid="" 
		f  {
			s pid=$o(transave(pid)) 
			q:pid=""
			s sys="" 
			f  {
				s sys=$o(transave(pid,sys)) 
				q:sys=""  
				if '$d(tranopen(pid,sys)) {
					k transave(pid,sys) 
					; don't commit the transaction if there was a rollback error
					if '$D(tranerror(pid,sys)) {
						if ($zu(34,9,pid,sys)!$zu(34,4)!$zu(34,9,0,0))  ;commit the transaction in the journal
						k:STU="S" ^%SYS("JOURNAL","ROLLBACK","tranopen",pid,sys)
					}
				}
			}
		}
		if STU="M" {
			do $SYSTEM.Mirror.UpdateTransitionTime()
		}
		if $D(tranopen), logprogress {
			s sizeProcessed=sizeProcessed+filesize(i)
			if (sizeProcessed >= nextMsg) {
				s trancnt=0
				s tranid=""
				for  {
					s tranid=$O(tranopen(tranid))
					q:tranid=""
					s trancnt=trancnt+1
				}
				d $zu(9,"","Rollback in progress, processed "_$FN(sizeProcessed/1000,"",2)_"GB ("_$FN(sizeProcessed/filesize*100,"",0)_"%) of journal data, "_trancnt_" transaction(s) remain open",0,0  /* Informational message */)
				do { 
					s nextMsg=nextMsg + msgInterval
				} while (sizeProcessed >= nextMsg)
			}
			if runguid'="" {
				; recordProgress reads the variables i, filelist, filesize, tranopen
				s abortquit=$$recordProgress("rollback",runguid,STU,i,.filesize,
												.filelist,.tranopen,.jrfilecnt,.transsys,
												.transbufnum,.nnRecs)
				quit:abortquit
			}
		}
	} while ($D(tranopen)'=0)
	; If we're tracking errors in errlist (checkerr=2) and there were
	; some errors then stop here and leave ^%SYS("....") set up so we can
	; restart transaction rollback if the user chooses to do so.
	if STU="S"&((checkerr'=2) ! '$G(errlist)) {
		;Keep ^%SYS("JOURNAL","ROLLBACK","transsys") around for ECP Recovery time.
		k ^SYS("ROLLBACK","CHKPNT","FILE")
		k ^SYS("ROLLBACK","CHKPNT")
		k ^%SYS("JOURNAL","ROLLBACK","tranopen") 
		k ^%SYS("JOURNAL","ROLLBACK","filelist") 
		s ^%SYS("JOURNAL","WIJFILE")=$zu(78,3)_","_($ZU(78,26))
		s ^%SYS("JOURNAL","ROLLBACK")=0
	}
exitroll ;
 s $zt="" 
 if '$G(abortquit,0),runguid'="" {
	 k ^SYS("ROLLBACK","TMP",runguid)
 }
 i $ze]"" ztrap $ze  ;the error trap of the caller should handle jrnstat
 i jrnstat\4 {
	 d DISABLE^%SYS.NOJRN 
	 s jrnstat=jrnstat#4
 }
 i jrnstat,STU'="S" {
	 d INT^JRNSTOP()
 }
 k ^||ISC.ROLLBACK.bitset
 Q  ;done with ROLL()
scanfile ;subroutine of bldxopen
	s NNMask=$system.ECP.GetNumNN()
 	d $zu(9,"","  Scanning "_filelist(i),(0>0),0)
 	 ;JO2141
	S x=$zu(78,6,chan)
	s addr=0
	i jroff {
		s addr=$zu(78,18,jroff)
		s jroff=0
	}
	i addr<0 {
		s addr=0 ;reset addr in case jroff wasn't valid
	}
	d ##class(%SYS.Journal.System).GetDejournalReaderSettings(.cachesize,.readahead,.disableaio)
	s rc=$zu(78,104,cachesize,1,readahead,disableaio)
	; transsys(ecpsysid) is an array of remote systems that have started a
	; transaction since the last JRNBIGNET journal entry for that system.  
	; This information goes into netsyspnt_s->netbig_s_recovery during 
	; recovery.  We also reconcile this list of servers with the list of 
	; servers that request recovery during the recovery interval, so we d
	; transbufnum(ecpsysid) is an array of remote systems for which we have an
	; up-to-date request buffer number.
	if runguid'="" {
		s oneGB=1024*1024*1024
		s chkpnt=oneGB
	}
	F  {
		s lastaddr=addr  ;for returning to bldxopen (JO2604)
		S addr=$zu(78,17,addr) 
		Q:addr'>0
		if runguid'="",addr>=chkpnt {
			if $G(^SYS("ROLLBACK","TMP",runguid,"STOP"))'="" {
				s addr=-1  ;so bldxopen doesn't report an error
				quit
			}
			s chkpnt=chkpnt+oneGB
		}
		S itype=$zu(78,80,addr)
		i itype=(128+6) g incrType
		s type=itype#128
		goto $case(type,5:commitType,
		                4:begTransType,
				15:bigNetType,
				21:trolevelType,
				16:beginLevelType,
				18:tcommitLevelType,
				17:tcommitPendLevelType,
				22:incrTypeNoClu,
				24:incrTypeNoClu,
				:skipRecord)
incrType ;
		if (cluconfig) {
			s tmpjrnseq=$zu(78,11,addr) 
			s:(tmpjrnseq>lastjrnseqnum) lastjrnseqnum=tmpjrnseq
		}
incrTypeNoClu ; count requests that could be recovered from journal
		S remsysid=$ZU(78,25,addr),ecpsysid=$zu(34,22,remsysid)
		Set:ecpsysid transsys(ecpsysid)=$G(transsys(ecpsysid),0)+1
		if $i(hasInc(ecpsysid)) 
		continue
commitType ;				
		S pid=$zu(78,10,addr),remsysid=$ZU(78,25,addr),ecpsysid=$zu(34,22,remsysid)
		 ;PWCDEBUG
		K tranopen(pid,remsysid) 
		K translevel(remsysid,pid)
		// if a remote commit and not a rollback commit
		Set:(ecpsysid && (itype = type)) transsys(ecpsysid)=$G(transsys(ecpsysid),0)+1
		kill rollbackstart(remsysid,pid)
		continue
begTransType ;
		S pid=$zu(78,10,addr),remsysid=$ZU(78,25,addr),ecpsysid=$zu(34,22,remsysid)
		 ;PWCDEBUG
		;The journal file count of transactions in the most recent journal file
		; is jrfilecnt, which is when i is 1, so set up for each transaction to
		; get the proper jrnfilecnt (PWC640)
		S tranopen(pid,remsysid)=addr_","_$case($ZBITGET($ZVERSION(0),46),0:$case($f(filelist(i),";"),0:$e(filelist(i),*-8-$l($p(filelist(i),".",$l(filelist(i),"."))),*-$case($e(filelist(i),*)="z",0:0,1:1)),:$e(filelist(i),*-8-$l($p(filelist(i),".",$l(filelist(i),"."))),$f(filelist(i),";")-2)),:filelist(i))_","_i
		K translevel(remsysid,pid) 
		Set:ecpsysid transsys(ecpsysid)=$G(transsys(ecpsysid),0)+1
		continue
bigNetType ;				
		S remsysid=$ZU(78,25,addr),ecpsysid=$zu(34,22,remsysid)
		Set transsys(ecpsysid)=0 ; Reset count to zero
		Set reqnum=($zu(78,45,addr))
		Set transbufnum(ecpsysid)=reqnum
		// If the reqnum == 0, then it's a new ECP session, cleanup any old info
		if ('reqnum) {
		   Kill nnRecs(ecpsysid)
		} // 'reqnum
		Set idx=($i(nnRecs(ecpsysid)) # NNMask)
		s nnRecs(ecpsysid,idx)=reqnum_","_addr_","_$case($ZBITGET($ZVERSION(0),46),0:$case($f(filelist(i),";"),0:$e(filelist(i),*-8-$l($p(filelist(i),".",$l(filelist(i),"."))),*-$case($e(filelist(i),*)="z",0:0,1:1)),:$e(filelist(i),*-8-$l($p(filelist(i),".",$l(filelist(i),"."))),$f(filelist(i),";")-2)),:filelist(i))_","_i_","_$g(hasInc(ecpsysid),0)
		// reset $inc counter
		kill hasInc(ecpsysid)
		continue
trolevelType ;				
		S pid=$zu(78,10,addr),remsysid=$ZU(78,25,addr),ecpsysid=$zu(34,22,remsysid)
		set trlvl=$zu(78,60,addr)
		set:remsysid rollbackstart(remsysid,pid,trlvl)=1
		continue
beginLevelType ;				
		S pid=$zu(78,10,addr),remsysid=$ZU(78,25,addr),ecpsysid=$zu(34,22,remsysid)
		if saveecptrans&&ecpsysid&&$d(tranopen(pid,remsysid)) {
			set trlvl=$zu(78,60,addr)
			 ;PWCDEBUG
			;The journal file count of transactions in the most recent journal file
			; is jrfilecnt, which is when i is 1, so set up for each transaction to
			; get the proper jrnfilecnt (PWC640)
			S translevel(remsysid,pid,trlvl)=addr_","_i
			Set transsys(ecpsysid)=$G(transsys(ecpsysid),0)+1
		}
		continue
tcommitLevelType ;
tcommitPendLevelType ;				
		S pid=$zu(78,10,addr),remsysid=$ZU(78,25,addr),ecpsysid=$zu(34,22,remsysid)
		if saveecptrans && ecpsysid && $d(tranopen(pid,remsysid)) {
			set trlvl=$zu(78,60,addr)
			 ;PWCDEBUG
			;The journal file count of transactions in the most recent journal file
			; is jrfilecnt, which is when i is 1, so set up for each transaction to
			; get the proper jrnfilecnt (PWC640)
			Kill translevel(remsysid,pid,trlvl)
			;; if not a rollback commit
			Set:(type = itype) transsys(ecpsysid)=$G(transsys(ecpsysid),0)+1
			kill rollbackstart(remsysid,pid)
		}
		continue
skipRecord ;	
		if (cluconfig) {
			s tmpjrnseq=$zu(78,11,addr) 
			s:(tmpjrnseq>lastjrnseqnum) lastjrnseqnum=tmpjrnseq
		}
	}  /* for loop */
	q  ;return from scanfile to bldxopen
getecpjrnpos(remsysid) 
	// find oldest NN jrn record 
	set NNMask=$system.ECP.GetNumNN()
 	s idx=($g(nnRecs(remsysid),0)+1) # NNMask
	s v=""
	for i=1:1:NNMask+1 {
	    s idx=$i(idx) # NNMask
	    q:($d(nnRecs(remsysid,idx),v)=1)&&($p(v,",",4) '= 0)
	}
	q:i=NNMask+1 ""
 	q v
getecpNNjrnpos()
    if (cluconfig) {
        // DLM cluster only feature
        // track min offset for jrn rec scan for duplication
	set remsysid=""
	for  {
		s remsysid=$o(nnRecs(remsysid))
		q:('remsysid)
		set delayed=1
		s tmp=$$getecpjrnpos(remsysid)
		if (tmp '= "") {
		   s fcnt=+$p(tmp,",",4) // get file #
		   s tmp=$p(tmp,",",2)   // get addr
		   If (fcnt<delayfcnt) {
			s delayfcnt=fcnt
			s delayindex=+tmp
		   } elseif (fcnt=delayfcnt) {
			If (+tmp<delayindex) {
				s delayindex=+tmp
			}
		   }
		}
	}
    } else {
	s:$o(nnRecs("")) delayed=1
    }
    q
setupProgressReporting ;
	if (STU="S") || (STU="M") || ($E(STU)="R") {  ;R = restart
		s runguid=$SYSTEM.Util.CreateGUID()
		while $D(^SYS("ROLLBACK","TMP",runguid)) {
			; this really should never exist but if we somehow get an
			; existing guid, pick another one.
			s runguid=$SYSTEM.Util.CreateGUID()
		}
		s filesize=0  ;in MB
		set i=""
		F  {
			s i=$o(filelist(i),1,FN)
			q:(i="")
			s filesize(i)=+$S($ZU(78,22,FN):$p($zu(78,22,FN,99),",",31+1),1:-1)/(1024*1024)
			s filesize=filesize+filesize(i)
		}
		if STU="S" {
			s type="system startup"
		} else {
			; STU="M"
			s type="mirror primary startup"
		}
		s ^SYS("ROLLBACK","TMP",runguid)="Rollback at "_type_" at "_$ZDATETIME($H)_" ("_filesize_"MB)"
		s jobnum=$ZU(61)
		s ^SYS("ROLLBACK","TMP",runguid,"jobnum")=jobnum
		s ^SYS("ROLLBACK","TMP",runguid,"jobid")=$ZU(61,30,jobnum)
		s ^SYS("ROLLBACK","TMP",runguid,"pid")=$J
		if filesize>5000 {  ;5GB
			d $zu(9,"","There is "_$FN(filesize/1000,"",2)_"GB of journal data to process for transaction rollback.",0,0  /* Informational message */)
			s logprogress=1
		}
		s msgInterval=filesize\10
		if msgInterval<1 s msgInterval=1  ;(can happen during debugging)
		if msgInterval>15000 {
			s msgInterval=10000
		}
		s nextMsg=msgInterval
		s sizeProcessed=0
	}
	quit  ;return to caller
}  ; end of ROLL() 
recordProgress(caller,runguid,STU,index,filesize,filelist,tranopen,
									jrfilecnt,transsys,transbufnum,nnRecs) public {
	; subroutine of bldxopen and dorollback which to post our
	; progress and check for operator requested abort. Called
	; after we've finished scanning or processing a file (just completed
	; file #i) before we move on to the next file.
	;
	; Returns 0 to continue or 1 to abort.
	;
	; We don't log when we abort so that this looks like a successful rollback to
	; the caller (System Startup (STU=S) or Mirror Primary Startup (STU=M).
	; The operator has told us to bring the system up for 'normal use' 
	; without completing rollback, presumably because there is some long
	; running transaction they don't care about/will deal with themselves.
	if '$D(^SYS("ROLLBACK","TMP",runguid,"FileList")) {
		; these don't change so they only need to be set once
		s ^SYS("ROLLBACK","TMP",runguid,"STU")=STU
		m ^SYS("ROLLBACK","TMP",runguid,"FileList")=filelist
		m ^SYS("ROLLBACK","TMP",runguid,"FileSize")=filesize
	}
	;
	s ^SYS("ROLLBACK","TMP",runguid,"Phase")=caller ;scan or rollback
	s ^SYS("ROLLBACK","TMP",runguid,"LastIndexProcessed")=index ;last file processed
	s ^SYS("ROLLBACK","TMP",runguid,"LastFileProcessed")=filelist(index)
	;
	k ^SYS("ROLLBACK","TMP",runguid,"OpenTransaction")
	m ^SYS("ROLLBACK","TMP",runguid,"OpenTransaction")=tranopen
	if $G(^SYS("ROLLBACK","TMP",runguid,"STOP"))'="" {
		; Record some more variables we'll need to resume later
		; but that we don't use for status reporting (eg. we don't
		; publish these on every call, just when we're stopping).
		;
		m ^SYS("ROLLBACK","TMP",runguid,"Jrfilecnt")=jrfilecnt
		m ^SYS("ROLLBACK","TMP",runguid,"TransSys")=transsys
		m ^SYS("ROLLBACK","TMP",runguid,"TransBufnum")=transbufnum
		m ^SYS("ROLLBACK","TMP",runguid,"nnRecs")=nnRecs
		;
		s pendingIndex=$I(^SYS("ROLLBACK","PENDING"))
	 	while $D(^SYS("ROLLBACK","PENDING",pendingIndex)) {
		 	; This shouldn't be defined but if it is, pick a new one. I suppose
		 	; we could kill it off instead....
			s pendingIndex=$I(^SYS("ROLLBACK","PENDING"))
	 	}
		s msg="Rollback ("_STU_") termininating during transaction "_caller
		s msg=msg_" due to operator request. Last file processed: "_filelist(index)
		s msg=msg_$C(13,10)_"Added to pending transaction rollback list as item #"_pendingIndex
		d $zu(9,"",msg,1 /* broadcast and log message*/,1  /* Warning */)
	 	l +^SYS("ROLLBACK","PENDING",pendingIndex)
	 	merge ^SYS("ROLLBACK","PENDING",pendingIndex)=^SYS("ROLLBACK","TMP",runguid)
		k ^SYS("ROLLBACK","TMP",runguid)
	 	l -^SYS("ROLLBACK","PENDING",pendingIndex)
		quit 1  ;bldxopen/dorollback will abort
	}
	quit 0
}
netdelayIncludeECPTrans(STU,ecpsysid,pid) {
	s service=$CASE(STU,"M":"ECPMIRs","S":"ECP",:"")
	;include all transactions if not Mirror Primary Startup or System startup
	quit:service="" 1
	if $G(^%SYS("SERVICE",service,ecpsysid))'="" {
		quit 1
	}
	quit 0
}
   ;
   ; $$curfile()
   ; returns current journal file name, if any, else ""
curfile() {
	try {
		s rc=$p($zu(78,4)_","_$zu(78,3),",",2)
	} catch {
		s rc=""
	}
	quit rc
}
miscerrlog(checkerr,reporterr,errlist) { ;
	s $ZT="miscerrlog2"
	; for checkerr=2 we record errors in the errlist array. Here we
	; have a unexpected problem (eg. not during a database set/kill).
	; These are recorded in the "misc" (as opposed to "db") subnode.
	s errlist=$G(errlist)+1
	if checkerr=2 {
		s index=$I(errlist("misc"))
		s errlist("all",errlist)=$LISTBUILD($G(%jrnfile),$g(adr),$ZE)
		s errlist("misc",index)=$LISTBUILD($G(%jrnfile),$G(adr),$ZE)
	}
miscerrlog2 ;
	d $zu(9,"","Unexpected error in JRNROLL: "_$ze,(1>0),1)
	q
}
othererrlog(errlist,errmsg) { ;
 	s errlist=$i(errlist)
	s errlist("all",errlist)=errmsg
	s z=$i(errlist("other"))
	s errlist("other",z)=errmsg
	do $zu(9,"",errmsg,(1>0),1)
}
Manage() PUBLIC {
	w !
	; Normally there is at most one active (if any) and maybe
  	; one or more pending which were interrupted.
	do getTransactionStatus(.active,.pending)
	if 'active && 'pending {
	    w "There are no rollbacks in progress nor any interrupted rollbacks",!
	    w "defered to be processed later.",!
	    quit
	}
	W !,"This utility allows you to interrupt transaction rollback so that the system"
	W !,"can continue. It is designed for use when transaction rollback is taking a long"
	W !,"time and you wish to make the system available without finishing the rollback."
	w !
	W !,"If you interrupt transaction rollback using this utility, the system will"
	W !,"automatically continue without finishing the rollback. The incomplete"
	W !,"rollback operation will be recorded and you can resume it later, after the"
	W !,"system has returned to normal operation. The following cautions apply when"
	W !,"resuming an interrupted rollback: some data affected by the rollback may have"
	W !,"changed and will be skipped, the rollback will occur without application"
	W !,"locking, and any partial transactions rolled back may have already been visible"
	W !,"to the application."
	w !
	w !,"Rollback begins with a ""scan"" phase which scans the journal files forwards to"
	w !,"build a list of open transactions. Then, in the ""rollback"" phase, it traverses"
	w !,"the journal files backwards, rolling back any open transactions from that list."
	w !,"You can display the phase and the transaction list, but in scan phase, the list"
	w !,"is not finalized. During the rollback phase, transactions will be removed from "
	w !,"the list as each rollback completes."
	w !
	w !,"It is usually best to wait for any recent open transactions to be rolled back"
	w !,"in the rollback phase before interrupting the rollback of any old transactions."
	w !!
  	do DisplayRollbackDetails
MenuTop ;
  	k MENU
	s MENU(1)="Restart pending rollback"
  	s MENU(2)="Interrupt transaction rollback"
  	s MENU(3)="Redisplay rollback information"
  	s MENU(4)="Delete pending rollback information"
	;
	s Value=""
	s Status=##class(%Library.Prompt).GetMenu("Option?",.Value,.MENU,,8+128+4)
	w !  ;not sure where %Library.Prompt leaves the cursor
 	i (+Status=0)||(Status=2)||(Value="") q
	do getTransactionStatus(.active,.pending)
	if 'active && 'pending {
	    w "There are no rollbacks in progress nor any interrupted rollbacks",!
	    w "defered to be processed later.",!
	    quit
	}
 	do $case(Value,	1:RestartPending,
 					2:InterruptRollback,
 					3:DisplayRollbackDetails,
 					4:DeletePending,
 					:IllegalValue)
	goto MenuTop
InterruptRollback ;
	if 'active {
		w "Transaction rollback is not currently in progress",!
		h 1
		quit
	}
	s id="",cnt=0
	k MENU  ;erase old menu
	for i=1:1 {
		s id=$O(active(id),1,val)
		q:id=""
		s list(i)=id
		s MENU(i)=val
		s cnt=cnt+1
	}
	if cnt>1 {
		s Value=""
		s Status=##class(%Library.Prompt).GetMenu("Select operation to interrupt?",.Value,.MENU,,8+128+4)
 		i (+Status=0)||(Status=2)||(Value="") q
	} else {
		s Value=1
	}
	w "Operation: ",!
	w ?5,MENU(Value),!
	w !,"The system will continue without finishing rollback."
	r !,"Really interrupt this rollback operation? <No> ",resp
	w !
	if "Yy"'[$E(resp_"X") quit
	s id=list(Value)
	d $zu(9,"","Interrupting transaction rollback id: "_id,0,0  /* Informational message */)
	s ^SYS("ROLLBACK","TMP",id,"STOP")="Interrupted by user at "_$ZDATETIME($H)
	w "Posted request to interrupt rollback id: ",id
	h 1
	quit
IllegalValue ;
	W "Unsupported option #",Value,!
	goto MenuTop
DisplayRollbackDetails ;
	s header=1
	s index=1
	do getTransactionStatus(.active,.pending)
	if active {
		w "Rollback operations currently in progress",!
		s id=""
		f  {
			s id=$O(active(id))
			q:id=""
			k ref
			merge ref=^SYS("ROLLBACK","TMP",id)
			do displayDetails(header,index,.ref)
			s index=index+1
			s header=0
		}
	}
	if pending {
		w "Pending operations queued for restart",!
		s id=""
		f  {
			s id=$O(pending(id))
			q:id=""
			k ref
			merge ref=^SYS("ROLLBACK","PENDING",id)
			do displayDetails(header,index,.ref)
			s index=index+1
			s header=0
		}
	}
	quit	
RestartPending ;
	if 'pending {
		w "There are no pending rollback operations to restart",!
		h 1
		quit
	}
	s id="",cnt=0
	k MENU  ;erase old menu
	for i=1:1 {
		s id=$O(pending(id),1,val)
		q:id=""
		s list(i)=id
		s MENU(i)=val
		s cnt=cnt+1
	}
	if cnt>1 {
		s Value=""
		s Status=##class(%Library.Prompt).GetMenu("Select operation to resume?",.Value,.MENU,,8+128+4)
 		i (+Status=0)||(Status=2)||(Value="") q
	} else {
		s Value=1
	}
	w "Operation: ",!
	w ?5,MENU(Value),!
	r "Confirm restart of this rollback operation? <No> ",resp
	w !
	if "Yy"'[$E(resp_"X") quit
	s id=list(Value)
	d $zu(9,"","Restarting suspended transaction rollback id: "_id,0,0  /* Informational message */)
	j restartROLL(id)::5
	if '$T w "Failed to job transaction rollback handler",!
	h 1
	quit
DeletePending ;
	if 'pending {
		w "There are no pending rollback operations to delete",!
		h 1
		quit
	}
	s id="",cnt=0
	k MENU  ;erase old menu
	for i=1:1 {
		s id=$O(pending(id),1,val)
		q:id=""
		s list(i)=id
		s MENU(i)=val
		s cnt=cnt+1
	}
	if cnt>1 {
		s Value=""
		s Status=##class(%Library.Prompt).GetMenu("Select operation to delete?",.Value,.MENU,,8+128+4)
 		i (+Status=0)||(Status=2)||(Value="") q
	} else {
		s Value=1
	}
	w "Warning: Deleting a pending rollback should only be done in special circumstances",!
	w "         and is not reversible",!
	w "Operation: ",!
	w ?5,MENU(Value),!
	r "Confirm the removal of this rollback operation? <No> ",resp
	w !
	if "Yy"'[$E(resp_"X") quit
	s id=list(Value)
	d $zu(9,"","Deleting suspended transaction rollback id: "_id,0,0  /* Informational message */)
	;Kill the node in a transaction so its contents are journaled for historical purposes
	tstart
	k ^SYS("ROLLBACK","PENDING",id) 
	tcommit	
	quit
}
restartROLL(id) PUBLIC {
	s STU="R^"_id
	merge save=^SYS("ROLLBACK","PENDING",id)
	s checkerr=2
	s reporterr=1
	try {
		do ROLL(STU,1,,,,,,,checkerr,reporterr,.errlist)
		if +$G(errlist) {
			d $zu(9,"","Transaction rollback id #"_id_" encountered "_errlist_" errors - requeued",1 /* broadcast and log message*/,1  /* Warning */)
			if '$D(^SYS("ROLLBACK","PENDING",id)) {
				; If ROLL didn't restore the pending request, restore it here
				merge ^SYS("ROLLBACK","PENDING",id)=save
			}
		}
	} catch {
		merge ^SYS("ROLLBACK","PENDING",id)=save
	    d $zu(9,"","Requeued pending transaction rollback id #"_id_" -  Caught error: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	}
}
displayDetails(header,id,array) {
	new %transinfo,%tref
	if $G(array)="" {
		; Might not exist if the entry was killed after we
		; saw it in the $O() loop but before we made a copy of it.
		quit
	}
	s phase=$G(array("Phase"))
	s lastIndex=$G(array("LastIndexProcessed"))
	m %transinfo=array("OpenTransaction")
	;m filelist=array("FileList")
	;m filesize=array("FileSize")
	if phase="scan" {
		; processes files from start->end so the files remaining
		; are from lastindex+1 to end.
		s start=lastIndex+1
		s end=$O(array("FileSize",""),-1)
	} else {
		; rollback processes files from end->start so the files remaining
		; are start->last-1
		s start=$O(array("FileSize","")) ;1st file# in list
		s end=lastIndex-1
	}
	s sizeleft=0
	s filesleft=end-start+1
	for i=start:1:end {
		s sizeleft=sizeleft+array("FileSize",i)
	}
	s tcount=0
	k translist,tfilelist
	s tfilecnt=0
	if $d(%transinfo) {
		s %tref=$Q(%transinfo(""),1,val)  ;val = addr,jrnshortname,jrnfilecnt
		for  {
			quit:%tref=""
			s tcount=tcount+1
			s addr=$P(val,",",1)
			s jrnfilename=$P(val,",",2)
			s jrnfilecnt=$p(val,",",3)
			s tfilelist(jrnfilecnt)=jrnfilename
			s x=$I(tfile(jrnfilecnt))
			if x=1 s tfilecnt=tfilecnt+1  ; # of different files
			s translist(jrnfilecnt,addr)=""
			s %tref=$Q(@%tref,1,val)
		}
	}
	if (header) {
		w ?5,"ID",?10,"Phase",?20,"MB Remaining",?35,"Current Open Transaction Count",!
	}
	w ?5,id,?10,phase,?20,sizeleft,?35,tcount,!
	w ?10,array,!
	if tfilecnt>5 {
		 w ?10,"Open transactions involve more than 5 files",!
	} else {
		s filecnt=""
		for  {
			s filecnt=$O(tfile(filecnt),1,val)  ;val = # of open transaction in this file
			q:filecnt=""
			s addr=$O(translist(filecnt,"")) ;earliest open transaction
			w ?10
			w tfilelist(filecnt)," has ",val," open transaction(s) starting at offset ",addr
			w !
		}
	}
	w ?10,filesleft," file(s) remaining to process",!
}
getTransactionStatus(active,pending) public {
	k active
	s active=0
	s id=""
	for  {
		s id=$O(^SYS("ROLLBACK","TMP",id),1,val)
		q:id=""
		s jobnum=$G(^SYS("ROLLBACK","TMP",id,"jobnum"))
		s jobid=$G(^SYS("ROLLBACK","TMP",id,"jobid"))
		s pid=$G(^SYS("ROLLBACK","TMP",id,"pid"))
		s curpid=$ZU(61,jobnum) ;"" or 0 if the jobnum isn't a valid process
		if +curpid'=0 {
			s curjobid=$ZU(61,30,jobnum)
			if curpid=pid,curjobid=jobid {
				s active=active+1
				s active(id)=val
			}
		}
	}
	k pending
	s pending=0
	s id=""
	for  {
		s id=$O(^SYS("ROLLBACK","PENDING",id),1,val)
		q:id=""
		if $G(val)'="" {
			s pending=pending+1
			s pending(id)=val
		}
	}
	quit
}
YN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YN"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"yn","YN") I "^YN"'[R W "  enter Yes or No, please"
 S POP=(R="^") W $E($S(R="N":"No",R="Y":"Yes",1:""),$L(X)+1,3) Q R
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/FILEINC.inc#1 $ ($Change: 7440104 $) */
 ; BITWISE.INC
FIXDIR(dir) ;procedure, dir is passed by reference
 Q:dir=""
 Q:$A(dir,$L(dir))=$A($s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""))
 s dir=dir_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")
 Q
fixdir(dir) ;function
 Q:dir="" ""
 Q:$A(dir,$L(dir))=$A($s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")) dir
 Q dir_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")
basename(f) ;similar to basename on UNIX
 Q $P(f,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""),1,$L(f,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""))-1)_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")
appdir(d1,d2) ;use $zu(12,d2) to append d2 to canonic dir
 S d1=d1_d2
 Q d1
VALIDIR(dir) ;validate directory dir and create it if dir doesn't exist
 new flag
 s flag=1
 g vdir2
validir(dir,flag) ;validate directory dir and optionally create it if it
vdir2 ; VALIDIR(dir) comes here with flag set to 1
 quit:$$ChkDirOrSpecEXISTS(dir)'="" 1   ; dir is valid and exists
 quit:$$ChkDirVALID(dir)="" 0    ; dir is not valid
 i flag'=1 q 0  ; flag says don't create, return failure
 new x
 set x=$$mkdir(dir)  ; returns 0 for success, 1 for failure
 q:x=1 0  ; failed to create
 quit:$$ChkDirOrSpecEXISTS(dir)="" 0   ; it doesn't we failed
 q 1  ; success
mkdir(dir) ;create a new directory
 q '##class(%Library.File).CreateDirectoryChain(dir)
jrnshort(jf,short) ;get/set short form of a journal file name FIXME HYY1999
         N (jf,short)
         S len=$L($P(jf,";"))
         Q:$G(short)="" $E(jf,len-11,len) ;"GET" form
         S $E(jf,len-11,len)=short ;"SET" form
         Q jf
GJrnPrefix(jf) ;extract prefix from the journal file name jf
         N (jf)
         S fname=$P(jf,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""),$L(jf,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")))       
         Q $e(fname,1,$l($p(fname,"."))-8)
GetJrnFileName(path) { 
	i $f(path,"/") q $p(path,"/",$l(path,"/")) ;presumably a Unix path
	if $f(path,"\") q $p(path,"\",$l(path,"\")) ;presumably a Windows path
	s vmsfile=$p(path,"]",2) i vmsfile="" q path ;a name only, not a path
	q $p(vmsfile,";") ;return name from a VMS path without trailing ";"
}
dirinvalidmsg(dir1,dir2) 
 n valid1,valid2,cnt,msg
 s valid1=$$VALIDIR(dir1),valid2=$$VALIDIR(dir2)
 s cnt=valid1+valid2 ; cnt = 0 if both invalid, 1 if one is valid
 s msg="The following journaling "
 s:cnt msg=msg_"directory is" 
 s:'cnt msg=msg_"directories are"
 s msg=msg_" not valid"_$C(13,10)
 s:'valid1 msg=msg_"     "_dir1_$C(13,10)
 s:'valid2 msg=msg_"     "_dir2_$C(13,10)
 q msg
ChkDirVALID(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,1)
ChkDirEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkDirOrSpecEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,3)
ChkDir(R) N N S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkBad S $ZT="" W !,"<"_$P($P($ZE,"<",2),">")_"> error -- invalid directory"
 Q ""

JRNUTIL^INT^1^67214,47330
JRNUTIL ; Extrinsic functs to manipulate journal file records ;$Change: 7440104 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ; Revision: $Id: //iris/2024.1.3/databases/sys/rtn/journal/jrnutil.mac#1 $
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/FILEINC.inc#1 $ ($Change: 7440104 $) */
 ;  Return values:
 ;
 ; Provides extrinsic functions to manipulate journal file records
 ; in a non-interactive fashion. One can open/use/close a journal 
 ; file, delete a journal file, switch journalling to another file
 ; as well as read /delete a record from an open journal file. 
 ;
 ;
 ;*******************************************************************
 ; $$GETREC(ADDR,.JRNODE)  : read a record 
 ;
 ;   Input: -  ADDR, address of the record to be read.
 ;          -  JRNODE, a local variable which should be passed by 
 ;             reference, so that it returns the information about the
 ;             record.
 ;   Output:   -13   ( cluster record, not supported )
 ;             -11   ( journal file empty )
 ;             -12   ( invalid address )
 ;             -9    ( journal file not open )
 ;              1    ( success )  which in this case:
 ;              JRNODE array: 
 ;              JRNODE(1,1)= pid/prev/next:type:collation:glo
 ;                 pid  is the process id.
 ;                 prev/next are previous/next adjacent record addrs 
 ;                 type is "S", "K", "k", "ZK", "B", "C", "NS, "NK", "QA", "QR", "QM"
 ;                      "VS" (for Set $Vector), "VK" (for kill $vector),
 ;                      "s" (for Set $BIT), "Ns" (for network Set $BIT),
 ;                      or "ZNK" designating the type of the record.
 ;                 glo is the complete global reference name.
 ;                              -or- (see note below)
 ;              JRNODE(1,1)= pid,remsysid/prev/next:type:collation:glo 
 ;                 pid  is the process id on the remote system
 ;                 remsysid is the internal unique id of the remote
 ;                      system
 ;                 prev/next are previous/next adjacent record addrs 
 ;                 type is "S", "K", "k", "ZK", "B", "C", "NS, "NK",
 ;                      "VS" (for Set $Vector), "VK" (for kill $vector),
 ;                      "s" (for Set $BIT), "Ns" (for network Set $BIT),
 ;                      or "ZNK" designating the type of the record.
 ;                 glo is the complete global reference name.
 ;                         
 ;              JRNODE(1,1,1) contains the old value if the global had
 ;              a previous value and this record is for a SET or KILL.
 ;              In the case of Set $BIT, the old value is in the form
 ;              bitpos^bitval, where bitpos is the 1-based integer bit
 ;              position of the bit and bitval is either 0 or 1.
 ; 
 ;              JRNODE(1,1,2) contains the new value if type is "S"
 ;                  (for SET) or "s" (for Set $BIT) or "VS" (for
 ;                   Set $Vector or "VK" for Kill $Vector)
 ;              In the case of Set $BIT, the new value is in the form
 ;              bitpos^bitval, where bitpos is the 1-based integer bit
 ;              position of the bit and bitval is either 0 or 1.
 ; 
 ;	            In the case of Set $Vector the new value is of the
 ;              form index^type^newval where newval may itself contain
 ;              ^ so care should be use when extracting it.
 ;
 ;              JRNODE(1,1,3) contains the timestamp in $H format
 ;              Note re two forms of JRNNODE(1,1):
 ;                  journal records are added to the local journal both
 ;                  by local processes and by server deamons on behalf
 ;                  of remote processes. When a record is generated by
 ;                  a local process the remote system id is zero and
 ;                  the 1st field of JRNNODE(1,1) is simply the local
 ;                  process' pid. When a record is added on behalf of
 ;                  a remote job the pid is the pid of the job on the
 ;                  remote machine and the remote system id is
 ;                  non-zero. To avoid confusion since the pid on the
 ;                  remote machine could match a local pid, the remote
 ;                  system id is returned in the pid field seperated 
 ;                  from the pid with a comma.
 ;*******************************************************************
GETREC(ADDR,JRNODE) ;read a record from a journal file, and put info. in JRNODE
 S $ZT="ERR^"_$ZN
 N TYPE,TRANS,PID,GLO,PREV,NEXT
 N REMSYSID
 ;
 I $G(%JFILE)="" Q "-9,Journal file has not been opened"  
 I ADDR=0 S ADDR=$zu(78,17,ADDR) I ADDR<1 Q "-11,Journal file is empty"
 ;
 S TYPE=$$GETYPE(ADDR)
 I TYPE="" Q "-12,Record address is not valid"
 I TYPE["N" Q "-13,Record is a cluster record"
 ;
 i TYPE="M" d  q 1
 . n markinfo s markinfo=$ZU(78,35,ADDR)
 . S PREV=$zu(78,18,ADDR)
 . S NEXT=$zu(78,17,ADDR)
 . S JRNODE(1,1,2)=$p(markinfo,",",4,$l(markinfo))
 . S JRNODE(1,1)=$p(markinfo,",",3)_"/"_PREV_"/"_NEXT_":"_TYPE_":"_$p(markinfo,",",2)_":"_$p(markinfo,",")
 . S JRNODE(1,1,3)=$zu(78,24,ADDR)
 S TRANS=$zu(78,9,ADDR)  ; was it in a transaction
 S PID=$zu(78,10,ADDR)
 S REMSYSID=+$ZU(78,25,ADDR)
 i REMSYSID S PID=PID_","_REMSYSID
 i TYPE="E" d  q 1
 . S PREV=$zu(78,18,ADDR)
 . S NEXT=$zu(78,17,ADDR)
 . S JRNODE(1,1)=PID_"/"_PREV_"/"_NEXT_":"_TYPE_"::"_$zu(78,45,ADDR)
 . S JRNODE(1,1,3)=$zu(78,24,ADDR)
 S GLO=$zu(78,13,ADDR)
 S PREV=$zu(78,18,ADDR)
 S NEXT=$zu(78,17,ADDR)
 S COLLATE=$ZU(78,27,ADDR)
 ;
 I TYPE="s" S JRNODE(1,1,2)=$zu(78,36,ADDR)_"^"_$zu(78,37,ADDR)
 I TRANS=1,TYPE="s" S JRNODE(1,1,1)=$zu(78,36,ADDR)_"^"_(1-$zu(78,37,ADDR))
 I TYPE="VS" {
   S JRNODE(1,1,2)=$ZU(78,122,ADDR)_"^"_$ZU(78,123,ADDR)_"^"_$zu(78,15,ADDR)
   I TRANS=1,$zu(78,14,ADDR)>1 S JRNODE(1,1,1)=$zu(78,16,ADDR)
 }
 I TYPE="VK" {
   S JRNODE(1,1,2)=$ZU(78,122,ADDR)_"^"_$ZU(78,123,ADDR)
   I TRANS=1,$zu(78,14,ADDR) S JRNODE(1,1,1)=$zu(78,16,ADDR)
 }
 I TYPE="S" S JRNODE(1,1,2)=$zu(78,15,ADDR) ;Get new value
 I TRANS=1,"Kk"[TYPE,$zu(78,14,ADDR)>0 S JRNODE(1,1,1)=$zu(78,16,ADDR)
 I TRANS=1,TYPE="S",$zu(78,14,ADDR)>1 S JRNODE(1,1,1)=$zu(78,16,ADDR)
 i TYPE="QA" S JRNODE(1,1,2)=$zu(78,15,ADDR)
 i TYPE="QM" S JRNODE(1,1,2)=$zu(78,15,ADDR)
 S JRNODE(1,1)=PID_"/"_PREV_"/"_NEXT_":"_TYPE_":"_COLLATE_":"_GLO
 S JRNODE(1,1,3)=$zu(78,24,ADDR)
 Q 1
 ;********************************************************************
 ; $$DELREC(ADDR):  Delete a record from the currently being used file
 ;
 ;   Input:  - ADDR, is the address of the record to be deleted
 ;
 ;   Output:   -13  ( cluster record )
 ;             -12  ( invalid address )
 ;             -11  ( FILE IS EMPTY )
 ;             -9   ( file not open / used )
 ;              1   ( success )
 ;********************************************************************
DELREC(ADDR)   ; delete a record from a journal file
 S $ZT="ERR^"_$ZN
 N X,TYPE
 ;
 I $G(%JFILE)="" Q "-9,Journal file has not been opened"
 I 'ADDR S ADDR=$zu(78,17,ADDR) I ADDR<1 Q "-11,Journal file is empty"
 ;
 S TYPE=$$GETYPE(ADDR)
 I TYPE="" Q "-12,Record address is not valid"
 I TYPE["N" Q "-13,Record is a cluster record"  ; Cluster type
 ;
 S X=$zu(78,19,ADDR) ;Remove the record
 I X<0 Q "-15,Unsuccessful operation"
 ;
 Q 1
 ;*********************************************************************
GETYPE(ADDR) ; return record type, string format
 S $ZT="GetErr^"_$ZN
 N TYPE,TYPECODE
 S TYPE=$zu(78,8,ADDR)
 ;
 I TYPE=4 Q "B"   ; begin transaction
 I TYPE=5 Q "C"     ; commit transaction
 I TYPE=6 Q "S"       ; set a node
 I TYPE=7 Q "K"       ; kill a node
 I TYPE=8 Q "k"    ; kill of a decendent node
 I TYPE=9 Q "ZK"     ; zkill (kill only this node)
 I TYPE=10 Q "NS"      ; network set
 I TYPE=11 Q "NK"     ; network kill
 I TYPE=12 q "NZK"  ; network zkill
 i TYPE=13 q "M"       ; journal marker
 I TYPE=14 Q "s"     ; set a specified bit position in a node
 I TYPE=25 Q "VS"     ; set an element in a vector
 I TYPE=26 Q "VK"    ; kill an element in a vector
 i TYPE=15 q "E"     ; ECP networking
 i TYPE=21 q "RB"  ; Rollback
 i TYPE=16 q "BTL"     ; Begin Transaction level
 i TYPE=17 q "PTL"  ;Commit pending level
 i TYPE=18 q "CTL"     ; Commit isolated level
 i TYPE=22 q "QA"	; Enqueue
 i TYPE=22 q "QR"	; Dequeue
 i TYPE=22 q "QM"	; Queue Move
 ;
GetErr Q ""  ; in case of error
 ;*********************************************************************
 ; $$DELFILE^JRNUTIL(JRNFILE) :  Delete a journal file
 ;   
 ;   Input:  - name of the journal file to be deleted
 ;             if the file is open, it won't be deleted
 ;      
 ;   Output:    -15  ( unknown error )
 ;              -10  ( not a journal file )
 ;              -6   ( file locked by another user )
 ;               1   ( success )
 ;*********************************************************************
DELFILE(JRNFILE,PurgeTimeH,errmsg)  ; delete a journal file
 S $ZT="ERR^"_$ZN
 N X,FILE,Y
 S FILE=JRNFILE
 ;
 S Y=$ZU(78,22,FILE) ;Make sure it's a journal file 
 I 'Y {
   s Y=$zu(140,1,FILE)
   i Y=-2 Q 1 ;a nonexisting file (already deleted??)
   Q "-7,Unable to open journal file" ;due to permission issue?
 }
 I Y<1 Q "-10,File is not a journal file"
 ;
 l +^%JRNZIPCHK(FILE):0
 if '$T {
	 s errmsg=""
     s ^%SYS("JOURNAL","PURGEF",FILE)=$zdt($g(PurgeTimeH,$h),3) 
	 quit "-18,Journal file is being compressed"
 }
 S X=$ZU(78,23,FILE) ;Delete the file
 i X<0 {
   n tmpfile s tmpfile=FILE
   if ''$ZU(140,4,tmpfile),'$ZU(140,4,tmpfile_"z"),$E(tmpfile,*)'="z" s tmpfile=tmpfile_"z"
   n errcode s errcode=$ZU(140,5,tmpfile)
   l -^%JRNZIPCHK(FILE)
   i errcode<0 {  ;error code from failure
     s errmsg=$zu(209,-errcode)
     s ^%SYS("JOURNAL","PURGEF",FILE)=$zdt($g(PurgeTimeH,$h),3) 
     I X=-1 Q "-16,File not found or open by another user"  ;File not found or locked by another user
     Q "-15,Unsuccessful operation"
   }
 }
 l -^%JRNZIPCHK(FILE)
 try {
 D History("DELETE",FILE)
 s ^%SYS("JOURNAL","PURGED",FILE)=$zdt($g(PurgeTimeH,$h),3) 
 s ^||%ISC.PurgedJrnFiles($i(^||%ISC.PurgedJrnFiles))=FILE
 } catch {
   d $zu(9,"","Unable to log purged journal file: "_$ze,(0>0),0)
   s $ze=""
 }
 Q 1
History(TYPE,FILE1,FILE2) ;
 d:TYPE="DELETE" $zu(9,"",TYPE_": "_FILE1,(0>0),0)
 q
HISTORY(type,file,curdir,altdir,prefix,short,jrnhist) 
 d $zu(9,"",type_": "_file,(0>0),0)
 q
 ; 
 ; clean up old journal history entries (can be run as stand-alone)
 ; LIFESPAN = 0: automatic purge is disabled
 ; purge entries down to the last STOP'ed journal whose "DATE" subentry
 ;   has 2nd field (session end date) beyond LIFESPAN (=30 days), OR 
 ;   prior to the last START'ed entry whose "DATE" subentry has 1st field 
 ;   (session begin date) beyond LIFESPAN.
PURGE ; purge journal files and history
 g PPURGE
 q
okpurge(flifespan,hlifespan) ;flifespan/hlifespan: lifespan of journal file/history
 s flifespan=+$g(^%SYS("JOURNAL","LIFESPAN","FILE"))
 s hlifespan=$s(flifespan>30:flifespan,1:30)
 s ^%SYS("JOURNAL","LIFESPAN")=hlifespan
 q 1
PPURGE ;
 s $zt="etPPURGE"
 i $d(^SYS("FirstRestartSinceInstall")) q
 n flifespan
 Set flifespan=""
 if $d(^$ROUTINE("%ZJRNPURGE")) {
 	try {
 		s flifespan=$$^%ZJRNPURGE()
	} catch {
 		d $zu(9,"","ERROR in purging journal files: "_$ze,(0>0),0)
		return
	}
 } 
 s:flifespan="" flifespan=$g(^%SYS("JOURNAL","LIFESPAN","FILE"))
 d Purge(flifespan)
 q
Purge(flifespan,CheckOnly,purgenode) ;internal entry point
 n (flifespan,CheckOnly,purgenode)
 s CheckOnly=+$g(CheckOnly)
 L +^%SYS("JOURNAL","PURGE"):10 
 i '$t {
   d $zu(9,"","Skip journal purging as one is in progress by PID "_$g(^%SYS("JOURNAL","PURGE")),(0>0),0)
   q
 }
 s $zt="etPurge"
 s ^%SYS("JOURNAL","PURGE")=$j
 d PurgeInt
 k ^%SYS("JOURNAL","PURGE")
 L -^%SYS("JOURNAL","PURGE")
 q
PurgeInt ;
 n ret s time=$h
 n errmsg
 k ^||%ISC.PurgedJrnFiles ;to record a list of purged journal files 
 k ^||%ISC.PurgedMirJrnFiles ;to record a list of purged mirror journal files
 s jrnf="" f  { ;try purging any files that failed to get purged before
   s jrnf=$o(^%SYS("JOURNAL","PURGEF",jrnf)) q:jrnf=""  
   k errmsg s ret=$$DELFILE(jrnf,time,.errmsg) 
   i ret>0 k ^%SYS("JOURNAL","PURGEF",jrnf)
   e  d msglog("Unable to delete file "_jrnf_": "_$s($g(errmsg)="":ret,1:errmsg),1)
 }
 s numbck=$p(flifespan,",",2),numday=+flifespan,date=$p($h,",")
 s limitall=$zd(47117,8)_".000J" ;a limit preventing any file from being purged
 i numday s limitbyday=$zd(date-numday,8)_".000J"
 e  s limitbyday=limitall  ;don't purge files by days
 i numbck d  i 1
 . s time=$$GetGoodBackups(numbck)
 . i time="" s limitbybck=limitall q  ;nothing meets the backup criterion
 . ;s jrnfbck=$g(^SYS("BUHISTORY",time,"JOURNAL"))
 . m jrnfbck=^SYS("BUHISTORY",time,"JOURNAL")
 . i jrnfbck="" s limitbybck=$zd(time\1000000,8)_".000J"
 . e  s limitbybck=$case($ZBITGET($ZVERSION(0),46),0:$case($f(jrnfbck,";"),0:$e(jrnfbck,*-8-$l($p(jrnfbck,".",$l(jrnfbck,"."))),*-$case($e(jrnfbck,*)="z",0:0,1:1)),:$e(jrnfbck,*-8-$l($p(jrnfbck,".",$l(jrnfbck,"."))),$f(jrnfbck,";")-2)),:jrnfbck)_"A"
 e  s limitbybck=limitall  ;don't purge files based on backups
 s limit=$s((($p(limitbyday,".")>$p(limitbybck,"."))||(($p(limitbyday,".")=$p(limitbybck,"."))&&(+$p(limitbyday,".",2)>+$p(limitbybck,".",2)))):limitbyday,1:limitbybck) 
 i $g(^%ISCLOG("JRNUTIL")) d $zu(9,"","Purge limit: "_limit) ;HYY000
 i $SYSTEM.Mirror.IsMember() {
   s mirrorname="" f  {
     s mirrorname=$o(jrnfbck(mirrorname),1,mirfilecnt) q:mirrorname=""
     ;getmfpurge() returns the latest file to purge prior to the given limit
     s startfile=$$getmfpurge(limitbyday,mirrorname)
     i startfile="" {  
       ;none to purge based on the day criterion, so use the backup criterion
       s jrnfbck(mirrorname)=(mirfilecnt-1)_"C"
       continue
     }
     s rc=$SYSTEM.Mirror.GetJournalFileInfo(mirrorname,startfile)
     i +rc=1 {
       s startfilejrncnt=$P(rc,",",3)
     } else {
       ; file not found in log, see if we can open it and get the
       ; mirror journal count that way.
       s jrninfo=$zu(78,22,startfile,13)
       i jrninfo<=0 {
         s jrnfbck(mirrorname)=0
         continue
       }
       s startfilejrncnt=$P(jrninfo,",",2)
     }
     ;i startfilejrncnt>=mirfilecnt s jrnfbck(mirrorname)=startfilejrncnt+1
     ;jrnfbck() will be merged to StartFile, which is the latest file to purge
     i startfilejrncnt>=mirfilecnt s jrnfbck(mirrorname)=startfilejrncnt_"C"
     e  s jrnfbck(mirrorname)=(mirfilecnt-1)_"C"
   }
 }
 n PurgedFiles,mirname,rc,Status
 n jrndatamove,limitbyDM,SQLCODE  ; The query will create SQLCODE variable.
 s rc=##class(DataMove.Data).GetEarliestJRNCUR(.jrndatamove,.DMName)
 if (''rc) {
	 i jrndatamove'="" {
	 s limitbyDM=$case($ZBITGET($ZVERSION(0),46),0:$case($f(jrndatamove,";"),0:$e(jrndatamove,*-8-$l($p(jrndatamove,".",$l(jrndatamove,"."))),*-$case($e(jrndatamove,*)="z",0:0,1:1)),:$e(jrndatamove,*-8-$l($p(jrndatamove,".",$l(jrndatamove,"."))),$f(jrndatamove,";")-2)),:jrndatamove)_"A"
	 if (($p(limit,".")>$p(limitbyDM,"."))||(($p(limit,".")=$p(limitbyDM,"."))&&(+$p(limit,".",2)>+$p(limitbyDM,".",2)))) {
	   s limit=limitbyDM,limitbybck=limitbyDM,jrnfbck=jrndatamove
	   		d msglog("Preserving journal files "_jrnfbck_" and later for Data Move "_DMName,2)
	 	}
	 }
 } else {
	 d msglog("Error from Data Move purging journal files: "_$System.Status.GetErrorText(rc),2)
	 q
 }
 i $SYSTEM.Mirror.IsAsyncMember(),$SYSTEM.Mirror.AsyncMemberType() {
	m limitx=jrnfbck
	if limit=limitbybck,$g(jrnfbck)'="" {	;purging limited by #backups
		s mirfilecnt=(+$P($ZU(78,22,jrnfbck,13),",",2))
		i 'mirfilecnt {
			s limitx=jrnfbck ;path of a non-mirror or non-existing file
		} else {
			s limitx=(mirfilecnt-1)_"C"
		}
	} else {
		s limitx=limit
	}
 	d ##class(SYS.Mirror).PurgeAsyncMemberJournalFiles(.Status,CheckOnly,,,,.PurgedFiles,.limitx)
	s mirname="" f  {
		s mirname=$o(Status(mirname),1,rc) q:mirname=""
		i ('rc) {
			d $zu(9,"","Error purging async mirror '"_mirname_"' journal files: "_$System.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
		} elseif 'CheckOnly {
			d msglog("Mirror '"_mirname_"' journal files purged: OK",0)
		}
	}
	i 'CheckOnly m ^||%ISC.PurgedMirJrnFiles=PurgedFiles
 }
 i limit=limitall {
 	s mirrorname="" f  {
   		s mirrorname=$o(jrnfbck(mirrorname),1,mirfilecnt) 
		i mirrorname="" q
		i mirfilecnt q  ;mirrorname'=""
	}
 	i mirrorname="" q  ;none to purge (neither files nor history)
 }
 s limitbytran=$$GetTranLimit(.jrnftran) 
 i $g(^%ISCLOG("JRNUTIL")) d $zu(9,"","Purge limitbytran: "_limitbytran_","_$g(jrnftran)) ;HYY000
 n mirrjrnf,mirlimit,mirlimitbytran,mirfilecnt,StartFile
 i $SYSTEM.Mirror.IsMember()=1||($SYSTEM.Mirror.IsMember()=2&&($SYSTEM.Mirror.AsyncMemberType()=0)) {	;a failover member (NOT async member)
	s mirrjrnf="" ;the oldest mirror journal file NOT to be purged
	s mirrjrnfcnt=0
	i $g(jrnftran)]"" {
	  s jrnf=$zu(78,3),prev="" f  {
	    s prev=$zu(78,22,jrnf,1) q:prev'>0  ;jrnf is non-existent or bad
	    s prev=$p(prev,",",2) ;path of previous journal file; could be ""
	    s mirfilecnt= (+$P($ZU(78,22,jrnf,13),",",2)) 
	    i mirfilecnt {
	      s mirrjrnf=jrnf
	      s mirrjrnfcnt=mirfilecnt
	    }
	    i jrnf=jrnftran q  ;done checking files needed for local recovery
	    i prev="" q  ;shouldn't happen, since jrnftran]""
	    s jrnf=prev
	  }
	}
	i mirrjrnf="" s mirlimitbytran=$zd($h+1,8)_".000J" ;all can be purged
	e  s mirlimitbytran=$case($ZBITGET($ZVERSION(0),46),0:$case($f(mirrjrnf,";"),0:$e(mirrjrnf,*-8-$l($p(mirrjrnf,".",$l(mirrjrnf,"."))),*-$case($e(mirrjrnf,*)="z",0:0,1:1)),:$e(mirrjrnf,*-8-$l($p(mirrjrnf,".",$l(mirrjrnf,"."))),$f(mirrjrnf,";")-2)),:mirrjrnf)_"A"
	i '$System.Mirror.IsPrimary() {
          s mirrorname=$G(^SYS("MIRRORSET"))
          s mirrorname=$P(mirrorname,"^",2)
          i mirrorname="" {
		d msglog($System.Status.GetErrorText($$Error^%apiOBJ(2002))) ;shouldn't happen
		q
	  }
	  s purgefcnt=$g(jrnfbck(mirrorname)) ;w/ trailing "C"
	  i purgefcnt { ;which embodies limitbyday if defined
	    ;mirrjrnfcnt is the oldest file to keep or 0 (all can be purged)
	    i mirrjrnfcnt&&(purgefcnt>=mirrjrnfcnt) { 
	      s StartFile=(mirrjrnfcnt-1)_"C" ;the latest file to purge
	      i (mirrjrnf'=$zu(78,3))&&((flifespan'=-1)||$$FileIsOld(mirrjrnf)) {
                d msglog("Preserving mirror journal files "_mirrjrnf_" and later for local recovery",2)
	      }
	    } else { ;all can be purged ('mirrjrnfcnt) or purgefcnt<mirrjrnfcnt)
	      s StartFile=purgefcnt ;w/ trailing "C"
	    }
	    g locpurge ;skip setting StartFile below
	  }
	}
	s mirlimit=limit ;keep limit intact as we use it to purge local files
        i (($p(limit,".")>$p(mirlimitbytran,"."))||(($p(limit,".")=$p(mirlimitbytran,"."))&&(+$p(limit,".",2)>+$p(mirlimitbytran,".",2)))) {;purging limited by local recovery
	  s mirfilecnt=(+$P($ZU(78,22,mirrjrnf,13),",",2))
	  s StartFile=(mirfilecnt-1)_"C" 
	  i (mirrjrnf'=$zu(78,3))&&((flifespan'=-1)||$$FileIsOld(mirrjrnf)) {
            d msglog("Preserving mirror journal files "_mirrjrnf_" and later for local recovery",2)
	  }
	} elseif limit=limitbybck {	;purging limited by #backups
	  s mirfilecnt=(+$P($ZU(78,22,jrnfbck,13),",",2))
	  i 'mirfilecnt {
	    s StartFile=jrnfbck ;path of a non-mirror or non-existing file
	  } else {
	    s StartFile=(mirfilecnt-1)_"C"
	  }
	} else { ;$p(limit,".",2)="000J" (purging limited by a date)
	  s StartFile=limit\1_"D" ;a date (YYYYMMDD)
	}
 }
locpurge ;
 i (($p(limit,".")>$p(limitbytran,"."))||(($p(limit,".")=$p(limitbytran,"."))&&(+$p(limit,".",2)>+$p(limitbytran,".",2)))) {
   s limit=limitbytran,jrnf=jrnftran
   i jrnftran'=$zu(78,3),jrnftran'=$g(mirrjrnf) {
     i (flifespan'=-1)||$$FileIsOld(jrnftran) {
       d msglog("Preserving journal files "_jrnftran_" and later for journal recovery and transaction rollback",2)
     }
   }
 } elseif limit=limitbybck {
   s jrnf=jrnfbck ;limitbytran]limit
 }
 i $p(limit,".",2)="000J" s jrnf=$$getfpurge(limit\1) i 1
 e  s stat=$$PREVJRN^JRNUTIL2(jrnf,.prev) d
 . i stat>0 s jrnf=prev q
 . s jrnf="" 
 s purgenode=$g(purgenode,$name(^||%ISC.JRN.PURGE)) k @purgenode
 ;store to-purge files in purgenode("-") (to distinguish it from mirrorname)
 i jrnf]"" d BuildPurgeList(jrnf,$s(CheckOnly:$name(@purgenode@("+")),1:purgenode))
 i $g(^%ISCLOG("JRNUTIL")) d $zu(9,"","Purge by file: "_jrnf_","_$d(@purgenode)) ;HYY000
 i $d(StartFile) { ;StartFile is set above on a failover member
 	s rc=##class(SYS.Mirror).PurgeJournalFiles(CheckOnly,StartFile,,,,,,.PurgedFiles)
	if ('rc) {
		k errtxt 
		Do DecomposeStatus^%apiOBJ(rc,.errtxt,"-d") 
		d $zu(9,"","Error purging mirror journal files up to '"_limit_"': "_errtxt(1),1 /* broadcast and log message*/,1  /* Warning */)
	}
	i 'CheckOnly m ^||%ISC.PurgedMirJrnFiles=PurgedFiles
 }
 i CheckOnly {
   s i="" f  {
     s i=$o(@purgenode@("+",i),1,file) q:i=""
     k @purgenode@("+",i)
     s @purgenode@("-",-i)=file
   }
   m @purgenode=PurgedFiles 
   q  ;done checking for files eligible for purging
 } 
 i $d(@purgenode) d FPURGE(purgenode)
 s hlifespan=$g(^%SYS("JOURNAL","LIFESPAN"),30) i 'hlifespan q
 s fdate=$zdh($s(jrnf="":limit,1:$case($ZBITGET($ZVERSION(0),46),0:$case($f(jrnf,";"),0:$e(jrnf,*-8-$l($p(jrnf,".",$l(jrnf,"."))),*-$case($e(jrnf,*)="z",0:0,1:1)),:$e(jrnf,*-8-$l($p(jrnf,".",$l(jrnf,"."))),$f(jrnf,";")-2)),:jrnf))\1,8)
 i fdate>(date-hlifespan) s fdate=date-hlifespan
 e  s hlifespan=date-fdate
 s stat=##class(%SYS.Journal.System).PurgeHistory(hlifespan)
 i 'stat d msglog("Error purging journal history: "_$System.Status.GetErrorText(stat))
 d PurgeArchiveLog($zd(fdate,8)) ;same criterion for log of archived files
 ; Now that we may have deleted some journal files, open the oldest existing
 ; file and clean out the jobid's in SYS("PIDList") which preceed this file.
 do PurgePIDList(numday)   ;JO2322
 i $s($S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0):''$zu(59,0),1:0) d PURGE^JRNINFO(1)
 q
etPurge s $zt=""
 d $zu(9,"","ERROR in purging journal files: "_$ze,(0>0),0)
 try {
   k ^%SYS("JOURNAL","PURGE")
   L -^%SYS("JOURNAL","PURGE")
   try {
     d BACK^%ETN
   } catch {
   }
 } catch {
   L -^%SYS("JOURNAL","PURGE")
 }
 zt $ze
etPPURGE ;
 s $zt="" 
 i $ze["PPURGE" d $zu(9,"","ERROR in purging journal files: "_$ze,(0>0),0)
 q
PurgeArchiveLog(date) ;purge archive log entries older than 'date' (YYYYMMDD)
 s startid=($p(date_".000",".")_$e(10000000000+$p(date_".000",".",2),2,11))
 s id=startid
 f  {
   s id=$o(^%SYS("JOURNAL","ARCHIVED","-",id),-1,fileinfo) q:id=""
   s file=$p(fileinfo,",")
   i $e(file,*)="z" s file=$e(file,1,*-1) ;remove trailing "z"
   k ^%SYS("JOURNAL","ARCHIVED","-",id)
   k ^%SYS("JOURNAL","ARCHIVED","--",file)
 }
 s sub="" f  {
   s sub=$o(^%SYS("JOURNAL","ARCHIVED",sub)) q:sub=""
   ;sub can be "-", "--", mirname, or mirname"-"
   ;we are only interested in mirname (no trailing "-") entries
   i $e(sub,*)="-" continue
   s id=startid
   f  {
     s id=$o(^%SYS("JOURNAL","ARCHIVED",sub,id),-1,fileinfo) q:id=""
     k ^%SYS("JOURNAL","ARCHIVED",sub,id)
     k ^%SYS("JOURNAL","ARCHIVED",sub_"-",+fileinfo) ;mirfilecnt
   }
 }
 q
FileIsOld(jrnf) ;
 i jrnf=$zu(78,3) q 0
 s info=$zu(78,22,jrnf,4)
 i info<0 q -1  ;
 s time0=$p(info,",",2)
 s htime=$zdth(time0,-2)
 i (($h-htime)*86400+$p($h,",",2)-$p(htime,",",2))<=3600 q 0
 s nextfile=$$NEXTJRN1(jrnf)
 i nextfile="" q -2 ;
 s info=$zu(78,22,nextfile,4)
 i info<0 q -3  ;
 s time0=$p(info,",",2)
 s htime=$zdth(time0,-2)
 q ((($h-htime)*86400+$p($h,",",2)-$p(htime,",",2))>3600)
GetGoodBackups(numbck) ;
 n time,bckcnt s time="",bckcnt=0 f  {
   s time=$o(^SYS("BUHISTORY",time),-1) q:time=""
   i $g(^SYS("BUHISTORY",time,"Complete"))'>0 s bckcnt=0 
   e  i $i(bckcnt)=numbck q
 }
 q time
GetTranLimit(jrnf) ;
 n limit,limitnone,jrninfo,jrninfo,fcnt,file,limitcnt,cnt,prev,stat
 s $zt="GetTranLimitE"
 s limitnone=$zd($h+1,8)_".000J"   ;NOT preventing any file from being purged
 s jrninfo=$zu(78,21)
 s fcnt=$p(jrninfo,",",3)
 s file=$p(jrninfo,",",2) ;fcnt = file counter of 'file'
 i file="" {
	 s file=$$GetPendingTransLimit(0)
	 if file '="" {
		 s jrnf=file
		 quit $case($ZBITGET($ZVERSION(0),46),0:$case($f(file,";"),0:$e(file,*-8-$l($p(file,".",$l(file,"."))),*-$case($e(file,*)="z",0:0,1:1)),:$e(file,*-8-$l($p(file,".",$l(file,"."))),$f(file,";")-2)),:file)_"A"
	 }
	 q limitnone           ;journaling is off: no file to preserve
 }
 s limitcnt=$zu(78,21,1) ;file count of the oldest OPEN transaction
 i limitcnt>fcnt s limitcnt=fcnt ;oldest file count for crash recovery
 s limitcnt=$$nettranfile(limitcnt)  ;oldest file count with net transactions
 s jrnf=$$GetPendingTransLimit(limitcnt)
 if jrnf="" {
 	s cnt=fcnt
 	s jrnf=file 
 	f  {
	 	q:cnt=limitcnt  
	 	s stat=$zu(78,22,jrnf,1) 
	 	q:stat'>0  
	 	s prev=$p(stat,",",2) 
	 	q:prev=""  
	 	s cnt=cnt-1,jrnf=prev 
	 	q:cnt=limitcnt
 	}
 }
 q $case($ZBITGET($ZVERSION(0),46),0:$case($f(jrnf,";"),0:$e(jrnf,*-8-$l($p(jrnf,".",$l(jrnf,"."))),*-$case($e(jrnf,*)="z",0:0,1:1)),:$e(jrnf,*-8-$l($p(jrnf,".",$l(jrnf,"."))),$f(jrnf,";")-2)),:jrnf)_"A"  ;the full path 'jrnf' is returned by reference
GetTranLimitE s $zt="" d BACK^%ETN
 ztrap $ze
GetPendingTransLimit(limitcnt) {
 	s limit=""
	try {
 		s id=""
 		for  {
	 		s id=$O(^SYS("ROLLBACK","PENDING",id))
	 		quit:id=""
			s index=$O(^SYS("ROLLBACK","PENDING",id,"FileList",""),1,file)
			if index'="" {
				; FileList is organized 1..n as newest->oldest so this is
				; the oldest file for this pending rollback
				s info=$zu(78,22,file,99)
				if +info=1 {
					s jrnfilecnt=$P(info,",",12+1)
					if 'limitcnt || (jrnfilecnt<limitcnt) {
						s limitcnt=jrnfilecnt
						s limit=file
					}
				}
			}
 		}
	} catch {
		d BACK^%ETN
		ztrap $ze  ;resignal error
	}
	quit limit ; null or jrnfile required for pending trollback
}
 ; input: 
 ;   f - full name of the a journal file (because we need to call PREVJRN)
 ;   purge - the node for a list of (non-mirror) files to be purged 
BuildPurgeList(f,purge) ;
 n ret,pf,i
 s $zt="BuildPurgeListErr"
 ; First we build a list of files to purge so that we can purge the oldest one first.
 ; This is better than purging the latest one first in case we are interrupted.
 i $ZU(78,22,f)'>0,$g(^%SYS("JOURNAL","PURGED",f))]"" d loginfo1(f) q
 n jrnflist s jrnflist=$name(^||JrnFileList($i(^||JrnFileList))) k @jrnflist
 f i=1:1 {
	 s ret=$$PREVJRN^JRNUTIL2(f,.pf) 
	 q:ret'>0  
	 q:pf=""
 	 s @jrnflist@(f)=""
     if '(+$P($ZU(78,22,f,13),",",2))||$$OrphanMirrorJrnFile(f) {
        s @purge@(i)=f  ;f is guaranteed to be a journal file
	i $g(^%ISCLOG("JRNUTIL")) d $zu(9,"","BuildPurgeList:"_f) ;HYY000
     }
     s f=pf
     q:$d(@jrnflist@(f))
 }
 k @jrnflist
 ; Log possible errors and proceed to delete whatever we deem proper
 n errhead s errhead="Error in purging journal files: "
 i ret>0!(ret=-1) {
    if '(+$P($ZU(78,22,f,13),",",2))||$$OrphanMirrorJrnFile(f) {
	   s @purge@(i)=f  ;pf="" or no previous file
	}
 } else {
    d:ret msglog(errhead_$$ERNXPVJRN^JRNUTIL2(ret,f),0)  ;ret=0: f is gone probably because it has been deleted
 }
 i ($g(^%SYS("JOURNAL","ARCHIVE"))'="") { ;to purge only the archived files
   s i="" f  {
     ;note that purge list is latest entry first (@purge@(1))
     s i=$o(@purge@(i),-1,f) q:i=""  ;going backwards from oldest to latest
     s f=$zu(12,f,0,4) ;consistent with the form used in ArchiveOne^JRNARC
     i $g(^%SYS("JOURNAL","ARCHIVED","--",f))="" {
       ;keep the oldest non-archived file and the files following it
       i (flifespan'=-1)||$$FileIsOld(f) {
         d msglog("Preserving non-archived journal file "_f_" and later ones")
       }
       f  {
	 k @purge@(i)
	 i $g(^%ISCLOG("JRNUTIL")) d $zu(9,"","BuildPurgeList: skip "_f) ;HYY000
         s i=$o(@purge@(i),-1,f) q:i=""  ;do not purge files f and later
       }
       q
     }
   }
 }
 q
BuildPurgeListErr ;
 s $zt=""
 i $d(purge) k @purge
 d msglog("BuildPurgeList: "_$ze_"; purging may have been stopped prematurely")
 q
 ; input: 
 ;   purge - a list of files to be purged       
FPURGE(purge) ;to purge the given list of files
 n ret,pf,i
 s $zt="etFPURGE"
 n time,errmsg s time=$h s i="",ret=1 f  {
   s i=$o(@purge@(i),-1) q:i=""  
   k errmsg s ret=$$DELFILE(@purge@(i),time,.errmsg) 
   i ret>0 continue  ;success
   d msglog("Unable to delete file "_@purge@(i)_": "_$s($g(errmsg)="":ret,1:errmsg),1)
 }
 k @purge
 q
etFPURGE 
 s $zt=""
 i $d(purge) k @purge
 d msglog("fpurge: "_$ze_"; purging may have been stopped prematurely")
 q
PurgePIDList(daysold = 0) PUBLIC {  ;JO2322
	s $zt="err"
	; Cleans out older entries in the jobid->PID translation table
	; in ^SYS("PIDList"). Must be called while in the %SYS namespace
	; If daysold is specified then we simply clean out any PIDList entries
	; which are old than this value. 
	; If daysold is 0 then we find the oldest journal file on the system
	; and clean out entries in the PIDList which are more than one day older
	; than the earliest timestamp in this journal file. We don't want to clean 
	; out all the entries which are simply 'older' because some of those jobid's 
	; might be in the file which remains. The 'one day' limit is a bit arbitrary
	; but is designed to leave behind entries which are still valid for
	; the oldest remaining file.
	quit:'$ZBITGET($ZVERSION(0),40)   ;quit if not USETID
	i $d(^SYS("PIDList"))<10 k ^SYS("PIDList") q
	s msgtag="PurgePIDList^"_$ZN  ;for console log messages
	s cnt=0
	if daysold'=0 {
		s purgeday=$H-daysold 
		goto purgeentries
	} 
	;Get the 1st journal file from both the current and the alternate journal
	; directory and then use which ever is older. We don't use PREVJRN^JRNUTIL2
	; because that can return journal files that don't exist and we want the oldest
	; file which still exists.
	s cdir=$G(^%SYS("JOURNAL","CURDIR"),"")
	s cjrnf=""
	if cdir'="" {
		s cjrnf=$ZSEARCH(cdir_"*.*")
		if ($zversion(1)=3) {
			/* $zsearch() on Unix does not return ordered results so we need
			   to go through the entire directory and find the */
		   s minjrnf=""
		   s minval="99999999.001"  /* an impossibly large date */
		   while (cjrnf'="") {
			   s sname=$case($ZBITGET($ZVERSION(0),46),0:$case($f(cjrnf,";"),0:$e(cjrnf,*-8-$l($p(cjrnf,".",$l(cjrnf,"."))),*-$case($e(cjrnf,*)="z",0:0,1:1)),:$e(cjrnf,*-8-$l($p(cjrnf,".",$l(cjrnf,"."))),$f(cjrnf,";")-2)),:cjrnf)
			   if sname?8N1"."3.10N0.1"z" {
				   if sname<minval {
					  s:$E(cjrnf,*)="z" $E(cjrnf,*)=""
				      s minjrnf=cjrnf
				      s minval=sname
				   }
			   }
			   s cjrnf=$ZSEARCH("")
		   }
		   if minjrnf'="" {
			   s cjrnf=minjrnf
		   } 
		} else {
		   while (cjrnf'="") && '($case($ZBITGET($ZVERSION(0),46),0:$case($f(cjrnf,";"),0:$e(cjrnf,*-8-$l($p(cjrnf,".",$l(cjrnf,"."))),*-$case($e(cjrnf,*)="z",0:0,1:1)),:$e(cjrnf,*-8-$l($p(cjrnf,".",$l(cjrnf,"."))),$f(cjrnf,";")-2)),:cjrnf)?8N1"."3.10N0.1"z") {
			   s cjrnf=$ZSEARCH("")
		   }
		   s:$E(cjrnf,*)="z" $E(cjrnf,*)=""
		}
	}
	s ajrnf=""
	s dir=$G(^%SYS("JOURNAL","ALTDIR"),"")
	if dir'=cdir {
	   s ajrnf=$ZSEARCH(dir_"*.*")
		if ($zversion(1)=3) {
			/* $zsearch() on Unix does not return ordered results so we need
			   to go through the entire directory and find the */
		   s minval="99999999.001"  /* an impossibly large date */
		   s minjrnf=""
		   while (ajrnf'="") {
			   s sname=$case($ZBITGET($ZVERSION(0),46),0:$case($f(ajrnf,";"),0:$e(ajrnf,*-8-$l($p(ajrnf,".",$l(ajrnf,"."))),*-$case($e(ajrnf,*)="z",0:0,1:1)),:$e(ajrnf,*-8-$l($p(ajrnf,".",$l(ajrnf,"."))),$f(ajrnf,";")-2)),:ajrnf)
			   if sname?8N1"."3.10N0.1"z" {
				   if sname<minval {
					  s:$E(ajrnf,*)="z" $E(ajrnf,*)=""
				      s minjrnf=ajrnf
				      s minval=sname
				   }
			   }
			   s ajrnf=$ZSEARCH("")
		   }
		   if minjrnf'="" {
			   s ajrnf=minjrnf
		   } 
		} else {
	       while (ajrnf'="") && '($case($ZBITGET($ZVERSION(0),46),0:$case($f(ajrnf,";"),0:$e(ajrnf,*-8-$l($p(ajrnf,".",$l(ajrnf,"."))),*-$case($e(ajrnf,*)="z",0:0,1:1)),:$e(ajrnf,*-8-$l($p(ajrnf,".",$l(ajrnf,"."))),$f(ajrnf,";")-2)),:ajrnf)?8N1"."3.10N0.1"z") {
		      s ajrnf=$ZSEARCH("")
	       }
		   s:$E(ajrnf,*)="z" $E(ajrnf,*)="z"
	   }
	}
	if ajrnf="" {
		s jrnf=cjrnf
	} elseif cjrnf="" {
		s jrnf=ajrnf
	} else {	// (ajrnf '= "") && (cjrnf '= "")
		s a1=$case($ZBITGET($ZVERSION(0),46),0:$case($f(ajrnf,";"),0:$e(ajrnf,*-8-$l($p(ajrnf,".",$l(ajrnf,"."))),*-$case($e(ajrnf,*)="z",0:0,1:1)),:$e(ajrnf,*-8-$l($p(ajrnf,".",$l(ajrnf,"."))),$f(ajrnf,";")-2)),:ajrnf)
		s c1=$case($ZBITGET($ZVERSION(0),46),0:$case($f(cjrnf,";"),0:$e(cjrnf,*-8-$l($p(cjrnf,".",$l(cjrnf,"."))),*-$case($e(cjrnf,*)="z",0:0,1:1)),:$e(cjrnf,*-8-$l($p(cjrnf,".",$l(cjrnf,"."))),$f(cjrnf,";")-2)),:cjrnf)
		if (($p(c1,".")>$p(a1,"."))||(($p(c1,".")=$p(a1,"."))&&(+$p(c1,".",2)>+$p(a1,".",2)))) {
			s jrnf=ajrnf
		} else {
			s jrnf=cjrnf
		}
	}
	if jrnf="" do $ZU(9,"",msgtag_": Unable to locate any journal files in current or alternate journal directory") quit
	;
	; jrnf is now the oldest journal file on the system we could find. 
	s cretime=$ZU(78,22,jrnf,4)  ;returns "4,time(0)" journal file was created for success
	if +cretime'=4 do $ZU(9,"",msgtag_": Unable to determine creation time of journal: "_jrnf) quit
	s cretime=$P(cretime,",",2)
	s purgetime=cretime-(24*60*60)  ;cretime is in seconds, subtract one day
	;The format of PIDList is: ^SYS("PIDList",<jobid>,<day from $H>,<time from $H>)=<pid>
	s purgeday=+$zdth(purgetime,-2)  ;day portion of $H representing purgetime
purgeentries ;	
	s today=+$h  ; Also clean out entries from the future
	set jobid=$O(^SYS("PIDList",""))
	while (jobid'="") {
	   s lastpid=""
	   s day=$O(^SYS("PIDList",jobid,""))
	   while (day'="") && (day <= purgeday) {
		  s lastday=day
		  s lasttime=$O(^SYS("PIDList",jobid,day,""),-1,lastpid)
		  k ^SYS("PIDList",jobid,day)
	  	  s day=$O(^SYS("PIDList",jobid,"")) 
		  s cnt=cnt+1
	   }
 	   ; If this is the only record for the day, check whether
	   ; this job is still active on the system. For systems which
	   ; do not restart there will be some jobs which live across
	   ; journal file purges and we don't want to lose the translation
	   ; for them. jobid#65536 is the job # of the job. If that job
	   ; has the same jobid and pid as this one we recreate the most 
	   ; recent record.
	   s jobnum=$zb(+jobid,65535,1)  ;low 16 bits is the job #
	   if lastpid'="",($ZU(61,30,jobnum)=jobid),($ZU(61,jobnum)=lastpid) {
		   s ^SYS("PIDList",jobid,lastday,lasttime)=lastpid
		   s cnt=cnt-1  ;reduce the # of records killed
	   }
	   ; Sometimes when people play with the system clock we get
	   ; entries from the future
	   s day=$O(^SYS("PIDList",jobid,today)) 
	   while (day'="") {
		  s x=day
	  	  s day=$O(^SYS("PIDList",jobid,day)) 
		  k ^SYS("PIDList",jobid,x)
		  s cnt=cnt+1
	   }
       s jobid=$O(^SYS("PIDList",jobid))
	}
	s ^SYS("PIDList")=$H_"^"_cnt  ;Purge stats for last cleanup
	quit
err ;
	s $zt=""
	do $ZU(9,"",msgtag_": Unexpected error "_$ZE)	
	quit
}								
getfpurge(date) ;
 n jrnlogfile,filepath,dateh,dtutc
 s dateh=$zdh(date,8) ;(local) date in $H format
 s dtutc=$zu(193,dateh,1) ;UTC date/time in $H format
 s jrnlogfile=$zu(12)_"journal.log"
 i $zu(78,79,0,1,0)
 s $zt="ErPostLockLog"
 o jrnlogfile:("r":/IOT="UTF8"):0 e  d  q ""
 . i $zu(78,79,0,0,0)
 . d msglog("getpurge: failed to open journal log "_jrnlogfile) 
 n rc,zeofset,prevfile,lastfile,logline,utc
 s rc=##class(%SYS.Journal.System).GetHistoryHeader(jrnlogfile) ;skip header
 i 'rc c jrnlogfile d $zu(78,79,0,0,0),msglog("getfpurge: "_rc) q -1_","_rc
 s zeofset=$zu(68,40,1),filepath="",prevfile="",lastfile=""
 s $zt="ErPostOpenLog"
 f  {
   u jrnlogfile r logline 
   i $ZEOF s filepath="" q  ;jrnfile not found
   i ($tr(logline,$c(13,10))="") continue  ;skip blank lines
   s lastfile=prevfile,prevfile=filepath,filepath=$p(logline,",",2)
   s utc=$p(logline,",",6) ;creation time in UTC
   i $zu(193,$zdth(utc,3),0)'<dateh q  ;the 1st file created on/after 'date'
 }
 i 'zeofset,$zu(68,40,0) ;restore <ENDOFFILE>
 c jrnlogfile
 i $zu(78,79,0,0,0)
 q lastfile ;could be ""
ErPostLockLog s $zt="" d BACK^%ETN
 d msglog("getpurge: "_$ze)
 i $zu(78,79,0,0,0)
 q ""
ErPostOpenLog s $zt="" d BACK^%ETN
 d msglog("getpurge: "_$ze)
 i 'zeofset,$zu(68,40,0) ;restore <ENDOFFILE>
 c jrnlogfile
 i $zu(78,79,0,0,0)
 q ""
getftime(jrnfile) [] public {
 s timeinfo=$zu(78,22,jrnfile,4)
 i timeinfo>0 { ;file exists
   s time0=$p(timeinfo,",",2) ;in time(0) format
   s timeh=$zdth(time0,-2) ;local time in $H format
   s timeutc=$zu(193,timeh,1) ;UTC time in $H format
   q $zdt(timeutc,3) ;YYYY-MM-DD HH:MM:SS
 }
 s jrnlogfile=$zu(12)_"journal.log"
 i $zu(78,79,0,1,0)
 s $zt="ErPostLockLog"
 o jrnlogfile:("r":/IOT="UTF8"):0 e  d  q ""
 . i $zu(78,79,0,0,0)
 . d msglog("getftime: failed to open journal log "_jrnlogfile) 
 s rc=##class(%SYS.Journal.History).GetHeader(jrnlogfile) ;skip header
 i 'rc c jrnlogfile d $zu(78,79,0,0,0),msglog("getftime: "_rc) q -1_","_rc
 s zeofset=$zu(68,40,1)
 s $zt="ErPostOpenLog"
 f  {
   u jrnlogfile r logline 
   i $ZEOF q  ;jrnfile not found
   i ($tr(logline,$c(13,10))="") continue  ;skip blank lines
   i $p(logline,",",2)=jrnfile s timeutc=$p(logline,",",6) q  ;found it
 }
 i 'zeofset,$zu(68,40,0) ;restore <ENDOFFILE>
 c jrnlogfile
 i $zu(78,79,0,0,0)
 q $g(timeutc) ;could be "" if jrnfile not found
ErPostLockLog s $zt="" d BACK^%ETN
 d msglog("getftime: "_$ze)
 i $zu(78,79,0,0,0)
 q ""
ErPostOpenLog s $zt="" d BACK^%ETN
 d msglog("getftime: "_$ze)
 i 'zeofset,$zu(68,40,0) ;restore <ENDOFFILE>
 c jrnlogfile
 i $zu(78,79,0,0,0)
 q ""
}
getmfpurge(limit,mirrorname,err) [] public {
 i limit?8N1"D" { ;a (local) date boundary
   s loch=$zdh(+limit,8) ;(local) date in $H format
   s utch=$zu(193,loch,1) ;
   s timeutc=$zdt(utch,3)
 } elseif limit?8N1"."3.10N0.1"z"1"J" {
   ; a limit file name of the form yyyymmdd.000J
   s loch=$zdh($p(limit,"."),8) ; yyyymmdd -> $H format
   s utch=$zu(193,loch,1) ;
   s timeutc=$zdt(utch,3)
 } else { ;a local journal file presumably
   s timeutc=$$getftime(limit)
 }
 s $zt="getmfpurgeErr"
 s open=0,locked=0
 if timeutc="" {
	 s shortname=$case($ZBITGET($ZVERSION(0),46),0:$case($f(limit,";"),0:$e(limit,*-8-$l($p(limit,".",$l(limit,"."))),*-$case($e(limit,*)="z",0:0,1:1)),:$e(limit,*-8-$l($p(limit,".",$l(limit,"."))),$f(limit,";")-2)),:limit)  ;yyyymmdd.nnn
	 if shortname'?8N1"."3.10N0.1"z" {
	   s err=$$Error^%apiOBJ(2098,limit)
   	   quit ""
	 }
	 s loch=$zdh($p(shortname,"."),8) ; yyyymmdd -> $H format
   	 s utch=$zu(193,loch,1) ;
   	 s timeutc=$zdt(utch,3)
 }
 s miridx=$SYSTEM.Mirror.MirrorNameToIndex(mirrorname,0)
 i miridx<0 s miridx=0
 s miridx=miridx+1
 s logf=$zu(12)_"mirrorjrn-"_mirrorname_".log"
 s checksum=$zu(78,83,logf,miridx)
 if checksum=-1 {
	s rc=##class(SYS.Mirror).BuildJournalLog(mirrorname,0,"",,1)
	if ('rc) s err=rc g getmfpurgeExit
 }
 do $zu(78,79,0,1,miridx)
 s locked=1
 s zusav=$zu(68,40,1)
 o logf:"RSK\UTF8\":5
 if '$T {
   s err=$$Error^%apiOBJ(2004,mirrorname)
   goto getmfpurgeExit
 }
 s open=1
 s rc=##class(%SYS.Journal.History).GetHeader(logf,.header,1)
 i 'rc {
	s err=$$Error^%apiOBJ(2004,mirrorname)
	goto getmfpurgeExit
 }
 s prevline="",lastfile=""
 f  {
   use logf 
   read line
   q:$zeof
   s time=$p(line,",",4)
   i time]timeutc q  ;prevfile is the oldest file NOT to purge
   s lastfile=prevline,prevline=line
 }
 s mirfile=$p(lastfile,",")
getmfpurgeExit ;
 if open close logf s open=0
 if locked do $zu(78,79,0,0,miridx) s locked=0
 i $g(zusav)'="" do $ZU(68,40,zusav)
 q $g(mirfile)
getmfpurgeErr s $zt="" s err=$$Error^%apiOBJ(5002,$ze) g getmfpurgeExit
}
SETLIFESPAN(flifespan,glifespan) 
 n oldfls s oldfls=$g(^%SYS("JOURNAL","LIFESPAN","FILE"))
 s:$d(flifespan) ^%SYS("JOURNAL","LIFESPAN","FILE")=flifespan
 s:$d(glifespan) ^%SYS("JOURNAL","LIFESPAN")=glifespan
 q oldfls
Time(s) N h,m,a S a=" am",h=s\3600,m=s\60#60 S:h>11 a=" pm",h=h-12 S:'h h=12
 Q ($J(h,2)_":"_$E(100+m,2,3)_a)                 
 ;********************************************************************
 ; $$OPENJRN^JRNUTIL(JRNFILE)  : Open a journal file
 ;   
 ;   Input: - name of the file to be opened.
 ;
 ;            Each process can open multiple files at a time, but each
 ;            file can be open by just one process at a time.
 ;            A local array %JFILE(file) keeps track of a process's 
 ;            open files. When a process opens a file, to prevent other
 ;            from opening it, a lock on ^%JOURNAL(file) is made.
 ;            When the process closes the file, this lock is removed.
 ;
 ;   Output:  -8   ( file is the current journal file )
 ;            -7   ( cannot open the file )
 ;            -6   ( file locked by another user )
 ;             1   ( success )
 ;********************************************************************
OPENJRN(JRNFILE) ; open a journal file for exclusive access 
 S $ZT="ERR^"_$ZN
 N FILE,FD,Y,CUR
 S FILE=JRNFILE
 ;
 I $D(%JFILE(FILE)) Q "-14,Journal file is already open"  ;Already opened by caller
 ;
 L +^%JOURNAL(FILE):1 I '$T Q "-6,Journal file open by other user"  
 S FD=$zu(78,5,FILE,0)          ;open it
 I FD<0 L -^%JOURNAL(FILE) Q "-7,Unable to open journal file"
 S %JFILE(FILE)=FD    ;Set your local document
 Q 1
 ;********************************************************************
 ; $$CLOSEJRN^JRNUTIL(JRNFILE) : Close a journal file
 ;
 ;   Input: - name of the journal file to be closed
 ;
 ;   Output:  -15   ( unknown error )
 ;             -9   ( file has not been opened )
 ;              1   ( success )
 ;********************************************************************
CLOSEJRN(JRNFILE) ; close a journal file
 S $ZT="ERR^"_$ZN
 N FILE,X,FD
 S FILE=JRNFILE
 ;
 I '$D(%JFILE(FILE)) Q "-9,Journal file has not been opened"  ; You haven't opened this file
 ;
 S FD=%JFILE(FILE)
 S X=$zu(78,7,FD)
 I X<0 Q "-15,Unsuccessful operation"
 ; 
 K %JFILE(FILE)
 L -^%JOURNAL(FILE)
 I $G(%JFILE)=FILE S %JFILE=""
 Q 1
 ;********************************************************************
 ; $$USEJRN^JRNUTIL(JRNFILE) :  to use an already opened journal file
 ;
 ;   Input: - name of the file
 ;    
 ;   Output:  -15    ( unknown error )
 ;             -9    ( file has not been opened )
 ;              1    ( success )  which in this case:
 ;              local variable %JFILE is set to this file name
 ;********************************************************************
USEJRN(JRNFILE)  ;set JRNFILE to be used for next read/delete journal records 
 s $ZT="ERR^"_$ZN
 N FILE,X,FD
 S FILE=JRNFILE
 ;
 I '$D(%JFILE(FILE)) Q "-9,Journal file has not been opened"    ;Not open
 ;
 S FD=%JFILE(FILE)
 S X=$zu(78,6,FD) I X>-1 S %JFILE=FILE Q 1
 Q "-15,Unsuccessful operation"
 ;*********************************************************************
 ; $$JRNSWCH^JRNUTIL(newdir) :  switch journalling (to a new directory)  
 ;   Input: - newdir, new directory into which journal is written
 ;            newdir="": switch journalling in the same directory
 ;   Output:  -5  ( journalling is not active now )
 ;            -3  ( unable to create journal file )
 ;            -2  ( JRNSWCH currently in use )
 ;            -1  ( cannot cease updates )
 ;             1  ( success )
 ;*********************************************************************
JRNSWCH(newdir,reason) ; switch journalling to new directory newdir
 S $ZT="ERRSWCH^"_$ZN
 s reason=$g(reason,1)
 i $g(newdir)="" {
   s Status=##class(%SYS.Journal.System).RollToNextFile(reason)
   i Status q 1
   s errmsg=$System.Status.GetErrorText(Status)
   i $System.Status.GetErrorCodes(Status)'=1142 q -99_","_errmsg
   i $p(errmsg,":",2)[$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1818997795"),"Journal disabled") q "-5,Journaling not enabled"
   i $p(errmsg,":",2)[$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2297478059"),"Another journal switch in progress") q "-2,Journal file being switched by another job"
   q -99_","_errmsg
 }
 n switched,err,msg
 s switched=$$INT^JRNSWTCH(newdir,"",.err,/*io*/,/*maxsiz*/,/*jrnall*/,/*chkshdw*/,reason)
 q:switched 1
 s msg=$p(err,",",2,$l(err,",")),err=$p(err,",")
 q $s(err=-3:"-5,Journaling not enabled",err=-2:"-2,Journal file being switched by another job",err=-4:+"-17,Invalid journal directory name"_","_msg,1:-99_","_msg)        
ERRSWCH ;
 s $zt=""
 q $ze
 ;**************************************************************
ERR S $ZT="" Q $ZE 
NXTMIRJRN(jrnfile,mirname,err) ;
 n jrninfo,filecnt,nextjrn,status
 s jrninfo=$zu(78,22,jrnfile,13)
 i jrninfo'>0 {
   s err=jrnfile_$s('jrninfo:" does not exist",1:" is not a journal file")
   q ""
 }
 s filecnt=$p(jrninfo,",",2)+1
 s nextjrn=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)
 i nextjrn<0 {
   s err=nextjrn_",Error searching mirror journal log "_mirname
   q ""
 }
 q $p(nextjrn,",",2)
NEXTJRN1(fd,mgdir) 
 ;mgdir = where to find journal history for this system.
 ;        normally omitted except for clustered systems
 s $zt="etNEXTJRN"
 n err,nextfd
 i '$d(mgdir) s mgdir=$ZU(12)
 s err=$$NEXTJRN^JRNUTIL2(fd,.nextfd,1,mgdir)
 i +err>0 q nextfd
 d msglog("NEXTJRN: "_err_","_fd_","_$g(nextfd)_","_mgdir)
 q ""
NEXTJRN0(fd,mgdir,usejrnloginfo,rc,mironly,mirname="") ;
 i ($zversion(1)=2) s fd=$zu(12,fd,0)
 ;mgdir = where to find journal history for this system.
 ;        normally omitted except for clustered systems
 s $zt="etNEXTJRN"
 n err,nextfd
 if $ZBITGET($ZVERSION(0),46) {
 	 s nextfd=$zu(78,22,fd,2) ;
	 if +nextfd=2 {
	    s nextfd=$p(nextfd,",",2)
	    ;nextfd might be "" if there's no next file, that's ok
	    s rc="1,"_nextfd
	    quit nextfd
	 }
	 if +nextfd=0 {
		 s rc="-1,"_fd_" does not exist"
	 } elseif +nextfd=-1 {
		 s rc="-1,"_fd_" is not a journal file"
	 } else {
		 s rc="-1,Unknown error code: "_nextfd_" for file "_fd
	 }
	 quit ""  ;not found
}
 s mironly=+$g(mironly)
 if 'mironly,(+$P($ZU(78,22,fd,13),",",2)) {
	 s nextfd=$zu(78,22,fd,2) ;
	 if +nextfd=2 {
	    s nextfd=$p(nextfd,",",2)
	    if nextfd'="" {
		    s rc="1,"_nextfd
		    quit nextfd
	    }
	 }
	 s nextfd=$$NextJournalFromJournalLog(fd,.rc)
	 if +rc<0 d msglog("NEXTJRN: "_$p(rc,",",2,$l(rc))) 
	 quit nextfd  ;could be "" if no next file or the name of the file we found
 }
 i +$g(usejrnloginfo) d  q nextfd
 . s rc=$$query^JRNINFO(,"JRNNEXT,"_fd,)
 . i +rc<0 d msglog("NEXTJRN: "_$p(rc,",",2,$l(rc))) s nextfd="" q
 . s nextfd=$p(rc,",",2,$l(rc))
 i '$D(mgdir) s mgdir=$ZU(12)
 s rc=$ZU(78,81,fd)
 if 'mironly,rc>-1 s nextfd=rc quit nextfd
 s rc=$$NEXTJRN^JRNUTIL2(fd,.nextfd,0,mgdir,mironly,mirname)
 n prevnextfd 
 i rc>0,nextfd]"" s prevnextfd=$P($zu(78,22,nextfd,1),",",2) i prevnextfd]"",($zversion(1)=2) s prevnextfd=$zu(12,prevnextfd,0)
 i +rc>0 {
   i nextfd]"",prevnextfd]"",prevnextfd'=fd,'mironly {
     s rc="-98,'"_nextfd_"' appears to be the next file of '"_fd_"' but contains a pointer to a different previous file from '"_prevnextfd_"' and thus couldn't be the next file"
     d msglog("NEXTJRN: "_rc)
     q ""
   }
   q nextfd
 }
 s err=$$ERNXPVJRN^JRNUTIL2(rc,fd,1) ;error message translated from error code
 s rc=$s(rc:+rc,1:-99)_","_err
 d msglog("NEXTJRN: "_rc_","_$g(nextfd)_","_mgdir)
 q ""
etNEXTJRN 
 s $zt=""
 d msglog("Error: "_$ze)
 q ""
msglog(msg,severity)
 s severity=$G(severity,1) ;defaults to 1 if not specified
 d $zu(9,"",msg,(severity>0),severity) q
loginfo(jrnfname) ;
 q
loginfo1(jrnfname) ;
 q
loginfo2(jrnfname) ;
 q
nettranfile(fcnt) ;
 n fc,sys,dmn
 s fcnt=$g(fcnt,2**32),sys="" f  s sys=$O(^NET("TPLOG",sys)) q:sys=""  d
 . s dmn="" f  s dmn=$O(^NET("TPLOG",sys,dmn)) q:dmn=""  d
 . . s fc=$p(^NET("TPLOG",sys,dmn),"^",2) i fc<fcnt s fcnt=fc
 q fcnt
OldestOpenTransTime() public {
 s $zt="exit"
 s wijjrninfo=$zu(78,21)
 s jrnfile=$p(wijjrninfo,",",2)
 s jrnfcnt=$p(wijjrninfo,",",3)
 s tranfcnt=$p(wijjrninfo,",",4)
 s tranindx=$p(wijjrninfo,",",5)
 i jrnfile="" q -4 ;journaling is off or data is unavailable
 s tranfile=jrnfile
 i tranfcnt<jrnfcnt {
   s fcnt=jrnfcnt f  {
     s prevfile=$P($zu(78,22,tranfile,1),",",2)
     i $ZU(78,22,prevfile)'=1 q 
     s tranfile=prevfile
     i $i(fcnt,-1)=tranfcnt q
   }
   i tranfcnt<fcnt q -2 ;or return the creation time of tranfile??
 }
 s dev=$zu(78,5,tranfile,0) i dev<0 q -3 ;shouldn't happen
 d $zu(78,6,dev)
 s rc=$zu(78,24,tranindx)
exit s $zt="" i $ze'="" s rc=$$Error^%apiOBJ(5002,$ze)
 i $g(dev)'="",dev'<0 d $zu(78,7,dev)
 q $g(rc) 
}
NextJournalFromJournalLog(fd,rc) PUBLIC {								
 ;rc is passed by reference and returns:
 ;    <status>,<text>
 ;    where <status>: 1 = success, <text> = next journal file name (could be "" if no next file)
 ;                   <0 = failed, <text> = error message
 ;    returns "" if no next file or error
 ;            <name> = name of next journal file
	 s nextfd=$ZU(78,81,fd)
	 if nextfd=-2 {
		s rc="-2,Journal file "_fd_" not found in journal log"
        d msglog("NEXTJRN: "_$p(rc,",",2,$l(rc))) 
        q "" 
	 }
	 if nextfd=-1 {
		s rc="-1,Error locating journal file "_fd_" in journal log"
        d msglog("NEXTJRN: "_$p(rc,",",2,$l(rc))) 
        q "" 
	 }
	 s rc="1,"_nextfd
	 quit nextfd  ;could be "" if no next file or the name of the file we found
}
CheckCurJrnfile() PUBLIC {
	/*  CheckCurJrnfile:
	       Called from %MONAPP as part of checking whether the
	       current journal file has been deleted. If so we switch
	       to a new journal file and hope that no one needs to open
	       the deleted file for something such as transaction rollback.
	     Returns 
           0 - everything was ok (including journaling is not enabled)
           1 - Problem detected, switched to a new journal file
           2 - Problem detected, failed to switch to a new journal file
           <0 - Unable to access journal file, 
                a negative OS error code returned from $ZU(140,4,curfile)
 	*/
	s $zt="err"	
	s curfile=$zu(78,3)
	if curfile="" {
		quit 0
	}
	if '$p($zu(78,22),"^") {
		; Journaling isn't enabled, nothing to do
		quit 0
	}
tryAgain ;	
	s exists=$ZU(140,4,curfile)
	if exists=0 {
		quit 0  ;file exists, we're done
	}
	if '$p($zu(78,22),"^") {
		quit 0  ;success, journaling is no longer running
	}
	; handle file access error (anything but 'no such file')
	if exists'=-2 {
		quit exists
	}
	; Check to make sure that the current file is the
	; same as it was before
	s file=$zu(78,3)
	if file'=curfile {
		s curfile=file
		goto tryAgain
	}
	d $zu(9,"","Missing current journal file: "_file_" - Rolling to new file",1 /* broadcast and log message*/,2  /* Severe error */)
	s switched=##class(%SYS.Journal.System).RollToNextFile(12,.newfile)
	i ('switched) {
		s err=$System.Status.GetErrorText(switched)
		d $zu(9,"","Failed to switch journaling to new file: "_err,1 /* broadcast and log message*/,1  /* Warning */)
		quit 2  ; failed to switch to a new file
	}
	quit 1
err ;
	s $zt=""
	d $zu(9,"","Journal file monitor logged error: "_$ze,1 /* broadcast and log message*/,1  /* Warning */)
	d BACK^%ETN
	quit 2  ;Failed, assume we failed before we switched
}	
OrphanMirrorJrnFile(f) {
	s mm=##class(Config.MirrorMember).Open()
	s ourname=mm.SystemName
	if ourname="" quit 1  ; Not a mirror member so this does not belong any mirror set configured.
	s mm=""
	s info=$zu(78,22,f,99)
	s mirguid=$P(info,",",15+1)
	if mirguid="" quit 1
	s rs=##class(%Library.ResultSet).%New("Config.Mirrors:List")
	Do rs.Execute() 
	s NoMatch=1  ; If there is no matched mirror set then this is an orphan file.
	While (rs.Next()) {
		if mirguid=rs.Data("GUID") {
			s NoMatch=0
			quit
		}
	}
	s rs=""
	Quit NoMatch
}
%swstat(sw,detail) ; Return the status of Switch (sw)...
 s sw=+$g(sw),detail=+$g(detail)
 i sw<0 q $s(detail:-1_$c(1)_"Illegal Switch",1:-1)
 n bit,i,info,job10
 s info=""
 s $zt="%swerr^"_$zn,$ze=""
 Set i=$System.Util.GetSwitch(sw)
 i +i=0 q $s(detail:0_$c(1)_"Switch "_sw_" is NOT set.",1:0)
 i sw=10 s job10=$p(i,",",2),info=" Set by JOB #: "_job10_"  ("_$v(-1,job10)_")"
 q $s(detail:1_$c(1)_"Switch "_sw_" IS set."_info,1:1)
%swerr   ; Some error occured when doing a Switch 10 Status...
 s $zt=""
 q $s(detail:-1_$c(1)_$ze,1:-1)
%swset(sw,val,detail) ; Set Switch (sw) to (val - {0,1})...
 s sw=+$g(sw),val=+$g(val),detail=+$g(detail)
 i sw<0 q $s(detail:-1_$c(1)_"Illegal Switch",1:-1)
 i val'=0,val'=1 q $s(detail:-1_$c(1)_"Illegal Switch Value",1:-1)
 s $zt="%swseter^"_$zn,$ze=""
 If +$System.Util.GetSwitch(sw)=val q 1
 Do $System.Util.SetSwitch(sw,val)  ;Also maintains job # for job 10
 If +$System.Util.GetSwitch(sw)=val q 1
 q 0
%swseter ; Some error occured when Setting Switch (sw) to (val)...
 s $zt=""
 q $s(detail:-1_$c(1)_$ze,1:-1)
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/FILEINC.inc#1 $ ($Change: 7440104 $) */
 ; BITWISE.INC
FIXDIR(dir) ;procedure, dir is passed by reference
 Q:dir=""
 Q:$A(dir,$L(dir))=$A($s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""))
 s dir=dir_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")
 Q
fixdir(dir) ;function
 Q:dir="" ""
 Q:$A(dir,$L(dir))=$A($s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")) dir
 Q dir_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")
basename(f) ;similar to basename on UNIX
 Q $P(f,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""),1,$L(f,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""))-1)_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")
appdir(d1,d2) ;use $zu(12,d2) to append d2 to canonic dir
 S d1=d1_d2
 Q d1
VALIDIR(dir) ;validate directory dir and create it if dir doesn't exist
 new flag
 s flag=1
 g vdir2
validir(dir,flag) ;validate directory dir and optionally create it if it
vdir2 ; VALIDIR(dir) comes here with flag set to 1
 quit:$$ChkDirOrSpecEXISTS(dir)'="" 1   ; dir is valid and exists
 quit:$$ChkDirVALID(dir)="" 0    ; dir is not valid
 i flag'=1 q 0  ; flag says don't create, return failure
 new x
 set x=$$mkdir(dir)  ; returns 0 for success, 1 for failure
 q:x=1 0  ; failed to create
 quit:$$ChkDirOrSpecEXISTS(dir)="" 0   ; it doesn't we failed
 q 1  ; success
mkdir(dir) ;create a new directory
 q '##class(%Library.File).CreateDirectoryChain(dir)
jrnshort(jf,short) ;get/set short form of a journal file name FIXME HYY1999
         N (jf,short)
         S len=$L($P(jf,";"))
         Q:$G(short)="" $E(jf,len-11,len) ;"GET" form
         S $E(jf,len-11,len)=short ;"SET" form
         Q jf
GJrnPrefix(jf) ;extract prefix from the journal file name jf
         N (jf)
         S fname=$P(jf,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""),$L(jf,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")))       
         Q $e(fname,1,$l($p(fname,"."))-8)
GetJrnFileName(path) { 
	i $f(path,"/") q $p(path,"/",$l(path,"/")) ;presumably a Unix path
	if $f(path,"\") q $p(path,"\",$l(path,"\")) ;presumably a Windows path
	s vmsfile=$p(path,"]",2) i vmsfile="" q path ;a name only, not a path
	q $p(vmsfile,";") ;return name from a VMS path without trailing ";"
}
dirinvalidmsg(dir1,dir2) 
 n valid1,valid2,cnt,msg
 s valid1=$$VALIDIR(dir1),valid2=$$VALIDIR(dir2)
 s cnt=valid1+valid2 ; cnt = 0 if both invalid, 1 if one is valid
 s msg="The following journaling "
 s:cnt msg=msg_"directory is" 
 s:'cnt msg=msg_"directories are"
 s msg=msg_" not valid"_$C(13,10)
 s:'valid1 msg=msg_"     "_dir1_$C(13,10)
 s:'valid2 msg=msg_"     "_dir2_$C(13,10)
 q msg
ChkDirVALID(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,1)
ChkDirEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkDirOrSpecEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,3)
ChkDir(R) N N S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkBad S $ZT="" W !,"<"_$P($P($ZE,"<",2),">")_"> error -- invalid directory"
 Q ""
%msub() New x Set x=$I(^mtemp) Kill ^mtemp(x) Quit x

JRNUTIL2^INT^1^67214,47330
JRNUTIL2 ;      ;$Change: 7440104 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ; Revision: $Id: //iris/2024.1.3/databases/sys/rtn/journal/jrnutil2.mac#1 $
 Q
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/FILEINC.inc#1 $ ($Change: 7440104 $) */
HISTCVT ;convert old form of journal history to new form (with trailing "J")
 n jrnhist,jf
 s jrnhist=$name(^%SYS("JOURNAL","HISTORY"))
 s $zt="etHISTCVT"
 s jf="" f  s jf=$o(@jrnhist@(jf)) q:jf=""  d:jf'["J"
 . m @jrnhist@(jf_"J")=@jrnhist@(jf)  
 . k @jrnhist@(jf)  
 q    
etHISTCVT ;
 s $zt=""
 i $ze'="" d $zu(9,"","HISTCVT:"_$ze,(0>0),0)
 q
HistCvtGloToLog(mgdir,jrnlogpath,debug) [] PUBLIC {
 d $zu(9,"","Converting journal history global to journal log",(0>0),0)
 i '$D(mgdir) s mgdir=$ZU(12)
 e  s mgdir=$zu(12,mgdir)
 s mgns="^^"_mgdir
 i $g(jrnlogpath)="" s jrnlogpath=mgdir_"journal.log"
 s sysjrnglo=$name(^|mgns|%SYS("JOURNAL"))
 i $zu(140,1,jrnlogpath)>0 {	// there exists a journal.log file
   s oldlogpath=mgdir_"jrnlog.old"
   s errcode=$zu(140,6,jrnlogpath,oldlogpath)
   i errcode {
     d $zu(9,"","Error "_errcode_" renaming the old "_jrnlogpath_" to "_oldlogpath,(2>0),2)
     d $zu(9,"","Aborted operation to convert journal history to "_jrnlogpath,(2>0),2)
     q
   } else {
     d $zu(9,"","The old "_jrnlogpath_" has been renamed to "_oldlogpath,(0>0),0)
   }
 }
 s jrnflist=0 ;initial file index
 s lastfile=""
 i mgdir=$ZU(12) {
   s lastfile=$zu(78,3)
   i lastfile="" {	// journaling is off
     s lastfile=$p($zu(78,21),",",2)
   }
 }
 i lastfile="" {
   s lastfile=$P($G(@sysjrnglo@("WIJFILE")),",",1)
 }
 i lastfile="" && ($p($g(@sysjrnglo@("LAST")),",",2)]"") {	
   s lastfile=$p($G(@sysjrnglo@("LAST")),"^",2)
 }
 i lastfile]"" {
   f  {
     i $ZU(78,22,lastfile)<1 s lastfile="" q  ;a broken chain
     s nextfile=$P($zu(78,22,lastfile,2),",",2) q:nextfile=""
     s lastfile=nextfile
   }
 }
 i lastfile="" {
   s curdir=$g(@sysjrnglo@("CURDIR")) 
   i curdir]"" s curdir=$zu(12,curdir),jrndir(curdir)=""
   s altdir=$g(@sysjrnglo@("ALTDIR")) 
   i altdir]"" s altdir=$zu(12,altdir),jrndir(altdir)=""
   s prefix=$g(@sysjrnglo@("PREFIX"))
   s jrndir="",lastname="" f  {
     s jrndir=$o(jrndir(jrndir)) q:jrndir=""
     s prename=$zu(12,jrndir_prefix,prefix="") ;put prefix in "canonical" file form
     s prenamelen=$l(prename)
     s wildpath=prename_"*.*"
     s filepath=$zse(wildpath)
     f  {
       q:filepath=""  s filepath=$zu(12,filepath)
       i $e(filepath,1,prenamelen)=prename {
     s:$E(filepath,*)="z" $E(filepath,*)=""
	 s filename=$e(filepath,prenamelen+1,$l(filepath))
         i filename?8N1"."3.10N0.1"z",(($p(filename,".")>$p(lastname,"."))||(($p(filename,".")=$p(lastname,"."))&&(+$p(filename,".",2)>+$p(lastname,".",2)))),$ZU(78,22,filepath)>0 {
	   s lastfile=filepath,lastname=$case($ZBITGET($ZVERSION(0),46),0:$case($f(lastfile,";"),0:$e(lastfile,*-8-$l($p(lastfile,".",$l(lastfile,"."))),*-$case($e(lastfile,*)="z",0:0,1:1)),:$e(lastfile,*-8-$l($p(lastfile,".",$l(lastfile,"."))),$f(lastfile,";")-2)),:lastfile)
	 }
       }
       s filepath=$zse("")
     }
   }
 }
 i lastfile="" {
   d $zu(9,"","No journal history to convert",(1>0),1)
   q
 }
 s OrigStorage=$ZSTORAGE
 s $ZSTORAGE=2147483647
 f  {
   s rc=$$PREVJRN^JRNUTILOLD(lastfile,.prevfile,0,mgdir) 
   i 'rc q  ;lastfile is bad or doesn't exist
   s JrnFiles($i(jrnflist,-1))=lastfile
   i rc<0 q  ;errors preventing us from continuing
   i prevfile="" q  ;no next file -- done
   s lastfile=prevfile
 }
 s Status=##class(%SYS.Journal.History).Build(jrnlogpath,.JrnFiles)
 k JrnFiles ; Clean
 s $ZSTORAGE=OrigStorage
 i Status {
   d $zu(9,"","Created "_jrnlogpath_" using information on existing journal files",(0>0),0)
   i mgdir=$zu(12) k @sysjrnglo@("HISTORY")
 } else {
   d $zu(9,"","Error building journal.log: "_$System.Status.GetErrorText(Status),(2>0),2)
 }
 q
}
 ; input: 
 ;   jrnfile: long form of new-styled journal file name
 ;   within (default=0): 1=stay within [START,STOP] boundary
 ;   mgdir when present is where to find %SYS. This is used in
 ;       restoring other cluster member's journal files when we
 ;       need to read their journal history.
 ;	 mironly (default=0): 1=show only mirror journal files (i.e., read from mirrorjrn-<mirname>.log)
 ; output:
 ;   prevfile: long form of prev journal file name (""=no prev file)
 ;   return 1 (=success) or errcode (0 or negative)
 ; error code:
 ;   0=file name format not supported or bad jrnfile (nonexistent or corrupted)
 ;  -1=previous file is not a journal file or does not exist
 ;  -2="missing directory information"
 ;  -3="program error"
 ;  -4="<UNDEFINED> error likely due to incomplete history record"
 ;  -5="weird"
 ;  -6=infinite loop in journal file link, possibly the resutl of setting
 ;     back system date
 ;  -7="unable to lock journal history log for read"
 ;  -8="unable to open journal history log"
 ;  -9="error reading journal history log"
 ; -10="journal file not found in journal log"
PREVJRN(jrnfile,prevfile,within,mgdir,mironly,mirname="") 
	if $ZBITGET($ZVERSION(0),46) {
		quit $$PREVJRNds(jrnfile,.prevfile)
	}
 i '$S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0) n mgdir ; ignore on non-clustered systems
 s $zt="etNXPVJRN"
 n mgns,return,jrnhist,ret,next,curdir,altdir,prefix,pfile,prev
 i '$D(mgdir) s mgdir=$ZU(12)
 s mgns="^^"_mgdir
 n prevguid,prevret
 s return=$zu(78,22,jrnfile,99)
 s prevfile=$p(return,",",1+1)
 s prevguid=$p(return,",",6+1)
 i return>0 s return=1 ;checked by the code below to indicate jrnfile is good
 i prevguid'="" {
   try {s prevret=$zu(78,22,prevfile,99)} catch {s prevret=0}
   i prevret>0 {
     i prevguid'=$p(prevret,",",7+1) {
       s prevfile="" 
     }
     i '$g(mironly) q 1 
   }
 }
 s within=$g(within) q:within +return
 s mironly=+$g(mironly)
 if mironly s prevfile=""  
 ;jrnfile is corrupted (return=-1) or nonexistent (return=0)
 i 'mironly,+return'=1 q 0
 i mironly,jrnfile]"",+return'=1 q 0
 ;or prevfile is located via back pointer
 q:prevfile'="" 1
 n jrnlogfile,filepath,thisguid,rc,miridx,etstate
 s jrnlogfile=mgdir_"journal.log"
 s $zt="ErrLog"
 s miridx=0
 i mironly { 
 	n mm
    if $SYSTEM.Mirror.IsMember() {
 		if mirname="" s mirname=##class(Config.Mirrors).GetMirrorName()
	 	s jrnlogfile=mgdir_"mirrorjrn-"_mirname_".log"
 		s miridx=$SYSTEM.Mirror.MirrorNameToIndex(mirname,0)
 		i miridx<0 s miridx=0
 		s miridx=miridx+1
 	}
 }
 i $zu(78,79,0,1,miridx)
 s etstate=1 ;log file locked (must be released upon exit)
 o jrnlogfile:("r":/IOT="UTF8"):0 e  d   q -8
 . i $zu(78,79,0,0,miridx)
 . d $zu(9,"","PREVJRN: failed to open journal log "_jrnlogfile)
 s rc=##class(%SYS.Journal.System).GetHistoryHeader(jrnlogfile,,miridx) ;skip header
 i 'rc c jrnlogfile d $zu(78,79,0,0,miridx),$zu(9,"","PREVJRN: "_rc) q -9_","_rc
 s zeofset=$zu(68,40,1),filepath=""
 s thisguid=$zu(78,22,jrnfile,7) ;return "7,GUID" or <=0 (nonexisting jrnfile)
 i thisguid>0 {	;jrnfile exists
   s thisguid=$p(thisguid,",",2) ;GUID of jrnfile
   f  {
     u jrnlogfile r logline 
     i $ZEOF s filepath="" q  ;jrnfile not found
     i ($tr(logline,$c(13,10))="") continue  ;skip blank lines
     i miridx {
	    s prevfile=filepath,filepath=$p(logline,",",1),guid=$p(logline,",",3) 
     }
     else {
     	s prevfile=filepath,filepath=$p(logline,",",2),guid=$p(logline,",",4)
     }
     i guid=thisguid q  ;found jrnfile and its previous file
   }
 } else {	;jrnfile doesn't exist or is not accessible
   f  {
     u jrnlogfile r logline 
     i $ZEOF s:'miridx filepath="" q  ;jrnfile not found
     i ($tr(logline,$c(13,10))="") continue  ;skip blank lines
     i miridx {
	    s prevfile=filepath,filepath=$p(logline,",",1) 
     }
     else {
     	s prevfile=filepath,filepath=$p(logline,",",2) 
     }
     i filepath=jrnfile q  ;found jrnfile and its previous file
   }
   i miridx,jrnfile="" s jrnfile=filepath
 }
 i 'zeofset,$zu(68,40,0) ;restore <ENDOFFILE>
 c jrnlogfile
 i $zu(78,79,0,0,miridx)
 i filepath="" q -10 ;jrnfile not found in the log
 q 1 ;jrnfile is found in the log (prevfile can be "")
 ;---------------------------------------------------------------
 ; input: 
 ;   jrnfile: long form of new-styled journal file name
 ;   within (default=0): 1=stay within [START,STOP] boundary
 ;   mgdir when present is where to find %SYS. This is used in
 ;       restoring other cluster member's journal files when we
 ;       need to read their journal history.
 ;	 mironly (default=0): 1=show only mirror journal files (i.e., read from mirrorjrn-<mirname>.log)
 ; output:
 ;   nextfile: long form of next journal file name (""=no next file)
 ;   return 1 (=success) or errcode (0 or negative)
 ; error code:
 ;   0="file name format not supported"
 ;  -1="next is not a journal file"
 ;  -2="missing directory information"
 ;  -3="program error"
 ;  -4="<UNDEFINED> error likely due to incomplete history record"
 ;  -7="unable to lock journal history log for read"
 ;  -8="unable to open journal history log"
 ;  -9="error reading journal history log"
 ; -10="journal file not found in journal log"
NEXTJRN(jrnfile,nextfile,within,mgdir,mironly,mirname) ;
 i '$S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0) n mgdir ; ignore on non-clustered systems
 s $zt="etNXPVJRN"
 if $ZBITGET($ZVERSION(0),46) {
 	 s nextfile=$zu(78,22,jrnfile,2)
 	 q:+nextfile'=2 0  ;failed, nextfile = error code
 	 s nextfile=$p(nextfile,",",2)   ;next file or ""
 	 q 1
 }
 n mgns,jrnhist,prev,x,ret,found
 n dir1,dir2,prefix,date,hdate,seq ;associated with jrnfile
 n limit,limitj,seql,dirl ;associated with limit
 i '$D(mgdir) s mgdir=$ZU(12)
 s mgns="^^"_mgdir
 s mironly=+$g(mironly)
 i jrnfile'?8N1"."3.10N0.1"z" s nextfile=$zu(78,22,jrnfile,2) q:+nextfile'=2 0 s nextfile=$p(nextfile,",",2) s:mironly nextfile="" q:nextfile]"" 1
 if 'mironly,(+$P($ZU(78,22,jrnfile,13),",",2)) {
	 s nextfile=$$NextJournalFromJournalLog^JRNUTIL(jrnfile,.rc)
     i +rc'<0 quit 1  ;nextfile is name of next journal file (could be "" if there isn't one)
     if '$SYSTEM.Mirror.IsMember() q 0
     s mironly = 1
 }
 n jrnlogfile,filepath,zeofset,thisguid,guid,rc,etstate
 s jrnlogfile=mgdir_"journal.log"
 s $zt="ErrLog"
 n miridx s miridx=0
 i mironly { 
 	n mm
    if $SYSTEM.Mirror.IsMember() {
 		if $g(mirname)="" s mirname=##class(Config.Mirrors).GetMirrorName()
	 	s jrnlogfile=mgdir_"mirrorjrn-"_mirname_".log"
 		s miridx=$SYSTEM.Mirror.MirrorNameToIndex(mirname,0)
 		i miridx<0 s miridx=0
 		s miridx=miridx+1
 	}
 }
 i $zu(78,79,0,1,miridx)
 s etstate=1 ;log file locked (must be released upon exit)
 o jrnlogfile:("r":/IOT="UTF8"):0 e  d   q -8
 . i $zu(78,79,0,0,miridx)
 . d $zu(9,"","NEXTJRN: failed to open journal log "_jrnlogfile)
 s rc=##class(%SYS.Journal.System).GetHistoryHeader(jrnlogfile,,miridx) ;skip header
 i 'rc c jrnlogfile d $zu(78,79,0,0,miridx),$zu(9,"","NEXTJRN: "_rc) q -9_","_rc
 s zeofset=$zu(68,40,1),filepath="",nextfile="",found=0
 s etstate=2 ;log file opened (must be closed upon exit)
 s thisguid=$zu(78,22,jrnfile,7) ;return "7,GUID" or <=0 (nonexisting jrnfile)
 n logline
 i thisguid>0 {
   s thisguid=$p(thisguid,",",2) ;GUID of jrnfile
   f  {
     u jrnlogfile r logline i $ZEOF=-1 q  ;nextfile="" (filepath=jrnfile or not)
     i ($tr(logline,$c(13,10))="") continue  ;skip blank lines
     i found s nextfile=$s(mironly:$p(logline,",",1),1:$p(logline,",",2)) q
     s guid=$s(mironly:$p(logline,",",3),1:$p(logline,",",4)),found=(guid=thisguid)
   }
 } else {
   f  {
     u jrnlogfile r logline i $ZEOF=-1 q  ;nextfile="" (filepath=jrnfile or not)
     i ($tr(logline,$c(13,10))="") continue  ;skip blank lines
     i found s nextfile=$s(mironly:$p(logline,",",1),1:$p(logline,",",2)) q
     s filepath=$s(mironly:$p(logline,",",1),1:$p(logline,",",2)),found=(jrnfile=filepath)
   }
 }
 i 'zeofset,$zu(68,40,0) ;restore <ENDOFFILE>
 c jrnlogfile
 i $zu(78,79,0,0,miridx)
 i 'found q -10 ;jrnfile not found in the log
 q 1 ;jrnfile is found in the log (nexfile="" possible)
ErrLog s $zt="" d BACK^%ETN i $zu(9,"",$ze)
 i $g(etstate)=2 d
 . i '$g(zeofset,1),$zu(68,40,0) ;skip if zeofset is undefined or set to 1
 . c jrnlogfile
 i +$g(etstate)>=1,$d(miridx) d $zu(78,79,0,0,miridx)
 ztrap $ze  ;pass it on to upper error handler
etNXPVJRN 
 s $zt=""
 i $ze["UNDEFINED" s $zt="etNXPVJRN" q "-4missing "_$zr_" ?"  ;$zr would never generate <UNDEFINED> error
 q -3_$ze
ERNXPVJRN(err,file,order) ;order: 1=errors in NEXTJRN, -1=PREVJRN
 s $zt="etERNXPVJRN"
 n errcode s err=$g(err),file=$g(file),errcode=+err,order=+$g(order,1)
 i errcode=-1 q "the "_$s(order=-1:"prev",1:"next")_" file of "_file_" is not a journal file or does not exist"
 i errcode=-2 q "missing directory information in journal history"
 i errcode=-3!(errcode=-4) q $e(err,3,$l(err))
 i errcode=-5,order=-1 q "error in finding previous file of "_file
 i errcode=-6,order=-1 q "infinite loop @ "_$p(err,",",2)_" in journal file link, possibly resulting from setting back system date"
 i errcode=0 q file_" is not a journal file or does not exist"
 i errcode=-8 q "unable to open journal history log"
 i errcode=-9 q "error reading journal history log"
 i errcode=-10 q file_" not found in journal log"
 q ""
etERNXPVJRN
 s $zt=""
 q $ze
 ; PREVJRNds is the PREVJRN function for USEDSONLY builds.
 ; This takes the same inputs as PREVJRN and return the same
 ;     output. For USEDSONLY builds the prior journal file is
 ;     always read from the journal header of the current journal
 ;     file but we need to check the journal file sequence #'s
 ;     to detect wrap around and ensure that the prior file listed
 ;     actually preceeds the current file.
 ; input: 
 ;   jrnfile: long form of new-styled journal file name
 ; output:
 ;   prevfile: long form of prev journal file name (""=no prev file)
 ;   return 1 (=success) or errcode (0 or negative)
 ; error code:
 ;   0=file name format not supported or bad jrnfile (nonexistent or corrupted)
 ;  -1=previous file is not a journal file or does not exist
 ;  -3="program error"
PREVJRNds(jrnfile,prevfile) PUBLIC {
	 s $zt="err"
	 s curinfo=$zu(78,22,jrnfile,99)
	 if +curinfo<=0 {
		 quit 0  ;input file is not a journal file or doesn't exist
	 }
	 s curjrnfilecnt=$P(curinfo,",",9+1)  ;+1 because of return code
	 s prevfile=$P(curinfo,",",1+1)
	 if prevfile="" {
		 ; This file was created by ^JRNSTART and there
		 ; isn't any prior file (for USEDSONLY, we set the prior
		 ; file to null during jrnstart)
		 quit 1
	 }
	 s previnfo=$zu(78,22,prevfile,99)
	 if +previnfo<=0 {
		 s prevfile=""
		 quit -1  ;prior file is not a journal file or doesn't exist
	 }
	 s prevjrnfilecnt=$P(previnfo,",",9+1)
	 if (prevjrnfilecnt+1)'=curjrnfilecnt {
		 s prevfile=""
	 }
	 quit 1
err	;
	s $zt=""
	quit -3  ;unexpected error	 
}
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/FILEINC.inc#1 $ ($Change: 7440104 $) */
 ; BITWISE.INC
FIXDIR(dir) ;procedure, dir is passed by reference
 Q:dir=""
 Q:$A(dir,$L(dir))=$A($s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""))
 s dir=dir_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")
 Q
fixdir(dir) ;function
 Q:dir="" ""
 Q:$A(dir,$L(dir))=$A($s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")) dir
 Q dir_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")
basename(f) ;similar to basename on UNIX
 Q $P(f,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""),1,$L(f,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""))-1)_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")
appdir(d1,d2) ;use $zu(12,d2) to append d2 to canonic dir
 S d1=d1_d2
 Q d1
VALIDIR(dir) ;validate directory dir and create it if dir doesn't exist
 new flag
 s flag=1
 g vdir2
validir(dir,flag) ;validate directory dir and optionally create it if it
vdir2 ; VALIDIR(dir) comes here with flag set to 1
 quit:$$ChkDirOrSpecEXISTS(dir)'="" 1   ; dir is valid and exists
 quit:$$ChkDirVALID(dir)="" 0    ; dir is not valid
 i flag'=1 q 0  ; flag says don't create, return failure
 new x
 set x=$$mkdir(dir)  ; returns 0 for success, 1 for failure
 q:x=1 0  ; failed to create
 quit:$$ChkDirOrSpecEXISTS(dir)="" 0   ; it doesn't we failed
 q 1  ; success
mkdir(dir) ;create a new directory
 q '##class(%Library.File).CreateDirectoryChain(dir)
jrnshort(jf,short) ;get/set short form of a journal file name FIXME HYY1999
         N (jf,short)
         S len=$L($P(jf,";"))
         Q:$G(short)="" $E(jf,len-11,len) ;"GET" form
         S $E(jf,len-11,len)=short ;"SET" form
         Q jf
GJrnPrefix(jf) ;extract prefix from the journal file name jf
         N (jf)
         S fname=$P(jf,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""),$L(jf,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")))       
         Q $e(fname,1,$l($p(fname,"."))-8)
GetJrnFileName(path) { 
	i $f(path,"/") q $p(path,"/",$l(path,"/")) ;presumably a Unix path
	if $f(path,"\") q $p(path,"\",$l(path,"\")) ;presumably a Windows path
	s vmsfile=$p(path,"]",2) i vmsfile="" q path ;a name only, not a path
	q $p(vmsfile,";") ;return name from a VMS path without trailing ";"
}
dirinvalidmsg(dir1,dir2) 
 n valid1,valid2,cnt,msg
 s valid1=$$VALIDIR(dir1),valid2=$$VALIDIR(dir2)
 s cnt=valid1+valid2 ; cnt = 0 if both invalid, 1 if one is valid
 s msg="The following journaling "
 s:cnt msg=msg_"directory is" 
 s:'cnt msg=msg_"directories are"
 s msg=msg_" not valid"_$C(13,10)
 s:'valid1 msg=msg_"     "_dir1_$C(13,10)
 s:'valid2 msg=msg_"     "_dir2_$C(13,10)
 q msg
ChkDirVALID(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,1)
ChkDirEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkDirOrSpecEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,3)
ChkDir(R) N N S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkBad S $ZT="" W !,"<"_$P($P($ZE,"<",2),">")_"> error -- invalid directory"
 Q ""

JRNUTILOLD^INT^1^67214,47330
JRNUTILOLD ;Old utilities for converting journal history
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 Q
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/FILEINC.inc#1 $ ($Change: 7440104 $) */
HISTCVT ;convert old form of journal history to new form (with trailing "J")
 n jrnhist,jf
 i +$g(^%SYS("JOURNAL","HISTORYVERSION"))'<1 q  ;alread updated
 s jrnhist=$name(^%SYS("JOURNAL","HISTORY"))
 s $zt="etHISTCVT"
 s jf="" f  s jf=$o(@jrnhist@(jf)) q:jf=""  d:jf'["J"
 . m @jrnhist@(jf_"J")=@jrnhist@(jf)  
 . k @jrnhist@(jf)  
 s ^%SYS("JOURNAL","HISTORYVERSION")=1
 q    
etHISTCVT ;
 s $zt=""
 i $ze'="" d $zu(9,"","HISTCVT:"_$ze,(0>0),0)
 q
 ; input: 
 ;   jrnfile: long form of new-styled journal file name
 ;   within (default=0): 1=stay within [START,STOP] boundary
 ;   mgdir when present is where to find %SYS. This is used in
 ;       restoring other cluster member's journal files when we
 ;       need to read their journal history.
 ; output:
 ;   prevfile: long form of prev journal file name (""=no prev file)
 ;   return 1 (=success) or errcode (0 or negative)
 ; error code:
 ;   0=file name format not supported or bad jrnfile (nonexistent or corrupted)
 ;  -1=previous file is not a journal file or does not exist
 ;  -2="missing directory information"
 ;  -3="program error"
 ;  -4="<UNDEFINED> error likely due to incomplete history record"
 ;  -5="weird"
 ;  -6=infinite loop in journal file link, possibly the resutl of setting
 ;     back system date
PREVJRN(jrnfile,prevfile,within,mgdir) 
 s $zt="etNXPVJRN"
 n mgns,return,jrnhist,ret,next,curdir,altdir,prefix,pfile,prev
 i '$D(mgdir) s mgdir=$ZU(12)
 s mgns="^^"_mgdir
 s return=$zu(78,22,jrnfile,1),prevfile=$p(return,",",2)
 s within=$g(within) q:within +return
 ;jrnfile is corrupted (return=-1) or nonexistent (return=0)
 q:+return'=1 0
 ;or prevfile is located via back pointer
 q:prevfile'="" 1
 s jrnfile=$case($ZBITGET($ZVERSION(0),46),0:$case($f(jrnfile,";"),0:$e(jrnfile,*-8-$l($p(jrnfile,".",$l(jrnfile,"."))),*-$case($e(jrnfile,*)="z",0:0,1:1)),:$e(jrnfile,*-8-$l($p(jrnfile,".",$l(jrnfile,"."))),$f(jrnfile,";")-2)),:jrnfile)
 q:jrnfile'?8N1"."3N 0 
 s jrnhist=$name(^|mgns|%SYS("JOURNAL","HISTORY"))
 ;by now we know jrnfile should be a START entry in journal history
 ;it may or may not be preceded by a STOP entry though (due to a crash)   
 s prev=$o(@jrnhist@(jrnfile_"J"),-1) q:prev="" 1  ;no previous file (prevfile="")
 s prevfile=$g(@jrnhist@(prev,"FULLNAME"),$p(prev,"J"))
 n jrnflist s jrnflist=$name(^||JrnFileList($i(^||JrnFileList))) k @jrnflist
 f  s @jrnflist@(prevfile)="",ret=$$NEXTJRN(prevfile,.next,0,mgdir) q:ret'>0  q:next=""  q:$case($ZBITGET($ZVERSION(0),46),0:$case($f(next,";"),0:$e(next,*-8-$l($p(next,".",$l(next,"."))),*-$case($e(next,*)="z",0:0,1:1)),:$e(next,*-8-$l($p(next,".",$l(next,"."))),$f(next,";")-2)),:next)'<jrnfile  s prevfile=next i $d(@jrnflist@(prevfile)) s ret="-6,"_prevfile q
 k @jrnflist
 i ret>0 s prevfile=$case($ZBITGET($ZVERSION(0),46),0:$case($f(prevfile,";"),0:$e(prevfile,*-8-$l($p(prevfile,".",$l(prevfile,"."))),*-$case($e(prevfile,*)="z",0:0,1:1)),:$e(prevfile,*-8-$l($p(prevfile,".",$l(prevfile,"."))),$f(prevfile,";")-2)),:prevfile),next=$case($ZBITGET($ZVERSION(0),46),0:$case($f(next,";"),0:$e(next,*-8-$l($p(next,".",$l(next,"."))),*-$case($e(next,*)="z",0:0,1:1)),:$e(next,*-8-$l($p(next,".",$l(next,"."))),$f(next,";")-2)),:next)
 i ret<0 q ret
 i 'ret {
   i prevfile=$g(@jrnhist@(prev,"FULLNAME"),$p(prev,"J")) {
     i $l($g(@jrnhist@(prev,"DATE")),"^")>1 q -1 ;jrnfile's prev no longer exists
   }
   q -1
 }
 i next>jrnfile q -5 ;weird
 i '$d(@jrnhist@(prev,"CURDIR")) d  q:ret'>0 ret ;must be a STOP entry
 . s prev=$o(@jrnhist@(prev),-1) s:prev="" ret=-2
 s curdir=@jrnhist@(prev,"CURDIR"),altdir=@jrnhist@(prev,"ALTDIR")
 i $d(@jrnhist@(prev,"PREFIX")) s prefix=@jrnhist@(prev,"PREFIX")
 e  d
 . s prefix=$$GJrnPrefix(@jrnhist@(prev,"FULLNAME"))
 s pfile=curdir_prefix_prevfile,ret=$zu(78,22,pfile) 
 i 'ret,altdir'=curdir s pfile=altdir_prefix_prevfile,ret=$zu(78,22,pfile)
 s prevfile=pfile ;set prevfile regardless of ret value
 ;return -1 if previous file is nonexistent (ret=0) or corrupted (ret=-1)
 q $s(ret=1:1,1:-1)  
 ;---------------------------------------------------------------
 ; input: 
 ;   jrnfile: long form of new-styled journal file name
 ;   within (default=0): 1=stay within [START,STOP] boundary
 ;   mgdir when present is where to find %SYS. This is used in
 ;       restoring other cluster member's journal files when we
 ;       need to read their journal history.
 ; output:
 ;   nextfile: long form of next journal file name (""=no next file)
 ;   return 1 (=success) or errcode (0 or negative)
 ; error code:
 ;   0="file name format not supported"
 ;  -1="next is not a journal file"
 ;  -2="missing directory information"
 ;  -3="program error"
 ;  -4="<UNDEFINED> error likely due to incomplete history record"
NEXTJRN(jrnfile,nextfile,within,mgdir) ;
 s $zt="etNXPVJRN"
 n mgns,jrnhist,prev,x,ret,found
 n dir1,dir2,prefix,date,hdate,seq ;associated with jrnfile
 n limit,limitj,seql,dirl ;associated with limit
 i '$D(mgdir) s mgdir=$ZU(12)
 s mgns="^^"_mgdir
 i jrnfile'?8N1"."3N s nextfile=$zu(78,22,jrnfile,2) q:+nextfile'=2 0 s nextfile=$p(nextfile,",",2) q:nextfile]"" 1
 ;no next journal for old-styled journal file or wrong file
 s:jrnfile'?8N1"."3N jrnfile=$case($ZBITGET($ZVERSION(0),46),0:$case($f(jrnfile,";"),0:$e(jrnfile,*-8-$l($p(jrnfile,".",$l(jrnfile,"."))),*-$case($e(jrnfile,*)="z",0:0,1:1)),:$e(jrnfile,*-8-$l($p(jrnfile,".",$l(jrnfile,"."))),$f(jrnfile,";")-2)),:jrnfile)
 q:jrnfile'?8N1"."3N 0 
 ;from now on, jrnfile has the format yyyymmdd.nnn
 s within=+$g(within),nextfile="" ;no next file
 s jrnfile=jrnfile_"J" ;now jrnfile has a trailing "J" (used in global)
 s jrnhist=$name(^|mgns|%SYS("JOURNAL","HISTORY"))
 s x=$d(@jrnhist@(jrnfile))
 ;either jrnfile itself is an entry in history
 i x q:$l($g(@jrnhist@(jrnfile,"DATE")),"^")>1&within 1 s prev=jrnfile
 ;or prev is a START or SWITCH (no 2nd field in "DATE")
 i 'x s prev=$o(@jrnhist@(jrnfile),-1) q:prev="" -2  ;q:$l(@jrnhist@(prev,"DATE"),"^")>1 -2
 ;limit = where to stop (last journal file to restore)
 s limit=$o(@jrnhist@(jrnfile))
 ;if jrnfile is a STOP entry, its next file (if any) must be recorded in 
 ;journal history (as a START entry), thus must be the "limit" entry
 i x,$p($g(@jrnhist@(jrnfile,"DATE")),"^",2)'="" d:limit'=""  q 1
 . s nextfile=@jrnhist@(limit,"CURDIR")_@jrnhist@(limit,"PREFIX")_$p(limit,"J")
 i limit="" s limit=$zd($h,8)_".999" ;last jrn file from today
 e  i within,$g(@jrnhist@(limit,"DATE"))]"",$l(@jrnhist@(limit,"DATE"),"^")=1 d  q:jrnfile=limit 1
 . ;since we are required to stay within the boundary and next entry is
 . ;a START, the "limit" must be one file earlier than that.
 . s limit=$p(limit,"J") d decrement(.limit) s limit=limit_"J"
 s dir1=@jrnhist@(prev,"CURDIR")
 s dir2=@jrnhist@(prev,"ALTDIR") s:dir2=dir1 dir2=""
 i $d(@jrnhist@(prev,"PREFIX")) s prefix=@jrnhist@(prev,"PREFIX")
 e  d
 . s prefix=$$GJrnPrefix(@jrnhist@(prev,"FULLNAME"))
 ;we don't use @jrnhist@(jrnfile) anymore, so remove "J" from jrnfile and limit
 s jrnfile=$p(jrnfile,"J"),limit=$p(limit,"J")
 s date=$p(jrnfile,"."),hdate=$zdh(date,8),seq=+$p(jrnfile,".",2)
 n ret1,ret2
 s ret2=0,ret1=$$nextseq(dir1_prefix_date,seq,.nextfile) i ret1>0 q ret1 ;found
 i dir2]"" s ret2=$$nextseq(dir2_prefix_date,seq,.nextfile) i ret2>0 q ret2
 i ret1!ret2 q -1 ;next file is invalid
 s found=0 f  s hdate=hdate+1,date=$zd(hdate,8) q:date>limit  d  q:found
 . s nextfile=dir1_prefix_date_".001"
 . s ret2=0,ret1=$zu(78,22,nextfile) i ret1>0 s found=ret1 q  ;found
 . i dir2]"" s nextfile=dir2_prefix_date_".001",ret2=$zu(78,22,nextfile) i ret2>0 s found=ret2 q
 . i ret1!ret2 s found=-1 q  ;next file is invalid
 i found q found ;however, found=-1 means nextfile is a non-journal file
 ;our last hope: limit itself is the next file (in a different directory
 ;or with a different prefix -- that is why we couldn't find it)
 s limitj=limit_"J",nextfile="" ;first assume nextfile not found (found=0)
 i $d(@jrnhist@(limitj)) d 
 . s dirl=@jrnhist@(limitj,"CURDIR") q:dirl=""  
 . n prefixl s prefixl=$g(@jrnhist@(limitj,"PREFIX"),prefix)
 . i prefixl=prefix,(dirl=dir1)||(dirl=dir2) q  ;already searched 
 . s seql=$p(limit,".",2) i seql'="001",seql-seq'=1 q
 . s nextfile=dirl_prefixl_limit
 . s found=$zu(78,22,nextfile)
 q $s(found:found,1:1)  ;return 1 (and nextfile="") if no nextfile found
etNXPVJRN 
 s $zt=""
 i $ze["UNDEFINED" s $zt="etNXPVJRN" q "-4missing "_$zr_" ?"  ;$zr would never generate <UNDEFINED> error
 q -3_$ze
ERNXPVJRN(err,file,order) ;order: 1=errors in NEXTJRN, -1=PREVJRN
 s $zt="etERNXPVJRN"
 n errcode s err=$g(err),file=$g(file),errcode=+err,order=+$g(order,1)
 i errcode=-1 q "the "_$s(order=-1:"prev",1:"next")_" file of "_file_" is not a journal file or does not exist"
 i errcode=-2 q "missing directory information in journal history"
 i errcode=-3!(errcode=-4) q $e(err,3,$l(err))
 i errcode=-5,order=-1 q "error in finding previous file of "_file
 i errcode=-6,order=-1 q "infinite loop @ "_$p(err,",",2)_" in journal file link, possibly resulting from setting back system date"
 i errcode=0 q file_" is not a journal file or does not exist"
 q ""
etERNXPVJRN
 s $zt=""
 q $ze
prevseq(preseq,seq,file) 
 q:seq=1 0
 s file=preseq_"."_$e(1000+seq-1,2,4)
 i '$ZU(78,22,file) q 0
 q $zu(78,22,file) 
nextseq(preseq,seq,file) 
 q:seq=999 0
 s file=preseq_"."_$e(1000+seq+1,2,4)
 i '$ZU(78,22,file) q 0
 q $zu(78,22,file) 
decrement(short) 
 n date,seq
 s date=$p(short,"."),seq=$p(short,".",2)
 i seq>1 s short=date_"."_$e(1000+seq-1,2,4) q
 s short=$zd($zdh(date,8)-1,8)_".001"
 q
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/FILEINC.inc#1 $ ($Change: 7440104 $) */
 ; BITWISE.INC
FIXDIR(dir) ;procedure, dir is passed by reference
 Q:dir=""
 Q:$A(dir,$L(dir))=$A($s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""))
 s dir=dir_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")
 Q
fixdir(dir) ;function
 Q:dir="" ""
 Q:$A(dir,$L(dir))=$A($s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")) dir
 Q dir_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")
basename(f) ;similar to basename on UNIX
 Q $P(f,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""),1,$L(f,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""))-1)_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")
appdir(d1,d2) ;use $zu(12,d2) to append d2 to canonic dir
 S d1=d1_d2
 Q d1
VALIDIR(dir) ;validate directory dir and create it if dir doesn't exist
 new flag
 s flag=1
 g vdir2
validir(dir,flag) ;validate directory dir and optionally create it if it
vdir2 ; VALIDIR(dir) comes here with flag set to 1
 quit:$$ChkDirOrSpecEXISTS(dir)'="" 1   ; dir is valid and exists
 quit:$$ChkDirVALID(dir)="" 0    ; dir is not valid
 i flag'=1 q 0  ; flag says don't create, return failure
 new x
 set x=$$mkdir(dir)  ; returns 0 for success, 1 for failure
 q:x=1 0  ; failed to create
 quit:$$ChkDirOrSpecEXISTS(dir)="" 0   ; it doesn't we failed
 q 1  ; success
mkdir(dir) ;create a new directory
 q '##class(%Library.File).CreateDirectoryChain(dir)
jrnshort(jf,short) ;get/set short form of a journal file name FIXME HYY1999
         N (jf,short)
         S len=$L($P(jf,";"))
         Q:$G(short)="" $E(jf,len-11,len) ;"GET" form
         S $E(jf,len-11,len)=short ;"SET" form
         Q jf
GJrnPrefix(jf) ;extract prefix from the journal file name jf
         N (jf)
         S fname=$P(jf,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""),$L(jf,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:"")))       
         Q $e(fname,1,$l($p(fname,"."))-8)
GetJrnFileName(path) { 
	i $f(path,"/") q $p(path,"/",$l(path,"/")) ;presumably a Unix path
	if $f(path,"\") q $p(path,"\",$l(path,"\")) ;presumably a Windows path
	s vmsfile=$p(path,"]",2) i vmsfile="" q path ;a name only, not a path
	q $p(vmsfile,";") ;return name from a VMS path without trailing ";"
}
dirinvalidmsg(dir1,dir2) 
 n valid1,valid2,cnt,msg
 s valid1=$$VALIDIR(dir1),valid2=$$VALIDIR(dir2)
 s cnt=valid1+valid2 ; cnt = 0 if both invalid, 1 if one is valid
 s msg="The following journaling "
 s:cnt msg=msg_"directory is" 
 s:'cnt msg=msg_"directories are"
 s msg=msg_" not valid"_$C(13,10)
 s:'valid1 msg=msg_"     "_dir1_$C(13,10)
 s:'valid2 msg=msg_"     "_dir2_$C(13,10)
 q msg
ChkDirVALID(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,1)
ChkDirEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkDirOrSpecEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,3)
ChkDir(R) N N S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkBad S $ZT="" W !,"<"_$P($P($ZE,"<",2),">")_"> error -- invalid directory"
 Q ""

JRNZIP^INT^1^67214,47330
JRNZIP ;Compress journal files
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/FILEINC.inc#1 $ ($Change: 7440104 $) */
 /*	s val=$$CHECK(val,.lastfail)  ; val starts as 0 and then the return value
                        		 ; is passed into the next call
                        		 ;lastfail is a local variable passed in for 
                        		 ; this routine to track the job cmd
                        		 ; failures. It is zero to start with and
                        		 ; then never touched by the caller
	The compression parameters are taken from ^SYS("JRNZIP") as followed:
		^SYS("JRNZIP","cengine")  ;defaults to zstd (engine #1)
		^SYS("JRNZIP","chunksz")  ;in mb, defaults to 4, range=1-16
  		^SYS("JRNZIP","loglevel") ;controls the messages generated
	This routine keeps track of the the most recent file # checked for compressing
	    in ^SYS("JRNZIP","lastchecked") and ^SYS("JRNZIP","lastchecked",<mirname>").
	    ^SYS("JRNZIP","lastchecked") contains a $$$JRNSHORTNAME with a trailing 'M' if its
	       a mirror journal and is used for the local journal file stream. 
	    ^SYS("JRNZIP","lastchecked",<mirname>") is used on async members and contains 
	       a mirror journal file count.
	    Each run starts by finding the most recent file that is eligible for compression 
	    (local file which is closed/non-final(*) mirror files with a valid end) and works 
	    backward to the 'lastchecked' location. 'lastchecked' is where we ended the last
	    compression pass. If we fail to compress a file its added to ^SYS("JRNZIP","retry",<file>)
	    to be retried. After scanning back to generate the list of files we run forward 
	    compressing the files. Then it repeats the check to see if more files became 
	    eligble for compression while it was working.
    If we fail to delete a file after compressing it (it may be open by
    	someone) we add the file to ^SYS("JRNZIP","PendingDelete",<filename>)
    	to be checked later. This is not counted as a failure
    The return value is a count which is the sum of all the journal file counts 
    	from the files being created. This is passed in so we can quickly check
    	whether we should scan for new files to compress or not. Files retrieved
    	via the agent are compressed (if needed) after they are received.
    CHECK is designed not to wait so it can be called by a process which is
     	responsible for other things as well. CHECK() jobs SCAN() if there is work
     	to do.
   (*) For Mirror journal files we never compress the most recent mirror journal, even if
       it has a valid end. When mirroring is started on a failover member we'll clear the
       valid end and compare the last block of the journal to the other failover member. Since
       we may update the file, we don't want it to be compressed.
 */
 /* The following are values for ^SYS("JRNZIP","loglevel"). */
 /* lastfail is passed by reference for use here in tracking failures
    in the job command */
CHECK(oldcnt,lastfail) PUBLIC { 
	s $zt="err"
	if $D(^SYS("JRNZIP","PendingDelete")) {
		;zero timeout because this lock can be blocked by someone 
		; comressing journal files and we don't want to wait if that's the
		; case as this is called by the RECEIVE process
		l +^%JRNZIPCHK:0
		if $T,$D(^SYS("JRNZIP","PendingDelete")) do ProcessPendingDeletes()
		l -^%JRNZIPCHK
	}
	if '$ZU(69,86) {
		quit oldcnt
	}
	if $G(^SYS("JRNZIP","pid"))'="",$D(^$LOCK("^%JRNZIPCHKSCAN")) {
		quit oldcnt
	}
	s cnt=$$jrnfilecnt()
	if (cnt'=oldcnt) {
		j SCAN()::5
		if '$T {
			;lastfail = <$zh of last msg>^<seconds to wait before next msg>
			s:+lastfail=0 lastfail=$ZH_"^300" ;5 min for initial msg
			s elapsed=$ZH-lastfail
			s msginterval=+$P(lastfail,"^",2)
			if elapsed>msginterval {  
			    ;add 5 minutes to the message interval until it gets to one hour
				s:msginterval<3600 msginterval=msginterval+300 
				s lastfail=$zh_"^"_msginterval
				s minutes=elapsed\60
				d $zu(9,"","CHECK^"_$ZN_": Unable to start scan for journal files to compress for "_minutes_" minutes",1 /* broadcast and log message*/,1  /* Warning */)
			}
			s cnt=oldcnt ;try again on the next pass rather than the next jrnfile
		} else {
			s lastfail=0
		}
	}
	quit cnt
err ;
	s $zt=""
	s lastref=$zr
	if $G(^SYS("JRNZIP",":errors:","CHECK"))'=+$ZTS {
		s ^SYS("JRNZIP",":errors:","CHECK")=+$ZTS
		d BACK^%ETN
	}
	d $zu(9,"","Journal File Compression: "_"CHECK^"_$ZN_" caught "_$ZE,1 /* broadcast and log message*/,2  /* Severe error */)
	quit 0
}
 /* SCAN() is jobbed off by CHECK() when CHECK() thinks
    there are files to compress. It can also be called
    directly. A lock is used to prevent two copies from 
    running at the same time. The lock does not conflict 
    with ^%JRNZIPCHK which is used to coordinate compressing 
    files and processing the pending delete list
    SCAN may wait (forever) if it cannot acquire the lock to
    check for journal files which need compression. It waits
    because RECEIVE won't start a new scan until a new journal file.
    SCAN calls main() to check for journal files from various
    sources. With "" main checks for local journal files. SCAN
    also calls main(<mirname>) for any mirrors we're a member of.
    SCAN also processes the retry list if there are files which failed
    to compress on earlier runs.
 */
SCAN() public {
	s $ZT="err"
	l +^%JRNZIPCHKSCAN:5
	if '$T {
		s failcnt=$I(^SYS("JRNZIP","runlockfail"))
		if failcnt>1 quit
		s ^SYS("JRNZIP","runlockfail","starttime")=$zts
		do {
			if '(failcnt#60) {  ;60 = 300 seconds/5 seconds/try - every 5 minutes
			   s last=$zts
			   s elapsed=$$elapsedSec($G(^SYS("JRNZIP","runlockfail","starttime")),last)
			   s elapsed=elapsed/60
			   s msg="SCAN^"_$ZN_" failed to acquire run lock for "_$FN(elapsed+0.5,,0)_" minutes. "
			   s msg=msg_"Check status of process "_$G(^SYS("JRNZIP","pid"),^$LOCK("^%JRNZIPCHKSCAN","OWNER"))
			   d $zu(9,"",msg,1 /* broadcast and log message*/,1  /* Warning */)
			}
			s failcnt=failcnt+1
			l +^%JRNZIPCHKSCAN:5
		} while ('$T)	
		zk ^SYS("JRNZIP","runlockfail","starttime")
		s ^SYS("JRNZIP","runlockfail")=0
	    d $zu(9,"","SCAN^"_$ZN_" run lock acquired",0,0  /* Informational message */)
	}
	s ^SYS("JRNZIP","pid")=$J
	s loglevel=+$G(^SYS("JRNZIP","loglevel"),1)
	; Start by processing the retry list if it exists. We'll process any files
	; that get added during this pass next time.
	s file=$O(^SYS("JRNZIP","retry",""))
	while file'="" {
		if $$compressone(file,1) {
			d $zu(9,"","Journal File Compression: "_file_" compressed, removed from the retry list",0,0  /* Informational message */)
		}
		if ''$ZU(140,4,file) {
		   ;even if we didn't compress it, it might be gone
		   k ^SYS("JRNZIP","retry",file)
		}
		s file=$O(^SYS("JRNZIP","retry",file))
	}
	;First deal with the file chain that we created. If
	; we're a failover mirror member, this may include some
	; mirror journal files. 
    s curfilecnt=$ZU(78,26)
    if curfilecnt'=+$G(^SYS("JRNZIP","active")) {
	    do {
    		s lastfilecnt=curfilecnt
    		do main("")
			s curfilecnt=$ZU(78,26)
    	} while (curfilecnt '= lastfilecnt)   
    	s ^SYS("JRNZIP","active")=curfilecnt
    }
    ;
    ;Now deal with journal files from any mirrors that
    ;we're a member of. 
	if '$SYSTEM.Mirror.IsPrimary() {
		s mirnames=$SYSTEM.Mirror.GetMirrorNames()
		s mircnt=$LL(mirnames)
		for i=1:1:mircnt {
			s name=$LG(mirnames,i)
			s idx=$SYSTEM.Mirror.MirrorNameToIndex(name)
			if (idx > -1) {
				s curfilecnt=+$SYSTEM.Mirror.GetInfo(2,idx)
				if curfilecnt'=+$G(^SYS("JRNZIP","active",name)) {
					do {
						s lastfilecnt=curfilecnt
						do main(name)
						s curfilecnt=+$SYSTEM.Mirror.GetInfo(2,idx)
					} while (curfilecnt '= lastfilecnt)   
					s ^SYS("JRNZIP","active",name)=curfilecnt
				}
			}
		}
	}
done ;
    zk ^SYS("JRNZIP","pid")
	l -^%JRNZIPCHKSCAN
	; before exiting, check whether there are pending deletes we can process
	if $D(^SYS("JRNZIP","PendingDelete")) {
		l +^%JRNZIPCHK:5
		if $T,$D(^SYS("JRNZIP","PendingDelete")) do ProcessPendingDeletes()
		l -^%JRNZIPCHK
	}
	quit
err ;
	s $zt=""
	s lastref=$zr
	if $G(^SYS("JRNZIP",":errors:","SCAN"))'=+$ZTS {
		s ^SYS("JRNZIP",":errors:","SCAN")=+$ZTS
		d BACK^%ETN
	}
	d $zu(9,"","Journal File Compression: "_"SCAN^"_$ZN_" caught "_$ZE,1 /* broadcast and log message*/,2  /* Severe error */)
	goto done
}
jrnfilecnt() public {
	; returns the sum of all the jrncnt values for the current
	; journal file and any mirror journal files we're creating.
	; we only add the low 32 bits so that n!=n+1 in our sum
	; (we could use up to 58 bits but 32 is fine).
	s mask=+$ZH("FFFFFFFF")  ;use the low 32 bits of each value
	s cnt=$ZBOOLEAN(+$ZU(78,26),mask,1) ;a&b
	s state=$SYSTEM.Mirror.IsMember() ;0=no, 1=failover, 2=async
	if state=0 quit cnt  ;not a member
	if $SYSTEM.Mirror.IsPrimary() quit cnt ;cnt reflects the primary's active file
	;
	; add in the mirror journal file counts. the point is to get a # that
	; changes to tell us that we should call SCAN again()
	s mirnames=$SYSTEM.Mirror.GetMirrorNames()
	s mircnt=$LL(mirnames)
	for i=1:1:mircnt {
		s name=$LG(mirnames,i)
		s idx=$SYSTEM.Mirror.MirrorNameToIndex(name)
		if (idx > -1) {
			s info=+$SYSTEM.Mirror.GetInfo(2,idx)
			s cnt=cnt+$ZBOOLEAN(info,mask,1)
		}
	}
	quit cnt
}
 /* main does the work of finding the journal file from a particular
    mirror, or if mirname is "", from the local system. If we're succesful,
    the latest file compressed is tracked as a JRNSHORTNAME in 
    ^SYS("JRNZIP","lastchecked") so we know how far back we have to check
    on the next pass. 
    Searching for local files is handled here and mirror files are in
    the mirror() subroutine. ##class(%SYS.Journal.File).GetPrev() is
    used to locate journal files in the chain.
    For local files we walk the chain of journal files from the prev
    journal file field in each file. This lets us walk across the local
    journal file stream and the files created when the system was the 
    primary (if a file doesn't have a previous file listed we use the
    local journal.log to find the prior file). Journal file #'s can reset
    across system starts but the names are unique. To deal with name
    conflicts between mirror and non-mirror files we add a "M" for mirror
    files.
    If we're the primary mirror member and we find both mirrored and
    non-mirrored files to compress then this is the 1st pass since we
    became the primary so we also want to scan for mirror journal files
    which we recived while we were the backup that are not part of our
    local journal file stream.
    In mirror() we can use the mirror journal file count to track where
    we are/find the prior file. mirror() is used when we're not the 
    primary & on async members.
    We walk backwards building a list of files to compress and then we
    process them oldest->newest. If we compress them from newest->oldest it
    creates odd pattern in which files are compressed/which aren't.
 */
main(mirname) PUBLIC  {
	s $ZT="err"
	if $G(mirname)'="" {
		do mirror(mirname)
		quit
	}
	k ^SYS("JRNZIP","worklist") ;in case this exists
	s loglevel=+$G(^SYS("JRNZIP","loglevel"),1)
	;This section handles our local journal files
	s mirsetname=""
	s lastchecked=$G(^SYS("JRNZIP","lastchecked"))
	s curfile=$zu(78,3) 
	i curfile="" {
		s prevfile=##class(%SYS.Journal.System).GetLastFileName() 
	} else {
		try {
			if $ZU(78,4)  ;current journal offset or <NOTOPEN> error
			;journaling is enabled, back up to the prior file
			s rc=##class(%SYS.Journal.File).GetPrev(curfile,.prevfile,0,0,mirsetname)
			i ('rc) {
				if curfile=$zu(78,3) {
					d $zu(9,"","Journal File Compression: "_"error "_$$Format^%qcr(rc,1)_" finding prior journal file for "_curfile,1 /* broadcast and log message*/,1  /* Warning */)
					return
				}
				; journaling has switched to a new file so use curfile as our 'prior' file
			}
		} catch {
			s prevfile=curfile
		}
	}
	if prevfile="" {
		if loglevel>=2 {d $zu(9,"","Journal File Compression: "_"no journal files found prior to /"_curfile_"/",0,0  /* Informational message */)}
		quit
	}
	s info=$zu(78,22,prevfile,99)
	q:'+info  ;file doesn't exist
	s filecnt=0
	s mirrorflag=0
	s nonmirrorflag=0
	s startfile=$case($ZBITGET($ZVERSION(0),46),0:$case($f(prevfile,";"),0:$e(prevfile,*-8-$l($p(prevfile,".",$l(prevfile,"."))),*-$case($e(prevfile,*)="z",0:0,1:1)),:$e(prevfile,*-8-$l($p(prevfile,".",$l(prevfile,"."))),$f(prevfile,";")-2)),:prevfile)
	if (+$P($ZU(78,22,prevfile,13),",",2)) {
		s startfile=startfile_"M"
		s mirrorflag=1
	}
	q:startfile=lastchecked ;nothing new to do
	do {
		s filecnt=filecnt+1
		s curfile=prevfile
	    s ^SYS("JRNZIP","worklist",filecnt)=curfile
		if loglevel>=2 {d $zu(9,"","Journal File Compression: "_"file to compress #"_filecnt_"=/"_curfile_"/",0,0  /* Informational message */)}
	    s rc=##class(%SYS.Journal.File).GetPrev(curfile,.prevfile,0,0,mirsetname)
		i ('rc) {
			d $zu(9,"","Journal File Compression: "_"error "_$$Format^%qcr(rc,1)_" finding prior journal file from "_curfile,1 /* broadcast and log message*/,1  /* Warning */)
			quit
		}
		s ok=$ZU(78,22,prevfile)  ;make sure the file is accessible
		s id=$case($ZBITGET($ZVERSION(0),46),0:$case($f(prevfile,";"),0:$e(prevfile,*-8-$l($p(prevfile,".",$l(prevfile,"."))),*-$case($e(prevfile,*)="z",0:0,1:1)),:$e(prevfile,*-8-$l($p(prevfile,".",$l(prevfile,"."))),$f(prevfile,";")-2)),:prevfile)
		i (+$P($ZU(78,22,prevfile,13),",",2)) {
			s id=id_"M"
		} else {
			s nonmirrorflag=1
		}
	} while (+ok && (id '= lastchecked))
	; If we're not the primary, go through the files and remove the most 
	; recent mirror journal file so we leave it uncompressed (if we're the
	; primary, our active journal file is the most recent mirror file)
	if '$SYSTEM.Mirror.IsPrimary() {
		for i=1:1:filecnt {
			s file=^SYS("JRNZIP","worklist",i)
			if (+$P($ZU(78,22,file,13),",",2)) {
				k ^SYS("JRNZIP","worklist",i)
				; reset startfile to the prior file so we compress the file
				; we just skipped next time
				s startfile=$G(^SYS("JRNZIP","worklist",i+1))
				if startfile="" {
					s rc=##class(%SYS.Journal.File).GetPrev(file,.prev,0,0,mirsetname)
					s startfile=prev
				}
				s startfile=$case($ZBITGET($ZVERSION(0),46),0:$case($f(startfile,";"),0:$e(startfile,*-8-$l($p(startfile,".",$l(startfile,"."))),*-$case($e(startfile,*)="z",0:0,1:1)),:$e(startfile,*-8-$l($p(startfile,".",$l(startfile,"."))),$f(startfile,";")-2)),:startfile)
				s:((+$P($ZU(78,22,startfile,13),",",2))) startfile=startfile_"M"
				quit  ;exit for loop
			}
		}
	}
	; now compress the files we found
 	do {
		s curfile=$G(^SYS("JRNZIP","worklist",filecnt))
	    s filecnt=filecnt-1
		if curfile'="",'$ZU(140,4,curfile) {
			if '$$compressone(curfile,0) {
		   		;compressone() logged a message about that went wrong
		   		s ^SYS("JRNZIP","retry",curfile)=""
			}
		}
	} while (filecnt > 0)
    s ^SYS("JRNZIP","lastchecked")=startfile
    if loglevel>=2 {d $zu(9,"","Journal File Compression: "_"lastchecked set to /"_startfile_"/",0,0  /* Informational message */)}
	k ^SYS("JRNZIP","worklist")
	if nonmirrorflag && (mirrorflag || $SYSTEM.Mirror.IsPrimary()) {
		s mirname=$P($G(^SYS("MIRRORSET")),"^",2)
		if mirname'="" {
		   if loglevel>=2 {d $zu(9,"","Journal File Compression: "_"searching for other mirror journal files to compress",0,0  /* Informational message */)}
		   do mirror(mirname)
		}
	}
	quit
err ;
	s $zt=""
	s lastref=$zr
	if $G(^SYS("JRNZIP",":errors:","main"))'=+$ZTS {
		s ^SYS("JRNZIP",":errors:","main")=+$ZTS
		k ^SYS("JRNZIP",":errors:","worklist")
		m ^SYS("JRNZIP",":errors:","worklist")=^SYS("JRNZIP","worklist")
		D BACK^%ETN
	}
	d $zu(9,"","Journal File Compression: "_"main^"_$ZN_" caught "_$ZE,1 /* broadcast and log message*/,2  /* Severe error */)
	k ^SYS("JRNZIP","worklist")
	quit
}
reset() PUBLIC {
	s $zt="err"
	/* called from STU at startup to clean out globals */
	merge save1=^SYS("JRNZIP","PendingDelete")
	merge save2=^SYS("JRNZIP","retry")
	merge enginename=^SYS("JRNZIP","cengine")
	merge chunksz=^SYS("JRNZIP","chunksz")
	merge loglevel=^SYS("JRNZIP","loglevel")	
	k ^SYS("JRNZIP")
	merge ^SYS("JRNZIP","PendingDelete")=save1
	merge ^SYS("JRNZIP","retry")=save2
	merge ^SYS("JRNZIP","cengine")=enginename
	merge ^SYS("JRNZIP","chunksz")=chunksz
	merge ^SYS("JRNZIP","loglevel")=loglevel
	quit
err ;
	s $zt=""
	d BACK^%ETN
	d $zu(9,"","Journal File Compression: "_"reset^"_$ZN_" caught "_$ZE,1 /* broadcast and log message*/,2  /* Severe error */)
	quit
}
 /* mirror(mirname) is the subroutine used by main() to 
    check for files from a given mirror member. It searches for
    files by mirror journal file count using the mirror journal log
 */
mirror(mirname) PUBLIC {
	s $zt="err"
	s loglevel=+$G(^SYS("JRNZIP","loglevel"),1)
	s mirname=$zcvt(mirname,"U")
	s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)
	if +rc<0 {
	    if $G(^SYS("JRNZIP","MirrorWarn",mirname))'=+$ZTS {
			d $zu(9,"","Journal File Compression: "_"failed to read last mirror journal file from log for "_mirname,1 /* broadcast and log message*/,1  /* Warning */)
			s ^SYS("JRNZIP","MirrorWarn",mirname)=+$ZTS 
	    }
		quit 
	}
	; We don't want to compress the very last mirror journal file so start checking
	; the file before this one
	s endfile=+rc
	do {
		s endfile=endfile-1
		q:'endfile
		s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(endfile,mirname)
		quit:rc<=0
		s jrnfile=$P(rc,",",2)
		s validend=+$p($zu(78,22,jrnfile,99),",",16+1)
	} while 'validend
	if ('endfile) || (rc<=0) {
		if loglevel>=2 {
			d $zu(9,"","Journal File Compression: "_"Did not find any journal files with a valid end for "_mirname,0,0  /* Informational message */)
		}
		quit
	}
	s lastchecked=+$G(^SYS("JRNZIP","lastchecked",mirname)) ;last file compressed
	k ^SYS("JRNZIP","worklist",mirname)
	q:endfile<=lastchecked
	if loglevel>=2 {
		d $zu(9,"","Journal File Compression: "_"Searching for mirror ("_mirname_") files to compress from "_endfile_" back to "_lastchecked,0,0  /* Informational message */)
	}
	s files=0
	s filecnt=endfile
	s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)		
	while rc>0,filecnt>lastchecked {
		s jrnfile=$P(rc,",",2)
		s info=$zu(78,22,jrnfile,99)
		if +info,'$P(info,",",25+1) {
			s files=files+1
			s ^SYS("JRNZIP","worklist",mirname,files)=jrnfile
		}
		s filecnt=filecnt-1
		s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)		
	}
	if files {
		if loglevel>=2 {
			d $zu(9,"","Journal File Compression: "_"Found "_files_" file(s) to compress for "_mirname,0,0  /* Informational message */)
		}
		for i=1:1:files {
			s jrnfile=^SYS("JRNZIP","worklist",mirname,i)
			if '$$compressone(jrnfile,0) {
				;compressone() logged an error
				s ^SYS("JRNZIP","retry",jrnfile)=""
			}
		}
	}
	k ^SYS("JRNZIP","worklist",mirname)
	s ^SYS("JRNZIP","lastchecked",mirname)=endfile
	quit
err ;
	s $zt=""
	s lastref=$zr
	if $G(^SYS("JRNZIP",":errors:","mirror"))'=+$ZTS {
		s ^SYS("JRNZIP",":errors:","mirror")=+$ZTS
		d BACK^%ETN
	}
	d $zu(9,"","Journal File Compression: "_"mirror^"_$ZN_" caught "_$ZE,1 /* broadcast and log message*/,2  /* Severe error */)
	quit
} 
    /* return the filecnt of the last compressed file we can find (the
       subsequent file is the 1st one to be compressed). */
findStartingFile(mirname,endfile) {
	s $zt="err"
	s loglevel=+$G(^SYS("JRNZIP","loglevel"),1)
	s filecnt=endfile-1
	for  {
		s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)
		q:+rc<1
		s jrnfile=$P(rc,",",2)
		s info=$zu(78,22,jrnfile,99)
		if +info,$P(info,",",25+1) quit  ;found a compressed file
		s filecnt=filecnt-1
		q:'filecnt
	}
	if loglevel>=2 {
		d $zu(9,"","Journal File Compression: "_"Compressing files starting at #"_(filecnt+1)_" for mirror ("_mirname_")",0,0  /* Informational message */)
	}
	quit filecnt ;either doesn't exist or is already compressed
err ;
	s $zt=""
	s lastref=$zr
	if $G(^SYS("JRNZIP",":errors:","mirror"))'=+$ZTS {
		s ^SYS("JRNZIP",":errors:","mirror")=+$ZTS
		d BACK^%ETN
	}
	d $zu(9,"","Journal File Compression: "_"mirror^"_$ZN_" caught "_$ZE,1 /* broadcast and log message*/,2  /* Severe error */)
	quit endfile
}
 /* Called when ^SYS("JRNZIP","PendingDelete") contains
    journal files that compressone() failed to delete, presumably
    because they were in use.  The value of the node for
    each file tracks when we last tried to delete it and
    the # of times we've tried. We only try once per minute
    and after 5 times we'll log a message that we've been having
    trouble. If we log the trouble message, we'll also log a
    success message if we later succeed. If a file doesn't exist,
    we consider that a success.
 */   
ProcessPendingDeletes() PUBLIC {
	s curtime=$zts
	s file=$O(^SYS("JRNZIP","PendingDelete",""),1,val)
	; val = $lb(start time, last check, chk cnt), times are utc
	while file'="" {
		s lastchecked=$LG(val,2)
  	    s cnt=$LG(val,3)+1
		s elapsed=$$elapsedSec(lastchecked,curtime)
		if elapsed>60 {
			s rc=$zu(138,5,file)  ;remove uncompressed version or old temporary file
		    if ('rc) {
			    k ^SYS("JRNZIP","PendingDelete",file)
			    if cnt>=5 d $zu(9,"","Journal File Compression: "_"succesfully deleted "_file,0,0  /* Informational message */)
		    } else {
			   if ''$ZU(140,4,file) {
			   		k ^SYS("JRNZIP","PendingDelete",file)
			    	if cnt>=5 d $zu(9,"","Journal File Compression: "_file_" which was pending delete, appears to have been removed",0,0  /* Informational message */)
			   } else {
  	 	  	   		s $LIST(val,2)=curtime
  	 	  	   		s $LIST(val,3)=cnt
			   		s ^SYS("JRNZIP","PendingDelete",file)=val
			   		if cnt=5 {
			      		d $zu(9,"","Journal File Compression: "_"failed to delete "_file_" after compressing - continuing to retry",1 /* broadcast and log message*/,1  /* Warning */)
			   		}
			   }
		    }
		}
	    s file=$O(^SYS("JRNZIP","PendingDelete",file),1,val)
	}
}
elapsedSec(st,end) {
	s std=+st,sts=$P(st,",",2)
	s endd=+end,ends=$P(end,",",2)
	; 86400 = 24*60*60
	s sec=(endd-std)*86400 + (ends - sts)
	quit sec
}
compressone(file,errorRetry) PUBLIC {
	/* Compresses the specified journal file to a new file with the
	   same name and a "z" added to the end. Removes the original file
	   if succesful. Fails if either the temp file or the target file
	   exists (or a problem is encountered in the compression process).
	   If we fail to delete the old file, it is added to 
	   ^SYS("JRNZIP","PendingDelete" to be processed later
	   Takes out a lock on ^%JRNZIPCHK(file) to prevent two processes
	   from compressing the same file at the same time. SCAN^JRNZIP
	   holds a lock on ^%JRNZIPCHK however compressone() is public and
	   can be called directly from elsewhere. 
	   errorRetry can be omitted (defaults to 0) but when passed as 1 it
	   indicates we're retrying a failed compression and we suppress all
	   console log messages related to the failure (success messages are
	   still logged)
	   Returns:  0 - failed, retry operation later
	             1 - success or skipped and don't retry later
	*/
	s $zt="err"
	s errorRetry=+$G(errorRetry,0)
	s enginename=$G(^SYS("JRNZIP","cengine"),"zstd") 
	s chunksz=+$G(^SYS("JRNZIP","chunksz"),4)
	if ((chunksz<1) || (chunksz>64)) { // HYY2323
		if 'errorRetry d $zu(9,"","Journal File Compression: "_"compression chunk size "_chunksz_" out of range (1-16)",1 /* broadcast and log message*/,2  /* Severe error */)
		quit 0
	}
	s cengine=$SYSTEM.Util.CompressionNameToID(enginename)
	s cflags=$SYSTEM.Util.GetCompressionEngineFlags(cengine)
	if (cengine<0)||(cflags["Hidden") {
		if 'errorRetry d $zu(9,"","Journal File Compression: "_enginename_" is not a valid compression engine",1 /* broadcast and log message*/,2  /* Severe error */)
		quit 0
	}
	s loglevel=+$G(^SYS("JRNZIP","loglevel"),1)
	; take out a lock so we block ProcessPendingDeletes() from getting run
	; (callers of ProcessPendingDeletes() take out a top leve lock on %JRNZIPCHK).
	; so we can post the temporary file we create to the PendingDelete list and it
	; won't get deleted while we're using it but if the system crashes, it will get cleaned up.
	; This also coordinates with journal file purging in ^JRNUTIL and SYS.Mirror.
	l +^%JRNZIPCHK(file):5
	if '$t {
		i 'errorRetry d $zu(9,"","Journal File Compression: "_"Failed to acquire lock to compress "_file,0,0  /* Informational message */)
		quit 0
	}
	;
	; If the file is missing return success. It was probably either compressed 
	; or removed by someone else.
	if ''$ZU(140,4,file) {
		l -^%JRNZIPCHK(file)
		if loglevel>=2,''$ZU(140,4,file_"z") {
			if 'errorRetry d $zu(9,"","Journal File Compression: "_file_" is missing",0,0  /* Informational message */)
		}
		quit 1
	}
	s info=$zu(78,22,file,99)
	if '+info {
		l -^%JRNZIPCHK(file)
		if ('$ZU(140,4,file) || '$ZU(140,4,file_"z")) {
			i 'errorRetry d $zu(9,"","Journal File Compression: "_"failed to read header from: "_file,1 /* broadcast and log message*/,2  /* Severe error */)
		} elseif loglevel>=2 {
			i 'errorRetry d $zu(9,"","Journal File Compression: "_file_" is missing",0,0  /* Informational message */)
		}
		quit 1
	}
	s mirfilecnt=+$P(info,",",13+1)
	if mirfilecnt {
		s validend=+$P(info,",",16+1)
		if 'validend {
			l -^%JRNZIPCHK(file)
			if (loglevel>=2) {
				if 'errorRetry d $zu(9,"","Journal File Compression: "_"Skipping compressing mirror "_file_" - valid end not set",0,0  /* Informational message */)
			}
			quit 1 
		}		
	}
	s basedir=$ZU(12,$p(file,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""),1,$l(file,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""))-1)_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""))  ;includes a trailing slash
	for i=1:1:5 {
		s x=$R(999999),x=$E("00000",$L(x),5)_x  ;pad to 6 chars
		s tmpfname=basedir_"jz"_x_".tmp"  ;temporary filename is 8.3 like journal filename
		s exists='$ZU(140,4,tmpfname)
		q:'exists
	}
	if exists {
		l -^%JRNZIPCHK(file)
		i 'errorRetry d $zu(9,"","Journal File Compression: "_"Failed in 5 tries to generate a temporary filename (last try = "_tmpfname_")",1 /* broadcast and log message*/,2  /* Severe error */)
		quit 0
	}
	s newfile=file_"z"
	if '$ZU(140,4,newfile) {
		if $D(^SYS("JRNZIP","PendingDelete",file)) {
			if (loglevel>=2) {
				i 'errorRetry d $zu(9,"","Journal File Compression: "_file_" appears to already be compressed, original still on the pending delete list",0,0  /* Informational message */)
			}
			l -^%JRNZIPCHK(file)
			quit 1  ;the uncompressed file is on the pending delete this so this is fine
		}
		if ''$ZU(140,4,file) {
			if (loglevel>=2) {
				i 'errorRetry d $zu(9,"","Journal File Compression: "_file_" appears to already be compressed",0,0  /* Informational message */)
			}
			l -^%JRNZIPCHK(file)
			quit 1  ;the compressed file exists and the uncompressed file is gone so I think this is good although unexpected
		}
		s x=$$ResolveDuplicateFiles(file,newfile,errorRetry)
		if x>-1 {
			l -^%JRNZIPCHK(file)
			quit x   ;-1 means fall through and recompress (compressed copy has been removed), 0/1 are returned to caller
		}
	}
	s ^SYS("JRNZIP","PendingDelete",tmpfname)=$LB($ZTS,$ZTS,0) 
	s rc=$zu(78,116,file,tmpfname,cengine,chunksz,errorRetry)
	if +rc=-2 {  ;file not found
		if loglevel>=2 {
			i 'errorRetry d $zu(9,"","Journal File Compression: "_file_" was deleted before it could be compressed",0,0  /* Informational message */)
		}
		k ^SYS("JRNZIP","PendingDelete",tmpfname)
		l -^%JRNZIPCHK(file)
		quit 1  ;skipped, don't retry
	}
	if +rc=-13 {  ;interrrupted (system shutdown, resjob?, sent an interrupt?)
		do $ZU(138,5,tmpfname)  ;remove the temp file
		k ^SYS("JRNZIP","PendingDelete",tmpfname)
		l -^%JRNZIPCHK(file)
	    if 'errorRetry d $zu(9,"","Journal File Compression: "_"Interrupted while processing "_file,0,0  /* Informational message */)
		quit 0   ;halt?
	}
	if rc'=1 {
		if 'errorRetry d $zu(9,"","Journal File Compression: "_"error "_rc_" compressing "_file,1 /* broadcast and log message*/,2  /* Severe error */)
		do $ZU(138,5,tmpfname)  ;remove the temp file
		k ^SYS("JRNZIP","PendingDelete",tmpfname)
		l -^%JRNZIPCHK(file)
		quit 0
	}
	s rc=$zu(138,6,tmpfname,newfile,1) ;,1 = durable rename 
	if (rc) {
		if 'errorRetry d $zu(9,"","Journal File Compression: "_"error "_rc_" renaming "_tmpfname_" to "_newfile,1 /* broadcast and log message*/,2  /* Severe error */)
		do $ZU(138,5,tmpfname)
		k ^SYS("JRNZIP","PendingDelete",tmpfname)
		l -^%JRNZIPCHK(file)
		quit 0
	}
	k ^SYS("JRNZIP","PendingDelete",tmpfname)
	s oldsize=$zu(140,1,file)
	do delfile(file)
	l -^%JRNZIPCHK(file)
	s newsize=$zu(140,1,newfile)
	if (loglevel>=1) {d $zu(9,"","Journal File Compression: "_"Compressed "_file_" from "_oldsize_" bytes to "_newsize_" bytes, compression ratio = "_$s(newsize:$j(oldsize/newsize,0,1),1:""),0,0  /* Informational message */)}
	quit 1
err s $zt=""
	s lastref=$zr
	if $G(^SYS("JRNZIP",":errors:","compressone"))'=+$ZTS {
		s ^SYS("JRNZIP",":errors:","compressone")=+$ZTS
		d BACK^%ETN
	}
	i 'errorRetry d $zu(9,"","Journal File Compression: "_"compressone^"_$ZN_" caught "_$ZE,1 /* broadcast and log message*/,2  /* Severe error */)
	l -^%JRNZIPCHK(file)
	quit 0
}
 /* delfile(file) - deletes a file or adds it to the pending delete list on windows
                    if we fail because its in use.
    Returns 1 - deleted the file
            0 - added the file to the pending delete list
 */
delfile(file) PRIVATE {
	s rc=$zu(138,5,file)  ;remove uncompressed version
	if ($zversion(1)=2),rc=-32 {
		;-32 on windows is file in use. On unix we can delete a file in
		; use and the o/s will clean it up when the last user closes it.
		; Wait a few seconds to see if that goes away before queuing it
		; to the pending delete list
		for i=1:1:5 {h 1 s rc=$zu(138,5,file) q:rc'=-32  }
	}
	if (rc) {
		; Add to the list and we'll generate a warning if its there for > 5 minutes
		s ^SYS("JRNZIP","PendingDelete",file)=$LB($ZTS,$ZTS,0)  ;start time, last check, chk cnt
		l -^%JRNZIPCHK(file)
		s loglevel=+$G(^SYS("JRNZIP","loglevel"),1)
		if (loglevel>=2) d $zu(9,"","Journal File Compression: "_"error "_rc_" deleting "_file_" after compressing - added to the pending delete list",0,0  /* Informational message */)
		quit 0
	}
	quit 1
}
 /* ResolveDuplicateFiles is called when we find both a compressed and uncompressed copy.
	This shouldn't happen often because there is a very small window where both files exist 
	so its possible. 
    We open both files and if they have the same end point, delete the uncompressed copy. 
    Otherwise, unless we fail to open the original, we delete the compressed copy and we'll
    rebuild it.
	errorRetry=1 means don't generate any console log messages for failures
    Returns:  1 - original version removed, compressed copy exists (we're done with this file)
              0 - failed to remove a file, its posted on the pending delete list
             -1 - compressed copy removed, original copy exists (recompress it)
 */
ResolveDuplicateFiles(file,newfile,errorRetry) private {
	s nfd=$zu(78,5,newfile,0)
	if nfd<0 {
		;failed to open the compressed copy, delete it
		if '$$delfile(newfile) {
			if 'errorRetry d $zu(9,"","Journal File Compression: "_"Compressed and uncompressed copies of "_file_" exist but failed to open the compressed copy and failed to remove it. Posted to the pending delete list",0,0  /* Informational message */)
			quit 0
		}
		if 'errorRetry d $zu(9,"","Journal File Compression: "_"Compressed and uncompressed copies of "_file_" exist but failed to open the compressed copy - removed it and continuing",0,0  /* Informational message */)
		quit -1 ;recompress
	}
	do $zu(78,6,nfd) 
	s newend=$ZU(78,18,0) 
	do $zu(78,7,nfd)
	;
	s ofd=$zu(78,5,file,0)
	if ofd<0 {
		if '$$delfile(file) {
			if 'errorRetry d $zu(9,"","Journal File Compression: "_"Compressed and uncompressed copies of "_file_" exist but failed to open the uncompressed copy. Posted to the pending delete list",0,0  /* Informational message */)
			quit 0
		}
		if 'errorRetry d $zu(9,"","Journal File Compression: "_"Compressed and uncompressed copies of "_file_" exist but failed to open the uncompressed copy - removed it and continuing",0,0  /* Informational message */)
		quit 1  ;we're done - the compressed copy remains
	}
	do $zu(78,6,ofd) 
	s oldend=$ZU(78,18,0) 
	do $zu(78,7,ofd)
	; Wait until we verified we can open both files to check the
	; guids but if they don't match, don't delete either copy
	s newguid=$p($zu(78,22,newfile,99),",",7+1)
	s oldguid=$p($zu(78,22,file,99),",",7+1)
	if newguid'=oldguid {
		if 'errorRetry d $zu(9,"","Journal File Compression: "_"Compressed and uncompressed copies of "_file_" exist but they have different guids ("_oldguid_"/"_newguid_") so they appear to be different files - preserving both copies",1 /* broadcast and log message*/,3  /* Fatal */)
		quit 0  ;this is an error the user needs to deal with
	}
	;
	if newend=oldend {
		if '$$delfile(file) {
			if 'errorRetry d $zu(9,"","Journal File Compression: "_"Compressed and uncompressed copies of "_file_" exist and have the same end points - posted the uncompressed copy to the pending delete list",0,0  /* Informational message */)
		} else {
			if 'errorRetry d $zu(9,"","Journal File Compression: "_"Compressed and uncompressed copies of "_file_" exist and have the same end points - removed the uncompressed copy",0,0  /* Informational message */)
		}
		quit 1  ;compressed copy remains
	}
	if '$$delfile(newfile) {
		if 'errorRetry d $zu(9,"","Journal File Compression: "_"Compressed and uncompressed copies of "_file_" exist and but have different end points ("_oldend_"/"_newend_"). Failed to remove compressed copy, posted to the pending delete list",0,0  /* Informational message */)
		quit 0
	}
	if 'errorRetry d $zu(9,"","Journal File Compression: "_"Compressed and uncompressed copies of "_file_" exist and but have different end points ("_oldend_"/"_newend_"). Removed the compressed copy",0,0  /* Informational message */)
	quit -1 ; recompress it
}
decompressone(file) PUBLIC {
	/* Deompresses the specified journal file to a new file with the
	   same name without the trailing "z". Removes the original file
	   if succesful. Fails if either the temp file or the target file
	   exists (or a problem is encountered in the decompression process).
	   If we fail to delete the old file, it is added to 
	        ^SYS("JRNZIP","PendingDelete" to be processed later
	   Takes out a lock on ^%JRNZIPCHK(file) to prevent two processes
	   from working on the same file at the same time.
	   This is not called from this routine, it is here to be used to
	   decompress journal files if needed during mirror startup because
	   we find the latest journal file is compressed. Mirror startup can't
	   build the data channel with a compressed file so it will decompress it
	   if necessary. Up above, we try to avoid compressing the last file but it
	   is possible somone compresses it anyway.
	   Returns $LB(1) for success or $LB(0,<errtext>) on failure
	*/
	s $zt="err"
	s file=$ZU(12,file,0)
	if $E(file,*)'="z" s file=file_"z"
	s uncompfile=$E(file,1,*-1)
	if '$ZU(140,4,uncompfile) quit 1  ;already uncompressed
	if ''$ZU(140,4,file) {
		quit $LB(0,"Cannot find "_file_" to decompress")
	}
	s info=$zu(78,22,file,99)
	if '+info {
		quit $LB(0,"Failed to read header from: "_file)
	}
	; take out a lock so we block ProcessPendingDeletes() from getting run
	; (callers of ProcessPendingDeletes() take out a top leve lock on %JRNZIPCHK).
	; This is so we can post the temporary file we create to the PendingDelete list
	; so that if the system crashes, it will get cleaned up. This also blocks journal
	; file purging
	l +^%JRNZIPCHK(file):5
	if '$t {
		quit $LB(0,"Failed to acquire lock to compress "_file)
	}
	;If the file doesn't exist, assume it was deleted by someone
	if ''$ZU(140,4,file) {
		l -^%JRNZIPCHK(file)
		quit $LB(1) 
	}
	;
	s basedir=$ZU(12,$p(file,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""),1,$l(file,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""))-1)_$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""))  ;includes a trailing slash
	for i=1:1:5 {
		s x=$R(999999),x=$E("00000",$L(x),5)_x  ;pad to 6 chars
		s tmpfname=basedir_"jz"_x_".tmp"  ;temporary filename is 8.3 like journal filename
		s exists='$ZU(140,4,tmpfname)
		q:'exists
	}
	if exists {
		l -^%JRNZIPCHK(file)
		quit $lb(0,"Failed in 5 tries to generate a temporary filename (last try = "_tmpfname_")")
	}
	if '$ZU(140,4,uncompfile) {
		if $D(^SYS("JRNZIP","PendingDelete",file)) {
			l -^%JRNZIPCHK(file)
			quit $LB(1)  ;the uncompressed file is on the pending delete list so this is fine
		}
		if ''$ZU(140,4,file) {
			l -^%JRNZIPCHK(file)
			quit $LB(1)  ;the compressed file exists and the uncompressed file is gone so I think this is good although unexpected
		}
		s x=$$ResolveDuplicateFiles(file,uncompfile,0)
		if x>-1 {
			l -^%JRNZIPCHK(file)
			quit $LB(x)   ;-1 means fall through and recompress (compressed copy has been removed), 0/1 are returned to caller
		}
	}
	s ^SYS("JRNZIP","PendingDelete",tmpfname)=$LB($ZTS,$ZTS,0) 
	s rc=$zu(78,117,file,tmpfname)
	if rc'=1 {
		do $ZU(138,5,tmpfname)  ;remove the temp file
		k ^SYS("JRNZIP","PendingDelete",tmpfname)
		l -^%JRNZIPCHK(file)
		quit $LB(0,"Error "_rc_" decompressing "_file)
	}
	s rc=$zu(138,6,tmpfname,uncompfile,1) ;,1 = durable rename 
	if (rc) {
		d $zu(9,"","Journal File Compression: "_"error "_rc_" renaming "_tmpfname_" to "_uncompfile,1 /* broadcast and log message*/,2  /* Severe error */)
		do $ZU(138,5,tmpfname)
		k ^SYS("JRNZIP","PendingDelete",tmpfname)
		l -^%JRNZIPCHK(file)
		quit $LB(0,"Failed to rename "_tmpfname_" to "_uncompfile)
	}
	k ^SYS("JRNZIP","PendingDelete",tmpfname)
	do delfile(file)
	l -^%JRNZIPCHK(file)
	quit $LB(1)
err s $zt=""
	s lastref=$zr
	if $G(^SYS("JRNZIP",":errors:","decompressone"))'=+$ZTS {
		s ^SYS("JRNZIP",":errors:","decompressone")=+$ZTS
		d BACK^%ETN
	}
	l -^%JRNZIPCHK(file)
	quit $LB(0,"decompressone^"_$ZN_" caught "_$ZE)
}

LABEL^INT^1^67214,47330
LABEL ;System Utilities
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ;change the directory label for a selected CACHE.DAT
GO ;select a directory, display it's label directory, get a new
 N R,X,DIR,ROOT,NVOL,LINK,VOL,TYPE,MOUNT,POP
 New dirinfo,isbigdb,mtemp1
 N dirlist S dirlist="^mtemp1(""dir"")" ;list of directories
 I $G(@dirlist)<$H K @dirlist S @dirlist=$H_","_$J_","_$I ;make current
 W !!,"Enter the name of the directory in which the database is"
 W !,"stored. For a multi-volume database, enter the name of the"
 W !,"primary volume's directory, even if you want to relabel a"
 W !,"secondary volume. For a multi-volume legacy 2K database, you"
 W !,"should enter the name of the secondary volume directory if "
 W !,"you need to relabel it."
DIR W ! S R=$$GetDir("Directory") Q:R=""
 I $E(R)="?" W ! DO  G DIR
 . W !?4,"Enter the directory of a "_"InterSystems IRIS"_" database which contains a "_"IRIS"_".DAT."
 . Write !,?4,"For a legacy 2k database you may also enter a directory which"
 . Write !,?4,"contains a "_"IRIS"_".EXT. If it is a legacy 2k database you may change"
 . W !?4,"the directory label for that database to point to another directory."
 . Write !,?4,"For any multivolume database, you may relabel the secondary volumes." 
 S DIR=$$ChkDirOrSpecEXISTS(R) G DIR:DIR="" I DIR'=R W "  "_DIR ;resolve ref
 D Touch(DIR) ;add DIR to available directory list
 Set dirinfo=$zu(49,DIR)
 Set isbigdb=$Piece(dirinfo,",",21)
 S TYPE=$$TYPE(DIR) I TYPE="" W *7 DO  G DIR
 . If isbigdb W !?4,"That directory does not contain a "_"IRIS"_".DAT."
 . Else  W !?4,"That directory contains neither a "_"IRIS"_".DAT nor a "_"IRIS"_".EXT"
 S ROOT=$$ROOT(DIR) ;get either the label (type=0) or root (type=1)
 S LINK=$$LINK(DIR) ;get pointer to next volume in chain
 S NVOL=$$NVOL(DIR) ;get the expected number of volumes?
 I NVOL="" S NVOL=$$NVOL(ROOT) ;possibly available under old name
 D Touch(LINK),Touch(ROOT) ;add other directories
 ;
 I TYPE=0 D FIRST G DIR ;primary/first volume
 I TYPE=1 D SECOND G DIR ;secondary/link volume
 W *7 W !?4,"unknown volume type: '"_TYPE_"' for volume '"_DIR_"'"
 G DIR
FIRST ;'DIR' represents the first volume
 I 'NVOL W ! DO  W ! ;case where volume should be one of one
 . W !?4,"Directory '"_DIR_"' contains a primary Database volume."
 . W !?4,"Volume status information is currently unavailable.  The"
 . W !?4,"current label is '"_ROOT_"'"
 . I DIR=ROOT W ", which is correct." Q
 . I $$STAT(DIR)]"" W ", which is correct." Q
 . W ", which is NOT correct; this label needs to be"
 . W !?4,"changed to match the directory where the database is located"
 . W !?4,"(i.e. '"_DIR_"')."
 I NVOL=1 W ! DO  W ! ;case where volume should be one of one
 . W !?4,"Directory '"_DIR_"' is the only Database volume."
 . If 'isbigdb W !?4,"The current label is '"_ROOT_"'"
 . Else  Quit  
 . I $ZU(12,DIR)=$zu(12,ROOT) W !,?4,"which is correct." Q
 . W !?4,"which is NOT correct; this label needs to be changed to"
 . W " match",!,?4,"the directory where the database is located"
 . W !?4,"(i.e. '"_DIR_"')."
 I NVOL>1 W ! DO  W ! ;volume should be first of many
 . W !?4,"Directory '"_DIR_"' "
 . w !?8,"is the first volume of a database"
 . W " containing "_NVOL_" volumes."
 . If isbigdb Quit
 . w !?4,"The first link volume is '"_LINK_"'" DO
 . . N LR S LR=$$ROOT(LINK) D Touch(LR) ;get/add LR
 . . I LR=DIR W !?8,"which points back to the current volume." Q
 . . I LR=ROOT W !?8,"which points to the label volume." Q
 . . I (LR="")!(LR=-1) W !?8,"which *HAS NO PRIMARY VOLUME*." Q
 . . W !?8,"which points to '"_LR_"'" Q
 . W !!?4,"The current label for this volume is '"_ROOT_"'"
 . I $ZU(12,DIR)=$zu(12,ROOT) W !?4,"which is correct." Q
 . W !?8,"which is NOT correct; this label needs to be changed to"
 . w " match",!?8,"the directory where the database is located"
 . W !?8,"(i.e. '"_DIR_"')."
 If isbigdb {
    If NVOL=1 Quit  
    Write !?4,"The first secondary volume is '"_LINK_"'" Goto FLINK
 }
FNEW S R=$$GetDir("New Label",DIR) q:R=""
 I $E(R)="?" W ! DO  W ! G FNEW ;help about label fof first volume
 . W !?4,"Enter the new label for this volume.  In order for"
 . W !?4,"InterSystems IRIS"_" to mount the volume successfully, this label must"
 . W !?4,"be the same name as the directory in which it is located."
 S NEW=$$ChkDirOrSpecEXISTS(R) I NEW="" W !,"(invalid directory name)" G FNEW
 I NEW=ROOT W !,"(no change)" G FLINK
 S MOUNT=$$MOUNTED(DIR) ;is directory DIR mounted?
 I MOUNT S MOUNT=$$DISMNT(DIR) I 'MOUNT Q  ;if mounted, ask to dismount
 S X=$$LABSET(DIR,NEW) I 'X D FAIL(X) Q  ;could not change label?
 I MOUNT S X=$$REMOUNT(DIR) I 'X W !,X ;re-mount the directory
 W !,"Label Modification complete.",!
FLINK I NVOL=1,LINK="" Q  ;only condition when link is not editable
 ;
 G EDLINK
 ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
SECOND ;edit the information for an CACHE.EXT
 S NVOL=$$NVOL(ROOT)
 I NVOL=1 W *7 DO  ;one??? when we're in a secondary???  WARN'em
 . W !?4,"This database indicates that there should be only ONE"
 . W !?4,"volume; yet this is obviously not the case -- this may"
 . W !?4,"indicate SERIOUS corruption of this database!!!"
 N VOL S VOL=1 I ROOT]"" D CHAIN1(ROOT,.VOL) ;display chain
 N FND,II S FND="" F II=1:1:VOL I $G(VOL(II))=DIR S FND=II
 I 'FND W *7,!,"Currently this volume is NOT in the chain!",!
 E  W !,"Currently this is volume "_FND_" of the database.",!
SNEW S R=$$GetDir("Point to Primary Volume",ROOT) I R="" G SNDEL
 I $E(R)="?" W ! DO  W ! G SNEW ;help about label of extra volumes
 . W !?4,"Enter the new primary volume for this database.  In order"
 . W !?4,"for "_"InterSystems IRIS"_" to use this volume correctly, this pointer must"
 . W !?4,"be the same name as the directory or the primary volume"
 . W !?4,"of this database."
 S NEW=$$ChkDirOrSpecEXISTS(R) I NEW="" W !,"(invalid directory name)" G SNEW
 I NEW=ROOT W !,"(no change)" G EDLINK
 S MOUNT=$$MOUNTED(DIR) ;is directory DIR mounted?
 I MOUNT S MOUNT=$$DISMNT(DIR) I 'MOUNT Q  ;ask if already mounted
 S X=$$PNTSET(DIR,NEW) I 'X D FAIL(X) Q  ;could not change label?
 I MOUNT S X=$$REMOUNT(DIR) I 'X W !,X ;re-mount the directory
 W !,"Root Pointer Modification complete.",!
 G EDLINK
SNDEL W !!,"*** NOT ALLOWED TO DELETE ROOT VOLUME POINTERS YET!!! ***",! Q
CHAIN1(DIR,VOL) ;given DIR as a 'top' directory, and 'VOL' as the volume
 N DD S DD=DIR S:'$G(VOL) VOL=1 F  DO  Q:DD=""  ;walk through the links
 . W !,"Vol "_VOL I NVOL W "/"_NVOL_". "
 . W ?12,DD S DD(DD)=VOL,VOL(VOL)=DD ;keep track to avoid loops
 . N LL S LL=$$LINK(DD),DD="" Q:LL=""  Q:LL=-1
 . I $D(DD(LL)) W *7,!,"*** REVISITING VOLUME '"_LL_"' ***" Q
 . S VOL=VOL+1,DD=LL D Touch(DD) ;next volume -- make it available
 I NVOL,VOL>NVOL W *7,*7,!?4,"*** too many volumes!!! ***",!
 I NVOL,VOL<NVOL W *7,*7,!?4,"*** too few volumes!!! ***",!
 Q
 ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
EDLINK ;allow editing of database link here
 W ! N FND S FND=""
 I TYPE=0 DO  W ! ;ask about existing chains
 . I NVOL>1,LINK="" W *7 DO  Q  ;strange case
 . . W !?4,"This PRIMARY VOLUME does not currently contain a link"
 . . W !?4,"to a continuation volume ("_"IRIS"_".EXT), while the status"
 . . W !?4,"information for this database indicates there should"
 . . W !?4,"be '"_NVOL_"' volumes.  Note also that adding a"
 . . W !?4,"continuation volume where one does not belong will be"
 . . W !?4,"extremely hazardous to the integrity of that database."
 . I $$YN("Show existing "_$Case(isbigdb,0:"chain",:"list")_" of volumes","Y")'="Y" Q
 . N DD S DD=$S($$STAT(DIR)="":ROOT,1:DIR) D CHAIN(DD,1) Q
 I TYPE=1 DO  W ! ;for intermediates, show whole chain
 . I $$YN("Show existing chain of volumes","Y")'="Y" Q
 . N VOL S VOL=1 D CHAIN(ROOT,.VOL) ;display chain from the root volume
 . N II F II=1:1:VOL I VOL(II)=DIR S FND=II Q
 . I FND=NVOL,LINK="" DO  Q  ;last entry
 . . W !?4,"This volume is the last volume of the defined chain"
 . . W !?4,"of continuation volumes -- an additional link is NOT"
 . . W !?4,"expected.  Note that adding a continuation volume where"
 . . W !?4,"one does not belong will be extremely hazardous to the"
 . . W !?4,"integrity of that database."
 . I FND<NVOL,LINK="" DO  Q  ;middle entry
 . . W !?4,"This volume *HAS NO CONTINUATION* and is not the expected"
 . . W !?4,"last entry in this database's chain of directories."
 . . W !?4,"Please specify the correct continuation volume from"
 . . W !?4,"this volume."
 ;
EDL If isbigdb Goto EDLBIGDB
 S R=$$GetDir("Link to Volume",LINK) I R="" Q:LINK=""  G EDLDEL
 I $E(R)="?" W ! DO  W ! G EDL
 . W !?4,"Enter the name of the new link volume for this database."
 . W !?4,"This directory should contain the "_"IRIS"_".EXT which is the"
 . W !?4,"proper continuation from this volume ('"_DIR_"')"
 S NLNK=$$ChkDirOrSpecEXISTS(R) I NLNK="" W !,"(invalid directory name)" G EDL
 I NLNK=LINK W !,"(no change)" Q
 S MOUNT=$$MOUNTED(DIR) ;is directory DIR mounted?
 I MOUNT S MOUNT=$$DISMNT(DIR) I 'MOUNT Q  ;ask if mounted
 S X=$$LNKSET(DIR,NLNK) I 'X D FAIL(X) Q  ;could not change label?
 N DIRPNT S DIRPNT=$$ROOT(DIR)  ;root pointer of current volume
 I DIRPNT'="" S X=$$PNTSET(NLNK,DIRPNT) I 'X D FAIL(X) Q
 I MOUNT S X=$$REMOUNT(DIR) I 'X W !,X ;re-mount the directory
 W !,"Volume Link Modification complete.",!
 Quit  
EDLBIGDB For VOL=2:1:NVOL {
    New zu36,newdir Set zu36=$Zutil(36,DIR,0,VOL-1)
    S R=$$GetDir("Change volume "_VOL,zu36) I R="" Q:LINK=""  G EDLDEL
    I $E(R)="?" W ! DO  W ! G EDL
    . W !?4,"Enter the name of the new volume"_VOL_"."
    . W !?4,"This directory should contain the "_"IRIS"_".EXT which is "
    . W !?4,"volume"_VOL_" of the database whose primary volume is in "_DIR
    S newdir=$$ChkDirOrSpecEXISTS(R) I newdir="" W !,"(invalid directory name)" G EDL
    If newdir=zu36  W !,"(no change)" Goto endloop
    S MOUNT=$$MOUNTED(DIR) ;is directory DIR mounted?
    I MOUNT S MOUNT=$$DISMNT(DIR) I 'MOUNT Q  ;ask if mounted
    S X=$$LNKSETBIGDB(DIR,newdir,VOL) I 'X D FAIL(X) Q  ;could not change label?
    I MOUNT S X=$$REMOUNT(DIR) I 'X W !,X ;re-mount the directory
    W !,"Volume Link Modification complete.",!
endloop
    ;
 } ;End For VOL=1...
 Q
EDLDEL W !,"*** DELETION OF LINKS IS NOT CURRENTLY PERMITTED ***",! Q
CHAIN(DIR,VOL) ;given DIR as a 'top' directory, and 'VOL' as the volume
 If isbigdb {
    New zu36 Set zu36=$Zutil(36,DIR,0,VOL-1)
    While (zu36'="" && (zu36'<0)) {
       Write !,"Vol "_VOL_"/"_NVOL_"."
       Write ?12,$Case(VOL,1:DIR,:zu36)
       Set VOL=VOL+1
       Set zu36=$Zutil(36,DIR,0,VOL-1)
    }
    If VOL>(NVOL+1) {
       W *7,*7,!?4,"*** too many volumes!!! ***",!
    }
    If VOL<(NVOL+1) {
       W *7,*7,!?4,"*** too few volumes!!! ***",!
    }
    Quit  
 }
 N DD S DD=DIR S:'$G(VOL) VOL=1 F  DO  Q:DD=""  ;walk through the links
 . W !,"Vol "_VOL I NVOL W "/"_NVOL_". "
 . W ?12,DD S DD(DD)=VOL,VOL(VOL)=DD ;keep track to avoid loops
 . N LL S LL=$$LINK(DD),DD="" Q:LL=""  Q:LL=-1
 . I $D(DD(LL)) W *7,!,"*** REVISITING VOLUME '"_LL_"' ***" Q
 . S VOL=VOL+1,DD=LL D Touch(DD) ;next volume -- make it available
 I NVOL,VOL>NVOL W *7,*7,!?4,"*** too many volumes!!! ***",!
 I NVOL,VOL<NVOL W *7,*7,!?4,"*** too few volumes!!! ***",!
 Q
FAIL(X) W !,X,!,"Volume Modification aborted.",! Q
LABSET(DIR,NEW) N ZU36
 S ZU36=$ZU(36,DIR,0,0,NEW) ;set label of primary vol to NEW
 Q $S(ZU36<0:"Label change failed because "_$$MSG^%DKIOERR(ZU36),1:1)
LNKSET(DIR,NEW) N TYP,ZU36 S TYP=$$TYPE(DIR)
 I TYP="" Q ("Link change failed: no Volume-Type")
 S ZU36=$ZU(36,DIR,TYP,1,NEW) ;change the continuation pointer
 Q $S(ZU36<0:"Link change failed because "_$$MSG^%DKIOERR(ZU36),1:1)
LNKSETBIGDB(DIR,NEW,VOL) New ZU36
 Set ZU36=$Zutil(36,DIR,0,VOL-1,NEW)
 Q $S(ZU36<0:"Changing volume "_VOL_" failed because "_$$MSG^%DKIOERR(ZU36),1:1)
PNTSET(DIR,NEW) N TYP,ZU36 S TYP=$$TYPE(DIR)
 I TYP'=1 Q ("Root pointer change failed: inappropriate Volume-Type")
 S ZU36=$ZU(36,DIR,1,0,NEW) ;change the root pointer
 Q $S(ZU36<0:"Root pointer change failed because"_$$MSG^%DKIOERR(ZU36),1:1)
ROOT(DIR) N ZU36 S ZU36=$ZU(36,DIR,0,0) Q:ZU36'<0 ZU36 ;label of primary volume
 S ZU36=$ZU(36,DIR,1,0) Q:ZU36'<0 ZU36 ;location of primary volume
 Q -1 ;return -1: could not get the root directory
LINK(DIR) N ZU36 S ZU36=$ZU(36,DIR,0,1) Q:ZU36'<0 ZU36 ;link from root volume
 S ZU36=$ZU(36,DIR,1,1) Q:ZU36'<0 ZU36 ;link from secondary volume
 Q -1 ;return -1: could not get link directory
NEXTLINK(DIR,VOL) New ZU36 Set ZU36=$Zutil(36,DIR,0,VOL+1) Quit:ZU36'<0 ZU36
 Quit -1  ; Unknown Error
STAT(DIR) I (DIR=-1)!(DIR="") Q "" ;handle special case; bad directory name...
 S $ZT="STERR" Q $ZU(49,DIR) ;could fail, so...
STERR S $ZT="",$ZE="" Q "" ;return null: MUMPS.DAT, but bad label
TYPE(DIR) N ZU36 S ZU36=$ZU(36,DIR,0,0) Q:ZU36'<0 0 ;assumed primary worked
 S ZU36=$ZU(36,DIR,1,0) Q:ZU36'<0 1 ;assumed secondary worked
 Q "" ;neither!
NVOL(DIR) ;return number-of-volumes belonginf to database
 N ROOT,STAT S STAT=$$STAT(DIR) ;1st try the specified directory
 I STAT="" S ROOT=$$ROOT(DIR),STAT=$$STAT(ROOT) ;then try root
 Q $P(STAT,",",15) ;15th ,-piece is number of database volumes
MOUNTED(DIR) N D S D=DIR I $$TYPE(DIR)=1 S D=$$ROOT(DIR) ;use root
 s D=$$STAT(D) q $s(D<1!(D'<$zu(40,0,41)):0,1:1) ;is directory mounted?
UNMOUNT(DIR) S $ZT="MNTERR1^"_$ZN ;unmount a specific directory
 D ONE^DISMOUNT(DIR) Q 1 ;perform the dismount
MNTERR1 S $ZT="" Q ("Could not dismount '"_DIR_"'")
REMOUNT(DIR) ;remount it (if it was dismounted)
 S $ZT="MNTERR2^"_$ZN N (DIR) D ^ST
 s Status=##Class(SYS.Database).MountDatabase(DIR,0,0)
 i Status'=1 q "Remount of "_DIR_" failed"
 i $$MOUNTED(DIR) q 1
 Q "Could not remount '"_DIR_"'"
MNTERR2 S $ZT="" Q ("Could not remount '"_DIR_"'")
DISMNT(DIR) N X,MNT S MNT=1 DO  Q MNT
 . S X=$$YN("Dismount directory '"_DIR_"' to perform change","Y")
 . I X'="Y" W !,"Modifications discarded.",! S MNT=0 Q  ;by decision
 . S X=$$UNMOUNT(DIR) I 'X D FAIL(X) S MNT=0 Q  ;by error
GetDir(prompt,defdir,exists,quit) ;ask for a directory, allow defaults
GetDirLoop ; Loop until we get something valid or exit
 s $zt="GetDirE"
 n exist,dir,x
 s exist=+$g(exists,1) ; default is to check if exists
 w !,prompt_": "_$s($g(defdir)'="":$g(defdir)_" => ",1:"") r dir s:dir="" dir=$g(defdir)
 i $$STOP(dir) Set quit=1 Q ""
 i $E(dir)="?" Q dir ;pass-on request for elaboration
 q:exist<0 dir ;exist<0 means don't check valid or exists
 s x=$S(exist:$$ChkDirOrSpecEXISTS(dir),1:$$ChkDirVALID(dir)) 
 i x="" W *7,"  "_$s(exist:"Directory '"_dir_"' does not exist",1:"Invalid directory specification '"_dir_"'") G:exist GetDirLoop d  g:x="N" GetDirLoop
 . s x=$$YN("Use this directory anyway","N")
 i x="^" s quit=1 Quit ""
 q dir
GetDirE S $ZT=""
 i $ze["<INTERRUPT>" q ""
 w !,"Error: "_$ZE
 zquit 1 i $ZT'="" G @$ZT
 q ""
Touch(D)
 q
ChkDirVALID(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,1)
ChkDirEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkDirOrSpecEXISTS(R) S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,3)
ChkDir(R) N N S $ZE="",$ZT="ChkBad" q:R[":mirror:" R q $ZU(12,R,2)
ChkBad S $ZT="" W !,"<"_$P($P($ZE,"<",2),">")_"> error -- invalid directory"
 Q ""
YN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YN"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"yn","YN") I "^YN"'[R W "  enter Yes or No, please"
 S POP=(R="^") W $E($S(R="N":"No",R="Y":"Yes",1:""),$L(X)+1,3) Q R
STOP(x) S x=$zconvert($E(x,1,4),"U") Q (x["EXIT")!(x["STOP")!(x["QUIT")!(x["HALT")!($E(x)="^")
ED(%L) ; Edit using the familiar old line editor.
 N %IED,%R,%W,%A,%B,%C,%D,%J X ^%("ED") W !?7,"--> "_%L Q %L

LANGZDEF^INT^1^67214,47330
LANGZDEF ;Placeholder for customer written 'Z' language extensions
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ; Used during installation if the corresponding %ZLANG* routine
 ; does not exist so we get <SYNTAX> errors instead of <NOROUTINE>
 ; errors for illegal Zcommands, Zfunctions, etc...
 q

LANGZINST^INT^1^67214,47330
%LANGZINST ;Gen defaults for customer written cmd routines
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
INSTALL ;
 n rtntype,rtn,base,len,custrtn
 ;
 ; C = commands, F = functions, V = variables
 f rtntype="C","F","V" d
 . s rtn="LANG"_rtntype  ; starting point for $ORDER()
 . s base=rtn
 . s len=$L(base)
 . f  s rtn=$O(^rOBJ(rtn)) q:$E(rtn,1,len)'=base  d
 . . s custrtn="%Z"_$E(rtn,2,$L(rtn))
 . . q:$D(^ROUTINE(custrtn))  ; already exists
 . . q:$D(^rOBJ(custrtn))  ; already exists
 . . x "zr  zl LANGZDEF zs "_custrtn  ; generate it

LEGACYNETWORK^INT^1^67214,47330
LEGACYNETWORK ;Legacy Network configuration manager
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 /*
---------------------Maintenance------------------------------------
SML1413 12/05/11 Simon Li, Fix wrong choice accepted in the 'FlowControl' option of ^LEGACYNETWORK. 
STC1706 11/25/09 Steve Clay, Process config file setting for Cache Windows LAT daemon 
SML1095 12/22/08 Simon Li, Create utility to configure legacy network. 
-------------------End Maintenance----------------------------------
 */
 New
MENU s $zt="MENUE"
 w !
 w !,"1) COM Port Setup"
 w !,"2) Exit"
 w !
 s Option=$$OPTION("Option? ",2,2)
 i Option=1 d COMSETUP() g MENU
 q
MENUE s $zt=""
 i $ze'["<INTERRUPT>" w !,"ERROR: "_$ZE
 q
COMSETUP() PRIVATE {
 I '($zversion(1)=2) w !,"Only support for Windows platform." q
TOP
 s $zt="COMSETUPE"
 w !
 w !,"1) List COM Ports"
 w !,"2) Add COM Ports"
 w !,"3) Edit COM Ports"
 w !,"4) Remove COM Ports"
 w !,"5) Exit"
 w !
 s Option=$$OPTION("Option? ",5,5)
 i Option=1 d COMLIST() g TOP
 i Option=2 d COMADD() g TOP
 i Option=3 d COMEDIT() g TOP
 i Option=4 d COMREMOVE() g TOP
 q
COMSETUPE s $zt=""
 i $ze'["<INTERRUPT>" w !,"ERROR: "_$ZE
 q
}
COMLIST() PRIVATE {
 s $zt="COMLISTE"
 Set Rset = ##class(%Library.ResultSet).%New("Config.ComPorts:List")
 i '(''Rset) d $SYSTEM.Status.DisplayError(%objlasterror) q
 d Rset.Execute()
 w !,Rset.GetColumnName(1)
 w ?7,"ModemCtrl"
 w ?17,Rset.GetColumnName(3)
 w ?26,Rset.GetColumnName(4)
 w ?34,Rset.GetColumnName(5)
 w ?43,"FlowCtrl"
 w ?52,Rset.GetColumnName(7)
 w ?60,Rset.GetColumnName(8)
 w ?68,Rset.GetColumnName(9)
 w !,$$UL(Rset.GetColumnName(1))
 w ?7,$$UL("ModemCtrl")
 w ?17,$$UL(Rset.GetColumnName(3))
 w ?26,$$UL(Rset.GetColumnName(4))
 w ?34,$$UL(Rset.GetColumnName(5))
 w ?43,$$UL("FlowCtrl")
 w ?52,$$UL(Rset.GetColumnName(7))
 w ?60,$$UL(Rset.GetColumnName(8))
 w ?68,$$UL(Rset.GetColumnName(9))
 While Rset.Next() {
	w !,Rset.Data("Name")
	s d=Rset.Data("ModemControl")
	w:$x>7 ! w ?7,$case(d," ":"Windows",1:"Enabled",:"Disabled")
	s d=Rset.Data("DataBits")
	w:$x>17 ! w ?17,$s(d=" ":"Windows",1:d)
	s d=Rset.Data("Parity")
	w:$x>26 ! w ?26,$case(d," ":"Windows","0":"No","1":"Odd","2":"Even","3":"Mark","4":"Space",:"Unknown")
	s d=Rset.Data("StopBits")
	w:$x>34 ! w ?34,$case(d," ":"Windows","1":"1","2":"2","3":"1.5",:"Unknown")
	s d=Rset.Data("FlowControl")
	w:$x>43 ! w ?43,$case(d," ":"Windows","X":"Xon-Xoff","C":"CTS-RTS","D":"DSR-DTR",:"Unknown")
	s d=Rset.Data("DTR")
	w:$x>52 ! w ?52,$case(d," ":"Windows",1:"Enabled",:"Disabled")
	s d=Rset.Data("ZAError")
	w:$x>60 ! w ?60,$case(d," ":"Windows",1:"Enabled",:"Disabled")
	w:$x>68 ! w ?68,Rset.Data("BaudRate")
 }
 q
COMLISTE s $zt=""
 i $ze'["<INTERRUPT>" w !,"ERROR: "_$ZE
 q
}
COMADD() PRIVATE {
 s property("BaudRate")=19200
 s property("DTR")=" "
 s property("DataBits")="8"
 s property("FlowControl")=" "
 s property("ModemControl")=" "
 s property("Parity")=" "
 s property("StopBits")=" "
 s property("ZAError")=" "
TOP w !
 s $zt="COMADDE",POP=0
 s Name=$$STRINGOPTION("Enter Name to be created","",1)
 If Name="?" D COMLIST() g TOP
 I Name="" Quit
 I Name'?1"COM".N1":" w "  Name should start with ""COM"" and end with "":""" g TOP
 i ##Class(Config.ComPorts).Exists(Name,.Obj) w " COM Port "_Name_" already exist." k Obj g TOP
BaudRate
 s property("BaudRate")=$$NUMOPTION("Baud Rate",property("BaudRate"),110,256000,.POP)
 I property("BaudRate")=-1 q
 I POP s property("BaudRate")=19200 g TOP
 I ",110,300,600,1200,2400,4800,9600,14400,19200,38400,56000,57600,115200,128000,256000,"'[(","_property("BaudRate")_",") w !,"Valid Baud Rates are",!,$e(",110,300,600,1200,2400,4800,9600,14400,19200,38400,56000,57600,115200,128000,256000,",2,*-1) s property("BaudRate")=19200 g TOP 
DTR
 s d=$TR(property("DTR")," ","2")
 w !!,"0) Disabled"
 w !,"1) Enabled"
 w !,"2) Windows Setting"
 s d=$$NUMOPTION("Enter DTR",d,0,2,.POP)
 I d=-1 q
 I POP s POP=0 s property("DTR")=" " g BaudRate
 s property("DTR")=$TR(d,"2"," ")
DataBits
 s d=$TR(property("DataBits")," ","9")
 w !!,"5) 5 Data Bits"
 w !,"6) 6 Data Bits"
 w !,"7) 7 Data Bits"
 w !,"8) 8 Data Bits"
 w !,"9) Windows Setting"
 s d=$$NUMOPTION("Enter Data Bits",d,5,9,.POP)
 I d=-1 q
 I POP s POP=0 s property("DataBits")=" " g DTR
 s property("DataBits")=$TR(d,"9"," ")
FlowControl
 s d=$TR(property("FlowControl")," ","W")
 w !!,"X) Xon-Xoff"
 w !,"C) CTS-RTS"
 w !,"D) DSR-DTR"
 w !,"W) Windows Setting"
 s d=$$STRINGOPTION("Enter Flow Control",d,0,.POP)
 I d=-1 q
 I POP s POP=0 s property("FlowControl")=" " g DataBits
 s d=$zconvert(d,"U")
 I ",X,C,D,W,"'[(","_d_",") w "  bad value, please enter X, C, D or W" s property("FlowControl")=" " g FlowControl
 s property("FlowControl")=$TR(d,"W"," ")
ModemControl
 s d=$TR(property("ModemControl")," ","2")
 w !!,"0) Disabled"
 w !,"1) Enabled"
 w !,"2) Windows Setting"
 s d=$$NUMOPTION("Enter ModemControl",d,0,2,.POP)
 I d=-1 q
 I POP s POP=0 s property("ModemControl")=" " g FlowControl
 s property("ModemControl")=$TR(d,"2"," ")
Parity
 s d=$TR(property("Parity")," ","5")
 w !!,"0) No Parity"
 w !,"1) Odd Parity"
 w !,"2) Even Parity"
 w !,"3) Mark Parity"
 w !,"4) Space Parity"
 w !,"5) Windows Setting"
 s d=$$NUMOPTION("Enter Data Bits",d,0,5,.POP)
 I d=-1 q
 I POP s POP=0 s property("Parity")=" " g ModemControl
 s property("Parity")=$TR(d,"5"," ")
StopBits
 s d=$TR(property("StopBits")," ","4")
 w !!,"1) 1 Stop Bit"
 w !,"2) 2 Stop Bits"
 w !,"3) 1.5 Stop Bits"
 w !,"4) Windows Setting"
 s d=$$NUMOPTION("Enter Data Bits",d,1,4,.POP)
 I d=-1 q
 I POP s POP=0 s property("StopBits")=" " g Parity
 s property("StopBits")=$TR(d,"4"," ")
ZAError
 s d=$TR(property("ZAError")," ","2")
 w !!,"0) Disabled"
 w !,"1) Enabled"
 w !,"2) Windows Setting"
 s d=$$NUMOPTION("Enter ZAError",d,0,2,.POP)
 I d=-1 q
 I POP s POP=0 s property("ZAError")=" " g FlowControl
 s property("ZAError")=$TR(d,"2"," ")
 s ans=$$YNOPTION("Confirm to Create COM Port "_Name,1,.POP)
 I POP s POP=0 g ZAError
 I ans<1 q
 s Status=##Class(Config.ComPorts).Create(Name,.property)
 i '(''Status) d $SYSTEM.Status.DisplayError(Status) q
 w !,"COM Port "_Name_" Created."
 q
COMADDE s $zt=""
 i $ze'["<INTERRUPT>" w !,"ERROR: "_$ZE
 q
}
COMEDIT() PRIVATE {
TOP w !
 s $zt="COMEDITE",POP=0
 s Name=$$STRINGOPTION("Enter Name to be edited","",1)
 If Name="?" D COMLIST() g TOP
 I Name="" Quit
 I Name'?1"COM".N1":" w "  Name should start with ""COM"" and end with "":""" g TOP
 i '##Class(Config.ComPorts).Exists(Name,.Obj) w " COM Port "_Name_" does not exist." g TOP
BaudRate
 s property("BaudRate")=$$NUMOPTION("Baud Rate",$g(property("BaudRate"),Obj.BaudRate),110,256000,.POP)
 I property("BaudRate")=-1 q
 I POP k property("BaudRate") g TOP
 I ",110,300,600,1200,2400,4800,9600,14400,19200,38400,56000,57600,115200,128000,256000,"'[(","_property("BaudRate")_",") w !,"Valid Baud Rates are",!,$e(",110,300,600,1200,2400,4800,9600,14400,19200,38400,56000,57600,115200,128000,256000,",2,*-1) k property("BaudRate") g TOP 
 I property("BaudRate")=Obj.BaudRate k property("BaudRate")
DTR
 s d=$TR($g(property("DTR"),Obj.DTR)," ","2")
 w !!,"0) Disabled"
 w !,"1) Enabled"
 w !,"2) Windows Setting"
 s d=$$NUMOPTION("Enter DTR",d,0,2,.POP)
 I d=-1 q
 I POP s POP=0 k property("DTR") g BaudRate
 s property("DTR")=$TR(d,"2"," ")
 I property("DTR")=Obj.DTR k property("DTR")
DataBits
 s d=$TR($g(property("DataBits"),Obj.DataBits)," ","9")
 w !!,"5) 5 Data Bits"
 w !,"6) 6 Data Bits"
 w !,"7) 7 Data Bits"
 w !,"8) 8 Data Bits"
 w !,"9) Windows Setting"
 s d=$$NUMOPTION("Enter Data Bits",d,5,9,.POP)
 I d=-1 q
 I POP s POP=0 k property("DataBits") g DTR
 s property("DataBits")=$TR(d,"9"," ")
 I property("DataBits")=Obj.DataBits k property("DataBits")
FlowControl
 s d=$TR($g(property("FlowControl"),Obj.FlowControl)," ","W")
 w !!,"X) Xon-Xoff"
 w !,"C) CTS-RTS"
 w !,"D) DSR-DTR"
 w !,"W) Windows Setting"
 s d=$$STRINGOPTION("Enter Flow Control",d,0,.POP)
 I d=-1 q
 I POP s POP=0 k property("FlowControl") g DataBits
 s d=$zconvert(d,"U")
 I ",X,C,D,W,"'[(","_d_",") w "  bad value, please enter X, C, D or W" k property("FlowControl") g FlowControl
 s property("FlowControl")=$TR(d,"W"," ")
 I property("FlowControl")=Obj.FlowControl k property("FlowControl")
ModemControl
 s d=$TR($g(property("ModemControl"),Obj.ModemControl)," ","2")
 w !!,"0) Disabled"
 w !,"1) Enabled"
 w !,"2) Windows Setting"
 s d=$$NUMOPTION("Enter ModemControl",d,0,2,.POP)
 I d=-1 q
 I POP s POP=0 k property("ModemControl") g FlowControl
 s property("ModemControl")=$TR(d,"2"," ")
 I property("ModemControl")=Obj.ModemControl k property("ModemControl")
Parity
 s d=$TR($g(property("Parity"),Obj.Parity)," ","5")
 w !!,"0) No Parity"
 w !,"1) Odd Parity"
 w !,"2) Even Parity"
 w !,"3) Mark Parity"
 w !,"4) Space Parity"
 w !,"5) Windows Setting"
 s d=$$NUMOPTION("Enter Data Bits",d,0,5,.POP)
 I d=-1 q
 I POP s POP=0 k property("Parity") g ModemControl
 s property("Parity")=$TR(d,"5"," ")
 I property("Parity")=Obj.Parity k property("Parity")
StopBits
 s d=$TR($g(property("StopBits"),Obj.StopBits)," ","4")
 w !!,"1) 1 Stop Bit"
 w !,"2) 2 Stop Bits"
 w !,"3) 1.5 Stop Bits"
 w !,"4) Windows Setting"
 s d=$$NUMOPTION("Enter Data Bits",d,1,4,.POP)
 I d=-1 q
 I POP s POP=0 k property("StopBits") g Parity
 s property("StopBits")=$TR(d,"4"," ")
 I property("StopBits")=Obj.StopBits k property("StopBits")
ZAError
 s d=$TR($g(property("ZAError"),Obj.ZAError)," ","2")
 w !!,"0) Disabled"
 w !,"1) Enabled"
 w !,"2) Windows Setting"
 s d=$$NUMOPTION("Enter ZAError",d,0,2,.POP)
 I d=-1 q
 I POP s POP=0 k property("ZAError") g FlowControl
 s property("ZAError")=$TR(d,"2"," ")
 I property("ZAError")=Obj.ZAError k property("ZAError")
 if $d(property) {
	 s ans=$$YNOPTION("Confirm to Update COM Portr "_Name,1,.POP)
	 I POP s POP=0 g ZAError
	 I ans<1 q
	 s Status=##Class(Config.ComPorts).Modify(Name,.property)
	 i '(''Status) d $SYSTEM.Status.DisplayError(Status) q
	 w !,"COM Port "_Name_" is updated."
 }
 q
COMEDITE s $zt=""
 i $ze'["<INTERRUPT>" w !,"ERROR: "_$ZE
 q
}
COMREMOVE() PRIVATE {
TOP w !
 s $zt="COMREMOVEE",POP=0
 s Name=$$STRINGOPTION("Enter Name to be removed","",1)
 I Name="?" D COMLIST() g TOP
 I Name="" Quit
 i '##Class(Config.ComPorts).Exists(Name,.Obj) w " COM Port "_Name_" does not exist." g TOP
 s ans=$$YNOPTION("Confirm to Remove COMPort "_Name,0,.POP)
 I POP s POP=0 k Obj g TOP
 I ans>0 {
	 s Status=##Class(Config.ComPorts).Delete(Name)
	 i '(''Status) d $SYSTEM.Status.DisplayError(Status) q
	 w !,"COM Port "_Name_" is removed"
 }
 q
COMREMOVEE s $zt=""
 i $ze'["<INTERRUPT>" w !,"ERROR: "_$ZE
 q
}
OPTION(prompt,default,max) [] PRIVATE {
 s $zt="OPTIONE"
OPTION1 w !,prompt
 r Option i Option="" q default
 i '(Option?1.2N)!(Option<1)!(Option>max) w !!,"Please enter a number between 1 and "_max,! g OPTION1
 q +Option
OPTIONE s $zt=""
 i $ze'["<INTERRUPT>" w !,"ERROR: "_$ZE
 q 0
}
YNOPTION(prompt,default,POP) [] PRIVATE {
 s $zt="YNOPTIONE"
 s dstr=$s(+default:"Yes",1:"No")
YNOPTION1 w !,prompt_"? "_dstr_" => "
 r Option i Option="" w dstr q default
 i Option="^" s POP=1 q 0
 s Option=$TR($E(Option),"yn","YN")
 i "YN"']Option w !!,"Please enter Yes or No",! g YNOPTION1
 q Option="Y"
YNOPTIONE s $zt=""
 i $ze'["<INTERRUPT>" w !,"ERROR: "_$ZE
 q -1
}
NUMOPTION(prompt,default,min,max,POP) [] PRIVATE {
 s $zt="NUMOPTIONE"
NUMOPTION1 w !,prompt_"? "_+default_" => "
 r Option i Option="" w default q default
 i Option="^" s POP=1 q 0
 i '(Option?1.10N)||(Option<min)||(max]""&&(Option>max)) w !!,"Please enter a number between "_min_" and "_$s(max]"":max,1:"10000000000"),! g NUMOPTION1
 q +Option
NUMOPTIONE s $zt=""
 i $ze'["<INTERRUPT>" w !,"ERROR: "_$ZE
 q -1
}
STRINGOPTION(prompt,default,allownull,POP) [] PRIVATE {
 s $zt="STRINGOPTIONE"
STRINGOPTION1 w !,prompt_"? " i default'="" w default_" => "
 r Option i Option="",(default'="") w default q default
 i Option="",(allownull=0) w !,"Please enter a non-null value" g STRINGOPTION1 
 i Option="^" s POP=1 q ""
 i Option=" ",(allownull=1) s Option=""
 q Option
STRINGOPTIONE s $zt=""
 i $ze'["<INTERRUPT>" w !,"ERROR: "_$ZE
 q -1
}
UL(String) PRIVATE {
	s $P(x,"-",$l(String)+1)=""
	q x
}
SECURITYCHECK() PRIVATE {
 i '$SYSTEM.Security.Check("%Admin_Secure","USE") {
	 w !,$$FormatMsg^%occMessages("%SECURITY.Security","OperationRequiresAccess","USE","%Admin_Secure")
	 q 0
 }
 q 1
}

LOCKTAB^INT^1^67214,47330
LOCKTAB ; LOCKTAB Utility
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 N PAGEF S PAGEF=1
 N ViewOnly S ViewOnly=0
start ;
 i '$SYSTEM.Security.Check("%Admin_Operate","USE") w !,"Operation requires %Admin_Operate:Use privilege" q
 N COMMAND,INDEX
 N MSYS,FF,SL,BS,RM,SUB,XY  ; from CURRENT^%IS
 N context,LockTime,FreeSpace,StartOwner,LockData
 N Ownersx,POP
 N LockTmp
 N HDL S HDL=8
MAIN S $ZT=""
 D CURRENT^%IS,GATHER,DISPLAY
 G:PAGEF=0 EXIT
 F  W !!,"Command=> " DO  I "^Qq"[$E(COMMAND_"?") Q
 . I INDEX>(SL-HDL) W "<RETURN> for more... "
 . R COMMAND#1
 . I "Ss"[COMMAND D DISPLAY Q
 . I "Qq^"[COMMAND QUIT
 . I "Rr"[COMMAND D GATHER,DISPLAY Q
 . I "Hh?"[COMMAND D HELP Q
 . I $G(ViewOnly) Q
 . I "Dd1"[COMMAND D DELONE,GATHER Q
 . I "Jj"[COMMAND D DELJOB,GATHER Q
 . I "Cc"[COMMAND D DELSYS,GATHER Q
 ;
EXIT S $ZT="" U 0:0 kill @LockTmp
 QUIT
GATHER  ;
 i '$SYSTEM.Security.Check("%Admin_Operate","USE") w !,"Operation requires %Admin_Operate:Use privilege" q
 S LockTime=$H,context="",StartOwner=0,INDEX=SL
 s LockTmp="^mtemp($j,""LockTab"")"
 k @LockTmp
 do buildtmp(LockTmp)
 S FreeSpace=##Class(SYS.Lock).GetLockSpaceInfo()
 s context=""
 Q
ALL ; entry point for display lock table without pause.
 N PAGEF S PAGEF=0
 N ViewOnly S ViewOnly=0
 i '$SYSTEM.Security.Check("%Admin_Operate","USE") w !,"Operation requires %Admin_Operate:Use privilege" q
 G start
View ; Entry point for only display lock table.
 N PAGEF S PAGEF=1
 N ViewOnly S ViewOnly=1
 i '$SYSTEM.Security.Check("%Admin_Operate","USE") w !,"Operation requires %Admin_Operate:Use privilege" q
 G start
buildtmp(tmpglo) []
{
	Set Rset=##class(%Library.ResultSet).%New("%SYS.LockQuery:Detail")
	S idx=1
	Do Rset.Execute("")
	While Rset.Next() {
		m @tmpglo@(idx)=Rset.Data
		s idx=idx+1
	}
}
DISPLAY ; Display contents of holder using necessary translation arrays etc.
 ;  and being mindful of screen length
 n BYTAVAIL,HEADER,rc,count,%T,%TIM,LineLeft,prev
 n NODEHEAD
 S %T=$p(LockTime,",",2) S %TIM=$ZTIME(%T,4,0,"")
 S HEADER="LOCK table entries at "_%TIM_"  "_$ZDATE(LockTime,1,,4)
 S BYTAVAIL=$P(FreeSpace,",",2)_" bytes usable, "_$P(FreeSpace,",",1)_" bytes available."
 n NodeInfo s NodeInfo=##class(SYS.Lock).GetNodeInfo()
 S NODEHEAD="Node Name: "_$p(NodeInfo,$C(0),1)
 I $P(NodeInfo,$C(0),2) D
 . S NODEHEAD=NODEHEAD_"  Cluster Master: "_$P(NodeInfo,$C(0),4)
 . I $P(NodeInfo,$C(0),3) S NODEHEAD=NODEHEAD_", You are in the Master Node."
 W @FF,?(RM-$L(NODEHEAD)/2),NODEHEAD,!
 W ?(RM-$L(HEADER)/2),HEADER,!,?(RM-$L(BYTAVAIL)/2),BYTAVAIL
 W !
 N HDR D HDR(1)
 S LineLeft=SL-HDL
 S prev=context
 If StartOwner=0 {
	 s context=$O(@LockTmp@(context))
	 If context=""&(prev="") W !,"**** EMPTY ****" QUIT
	 k LockData m LockData=@LockTmp@(context) s LockData("LockEntryNum")=context
 }
again ;
 S:PAGEF=0 LineLeft=1000
 s StartOwner=$$Show(.LockData,.LineLeft,RM,StartOwner,0,1,0)
 I LineLeft=0,StartOwner=0 s rc=context I $O(@LockTmp@(rc))="" s INDEX=0,context="" Q
 S INDEX=SL
 Q:LineLeft=0
 s context=$O(@LockTmp@(context))
 i context="" S INDEX=0 Quit
 k LockData m LockData=@LockTmp@(context) s LockData("LockEntryNum")=context
 g again
Show(info,LineLeft,RM,StartOwner,pid,WaiterFlag,updateINDEX)
 s updateINDEX=$g(updateINDEX,0)
 N entry,LMode,ref,Owners,Waiters,Flags,LineIN,nline,nOwner,nWaiter,lineOK,PrintWaiter,i
 S LineIN=LineLeft,lineOK=1,PrintWaiter=0
 I LineIN=0 S WaiterFlag=0,pid=$g(pid,0)
 E  S pid=0
 S StartOwner=$g(StartOwner,1) I StartOwner=0 S StartOwner=1
 S entry=info("LockEntryNum"),LMode=info("Mode")
 S ref=$$Quote^%qcr(info("FullReference"),1)
 S Owners=$LB(info("Owner"),info("Counts"),$G(info("EscalateInfo"))),Waiters=$s($d(info("WaiterPID")):$LB(info("WaiterPID"),info("WaiterMode"),info("WaiterType")),1:$LB("","",""))
 S Flags=info("Flags")
 S nOwner=$L($LIST(Owners,1),","),nWaiter=$S($LIST(Waiters,1)="":0,1:$L($LIST(Waiters,1),","))
 I LineIN DO  i updateINDEX s INDEX=INDEX+$s(lineOK=0:LineIN+20,1:$L($LIST(Owners,1),",")-StartOwner+nline+$s(nWaiter:1,1:0)-1)
 . S nline=$l(ref)+$s(WaiterFlag:((((((0+6)+9)+5)+5+1)+4)+4+1),1:(((((0+6)+9)+5)+5+1)+4))-1\RM+1
 . S LineLeft=LineLeft-nline I LineLeft<0 S (LineLeft,nOwner,lineOK)=0 Q
 . I LineLeft=0 S:nWaiter!(nOwner>1) lineOK=0 S nOwner=$S(nWaiter:0,1:1) Q  ; No more space.
 . ; There is at least one line space available
 . ; Only one Owner or last owner to print
 . I (nOwner=1!(StartOwner=nOwner)) S nOwner=1 S:nWaiter LineLeft=LineLeft-1,PrintWaiter=1 Q
 . ; no enough lines for this lock entry
 . I (nOwner-StartOwner)>LineLeft s nOwner=LineLeft+$s(nWaiter:0,1:1),(LineLeft,lineOK)=0 Q
 . I (nOwner-StartOwner)=LineLeft s nOwner=LineLeft+$s(nWaiter:0,1:1),LineLeft=0 s:nWaiter lineOK=0 Q
 . s nOwner=nOwner-StartOwner,LineLeft=LineLeft-nOwner
 . S nOwner=nOwner+1
 . I nWaiter S LineLeft=LineLeft-1,PrintWaiter=1
 DO:nOwner
 . N i
 . I pid'=0 DO  Q:nOwner
 . . F i=1:1:nOwner I $P($LIST(Owners,1),",",i)=pid S StartOwner=i,nOwner=0 Q
 . W !,$J(entry,4),")",?(0+6)
 . s Ownersx=$P($LIST(Owners,1),",",StartOwner)
 . If Ownersx?1.N S Ownersx=Ownersx  ;Convert to hex to display.
 . W Ownersx
 . N ccnt s ccnt=$P($LIST(Owners,2),",",StartOwner)
 . N escainfo s escainfo=$P($LIST(Owners,3),",",StartOwner)
 . N xcnt,scnt,cnt,xeinfo,seinfo,ebcnt,edcnt,ebdcnt,eddcnt,ps
 . I LMode="X" do
 . . s xcnt=$p(ccnt,"|",1),xeinfo=$p(escainfo,"|",1)
 . . s ebcnt=+$p(xeinfo,"^",2),edcnt=+$p(xeinfo,"^",3),ebdcnt=+$p(xeinfo,"^",4),eddcnt=+$p(xeinfo,"^",5)
 . . i xcnt["D" s cnt=+xcnt-ebdcnt-eddcnt,ps="+" s:cnt=0 cnt="",ps="" s:ebdcnt cnt=cnt_ps_ebdcnt_"e",ps="+" s:eddcnt cnt=cnt_ps_eddcnt_"E" s cnt=cnt_"D"
 . . i xcnt'["D" s cnt=+xcnt-ebcnt-edcnt,ps="+" s:cnt=0 cnt="",ps="" s:ebcnt cnt=cnt_ps_ebcnt_"e",ps="+" s:edcnt cnt=cnt_ps_edcnt_"E",ps="+" s:ebdcnt cnt=cnt_ps_ebdcnt_"de",ps="+" s:eddcnt cnt=cnt_ps_eddcnt_"dE"
 . . W ?((0+6)+9),$j(cnt,5)
 . . I ccnt["|" Do
 . . . s scnt=$p(ccnt,"|",2),seinfo=$p(escainfo,"|",2)
 . . . s ebcnt=+$p(seinfo,"^",2),edcnt=+$p(seinfo,"^",3),ebdcnt=+$p(seinfo,"^",4),eddcnt=+$p(seinfo,"^",5)
 . . . i scnt["D" s cnt=+scnt-ebdcnt-eddcnt,ps="+" s:cnt=0 cnt="",ps="" s:ebdcnt cnt=cnt_ps_ebdcnt_"e",ps="+" s:eddcnt cnt=cnt_ps_eddcnt_"E" s cnt=cnt_"D"
 . . . i scnt'["D" s cnt=+scnt-ebcnt-edcnt,ps="+" s:cnt=0 cnt="",ps="" s:ebcnt cnt=cnt_ps_ebcnt_"e",ps="+" s:edcnt cnt=cnt_ps_edcnt_"E",ps="+" s:ebdcnt cnt=cnt_ps_ebdcnt_"de",ps="+" s:eddcnt cnt=cnt_ps_eddcnt_"dE"
 . . . W ?(((0+6)+9)+5),$j(cnt,5)
 . I LMode="ZAX"&(ccnt["|") W ?(((0+6)+9)+5),$j($p(ccnt,"|",2),5)
 . I LMode="S" Do
 . . s scnt=ccnt,seinfo=escainfo
 . . s ebcnt=+$p(seinfo,"^",2),edcnt=+$p(seinfo,"^",3),ebdcnt=+$p(seinfo,"^",4),eddcnt=+$p(seinfo,"^",5)
 . . i scnt["D" s cnt=+scnt-ebdcnt-eddcnt,ps="+" s:cnt=0 cnt="",ps="" s:ebdcnt cnt=cnt_ps_ebdcnt_"e",ps="+" s:eddcnt cnt=cnt_ps_eddcnt_"E" s cnt=cnt_"D"
 . . i scnt'["D" s cnt=+scnt-ebcnt-edcnt,ps="+" s:cnt=0 cnt="",ps="" s:ebcnt cnt=cnt_ps_ebcnt_"e",ps="+" s:edcnt cnt=cnt_ps_edcnt_"E",ps="+" s:ebdcnt cnt=cnt_ps_ebdcnt_"de",ps="+" s:eddcnt cnt=cnt_ps_eddcnt_"dE"
 . . W ?(((0+6)+9)+5),$j(cnt,5)
 . W ?((((0+6)+9)+5)+5+1),Flags
 . W:WaiterFlag ?(((((0+6)+9)+5)+5+1)+4),$j($s(nWaiter:nWaiter,1:""),4)
 . W ?$s(WaiterFlag:((((((0+6)+9)+5)+5+1)+4)+4+1),1:(((((0+6)+9)+5)+5+1)+4)),ref
 . F i=1:1:nOwner-1 DO
 . . W !,?(0+6)
 . . s Ownersx=$P($LIST(Owners,1),",",StartOwner+i)
 . . If Ownersx?1.N S Ownersx=Ownersx  ;Convert to hex to display.
 . . W Ownersx
 . . I LMode="X" W ?((0+6)+9),$j($P($LIST(Owners,2),",",StartOwner+i),5)
 . . I LMode="S" W ?(((0+6)+9)+5),$j($P($LIST(Owners,2),",",StartOwner+i),5)
 . DO:PrintWaiter
 . . N tot,wpid S tot=8
 . . W !,"Waiters:"
 . . F i=1:1:nWaiter d
 . . . s wpid=$P($LIST(Waiters,1),",",i)
 . . . If wpid?1.N S wpid=wpid  ;Convert to hex to display.
 . . . s wpid=wpid_"("_$P($LIST(Waiters,2),",",i)_$P($LIST(Waiters,3),",",i)_")" s tot=tot+$l(wpid)+1 q:tot>RM  W " ",wpid
 Q $s(lineOK!((StartOwner+nOwner)>$L($LIST(Owners,1),",")):0,1:StartOwner+nOwner)
HDR(Waiter) W ! ;display the column headers
 S Waiter=$g(Waiter,0)
 W "Entry",?(0+6),"Process"
 W ?((0+6)+9),$j("X#",5)
 W ?(((0+6)+9)+5),$j("S#",5)
 W ?((((0+6)+9)+5)+5+1),"Flg"
 W:Waiter ?(((((0+6)+9)+5)+5+1)+4),$j("W#",4)
 W ?$s(Waiter:((((((0+6)+9)+5)+5+1)+4)+4+1),1:(((((0+6)+9)+5)+5+1)+4)),"Item Locked"
 S HDR=1 Q  ;marks that the header was displayed
DELONE ; Delete one entry
 i '$SYSTEM.Security.Check("%Admin_Operate","USE") w !,"Operation requires %Admin_Operate:Use privilege" q
 N entry,data,ll
delonein R !,"Entry to delete: ",entry I entry="?" D  G delonein
 . W !,"Enter an entry number from the left column or the full entry"
 . W !,"as listed in the right column."
 I "Qq^"[entry QUIT
 DO
 . S entry=$$FindEntry(entry)
 . I 'entry W !,"Entry #",entry," does not exist" Q
 . s ll=0
 . k data m data=@LockTmp@(entry) s data("LockEntryNum")=entry
 . I $$Show(.data,.ll)
 . I data("Flags")["D" D
 . . W !,"WARNING ***"
 . . W !,"The lock entry is in the middle of unlocking to remote server."
 . . W !,"Remove this lock may cause problem unless you are cleaning"
 . . W !,"the stranded lock entries."
 . I data("RemoteOwner") D
 . . W !,"WARNING ***"
 . . W !,"The lock entry is owned by a remote owner."
 . . W !,"Remove this lock may cause problem unless you are cleaning"
 . . W !,"the stranded lock entries."
 . I $$YN("Are you sure you want to delete this lock","N")'="Y" Q
 . n rc s rc=##Class(SYS.Lock).DeleteOneLock(data("DelKey"),"",1)
 . W:+rc " deleted" W:'+rc " failed, error=",$SYSTEM.Status.GetErrorText(rc)
 G delonein
FindEntry(entry)
 If entry?.N Quit $s($d(@LockTmp@(entry))=0:0,1:entry)
 New i
 s i=""
 For  s i=$O(@LockTmp@(i)) Q:i=""  Q:@LockTmp@(i,"FullReference")=entry
 Quit +i
DELJOB ; delete all locks for one job on the current system
 i '$SYSTEM.Security.Check("%Admin_Operate","USE") w !,"Operation requires %Admin_Operate:Use privilege" q
 N job,R,SUB,CNT
DJOB K job F  DO  Q:$D(job)  ;loop until a job is selected (or quits)
 . R !,"Process # ",R I R["?" W ! DO  W ! Q
 . . W !?4,"Select a job/process number from the list of jobs in"
 . . W !?4,"lock table display."
 . I "^Qq"[$E(R_"^") S job="" Q
 . I R'?1.N,+R'=R W *7," that is not a valid process #" Q
 . S job=R ;a valid process#
 I job="" Q  ;done!
 ;
 S CNT=+##Class(SYS.Lock).DeleteAllLocks(job)
 W !,CNT_" lock"_$E("s",CNT'=1)_" deleted.",!
 G DJOB ;ask another one
DELSYS ; delete all entries for one system
 i '$SYSTEM.Security.Check("%Admin_Operate","USE") w !,"Operation requires %Admin_Operate:Use privilege" q
 N sys,CNT,PROMPT,R,sys,name
DSYS K sys F  DO  Q:$D(sys)  ;loop until a system is selected (or quits)
 . R !,"Delete locks for System: ",R I R["?" DO HDELSYSQ Q
 . I "^Qq"[$E(R_"^") S sys="" Q  ;done
 . I R?1.N W *7,!?4,"'"_R_"' is not a system name.  Enter ? for help." Q
 . S N=##Class(SYS.Lock).ClientSysNameToSysNum(R)
 . I N<0 W *7,!?4,"'"_R_"' does not exist in the current tables.",! Q
 . S sys=N
 I sys="" Q  ;no system selected
 ;
 S name=##Class(SYS.Lock).ClientSysNumToSysName(sys) S:name="" name=sys
 S PROMPT="Delete all locks for system '"_name_"'"
 S:R'=name PROMPT=PROMPT_" ( = '"_R_"')"
 I $$YN(PROMPT,"N")'="Y" G DSYS
 ;
 S CNT=##Class(SYS.Lock).DeleteAllLocks("C"_sys)
 W !,CNT_" lock"_$E("s",CNT'=1)_" deleted.",!
 G DSYS
DDPDEL QUIT   ; Delete all DDP locks in all clustered DB's - NOT SUPPORTED
HELP ;
 W !,"<RETURN> or ""S"" to show another screenful of items"
 W !,"""R"" to Restart display"
 W !,"""Q"" or ""^"" to quit"
 W !,"""H"" or ""?"" for help (this text)"
 I '$G(ViewOnly) Do
 . W !,"""D"" or ""1"" to delete one lock"
 . W !,"""J"" to delete ALL of one Process' locks"
 . W !,"""C"" to delete ALL of one SYSTEM's (Computer's) locks"
 W !!,"In display:"
 W !,"  X#   Lock count of exclusive lock"
 W !,"  S#   Lock count of share lock"
 W !,"  W#   Number of processes are waiting for this lock"
 W !!,"In Flg field:"
 W !,"  *    outgoing (client) lock to another system; may be pending"
 W !,"  L    Lost lock due to lock reset condition"
 W !,"  Z    Lock granted by ZA command. The ZA and ZD commands are obsolete,"
 W !,"       though the network daemons still grant the locks for remote client"
 W !,"       with the ZA lock mode internally."
 W !,"  P    Lock Pending, waiting for server to grant the lock"
 W !,"  D    Delock Pending, waiting for server to release the lock"
 Q
HDELSYSQ ;
 W !
 W !?4,"To delete incoming locks held on this system ("
 W ##Class(SYS.Lock).ClientSysNumToSysName(0),") by a remote system,"
 W !?4,"enter the name of that system (as it appears in the "
 W "Owner column)."
 W !!?4,"To delete all locks held by processes on THIS system,"
 W " enter:   ",##Class(SYS.Lock).ClientSysNumToSysName(0)
 W !
 Q 
YN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YN"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"yn","YN") I "^YN"'[R W "  enter Yes or No, please"
 S POP=(R="^") W $E($S(R="N":"No",R="Y":"Yes",1:""),$L(X)+1,3) Q R

MIRROR^INT^1^67214,47330
MIRROR ;GUI user interface and STU initialization code for mirroring, ;$Change: 7440104 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ; Revision: $Id: //iris/2024.1.3/databases/sys/rtn/sysconfig/mirror.mac#1 $
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/_syMirror.inc#1 $ ($Change: 7440104 $) */
        /* Initializing is the state a member has at startup until it
           gets to wait^MIRRORMGR for the 1st time. At that point it has 
           either become the backup or primary or we set the role to null
           to indicate that it is up and running as opposed to still getting
           started */
				    /* Arbiter failover rules are in effect */
				    /* Agent contact is required */
					/* IsOtherNodeDown^ZMIRROR */
				/* The client supports the arbiter */
			 	/* This system is connected to the arbiter */
		  		/* The other failover member is connected to the arbiter */
		  		/* Either the QOSTimeout changed or the arbiter address changed.
		  		   we should look up the current values and use them */
				/* Arbiter job shoud close the connection and exit. The
				   retry routine can restart the arbiter if conditions
				   warrent. Generally used with clearing ArbiterSupported
				   when the backup is removed or demoted. Cleared when
				   the arbiter exits (eg. its a one time flag). */
 do refreshLoop()
 quit
refreshLoop() PUBLIC {
 do {
	 if $SYSTEM.Mirror.GetInfo()["NOTINIT"&&('##class(Config.MirrorMember).isAsyncMember()) {
	    s refresh=$$NotMemberMENU()
	 } else {
	 	s refresh=$$MENU()
	 }
 } while (refresh)
 q
}
NotMemberMENU() PUBLIC { 
 s $zt="ERROR"
 s List(1)="List mirrored databases"
 s List(2)="Remove one or more mirrored databases"
 ; List(3)="Remove mirror configuration"
 s cls=##Class(Config.MirrorMember).Open()
 if cls.SystemName="" {
	 s HasMirrorConfig=0
 } else {
	 s HasMirrorConfig=1
	 s isAsyncMember=cls.isAsyncMember()
 	 s List(3)="Remove mirror configuration"
 }
 s listnum=HasMirrorConfig+2
 if ##class(SYS.MirrorConfiguration).EnableMirrorMenu(1) {
	 s List($i(listnum))="Create a Mirror"
	 s ListRtn(listnum)=4
 }
 if ##class(SYS.MirrorConfiguration).EnableMirrorMenu(2) {
	 s List($i(listnum))="Join Mirror as Failover Member"
	 s ListRtn(listnum)=5
 }
 if ##class(SYS.MirrorConfiguration).EnableMirrorMenu(4) {
	 s List($i(listnum))="Join Mirror as Async Member"
	 s ListRtn(listnum)=6
 }
 if '$$IsMirrorServiceEnabled^MIRRORCTL() {
	 s List($i(listnum))="Enable Mirror Service"
	 s ListRtn(listnum)=7
 }
 s cls=""
 ;
 if 'HasMirrorConfig {
    w !,"This instance is not initialized as a mirror member"
 } else {
	w !,"This instance is configured as "
	if isAsyncMember {
		w "an async member"
	} else {
		w " a failover member"
	}
	w " but is not currently"
	w !,?5,"initialized as a mirror member."
 }
 f  {
 	s Value=""
	s Status=##class(%Library.Prompt).GetMenu("Option?",.Value,.List,,8+128+4)
 	i (+Status=0)||(Status=2)||(Value="") s Status=0 q
 	i Value=1 d DBList(),pause() Continue
 	i Value=2 d DBRemoveMany(),pause() Continue
 	i Value=3&&('$d(ListRtn(Value))) {
	 	d RemoveMirrorConfig(),pause()
	 	s Status=1 quit 
 	}
 	s Value=$G(ListRtn(Value))
 	i Value=4 d SetupMirror(0),pause() s Status=1 quit
 	i Value=5 d SetupMirror(1),pause() s Status=1 quit
 	i Value=6 d SetupMirror(2),pause() s Status=1 quit
 	i Value=7 {
	 	r !,"Are you sure you want to enable Mirror Service <Y>? ",resp
	 	if '("Nn"[$E(resp_"X")) {
		 	if '##Class(Security.Services).Exists("%Service_Mirror",.Service,.st) d $SYSTEM.Status.DisplayError(st) continue
		 	s Service.Enabled=1
		 	s st=Service.%Save()
		 	i '(''st) {
			 	d $SYSTEM.Status.DisplayError(st)
			} else {
				w !,"%Service_Mirror is enabled."
			}
			s Service=""
	 	}
	 	d pause() s Status=1 quit
 	}
 }
 q Status
ERROR s $zt=""
 i $ze["<INTERRUPT>" q 0
 ztrap $ze
}
EMSClient()	PRIVATE {
	Q 0
}
EMSEditText()	PRIVATE {
	i 0 q " (restricted)"
	q ""
}
MENU() PUBLIC { 
 s $zt="ERROR"
  if $D(^SYS("MIRRORSET",":LocalValidationFailure")) {
      do ProcessValidationFailure()
	  quit 0  ;exit ^MIRROR
  }
  if $SYSTEM.Mirror.GetInfo()["PRIMARY" {
	 do getTransactionStatus^JRNROLL(.active,.pending)
	 if active || pending {
		 w !,"Transaction rollback is active or pending"
		 r !,"Do you want to run Manage^JRNROLL? <Y> ",resp
		 if "Nn"'[$E(resp_"X") {
			 do Manage^JRNROLL()
			 quit 0
		 }
	 }
 }
  if (($SYSTEM.Mirror.GetInfo()["PRIMARY") &&
	($SYSTEM.Mirror.FailoverRule()=1) &&
	(+$P($SYSTEM.Mirror.GetInfo(2),",",12)=1)) {
	w !,"This member is the primary and is in a trouble state while in Arbiter" 
	w !,"Controlled failover mode.  This means that both the connection to the arbiter"
	w !,"and the other failover member were lost while the other member was an active"
	w !,"backup.  If the other member's connection to the arbiter remained up, it will"
	w !,"have tried to become the primary, and if another condition prevented it from"
	w !,"becoming primary, it may still be retrying."
	w !
	w !,"If you can re-establish the network to the other failover member the problem"
	w !,"should resolve automatically in about a minute.  Otherwise, you can force"
	w !,"this node to resume as primary if you do ALL of the following:"
	w !," - Shut down the other failover member or confirm that it is already down"
	w !," - Confirm that the other failover member did not become primary"
	w !," - Confirm that, while trying to become primary, the other member did not"
	w !,"   create a mirror journal file later than #"_$P($SYSTEM.Mirror.GetInfo(2),",",1)_","
	w !,"     ",$ZU(78,3)
	w !,"Forcing this node to continue without all of the above may result in both"
	w !,"members running as primary and/or a member that requires being rebuilt."
	w !
	for {
		w !,"Has the other member become primary or created a mirror journal later than"
		w !,"the one specified above? "
		r resp
		if "YyNn"[$E(resp_"X") { quit } ; break on valid response
		w !,"You must answer yes or no."
	}
	if "Nn"[$E(resp_"X") {
		r !,"Do you want to force this member to resume as the primary? <No> ",resp
		if "Yy"[$E(resp_"X") {
			r !,"Are you sure that all of the conditions above are satisfied? <No> ",resp
			if "Yy"'[$E(resp_"X") {
				w !!,"Please verify the state of the other member before continuing."
			} else {
				d $zu(9,"","Operator requested primary switch to agent controlled mode",0,0  /* Informational message */)
				if (($SYSTEM.Mirror.FailoverRule()=1) &&
				    (+$P($SYSTEM.Mirror.GetInfo(2),",",12)=1)) {
					do $SYSTEM.Mirror.FailoverRule(2)
					w !!,"Switched to agent contact required mode, primary should resume."
				} else {
					w !!,"The primary is no longer in the trouble state"
				}
			}
		}
	} else {
		w !!,"If the other member became primary or created a later mirror journal file then"
		w !,"this member should be shut down."
		r !,"Do you want to force this instance down? ",resp
		if "Yy"[$E(resp_"X") {
			w !!,"Shutting down"
			d $zu(9,"","Operator requested shutdown of frozen primary",0,0  /* Informational message */)
			try {
			   s mirname=##class(Config.Mirrors).GetMirrorName()
			   if $G(^SYS("MIRRORSET",mirname,"VirtualAddress"))'="" {
				   s rc=$$DeleteVirtualAddress^MIRRORMGR(mirname)
			   }
		       s info=$G(^SYS("MIRRORSET",mirname,"Member",0))
			   s rc=$$ForceNodeDown^MIRRORCTL(mirname,0)
			   h 10  ;if we're still running after a few seconds, something went wrong
			   w !,"Force may have failed. Check console log for details"
			} catch {
			   w !,"Caught error forcing ourself down: ",$ZE
			}
			halt
		}
    } 
	w !
 }
 if ##class(SYS.MirrorConfiguration).EnableMirrorMenu(3) {
	 s mirname=##class(Config.Mirrors).GetMirrorName()
	 if mirname'="" {
		 s rs=##class(%Library.ResultSet).%New("SYS.Mirror:PendingNewMembers")
		 d rs.Execute()
		 while rs.Next() {
			s name=rs.Data("Name")
			s mlist($i(mlist)) = rs.Data("Name")_" ("_rs.Data("MemberTypeDisplay")_")"
		}
		if +$g(mlist)'=0 {
			s authorizetext=$s($G(^SYS("MIRRORSET",mirname,"UseSSL")):"authorize",1:"add")
			w !,"The following member"_$s(mlist>1:"s are ",1:" is ")_"pending to be ",authorizetext," to join this mirror."
			w !,"Please go to 'Mirror Configuration' to ",authorizetext," the expected members"
			w !,"or reject the unexpected members.",!
			f i=1:1:mlist w !,?5,mlist(i)
		}
	 }
 }
 if ##class(SYS.MirrorConfiguration).EnableMirrorMenu(8) {
	 k mlist
	 s IsPrimary=$SYSTEM.Mirror.IsPrimary(),total=0
	 s mirname=##class(Config.Mirrors).GetMirrorName()
	 while mirname'="" {
		 s rs=##class(%Library.ResultSet).%New("SYS.Mirror:PendingDNUpdates")
		 d rs.Execute(mirname)
		 s mlist=0
		 while rs.Next() {
			 s name=rs.Data("Name")
			 s mlist(mirname,$i(mlist)) = rs.Data("Name")_" ("_rs.Data("MemberType")_")"_$s('IsPrimary:" ("_rs.Data("SSLComputerName")_")",1:"")
			 s guid(mirname,rs.Data("Name"))=rs.Data("GUID")
			 s toatl=$i(total)
		 }
		 s mirname=##class(Config.Mirrors).GetMirrorName(mirname)
	 }
	 if total'=0 {
		 w !,"The following member"_$s(total>1:"s are ",1:" is ")_"pending to be authorized to update DN names."
		 if IsPrimary {
			 w !,"Please go to 'Mirror Configuration' to authorize the expected members' DN"
			 w !,"or reject the unexpected members' DN.",!
		 } else {
			 w !
		 }
		 s mirname=$o(mlist(""))
		 while mirname'="" {
			 if 'IsPrimary {
				 d PromptForDNUpdates(mirname,.mlist,.guid)
			 } else {
				 w !,"Mirror set name: "_mirname
				 s idx=$o(mlist(mirname,""),1,info)
				 while idx'="" {
					 w !,?5,info
					 s idx=$o(mlist(mirname,idx),1,info)
				 }
			 }
			 s mirname=$o(mlist(mirname))
		 }
	 }
 }
 s List(1)="Mirror Status"
 s List(2)="Mirror Management"
 s List(3)="Mirror Configuration"
 f  {
 	s Value=""
	s Status=##class(%Library.Prompt).GetMenu("Option?",.Value,.List,,8+128+4)
 	i (+Status=0)||(Status=2)||(Value="") s Status=0 q
 	i Value=1 d MIRRORSTATUS() Continue
 	i Value=2 d MIRRORMANAGE() Continue
 	i Value=3 {
	 	i '$$EMSClient s Status=$$MIRRORCONFIG() q:Status  Continue
	 	e  d DisplayConfig() w !,"Managed by Enterprise Manager.",! d pause() continue
 	}
 }
 q Status
ERROR s $zt=""
 i $ze["<INTERRUPT>" q 0
 ztrap $ze
}
MIRRORSTATUS() {
 s $zt="ERROR"
 s List(1)="List mirrored databases"
 s List(2)="Display mirror status of this node"
 s List(3)="Display journal file info"
 s List(4)="Status Monitor"
 f  {
 	s Value=""
	s Status=##class(%Library.Prompt).GetMenu("Option?",.Value,.List,,8+128+4)
 	i (+Status=0)||(Status=2)||(Value="") q
 	i Value=1 d DBList(),pause() Continue
 	i Value=2 d LocalMirrorStatus(),pause() continue
 	i Value=3 d JrnDisplayx(),pause() Continue
 	i Value=4 d Monitor() Continue
 }
 q Status
ERROR s $zt=""
 i $ze["<INTERRUPT>" q 0
 ztrap $ze
}
MIRRORMANAGE() {
 s $zt="ERROR"
 s List(1)="Add mirrored database(s)"
 s List(2)="Remove mirrored database(s)"
 s List(3)="Activate or Catchup mirrored database(s)"
 s List(4)="Change No Failover State"
 s List(5)="Try to make this the primary"
 s List(6)="Start Mirror On This Member"
 s List(7)="Stop Mirror On This Member"
 s List(8)="Modify Database Size Field(s)"
 s List(9)="Force this node to become the primary"
 s List(10)="Promote Async DR Member to Failover Member"_$$EMSEditText
 s List(11)="Demote Backup Member to Async DR Member"_$$EMSEditText
 s List(12)="Mark an inactive database as caught up"
 Set isReporting = $System.Mirror.IsAsyncMember()
 s List(13)="Manage mirror dejournaling on async member"
 if 'isReporting s List(13)=List(13)_" (disabled)"
 s List(14)="Pause dejournaling for database(s)"
 d updateList(.List)
 f  {
 	s Value=""
	s Status=##class(%Library.Prompt).GetMenu("Option?",.Value,.List,,8+128+4)
 	i (+Status=0)||(Status=2)||(Value="") q
 	i Value=1 d DBAdd(),pause() Continue
 	i Value=2 d DBRemove(1),pause() Continue
 	i Value=3 d DBActivate(),pause() Continue
 	i Value=4 d ManageNoFailover(),pause() Continue
 	i Value=5 d RequestPrimary(),pause() Continue
 	i Value=6 d ActivateMirror(),pause() Continue
 	i Value=7 d DeactivateMirror(),pause() Continue
 	i Value=8 d ModifyDBSize(),pause() Continue
 	i Value=9 d ForcePrimary(),pause() Continue
 	i Value=10,'$$EMSClient d Promote(),updateList(.List),pause() Continue
 	i Value=11,'$$EMSClient d Demote(),updateList(.List),pause() Continue
 	i Value=12 do MarkAsCaughtUp(),pause() continue
	i isReporting,Value=13 d ManageDejournaling(),pause() continue
	i Value=14 do DBPause(),pause() Continue
	i $$DemotePartnerOK(),Value=15 d DemotePartner(),updateList(.List),pause() continue
}
 q Status
ERROR s $zt=""
 i $ze["<INTERRUPT>" q 0
 ztrap $ze
}
MIRRORCONFIG() {
 s $zt="ERROR"
 s isMirror=($SYSTEM.Mirror.GetInfo()[",DEFINED,")
 if 'isMirror {
	s mm=##class(Config.MirrorMember).Open()
	s ourname=mm.SystemName
    Set isMirror=(ourname'="")
    k mm
 }
 if 'isMirror {
	w !,"System is not configured as a mirror member"
	quit 0
 }
RedisplayMemu ;
 Set isShadow = ##class(Config.MirrorMember).isAsyncMember()
 if isShadow {
 	s List(1)="Stop tracking a mirror"
 	s List(2)="Remove Mirror Configuration"
 	s List(3)="Display Mirror Configuration"
 	s List(4)="Manage Async Journal File Retention"
 	if ##class(Config.MirrorMember).IsDRMember() {
	 	s List(4)=List(4)_" (disabled)"
 	}
 	s List(5)="Manage Async Mirror Member Type"
 	s List(6)="Clear FailoverDB Flag of Mirrored Databases"
 	s List(7)="Display Mirrored Databases"
 	s List(8)="Modify Network Address"
 	s List(9)="Edit SSL Configuration"
	s List(10)="Join Another Mirror as Async Member"
 	if '##class(Config.MirrorMember).AllowNewMirrorSet() {
	 	s List(10)=List(10)_" (disabled)"  ;JO2553
 	}
 	s List(11)="Authorize Pending DN Updates"_$s('##class(SYS.MirrorConfiguration).EnableMirrorMenu(8):" (disabled)",1:"")
 	s List(12)="Verify Mirror SSL certificates"_$s('##class(SYS.MirrorConfiguration).EnableMirrorMenu(9):" (disabled)",1:"")
 	s List(13)="Change Dejournal Filter Setting"_$s('$SYSTEM.Mirror.AsyncMemberType():" (disabled)",1:"")
} else {
	s List(1)="Edit VIP Address"
 	s List(2)="Remove Other Mirror Member"
 	s List(3)="Remove This Failover Member"
 	s List(4)="Display Mirror Configuration"
 	s List(5)="Adjust QOS Timeout parameter"
	s List(6)="Modify Network Addresses"
	s List(7)="Refresh other failover member's data via agent"
 	s List(8)="n/a"
 	s mirname=##class(Config.Mirrors).GetMirrorName()
 	if mirname=""||$G(^SYS("MIRRORSET",mirname,"UseSSL")) {
	 	s authorizetext="Authorize",membertext=""
 	} else {
	 	s authorizetext="Add",membertext="Failover "
 	}
 	s List(9)=authorizetext_"/Reject Pending New "_membertext_"Members"_$s('##class(SYS.MirrorConfiguration).EnableMirrorMenu(3):" (disabled)",1:"")
 	s List(10)="Authorize"_$s($SYSTEM.Mirror.IsPrimary():"/Reject",1:"")_" Pending DN Updates"_$s('##class(SYS.MirrorConfiguration).EnableMirrorMenu(8):" (disabled)",1:"")
	s List(11)="Edit SSL Settings"
	s List(12)="Manage arbiter address"
	 if '$SYSTEM.Mirror.IsPrimary() s List(12)=List(12)_" (n/a)"
 	s List(14)="Add Async Member Not In Pending List"_$s('$SYSTEM.Mirror.IsPrimary():" (disabled)",1:"")
 	s List(13)="Verify Mirror SSL certificates"_$s('##class(SYS.MirrorConfiguration).EnableMirrorMenu(9):" (disabled)",1:"")
	s List(15)="Manage compression modes"
	if '$SYSTEM.Mirror.IsPrimary() s List(15)=List(15)_" (n/a)"
	s List(16)="Manage 'Allow Parallel Dejournaling'"
	if '$SYSTEM.Mirror.IsPrimary() s List(16)=List(16)_" (n/a)"
 }
 f  {
 	s Value=""
	s Status=##class(%Library.Prompt).GetMenu("Option?",.Value,.List,,8+128+4)
 	i (+Status=0)||(Status=2)||(Value="") s Status=0 q
	if isShadow {
		i Value=1 d RemoveAsyncMemberSource(),pause() s Status=2 quit
		i Value=2 d RemoveMirrorConfig(),pause() s Status=1 quit
		i Value=3 d DisplayConfig(),pause() continue
		i Value=4 {
		 	if ##class(Config.MirrorMember).IsDRMember() w "  disabled " continue
			d ManageAsyncJournalPurge(),pause() continue
	 	}
		i Value=5 d ManageAsyncMemberType(),pause() s Status=2 quit
		i Value=6 d ClearFailoverDBFlag(),pause() continue
		i Value=7 d DisplayMirroredDB(),pause() continue
		i Value=8 d EditNetworkAddresses(),pause() continue
		i Value=9 {
			 d EditSSLSettings(1),pause() 
			 continue
		}
		i Value=10 {
			if '##class(Config.MirrorMember).AllowNewMirrorSet() w "  disabled " continue
			d SetupMirror(2),pause() s Status=2 quit
		}
		i Value=11 {
			if '##class(SYS.MirrorConfiguration).EnableMirrorMenu(8) w "  disabled " continue
			d PendingDNUpdates(),pause() continue
		}
		i Value=12 {
			if '##class(SYS.MirrorConfiguration).EnableMirrorMenu(9) w "  disabled " continue
			d VerifySSLCertificates(1),pause() continue
		}
		i Value=13 {
			if '$SYSTEM.Mirror.AsyncMemberType() w "  disabled " continue
			d DejournalFilter(),pause() continue
		}
	} else {
		i Value=1 d EditVIP(),pause() Continue
		i Value=2 d RemoveMirrorMember(),pause() continue
		i Value=3 d RemoveMirrorConfig(),pause() s Status=1 quit
		i Value=4 d DisplayConfig(),pause() continue
		i Value=5 d AdjustQOSTimeout(),pause() continue
		i Value=6 d EditNetworkAddresses(),pause() continue
	    i Value=7 d UpdateOtherFailoverNodeInfo(),pause() continue
		i Value=8 w !,"Option unavailable" d pause() continue
		i Value=9 {
			if '##class(SYS.MirrorConfiguration).EnableMirrorMenu(3) w "  disabled " continue
			d AddNewMember(),pause() continue
		}
		i Value=10 {
			if '##class(SYS.MirrorConfiguration).EnableMirrorMenu(8) w "  disabled " continue
			d PendingDNUpdates(),pause() continue
		}
		If Value=11 {
			 d EditSSLSettings(0),pause() 
			 s Status=2 
			 quit
		}
		if Value=12 do ConfigureArbiter(),pause() continue
		i Value=14 {
			if '$SYSTEM.Mirror.IsPrimary() w "  disabled " continue
			d SetupMirror(4),pause() continue
		}
		i Value=13 {
			if '##class(SYS.MirrorConfiguration).EnableMirrorMenu(9) w "  disabled " continue
			d VerifySSLCertificates(0),pause() continue
		}
		if Value=15 do ConfigureCompressMode(),pause() continue
		if Value=16 do ConfigureMultiDejournalMode(),pause() continue
	}
 }
 if Status=2 {
	 if $SYSTEM.Mirror.GetInfo()[",NOTINIT," quit 1
	 k List goto RedisplayMemu
 }
 q Status
ERROR s $zt=""
 i $ze["<INTERRUPT>" q 0
 ztrap $ze
}
EditSSLSettings(isAsync) {
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
	; Opens it and returns SSLCOnfig if it exists
	s exists=##class(Security.SSLConfigs).%ExistsId("%MirrorServer")
	if exists {
		r !,"Edit Mirror SSL Configuration? <Y> ",resp
	} else {
		r !,"Create Mirror SSL Configuration? <Y> ",resp
	}
	if "Nn"'[$E(resp_"X") {
		do CreateEditMirrorSSL^SECURITY2(exists)
	}
	if isAsync quit  ;this isn't a failover member, it can't edit UseSSL
	;
	; Now see if they can edit the Mirror's USE SSL option
	if $SYSTEM.Mirror.IsPrimary() {
		s mirname=##class(Config.Mirrors).GetMirrorName()
		if mirname'="" {
			s JRNEncrypted=##class(%SYS.Journal.System).IsJournalEncryptionEnabled(3)
			s MirrorsObj=##class(Config.Mirrors).Open(mirname)
			if '$isobject(MirrorsObj) w !!,"Mirror set '"_mirname_"' does not exist." Quit
			if JRNEncrypted&&MirrorsObj.UseSSL {
				w !!,"Mirror wide 'Use SSL' Setting can not be changed when it is"
				w !,"enabled while journal encryption is also enabled."
				Quit  ;we're done
			}
			s MirrorsObj=""
		} else {
			w !!,"Failed to find mirror set name on the primary."
			Quit  ;we're done
		}
	} else {
		w !!,"Mirror wide 'Use SSL' Setting can only be changed on the primary."
		Quit  ;we're done
	}
	s mirname=##class(Config.Mirrors).GetMirrorName()
	if mirname="" w !,"Failed to locate mirror name in Config.Mirrors" quit
	s MirrorsObj=##class(Config.Mirrors).Open(mirname)
	if '$IsObject(MirrorsObj) w !,"failed to open Config.Mirrors(",mirname,")" quit
	Set sslc=##class(Security.SSLConfigs).%OpenId("%MirrorClient",,.status)
	Set ssls=##class(Security.SSLConfigs).%OpenId("%MirrorServer",,.status)
	s sslconfigured=$isobject(sslc)||$isobject(ssls)
RetrySSL ;
	w !!,"Do you want to use SSL for the Mirror? <",$s(MirrorsObj.UseSSL:"Y",1:"N"),"> " r resp
	if resp="" quit
	s resp=$zcvt($E(resp),"U")
	s resp=$case(resp,"Y":1,"N":0,:-1)
	if resp=-1 w !,"   Enter 'Y' or 'N'." goto RetrySSL
	if ''MirrorsObj.UseSSL=resp q
	if resp {
		if 'sslconfigured {
			w !,"Mirror SSL is not set up, setting up the mirror SSL now."
			if '$$SetupSSL() Goto RetrySSL
		} else {
			if $isobject(sslc)&&'sslc.Enabled s sslc.Enabled=1 s rc=sslc.%Save()
			if $isobject(ssls)&&'ssls.Enabled s ssls.Enabled=1 s rc=ssls.%Save()
			if '$isobject(sslc) w !,"%MirrorClient SSL configuration does not exist, could not use SSL for mirror." G RetrySSL
			if '$isobject(ssls) w !,"%MirrorServer SSL configuration does not exist, could not use SSL for mirror." G RetrySSL
        }
	    s clientcn=$$GetSSLDNField^MIRRORCTL("client")
	    if '$LG(clientcn) {
		    w !,"Error getting SSL DN name in %MirrorClient: ",$LG(clientcn,2)
		    goto RetrySSL
	    }
	    s servercn=$$GetSSLDNField^MIRRORCTL("server")
	    if '$LG(servercn) {
		    w !,"Error getting SSL DN name in %MirrorServer: ",$LG(servercn,2)
		    goto RetrySSL
	    }
	    s clientcn=$LG(clientcn,2)
	    s servercn=$LG(servercn,2)
	    if servercn'=clientcn {
		    w !,"SSL config error: Names in Server and client configurations are different"
		    w !,"   server: ",servercn
		    w !,"   client: ",client
		    goto RetrySSL
	    }
	}
	s MirrorsObj.UseSSL=resp
	s rc=MirrorsObj.%Save()
	if ('rc) {
		w !,"Failed to save the UseSSL change, error: ",$SYSTEM.Status.GetErrorText(rc)
	} else {
		w !,"UseSSL change is saved."
	}
}
ConfigureArbiter() {
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
	s state=$SYSTEM.Mirror.GetInfo()
	if state'[",PRIMARY," {
		w !,"The arbiter address can only be managed on the primary mirror member."
		if state[",BACKUP," {
			s primary=$$getPrimary()
			if primary'="" w !,"The primary is ",primary
		} else {
			if state'[",DEFINED," {
				w !,"This node is not configured as a mirror member"
			} else {
				w !,"The mirror has not elected a primary member yet"
			}
		}
		quit
	}
	s mirname=##class(Config.Mirrors).GetMirrorName()
	if mirname="" w !,"Failed to locate mirror name in Config.Mirrors" quit
	s mir=##class(Config.Mirrors).Open(mirname)
	if '$IsObject(mir) w !,"failed to open Config.Mirrors(",mirname,")" quit
	s arbiteraddr=$P(mir.ArbiterNode,"^",1)
	if arbiteraddr="" {
		s oldaddr="",oldport="2188"  ;port defaults to the agent port
		w !,"There is no arbiter address configured."
		r !,"Do you want to configure one? <N> ",resp
	} else {
		s oldaddr=$P(arbiteraddr,"|",1)
		s oldport=$P(arbiteraddr,"|",2)
		w !,"The current arbiter address is ",oldaddr," on port #",oldport
		r !,"Do you want to change this? <N> ",resp
	}
	if "Yy"'[$E(resp_"X") quit
	r !,"Enter new address for the arbiter: ",addr
	if addr="" {
		if oldaddr="" w !,"Aborted" quit 
		r !,"Do you want to remove the arbiter address? <N> ",resp
		if "Yy"[$E(resp_"X") {
			s mir.ArbiterNode=""
			s rc=mir.%Save()
			i ('rc) {
				k err
				d DecomposeStatus^%apiOBJ(rc,.err,"-d") 
				w !,"Failed to save change to remove arbiter address: ",err(1)
			} else {
				w !,"Arbiter address removed."
			}
		}
		q
	}
	while (addr'="") {
		s rc=##class(Config.Mirrors).ValidateArbiterAddress(addr)
		q:(''rc)
		w !,$SYSTEM.Status.GetErrorText(rc)
		r !,"Enter new address for the arbiter: ",addr
	}
	if addr="" {  ;A null address now means stop
		w !,"Aborted"
		quit
	}
	w !,"Enter new port for the arbiter: <",oldport,"> "
	r port
	if port="" {
		s port=oldport
	}
	w !,"Confirm change of arbiter address to ",addr," on port #",port," <No> "
	r resp
	if "Yy"'[$E(resp_"X") {
		w !,"Aborted"
		quit
	}
	s mir.ArbiterNode=addr_"|"_port
	s rc=mir.%Save()
	i ('rc) {
		k err
		d DecomposeStatus^%apiOBJ(rc,.err,"-d") 
		w !,"Failed to save change to update arbiter address: ",err(1)
	} else {
		w !,"Arbiter address updated."
	}
}
ConfigureCompressMode() {
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
	s state=$SYSTEM.Mirror.GetInfo()
	if state'[",PRIMARY," {
		w !,"The compression mode can only be managed on the primary mirror member."
		if state[",BACKUP," {
			s primary=$$getPrimary()
			if primary'="" w !,"The primary is ",primary
		} else {
			if state'[",DEFINED," {
				w !,"This node is not configured as a mirror member"
			} else {
				w !,"The mirror has not elected a primary member yet"
			}
		}
		quit
	}
	s mirname=##class(Config.Mirrors).GetMirrorName()
	if mirname="" w !,"Failed to locate mirror name in Config.Mirrors" quit
	s mir=##class(Config.Mirrors).Open(mirname)
	if '$IsObject(mir) w !,"failed to open Config.Mirrors(",mirname,")" quit
	s ModeToText(0)="System Selected"
	s ModeToText(2)="Compressed"
	s ModeToText(1)="Uncompressed"
	s TextToMode("System Selected")=0
	s TextToMode("Compressed")=2
	s TextToMode("Uncompressed")=1
	s (curFOmode,FOCmpMode)=mir.CompressionForFailoverMembers
	s (curASYNCmode,ASYNCmpMode)=mir.CompressionForAsyncMembers
	s TypeToText(0)="ZLIB"
	s TypeToText(1)="ZSTD"
	s TypeToText(2)="LZ4"
	s TextToType("ZLIB")=0
	s TextToType("ZSTD")=1
	s TextToType("LZ4")=2
	s (curFOtype,FOCmpType)=mir.CompressionTypeForFailoverMembers
	s (curASYNCtype,ASYNCmpType)=mir.CompressionTypeForAsyncMembers
again ;
	w !!,"Current compression mode settings are:",!
	w !,"1) Compression mode for Failover members : ",ModeToText(curFOmode)
	if curFOmode=2 w ", Compression type : ",TypeToText(curFOtype)
	w !,"2) Compression mode for Async members    : ",ModeToText(curASYNCmode)
	if curASYNCmode=2 w ", Compression type : ",TypeToText(curASYNCtype)
	r !,"Select item to be changed? ",resp
	if resp=""||(resp="^") {
		s count=((curFOmode'=FOCmpMode)||(curFOtype'=FOCmpType))+((curASYNCmode'=ASYNCmpMode)||(curASYNCtype'=ASYNCmpType))
		if count {
			w !!,"The following item",$s(count>1:"s are ",1:" is "),"changed:"
			if curFOmode'=FOCmpMode||(curFOtype'=FOCmpType) {
				s srcText=ModeToText(FOCmpMode)_$s(FOCmpMode=2:"(Type:"_TypeToText(FOCmpType)_")",1:"")
				s destText=ModeToText(curFOmode)_$s(curFOmode=2:"(Type:"_TypeToText(curFOtype)_")",1:"")
				w !,"Compression mode for Failover members : ",srcText," -> ",destText
			}
			if curASYNCmode'=ASYNCmpMode||(curASYNCtype'=ASYNCmpType) {
				s srcText=ModeToText(ASYNCmpMode)_$s(ASYNCmpMode=2:"(Type:"_TypeToText(ASYNCmpType)_")",1:"")
				s destText=ModeToText(curASYNCmode)_$s(curASYNCmode=2:"(Type:"_TypeToText(curASYNCtype)_")",1:"")
				w !,"Compression mode for Async members    : ",srcText," -> ",destText
			}
			w !,"Do you want to save the change",$s(count>1:"s",1:"")," before exiting, <Y>? "
			r resp
			if "Yy"[$E(resp_"Y") {
				s mir.CompressionForFailoverMembers = curFOmode
				s mir.CompressionForAsyncMembers = curASYNCmode
				s mir.CompressionTypeForFailoverMembers = curFOtype
				s mir.CompressionTypeForAsyncMembers = curASYNCtype
				s rc=mir.%Save()
				i ('rc) {
					w !,"Failed to save change to update compression mode: ",$SYSTEM.Status.GetErrorText(rc)
				} else {
					w !,"Compression mode updated."
				}
			}
		}
		quit
	}
	if resp'=1&&(resp'=2) w "   invalid selection!!!" g again
	s curmode=$s(resp=1:curFOmode,1:curASYNCmode)
	s curtype=$s(resp=1:curFOtype,1:curASYNCtype)
nextmode ;
	w !!,"Please select one of the following compression modes for ",$s(resp=1:"Failover",1:"Async")," member."
	w !,"1) System Selected"
	w !,"2) Uncompressed"
	w !,"3) Compressed",$s(curmode=2:" (Type: "_TypeToText(curtype)_")",1:"")
	w !,"Select <",curmode+1,">? "
	r respx
	if respx="" g again
	if respx'=1,respx'=2,respx'=3 w " invalid selection!!!" goto nextmode
	if resp=1 {
		s (curmode,curFOmode) = respx - 1
	} else {
		s (curmode,curASYNCmode) = respx - 1
	}
	if curmode'=2 {
		if resp=1 {
			s curFOtype = 0
		} else {
			s curASYNCtype = 0
		}
		g again
	}
nexttype
	w !!,"Please select one of the following compression type for ",$s(resp=1:"Failover",1:"Async")," member."
	w !,"1) ZLIB"
	w !,"2) ZSTD"
	w !,"3) LZ4"
	w !,"Select <",curtype+1,">? "
	r respx
	if respx="" g again
	if respx'=1,respx'=2,respx'=3 w " invalid selection!!!" goto nexttype
	if resp=1 {
		s curFOtype = respx - 1
	} else {
		s curASYNCtype = respx - 1
	}
	g again
}
ConfigureMultiDejournalMode() {
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
	s state=$SYSTEM.Mirror.GetInfo()
	if state'[",PRIMARY," {
		w !,"The 'Parallel Dejournaling' mode can only be managed on the primary mirror member."
		if state[",BACKUP," {
			s primary=$$getPrimary()
			if primary'="" w !,"The primary is ",primary
		} else {
			if state'[",DEFINED," {
				w !,"This node is not configured as a mirror member"
			} else {
				w !,"The mirror has not elected a primary member yet"
			}
		}
		quit
	}
	s mirname=##class(Config.Mirrors).GetMirrorName()
	if mirname="" w !,"Failed to locate mirror name in Config.Mirrors" quit
	s mir=##class(Config.Mirrors).Open(mirname)
	if '$IsObject(mir) w !,"failed to open Config.Mirrors(",mirname,")" quit
	s ModeToText(0)="Failover Members and DR"
	s ModeToText(1)="Failover Members Only"
	s ModeToText(2)="All Members"
	s (curmode,DejrnMode)=mir.AllowParallelDejournaling
again ;
	w !!,"Current 'Allow Parallel Dejournaling' settings is: ",ModeToText(curmode)
	w !,"Please select one of the following modes."
	w !,"1) Failover Members and DR"
	w !,"2) Failover Members Only"
	w !,"3) All Members"
	w !,"Select <",curmode+1,">? "
	r respx
	if respx="" q
	if respx'=1,respx'=2,respx'=3 w " invalid selection!!!" goto again
	s newcurmode = respx - 1
	if newcurmode'=curmode {
		w !,"Are you sure you want to change 'Allow Parallel Dejournaling' to '",ModeToText(newcurmode),"' <Y>? "
		r resp
		if "Yy"[$E(resp_"Y") {
			s mir.AllowParallelDejournaling = newcurmode
			s rc=mir.%Save()
			i ('rc) {
				w !,"Failed to save change to update 'Allow Parallel Dejournaling': ",$SYSTEM.Status.GetErrorText(rc)
			} else {
				w !,"'Allow Parallel Dejournaling' is updated to '",ModeToText(newcurmode),"'."
			}
		}
	}
}
pause() {
	r !,"Press <enter> to return to the main menu...",resp
}
DBAdd() {
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
	s state=$SYSTEM.Mirror.GetInfo()
	if state'[",PRIMARY," {
	   w !,"Mirrored databases can only be added on the Primary mirror member."
  	   if state[",BACKUP," {
	      s primary=$$getPrimary()
          if primary'="" w !,"The primary is ",primary
	   } else {
	      if state'[",DEFINED," {
	         w !,"This node is not configured as a mirror member"
	      } else {
	         w !,"The mirror has not elected a primary member yet"
	      }
	   }
	   quit
	}
	; Mount all unmounted databases so they appear in the
	; list of choices from $$getDatabase()
	s dir=$$GetNextDatabaseByUCI^%SYS.CONFIG("")
	while dir'="" {
		s info=+$ZU(49,dir)
		if (info<0)!(info=$zu(40,0,41)) {
		   do $ZU(17,dir)
		   s info=+$ZU(49,dir)
		   if (info<0)!(info=$zu(40,0,41)) {
		      do $ZU(9,"","Mirror: "_"Failed to mount database: "_dir)
		   }
		}
		s dir=$$GetNextDatabaseByUCI^%SYS.CONFIG(dir)
	}
	s MustJournal=1
	s numdb=$$SelectDatabases(.AddDBList,.DBInfo,,.MustJournal,0)
	i 'numdb q
	i numdb>1 { ;multiple databases, which must be all journaled
		w !,"The following databases will be added to the mirror with their"
		w !,"mirror DB names generated from the configured dataset names:"
		s i=1 f  {
			s dbpath=$li(AddDBList,i)
			s mirdbname=$li(DBInfo(i),1)
			w !,dbpath," as ",mirdbname
			i $i(i)>numdb q
		}
		i $$YN("Continue","N")="N" {
			w !,"Aborted"
			q
		}
		s i=1 f  {
			s dbpath=$li(AddDBList,i)
			s mirdbname=$li(DBInfo(i),1)
			s rc=$SYSTEM.Mirror.DBAdd(dbpath,mirdbname)
			i rc w !,"Added ",dbpath," as ",mirdbname d ##Class(%SYS.Audit).WriteToAuditFile("%System","%System","ConfigurationChange",dbpath,"Create mirrored database "_mirdbname)
			e  w !,"Failed to add ",dbpath," because ",$p(rc,",",2,99)
			i $i(i)>numdb q
		}
		q
	}
	s dbpath=$li(AddDBList,1)
	s Obj=""
	i MustJournal<0 { ;meaning that journaling must be enabled
		w !,"Journaling is not currently enabled for this database. Adding the"
		w !,?5,"database to the mirror will enable journaling of all sets and kills."
		i $$YN("Continue","N")="N" q
		s Obj=##class(SYS.Database).%OpenId(dbpath,,.Status)
		i ('Status) {
			w ! d $SYSTEM.Status.DisplayError(Status) w !
			q
		}
		d Obj.EnableJournaling(1)
		s rc=Obj.%Save()
		i ('rc) {
			k err
			d DecomposeStatus^%apiOBJ(rc,.err,"-d") 
			w !,"Failed to enable journaling on ",dbpath,": ",err(1)
			q
		}
	}
	s $zt="Exit" ;to restore (disable) journaling state if necessary
	s dbname=$li(DBInfo(1),1),mirdbname=dbname
    s prompt="Enter mirror DB name for this database: "
 	f  {
 		s mirdbname=dbname
		s Status=##Class(%Library.Prompt).GetString(prompt,.mirdbname,0,62,,8)
		i (+Status=0)!(+Status=2)!(mirdbname="") zt "EXIT"
		; Uuppercase the database mirror name
		s mirdbname=$zconvert(mirdbname,"U")
		; Run it through the standard validation checks
		set rc=##class(SYS.MirrorConfiguration).IsMirrorDatabaseNameValid(mirdbname)
		if (''rc) quit  ;success
		w !,$System.Status.GetErrorText(rc)
		continue
	}
	s rc=$$CheckDBUniqueName(mirdbname)
	if '+rc {
		w !,$P(rc,",",2,99)
		quit
	}
	s rc=$SYSTEM.Mirror.DBAdd(dbpath,mirdbname)
	i rc w !,"Added ",dbpath," as ",mirdbname d ##Class(%SYS.Audit).WriteToAuditFile("%System","%System","ConfigurationChange",dbpath,"Create mirrored database "_mirdbname) q
	w !,"Failed to add ",dbpath," because ",$p(rc,",",2,99)
Exit ;
	s $zt="" i $ze'="",$ze'["ZEXIT" w !,$ze,!
	i MustJournal<0 {
		d Obj.DisableJournaling()
		d Obj.%Save()
	}
	q	
}	
CheckDBUniqueName(dbname) {
	; Takes a mirror database name and checks whether its
	; in use by any nodes in the mirror. 
	; Returns: 0,<text> = error or name is in use
	;          1 = name is not in use
	;
	s mirname=##class(Config.Mirrors).GetMirrorName()
	if mirname="" quit "0,Mirror name not found"
	; Uppercase the database mirror name
	s dbname=$zconvert(dbname,"U")
	s mirdbname=":mirror:"_mirname_":"_dbname
	s rc=$$CheckMirrorDBName^MIRRORCOMM(mirdbname)
	s status=$LG(rc)
	if status["ERR" {
		s msg="0,Failed to check duplicated """_dbname_""" err="_$LG(rc,2)
		goto done
	}
	if status="FOUND" {
		s dir=$LG(rc,2)  ;directory pagh
		s msg="0,"""_dbname_""" is already in use on this system by "_dir
		goto done
	}
	;
	s cnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
	for i=1:1:cnt {
	   s info=$G(^SYS("MIRRORSET",mirname,"Member",i),"")
	   if $L(info) {
	      s name=$lg(info,1)
          if +$lg(info,8)'=0 continue
	      s rc=$$CheckDBNameInUse^MIRRORCTL(mirname,i,mirdbname)
	      s status=$LG(rc)
	      if status="FOUND" {
		      s dir=$LG(rc,2)  ;directory pagh
		      s msg="0,"""_dbname_""" is already in use on "_name_" by "_dir
		      goto done
	      }
	      if status["ERR" {
		      s msg="0,Failed to get DB info for """_dbname_""" on "_name_" err="_$LG(rc,2)
		      goto done
	      }
	   }
	}
	quit 1
done ;
	quit msg
}
DBRemoveMany() {
	;called when we're not a mirror member to remove one or all
	; mirrored databases.
	;Remove all mirrored databases
	Kill List,ActiveList
	s Index=0
	s ActiveCnt=0
	Set rs=##class(%Library.ResultSet).%New("SYS.Database:List")
	if '$IsObject(rs) {
		w !,"Failed to generate list of currently mounted databases"
		quit
	}
	d rs.Execute()
	While (rs.Next()) {
		if +rs.Data("Mirrored") {
			s dir=rs.Data("Directory")
			s List($i(Index))=dir
			s dirobj=##class(SYS.Database).%OpenId(dir)
			if $IsObject(dirobj) && +dirobj.InActiveMirror {
				s ActiveCnt=ActiveCnt+1
				s ActiveList(Index)=1
			}
			s dirobj=""
		}
 	}
 	Kill rs
 	; ActiveCnt should be 0 because this entry point is only
 	; used on non-mirror members. Its just here in case we decide
 	; to extend this to active mirror members as well. On an active
 	; mirror member though, the SMP could be used to do this and
 	; its pretty easy to click through the databases to remove them.
 	; On non-mirror members, that SMP page isn't displayed.
	if 'Index {
	 	w !,"There are no mirrored databases to remove"
	 	quit
 	} else {
	 	if Index=1 {
		 	w !,"There is one mirrored database on this system"
		 	if ActiveCnt w !,"     and it is in the active mirror"
		 	s prompt="Remove it? <No> "
		 	s anslist="YyNn"
		 	s default="N"
	 	} else {
		 	w !,"There are ",Index," mirrored databases on this system"
		 	if ActiveCnt w !,"     and ",ActiveCnt," are active in the mirror"
		 	s prompt="Remove (O)ne mirrored database, (A)ll mirrored databases or (Q)uit? <quit> "
		 	s anslist="OoAaQq"
		 	s default="Q"
	 	}
 	}
 	w !,prompt
 	r resp
	s x=$E(resp_default)
	while anslist'[x {
		w !,"Invalid response - ",resp
		w !,prompt
		r resp
		s x=$E(resp_default)
	}
	if "NnQq"[x quit    ;No and Quit both return
	if "Oo"[x do DBRemove(0) quit   ;Ones go to DBRemove
	; Yes (which is remove the 1 database) is the same as 
	; All - remove all the databases 
	for i=1:1:Index {
		s dir=List(i)
		w !,"Removing ",dir
		if +$ZU(49,dir)<0 {
			; mount db if its dismounted
			do $ZU(17,dir)
		}
		s rc=##class(SYS.Mirror).RemoveMirroredDatabase(dir)
		if '(''rc) {
			w !," ...failed: ",$SYSTEM.Status.GetErrorText(rc)
		} else {
		   w " ...succeeded"
		}
	}
	q
}
DBRemove(isMember) {
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
	s rc=$$SelectDatabases(.RemoveDBList,.DBInfo,"M",/*MustJournal*/,1)
	i 'rc q
	s ActiveBits="" ;a bitstring of InActiveMirror flags of selected DBs
	s i=1 f  {
		s dbpath=$li(RemoveDBList,i)
		w !,dbpath
		i $li(DBInfo(i),3) { ;InActiveMirror flag is on
			w " is active in the mirror"
			s $bit(ActiveBits,i)=1 
		}
		i $i(i)>$ll(RemoveDBList) q
	}
	if +$G(isMember) {
		w !,"Access to databases being removed may result in <PROTECT> error,"
		w !,"while this action takes place. Once a mirrored database is removed,"
		w !,"it is no longer a valid copy; this is irreversible."
		if $SYSTEM.Mirror.IsPrimary() {
			w !,"If this database is added back to the mirror later, using"
			w !,"the same mirror database name, other copies will need to "
			w !,"be replaced with this version of the database."
		} else {
			w !,"If you decide to restore this database later, you will need"
			w !,"to get a copy from one of the other mirror members."
		}
	}
	i $$YN("Really remove above databases from the mirror","N")="N" {
		w !,"Aborted" 
		q
	}
	s i=1 f  {
		s dbpath=$li(RemoveDBList,i)
		w !,"Removing ",dbpath," from the mirror"
		s rc=##class(SYS.Mirror).RemoveMirroredDatabase(dbpath)
		if '(''rc) {
			w !,"Failed: ",$SYSTEM.Status.GetErrorText(rc)
		} else {
		   	w " ...Done"
		}
		i $i(i)>$ll(RemoveDBList) q
	}
	q
}	
DBActivate() PUBLIC {
	s state=$SYSTEM.Mirror.GetInfo()
	if state'[",DEFINED," {
		w !,"Must be a mirror member to activate a database"
		quit
	}
	s cls=##class(Config.MirrorMember).Open(,,.rc)
	if ('rc) {
		w !,"Can't activate database - failed to read mirror member configuration"
		quit
	}
	s AsyncMember=cls.isAsyncMember()
	s cls=""
	s list="",index=0
	d ActivateDatabases(AsyncMember,.list)
	if list'="" {
		r !,"Start catchup for activated database(s)? <Y> ",resp
		if "Nn"'[$E(resp_"Y") {
			JOB ##class(SYS.Mirror).CatchupDB(list)::5
			i $T {
				w !,"CatchupDB background job is started."
				w !,"You can run Mirror Monitor to check status of the databases."
			} else {
				w !,"Failed to start CatchupDB background job."
			}
		}
	}
}
ActivateDatabases(AsyncMember,actsfnList) {	
	s CanActivate=$SYSTEM.Security.Check("%Admin_Manage","USE")
	s CanCatchup=$SYSTEM.Security.Check("%Admin_Operate","USE")
	if 'CanActivate,'CanCatchup w !,"Activate required %Admin_Manage:USE, catchup required %Admin_Operate:USE privilege." q
	s SkipCatchup=0,SkipActivate=0
	s rc=$$SelectDatabases(.ActDBList,.DBInfo,,,1,0/*InActiveMirror*/)
	i 'rc q
	s ActivateBits="" ;a bitstring of the databases that need activation
	s i=1 f  {
		s dbpath=$li(ActDBList,i)
		w !,dbpath
		i $li(DBInfo(i),4) s $bit(ActivateBits,i)=1
		e  s $bit(ActivateBits,i)=0 w " is active but requires catchup" ;'MirrorActivationRequired
		i $i(i)>$ll(ActDBList) q
	}
	i $bitcount(ActivateBits,0) { ;#databases that DO NOT need activation
		w !,"Some databases, as indicated above, are active but require catchup"
		if 'CanCatchup {
			w !,"But it required %Admin_Operate:USE privilege, catchup skipped."
			s SkipCatchup=1
		} else {
			i $$YN("Do you want to catch up those database","Y")="N" s SkipCatchup=1
		}
	}
	i $bitcount(ActivateBits,1) { ;#databases that DO need activation
		if 'CanActivate {
			s SkipActivate=1
			w !,"Activate mirrored databases required %Admin_Manage:USE privilege, activation skipped."
			if CanCatchup,$bitcount(ActivateBits,0),'SkipCatchup w !,"But you still can catchup those already activated databases."
		} else {
			if 'CanCatchup w !,"You could activate those databases.",!,"But you don't have %Admin_Operate:USE privilege to catchup them."
			i $$YN("Really activate above databases for use on this mirror member","N")="N" s SkipActivate=1
		}
	}
	s actcnt=0 
	f i=1:1:$LL(ActDBList) {
		s dbpath=$li(ActDBList,i)
		i $bit(ActivateBits,i) {
			if SkipActivate continue
			w !,dbpath
			s rc=$SYSTEM.Mirror.DBActivate(dbpath)
			if '+rc {
				s text=$P(rc,",",2)
				w !,"Activation failed because ",text
				continue
			}
			w " ...Activated"
			if SkipCatchup {
				w ", but can't catchup."
			} else {
				s $li(actsfnList,$i(actcnt))=$li(DBInfo(i),2) ;sfn of dbpath
			}
			s dbobj=##Class(SYS.Database).%OpenId(dbpath,,.Status)
			s mirdbname=$s(('Status):"",1:dbobj.MirrorDBName)
			k dbobj
			d ##Class(%SYS.Audit).WriteToAuditFile("%System","%System","ConfigurationChange",dbpath,"Activate mirrored database "_mirdbname)
		} else {
			if 'SkipCatchup {
				w !,dbpath
				s $li(actsfnList,$i(actcnt))=$li(DBInfo(i),2) ;sfn of dbpath
			}
			continue
		}
		; if we're a read/write async member then clear the failover db
		; flag now.
		if AsyncMember {
			if ##class(Config.MirrorMember).IsReadWriteReportingMember() {
				; read-write async member
			    s rc=$SYSTEM.Mirror.ClearFailoverDBFlag(dbpath)
			    w " ...marked as read/write"
			}
		}
	}
}
DBList(detail) PUBLIC {
	s $zt="err"
	s sfn=$SYSTEM.Mirror.GetNextDBBySFN(-1)	
	if +sfn=-1 {
		w !,"No mirrored db's mounted"
		goto scan
	}
	i $g(detail)="" {
		r !,"Show details? <N> ",resp
		s detail=$s("Yy"[$e(resp_"X"):1,1:0)
	}
	w !,"SFN",?5,"Local path",?50,"Mirror name"
	if detail {
	   w !,?5,"Jrncnt/jrnoff/targjrncnt/targjrnoff/lastjrnrestored/mirrorname/curdirname"
	   w !,?5,"dbguid/jrnguid"
	   w !,?5,"mirrorguid/cursysguid"
	   w !,?5,"createdflag/newcnt/newoff/oldcnt/oldoff"
	}
	w !,"----"
    s nofailoverbit=+$ZU(40,8,31)
    s creatednewbit=+$ZU(40,8,34)
	do {
		s mirname=$P(sfn,"^",2)
		s locdir=$P(sfn,"^",3)
		s locsfn=$P(sfn,"^",4)
		w !,+sfn," "
		w ?5,locdir
		if $X>48||($l(mirname)>($X+1)) w !
		w ?$s($l(mirname)<32:50,1:(80-$l(mirname))),mirname
	  	if +locsfn=$ZU(40,0,41) {
		  	s info="" w !,?5,"Removed or Dismounted"
	  	} else {
		  	s info=$SYSTEM.Mirror.DBGetInfo(0,+locsfn)
	  	}
		if detail,info'="" {
		   w !,?5
		   w $P(info,"^",3),"/"
		   w $P(info,"^",4),"/"
		   w $P(info,"^",18),"/"
		   w $P(info,"^",19),"/"
		   w $P(info,"^",11),"/"
	       w $P(info,"^",8),"/",$P(info,"^",10)
		   w !,?5,$P(info,"^",6),"/",$P(info,"^",17)
		   w !,?5,$P(info,"^",7),"/",$P(info,"^",9)
	       s infoflag=+$P(info,"^",12)
    	   s curval=$ZB(infoflag,creatednewbit,1)
    	   w !,?5,curval,"/"
    	   w $P(info,"^",13),"/"
    	   w $P(info,"^",14),"/"
    	   w $P(info,"^",15),"/"
    	   w $P(info,"^",16)
    	   s curval=$ZB(infoflag,nofailoverbit,1)			
    	   if curval=0 {
	    	   w !,?5,"Database modified by async member, not a failover copy"
    	   }
		}
	    s sfn=$SYSTEM.Mirror.GetNextDBBySFN(+sfn)	
	} while (+sfn '= -1)
scan ;
	; 
	; Now go through and see if we can find any db's with the activate req
	; bit set. If so, these don't have mirrored aliases as there's a problem
	; so they aren't returned by .GetNextDBBySFN().
	s sfnmax=$zu(40,0,41)
	s first=1
	for sfn=0:1:sfnmax {
		s dbdata=$ZU(49,+sfn)
		if +dbdata>-1,($zb(+$p(dbdata,",",18),$zu(40,8,32),1)) {
		   if first w !,"Databases with the activation required flag set" s first=0
		   s namedata=$zu(49,+sfn,3)
		   s locdir=$P(namedata,"^",2)
	 	   s info=$SYSTEM.Mirror.DBGetInfo(0,+sfn)
	 	   s mirname=$P(info,"^",2)
		   w !,+sfn," "
	       w ?5,$E(locdir,$L(locdir)-40,$L(locdir))," "  ;trim to field width
	       w ?50,$E(mirname,$L(mirname)-30,$L(mirname))," "
	       if info'="" {
		      w !,?5
		         w $P(info,"^",3),"/"
		         w $P(info,"^",4),"/"
		         w $P(info,"^",18),"/"
		         w $P(info,"^",19),"/"
			     w $P(info,"^",11),"/"
	             w $P(info,"^",8),"/"
	             w $P(info,"^",10)
	          w !,?5
	             w $P(info,"^",6)
	          w !,?5
	             w $P(info,"^",7),"/"
	             w $P(info,"^",9)
		   }
		}
	}
	quit
err ;
	s $zt=""
	w !,"Unexpected error: ",$ze
	quit	
} 
 ; Pause journaling on one or more databases
DBPause() {	
	if $SYSTEM.Mirror.IsPrimary() {
		w !,"This option is not available on the primary mirror member"
		quit
	}
	i '$SYSTEM.Security.Check("%Admin_Operate","USE") w !,"Operation requires %Admin_Operate:Use privilege" q
	w !,"Pause dejournaling to one or more databases"
	s rc=$$SelectDatabases(.PauseDBList,/*DBInfo*/,,/*MustJournal*/,1)
	i 'rc q ""
	s i=1 f  {
		s dbpath=$li(PauseDBList,i)
		w !,dbpath
		i $i(i)>$ll(PauseDBList) q
	}
	i $$YN("Really pause dejournaling to above databases","N")="N" {
		w !,"Aborted" 
		q ""
	}
	W !,"Use Database Catchup when you are ready to start dejournaling again"
	s i=1 f  {
		s dbpath=$li(PauseDBList,i)
		w !,dbpath
		s rc=##class(SYS.MirrorConfiguration).DejournalPauseDatabase(dbpath)
 		if ('rc) {
	 		k err
    			D DecomposeStatus^%apiOBJ(rc,.err,"-d") 
    			w !,"Failed to pause dejournaling: ",err(1)
		}
		i $i(i)>$ll(PauseDBList) q
	}
}
ModifyDBSize() {
	if $SYSTEM.Mirror.GetInfo()["PRIMARY" {
		w !,"This node is the primary, switching to ^DATABASE"
		D EDIT^DATABASE
		quit
	}
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
	s status=$SYSTEM.Mirror.GetInfo()
	s Obj = $$SelectDatabases(/*DBList*/,/*DBInfo*/,1/*SingleSelect*/,,1)
	q:Obj=0
	s dirname=Obj.Directory
	s cursize=Obj.Size
	s expsize=Obj.ExpansionSize
	s maxsize=Obj.MaxSize
	s blocksize=Obj.BlockSize
	s Obj=""
	w !,"1. Current size (MB):   ",cursize
	w !,"2. Expansion size (MB): ",expsize
	w !,"3. Maximum size (MB):   ",maxsize
		r !,"Enter field to change? <Quit> ",field
	s field=+field
	while field>3 {
		w !,"Field out of range, must be 1-3"
		r !,"Enter field to change? <Quit> ",field
		s field=+field
	}
	if 'field quit
	s type=$CASE(field,1:"current",2:"expansion",3:"maximum")
	w !,"Enter new ",type," size (MB)? <no change> "
	read resp	
	if resp="" quit
	s resp=+resp
	if resp<0 w !,"Invalid value, size cannot be negative" quit
	if (field=1) {
		if resp<cursize {
			w !,"Invalid size, cannot be less than current size" 
			quit
		}
		s cursize=resp
	} elseif (field=2) {
		s expsize=resp
	} elseif (field=3) {
		if resp && (resp<cursize) {
			 w !,"Invalid size, cannot be less than current size" 
			 quit
		}
		s maxsize=resp
	}
	; expandby and maxsize are in blocks, cursize is in MB
	; so convert expandby & maxsize
	s expsize=(expsize*1048576)/blocksize
	s maxsize=(maxsize*1048576)/blocksize
	;
	s rc=$SYSTEM.Mirror.DBModify(dirname,cursize,expsize,maxsize)
	if rc>0 {
		w !,"Succeeded"
	} else {
		w !,"Failed."
	    if rc<0	w "Error: ",$$Error^%apiOBJ(-rc)
	}
	q
}	
MarkAsCaughtUp() PUBLIC {
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
	s state=$SYSTEM.Mirror.GetInfo()
	if state'[",DEFINED," {
		w !,"Must be a mirror member to manage mirrored databases"
		quit
	}
	s Obj = $$SelectDatabases(/*DBList*/,,1/*SingleSelect*/,,1,0,0)
	q:'$IsObject(Obj)
	w !,"This is only supposed to be used in cases where a read-only database"
	w !,"has been changed to read-write and it needs to be marked ""current"""
	w !,"so that it can be used as part of the current mirror. The catch up function"
	w !,"should be used if there is any journal data which has yet to be applied to "
	w !,"the database."
	w !
	w !,"Really mark ",Obj.Directory
	w !,"     as up to date <N> "
	r conf
	s conf=$E(conf_"X")
	if "Yy"'[conf w !,"Aborted" quit ""
	do AskResetMirroredDB(Obj)
	quit
}
SelectDatabases(DBPathList,DBInfo,SingleSelect,Journaled,Mirrored,ActiveYN,ActReqYN) Public {
 s $zt="ERROR"    
 s Flag=8+512
 i '$g(SingleSelect) s Flag=Flag+1024
 s MustJournal=$g(Journaled) ;Journaled may be set to -1 below
 s Mirrored=+$g(Mirrored)
 i $g(ActiveYN)="" s ActiveYN="01" 
 e  s ActiveYN=+ActiveYN
 i $g(ActReqYN)="" s ActReqYN="01" 
 e  s ActReqYN=+ActReqYN
 s rc=0 ;return value, which is either an OREF (SingleSelect) or #databases
 f  {
	Kill dbname,DBInfo
	s Index=0
	s (List,dbinfo,active,actreq)=""
	s Journaled=MustJournal ;restore original value
	i $g(SingleSelect)="M" { ;a list of mounted databases instead of ...
		Set Rset = ##class(%Library.ResultSet).%New("SYS.Database:List")
	} else { ;a list of configured databases
		Set Rset = ##class(%Library.ResultSet).%New("Config.Databases:List")
	}
	d Rset.Execute()
	While (Rset.Next()) {
		i $g(Rset.Data("Server"))'="" continue ;must be local
		s dbpath=Rset.Data("Directory") 
		s dbname=$g(Rset.Data("Name")) ;="" for SYS.Database:List
		i $d(dbname(dbpath)) continue
		s dbinfo=$zu(49,dbpath)
		i (dbinfo<-1) continue ;must be mounted or mountable.
		i MustJournal,$zb(+$p(dbinfo,",",17),$zu(40,8,23),1) continue
		i Mirrored {
			i '$zb(+$p(dbinfo,",",17),$zu(40,8,28),1)||('$zb(+$p(dbinfo,",",18),$zu(40,8,32),1)&&$zb(+$p(dbinfo,",",18),$zu(40,8,30),1)) continue
			s active=''$zb(+$p(dbinfo,",",18),$zu(40,8,29),1)
			i ActiveYN'[active continue
			s actreq=''$zb(+$p(dbinfo,",",18),$zu(40,8,32),1)
			i ActReqYN'[actreq continue
			if ActiveYN=0,'actreq {
				s mirdbinfo=$SYSTEM.Mirror.DBGetInfoByName(0,dbpath)
				if mirdbinfo="" continue
				s dbmirname=$p(mirdbinfo,"^",8)
				s miridx=$SYSTEM.Mirror.MirrorNameToIndex(dbmirname,0)
				s mirinfo=$SYSTEM.Mirror.GetInfo(2,miridx)
				if (##class(SYS.MirrorConfiguration).GetDejournalReaderStatus(dbmirname)'="running") {
					if +$p(mirinfo,",",6) {
						s mirchkpntfcnt=$p(mirinfo,",",6)
						s mirchkpntoff=$p(mirinfo,",",7)
					} else {
						s rc=$SYSTEM.Mirror.GetLastJournalFilename(dbmirname)
						i +rc'>0 {
							w !,"Can't find the last mirror journal file in the system"
							q
						}
						s lastfilecnt=+rc
						s lastfname=$p(rc,",",2)
						s rc=##class(SYS.Mirror).GetCurrentState(dbmirname,lastfilecnt,0)
						if rc<0 {
							w !,"Can't find the current mirror status to decide the CatchupDB position"
							q
						} elseif +rc>3 {
					        s mirchkpntfcnt=+$p(rc,",",2)  ;could be 0,0
					        s mirchkpntoff=+$p(rc,",",3)
						} elseif +rc=0 {
							s mirchkpntfcnt=+$p(rc,",",2)
							s mirchkpntoff=+$p(rc,",",3)
						} else {
							s mirchkpntfcnt=0
							s mirchkpntoff=0
						}
						if 'mirchkpntfcnt {
							s mirchkpntfcnt=lastfilecnt
						    s fd=$zu(78,5,lastfname,0)
						    if fd<0 {
							   w !,"Can't open last journal file ",lastfname
							   quit 
						    }
						    do $zu(78,6,fd)
						    s mirchkpntoff=+$zu(78,18,0)
						    do $zu(78,7,fd)
						}
					}
					if mirchkpntfcnt=$P(mirdbinfo,"^",3)&&(mirchkpntoff=$P(mirdbinfo,"^",4)) continue
				}
			}
		} else { ;requiring a non-mirrored, non-system database
			i '##class(SYS.Database).CanDatabaseBeMirrored(dbpath) continue
		}
		s List($i(Index))=dbpath
		if (dbinfo<0) {
			s List(Index,0)=" *Dismounted"
		} elseif (dbinfo>=$zu(40,0,41)) {
			s List(Index,0)=" *Unmounted"
		}
		s dbname(dbpath)=$lb(dbname,+dbinfo,$g(active),$g(actreq))
 	}
 	Kill Rset
	s rc=0 ;none selected
	i 'Index {
		w !,"No applicable databases found",!
		q  ;no database to choose from that meets the criteria
	}
	s DBPathList=""
	s Status=##Class(%Library.Prompt).GetArray("Database directory?",.DBPathList,.List,,,,Flag)
 	i (+Status=0)||(Status=2)||(DBPathList="") q
	i $g(SingleSelect) {
		s dbpath=DBPathList
	} elseif $ll(DBPathList)<2 {
		s dbpath=$li(DBPathList,1)
		i $d(dbname(dbpath)) {
			if $li(dbname(dbpath),2)<0||(+$li(dbname(dbpath),2)=$zu(40,0,41)) {
				s dbinfo=$zu(49,dbpath)
				goto AskMount
			}
			s rc=1
			s DBInfo(1)=dbname(dbpath)
			q
		}
	} else {	;multiple selected
		s rc=$ll(DBPathList)
		k NeedMount   ; list of DBs need to be mounted.
		s i=1 f  {
			s dbpath=$li(DBPathList,i)
			s DBInfo(i)=dbname(dbpath)
			if $li(dbname(dbpath),2)<0||(+$li(dbname(dbpath),2)=$zu(40,0,41)) s NeedMount(i)=dbpath,xx=$i(NeedMount)
			i $i(i)>rc q
		}
		if +$g(NeedMount)>0 {
			w !,"The following database",$s(NeedMount>1:"s are",1:" is")," not mounted."
			s i=$o(NeedMount(""),1,dbpath)
			while i'="" { w !,"   ",dbpath s i=$o(NeedMount(i),1,dbpath) }
			w !!,"You need to mount ",$s(NeedMount>1:"all ",1:""),"the database",$s(NeedMount>1:"s",1:"")," in order to"
			w !,"   check if ",$s(NeedMount>1:"they are still candidates",1:"it is still a candidate")," of the operation."
			w !,"Do you want to mount ",$s(NeedMount>1:"these databases",1:"this database"),"? <Y> " r resp
			s resp=$S("Nn"[$E(resp_"Y"):0,1:1)
			if 'resp {
				w "   removed unmounted database",$s(NeedMount>1:"s",1:"")," from selections.",!
				if NeedMount=rc {
					w "All the selected databases are removed, please re-ented.",!
					continue
				}
				s newcnt=0,newlist="" k DBInfo
				for i=1:1:rc {
					if '$d(NeedMount(i)) {
						s dbpath=$li(DBPathList,i)
						s newlist=newlist_$lb(dbpath)
						s DBInfo($i(newcnt))=dbname(dbpath)
					}
				}
				s rc=newcnt,DBPathList=newlist
				quit
			}
			s i=$o(NeedMount(""),1,dbpath)
			while i'="" {
				do $ZU(17,dbpath)
				s dbinfo=$ZU(49,dbpath)
				s NeedSkip=0
				if (dbinfo<0)||(+dbinfo=$zu(40,0,41)) {
					w !,"Failed to mount '",dbpath,"', removed from the selected list."
					s NeedSkip=1
				} elseif Mirrored {
					s active=''$zb(+$p(dbinfo,",",18),$zu(40,8,29),1)
					s actreq=''$zb(+$p(dbinfo,",",18),$zu(40,8,32),1)
					i ActiveYN'[active {
						i ActiveYN w !,"'",dbpath,"' is not currently active on this system"
						e  w !,"'",dbpath,"' is already active on this system"
						w ", removed from the selected list."
						s NeedSkip=1
					} elseif ActReqYN'[actreq {
						i ActReqYN w !,"'",dbpath,"' requires activation for use on this system"
						w ", removed from the selected list."
						s NeedSkip=1
					} else {
						s DBInfo(i)=$LB($li(DBInfo(i),1),+dbinfo,active,actreq)
						w !,"'",dbpath,"' is mounted ok."
					}
				}
				if NeedSkip {
					s DBPathList=$li(DBPathList,1,i-1)_$li(DBPathList,i+1,rc)
					for ii=i+1:rc { s DBInfo(ii-1)=DBInfo(ii) }
					k DBInfo(rc)
					s rc=rc-1  ; Reduce counter
				}
				s i=$o(NeedMount(i),1,dbpath)
			}
		}
		q
	}
 	s dir0=$zu(12,dbpath,1)
 	i dir0="" {
	 	i dir0="" w !!,"Invalid directory specification, please re-enter",! Continue
 	}
 	s dbpath=$zu(12,dir0,3)
 	i dbpath="" {
	 	w !!,"Directory "_dir0_" does not exist, please re-enter",! 
		Continue
 	}
	s dbinfo=$zu(49,dbpath)
	i (dbinfo<0)||(dbinfo>=$zu(40,0,41)) {
AskMount w !!,"Database is not mounted. You need to mount the database in order to"
		w !,"   check if it is still a candidate of the operation."
		w !,"Do you want to mount this database? <Y> " r resp
		s resp=$S("Nn"[$E(resp_"Y"):0,1:1)
		if 'resp {
			w "  selection skipped, please re-enter.",!
			Continue
		}
		do $ZU(17,dbpath)
		s dbinfo=$ZU(49,dbpath)
		if (dbinfo<0)||(dbinfo>=$zu(40,0,41)) {
			w !,"Failed to mount '",dbpath,"', please re-enter.",!
			continue
		}
	}
	i Mirrored {
		i '$zb(+$p(dbinfo,",",17),$zu(40,8,28),1) {
			w !,dbpath," not marked as mirrored"
			continue
		}
		s active=''$zb(+$p(dbinfo,",",18),$zu(40,8,29),1)
		s actreq=''$zb(+$p(dbinfo,",",18),$zu(40,8,32),1)
		i ActiveYN'[active {
			i ActiveYN w !,dbpath," is not currently active on this system"
			e  w !,dbpath," is already active on this system"
			continue
		}
		i ActReqYN'[actreq {
			i ActReqYN w !,dbpath," requires activation for use on this system"
			continue
		}
	} else { ;requiring a non-mirrored, non-system database
		i $zb(+$p(dbinfo,",",17),$zu(40,8,28),1) {
			w !,"Already mirrored" 
			continue
		}
		i '##class(SYS.Database).CanDatabaseBeMirrored(dbpath) {
			w !,"DB is not allowed to be mirrored because it is a system DB." 
			continue
		}
		s status=##class(Config.Databases).DatabasesByDirectory("",dbpath,.dbnamelist)
		i ('status) {
	 		w ! d $System.Status.DisplayError(status) w !
			Continue
		}
		i '$ll(dbnamelist) {
			w !!,dbpath," not defined in ","iris",".cpf"
			continue
		}
		s dbname=$li(dbnamelist,1)
	}
	i MustJournal,$zb(+$p(dbinfo,",",17),$zu(40,8,23),1) {
		s Journaled=-1 ;caller needs to enable journaling on the DB
	}
	i $g(SingleSelect) {
		s rc=##Class(SYS.Database).%OpenId(dbpath,,.Status)
		if ('Status) {
			w ! d $SYSTEM.Status.DisplayError(Status) w !
			Continue
		}
		q 
	}
	s DBPathList=$lb(dbpath)
	s DBInfo(1)=$lb($g(dbname),+dbinfo,$g(active),$g(actreq))
	s rc=1
 	q
 }
 q rc
ERROR s $zt=""
 i $ze["<INTERRUPT>" q 0
 ztrap $ZE
}
getPrimary() PUBLIC {
	; Looks up the name of the primary mirror member or
	; returns NULL if we can't find it
	s mirname=$p(^SYS("MIRRORSET"),"^",2)
	s id=$O(^MIRROR(mirname,"Status","Member",""))
	while (id '= "") {
	   q:$G(^MIRROR(mirname,"Status","Member",id,"Role"))="PRIMARY" 
	   s id=$O(^MIRROR(mirname,"Status","Member",id))
	}
	quit:id="" ""  ; can't find a primary
	s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
	s primary=$LG(info,1)
	quit primary
}
LocalMirrorStatus() PUBLIC {
	s x=$SYSTEM.Mirror.GetInfo(1)
	if x'["DEFINED" w !,"This node is not a mirror member" q
	s membertype=##class(%SYSTEM.Mirror).GetMemberType()
	; does the member type need to be localized?
	;s membertype=##class(SYS.Mirror).LocalizeMemberType(membertype)
	s info=$G(^SYS("MIRRORSET"))
	s mirname=$p(info,"^",2)
	s mircnt=$L(mirname,",")
	w !,"This instance is a ",membertype," member "
	if mircnt>1 {
		w "of ",mircnt," mirrors"
	}
	w !
	for i=1:1:mircnt {
		s name=$P(mirname,",",i)
		s status=##class(%SYSTEM.Mirror).GetMemberStatus(name)
		s troubelflag=$LG(status,2)
		s status=$LG(status)
		if status="Primary",troubelflag="Trouble" s status="Primary In Trouble"
		; does the member statys need to be localized?
		s status=##class(SYS.Mirror).LocalizeMemberStatus(status)
		w ?5,"Status for mirror ",name," is """,status,"""",!
	}
	s flags=$SYSTEM.Mirror.DebugFlags()
	if +flags w !,"Mirror Debug Flags: 0x",$ZH(+flags)
	;
	s info=$SYSTEM.Mirror.GetInfo(2)
	if x["PRIMARY" {
	   w !,"Current mirror file #",$P(info,",",1)," ends at ",$P(info,",",4)
	   w !,"Min trans file #",$P(info,",",3)," min trans index: ",$P(info,",",2)
	} elseif x["ACTIVE" {
	   w !,"Currently have pos ",$P(info,",",4)," in mirror file #",$P(info,",",1)
	   s chkpnt=$G(^MIRROR(mirname,"dejrnchkpnt"))
	   w !,"Last dejrnchkpnt = file #",+chkpnt," pos: ",+$P(chkpnt,"^",2)
	}
	if (x'["SHADOW") && (mirname'="") {
		s cls=##class(Config.Mirrors).Open(mirname)
		s defprimary=cls.DefinedPrimary
		s cls=""
		if defprimary'="" {
			if defprimary=":NOPARTNER" {
				w !!,"Mirror is set to 'no failover'."
			} else {
				w !!,"Mirror is set to 'no failover' with ",defprimary," defined as primary"
			}
		}
	}
	w !
}
ChangeValidEnd() PUBLIC {
	if '$D(^SYS("MIRRORSET")) {
		w !,"Mirror configuration not loaded"
		quit
	}
	w !,"WARNING: It should never be necessary to use this function"
	w !,"         There may be situations where this is required to recover"
	w !,"         from a bug to get the system back up. Unless you have been"
	w !,"         told to do this by someone from the InterSystems WRC you should"
	w !,"         not proceed."
	r !,"Continue? <No> ",resp
	if "Yy"'[$E(resp_"X") quit
	s $zt="cveErr"
	if $SYSTEM.Mirror.GetInfo()["ACTIVE" {
		w !!,"This node is an active mirror member. This option is only used"
		w !,"to resolve troubles that block a node from becoming an active member."
		w !
		quit
	}
top ;	
    if +$G(^SYS("MIRRORSET")) {
	    r !,"Enter mirror set name: (? for list, return for quit) ",mirname
	    if mirname="?" w !!,"Mirror Set name is one of:",!,$p(^SYS("MIRRORSET"),"^",2) goto top
	    if mirname="" quit
	    if ","_$P(^SYS("MIRRORSET"),"^",2)_","'[(","_mirname_",")||(mirname[",") w "   does not exist!" g top
    } else {
	    s mirname=$p(^SYS("MIRRORSET"),"^",2)
    }
	r !,"Enter mirror journal number: (? for list, Q for quit) ",filecnt
	if filecnt'="","Qq"[filecnt quit
	if filecnt="?" do JrnDisplay(mirname) goto top
	if filecnt="" goto top
    s jrnfile=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)
	if '+jrnfile {
	   w !,"Failed to find file #"_filecnt_" in journal log"
	   goto top
    }
    s jrnfile=$P(jrnfile,",",2)
	s jrninfo=$zu(78,22,jrnfile,99)
	if jrninfo<0 {
	   w !,"Failed to read header information from "_jrnfile
	   goto top
	}
    s filecnt=$P(jrninfo,",",13+1)
    s jrnguid=$P(jrninfo,",",7+1)
    s sysguid=$P(jrninfo,",",14+1)
    s mirguid=$P(jrninfo,",",15+1)
    s valid=$P(jrninfo,",",16+1)
    ;
	s fd=$zu(78,5,jrnfile,0)
	if fd<0 {
	   w !,"Failed to open journal file: "_jrnfile
	   quit $LB(0)
	}
    do $zu(78,6,fd)
	s jrnend=$zu(78,18,0)
	do $zu(78,7,fd) 
	s fd=0
enteroption ;
	w !,"For ",jrnfile
	w !,?5,"Current endoff: ",jrnend
	w !,?5,"Current valid end: ",valid
	if 'valid {
		s validopts="SQ"
		w !,"(S)et valid end or (Q)uit? <Quit> "
	} else {
		s validopts="CRQ"
		w !,"(C)lear valid end, (R)eset valid end, or (Q)uit? <Quit> "
	}
	r resp w !
	s resp=$ZCVT($E(resp_"Q"),"U")
	if validopts'[resp {
		w !,"Invalid option: ",resp," - Try again"
		goto enteroption
	}
	if resp="Q" goto top
	if (resp="C") {
		;clear valid end or reset valid end
		do $ZU(9,"","Mirror: "_"MIRROR: Clearing valid end of "_jrnfile_" ("_valid_")")
		s x=$SYSTEM.Mirror.ClearJournalFileMirEnd(jrnfile)
		if +x {
			w !,"Done"
		} else {
		   s reason=$P(x,",",2)
		   w !,"Failed to clear end: ",reason
		}
		goto top
	}
	; set or reset
	s actend=jrnend
	if (resp="R") {
		;reset valid end starts by clearing it
		do $ZU(9,"","Mirror: "_"MIRROR: Resetting valid end of "_jrnfile_" ("_valid_")")
		s x=$SYSTEM.Mirror.ClearJournalFileMirEnd(jrnfile)
		if '+x {
		   s reason=$P(x,",",2)
		   w !,"Reset aborted, failed to clear end: ",reason
		   goto top
		}
	   ; now that valid end is cleared, open the file and find the
	   ; actual end
	   s fd=$zu(78,5,jrnfile,0)
	   if fd<0 {
	      w !,"Failed to open journal file: "_jrnfile_" to locate actual end"
	      goto top
  	   }
       do $zu(78,6,fd)
	   s actend=$zu(78,18,0)
	   do $zu(78,7,fd)
	   s fd=0
	}		
	w !,"Enter new valid end up to actual end ",actend,"? "
	read resp
	while ('+resp) || (+resp > actend) {
	   if '+resp {
		   w !,"0 is not a valid response - please enter a value"
	   } else {
	       w !,resp," is > than actual end - try again"
	   }
	   w !,"Enter new valid end up to actual end ",actend,"? "
	   read resp
	}
	w !
	do $ZU(9,"","Mirror: "_"MIRROR: Setting valid end of "_jrnfile_" to "_resp)
	s x=$SYSTEM.Mirror.SetMirrorJournalFileEnd(jrnfile,+resp)
	if +x {
	   w !,"Done" 
	} else {
	   w !,"Failed"
	}
	goto top
cveErr ;
	s $zt=""	
	w !,"Unexpected error: ",$ZE," at ",$ZU(56,2)
	if fd do $zu(78,7,fd)
	quit
}
JrnDisplayx() PUBLIC {
	if '$D(^SYS("MIRRORSET")) {
		w !,"Mirror configuration not loaded"
		quit
	}
	i '+$G(^SYS("MIRRORSET")) d JrnDisplay($p(^SYS("MIRRORSET"),"^",2)) quit
top ;
    s cnt=$$getAsyncMemberSources(.names)
	if 'cnt {
	   w !,"No Async member sources defined"
	   quit
	}
	if cnt=1 {
	   s mirname=names(1)
	   w !,"Displaying journal files for ",mirname
	} else {
	   w !,"This is an Async member tracking ",cnt," mirrors"
	   r !,"List journal files for which mirror? (? for list, <ret> to exit) ",mirname
	   while mirname="?" {
		   w !,"This node is tracking the following mirrors:"
		   w !,?5
		   for i=1:1:cnt w names(i) w:i'=cnt ", " w:$X>75 !,?5 
	       r !,"List journal files for which mirror? (? for list, <ret> to exit) ",mirname
	   }
	   s mirname=$zcvt(mirname,"U")
	}
	if mirname="" quit
	d JrnDisplay(mirname)
	if cnt>1 goto top
}
JrnDisplay(mirname) PUBLIC {
	w:$X !  ;start with a fresh line
	s cnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
	for i=0:1:cnt {
		s info=$G(^SYS("MIRRORSET",mirname,"Member",i),"")
		if $L(info) {
			s name=$LG(info,1)
			s guid=$LG(info,2)
			s guidxlate(guid)=name
		}
	}
	s curmirguid=$G(^SYS("MIRRORSET",mirname,"GUID"))
	;
	s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)
	if +rc=-1 {
		w "Failed to read mirror journal log, can't display journal files",!
		quit
	}
	if +rc=0 {
		w "Mirror journal log doesn't exist, can't display journal files",!
		quit
	}
	s jrnfile=$P(rc,",",2)
	s jrninfo=$$getjrninfo(jrnfile)  ;returns $LB(1,<mirfilecnt>,<jrnend>,<validflag>,
									 ;							<jrnguid>,<createguid>,<mirguid>)
    if '$LG(jrninfo) {
	    s endfilecnt=+rc-1
	    if endfilecnt<2 q
	    s filecnt=endfilecnt - 5
	    if filecnt<1 s filecnt=1
	    for i=endfilecnt:-1:filecnt {
		    s jrnfile=$SYSTEM.Mirror.GetJournalFileByMjrncnt(i,mirname)
		    q:'+jrnfile
		    s jrnfile=$P(jrnfile,",",2)
		    s jrninfo=$$getjrninfo(jrnfile)
		    q:$LG(jrninfo)
	    }
    }					
    ; 
    if '$LG(jrninfo) {
	    w !,"Can't find any mirror journal files even though they are listed"
	    w !,"   in the journal log"
	    quit
    }
	w !,"Filecnt  ",?11,$J("End addr",10),"(Valid)",?29,"File Name",!
	s cnt=1  ;gets updated with filecnt of next file later
	s linecnt=0,dontask=0
	while cnt,$LG(jrninfo) {
		if 'dontask,linecnt>20 {
			s $X=0
			w "more (a/n/y)?"
			read *more
			s more=$C(more)
			if "QqNn"[more w ! quit
			if "Aa"[more s dontask=1
			s linecnt=0
			s n=$X 
			f i=1:1:n w *8," ",*8
			s $X=0
		}
		s linecnt=linecnt+1
		s filecnt=$LG(jrninfo,2)
		s endoff=$LG(jrninfo,3)
		s validflag=$LG(jrninfo,4)
		s sysguid=$LG(jrninfo,6)
		s mirguid=$LG(jrninfo,7)
		s len=$L(jrnfile)
		s validflag=$S(validflag:"(v)",1:"   ")
	    w $J(filecnt,4),?12,$J(endoff,10),validflag,?29,$E(jrnfile,len-50,len)
	    ;w " ",$J($G(guidxlate(sysguid),sysguid),10)
	    if mirguid'=curmirguid w !,?30,"<Foreign mirror: ",mirguid,">"
	    write !
	    s cnt=filecnt-1
	    if cnt {
		  s jrnfile=$SYSTEM.Mirror.GetJournalFileByMjrncnt(cnt,mirname)
		  if +'jrnfile {
			 s cnt=0
		  } else {
		     s jrnfile=$P(jrnfile,",",2)
		 	 s jrninfo=$$getjrninfo(jrnfile)  ;returns $LB(1,<mirfilecnt>,<jrnend>,<validflag>,
									 ;							<jrnguid>,<createguid>,<mirguid>)
			 if $LG(jrninfo),$LG(jrninfo,2)'=cnt {
				 w "File count mismatch in ",jrnfile," (expected: ",cnt," but it has :",$LG(jrninfo,2),")."
				 quit
			 }
		  }
		}
	}
	s SYSOBJ=##Class(Config.Journal).Open()
	w !,"Primary Journal Directory: ",SYSOBJ.CurrentDirectory
	w !,"Secondary Journal Directory: ",SYSOBJ.AlternateDirectory
	quit
}
getjrninfo(file) PUBLIC {
	;returns $LB(1,<mirfilecnt>,<jrnend>,<jrnguid>,<sysguid>,<mirguid>)
	; sysguid is the guid of the system which created the journal file
	; mirguid if the guid of the mirror the journal file belongs to
	s jrninfo=$zu(78,22,file,99)
	if jrninfo<0 {
	   w !,"Failed to read header information from "_file
	   quit $LB(0)
	}
    s filecnt=$P(jrninfo,",",13+1)
    s jrnguid=$P(jrninfo,",",7+1)
    s sysguid=$P(jrninfo,",",14+1)
    s mirguid=$P(jrninfo,",",15+1)
    s valid=$P(jrninfo,",",16+1)
	s fd=$zu(78,5,file,0)
	if fd<0 {
	   quit $LB(0)
	}
    do $zu(78,6,fd)
	s jrnend=$zu(78,18,0)
	do $zu(78,7,fd)
	quit $LB(1,filecnt,jrnend,valid,jrnguid,sysguid,mirguid)
}
ChangeRecoveryParams() PUBLIC {
	if '$D(^SYS("MIRRORSET")) {
		w !,"Mirror configuration not loaded"
		quit
	}
	s state=$SYSTEM.Mirror.GetInfo()
	s mirname=##class(Config.Mirrors).GetMirrorName()
	if mirname="" w !,"Failed to locate mirror name in Config.Mirrors" quit
	s mir=##class(Config.Mirrors).Open(mirname)
	if '$IsObject(mir) w !,"failed to open Config.Mirrors(",mirname,")" quit
	s qostimeout=mir.QOSTimeout
	w !,"QOS Timeout:        ",qostimeout," (msec)"
	if state'["PRIMARY" {
		w !,"Parameters can only be changed on the primary"
		read !,"Press RETURN to continue...",resp
		quit
	}
	r !,"Change this parameter? <N> ",resp
	if "Yy"'[$E(resp_"N") quit
	;
	; get new values
	;
	w !,"QOS Timeout in msec <",qostimeout,"> "
	s resp="" r resp
	if +resp s qostimeout=+resp
	w !,"New value: "
	w !,?5,"QOS Timeout:        ",qostimeout," (msec)"
	s resp=""
	read !,"Ok? <n> ",resp
	s resp=$E(resp_"N")
	if "Yy"'[resp {
		w !,"not changed" 
		quit
	}
	if (qostimeout '= mir.QOSTimeout) {
		s mir.QOSTimeout=qostimeout
		s rc=mir.%Save()
		if 'rc {
			w !,"Failed, rc=",rc
		} else {
			w !,"Changed"
		}
	}
}
AdjustQOSTimeout() {
	if 0 w !!,"Managed by Enterprise Manager, operation not allowed." Quit
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
	s mirname=$P($G(^SYS("MIRRORSET")),"^",2)
	if mirname="" w !,"Mirror name not set" quit
	s state=$SYSTEM.Mirror.GetInfo()
	s mir=##class(Config.Mirrors).Open(mirname)
	if '$IsObject(mir) w !,"failed to open Config.Mirrors(",mirname,")" quit
	s qostimeout=mir.QOSTimeout
	if qostimeout {
		s displayval=qostimeout
	} else {
		; if its 0 or not defined, use the active value as the default
		s recovparams=$SYSTEM.Mirror.ReconfigParams()
		s displayval=$P(recovparams,",",1)
	}
	w !,"QOS Timeout: ",displayval," (msec)"
	if state'["PRIMARY" {
		w !,"Parameters can only be changed on the primary"
		read !,"Press RETURN to continue...",resp
		quit
	}
	r !,"Change this parameter? <N> ",resp
	if "Yy"'[$E(resp_"N") quit
	w !,"QOS timeout in msec (0=default) <",qostimeout,"> "
	r resp
	if resp="" {
		s newqostimeout=qostimeout
	} else {
		s newqostimeout=+resp
	}
	if (newqostimeout '= qostimeout) {
	    s mir.QOSTimeout=newqostimeout
		s rc=mir.%Save()
		if 'rc {
			w !,"Failed, rc=",rc
		} else {
			w !,"Changed"
		}
	}
}
ChangeReconnectionParams() PUBLIC {
	; There are several configuration entries in ^MIRROR which affect
	; the behavior of certain aspects of mirroring. These are 
	; not usually defined and the code uses default values but they are
	; present in case we need to "tune" the values on a system to deal 
	; with problems that arise.
	;
	; This entry point is not accessible via the ^MIRROR menu as these
	; are not documented and we don't intend for people to change them,
	; at least not on their own.
	;
	; These may be removed in the future if we find the defaults work well.
	;
	; ^MIRROR(mirname,"reconnect","disable")=0/1
	; ^MIRROR(mirname,"reconnect","mininterval") = min # of seconds we permit
	;             between reconnections. If a backup tries to connect
	;             more often, we delay it. Defaults to 60 when missing.
	; ^MIRROR(mirname,"reconnect","largedelay") = If we've reconnected 10 times in
	;             a row and our average connection time is less than
	;             minreconnect, this is an added delay. Defaults to 
	;             5 minutes.
	; ^MIRROR(mirname,"reconnect","fixeddelay") = # of seconds which every
	;        reconnection attempt waits. This overrides "minreconnect"/"largedelay"
	; ^MIRROR("MirrorStartupSSHoldTime") = max # of seconds which superserver
	;        holds a job for (other than ECP) while mblkuser=3 indicating that
	;		 the instance is in the process of becoming the primary. Defaults
	;        to 60 seconds in %SYS.SERVER. If time expires and mblkuser is still
	;        set the connection is dropped. Only used on failover members.
	; 	
	if '$D(^SYS("MIRRORSET")) {
		w !,"Mirror configuration not loaded"
		quit
	}
	w !,"These parameters control how an instance retries when it fails to"
	w !,"connect to another mirror member. Normally these parameters"
	w !,"do not need to be modified and they do not affect the behavior of"
	w !,"a system once it has connected."
	w !
	i '+$G(^SYS("MIRRORSET")) s mirname=$p(^SYS("MIRRORSET"),"^",2) d ChangeOneMirror quit
top	r !!,"Enter mirror set name: (? for list, return for quit) ",mirname
	if mirname="?" w !!,"Mirror Set name is one of:",!,$p(^SYS("MIRRORSET"),"^",2) goto top
	if mirname="" quit
	if ","_$P(^SYS("MIRRORSET"),"^",2)_","'[(","_mirname_",")||(mirname[",") w "   does not exist!" g top
	d ChangeOneMirror
	g top
ChangeOneMirror ;
	s disable=$G(^MIRROR(mirname,"reconnect","disable"),0)  ;enabled
	s minreconnect=+$G(^MIRROR(mirname,"reconnect","mininterval"),60)  ;in seconds
	s longdelay=+$G(^MIRROR(mirname,"reconnect","longdelay"),300)  ;in seconds
	s fixeddelay=+$G(^MIRROR(mirname,"reconnect","fixeddelay"))
	s ssholdtime=$G(^MIRROR("MirrorStartupSSHoldTime"),10)  ;seconds
	s isFailoverNode='+$G(^SYS("MIRRORSET"))
	r !,"Change this? <No>"
	w !,"Reconnection parameters for mirror: ",mirname
	w !,?5,"Reconnection Disabled: ",$S(disable:"Yes",1:"No")
	w !,?5,"Minimum reconnect time: ",minreconnect
	w !,?5,"Long Delay time: ",longdelay
	w !,?5,"Fixed Reconnection Delay: ",fixeddelay
	w:isFailoverNode !,?5,"Superserver Hold Time for mirror startup: ",ssholdtime
	r !,"Change these parameters? <no> ",resp
	if "Yy"'[$E(resp_"N") quit
	w !,"Entering K/k for a value will delete it so it takes on its"
	w !,"'natural' default"
	r !,"Reconnection enabled (Kill/Yes/No)? <Kill> ",resp
	s x=$E(resp_"k")
	while "YyNnKk"'[x {
	   w !,"Invalid response - """,resp,""" - Enter one of Yes, No or Kill"
	   r !,"Reconnection enabled (Kill/Yes/No)? <Kill> ",resp
	   s x=$E(resp_"k")
	}
	if "Yy"[x {
		s ^MIRROR(mirname,"reconnect","disable")=0
	} elseif "Nn"[x {
		s ^MIRROR(mirname,"reconnect","disable")=1
	} else {  /* must be kill */
		k ^MIRROR(mirname,"reconnect","disable")
	}
	r !,"Minimum reconnect time? <Kill> ",resp
	if "Kk"[$E(resp_"K") {
		k ^MIRROR(mirname,"reconnect","mininterval")
	} else {
		s ^MIRROR(mirname,"reconnect","mininterval")=+resp
	}
	r !,"Long delay time? <Kill> ",resp
	if "Kk"[$E(resp_"K") {
		k ^MIRROR(mirname,"reconnect","longdelay")
	} else {
		s ^MIRROR(mirname,"reconnect","longdelay")=+resp
	}
	r !,"Fixed reconnect time? <Kill> ",resp
	if "Kk"[$E(resp_"K") {
		k ^MIRROR(mirname,"reconnect","fixeddelay")
	} else {
		s ^MIRROR(mirname,"reconnect","fixeddelay")=+resp
	}
	if isFailoverNode { 
	   r !,"Superserver Hold time for mirror startup? <Kill> ",resp
	   if "Kk"[$E(resp_"K") {
		  k ^MIRROR("MirrorStartupSSHoldTime")
	   } else {
		  s ^MIRROR("MirrorStartupSSHoldTime")=+resp
	   }
	}
	q
}
Reconfigure() PUBLIC {
	s isMirror=($SYSTEM.Mirror.GetInfo()[",DEFINED,")
	if 'isMirror {
		s mm=##class(Config.MirrorMember).Open()
		s ourname=mm.SystemName
		Set isMirror=(ourname'="")
		s mm=""
	}
	if 'isMirror {
		w !,"System is not configured as a mirror member"
		quit
	}
	Set isShadow = ##class(Config.MirrorMember).isAsyncMember()
	;
	if isShadow {
		do ReconfigureAsyncMember()
	} else {
		do ReconfigureFailoverMember()
	}
}
ReconfigureAsyncMember() {
 	s cmenu(1)="Stop tracking a mirror"
 	s cmenu(2)="Remove mirror configuration"
 	s cmenu(3)="Display Mirror Configuration"
 	for  {
	   s Value=""
	   s Status=##class(%Library.Prompt).GetMenu("Option?",.Value,.cmenu,.hmenu,8+128+4)
	   i (+Status=0)||(Status=2)||(Value="") q
	   i Value=1 d RemoveAsyncMemberSource() Continue
	   i Value=2 d RemoveMirrorConfig() continue
	   i Value=3 d DisplayConfig() continue
 	}
 	quit
}
ReconfigureFailoverMember() {
 	s cmenu(1)="Remove Other Mirror Member"
 	s cmenu(2)="Remove This failover member"
 	s cmenu(3)="Display Mirror Configuration"
 	for  {
	   s Value=""
	   s Status=##class(%Library.Prompt).GetMenu("Option?",.Value,.cmenu,.hmenu,8+128+4)
	   i (+Status=0)||(Status=2)||(Value="") q
	   i Value=1 d RemoveMirrorMember() continue
	   i Value=2 d RemoveMirrorConfig() continue
	   i Value=3 d DisplayConfig() continue
 	}
 	quit
}
DisplayConfig() {
	s mm=##class(Config.MirrorMember).Open()
	if '$IsObject(mm) {
		 w !,"Failed to open Config.MirrorMember - Config file requires updating" 
		 quit
	}
	s sysname=mm.SystemName
	if mm.AsyncMemberGUID'="" {
		s mm="",cnt=0
		s rs=##class(%Library.ResultSet).%New("Config.Mirrors:List")
		Do rs.Execute()
		While (rs.Next()) {
			s cnt=cnt+1
			s list(cnt)=rs.Data("Name")
		}
		s rs=""
		if cnt=1 s mirname=list(1) goto top
choose ;
		w !,"There are ",cnt," mirror sets tracked:"
		for i=1:1:cnt w !,i,")",?5,list(i)
		r !,"Enter mirror set name to be displayed: ",mirname
		if mirname="" quit
		if mirname?.N {
			if '$d(list(mirname),mirname) w !,"Item #",mirname," does not exist." goto choose
			w "  ",mirname,!
		} else {
			s mirname=$ZCVT(mirname,"U")
			for i=1:1:cnt q:list(i)=mirname
			if list(i)'=mirname {
				w !,"""",mirname,""" is not a mirror set being tracked."
				goto choose
			}
		}
	} else {
		s mm=""
		s mirname=##class(Config.Mirrors).GetMirrorName()
		if mirname="" {
			w !,"No mirror defined, can't change modify data"
			quit
		}
	}
top ;
	k list
	k params
	s rc=##class(Config.Mirrors).Get(mirname,.params)
	if ('rc) {
	 	k err
    	Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
		w !,"Failed to read mirror parameters for ",mirname,": "
		for i=1:1:err w !,?5,err(i)
		quit
	}
	if $d(params("AllowParallelDejournaling"),dejrnmode) {
		s params("AllowParallelDejournaling")=$case(dejrnmode,0:"Failover Members and DR",1:"Failover Members Only",2:"All Members",:"Unknown")
	}
	w !!,"Parameters for mirror: ",mirname
	do dumpparams(.params)
	;
	k params
	s rc=##class(Config.MirrorMember).Get(.params)
	if ('rc) {
	 	k err
    	Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
		w !,"Failed to read mirror member parameters:"
		for i=1:1:err w !,?5,err(i)
		quit
	}
	w !!,"Mirror member parameters:"
	k params("AgentAddress")  ;don't display this, its obsolete
	do dumpparams(.params)
	;
 	Set rs=##class(%Library.ResultSet).%New("Config.MapMirrors:List")
 	s rc=rs.Execute(mirname)
 	if rc {
 	   While (rs.Next()) {
	      Set name=rs.Data("Name")
	      q:name=""  ;exit loop if we get a null name
	      if rs.Data("MemberType")'=0 continue
	      k params
	      s x=##class(Config.MapMirrors).Get(mirname,name,.params)
		  if ('x) {
		 	 k err
    		 Do DecomposeStatus^%apiOBJ(x,.err,"-d") 
			 w !,"Failed to read MapMirrors.",mirname," info for: ",name
			 for i=1:1:err w !,?5,err(i)
			 quit
		  }
		  w !!,"Mirror set member information for ",name
		  ; We want the ECPAddress property called superserver Address
		  s params("SuperServerAddress")=params("ECPAddress")
		  k params("ECPAddress")
		  k params("PreferredArbiter")
		  k params("ConnectsTo")
		  do dumpparams(.params)
 	   }
 	}
    w !
}
dumpparams(params) {
	s maxlen=32  ;we'd like 32 but if there's a longer field, we'll
	             ;adjust this up.
	s i=""
	for  s i=$O(params(i)) quit:i=""  if $L(i)>maxlen s maxlen=$L(i)
	;
	s i=$O(params(""),1,v)
	while (i'="") {
		w !,?5,$J(i,maxlen)," = "
		if $ISVALIDNUM(v) {
			w v
		} else {
			w """",v,""""
		}
		s i=$O(params(i),1,v)
	}
}
ManageDejournaling() {
	s $zt="err"
	i '$SYSTEM.Security.Check("%Admin_Operate","USE") w !,"Operation requires %Admin_Operate:Use privilege" q
	if '$System.Mirror.IsAsyncMember() {
		w !,"This option is only available on async mirror members"
	}
	s cnt=$$getAsyncMemberSources(.names)
	if 'cnt {
		w !,"No Async member sources defined"
		quit
	}
listMirrors ;
	w !,"Mirror",?20,"Dejournaling Status"
	w !,"---------------",?20,"-------------------"
	s namelist=","
	for i=1:1:cnt {
		   s mirname=names(i)
		   s namelist=namelist_mirname_","
		   s status=##class(SYS.MirrorConfiguration).GetDejournalStatusMsg(mirname)
		   w !,mirname,?20,status
	}
	if (cnt=1) {
		w !,"Change dejournaling status of ",names(1),"? <No> "
		r resp
		quit:"Yy"'[$E(resp_"X")
		s resp=names(1)
	} else {
		r !,"Change dejournaling status of which member (return to exit)? ",resp
		quit:resp=""
		if resp="?" goto listMirrors
		s mirname=","_$zcvt(resp,"U")_","
		while (resp'="") && (resp'="?") && (namelist'[mirname) {
			w !,resp," is not a mirror this instance is tracking"
			r !,"Change dejournaling status of which member (return to exit)? ",resp
			s mirname=","_$zcvt(resp,"U")_","
		}
		quit:resp=""
		if resp="?" goto listMirrors
	}
	s mirname=$zcvt(resp,"U")
    s status=##class(SYS.MirrorConfiguration).GetDejournalStatus(mirname)
	w !,"Current status is ",status
	do {
		if status="running" {
			w !,"Are you sure you want to stop dejournaling for ",mirname," now? "
		} else {
			w !,"Are you sure you want to start dejournaling for ",mirname," now? "
		}
		r resp
	} while "YyNn"'[$E(resp_"X")
	q:"Nn"[$E(resp)
	if status="running" {
		s rc=##class(SYS.MirrorConfiguration).DejournalStop(mirname)
		s verb="stopp"
	} else {
		s rc=##class(SYS.MirrorConfiguration).DejournalStart(mirname)
		s verb="start"
	}
	if (''rc) {
		w !,"....",verb,"ed"
	} else {
	 	k err
    	Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
		w !,"Error ",verb,"ing dejournaling for ",mirname,":"
		w !,?5,err(1)
	}
	quit		
err	;
	s $zt=""
	w !,"Unexpected error: ",$ze
	quit
}
SetupMirror(Type) {
	s $zt="err"
	if 0 w !!,"Managed by Enterprise Manager, operation not allowed." Quit
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
	; Mirroring requires the MirrorService, check that its
	; enabled and offer to enable it if it isn't.
	s x=##class(Security.Services).%OpenId($ZCVT("%Service_Mirror","L"),,.rc)
 	if ('rc) {
	 	k err
    	Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
    	w !,"Failed to check status of MirroringingService: ",err(1)
    	Quit
 	} else {
	 	if 'x.Enabled {
		 	w !,"%Service_Mirror is required for Mirroring."
		 	w !,"You have to enable %Service_Mirror in order to continue."
		 	r !,"Do you want to enable it now? <Y> ",resp
		 	if "Nn"'[$E(resp_"y") {
			 	s x.Enabled=1
			 	s rc=x.%Save()
			 	if 'rc { w !,"Failed to enable Mirror Service" Quit}
		 	} else {
			 	w !,"Service not enabled." Quit
			}
		}
 	}
 	s x=""
 	if Type=3||(Type=4) goto retrieve
 	if Type=0||(Type=1) {
	 	s rc=##class(SYS.Mirror).CheckISCAgent()
	 	if '(''rc) {
		 	w !,"ISCAgent check failed, error = ",$SYSTEM.Status.GetErrorText(rc)
		 	quit
	 	}
 	}
GetMirrorName	;
	r !,"Mirror Set Name: ",resp
	while ($L(resp)>15) || (resp'?1.(1A,1N)) {
		w !,"Mirror Set Name is limited to ",15," alphanumeric characters."
	    r !,"Mirror Set Name: ",resp
	}
	s mirname=$zcvt(resp,"U")
	if mirname="" Quit
	;
	s mm=##class(Config.Mirrors).Open(mirname)
	if $isobject(mm) s mm="" w !,"The Mirror Set name ",mirname," already existed." Goto GetMirrorName
	;
	Set sslc=##class(Security.SSLConfigs).%OpenId("%MirrorClient",,.status)
	Set ssls=##class(Security.SSLConfigs).%OpenId("%MirrorServer",,.status)
	s sslconfigured=$isobject(sslc)||$isobject(ssls)
 	if Type goto retrieve
	; We're creating a new mirror, check whether we have ssl configs. If not
	; remind the user that SSL is recommended and ask if they want to pause
	; and go create them.
	s JRNEncrypted=##class(%SYS.Journal.System).IsJournalEncryptionEnabled(3)
	If JRNEncrypted {
		w !!,"Journal encryption is enabled, UseSSL will be set automatically."
		Set resp=1
		Goto doSSL
	}
RetrySSL ;
	if JRNEncrypted {
		w !!,"SSL configuration failed. Abort!" Quit
	}
	w !,"The use of SSL for mirroring is strongly recommended due to the"
	w !,"nature of what mirror members can ""do"" to each other."
	w !,"This requires two SSL configurations on each failover mirror member:"
	w !,"    SSL Client configuration: %MirrorClient"
	w !,"    SSL Server configuration: %MirrorServer"
	w !,"both configurations should use the same X.509 Credentials, they"
	w !,"differ only in the client/server designation"
	w !!,"Do you want to use SSL for the Mirror? <Y> " r resp
	s resp=$S("Nn"[$E(resp_"Y"):0,1:1)
doSSL ;
	if resp {
		if 'sslconfigured {
			w !,"Mirror SSL is not set up, setting up the mirror SSL now."
			if '$$SetupSSL() Goto RetrySSL
		} else {
			if $isobject(sslc)&&'sslc.Enabled s sslc.Enabled=1 s rc=sslc.%Save()
			if $isobject(ssls)&&'ssls.Enabled s ssls.Enabled=1 s rc=ssls.%Save()
			if '$isobject(sslc) w !,"%MirrorClient SSL configuration does not exist, could not use SSL for mirror." G RetrySSL
			if '$isobject(ssls) w !,"%MirrorServer SSL configuration does not exist, could not use SSL for mirror." G RetrySSL
        }
	    s clientcn=$$GetSSLDNField^MIRRORCTL("client")
	    if '$LG(clientcn) {
		    w !,"Error getting SSL DN name in %MirrorClient: ",$LG(clientcn,2)
		    goto RetrySSL
	    }
	    s servercn=$$GetSSLDNField^MIRRORCTL("server")
	    if '$LG(servercn) {
		    w !,"Error getting SSL DN name in %MirrorServer: ",$LG(servercn,2)
		    goto RetrySSL
	    }
	    s clientcn=$LG(clientcn,2)
	    s servercn=$LG(servercn,2)
	    if servercn'=clientcn {
		    w !,"SSL config error: Names in Server and client configurations are different"
		    w !,"   server: ",servercn
		    w !,"   client: ",client
		    goto RetrySSL
	    }
	}
	s MirrorInfo("UseSSL")=resp
	r !,"QOS Timeout (msec)? <8000> ",resp
	if '+resp s resp=8000
	s MirrorInfo("QOSTimeout")=resp
	;
	s arbiterok=0
	do {
		r !,"Address of the arbiter node? ",arbiteraddr
		while (arbiteraddr'="") {
			s rc=##class(Config.Mirrors).ValidateArbiterAddress(arbiteraddr)
			q:(''rc)
			w !,$SYSTEM.Status.GetErrorText(rc)
			r !,"Enter an address for the arbiter: ",arbiteraddr
		}	
		if arbiteraddr="" {
			w !,"The use of an arbiter node is strongly recommended."
			r !,"Do you want to configure the mirror without an arbiter? <N> ",resp
			if "Yy"[$E(resp_"X") s arbiterok=1
		}
	} while ((arbiteraddr="") && (arbiterok=0))
	if (arbiteraddr '= "") {	
		r !,"Arbiter port? <2188> ",arbiterport
		if arbiterport="" s arbiterport=2188
		s MirrorInfo("ArbiterNode")=arbiteraddr_"|"_arbiterport
	} else {
		s MirrorInfo("ArbiterNode")=""
	}
	while (1) {
		r !,"Mirror Virtual IP address: ",resp
		if resp="" quit  ;If no VIP entered, quit. VIP is not required
		s err="",type="",ipOut=""
		s rc=##class(SYS.MirrorConfiguration).ValidateVirtualAddress(resp)
		if 'rc {  ;Want IP only (for now). Will add FQDN later...
			k err
			Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
			write !,$G(err(1))
			continue	
		}
		w !,?5,"Checking if IP exists..."
		if $System.INetInfo.CheckAddressExist($p(resp,"/")) {
			write !,?5,"IP address already exists. Cannot use it for Virtual IP."
			continue	
		}
		w " - IP does not exist. It can be used as Virtual IP address!"
		quit  ;exit loop 
	}	
	s MirrorInfo("VirtualAddress")=resp  ;Null, or validated
	if resp'="" {
		s VIPInterface=$$getVirtualAddressInterface(resp)
		if VIPInterface="" quit
		s MirrorInfo("VirtualAddressInterface")=VIPInterface
	}
	/* SML1836, don't need this.
	if MirrorInfo("UseSSL") {
		r !,"Do you want to add names of authorized Async members? <N> ",resp
		if "Yy"[$E(resp_"n") {
#;SML1552
			do ManageAuthorizedAsyncMembers(1)
		}
	}
	*/
	while (1) {
		w !,"Enter compression mode for Failover members."
		r !,"0 -> System Selected, 1 -> Uncompressed, 2 -> Compressed <0>? ",resp
		if resp="" s resp=0 quit
		if resp>=0,resp<=2 quit
		w "   please enter 0, 1 or 2."
	}
	s MirrorInfo("CompressionForFailoverMembers")=+resp
	if +resp=2 {
		while (1) {
			w !,"Enter compression type."
			r !,"0 -> ZLIB, 1 -> ZSTD, 2 -> LZ4 <0>? ",resp
			if resp="" s resp=0 quit
			if resp>=0,resp<=2 quit
			w "   please enter 0, 1 or 2."
		}
		s MirrorInfo("CompressionTypeForFailoverMembers")=+resp
	} else {
		s MirrorInfo("CompressionTypeForFailoverMembers")=0
	}
	while (1) {
		w !,"Enter compression mode for Async members."
		r !,"0 -> System Selected, 1 -> Uncompressed, 2 -> Compressed <0>? ",resp
		if resp="" s resp=0 quit
		if resp>=0,resp<=2 quit
		w "   please enter 0, 1 or 2."
	}
	s MirrorInfo("CompressionForAsyncMembers")=+resp
	if +resp=2 {
		while (1) {
			w !,"Enter compression type."
			r !,"0 -> ZLIB, 1 -> ZSTD, 2 -> LZ4 <0>? ",resp
			if resp="" s resp=0 quit
			if resp>=0,resp<=2 quit
			w "   please enter 0, 1 or 2."
		}
		s MirrorInfo("CompressionTypeForAsyncMembers")=+resp
	} else {
		s MirrorInfo("CompressionTypeForAsyncMembers")=0
	}
	while (1) {
		w !,"Enter 'Allow Parallel Dejournaling' setting."
		r !,"0 -> Failover Members and DR, 1 -> Failover Members Only, 2 -> All Members<0>? ",resp
		if resp="" s resp=0 quit
		if resp>=0,resp<=2 quit
		w "   please enter 0, 1 or 2."
	}
	s MirrorInfo("AllowParallelDejournaling")=+resp
	s SystemName=$$GetLocalMirrorInfo(.MirrorInfo,1)
	w !,"Are you sure you want to create Mirror Set '",mirname,"'? <Y> " r resp
	s resp=$S("Nn"[$E(resp_"Y"):0,1:1)
	quit:'resp
	s rc=##class(SYS.Mirror).CreateNewMirrorSet(mirname,SystemName,.MirrorInfo)
	i ('rc) {
		w !,"Failed to create new mirror set '",mirname,"'."
		w !," Error:",$SYSTEM.Status.GetErrorText(rc)
	} else {
		w !,"Mirror set '",mirname,"' successfully created!"
	}
	quit
retrieve ;
 	while (1) {
	 	set ipToUse=""
	 	if Type=4 {
		 	w !,"Network address of superserver of the async member? "
	 	} else {
		 	w !,"Network address of agent job of ",$s(Type=3:"failover",1:"primary")," member? "
	 	}
	 	r ipaddr
		if '##class(SYS.MirrorConfiguration).IsIPFormatValid(ipaddr,.type) {  ;Allow hostname 
			write !,?5,"Invalid IP address entered."
			continue	
		}
		if type="HOST" {
			set ipToUse=$$convHostToIP(ipaddr)
			if ipToUse="" {
				write !,?5,"Could not resolve host "_ipaddr_" to IP address."
				continue
			}
		}
		else {
			set ipToUse=ipaddr	
		}
		if '$System.INetInfo.CheckAddressExist(ipToUse) {
			write !,?5,"IP address ("_ipToUse_") is not reachable from this machine."
			continue	
		} 
		quit
 	}
 	set ipaddr=ipToUse
 	if Type=4 {
	 	w !,"Port of superserver of the async member? <",1972,"> "
 	} else {
	 	w !,"Port of agent job of ",$s(Type=3:"failover",1:"primary")," member? <",2188,"> "
 	}
 	r port
	if port="" s port=$s(Type=4:1972,1:2188)
	if Type=4 {
		s mirname=##class(Config.Mirrors).GetMirrorName()
		if mirname="" {
			w !,"No mirror defined, can't add new async member."
			quit
		}
		s rc=$$GetMemberConfigData^MIRRORCTL(mirname,ipaddr_"|"_port,"","","**")
		if '+$LG(rc) {
			w !,"Failed to retrieve member's information. Error=",$LG(rc,2)
			quit
		}
		s info=$LG(rc,3)  ;list of $LIST(name,<list of key/value pairs>)
		if info="" w !,"Remote member does not exist or is not an async member." q
		s MapMirrors("Name")=$LG(info,1)
		s data=$lg(info,2)
		s len=$LL(data)
		for i=1:1:len {
			s item=$LG(data,i)
			s p=$LG(item,1)
			s v=$LG(item,2)
			s MapMirrors(p)=v
		}
		m params=MapMirrors
		s params("MemberType")=$case(MapMirrors("MemberType"),0:"Failover",2:"Async",:"Unknown")
		; We want the ECPAddress property called superserver Address
		s params("SuperServerAddress")=$G(params("ECPAddress"))
		k params("ECPAddress")
		k params("PreferredArbiter")
		k params("ConnectsTo")
		w !!,"Properties for member '",MapMirrors("Name"),"':"
		do dumpparams(.params)
		w !
		i $$YN("Are you sure you want to add this new async member '"_MapMirrors("Name")_"'","N")="N" {
			w !,"Aborted" 
			q
		}
		s rc=##class(Config.MapMirrors).Create(mirname,MapMirrors("Name"),.MapMirrors)
		if ('rc) {
			w !,"Failed to add new member '",MapMirrors("Name"),"'. Error=",$SYSTEM.Status.GetErrorText(rc)
		} else {
			w !,"New member '",MapMirrors("Name"),"' is added."
			d ##class(SYS.Mirror).RemoveFromApprovalList(MapMirrors("Name"),MapMirrors("GUID"))
		}
		q
	}
	w !,"Instance name of the ",$s(Type=3:"failover",1:"primary")," member? " r InstanceName
	s InstanceName=$zcvt(InstanceName,"U")
	if Type=3 {
		s rc=##class(SYS.Mirror).AddFailoverMember(,InstanceName,ipaddr,port)
		i ('rc) {
			w !,"Failed to add failover member. Error: ",$SYSTEM.Status.GetErrorText(rc)
		} else {
			w !,"Add failover member succeeded!"
		}
		quit
	}
	Set tObj = ##class(SYS.MirrorConfiguration).RetrieveMirrorConfig(mirname, ipaddr, port, InstanceName, .status)
	if ('status) {
		w !,"Failed to contact the primary member. Error:",$SYSTEM.Status.GetErrorText(status)
		quit
	}
	;AsyncMemberType and SystemName are filled in by GetLocalConfigInfo()
	;GetLocalConfigInfo() may also change the sslconfigured value and adds the local
	; system info to the MirrorInfo() array.
	; AsyncMemberType is also passed as input to indicate whether this system is already
	;   an async member or not (GetLocalConfigInfo wants to ask what kind of member this should be)
	s AsyncMemberType=$SYSTEM.Mirror.AsyncMemberType()
	s primaryInfo=$LB(ipaddr, port, InstanceName)
	s ok=$$GetLocalConfigInfo(Type,tObj,primaryInfo,.sslconfigured,.SystemName,.MirrorInfo,.AsyncMemberType)
	if 'ok quit
	w !,"Are you sure you want to join Mirror Set '",mirname,"' as ",$s(Type=1:"failover",1:"async")," member? <Y> " r resp
	s resp=$S("Nn"[$E(resp_"Y"):0,1:1)
	quit:'resp
	if Type=1 {
		s rc=##class(SYS.Mirror).JoinMirrorAsFailoverMember(mirname,SystemName,InstanceName,ipaddr,port,.MirrorInfo)
	} else {
		s rc=##class(SYS.Mirror).JoinMirrorAsAsyncMember(mirname,SystemName,InstanceName,ipaddr,port,AsyncMemberType,.MirrorInfo)
	}
	i ('rc) {
		w !,"Failed to join mirror set '",mirname,"' as ",$s(Type=1:"failover",1:"async")," member."
		w !," Error:",$SYSTEM.Status.GetErrorText(rc)
	} else {
		w !,"Joining Mirror set '",mirname,"' as ",$s(Type=1:"failover",1:"async")," succeeded!"
	}
	if tObj.UseSSL&&(Type=1)&&('('rc)) w !,"Don't forget to authorize this node to join the configuration on the primary member."
	quit
err ;
	s $zt=""
	w !,"Unexpected error: ",$ze
	quit 0
}
GetLocalConfigInfo(Type,tObj,primaryInfo,sslconfigured,SystemName,MirrorInfo,AsyncMemberType) {
    ;sslconfigured, MirrorInfo are input/output variables passed by reference 
    ;SystemName is an output variable passed by reference
    ;AsyncMemberType (passed by ref) is 0 if the system is not currently an async member and
    ;      will be set on output. If non-zero, the system is currently an async member
    ;tObj is a Config.Mirrors object
    ;Type is the argument to SetupMirror()
    ;    ;
    ; Returns: 0 - abort, 1 - continue
    ;
	s ipaddr=$LG(primaryInfo,1)
	s port=$LG(primaryInfo,2)
	s InstanceName=$LG(primaryInfo,3)
	if tObj.UseSSL {
		if 'sslconfigured {
			w !,"The primary member has UseSSL set, so you need to setup Mirror SSL configuration"
			w !,"before you could join the mirror set."
			w !,"Setting up the Mirror SSL configuration now:"
			if '$$SetupSSL() w !,"Mirror SSL configuration must be setup before the mirror configuration is setup." Quit
			s sslconfigured=1
		}
		w !
		w !,"After adding this instance you need to authorize it as a mirror member"
		w !,"on the primary. Pending authorizations are managed using the Edit Mirror"
		w !,"page or using the ^MIRROR Mirror Configuration->Authorize/reject pending"
		w !,"new members option"
		w !
	}
	if Type=2 {
		s MirrorInfo("EncryptCommunication")=0
		if 'AsyncMemberType {
			s resp=-1
			while (resp'?1N||(resp<0||(resp>2))) {
				w !!,"0 - Disaster Recovery.",!,"1 - Read-Only Reporting.",!,"2 - Read-Write Reporting."
				r !!,"Enter Async Member Type <0>: ",resp
				s:resp="" resp=0
				s rc=##class(SYS.Mirror).CheckISCAgent()
				if resp=0,'(''rc) {
					w !,"DR is not allowed to join becasue of ISCAgent check error: ",$SYSTEM.Status.GetErrorText(rc)
					s resp=-1
				}
			}
			s AsyncMemberType=resp
		} else {
			s AsyncMemberType=1
		}
		s SystemName=$$GetLocalMirrorInfo(.MirrorInfo,AsyncMemberType=0)
	} else {
		s SystemName=$$GetLocalMirrorInfo(.MirrorInfo,1)
	}
	if tObj.VirtualAddress'=""&&(Type=1||(AsyncMemberType=0)) {
		s VIPInterface=$$getVirtualAddressInterface(tObj.VirtualAddress)
		if VIPInterface=""&&(Type=1) quit 0
		s MirrorInfo("VirtualAddressInterface")=VIPInterface
	}
	if tObj.UseSSL {
		s RetrieveInfo=$LB(SystemName,+$G(AsyncMemberType)'=0,InstanceName,ipaddr,port)
		s mirname=tObj.Name
		w !!,"Verifying Mirror SSL Certificates..."
		s rc=##class(SYS.MirrorConfiguration).VerifyMirrorSSLCertificates(mirname,0,RetrieveInfo)
		if '(''rc) {
			s ErrCodes=$SYSTEM.Status.GetErrorCodes(rc)
			s ok=1,numerr=$l(ErrCodes,",")
			for i=1:1:numerr if $p(ErrCodes,",",i)'=737 s ok=0 q
			w !,"Mirror SSL certificates verification returned the following errors:",!
			d $SYSTEM.Status.DisplayError(rc)
			w !
			if ok {
				w !,"The error",$s(numerr=1:" is",1:"s are")," due to other mirror member",$s(numerr=1:" is",1:"s are")," not reachable, you can still join the mirror.",!
			} else {
				w !,"There ",$s(numerr=1:"is",1:"are")," real certificate error",$s(numerr=1:"",1:"s")," you need to fix ",$s(numerr=1:"it",1:"them")," before you can join the mirror.",!
				quit 0
			}
		}
	}
	quit 1
}
EditVIP() {
	if 0 w !!,"Managed by Enterprise Manager, operation not allowed." Quit
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
	s mm=##class(Config.MirrorMember).Open()
	s mirname=##class(Config.Mirrors).GetMirrorName()
	if mirname="" {
		w !,"No mirror defined, can't change VIP address"
		quit
	}
	s mir=##class(Config.Mirrors).Open(mirname)
	if '$IsObject(mir) {
		 w !,"Failed to open Config.Mirrors(",mirname,") - Config file requires updating" 
		 quit
	}
	if +$G(^SYS("MIRRORSET",mirname,"Member"))>0 {
		; we're member #0, the other failover node is #1
		s info=$G(^SYS("MIRRORSET",mirname,"Member",1))
		s othername=$LG(info,1) ;name of the other failover node
	}
	s vipchanged=0
	s vip=mir.VirtualAddress
	if $SYSTEM.Mirror.IsBackup() {
		w !!,"Current Virtual Address is: ",$s(vip="":"Not Configured",1:vip)
		w !,"Virtual Address can only be changed on the primary."
		s nvip = vip
		g interface
	}
vip	w !!,"New Virtual Address (address/CIDR mask)? "
	if vip'="" {
		w "(enter '-' to remove it) <"_vip_"> " 
	} else {
		w "<quit> "
	}
	r nvip
	i nvip="" s nvip=vip
	i nvip="-" s nvip="" i vip'="" s vipchanged=1
	i nvip'=vip&&(nvip'="") {
		s vipchanged=$s($p(nvip,"/")'=$p(vip,"/"):1,1:2)
	}
interface ;
    s virtualinterfaceupdated=0
	if nvip'="" {
		s virtualinterface=mm.VirtualAddressInterface
		if virtualinterface="" {
			w !,"Must define an interface to host the virtual address"
			s resp="Y"
		} else {
		    w !,"Current interface for the virtual address is: ",virtualinterface
		    w !,"Do you want to change this? "
		    if vipchanged {
		       w "<Yes> " s def="Y"
		    } else {
			   w "<No> " s def="N"
		    }
		    r resp
		    if "Yy"[$E(resp_def) s resp="Y"
		}
		if resp="Y" {
			s resp=$$getVirtualAddressInterface(nvip)
			if resp'="" {
				s mm.VirtualAddressInterface=resp
				s virtualinterfaceupdated=1
			} elseif virtualinterface="" {
				s vipchanged=0
				If $SYSTEM.Mirror.IsPrimary() g vip	
			}
		}
		if vipchanged||(virtualinterface'=mm.VirtualAddressInterface) {
			s rc=##class(SYS.MirrorConfiguration).ValidateVirtualAddress(nvip,$s($SYSTEM.Mirror.GetInfo()["PRIMARY"&&(vipchanged=1):1,1:0),mm.VirtualAddressInterface)
			if 'rc {  ;Want IP only (for now). Will add FQDN later...
				k err
				Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
				write !,$G(err(1))
				s vipchanged=0,mm.VirtualAddressInterface=virtualinterface
				If '$SYSTEM.Mirror.IsPrimary() g interface	
				g vip	
			}
		}
	} else {
		if mm.VirtualAddressInterface'="" {
			if vipchanged {
			 	s mir.VirtualAddress=nvip
			 	s rc=mir.%Save()
			 	if (''rc) {
				 	w !,"Virtual Address updated."
				 	w:$g(othername)'="" !,"*** Don't forget to also update the address on (",$g(othername),")."
			 	} else {
				 	k err
				 	Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
				 	w !,"Error updating Mirror Virtual Address(",$G(err(1)),")"
			 	}
		 	}
		   s mm.VirtualAddressInterface=""
		   s virtualinterfaceupdated=1
		}
	}
	if (virtualinterfaceupdated) {
	   if $SYSTEM.Mirror.GetInfo()["PRIMARY" && (nvip="") && vipchanged {
	      for i=1:1:10 q:'$System.INetInfo.CheckAddressExist($p(vip,"/"))  h .5
	   }
	   s rc=mm.%Save()
	   if (''rc) {
		   w !,"Virtual Address Interface updated"
	   } else {
		 	k err
		 	Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
		 	w !,"Error updating Mirror Member info (",$G(err(1)),") - Virtual address interface not changed"
	   }
	}
	s mm=""
	if vipchanged&&(nvip'="") {
	 	s mir.VirtualAddress=nvip
	 	s rc=mir.%Save()
	 	if (''rc) {
		 	w !,"Virtual Address updated."
		 	w:$g(othername)'="" !,"*** Don't forget to also update the address on (",$g(othername),")."
	 	} else {
		 	k err
		 	Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
		 	w !,"Error updating Mirror Virtual Address(",$G(err(1)),")"
	 	}
 	}
}
DisplayMembers(mirname,list) {
	k list
    Set rs=##class(%Library.ResultSet).%New("Config.MapMirrors:List")
    s rc=rs.Execute(mirname)
    if 'rc {
 	    w !,"Failed to retrieve list of mirror members for",mirname
 	    quit
    }
    w !
    While (rs.Next()) {
        Set name=rs.Data("Name")
        s list($i(list))=name
        w !,list,")",?5,name
    }
    d rs.Close()
    quit
}
EditNetworkAddresses() {
	if 0 w !!,"Managed by Enterprise Manager, operation not allowed." Quit
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
	s mm=##class(Config.MirrorMember).Open()
	if '$IsObject(mm) {
		 w !,"Failed to open Config.MirrorMember - Config file requires updating" 
		 quit
	}
	s sysname=mm.SystemName
	if mm.AsyncMemberGUID'="" {
		s mm="",cnt=0
		s rs=##class(%Library.ResultSet).%New("Config.Mirrors:List")
		Do rs.Execute()
		While (rs.Next()) {
			s cnt=cnt+1
			s list(cnt)=rs.Data("Name")
		}
		s rs=""
		if cnt=1 s mirname=list(1) goto topx
choose ;
		w !,"There are ",cnt," mirror sets tracked:"
		for i=1:1:cnt w !,i,")",?5,list(i)
		r !,"Enter mirror set name to be modified: ",mirname
		if mirname="" quit
		if mirname?.N {
			if '$d(list(mirname),mirname) w !,"Item #",mirname," does not exist." goto choose
			w "  ",mirname,!
		} else {
			s mirname=$ZCVT(mirname,"U")
			for i=1:1:cnt q:list(i)=mirname
			if list(i)'=mirname {
				w !,"""",mirname,""" is not a mirror set being tracked."
				goto choose
			}
		}
	} else {
		s mm=""
		s mirname=##class(Config.Mirrors).GetMirrorName()
		if mirname="" {
			w !,"No mirror defined, can't change modify data"
			quit
		}
	}
	k list
topx ;
	If '$SYSTEM.Mirror.IsPrimary() {
		if $SYSTEM.Mirror.ConnectedToPrimary(mirname) {
			if $SYSTEM.Mirror.IsBackup() w !,"This member is the backup. Changes must be made on the primary." quit
			w !,"This member is connected. Changes must be made on the primary."
			quit
		}
		if +$G(^SYS("MIRRORSET")) {
			w !!,"This member is not connected. If the network addresses of the primary have"
			w !,"changed, ensure that the addresses for all members are correctly configured"
			w !,"on the primary, then update the primary's current addresses here."
			w !,"Once connected, this member will automatically update all addresses to match"
			w !,"the primary's configuration."
		} else {
			w !!,"This member is neither primary nor backup. If the network addresses of the"
			w !,"other failover member have changed, and it is running as primary, ensure that"
			w !,"the addresses for all members are correctly configured on the primary,"
			w !,"then update the primary's current addresses here. Otherwise, update the"
			w !,"addresses of all members here as required. On connecting, the backup and async"
			w !,"members automatically update all addresses to match the primary's configuration."
		}
		r !,"Press <enter> to continue...",resp
	} else {
		w !!,"This member is the primary. Changes will be sent to other members."
	}
top ;
	do DisplayMembers(mirname,.list)
	w !!,"Member to edit? (^ to exit) <",sysname,"> "
	r resp
	if resp="^" quit
	if resp="" {
		s resp=sysname
	} elseif resp?.N {
		if '$d(list(resp),resp) w !,"Item #",resp," does not exist." goto top
		w "  ",resp,!
	} else {
	 	s resp=$zcvt(resp,"U")
	}
	s localsystem = (resp=sysname)
	s ok=$$GetNewNetworkAddresses(mirname,resp,localsystem) ;SML2242
	if 'ok goto top
	quit
}
GetNewNetworkAddresses(mirname,member,localsystem) {
	s changed=0
	s mm=##class(Config.MapMirrors).Open(mirname,member,,,.rc)
	if '$IsObject(mm) {
	    k err
	    Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
		w !,"Failed to open Config.MapMirrors("""_mirname_""","""_member_""") - Error = "_$G(err(1)) 
		quit 0 ; failure
	}
    s def=mm.AgentAddress
    s resp=$$getAddress("Agent Address",def)
	if resp'=""&&(resp'=def) {
 	   s changed=1
	   s mm.AgentAddress=resp
	}
	s def=mm.AgentPort
	w !,"Agent Port <"_def_"> " 
	r resp
	if resp'=""&&(resp'=def) {
		s changed=1
		s mm.AgentPort=resp
	}
	s def=mm.MirrorAddress
    s resp=$$getAddress("Mirror Private Address",def)
	if resp'=""&&(resp'=def) {
		s changed=1
		s mm.MirrorAddress=resp
	}
	Set PortDisable=0,SSPortChanged=0
	if $SYSTEM.Mirror.IsPrimary(),'localsystem {
		Set clientcnt=$SYSTEM.Mirror.ClientQuery()
		For id=1:1:clientcnt {
			Set meminfo=$SYSTEM.Mirror.ClientQuery(id)
			If +meminfo,$P(meminfo,",",2)=mm.Name,$P(meminfo,",",3)="Active"||($P(meminfo,",",3)="Catchup") {
				Set PortDisable = 1
				Quit
			}
		}
	}
	if PortDisable {
		w !,"Editing superserver Port '",mm.MirrorSSPort,"' is not allowed because member"
		w !,"  '",mm.Name,"' is currently connected to this primary member."
	} else {
		if localsystem {
			w !,"WARNING!!! This is for local member, changing superserver Port of the mirroring"
			w !,"  also updating system's superserver Port."
			s startup=##class(Config.Startup).Open()
			s def=startup.DefaultPort
		} else {
			s def=mm.MirrorSSPort
		}
		w !,"Superserver Port <"_def_"> " 
		r resp
		if resp'=""&&(resp'=def) {
			s changed=1
			s mm.MirrorSSPort=resp
			if localsystem {
				s startup.DefaultPort = resp
				s SSPortChanged=1
			}
		}
	}
	s def=mm.ECPAddress
    s resp=$$getAddress("Superserver Address",def)
	if resp'=""&&(resp'=def) {
		s changed=1
		s mm.ECPAddress=resp
	}
	if 'changed quit 0  ;no changes
	w !!,"New settings:"
	w !,"Agent Address:  ",mm.AgentAddress,"|",mm.AgentPort
    w !,"Mirror Private Address: ",mm.MirrorAddress,"|",mm.MirrorSSPort
    w !,"Superserver Address:    ",mm.ECPAddress,"|",mm.MirrorSSPort
    r !,"Save changes? ",resp
    while "YyNn"'[$E(resp_"X") {
	    w !,"Please enter yes or no"
	    r !,"Save changes? ",resp
    }
    if "Yy"[$E(resp_"X") {
	    s rc=mm.%Save()
   	 	if (''rc) {
		    w !,"Saved"
		    s rc=1
		    if SSPortChanged {
				s rc=startup.%Save()
				if 'rc {
					w !,"Failed to save Config.Startup class, error=",$SYSTEM.Status.GetErrorText(rc)
				}
		    }
   	 	} else {
    	 	w !,"Failed to save changes"
    	 	s rc=0
   	 	}
    } else {
	    w !,"Changes discarded"
	    s rc=0
    }
	s mm=""
	quit rc
}
getAddress(prompt,default) {
	; Ask the user to enter a network address and validate
	; it and if it doesn't exist, ask them if they really want
	; to use it.
	;
	; If a default is supplied then we accept <RET> (null) as an answer.
	;
	; Returns:
	;      null - use the default
	;      <all else> - answer
	while (1) {
	   w !,prompt,"?"
	   if default'="" {
		   w " <"_default_">"
	   }
	   w " " 
	   r resp
	   if default'="",resp="" {
		   quit  ;exit while loop & return "" to use the default
	   }
	   s rc=##class(SYS.MirrorConfiguration).IsIPFormatValid(resp, .IPType, 0)
	   if (''rc) {
		   if IPType="HOST" {
			   set ipToUse=$$convHostToIP(resp)
			   if (ipToUse="") {
				   write !,"Error: Host ",resp," does not resolve to IP address"
				   continue	
			   }
		   } else {
			   set ipToUse=resp	
		   }
           if $System.INetInfo.CheckAddressExist(ipToUse) {
	           quit  ;all is good, exit while loop
           }
	       w !,$s(resp'=ipToUse:"Host '"_resp_"' translated ",1:""),"IP address """,ipToUse,""" does not exist."
	       r !,"Are you sure you want to use this? <No> ",ans
	       if "Yy"[$e(ans_"X") quit
	   } else {
	      w !,"Address """,resp,""" is not valid"
	   }
	}
	quit resp
}
UpdateOtherFailoverNodeInfo() {
	if 0 w !!,"Managed by Enterprise Manager, operation not allowed." Quit
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
	; Retrieve the info from the other node - its ip addresses,
	; ssl name, etc... Requires that the agent address be correct.
	s mirname=##class(Config.Mirrors).GetMirrorName()
	if mirname="" {
		w !,"Failed to lookup mirror name"
		quit
	}
	;
	s id=1  ;the other node
	s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
    if info="" {
	   w !,"Missing information for mirror member #"_id
	   quit
    }
	s name=$lg(info,1)
    s agentip=$lg(info,5)
    s basedir=$lg(info,6)
    s targguid=$LG(info,2)
	;
    s rc=$$GetMemberConfigData^MIRRORCTL(mirname,agentip,targguid,basedir)
	if '$LG(rc) {
		w !,"Failed to retrieve configuration for ",name," from ",agentip
		w !,"Error: ",$LG(rc,2)
		quit
	}
	s memberlist=$LG(rc,2)
	s found=0
	for i=1:1:$LL(memberlist) {
		s item=$LG(memberlist,i)
		s membername=$lg(item,1)
		if membername=name {
			s found=1
			s memberinfo=$LG(item,2)
			k xx
			for i=1:1:$LL(memberinfo) {
				s item=$LG(memberinfo,i)
				s p=$LG(item,1)
				s v=$LG(item,2)
				s xx(p)=v
			}
			s rc=""
			if '$d(xx("EncryptCommunication")) s xx("MemberType")=0
			;
			; We want the ECPAddress property called superserver Address
			s xx("SuperServerAddress")=$G(xx("ECPAddress"))
			k xx("ECPAddress")
			k xx("PreferredArbiter")
			s cc2=xx("ConnectsTo") k xx("ConnectsTo")
			w !,"Mirror member data for """,name,""""
			do dumpparams(.xx)
			read !,"Ok to store these values for this instance? <Y> ",resp
			if "Nn"[$E(resp_"Y") {
				w !,"Not saved"
				quit
			}
			s xx("ECPAddress")=xx("SuperServerAddress")
			k xx("SuperServerAddress")
			s xx("ConnectsTo")=cc2
	   		s rc=##class(Config.MapMirrors).Modify(mirname,name,.xx)
		 	if 'rc {
	   			k err
	   			Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
	   			w !,"Error modifying mirror member ",name," (",$G(err(1)),")"
 			} else {
 			   w !,"Saved"
 			}
 			quit  ;exit for loop
		}
	}
	if 'found {
	    ; Its a bit odd if we get out of the for loop and 
	    ; don't find the other node's information in its config...
		w !,"Couldn't find information for ",name," at ",agentip
	}
}
ModifyPerNodeSSL(isAsync) PUBLIC {
	; This entry point manages the Config.MapMirrors.EncryptCommunication
	; parameter. When Config.Mirrors.UseSSL is set all communication is encrypted.
	; When Config.Mirrors.UseSSL is clear, this parameter controls whether
	; outgoing connections made by this mirror member are encrypted.
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
	; Opens it and returns SSLCOnfig if it exists
	s exists=##class(Security.SSLConfigs).%ExistsId("%MirrorServer")
	if exists {
		r !,"Edit Mirror SSL Configuration? <Y> ",resp
	} else {
		r !,"Create Mirror SSL Configuration? <Y> ",resp
	}
	if "Nn"'[$E(resp_"X") {
		do CreateEditMirrorSSL^SECURITY2(exists)
	}
	if 0 {
		w !!,"Managed by Enterprise Manager, cannot alter per-node SSL requirements." 
		Quit
	}
	s mm=##class(Config.MirrorMember).Open()
	s ourname=mm.SystemName
	if ourname="" {
		w !,"Local Mirror system name not defined - can't modify configuration"
		quit
	}
	s mm=""
	Set isShadow = ##class(Config.MirrorMember).isAsyncMember()
	if 'isShadow {
		s mirname=##class(Config.Mirrors).GetMirrorName()
		if mirname="" {
			w !,"No mirror defined, cannot modify parameter"
			quit
		}
	} else {
		s cnt=0
		Set rs=##class(%Library.ResultSet).%New("Config.Mirrors:List")
		s rc=rs.Execute()
		if rc {
			While (rs.Next()) {
				Set name=rs.Data("Name")
				q:name=""  ;exit loop if we get a null name
				s List(name)=""
				s cnt=cnt+1
			}
		}
		s rs=""
		if cnt=0 {
			w !,"This instance is not tracking any mirrors"
			quit
		}
	    if cnt=1 {
		    s mirname=$O(List(""))
	    } else {
ask ;		
			r !,"Enter name of mirror to modify, <ret> to exit? ",mirname
			if mirname="" quit  ;exit
			if mirname="?" || '$D(List(mirname)) {
				if mirname'="?" {
					w !,"Invalid name - ",mirname," - enter one of"
				}
				s name=""
				for  {
					s name=$O(List(name))
					q:name=""
					w !,?5,name
				}
				goto ask
			}
	    }
	}
	s mirror=##class(Config.Mirrors).Open(mirname)
	if '$IsObject(mirror) {
	   w !,"Failed to open Config.Mirrors to read mirror parameters for ",mirname
	   quit
	}
	s usessl=mirror.UseSSL
	s mirror=""
	s mm=##class(Config.MapMirrors).Open(mirname,ourname)
	if '$IsObject(mm) {
	   w !,"Failed to open Config.MapMirrors to read mirror parameters for ",ourname
	   w " in mirror ",mirname
	   quit
	}
	s encryptCommunication=mm.EncryptCommunication
	if encryptCommunication=0 {
		s default="0 - None"
	} elseif encryptCommunication=1 {
		s default="1 - Outgoing only"
	} elseif encryptCommunication=2 {
		s default="2 - Incoming only"
	} elseif encryptCommunication=3 {
		s default="3 - All"
	}
	;
	if usessl {
		w !!,"The mirror is configured to use SSL so SSL is required"
		w !,"regardless of the encryption setting of this member."
		w !!,"This setting only applies if the mirror wide SSL setting is changed."
	}
	s resp=-1
	while (((resp'?1N)&&(resp'=""))||(resp<0||(resp>3))) {
		w !!,"0 - None",!,"1 - Outgoing only"
		w !,"2 - Incoming only",!,"3 - All"
		w !!,"Enter new setting: ",default," => "
		r resp
	}
	i resp="" quit
	s mm.EncryptCommunication=resp
	s rc=mm.%Save()
	if 'rc {
	   k err
	   Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
	   w !,"Error changing EncryptCommunication setting: (",$G(err(1)),")"
	   quit
	}
	w !,"EncryptCommunication setting saved."
	quit
}
GetLocalSystemName() {
	s ourname=""
	s defaultname=##class(SYS.MirrorConfiguration).DefaultSystemName()
	k MemberNames
	s mirnames=$p($G(^SYS("MIRRORSET")),"^",2)
	if mirnames'="" {
		for i=1:1:$L(mirnames,",") {
			s mirname=$P(mirnames,",",i)
			s syscnt=+$G(^SYS("MIRRORSET",mirname,"Member"))
			f j=0:1:syscnt {
				s name=$LG(^SYS("MIRRORSET",mirname,"Member",j))
				s MemberNames(name)=1
			}
		}
	}
	if defaultname'="",$G(MemberNames(defaultname))=1 s defaultname=""
	do {
		w !,"Our mirror member name: <",defaultname,"> "
		r ourname s:ourname="" ourname=defaultname
		if ourname="" {
			w !,"Mirror member name can not be null."
		} else {
			s rc=##class(Config.MirrorMember).ValidateMemberName(ourname)
			if '(''rc)	{
			   w !,$SYSTEM.Status.GetErrorText(rc)
			   s ourname=""
			}
			s ourname=$zcvt(ourname,"U")
			if $G(MemberNames(ourname))=1 {
				w !,ourname," is in use by another mirror member."
				s ourname=""
			}
		}
	} while ourname=""
	quit ourname
}
GetLocalMirrorInfo(MirrorInfo,AskAgent=0) {
	s ourname=""
	if '##class(Config.MirrorMember).isAsyncMember() {
	 	s ourname=$$GetLocalSystemName()
	}
 	while (1) {
	 	s defaultaddr=$System.INetInfo.LocalHostName()
 		w !,"Mirror Private address of local member: <",defaultaddr,"> "
 		r resp
 		if resp="" { 
 			s resp=defaultaddr
 			quit
 		}
 		else {
		 	if '##class(SYS.MirrorConfiguration).IsIPFormatValid(resp,.type) { ;Allow hostname 
			 	write !,type
			 	continue
		 	}
		 	if type="HOST" {
			 	set ipToUse=$$convHostToIP(resp)
			 	if (ipToUse="") {
				 	write !,"Error: Host ",resp," does not resolve to IP address"
				 	continue	
			 	}
		 	}
		 	else {
			 	set ipToUse=resp	
		 	}
		 	if '$System.INetInfo.CheckAddressExist(ipToUse) {
				write !,"IP address does not exist. Cannot use it as the Mirror Private address"
			 	continue	
		 	}
 		}
 		quit
 	}
 	s ssaddr=resp
 	while (1) {
		w !,"Superserver Address: <",ssaddr,"> "
 		r resp
 		if resp="" {
	 		s resp=ssaddr
	 		quit
 		}
 		else {
	 		if '##class(SYS.MirrorConfiguration).IsIPFormatValid(resp,.type) { ;Allow hostname
		 		write !,type
		 		continue	
	 		}	
	 		if type="HOST" {
		 		set ipToUse=$$convHostToIP(resp)
		 		if (ipToUse="") {
			 		write !,"Error: Host ",resp," does not resolve to IP address"
			 		continue	
		 		}
	 		}
	 		else {
		 		set ipToUse=resp	
	 		}
	 		if '$System.INetInfo.CheckAddressExist(ipToUse) {
		 		write !,"IP address does not exist. Cannot use it the superserver address"
		 		continue	
	 		}
 		}
 		quit
 	}
 	s ecpaddr=resp
 	if AskAgent {
	 	s agentaddr=##class(SYS.Agent).GetApplicationInterface()
	 	s:agentaddr=""||(agentaddr="*") agentaddr=ecpaddr
	 	while (1) {
			w !,"Agent Address: <",agentaddr,"> "
	 		r resp
	 		if resp="" {
		 		s resp=agentaddr
		 		quit
	 		}
	 		else {
		 		if '##class(SYS.MirrorConfiguration).IsIPFormatValid(resp,.type) { ;Allow hostname
			 		write !,type
			 		continue	
		 		}	
		 		if type="HOST" {
			 		set ipToUse=$$convHostToIP(resp)
			 		if (ipToUse="") {
				 		write !,"Error: Host ",resp," does not resolve to IP address"
				 		continue	
			 		}
		 		}
		 		else {
			 		set ipToUse=resp	
		 		}
		 		if '$System.INetInfo.CheckAddressExist(ipToUse) {
			 		write !,"IP address does not exist. Cannot use it the Agent address"
			 		continue	
		 		}
	 		}
	 		quit
	 	}
	 	s MirrorInfo("AgentAddress")=resp
 	}
 	s MirrorInfo("ECPAddress")=ecpaddr
 	s MirrorInfo("MirrorAddress")=ssaddr
 	quit ourname
}
GetOS() {
	q:$System.Version.GetOS()'="UNIX" ""
	s dev="uname -s" o dev:"QR" u dev r os c dev
	quit os
}
getVirtualAddressInterface(mirrorVIP) {
	s os=$$GetOS(),hpsun=((",HP-UX,")[(","_os_","))
	if '$SYSTEM.INetInfo.CheckArpingInstalled() {
		w !!,"The 'arping' command is not installed in the system, please install"
		w !,"iputils-arping package in the Linux system before yoo can configure"
		w !,"Virtual IP address for mirroring. The 'arping' command is needed to"
		w !,"inform routers outside the sub-net so they can recognize this new"
		w !,"IP address",!
		Quit ""
	}
	while (1) {
		;This will eventually get replaced by code that provides a list of interfaces...
		k viarray
 		Set tList = ##class(%SYSTEM.INetInfo).GetListOfConfiguredInterfaces(0,mirrorVIP)
 		if tList="" {
	 		w !!,"There is no installed interface with matched subnet for '",mirrorVIP,"'."
	 		w !,"Please check if the virtual IP address and subnet mask is correct.",!
	 		s iVirt=""
	 		quit
 		}
 		Set tItem = 1
 		w !
 		While $lg(tList,tItem) '= "" {
 			Set value = $lg($lg(tList,tItem),1)
 			w !,tItem,") ",value s viarray(tItem)=value
 			Set tItem = tItem + 1
 		}
 		w !,tItem,") Abort." s viarray(tItem)="Abort"
		w !!
		r "Select Network interface for Mirror Virtual Network address: ",iVirt
		if iVirt="" {
			continue
		} elseif iVirt?.N {
			if $G(viarray(iVirt))="" {
	 			write !,"Select item 1 to ",tItem
	 			continue
			}
			s iVirt=viarray(iVirt)
		} Else {
			s iv=$p(iVirt,":"),found=0
			f i=1:1:tItem i viarray(i)=iv s found=1 q
			if 'found {
				w !,"Interface '",iv,"' not found."
				continue
			}
		}
		if iVirt="Abort" s iVirt="" quit
		i hpsun {
idxnum		r !,"logical index number :",idxnum
			if idxnum'?.N w !,"Must be a integer value" g idxnum
			s iVirt=iVirt_":"_idxnum
		}
		if os]"" { ;This is some form of UNIX/Linux 
			s ifaceExists=$System.INetInfo.CheckInterfaceExist(iVirt,1) ;Ask for exact match for the interface - don't strip out the virtual part...
			if ($e(iVirt,1,2)="lo") {  ;On UNIX platforms, interfaces that start with lo are *typically* loopback interfaces. We don't want these...
				write !,"This interface appears to be a loopback interface."
				write !,"Please enter an appropriate non-loopback interface."
				continue	 				
			}
	 		if hpsun { ;For HP-UX and SunOS platforms, we require virtual (logical) interfaces, so we have to check to see if the base (physical) one exists...
		 		if ifaceExists {
		 			write !,?5,"This platform requires a virtual (logical) interface."
		 			write !,?5,"The interface you entered ("_iVirt_") already exists."
		 			write !,?5,"Please enter an appropriate logical interface that does not already exist (it"
		 			write !,?5,"will be created when assigning the Virtual IP"
		 			continue
		 		}
		 		if $p(iVirt,":",2)="" {
			 		write !,?5,"Please enter an appropriate logical interface that does not already exist (it"
			 		write !,?5,"will be created when assigining the Virtual IP"
			 		continue
		 		}
			 	if '$System.INetInfo.CheckInterfaceExist($p(iVirt,":")) {
					write !,?5,"Physical interface ("_$p(iVirt,":")_") does not exist."
					write !,?5,"The base physical interface must exist for a virtual interface"
					write !,?5,"to be added on."
					continue	
			 	}
			} else { ;Non HP-UX, non SunOS platforms, so the entered interface must already exist for it to be selected
				if 'ifaceExists {
			 		write !,?5,"This platform requires a physical interface, and it must already"
			 		write !,?5,"exists. The interface you entered ("_iVirt_") does not exist."
					continue 
				}
		 	}
		} else {
		 	if '$System.INetInfo.CheckInterfaceExist(iVirt) {
		 		w !,"Interface does not exist."
		 		continue
			}
		}
		quit	
	}
	quit iVirt
}
RemoveMirrorMember() {
	if 0 w !!,"Managed by Enterprise Manager, operation not allowed." Quit
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
	s mirname=##class(Config.Mirrors).GetMirrorName()
	if mirname="" {
		w !,"Failed to determine mirror name"
		quit
	}
	s mm=##class(Config.MirrorMember).Open()
	s ourname=mm.SystemName
	k mm
	s $p(space," ",40)=" "
 	Set rs=##class(%Library.ResultSet).%New("Config.MapMirrors:List")
 	s rc=rs.Execute(mirname)
 	if rc {
 	   While (rs.Next()) {
	      Set name=rs.Data("Name")
	      if name=ourname continue
	      s type=$case(rs.Data("MemberType"),0:"Failover",2:"Async")
	      s mlist($i(mlist))=$e(name_space,1,40)_"("_type_")"
 	   }
    }
 	s rs=""
 	if +$G(mlist)=0 w !,"No other mirror member is configured." q
	s Value=""
	s Status=##class(%Library.Prompt).GetMenu("Select member to be removed?",.Value,.mlist,,128+8+4)
 	i (+Status=0)||(Status=2)||(Value="") q
 	s othername=$p(mlist(Value)," "),type=$p($p(mlist(Value),")"),"(",2)
	if (type="Failover") {
		if $SYSTEM.Mirror.IsBackup() {
			w !,"Backup member is not allowed to remove another failover member which could be primary now."
			q
		}
		s MirrorsObj=##class(Config.Mirrors).Open(mirname)
		s UseSSL=$s($isobject(MirrorsObj)&&MirrorsObj.UseSSL:1,1:0) k MirrorsObj
		w !,"WARNING! Removing another failover member, the removed failover member won't be"
		w !,"able to connects to primary when it is running. If you want to let it re-join"
		w !,"the mirror set, you will need to '",$s(UseSSL:"Authorize",1:"Add"),"' this failover member later."
	}
 	w !,"Are you sure you want to remove the mirror member '",othername,"' <N>? "
 	r resp
 	if "Yy"'[$E(resp_"N") quit
 	s rc=##class(Config.MapMirrors).Delete(mirname,othername)
 	if (''rc) {
	 	w !,"Mirror member ",othername," is removed."
 	} else {
		k err
		Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
		w !,"Failed to remove member ",othername," (",$G(err(1)),")"
		quit
	}
}
RemoveMirrorDBandNS(DBName) {
	Do ##Class(Config.Databases).SynonymDBs(DBName,.SynonymDBs)
	Quit:$G(SynonymDBs)=""
	For dbi=1:1 {
		s dbn = $p(SynonymDBs,",",dbi) Quit:dbn=""
		kill nsp
		d ##class(Config.Namespaces).NamespacesByDB(dbn,.nsp,0)
		if $G(nsp)'="" {
			For n=1:1 {
				Set nam = $P(nsp,",",n) Quit:nam=""  
				Set sta = ##Class(Config.Namespaces).Delete(nam)
				Kill ^IRIS.Temp.MgtPortalMap("cfgMappings",nam)
				If ##class(%Library.EnsembleMgr).IsEnsembleInstalled() do ##class(%Library.EnsembleMgr).DisableNamespace(nam)
				if (''sta) w !,"Removed namespace "_nam
			}
		}
		s sta=##class(Config.Databases).Delete(dbn)
		if (''sta) w !,"Removed dataset "_dbn_" from the configuration"
	}
}
RemoveMirrorConfig() {
	if 0 w !!,"Managed by Enterprise Manager, operation not allowed." Quit
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
	if $SYSTEM.Mirror.GetInfo()["PRIMARY" {
		w !!,"This is the active primary node so you can't remove"
		w !,"the mirror configuration."
		w !!,"You need to first clear JoinMirror in the CPF file"
		w !,"or disable the %Service_Mirror service so that this node does not"
		w !,"activate the configuration at startup and then restart the instance"
		w !,"and then run this option again."  ;JO2395
		s mm=##class(Config.MirrorMember).Open()
		if mm.JoinMirror {
			r !,"Do you want to Clear the JoinMirror flag? <No> ",resp
			if "Yy"[$E(resp_"n") {
				s mm.JoinMirror=0
				s rc=mm.%Save()
			}
		} else {
			w !!,"***The JoinMirror flag has been cleared. Restart InterSystems IRIS to"
			w !,"continue removing this mirror member."
		}
		q
	}
	s mm=##class(Config.MirrorMember).Open()
	if '$IsObject(mm)||(mm.SystemName="") {
		w !,"Failed to open Config.MirrorMember - aborting"
		quit
	}
	if $D(^SYS("MIRRORSET",":LocalValidationFailure")) {
		w !,"This instance appears to be a clone of another mirror member."
		s rc=$$DeleteLocalConfig()
		quit
	}
	w !!,"This action will delete the mirror configuration information."
	if $SYSTEM.Mirror.GetInfo()'["NOTINIT" {
		w !,"The database instance needs to be restarted to complete this operation."
	}
	r !,"Are you sure you want to do this? <N> ",resp
	if "Nn"[$E(resp_"n") quit
	;
	w !!,"In addition to the above, do you also want to remove mirror attribute of"
	w !,"mirrored databases (the databases themselves will not be deleted)? <No> "
	r resp
	if "Yy"[$E(resp_"n") {
		s deleteDBs=1
		w !,"The mirrored databases' mirror attribute will be removed."
	} else { 
		s deleteDBs=0
		w !,"The mirrored databases' mirror attribute will not be removed."
	}
	s deleteSSL=0
	If ##class(Security.SSLConfigs).Exists("%MirrorClient",,.status) {
		w !!,"In addition to the above, do you also want to remove"
		w !,"   %MirrorClient/%MirrorServer SSL configuration? <No> "
		r resp
		if "Yy"[$E(resp_"n") {
			s deleteSSL=1
			w !,"The %MirrorClient/%MirrorServer SSL configuration will be removed."
		} else { 
			w !,"The %MirrorClient/%MirrorServer SSL configuration will not be removed."
		}
	}
	w !!,"In addition to the above, do you also want to remove"
	w !,"   mirror journal files listed in journal.log? <No> "
	r resp
	if "Yy"[$E(resp_"n") {
		s deleteJrn=2
		w !,"All mirror journal files will be removed."
	} else { 
		s deleteJrn=1
		w !,"The mirror journal files in journal.log will not be removed."
	}
	s rc=##class(SYS.MirrorConfiguration).RemoveMirrorConfiguration(deleteDBs,deleteJrn,deleteSSL)
	;
	if ('rc) {
	   k err
       Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
	   w !,"**** Failed to delete mirror configuration. Error ",err(1)
	}
    ;
    w !,"Mirror configuration deleted."
	if $SYSTEM.Mirror.GetInfo()'["NOTINIT" {
	    w " You should shutdown and restart this system."
	}
    quit
err ;
	s $zt=""
	w !,"Unexpected error removing node from the mirror: ",$ze
	quit     
}
getAsyncMemberSources(list) {
	 s cnt=0
	 if +$G(^SYS("MIRRORSET")) {
		 s rs=##class(%Library.ResultSet).%New("Config.Mirrors:List")
		 Do rs.Execute()
		 While (rs.Next()) {
			 s cnt=cnt+1
			 s list(cnt)=rs.Data("Name")
		 }
	 }
	 quit cnt
}
RemoveAsyncMemberSource() {
	if 0 w !!,"Managed by Enterprise Manager, operation not allowed." Quit
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
	 s cnt=$$getAsyncMemberSources(.names)
	 if 'cnt {
		 w !,"No Async member sources defined"
		 quit
	 }
	 if cnt=1 {
		 s name=names(1)
		 s newformat=+$g(names(1,0))
		 w !,"There is one Async member source, """,name,""" defined"
		 r !,"Remove it? <N> ",resp
		 if "Yy"[$E(resp_"x") {
			 goto deleteone
		 }
		 w !,"Not removed"
		 quit
	 }
choose ;	 
	 w !,"There are ",cnt," Async member sources:"
	 for i=1:1:cnt w !,?5,names(i)
	 r !,"Enter source to delete or "":ABORT"" to cancel: ",name
	 s name=$ZCVT(name,"U")
	 if name=":ABORT" w !,"Cancled" quit
	 for i=1:1:cnt q:names(i)=name
	 if names(i)'=name {
		 w !,"""",name,""" is not a Async member source"
		 goto choose
	 }
deleteone ;	 
	w !!,"This action will remove the mirror from the list of mirrors"
	w !,"being tracked, delete the journal log for this mirror and remove"
	w !,"all journal files from this mirror except files in journal.log. "
	r !,"Are you sure you want to do this? <N> ",resp
	if "Nn"[$E(resp_"n") quit
	;
	w !!,"In addition to the above, do you also want to remove mirror attribute of"
	w !,"mirrored databases (the databases themselves will not be deleted)? <No> "
	r resp
	if "Yy"[$E(resp_"n") {
		s deleteDBs=1
		w !,"The mirrored databases' mirror attribute will be removed."
	} else { 
		s deleteDBs=0
		w !,"The mirrored databases' mirror attribute will not be removed."
	}
	w !!,"In addition to the above, do you also want to remove"
	w !,"   mirror journal files listed in journal.log? <No> "
	r resp
	if "Yy"[$E(resp_"n") {
		s deleteJrn=2
		w !,"All mirror journal files will be removed."
	} else { 
		s deleteJrn=1
		w !,"The mirror journal files in journal.log will not be removed."
	}
	s rc=##class(SYS.MirrorConfiguration).RemoveOneMirrorSet(name,deleteDBs,deleteJrn)
	if ('rc) {
	   k err
       Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
	   w !,"Failed to delete ",name,". Error ",err(1)
	} else {
	   w !,"Deleted"
	}
    ; 
	quit 
}
fixbasedir(dir) {
	; the base directory (installation directory) needs to end
	; in a seperator. we're not sure what the target o/s is though
	; so scan though the directory to find the 1st seperator.
	s last=$E(dir,$L(dir))
	if "/\]"[last quit dir  ;we're all set
	f i=1:1:$L(dir) s ch=$E(dir,i) quit:"/\["[ch
	if "/\"[ch {
		; if this is VMS we already checked that it ends in ] and it
		; doesn't. that's bad but we can't just add one... otherwise, if we
		; found a \ or / then add it to the end. If not, we'll live with what
		; we have.
		s dir=dir_ch
	}
	quit dir
}
ManageNoFailover() {
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
	s info=$SYSTEM.Mirror.GetInfo()
	if info'[",DEFINED,"||+$G(^SYS("MIRRORSET")) {
		w !,"This instance is not initialized as a failover member"
		quit
	}
	if (info [ ",SHADOW,") {
		w !,"This option is not valid on async members"
		quit
	}
	s mirname=##class(Config.Mirrors).GetMirrorName()
	if mirname="" {
		w !,"Failed to determine mirror name"
		quit
	}
	s cls=##class(Config.Mirrors).Open(mirname)
	s primary=cls.DefinedPrimary
	if primary="" {
		if $SYSTEM.Mirror.IsPrimary() {
			s name=$LG($G(^SYS("MIRRORSET",mirname,"Member",0)))
			if name="" w !,"No primary member is found, could not set 'no failover'" quit
		} else {
			s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
			if 'systemcnt w !,"No primary member is found, could not set 'no failover'" quit
			s info=$G(^SYS("MIRRORSET",mirname,"Member",1))
			s name=$lg(info,1)
			if info=""||(name="") w !,"No primary member is found, could not set 'no failover'" quit
			s rc=$$GetStatus^MIRRORCTL(mirname,1)
			s status=$LG(rc)  
			if status'="PRIMARY" w !,"No primary member is found, could not set 'no failover'" quit
		}
		w !,"The mirror is not set to 'no failover'. Setting 'no failover' will"
		w !,"prevent ",$s($SYSTEM.Mirror.IsPrimary():"the other",1:"this")," member from becoming a primary member when the primary is down."
		r !,"Do you want to set it? <N> ",resp
		if "Yy"'[$E(resp_"X") quit
	    s rc=$$SetMirrorNoFailover^MIRRORCTL(name)
	    if $LG(rc)="OK" {
		    w !,"Success."
	    } else {
		    w !,"Failed with error: ",$lg(rc,2)
	    }
	} else {
		if (primary=":NOPARTNER") {
			w !,"The mirror is set to 'no failover'."
			if $G(^SYS("MIRRORSET",mirname,"Member"),0)>0 {
				w !,"Clearing 'no failover' will allow either failover member to become primary."
				w !,"If you want this member to be the first to become primary, ensure that the"
				w !,"other member is shut down before proceeding."
			} else {
				w !,"Clearing 'no failover' will allow this member to become primary."
			}
		} else {
			s name=$LG($G(^SYS("MIRRORSET",mirname,"Member",0))) 
			w !,"The mirror is set to 'no failover' with ",primary," defined as primary."
			w !,"Clearing the 'no failover' will allow ",$s(name=primary:"the other",1:"this")," member to become"
			w !,"primary when the primary is down."
		}
		r !,"Do you want to clear this? <N> ",resp
		if "Yy"'[$E(resp_"X") quit
	    s rc=$$ClearMirrorNoFailover^MIRRORCTL("")
	    if $LG(rc)="OK" {
		    w !,"Success"
	    } elseif $LG(rc)="TIMEOUT" {
		    w !!,"The other failover member '",$LG($G(^SYS("MIRRORSET",mirname,"Member",1))),"' is unreachable."
		    w !,"We can't clear 'no failover' on the other failover member."
		    w !,"If you choose to clear 'no failover' on this failover member,"
		    w !,"then this member will try to become primary and the other member"
		    w !,"will clear its 'no failover' when it is restarted and contacts this member."
		    w !,"Do you want clear 'no failover' on this failover member? <N> "
		    r resp
		    if "Yy"'[$E(resp_"X") quit
		    s cls.DefinedPrimary=""
		    s rc=cls.%Save()
		    if ('rc) {
			    w !,"Failed to save cleared DefinedPrimary value, rc = "_$System.Status.GetErrorText(rc)
		    } else {
			    d post^MIRRORCOMM(mirname,0,0,"CLRDEFPRIMARY:")
			    w !,"The 'no failover' is cleared on this failover member."
		    }
	    } else {
		    w !,"Failed with error: ",$lg(rc,2)
	    }
	}
}
RequestPrimary() {
	s $zt="err"
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
	s info=$SYSTEM.Mirror.GetInfo()
	if info[",SHADOW," {
		w !,"This option only works on failover members"
		quit
	}
	s mirname=##class(Config.Mirrors).GetMirrorName()
	if mirname="" {
		w !,"Cannot read mirror name, cannot become primary"
		quit
	}
	s cls=##class(Config.Mirrors).Open(mirname,,,.rc)
	if ('rc) {
		w "Failed to read [Mirrors] configuration section"
		quit
	}
	if '$SYSTEM.Mirror.IsBackup() {
		w !,"This function only works on the backup"
		quit
	}
	s defprimary=cls.DefinedPrimary
	s cls=""
	s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
	s status=""
	for id=1:1:systemcnt {
	   s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
       if info'="" {
	      s name=$lg(info,1)
          s rc=$$GetStatus^MIRRORCTL(mirname,id)
          s status=$LG(rc)  
	      if status="PRIMARY" {
		      quit
	      }
       }
	}
	w !,name," is the current primary. Continuing will force it down"
	r !,"Continue? <N> ",resp
	if "Yy"'[$E(resp_"X") {
		w !,"Aborted"
		quit
	}
	if defprimary'="" {
		s ourname=$LG($G(^SYS("MIRRORSET",mirname,"Member",0)),1)
		if ourname'=defprimary {
			w !,"No failover mode is set and the primary is defined as ",defprimary
			r !,"Do you want to clear this so that this node can take over? <N> ",resp
		    if "Yy"'[$E(resp_"N") quit
	        s rc=$$ClearMirrorNoFailover^MIRRORCTL("")
	        if $LG(rc)'="OK" {
		       w !,"Cannot become primary - failed to clear defined primary"
		       w !,"Error: ",$lg(rc,2)
		       quit
	       }
		}
	}
	w !,"Please wait..."
	s rc=$$TakeOverAsPrimary^MIRRORMGR() 
	if $LG(rc) {
		w !,$LG(rc,2)
		quit
	}
	w !,"Failed to become the primary:"
	w !,?5,$LG(rc,2)
	quit
err ;
	s $zt=""
	w !,"Unexpected error: ",$ze
	quit
}
ForcePrimary() {
	s $zt="err"
	s info=$SYSTEM.Mirror.GetInfo()
	if info["PRIMARY" {
		w !,"This node is already the primary"
		quit
	}
	if (info[",NOTINIT,") {
		w !,"This instance is not initialized as a mirror member"
		quit
	}
	if (info [ ",SHADOW,") {
		w !,"This option is not valid on async members"
		quit
	}
	s mirname=##class(Config.Mirrors).GetMirrorName()
	if mirname="" {
		w !,"Failed to read mirror name - Cannot become primary"
		quit
	}
	s cls=##class(Config.Mirrors).Open(mirname,,,.rc)
	if ('rc) {
		w "Failed to read [Mirror] configuration section"
		quit
	}
	s defprimary=cls.DefinedPrimary
	s cls=""
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
	s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
	s status=""
	for id=1:1:systemcnt {
	   s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
       if info'="" {
	      s name=$lg(info,1)
          s rc=$$GetStatus^MIRRORCTL(mirname,id)
          s status=$LG(rc)  
	      if status="PRIMARY" {
		      quit
	      }
       }
	}
	s forcefailover=0
	if (status="PRIMARY") {
		w !,"Mirror member """,name,""" is currently the primary."
		read !,"Do you want to force it down so that we become the primary? <No> ",resp
		if "Yy"'[$E(resp_"N") quit  ;JO2369
		s forcefailover=1
	} else {
		s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
		if +rc<0 {
			s lastfilecnt=""
			s lastfilename=""
		} else {
			s lastfilecnt=+rc
			s lastfilename=$P(rc,",",2)
		}
		if (lastfilename'="") && ($SYSTEM.Mirror.ActiveBackupFlag(-1)=1) {
			w !,"This instance was an active backup member the last time it was "
			w !,"connected so if the primary has not done any work since that time,"
			w !,"this instance can take over without having to rebuild the mirror "
			w !,"when the primary reconnects. If the primary has done any work"
			w !,"beyond this point (file #",lastfilecnt,"),"
			w !,?5,lastfilename
			w !,"then the consequence of forcing this instance to become the primary is"
		    w !,"that some operations may be lost and the other mirror member may need"
		    w !,"to be rebuilt from a backup of this node before it can join as"
		    w !,"a backup node again."
		} else {
		   w !,"Warning, this action can result in forcing this node to become"
		   w !,"the primary when it does not have all of the journal data which"
		   w !,"has been generated in the mirror. The consequence of this is that"
		   w !,"some operations may be lost and the other mirror member may need"
		   w !,"to be rebuilt from a backup of this node before it can join as"
		   w !,"a backup node again."
		}
		s lastjrninfo=$$GetMaxDejrnStart^MIRRORMGR(mirname,3)  ;returns $LB(rc,<jrnfilecnt>,<jrnendoff>)
	    if '$LG(lastjrninfo)||($LG(lastjrninfo,2)=0) {
		    s lastjrnfilecnt=0
		    s lastjrnend=""  ;no journal files yet	
	    } else {
		    s lastjrnend=+$LG(lastjrninfo,3)
		    s lastjrnfilecnt=+$LG(lastjrninfo,2)
	    }
		if '$$CheckRequiredDatabases^MIRRORCOMM(1,lastjrnfilecnt,lastjrnend) {
			w !!,"Additionally, one or more mirrored databases which are marked"
			w !,"in the configuration as ""Mount Required at Startup"" are not currently"
			w !,"active. Continuing will force this instance to become the primary and these"
			w !,"databases will be mounted read-only rather than read-write."
		}
		read !,"Do you want to continue? <No> ",resp
		if "Yy"'[$E(resp_"N") {
			w !,"Aborted"
			quit
		}
	}
	if defprimary'="" {
		s ourname=$LG($G(^SYS("MIRRORSET",mirname,"Member",0)),1)
		if ourname'=defprimary {
			w !,"No failover mode is set and the primary is defined as ",defprimary
			r !,"Do you want to clear this so that this node can take over? <N> ",resp
		    if "Yy"'[$E(resp_"N") quit
	        s rc=$$ClearMirrorNoFailover^MIRRORCTL("")
		    if $LG(rc)="TIMEOUT" {
			    w !!,"The other failover member '",$LG($G(^SYS("MIRRORSET",mirname,"Member",1))),"' is unreachable."
			    w !,"We can't clear 'no failover' on the other failover member."
			    w !,"If you choose to clear 'no failover' on this failover member,"
			    w !,"then this member will try to become primary and the other member"
			    w !,"will clear its 'no failover' when it is restarted and contacts this member."
			    w !,"Do you want clear 'no failover' on this failover member? <N> "
			    r resp
			    if "Yy"'[$E(resp_"X") quit
				s cls=##class(Config.Mirrors).Open(mirname,,,.rc)
			    s cls.DefinedPrimary=""
			    s rc=cls.%Save()
			    if ('rc) {
				    w !,"Failed to save cleared DefinedPrimary value, rc = "_$System.Status.GetErrorText(rc)
				    quit
			    } else {
				    w !,"The 'no failover' is cleared on this failover member."
			    }
			    s rc=$LB("OK")
		    }
	        if $LG(rc)'="OK" {
		       w !,"Cannot become primary - failed to clear defined primary"
		       w !,"Error: ",$lg(rc,2)
		       quit
	       }
		}
	}
	s cls=##class(Config.MirrorMember).Open()
	if cls.ValidatedMember'=1 {
		w !,"This mirror member has not been validated, this could be a promoted"
		w !,"async member and you are forcing this member to be a primary member."
		w !,"You need to set this member as a validated member to be able to become"
		w !,"a primary member."
		r !,"Do you want to set this member as a validated member? <N> ",resp
		if "Yy"'[$E(resp_"N") quit
		s cls.ValidatedMember = 1
		s x=cls.%Save()
		i 'x w !,"Failed to become a validated member, Error:",$SYSTEM.Status.GetErrorText(x) quit
		w !,"This member is now a validated member."
	}
	s cls=""
	w !,"Please wait..."
	s rc=$$DesignatePrimary^MIRRORMGR(forcefailover) 
	if $LG(rc) {
		w !,"Success"
		quit
	}
	w !,"Timed out waiting to become the primary: "
	w !,?5,$LG(rc,2)
	w !,"Check the console log for further information, this instance may still be"
	w !,?5,"in the process of becoming the primary mirror member."
	quit
err ;
	s $zt=""
	w !,"Unexpected error: ",$ze
	quit
}
ActivateMirror() {
	i '$SYSTEM.Security.Check("%Admin_Operate","USE") w !,"Operation requires %Admin_Operate:Use privilege" q
	s $zt="err"
	s cls=##class(Config.MirrorMember).Open()
	s isasync=cls.isAsyncMember()
	if $SYSTEM.Mirror.GetInfo()[",DEFINED,"&&isasync {
		s mirname=$p(^SYS("MIRRORSET"),"^",2)
		if mirname="" w !," No mirror set to be started." quit
		if $L(mirname,",")=1 goto gotname
top		r !,"Enter mirror set name: (? for list, return for quit) ",mirname
		if mirname="?" w !!,"Mirror Set name is one of:",!,$p(^SYS("MIRRORSET"),"^",2) goto top
		if mirname="" quit
		s mirname=$zcvt(mirname,"U")
		if ","_$P(^SYS("MIRRORSET"),"^",2)_","'[(","_mirname_",")||(mirname[",") w "   does not exist!" g top
gotname	;
		s dspname=mirname
	} else {
		if ('isasync)&&'cls.JoinMirror {
			w !,"The JoinMirror is not set, could not start the mirror until it is set"
			quit
		}
		if isasync {
			s dspname="All Mirror Sets"
			s mirname=""
		} else {
			s (mirname,dspname)=##class(Config.Mirrors).GetMirrorName()
		}
	}
	s cls=""
	if mirname'=""&&##class(SYS.Mirror).IsMirrorStarted(mirname) {
		w !,"The mirror '",dspname,"' has already been started."
		quit
	}
	s dspname=$s(dspname["All Mirror":dspname,1:"Mirror Set "_dspname)
	w !,"OK to start "_dspname_" <N>? " r resp
	if "Yy"'[$E(resp_"X") quit
	s rc=##class(SYS.Mirror).StartMirror(mirname)
	if ('rc) {
		k err
	   	Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
	   	w !,"Failed to start ",dspname,". Error = ",err(1)
    	quit
	}
	w !,dspname," started."
	w !,"See Status Monitor for connection status and progress."
	quit
err ;
	s $zt=""
	w !,"Unexpected error: ",$ze
	quit
}
DeactivateMirror() {
	i '$SYSTEM.Security.Check("%Admin_Operate","USE") w !,"Operation requires %Admin_Operate:Use privilege" q
	s $zt="err"
	s info=$SYSTEM.Mirror.GetInfo()
	if info'[",DEFINED," w !,"Mirror is not started yet." quit
	if info["PRIMARY" w !,"Cannot stop the primary mirror member." quit
	s isasync=##class(Config.MirrorMember).isAsyncMember()
	if isasync {
		s mirname=$p(^SYS("MIRRORSET"),"^",2)
		if mirname="" w !," No mirror set to be stopped." quit
		if $L(mirname,",")=1 goto gotname
top		r !,"Enter mirror set name: (? for list, return for quit) ",mirname
		if mirname="?" w !!,"Mirror Set name is one of:",!,$p(^SYS("MIRRORSET"),"^",2) goto top
		if mirname="" quit
		s mirname=$zcvt(mirname,"U")
		if ","_$P(^SYS("MIRRORSET"),"^",2)_","'[(","_mirname_",")||(mirname[",") w "   does not exist!" g top
gotname	;
		s dspname=mirname
	} else {
		if isasync {
			s dspname="All Mirror Sets"
			s mirname=""
		} else {
			s (mirname,dspname)=##class(Config.Mirrors).GetMirrorName()
		}
	}
	if mirname'=""&&'##class(SYS.Mirror).IsMirrorStarted(mirname) {
		w !,"The mirror '",dspname,"' has already been stopped."
		quit
	}
	s dspname=$s(dspname["All Mirror":dspname,1:"Mirror Set "_dspname)
	w !,"OK to stop "_dspname_" <N>? " r resp
	if "Yy"'[$E(resp_"X") quit
	s rc=##class(SYS.Mirror).StopMirror(mirname)
	if ('rc) {
		k err
	   	Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
	   	w !,"Failed to stop ",dspname,". Error = ",err(1)
    	quit
	}
	w !,dspname," stopped."
	quit
err ;
	s $zt=""
	w !,"Unexpected error: ",$ze
	quit
}
Monitor() PUBLIC {
	s $zt="err"
	s x=$SYSTEM.Mirror.GetInfo(1)
	if x'["DEFINED" {
		w !,"This node is not a mirror member"
		q
	}
	if +$G(^SYS("MIRRORSET")) {
	   s cnt=$$getAsyncMemberSources(.mirnames)
	   if 'cnt {
		   w !,"No Async member sources defined"
		   quit
	   }
	   if cnt=1 {
		   s mirname=mirnames(1)
		   w !,"Monitoring ",mirname
	   } else {
		   s namelist=","
		   for i=1:1:cnt s namelist=namelist_mirnames(i)_","
		   w !,"This is an Async member tracking ",cnt," mirrors"
		   r !,"Enter name of mirror to monitor? (? for list) ",mirname
		   s mirname=$zcvt(mirname,"U")
		   q:mirname=""
		   while (1) {
			   q:mirname=""||(namelist[(","_mirname_",")&&(mirname'[","))
			   if (mirname'="?") w "   does not exist!"
			   w !,"This node is tracking the following mirrors:"
			   w !,?5
			   for i=1:1:cnt w mirnames(i) w:i'=cnt ", " w:$X>75 !,?5 
	  	       r !,"Enter name of mirror to monitor? (? for list) ",mirname
			   s mirname=$zcvt(mirname,"U")
		   }
	   }
	} else {
	    s mirname=$p($G(^SYS("MIRRORSET")),"^",2)
	}
	if mirname="" {
		quit
	}
	if x["PRIMARY" {
		s primary=1
	} else {
		s primary=0
	}
	s index=""
	s ourname=$LG(^SYS("MIRRORSET",mirname,"Member",0))
	s ourindex=0
	for  {
	   s index=$O(^SYS("MIRRORSET",mirname,"Member",index),1,info)
	   q:index=""
	   s name=$lg(info,1)
	   s nameindex(name)=index
       if name=ourname {
	       s ourindex=index
	       quit
       }
	}
	s DisplayDatabases=0  ;user can toggle this after the 1st pass
	s refresh=60
	s PrevRate="0,0,0"
StatusLoop ;
	; 
	s cls=##class(Config.Mirrors).Open(mirname,,,.rc)
	if ('rc) {
		w "Monitor aborted - Failed to read configuration for "_mirname
		quit
	}
	s defprimary=cls.DefinedPrimary
    if +$G(^SYS("MIRRORSET")) {
	    s failoverMember = 0
    } else {
	    s failoverMember = 1
	    s VIPAddress=cls.VirtualAddress
	    if VIPAddress'="" {
		    s mm=##class(Config.MirrorMember).Open(,,.rc)
			if ('rc) {
				w "Monitor aborted - Failed to read MirrorMember configuration."
				quit
			}
			s VIPInterface = mm.VirtualAddressInterface
			k mm
	    }
		Set arbiteraddr = $P(cls.ArbiterNode,"^",1)
		If arbiteraddr = "" {
			s ArbiterNode = "Arbiter not configured"
		} Else {
			s ArbiterNode = arbiteraddr
		}
		; Mirror FailoverMode
		Set mode = $SYSTEM.Mirror.FailoverRule()
		If mode = 1 {
			Set modeString = "Arbiter Controlled"
		} ElseIf mode = 2 {
			Set modeString = "Agent Controlled"
		} Else {
			Set modeString = "User Controlled"
		}
		;Arbiter ConnectionStatus
		Set state = $SYSTEM.Mirror.ArbiterState()
		Set thisConnected = $SELECT($ZB(+state,+2,1)'=0:1,1:0)
		Set otherConnected = $SELECT($ZB(+state,+4,1)'=0:1,1:0)
		If 'thisConnected {
			Set stateString = "This member is not connected to the arbiter"
		} ElseIf 'otherConnected {
			Set stateString = "Only this member is connected to the arbiter"
		} Else {
			Set stateString = "Both failover members are connected to the arbiter"
		}
    }
	s cls=""
	s time=$zdatetime($H)
	w !,"Status of Mirror ",mirname," at ",$P(time," ",2)," on ",$P(time," ")
	if '$SYSTEM.Mirror.IsPrimary() {
		w !,"Incoming Journal Transfer Rate for This Member (over refresh interval)"
		d JournalRate(mirname,.PrevRate)
	}
	if failoverMember {
		w !,"Arbiter Connection Status:"
		w !,?5,"Arbiter Address:   ",ArbiterNode
		w !,?5,"Failover Mode:     ",modeString
		w !,?5,"Connection Status: ",stateString
		if VIPAddress'="" {
		w !,"Virtual Address Information:"
		w !,?5,"IP Address/Mask:   ",VIPAddress
		w !,?5,"Network Interface: ",VIPInterface
		}
		w !
	}
	w !,?39,"Journal Transfer"
	w !,"Member Name+Type",?28,"Status",?42,"Latency"
	w ?56,"Dejournal Latency"
	w !,"--------------------------",?28,"---------"
	w ?39,"---------------",?56,"--------------"
	s haveprimary=0
	; reset list of members between each run
	k names,membertype,displaystatus,jrntimelatency,dbtimelatency
	Set tRS = ##class(%Library.ResultSet).%New("SYS.Mirror:MemberStatusList")
	Do tRS.Execute(mirname)
	while tRS.Next() {
		s name=tRS.Data("MemberName")
		s names(name)=name
		s membertype(name)=tRS.Data("DisplayType")
		s displaystatus(name)=tRS.Data("DisplayStatus")
		s jrntimelatency(name)=tRS.Data("JournalTimeLatency")
		s dbtimelatency(name)=tRS.Data("DatabaseTimeLatency")
		if tRS.Data("CurrentRole")="Primary" {
			s pindex=$G(nameindex(name))
			s haveprimary=1
		}
	}
	s tRS=""
	; Now retrieve the set of async members so we can get a more
	; detailed member type for the display than simply "Async"
	Set tRS = ##class(%Library.ResultSet).%New("SYS.Mirror:AsyncMemberList")
	Do tRS.Execute()
	while tRS.Next() {
		s name=tRS.Data("Name")
		s membertype(name)= tRS.Data("Type")
	}
	s tRS=""
	s name=""
	for  {
		s name=$O(names(name))
		q:name=""
		W !,name
		w !,?5,membertype(name)
		w ?28,displaystatus(name)
		w ?39
		if $X+$L(jrntimelatency(name))>79 s tab=79-$L(jrntimelatency(name)) w !,?tab
		w jrntimelatency(name)
		if (dbtimelatency(name)'["Disconnected") || (dbtimelatency(name)'=jrntimelatency(name)) {
			w ?56
			if $X+$L(dbtimelatency(name))>79 s tab=79-$L(dbtimelatency(name)) w !,?tab
			w dbtimelatency(name)
		}
	}
	if defprimary'="" {
		if defprimary=":NOPARTNER" {
			w !!,"Mirror is set to 'no failover'."
		} else {
			w !!,"Mirror is set to 'no failover' with ",defprimary," defined as primary"
		}
	}
	if $SYSTEM.Mirror.IsAsyncMember() {
		w !,"Dejournal Status: ",##class(SYS.MirrorConfiguration).GetDejournalStatusMsg(mirname)
	}
	if $SYSTEM.Mirror.IsBackup()||##class(Config.MirrorMember).IsDRMember() {
		s rs=##class(%Library.ResultSet).%New("SYS.Mirror:MissingMirroredDatabases")
		if rs.Execute(mirname) {
			if rs.Next() {
				w !!,"WARNING!!!!!",!
				w "Missing mirrored database(s) which existed in primary member:"
				do {
				w !,?5,rs.Data("Name")
				} while rs.Next()
			}
		}
	}
	if 'DisplayDatabases {
		goto skip
	}
	w !!,"Mirror Databases:"
	w !,?67,"Record To"
	w !,"Name",?15,"Directory path",?55,"Status",?67,"Dejournal"
	w !,"-------------",?15,"-----------------------------------"
	w ?55,"-----------",?67,"-----------"
	s rs=##class(%Library.ResultSet).%New("%CSP.UI.System.Mirror:MirroredDatabaseList")
	s x=rs.Execute(mirname)
	while (rs.Next()) {
		s name=rs.Data("Name")
		s directory=rs.Data("Directory")
		s status=rs.Data("MirrorStatus")
		s latency=rs.Data("LastDejournalRecord")
		w !,name
		w ?15,directory
		if $X>55 w !
		w ?55,status
		if $l(latency)>10 {
			w !,?3,latency
		} else {
			w ?67,latency
		}
	}
	s rs=""
	w !
skip ;
	w !!,"Press RETURN to refresh, D to toggle database display, Q to quit,"
	w !," or specify new refresh interval <",refresh,"> "
	s intv=0
	r intv:refresh
	if +intv s refresh=intv
	if "Dd"[$E(intv_"x") {
		s DisplayDatabases='DisplayDatabases
		w !,"Database display is now ",$S(DisplayDatabases:"on",1:"off")
	}
	if "Qq"'[$E(intv_"X") w !! goto StatusLoop
	w !,"Done"
	q
err ;
	s $zt=""
	w !,"Unexpected error: ",$ze
	quit
}
JournalRate(mirname,prev) {
	Set miridx = $SYSTEM.Mirror.MirrorNameToIndex(mirname,0)
	if miridx>=0 {
		Set curtime=$ZH
		Set cur=$SYSTEM.Mirror.GetInfo(7,miridx)
		Set recv=+$p(cur,",",1),recvcmp=+$p(cur,",",2)
		If +prev>recv Set $p(prev,",",1)=0
		If +$p(prev,",")=0 {
			Set Text="--- (will be displayed on refresh)"
		} else {
			Set timediff=curtime-$p(prev,",",3),intervaltext=" ("_(timediff\1)_"s interval)"
			Set journalbyte=recv-prev
			Set datatext=$J(journalbyte/1024/timediff,0,2)_" KB/s"
			if recvcmp=0 {
				Set Text=datatext
			} else {
				Set cmpbyte=recvcmp-$p(prev,",",2)
				Set Text=$J(cmpbyte/1024/timediff,0,2)_" KB/s network; "_datatext_" journal; compression ratio "_$J($s(cmpbyte=0:0,1:journalbyte/cmpbyte),0,2)_":1"
			}
			Set Text=Text_intervaltext
		}
		s prev=recv_","_recvcmp_","_curtime
	} else {
		Set Text="Can't find mirror set name "_mirname
	}
	w !," ",Text,!
}
convHostToIP(host) {
	if $zcvt(host,"U")=$zcvt($zu(54,0),"U") s host="localhost"  ;force to localhost to get loopback address if the machine name is passed in
	quit $s($zbitget($zversion(0)_$c(0,0,0,0),42):$SYSTEM.INetInfo.HostNameToAddr(host),1:$p($zu(54,13,host),","))	
}
ManageAsyncJournalPurge() {
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
	s curval=+$G(^SYS("MIRRORSET",0,"AsyncUseSystemPurgeInterval"))
	if curval {
		w !,"This async member is configured to purge mirror journal files"
		w !,"according to the same criteria used to control purging of locally"
		w !,"created journal files."
	} else {
		w !,"This async member is configured to purge mirror journal files"
		w !,"as soon as they are no longer needed."
	}
	r !,"Do you want to change this behavior? <No> ",resp
	if "Yy"'[$E(resp_"X") {
		quit
	}
	s cls=##class(Config.MirrorMember).Open(,,.rc)
	if ('rc) {
		k err
		Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
		w !,"Modify failed  - error reading mirror member configuration: ",err(1)
		quit
	}
	s newval='curval	; the new setting is the opposite of the current setting
	s cls.AsyncUseSystemPurgeInterval = newval
	s rc=cls.%Save()
	if ('rc) {
		k err
		Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
		w !,"Failed to save changes: ",err(1)
		quit
	}
	if newval {
		w !!,"This async member is now configured to purge mirror journal files"
		w !,"according to the same criteria used to control purging of locally"
		w !,"created journal files."
	} else {
		w !!,"This async member is now configured to purge mirror journal files"
		w !,"as soon as they are no longer needed."
		d PURGE^JRNUTIL  ;see if there are files we can clean up
	}
}
Promote() {
	if 0 w !!,"Managed by Enterprise Manager, operation not allowed." Quit
	s mirname=##class(Config.Mirrors).GetMirrorName()
	if mirname="" w !!,"No mirror set name is configured." quit
	if '##class(Config.MirrorMember).isAsyncMember() {
		w !!,"The system is a failover member, promoting to failover member is not allowed.",!
		Quit
	}
	if '##class(Config.MirrorMember).IsDRMember() {
		w !!,"The system is a non-DR Async mirror member, promoting to failover member is not allowed.",!
		Quit
	}
	if '+$ZU(78,22) {  ;journaling is not running
		w !!,"Journaling must be started before this system can be promoted."
		quit
	}
	s cls=##class(Config.Mirrors).Open(mirname)
	s vip=cls.VirtualAddress,cls="",virtualinterface=""
	if vip'="" {
		s MemberObj=##class(Config.MirrorMember).Open()
		s virtualinterface=MemberObj.VirtualAddressInterface
		s MemberObj=""
 		Set tList = ##class(%SYSTEM.INetInfo).GetListOfConfiguredInterfaces(1,vip)
 		if tList="" {
			w !!,"WARNING: There is no network interface could acquire virtual IP '",vip,"'."
			w !,"It is likely because all network interfaces do not have matched subnet for '",vip,"'."
			w !,"This promoted failover member won't acquire virtual IP when it becomes primary."
			w !,"Do you want to continue? <No> "
			r resp
			if "Yy"'[$E(resp_"N") quit
			s virtualinterface="NoMatchedSubnet"
			s resp="N"
 		} elseif virtualinterface=""||(virtualinterface="NoMatchedSubnet") {
			w !,"Must define an interface to host the virtual address ",vip,"."
			s resp="Y"
		} else {
		    w !,"Current interface for the virtual address is: ",virtualinterface
			s subnetmatched=(''##class(SYS.MirrorConfiguration).ValidateVirtualAddress(vip,0,virtualinterface))
			if 'subnetmatched {
				w !,"This interface could not acquire virtual IP '",vip,"' so you must change it.",!
				s resp="Y"
			} else {
			    w !,"Do you want to change this? <No> "
			    r resp
			    if "Yy"[$E(resp_"N") s resp="Y"
			}
		}
		if resp="Y" {
vif			s resp=$$getVirtualAddressInterface(vip)
			if resp'="" {
				s virtualinterface=resp
			} else {
				w !!,"You need to setup Network Interface for the Virtual IP '",vip,"'."
				r !,"Do you want to setup Network Interface again? <Yes> ",resp
				if "Nn"'[$E(resp_"y") g vif
				w !,"Aborted!!" quit
			}
		}
	}
	try {
		s mirlock=$zu(156,11)
	} catch {
		s mirlock=0
	}
	if mirlock {
		w !!,"Warning!! There are locks of mirrored databases in this system."
		w !,"   Promoting the system to failover member will remove these locks"
		w !,"   and owners of these locks will get <LOCKLOST> error."
	}
	s nfailover=0
 	Set rs=##class(%Library.ResultSet).%New("Config.MapMirrors:List")
 	s rc=rs.Execute(mirname)
 	if rc {
 	   While (rs.Next()) {
	      if rs.Data("MemberType")=0 s nfailover=nfailover+1
 	   }
    }
 	s rs=""
 	if nfailover=2 {
	 	w !!,"Warning!! There are two failover members configured, promoting this system"
	 	w !,"   will demote the backup member to DR async member."
 	}
	r !!,"Are you sure you want to promote this system to a failover member? <No> ",ans
	if "Yy"'[$e(ans_"X") quit
	s DownList=""
	w !,"Please wait..."
	s rc=##class(SYS.MirrorConfiguration).PromoteToFailoverMember("",.DownList,"",0,virtualinterface)
	if (''rc) {
		w !,"System is promoted to a failover member."
		if DownList'="" {
			d $zu(9,"","IMPORTANT: Before you restart "_DownList_" you must manually edit the "_"iris"_".cpf configuration file, and in the [MirrorMember] section set ValidatedMember=0.",1 /* broadcast and log message*/,2  /* Severe error */)
			w !!,"IMPORTANT: Agent of ",DownList," could not be contacted."
			w !,"Before you restart ",DownList
			w !,"you must manually edit the "_"iris"_".cpf configuration file, and in the"
			w !,"[MirrorMember] section set ValidatedMember=0. Failure to do so could result in"
			w !,"having two primary members running simultaneously."
			r !!,"Press <RETURN> to continue",x
		}
		quit
	}
	if DownList="" {
		w !,"Failed to promote this system to failover member"
		w !," Error:",$SYSTEM.Status.GetErrorText(rc)
		q
	}
	s MemberObj=##class(Config.MirrorMember).Open()
	s ourname=MemberObj.SystemName
	s MemberObj=""
	k MemberList,MemberNames
	s mirname=$p(^SYS("MIRRORSET"),"^",2),syscnt=+$G(^SYS("MIRRORSET",mirname,"Member"))
	f i=1:1:syscnt {
		s MemberList(i)=$LG(^SYS("MIRRORSET",mirname,"Member",i))
		s MemberNames(MemberList(i))=i
	}
	s MemberList(syscnt+1)="No Partner Failover Member"
	s MemberList(syscnt+2)="Abort"
	w !!,"Could not contact the agent(s) on failover member(s):"
	w !,?5,DownList
	w !,"If these failover member(s) are available, choose ""Abort"" and restore" 
	w !,"connectivity. Otherwise, you may select a failover partner for this member."
	w !!,"This member may not have the mirror's most recent journal data. If you select a"
	w !,"partner failover member, on successful contact with it, this member will obtain"
	w !,"any newer journal data that the partner has, and attempt to become primary." 
	w !,"Choose the failover member that was last primary since that member has the most"
	w !,"recent journal data. If the partner member remains inaccessible and you wish to"
	w !,"make this member primary without obtaining additional journal data, you may"
	w !,"later use the ^MIRROR option ""Force this node to become primary""."
	w !!,"If you select ""No Partner Failover Member"", this member can become primary"
	w !,"after applying all the journal data it has and attempting to obtain additional"
	w !,"journal data from any other members it can contact."
	w !!,"Existing failover member(s) not selected as partner will be demoted to DR async.",!
	f i=1:1:syscnt+2 w !,i,") ",MemberList(i)
again r !,"Enter the partner failover member: ",member
	if member="" s member=syscnt+2
	if '$D(MemberNames(member)),(member?1.N) {
		if member>(syscnt+2) w !,"please enter 1 to ",syscnt+2,"." g again
		if member=(syscnt+2) w "   Aborted!" quit
		if member=(syscnt+1) {
			s member="" w "   No partner selected."
		} else {
			s member=MemberList(member)
			w "   '",member,"' selected."
		}
	} else {
		s member=$zcvt(member,"U")
		if '$D(MemberNames(member)) {
			w "   member doesn't exist!" 
			g again		
		}
	}
	if member="" {
		w !!,"Warning: This member may become the primary without all of the journal data" 
		w !,"which has been generated in the mirror. The consequence of this is that some"
		w !,"operations may be lost and the other mirror members may need to be rebuilt"
		w !,"from a backup."
		w !
		w !,"You can optionally set the mirror to 'no failover'. If you do, the member"
		w !,"will prepare to become primary, but will not become primary until you"
		w !,"clear 'no failover'. This preparation includes applying all the journal data"
		w !,"it has, and periodially scanning for additional journal data from any other"
		w !,"members it can contact. This allows you to perform any additional"
		w !,"verification you wish before allowing the member to become primary."
		w !,"If you do not set 'no failover', the member will apply all the journal data"
		w !,"it has and scan once for additional journal data from other members before"
		w !,"becoming primary."
selagain w ! 
		w !,"1) Continue, allowing this member to become primary immediately"
		w !,"2) Set 'no failover' and continue"
		w !,"3) Abort"
		r !!,"Select <3>: ",sel
		if sel=""||(sel=3) quit
		if sel'=1&&(sel'=2) w "  Please enter 1, 2 or 3." g selagain
		s NoFailover=sel-1
		s standalone=1
		goto dopromote
	}
	s NoFailover=0
	s standalone=0
	w !!,"Warning: If the partner member ",member
	w !,"was not the last member to be primary, it may not have all of the journal data"
	w !,"which has been generated in the mirror. The consequence of this is that some"
	w !,"operations may be lost and the other mirror members may need to be rebuilt" 
	w !,"from a backup."
	r !!,"Do you want to continue? <No> ",ans
	if "Yy"'[$e(ans_"X") quit
dopromote ;
	s DownList=""
	w !,"Please wait..."
	s rc=##class(SYS.MirrorConfiguration).PromoteToFailoverMember("",.DownList,member,standalone,virtualinterface,NoFailover)
	if (''rc) {
		w !,"System is promoted to a failover member."
		if DownList'="" {
			d $zu(9,"","IMPORTANT: Before you restart "_DownList_" you must manually edit the "_"iris"_".cpf configuration file, and in the [MirrorMember] section set ValidatedMember=0.",1 /* broadcast and log message*/,2  /* Severe error */)
			w !!,"IMPORTANT: Before you restart ",DownList
			w !,"you must manually edit the "_"iris"_".cpf configuration file, and in the"
			w !,"[MirrorMember] section set ValidatedMember=0. Failure to do so could result in"
			w !,"having two primary members running simultaneously."
			r !!,"Press <RETURN> to continue",x
		}
		quit
	}
	w !,"Failed to promote this system to failover member"
	w !," Error:",$SYSTEM.Status.GetErrorText(rc)
	q
}
Demote() {
	if 0 w !!,"Managed by Enterprise Manager, operation not allowed." Quit
	if ##class(Config.MirrorMember).isAsyncMember()||$SYSTEM.Mirror.IsPrimary() {
		w !!,"The system is a primary or async mirror member, demoting to async member is not allowed.",!
		Quit
	}
	r !,"Are you sure you want to demote this system to an async member? <No> ",ans
	if "Yy"'[$e(ans_"X") quit
	s rc=##class(SYS.MirrorConfiguration).DemoteToAsyncMember("")
	if (''rc) {
		w !,"System is demoted to an async member."
		quit
	}
	w !,"Failed to demote the system to async member."
	w !," Error:",$SYSTEM.Status.GetErrorText(rc)
	q
}
updateList(List) {
	s List(15)="Demote Other Failover Member to DR Async Member"
	if '$$DemotePartnerOK() s List(15)=List(15)_" (disabled)"
}
DemotePartnerOK() {
	s mirname=##class(Config.Mirrors).GetMirrorName()
	if mirname="" quit 0
	if ##class(Config.MirrorMember).isAsyncMember() quit 0
	s nfailover=0
 	Set rs=##class(%Library.ResultSet).%New("Config.MapMirrors:List")
 	s rc=rs.Execute(mirname)
 	if rc {
 	   While (rs.Next()) {
	      if rs.Data("MemberType")=0 s nfailover=nfailover+1
 	   }
    }
 	s rs=""
 	if nfailover<2 quit 0
 	i '$SYSTEM.Mirror.IsPrimary()&&($SYSTEM.Mirror.IsBackup()||($LG($$GetStatus^MIRRORCTL(mirname,1,1))="PRIMARY")) quit 0
 	quit 1
}
DemotePartner() {
	if 0 w !!,"Managed by Enterprise Manager, operation not allowed." Quit
	s MemberObj=##class(Config.MirrorMember).Open()
	if '$isobject(MemberObj) {
		w !,"Failed to open Config.MirrorMember object"
		quit
	}
	s ourname=MemberObj.SystemName
	if ourname="" {
		w !,"Mirror is not configured"
		quit
	}
	s mirname=##class(Config.Mirrors).GetMirrorName()
    if mirname="" {
	    w !,"Mirror set is not configured"
	    q
    }
    s othername=""
 	Set rs=##class(%Library.ResultSet).%New("Config.MapMirrors:List")
 	s rc=rs.Execute(mirname)
 	if rc {
 	   While (rs.Next()) {
	      if rs.Data("MemberType")=0&&(rs.Data("Name")'=ourname) {
		      s othername = rs.Data("Name")
		      quit
	      }
 	   }
    }
 	s rs=""
 	if othername="" w !,"No other failover member is configured" q
	w !,"Are you sure you want to demote '",othername,"' to an async member? <No> " r ans
	if "Yy"'[$e(ans_"X") quit
	s rc=##class(SYS.MirrorConfiguration).DemotePartnerToAsyncMember("")
	if (''rc) {
		w !,"'",othername,"' is demoted to an async member."
		quit
	}
	w !,"Failed to demote '",othername,"' to async member."
	w !," Error:",$SYSTEM.Status.GetErrorText(rc)
	q
}
ManageAsyncMemberType() {
	if 0 w !!,"Managed by Enterprise Manager, operation not allowed." Quit
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
	s cls=##Class(Config.MirrorMember).Open()
	s curtype=cls.AsyncMemberType
	s curtypestring=$case(curtype,0:"Disaster Recovery (DR)",1:"Read-Only Reporting",2:"Read-Write Reporting",:"Unknown")
	w !!,"Current async member type is ",curtypestring,"."
	if curtype=1 {
		s List(1)="Disaster Recovery (DR)"
		s List(2)="Read-Write Reporting"
		s NewList(1)=0
		s NewList(2)=2
	} elseif curtype=2 {
		s List(1)="Disaster Recovery (DR)"
		s List(2)="Read-Only Reporting"
		s NewList(1)=0
		s NewList(2)=1
	} else {
		s List(1)="Read-Only Reporting"
		s List(2)="Read-Write Reporting"
		s NewList(1)=1
		s NewList(2)=2
	}
	s Help(1)="There are three types of async member."
	s Help(2)="Disaster Recovery (DR) - All the mirrored databases are read-only."
	s Help(3)="Read-Only Reporting - The mirrored databases could be read-only or read-write."
	s Help(4)="                      When a mirrored DB is created/restored,"
	s Help(5)="                      the DB is set to read-only."
	s Help(6)="Read-Write Reporting- The mirrored databases could be read-only or read-write."
	s Help(7)="                      When a mirrored DB is created/restored,"
	s Help(8)="                      the DB is set to read-write."
	s Value=""
	s Status=##class(%Library.Prompt).GetMenu("Change to new async member type?",.Value,.List,.Help,128+8+4)
 	i (+Status=0)||(Status=2)||(Value="") q
	s newtype=NewList(Value)
 	if newtype=0 {
	 	s rc=##class(SYS.MirrorConfiguration).DRMemberValidation(cls.SystemName)
	 	if '(''rc) {
		 	s errcode=+$SYSTEM.Status.GetErrorCodes(rc)
		 	if errcode=2172 {
				w !,"This member cannot become a DR async because the FailoverDB flag is cleared"
				w !,"on at least one mirrored database. To make this member a DR async, first remove"
				w !,"all such databases from the mirror on this member, then change the member type"
				w !,"to DR async, and finally restore the databases from a backup made on a failover"
				w !,"member to add them back to the mirror."
		 	} elseif errcode=2149 {
				w !,"This member cannot become a DR async because this member has joined more than"
				w !,"one mirror set."
		 	} else {
				w !,"This member cannot become a DR async for unknown reason."
				w !,"Error code: ",$SYSTEM.Status.GetErrorText(rc)
		 	}
		 	w !,"*** Failed to convert to Disaster Recovery (DR) async member type."
		 	Quit
	 	}
		Set rc=##class(SYS.Mirror).CheckISCAgent()
		If '(''rc) {
			w !,"This member cannot become a DR async because error on checking ISCAgent."
			w !,"Error code: ",$SYSTEM.Status.GetErrorText(rc)
		 	w !,"*** Failed to convert to Disaster Recovery (DR) async member type."
		 	Quit
		}
		s mirname=##class(Config.Mirrors).GetMirrorName()
	    if mirname="" {
		    W !,"No mirror set is configured."
		    Quit
	    }
		s mm=##class(Config.MapMirrors).Open(mirname,cls.SystemName,,,.rc)
		if ('rc) {
			W !,"Could not open the mirror member "_cls.SystemName_" in mirror set"_mirname_". Error:"_$SYSTEM.Status.GetErrorText(rc)
			Quit
		}
		if mm.DejournalFilter'="" {
			w !,"WARNING!!!"
			w !,"The currently configured DejournalFilter '"_mm.DejournalFilter_"'"
			w !,"will be removed after changing async member type from Reporing to DR."
			w !,"You need to reconfigure it if you decide to change it back to Reporting type later."
		}
		s mm=""
	 	if +##class(%SYS.Journal.System).IsJournalEncryptionEnabled() {
			w !,"WARNING!!!"
			w !,"The journal encryption is currently enabled, DR member must have same encryption"
			w !,"key as failover members have. Please make sure the encryption key matched with"
			w !,"failover members' key otherwise the DR member will not be able to connect to"
			w !,"primary."
	 	}
 	}
 	s x=$case(newtype,0:"Disaster Recovery (DR)",1:"Read-Only Reporting",2:"Read-Write Reporting",:"Unknown")
	w !,"Are you sure you want to change to ",x," type <Y>? " r resp
	if ("Nn"[$E(resp_"X")) Quit
	s cls.AsyncMemberType = newtype
	s rc=cls.%Save()
	if ('rc) {
		w !,"Failed to update the AsyncMemberType in MirrorMember section."
		w !,"   Error: ",$SYSTEM.Status.GetErrorText(rc)
		quit
	} else {
		w !,"Async member type is updated from ",curtypestring," to ",$case(newtype,0:"Disaster Recovery (DR)",1:"Read-Only Reporting",2:"Read-Write Reporting",:"Unknown"),"."
	}
	s cls=""
	if newtype=2 {
		w !!,"Do you want to clear FailoverDB flag for all the mirrored databases"
		w !,"in this system to make them read-write databases? <N>"
		r ans
		if "Yy"[$E(ans_"X") {
			s rc=##class(Config.MirrorMember).ClearFailoverDBForNonDRAsyncMember()
			if ('rc) {
				w !,"Failed to clear FailoverDB flag on all mirrored databases."
				w !,"   Error: ",$SYSTEM.Status.GetErrorText(rc)
			} else {
				w !,"All the activated mirrored databases have been set to be read-write databases."
			}
		}
	}
}
ClearFailoverDBFlag() {
	if '##class(Config.MirrorMember).AllowClearFailoverDBFlag() {
		w !,"Clear FailoverDB flag on mirrored databases is not allowed" 
		q
	}
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
	s cnt=$$GetListOfMirroredDB(.dblist,1)
	if 'cnt w !,"No mirrored database with FailoverDB flags set." q
loop
	w !!,"The following databases have FailoverDB flag (Read-Only) set."
	w !,"Please select one of the database or all the databases to"
	w !,"clear the FailoverDB flag.",!
	f i=1:1:cnt w !,i,") ",dblist(i) if '+$g(dblist(i,0)) w " (Not activated, can't be cleared)"
	w !,cnt+1,") All of the above databases."
	w !,cnt+2,") Exit"
	r !!,"Select: ",sel
	if sel=""||(sel=(cnt+2)) quit
	if sel?.N {
		if sel=(cnt+1) {
			w !,"You selected to clear FailoverDB flag for all the mirrored databases."
			r !,"Are you sure? <N>",ans
			if "Yy"'[$E(ans_"X") goto loop
			s rc=##class(Config.MirrorMember).ClearFailoverDBForNonDRAsyncMember()
			if ('rc) {
				w !,"Failed to clear FailoverDB flag for all mirrored databases."
				w !,"   Error: ",$SYSTEM.Status.GetErrorText(rc)
			} else {
				w !,"The FailoverDB flag on all mirrored databases have been cleared."
			}
			quit
		}
		if '$d(dblist(sel),dir) w !," Invalid selection" goto loop
	} else {
		s dir=sel
	}
	s rc=##class(SYS.Database).ClearMirrorFailoverDB(dir)
	if ('rc) {
		w !,"Failed to clear FailoverDB flag for ",dir
		w !,"   Error: ",$SYSTEM.Status.GetErrorText(rc)
	} else {
		w !,"The FailoverDB flag on ",dir," have been cleared."
	}
	q
}
GetListOfMirroredDB(dblist,flag) {
	s rs=##class(%Library.ResultSet).%New("Config.Databases:MirrorDatabaseList")
	d rs.Execute()
	s cnt=0
	while (rs.Next()) {
		s dir=rs.Data("Directory")
		if (flag&&rs.Data("MirrorFailoverDB"))||(('flag)&&('rs.Data("MirrorFailoverDB"))) {
			s dblist($i(cnt))=dir
			if flag {
				s Obj=##class(SYS.Database).%OpenId(dir,,.rc)
				if (''rc) s dblist(cnt,0)=('Obj.MirrorNoWrite)&&('Obj.MirrorActivationRequired)
			}
		}
	}
	quit cnt
}
DisplayMirroredDB() {
	s rs=##class(%Library.ResultSet).%New("Config.Databases:MirrorDatabaseList")
	d rs.Execute()
	s $p(b,"-",80)="-"
	w !!,"Directory",?45,"Mirror DB Name",?70,"FailoverDB Flag"
	w !,b
	while (rs.Next()) {
		w !,rs.Data("Directory")
		w ?45,":mirror:",rs.Data("Mirror"),":",rs.Data("MirrorDBName")
		w ?73,$s(rs.Data("MirrorFailoverDB"):"Set",1:"Cleared")
	}
}
AskResetMirroredDB(Obj) PUBLIC {
	s $zt="err"
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
	s dir=Obj.Directory
	s mirname=Obj.MirrorSetName
	s mirrordbname=":mirror:"_mirname_":"_Obj.MirrorDBName
	s sfn=Obj.SFN
	;
	if Obj.ReadOnly {
		w !,dir," is marked read-only."
		r !,"Do you want to mark it read-write? <Yes> ",resp
		if "Nn"[$E(resp_"X") {
			w !,"Not reset."
			quit
		}
		s Obj.ReadOnly=0
		s rc=Obj.%Save()
		i ('rc) {
			w !
			d $SYSTEM.Status.DisplayError(rc) 
			w !
			quit
		}
		w !
	}
	if Obj.InActiveMirror {
		w !,dir," is part of the active mirror - no updating is required"
		quit
	}
	s dbinfo=$SYSTEM.Mirror.DBGetInfo(0,sfn)  ;get current info string
	if dbinfo="" {
		w !,"Failed to read mirror database info for sfn #",sfn
		quit
	}
	s curfilecnt=$P(dbinfo,"^",3)
	s curfileoff=$P(dbinfo,"^",4)
	; See whether curfilecnt exists, it could even be the current
	; file if this db was just marked r/o and then r/w!
	s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(curfilecnt,mirname)
	s missingjournalfiles=1
	if +rc>0 {
		s jrnfile=$P(rc,",",2)
		s jrninfo=$zu(78,22,jrnfile,99)
		if +jrninfo>0 {
			; Journal file exists, lets see if all the other files exist too
		    s lastfilecnt=+$SYSTEM.Mirror.GetLastJournalFilename(mirname)
			for i=curfilecnt+1:1:lastfilecnt {
				s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(i,mirname)
				q:rc<=0
				s jrnfile=$P(rc,",",2)
				s jrninfo=$zu(78,22,jrnfile,99)
				q:+jrninfo<=0
			}
			if (rc>0) && (jrninfo>0) {
				s missingjournalfiles=0
				w !,"All of the journal files (#'s ",curfilecnt,"-",lastfilecnt,") required to"
				w !,"catch up ",dir," exist."
				w !,"Do you want to run catch-up rather than resetting the end? <Yes> "
				r resp
				if "Nn"'[$E(resp_"X") {
					s list=$LB(sfn)
					s x=##class(SYS.Mirror).CatchupDB(list,,.errlist)
					if 'x {
						w !,"CatchupDB failed."
					} else {
						if '$LL(errlist) {
							w !,"Succeeded"
						} else {
							w !,"The following databases were not successfully restored"
							f i=1:1:$LL(errlist) {
								s sfn=$LG(errlist,i)
								w !,?5,$P($ZU(49,+sfn,3),"^",2)
							}
						}
						w !,"Don't forget repeat the operation for the database on the other mirror members"
					}
					quit
				} 
			}
		}
	}
	; Ok, we don't have all the journal files we need or the user doesn't
	; want to catch the file up, see if we can reset the current end so we 
	; can make this writeable
	if $SYSTEM.Mirror.GetInfo()["PRIMARY" {
		; If there is another failover member check to see whether its copy of the
		; database has already been reset as if so, it would be best to update ours
		; to match it since it must have been reset on the node which was the primary
		; at the time and there's a good chance (since it became read/write) that there
		; is journal data which needs to be replayed.
		; If we're the primary, if there is a backupm, is node #1
		s info=$g(^SYS("MIRRORSET",mirname,"Member",1))
		s jrnoffnew=0
		i $LG(info,8)=0 {  ;this is false when info is ""
			s name=$lg(info,1)
			s rc=$$CheckDBNameInUse^MIRRORCTL(mirname,1,mirrordbname)
			s status=$LG(rc)  
			if status="FOUND" {
				s info=$LG(rc,3)  ;$SYSTEM.Mirror.DBGetInfo(sfn)
				s jrnoffnew=+$P(info,"^",14)
				if jrnoffnew'=0 {
					s jrnfcntnew=+$P(info,"^",13)
					s jrnoffold=+$P(info,"^",16)
					s jrnfcntold=+$P(info,"^",15)
				}
			}
			if jrnoffnew'=0 {
				; when jrnoffnew is non-zero that means this db has been reset. We need
				; to figure out whether this is an older reset or whether it matches the
	 			; our db.
	 			if (jrnfcntnew>curfilecnt) || 
	 				((jrnfcntnew = curfilecnt) && (jrnoffnew > curfileoff)) {
		 			if (jrnfcntold=curfilecnt) && (jrnoffold=curfileoff) {
			 			; our current journal point exactly matches the point at which the other
			 			; copy was reset so use it to reset this copy. Maybe we also want to include
			 			; cases where its close, but not exact?
		 		    	w !,name," has a copy of this database which was at the same point as the"
		 		    	w !,"   local copy is now when it was reset to read/write. Resetting the local"
		 		    	w !,"   copy based on the same point in time after which it can be caught up"
						goto ResetToMatchOther
		 			}
		 		    /* this copy was reset to a point after our current end so we should either
		 		       update ours to match this end or the user should restore a copy of the
		 		       other database over the local copy */
		 		    w !,name," has a copy of this database"
		 		    w !,"     which was reset to read/write from "
		 		    w !,          jrnfcntold,"/",jrnoffold," to ",jrnfcntnew,"/",jrnoffnew
					w !,"The local copy of the database is current as of ",curfilecnt,"/",curfileoff
					w !,"If there is no journal data in the gap between when this file was marked"
					w !,"     read-only and when the other file was marked read-only, this file can be"
					w !,"     updated to be current as of ",jrnfcntnew,"/",jrnoffnew," and then caught"
					w !,"     up from there to make it active."
					w !!,"Mark this copy as up-to-date using the information from the other file? <Yes> "
					r resp
					if "Nn"'[$E(resp_"X") {
						goto ResetToMatchOther
					}
	 			}
				;  Should we check whether the other db is currently read/write or 
	 			;  not? 
			}
		}
		w !,"Is there any journal data to"
		w !,"     replay since this database was marked read/only? "
		r resp
		while "YyNnQq"'[$E(resp_"X") {
			w !,"Please enter Yes, No or Quit"
			w !,"Is there any journal data to"
			w !,"     replay since this database was marked read/only? "
			r resp
		}
		if "Qq"[$E(resp_"X") {
			w !!,"The read only flag for ",dir
			w !,"    has been cleared but since it is a mirrored database it will "
			w !,"    remain read-only until it is caught up or ""reset"" to be current."
			quit
		}
		if "Yy"[$E(resp_"X") {
			if missingjournalfiles {
			   s rc=$$GetJournalFilesAndUpdateLog^MIRRORCOMM(mirname,curfilecnt)
			   i 'rc {
				   s msg=$p(rc,",",2)
					w !,"One or more journal files required to catch up the database are missing"
					w !,"and we ran into trouble trying to retrieve them: "
					w !,?5,msg
					w !,"Please ensure all of the journal files since mirror journal file #",curfilecnt
					w !,"are available. The mirror management inferface can be used to rebuild the"
					w !,"mirror journal log if necessary after restoring the journal files."
					quit
			   }
			}
			w !,"Start catchup for ",dir,"? "
			r resp
			while ("NnYy"'[$E(resp_"X")) {
				w !,"Please answer yes or no"
				w !,"Start catchup for ",dir,"? "
				r resp
			}
			if "Yy"[$E(resp_"X") {
				s list=$LB(sfn)
				s x=##class(SYS.Mirror).CatchupDB(list,,.errlist)
				if 'x {
					w !,"CatchupDB failed."
				} else {
					if '$LL(errlist) {
						w !,"Succeeded"
					} else {
						w !,"The following databases were not successfully restored"
						f i=1:1:$LL(errlist) {
							s sfn=$LG(errlist,i)
							w !,?5,$P($ZU(49,+sfn,3),"^",2)
						}
					}
				}
				quit
			} else {
				w !!,"Since there is journal data which has not been applied to "
				w !,"     the database if you continue, and reset the database to be"
				w !,"     up to date, the database will be made writable even though it"
				w !,"     is incomplete. This should only be done if the journal files"
				w !,"     required to complete catch-up are not available and you will"
				w !,"     resolve any issues due to possible missing data/incomplete open "
				w !,"     transactions manually."
			}
		}
		w !,"Do you want to reset ",dir
		w !,"   to mark it as caught up so that it can be mounted read/write? "
		r resp
		while "YyNnQq"'[$E(resp_"X") {
			if "Hh?"[$E(resp_"X") {
				w !!,"When a mirrored database is read-only the internal journal position in the"
				w !,"    database is not updated. When the read/only flag is cleared in order for"
				w !,"    the database to be mounted read/write, the database needs to be declared"
				w !,"    up-to-date. This is safe as long as no other copies of the database have"
				w !,"    been marked read/write since this database was changed to read/only - it is"
				w !,"    safe if this copy of the database is up to date. Alternativly, if the"
				w !,"    journal files dating back to when this database was marked read only are"
				w !,"    available, the catch up option can be used to apply the required"
				w !,"    modifications (eg. if some other copy of the database wasn't marked "
				w !,"    read/only and became active somehow)."
				w !
			} else {
				w !,"Please enter Yes, No, Quit or h/H/? for help"
			}
			w !,"Do you want to reset ",dir
			w !,"   to mark it as caught up so that it can be mounted read/write? "
			r resp
		}
		if "NnQq"[$E(resp_"X") {
			w !!,"The read only flag for ",dir
			w !,"    has been cleared but since it is a mirrored database it will "
			w !,"    remain read-only until it is caught up or ""reset"" to be current."
			quit
		}
		s rc=$SYSTEM.Mirror.DBReset(dir)
		if +rc=0 {
			s msg=$p(rc,",",2,99)
			w !,"Failed to reset database ",dir
			w !,?10,msg
		}
		w !,"Don't forget repeat the operation for the database on the other mirror members"
		quit	
	}
	s jrnoffnew=0  ;in case we don't find any failover members
	s index=0  ;start with us so we don't see our copy
	for  {
		s index=$O(^SYS("MIRRORSET",mirname,"Member",index),1,info)
		q:index=""
		i $LG(info,8)=0 {
			s name=$lg(info,1)
			s rc=$$CheckDBNameInUse^MIRRORCTL(mirname,index,mirrordbname)
			s status=$LG(rc)  
			if status="FOUND" {
				s info=$LG(rc,3)  ;$SYSTEM.Mirror.DBGetInfo(sfn)
				s jrnoffnew=+$P(info,"^",14)
				if jrnoffnew'=0 {
					s jrnfcntnew=+$P(info,"^",13)
					s jrnoffold=+$P(info,"^",16)
					s jrnfcntold=+$P(info,"^",15)
					quit  ;we found a node with data so we can stop
				}
			}
		}
	}
	if jrnoffnew=0 {
		w !!,"We cannot locate a copy of this database on a failover member which"
		w !,"    has been reset so the local copy cannot be updated. When a copy is"
		w !,"    available on a failover member you can try resetting this copy with"
		w !,"    the mirror management screen or utility."
		quit
	}
	w !!,"A read/write copy of this database was found on ",name
	w !,"    which was converted from read/only to read/write at journal"
	w !,"    position ",jrnfcntnew,"/",jrnoffnew," (file #/journal offset)"
	w !
	; In order for us to use the new filecnt/fileoffset the current
	; journal position must match (equal or greater than) the old journal 
	; position from the reset data. Otherwise we need to ask the user
	; if its ok - it might be. When a db is marked read-only we'll update
	; the other copies we can find or the other copies will get updated the
	; next time the node reconnects and sees that it is now readonly. This
	; can result in different current journal offsets stored in different 
	; copies even though all of them actually became read-only at the same
	; time. The 1st copy to become read/write could be "ahead" or "behind"
	; the other copies depending on which one is on the primary at the time
	; the use wants to make it read/write again.
	if ((curfilecnt<jrnfcntold) || 
		((curfilecnt=jrnfcntold) && (curfileoff <= jrnoffold))) {
	    w !,"This copy of the database was last updated at an earlier"
	    w !,"    point in time ("
	    if curfilecnt<jrnfcntold w curfilecnt,"/"
	    w curfileoff
	    w ") than the point at which the read/write copy"
	    w !,"    was converted from read/only to read/write ("
	    if curfilecnt<jrnfcntold w jrnfcntold,"/"
		w jrnoffold,")."
		w !,"    There may be journal data which needs to be"
		w !,"    restored to this copy before marking it as up to date."
		r !,"Do you want to continue anyway and mark this copy as up to date? <No> ",resp
		if "Yy"'[$E(resp_"X") {
			w !,"Not updated."
			quit
		}
	} else {
		r !,"Reset this database to be current as of this position? ",resp
		while "YyNnQq"'[$E(resp_"X") {
			w !,"Please answer one of yes, no or quit."
			r !,"Reset this database to be current as of this position? ",resp
		}
		if "NnQq"[$E(resp) {
			w !,"Not updated."
			quit
		}
	}
ResetToMatchOther ;	
	s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(jrnfcntnew,mirname)
	if rc<=0 {
		w !,"Journal file #",jrnfcntnew," could not be found in mirror journal log file."
		quit
	}
	s jrnfile=$P(rc,",",2)
	s jrninfo=$zu(78,22,jrnfile,99)
	if +jrninfo<=0 {
		w !,"Journal file ",jrnfile," (#",jrnfcntnew,") does not exist."
		quit
	}
	s x=$SYSTEM.Mirror.DBReset(dir, jrnfcntnew, jrnoffnew,$p(jrninfo,",",7+1))
	if +x=0 {
		w !,"Failed to reset database: ",$P(x,",",2,99)
		quit
	}
	w !!,dir," is now marked current as of ",jrnfcntnew,"/",jrnoffnew
	w !,"Do you want to start the catchup process so this database"
	w !,"gets linked into the active deournaling system? <Yes> "
	r resp
	if "Nn"[$E(resp_"X") {
		w !,"Not started"
		quit
	}
	s list=$LB(sfn)
	s x=##class(SYS.Mirror).CatchupDB(list,,.errlist)
	if 'x {
		w !,"Catchup failed."
	} else {
		if '$LL(errlist) {
			w !,"Succeeded"
		} else {
			w !,"The following databases were not successfully restored"
			f i=1:1:$LL(errlist) {
				s sfn=$LG(errlist,i)
				w !,?5,$P($ZU(49,+sfn,3),"^",2)
			}
		}
	}
	w !,"Done"
	quit
err ;
	s Zt=""
	w !,"Unexpected error: ",$ZE
	QUIT
}
UpdateMemberType(mirname,newtype) PUBLIC {
	if (newtype'=2) quit "0,wrong async type "_newtype_"."
	s cls=##class(Config.MirrorMember).Open(,,.rc)
	if ('rc) Quit "0,failed to read mirror member configuration. Error:"_$SYSTEM.Status.GetErrorText(rc)
	s ourname=cls.SystemName
	if 'cls.isAsyncMember() quit "0,This is not an async member"
	s cls=##class(Config.MapMirrors).Open(mirname,ourname,,,.rc)
	if ('rc) Quit "0,Could not open the mirror member "_ourname_" in mirror set"_mirname_". Error:"_$SYSTEM.Status.GetErrorText(rc)
	s cls.MemberType=newtype
	s rc=cls.%Save()
	if ('rc) Quit "0,Could not update mirror member "_ourname_" in mirror set"_mirname_". Error:"_$SYSTEM.Status.GetErrorText(rc)
	Quit 1
}
SetupSSL() {
 s SSLConfig=##class(Security.SSLConfigs).%New()
retry
 if ($SYSTEM.Util.OpenSSLVersion()=100) {
	 Set List(1)="SSLv3"
	 Set List(2)="TLSv1.0"
	 Set List(3)="TLSv1.1"
	 Set List(4)="TLSv1.2"
 } else {
	 Set List(1)="TLSv1.0"
	 Set List(2)="TLSv1.1"
	 Set List(3)="TLSv1.2"
	 Set List(4)="TLSv1.3"
 }
 Set ver=SSLConfig.TLSMinVersion
 if ($SYSTEM.Util.OpenSSLVersion()=100) {
	 Set Value=$Select(ver=2:1,ver=4:2,ver=8:3,ver=16:4,1:4)
 } else {
	 Set Value=$Select(ver=4:1,ver=8:2,ver=16:3,ver=32:4,1:3)
 }
 Set Status=##Class(%Library.Prompt).GetMenu("Select minimum enabled protocol:",.Value,.List,,8+128+4)
 If (+Status=0)||(Status=2)||(Value="") Quit
 if ($SYSTEM.Util.OpenSSLVersion()=100) {
	 Set SSLConfig.TLSMinVersion=$Select(Value=1:2,Value=2:4,Value=3:8,Value=4:16)
 } else {
	 Set SSLConfig.TLSMinVersion=$Select(Value=1:4,Value=2:8,Value=3:16,Value=4:32)
 }
 Set ver=SSLConfig.TLSMaxVersion
 if ($SYSTEM.Util.OpenSSLVersion()=100) {
	 Set Value=$Select(ver=2:1,ver=4:2,ver=8:3,ver=16:4,1:4)
 } else {
	 Set Value=$Select(ver=4:1,ver=8:2,ver=16:3,ver=32:4,1:3)
 }
 Set Status=##Class(%Library.Prompt).GetMenu("Select maximum enabled protocol:",.Value,.List,,8+128+4)
 If (+Status=0)||(Status=2)||(Value="") Quit
 if ($SYSTEM.Util.OpenSSLVersion()=100) {
	 Set SSLConfig.TLSMaxVersion=$Select(Value=1:2,Value=2:4,Value=3:8,Value=4:16)
 } else {
	 Set SSLConfig.TLSMaxVersion=$Select(Value=1:4,Value=2:8,Value=3:16,Value=4:32)
 }
 If (SSLConfig.TLSMinVersion > SSLConfig.TLSMaxVersion) {
	 Write !, "Maximum  protocol version cannot be less than minimum protocol version"
	 Goto retry
 }
 Set SSLInfo("TLSMinVersion")=SSLConfig.TLSMinVersion
 Set SSLInfo("TLSMaxVersion")=SSLConfig.TLSMaxVersion
CipherList
 If (SSLConfig.TLSMinVersion < 32) {
	 s SSLConfig.CipherList=$$STRINGOPTION("Enabled ciphersuites for TLSv1.2 and below",SSLConfig.CipherList,1) q:SSLConfig.CipherList=-1 0
	 s SSLInfo("CipherList")=SSLConfig.CipherList
 }
Ciphersuites
 If (SSLConfig.TLSMaxVersion > 16) {
	 s SSLConfig.Ciphersuites=$$STRINGOPTION("Enabled ciphersuites for TLSv1.3",SSLConfig.Ciphersuites,1) q:SSLConfig.Ciphersuites=-1 0
	 s SSLInfo("Ciphersuites")=SSLConfig.Ciphersuites
 }
CertificateFile
 s SSLConfig.CertificateFile=$$STRINGOPTION("File containing this configuration's X.509 certificate",SSLConfig.CertificateFile,0) q:SSLConfig.CertificateFile=-1 0
 s SSLInfo("CertificateFile")=SSLConfig.CertificateFile
PrivateKeyFile
 s SSLConfig.PrivateKeyFile=$$STRINGOPTION("File containing this configuration's private key",SSLConfig.PrivateKeyFile,0) q:SSLConfig.PrivateKeyFile=-1 0
 s SSLInfo("PrivateKeyFile")=SSLConfig.PrivateKeyFile
PrivateKeyType
 w !
 w !,"   Key Type"
 w !,"   --------"
 w !,"1) DSA"
 w !,"2) RSA"
 w !
 s Option=$$NUMOPTION("Private key type",SSLConfig.PrivateKeyType,1,2)
 i Option=0 q 0
 i Option=1 s SSLConfig.PrivateKeyType=1
 i Option=2 s SSLConfig.PrivateKeyType=2
 s SSLInfo("PrivateKeyType")=SSLConfig.PrivateKeyType
PrivateKeyPassword
 s oPassword=SSLConfig.PrivateKeyPasswordLogicalToDisplay(SSLConfig.PrivateKeyPassword)
 u:$zu(96,14)=1 $io:(:"S")
 s Password=$$STRINGOPTION("Private key password",oPassword,1) 
 u:$zu(96,14)=1 $io:(:"-S") 
 q:Password=-1 0
 i (Password'=oPassword) {
	u:$zu(96,14)=1 $io:(:"S")
	s cPassword=$$STRINGOPTION("Please enter the password again","",1) 
	u:$zu(96,14)=1 $io:(:"-S") 
	q:cPassword=-1 0
	i cPassword'=Password w !,"Password does not match, please re-enter" g PrivateKeyPassword
	s SSLConfig.PrivateKeyPassword=Password
 }
 s SSLInfo("PrivateKeyPassword")=SSLConfig.PrivateKeyPassword
CAFile
 s SSLConfig.CAFile=$$STRINGOPTION("Trusted Certificate Authority X.509 certificate(s)",SSLConfig.CAFile,0) q:SSLConfig.CAFile=-1 0
 s SSLInfo("CAFile")=SSLConfig.CAFile
CRLFile
 k SSLConfig
 s rc=##class(SYS.Mirror).UpdateMirrorSSL(.SSLInfo)
 i ('rc) w !,"Failed to create Mirror SSL configuration. Error: ",$SYSTEM.Status.GetErrorText(rc) quit 0
 w !,"%MirrorClient and %MirrorServer SSL configuration successfully created."
 quit 1
}
NUMOPTION(prompt,default,min,max) [] PRIVATE {
 s $zt="NUMOPTIONE"
NUMOPTION1 w !,prompt_"? "_default_" => "
 r Option i Option="" q default
 i '(Option?1.5N)!(Option<min)!(Option>max) w !!,"Please enter a number between "_min_" and "_max,! g NUMOPTION1
 q +Option
NUMOPTIONE s $zt=""
 i $ze'["<INTERRUPT>" w !,"ERROR: "_$ZE
 q -1
}
STRINGOPTION(prompt,default,allownull) [] PRIVATE {
 s $zt="STRINGOPTIONE"
STRINGOPTION1 w !,prompt_"? " i default'="" w default_" => "
 r Option i Option="",(default'="") q default
 i Option="",(allownull=0) w !,"Please enter a non-null value" g STRINGOPTION1 
 q Option
STRINGOPTIONE s $zt=""
 i $ze'["<INTERRUPT>" w !,"ERROR: "_$ZE
 q -1
}
ConvertShadowDatabases() public {
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !!,"Operation requires %Admin_Manage:Use privilege." q
	If '$System.Mirror.IsMember() w !!,"The system is not a mirror member." q
	If $system.Mirror.IsPrimary() w !!,"The system is a primary member, not allowed." q
getshdid ;
	k list
	s rs=##class(%Library.ResultSet).%New("SYS.Shadowing.Shadow:List")
	s rc=rs.Execute()
	i ('rc) {
		w !!," Failed to get Shadow ID list. Error=",$System.Status.GetErrorText(rc)
		q
	}
	s list=""
	f  q:'rs.Next()  s list($i(list))=rs.Data("Name")
	if '$g(list) w !!,"No Shadow is configured." q
	if list>1 {
		s ShadowID=""
		s Flag=8+512+128
		s Status=##Class(%Library.Prompt).GetArray("Shadow ID?",.ShadowID,.list,,,,Flag)
	 	i (+Status=0)||(Status=2)||(ShadowID="") q
	} else {
		s ShadowID=list(1)
	}
	s mirlist=$p($G(^SYS("MIRRORSET")),"^",2)
	if mirlist="" w !,"No mirror set is configured." q
	for list=1:1:$l(mirlist,",") s list(list)=$p(mirlist,",",list)
	if list>1 {
		s mirname=""
		s Flag=8+512+128
		s Status=##Class(%Library.Prompt).GetArray("Mirror Set Name?",.mirname,.list,,,,Flag)
	 	i (+Status=0) q
	 	if (Status=2)||(mirname="") g getshdid
	 	w !
	} else {
		s mirname=list(1)
	}
	;if +$G(^SYS("MIRRORSET",mirname,"Member"))'=1 w !!,"Need only one failover member for shadow client to connect to" q
	s shdwobj=##class(SYS.Shadowing.Shadow).%OpenId(ShadowID)
	i '$isobject(shdwobj) w !!,"Invalid shadow '",ShadowID,"'." q
	if '##class(%Library.ShadowState).CanStart(shdwobj.Status) {
		w !,"Shadow '",ShadowID,"' is not stopped."
		w !,"It needs to be stopped before proceeding."
		w !,"Stop Shadow '"_ShadowID_"'? <Y> " r resp
		w !,"Stopping Shadow '",ShadowID,"'..."
		if "Nn"[$E(resp_"Y") w !," Abort!" q
		s rc=shdwobj.Stop()
		i ('rc) {
			w !,"Failed to stop Shadow '"_ShadowID_"'. Error:",$System.Status.GetErrorText(rc)
			q
		}
		w !,"Shadow '",ShadowID,"' is stopped."
	}
	k cpinfo
	s rc=##class(SYS.Shadowing.Shadow).CheckPointInfo(ShadowID,.cpinfo)
	if 'rc {
		w !!,"Failed to get shadow journal check point."
		q
	}
	s filename=$g(cpinfo(0,"JournalLocation","File"))
	s tfname=$g(cpinfo(0,"OldestOpenTranLoc","File"))
	if filename="" w !!,"Could not find shadow journal file." q
	s jrninfo=$zu(78,22,filename,99)
	s JrnFileCount=+$p(jrninfo,",",13+1)
	s JrnFileOffset=$g(cpinfo(0,"JournalLocation","Offset"))
	if 'jrninfo||('JrnFileCount) {  ;+1 to skip status code
		w !!,"Shadow check point journal file ",filename," is not a mirror journal file." q
		q
	}
	if tfname'="" {
		if '(+$P($ZU(78,22,tfname,13),",",2)) {
			w !!,"Shadow transaction check point journal file ",tfname," is not a mirror journal file." q
			q
		}
	}
	s rs=##class(%Library.ResultSet).%New("SYS.Shadowing.Shadow:DatabaseRedirections")
	s rc=rs.Execute(ShadowID)
	i ('rc) {
		w !!," Failed to get Shadow database list. Error=",$System.Status.GetErrorText(rc)
		q
	}
	k DstDB,SrcDB
	m SrcDB=shdwobj.DatabaseRedirection
	s nextdb=$o(SrcDB(""),1,dstdb)
	while (nextdb'="") {
		if $d(DstDB(dstdb)) {
			k SrcDB(DstDB(dstdb))
			k SrcDB(nextdb)
		} else {
			s DstDB(dstdb)=nextdb
		}
		s nextdb=$o(SrcDB(nextdb),1,dstdb)
	}
	k DstDB
	k srclist,dstlist
	s narray=0,ndb=0
	s nextdb=$o(SrcDB(""),1,dstdb)
	while (nextdb'="") {
		s dstdb=$zu(12,$p(dstdb,"^",3)),srcdb=$p(nextdb,"^",3)
		s dbobj=##class(SYS.Database).%OpenId(dstdb,,.rc)
		if ('(''rc) || dbobj.Mirrored || '##class(SYS.Database).CanDatabaseBeMirrored(dstdb)) {
			s nextdb=$o(SrcDB(nextdb),1,dstdb)
			continue
		}
		if ndb=50 s ndb=0,narray=narray+1
		s srclist(narray)=$g(srclist(narray))_$LB(srcdb)
		s dstlist(narray)=$g(dstlist(narray))_$LB(dstdb)
		s ndb=ndb+1
		s nextdb=$o(SrcDB(nextdb),1,dstdb)
	}
	if 'narray,'ndb w !!,"No shadow DB needs to be converted to mirrored DB." q
	s failed=0,Index=0
	k List
	for ii=0:1:narray {
		s srclist=srclist(ii),dstlist=dstlist(ii)
		s rc=$$GetMultipleDBInfo^MIRRORCTL(mirname,1,srclist)
		if $LG(rc)'="OK" s failed=1 q
		s dbinfo=$LG(rc,2)
		for ndb=1:1:$listlength(dbinfo) {
			s dstdb=$lg(dstlist,ndb)
			s onedb=$lg(dbinfo,ndb)
			if onedb'="" {
				s DstDB(dstdb)=$lb(onedb,$lg(srclist,ndb))
				s List($i(Index))=dstdb_" ("_$P(onedb,"^",2)_")"
			}
		}
	}
	if failed {
		if $LG(rc)="TIMEOUT" {
			s errstr="Connection timed out"
		} else {
			s errstr=$LG(rc,2)
		}
		w !!,"Failed to retrieve database info from primary, error:",errstr
		q
	}
	if Index=0 w !!,"No mirrored database in primary matched shadow database" q
promptdb ;
	s Flag=8+512+1024
	s DBPathList=""
	w !!,"A shadow database can be converted to a mirror database only if it has"
	w !,"a single source database and that database is mirrored on the primary member.",!
	s Status=##Class(%Library.Prompt).GetArray("Database to be converted?",.DBPathList,.List,,,,Flag)
 	i (+Status=0)||(Status=2)||(DBPathList="") q
 	w !!,"The following shadow database"_$s($ll(DBPathList)<2:" is",1:"s are")_" selected:"
	s ndb=$ll(DBPathList)
	f i=1:1:ndb w !,$li(DBPathList,i)
	w !
	i $$YN("Are you sure you want to convert selected shadow DB to mirrored DB","N")="N" {
		w !,"Aborted" 
		q
	}
	if $ll(DBPathList)<2 {
		s dbpath=$p($li(DBPathList,1)," (")
	    s dir=$zu(12,dbpath,2) i dir]"" s dbpath=dir
		i '$d(DstDB(dbpath)) {
			s dir0=$zu(12,dbpath,1)
			i dir0="" {
			 	i dir0="" w !!,"Invalid directory specification, please re-enter",! goto promptdb
			}
		 	s dbpath=$zu(12,dir0,3)
		 	i dbpath="" {
			 	w !!,"Directory "_dir0_" does not exist, please re-enter",! 
				goto promptdb
		 	}
			s dbinfo=$zu(49,dbpath)
			i (dbinfo<0)||(dbinfo>=$zu(40,0,41)) {
		 		w !!,"Database is not mounted, please re-enter",! 
				goto promptdb
			}
			i '$d(DstDB(dbpath)) w !!,"Selected DB is not a shadow database, please re-enter",! goto promptdb
		}
		s SelectedDB(dbpath)=$li(DstDB(dbpath))
	} else {	;multiple selected
		s ndb=$ll(DBPathList)
		f i=1:1:ndb {
			s dbpath=$p($li(DBPathList,i)," (")
			s SelectedDB(dbpath)=$li(DstDB(dbpath))
		}
	}
	k list,ndb,ConvertedDB
	s dbpath=$o(SelectedDB(""),1,dbinfo)
	while dbpath'="" {
		s dbname=$p(dbinfo,"^",2)
		s rc=##class(SYS.Mirror).AddDatabaseNonPrimary(dbpath,mirname,dbname,JrnFileCount,JrnFileOffset,dbinfo,0)
		if (''rc) {
			w !,"Shadow DB '",dbpath,"' is converted to mirrored DB '",dbname,"'."
			s $li(list,$i(ndb))=+$zu(49,dbpath)
			s ConvertedDB($LG(DstDB(dbpath),2))=""
		} else {
			w !,"Shadow DB '",dbpath,"' failed to be converted, error:",$SYSTEM.Status.GetErrorText(rc)
		}
		s dbpath=$o(SelectedDB(dbpath),1,dbinfo)
	}
	if $d(list) {
		r !,"Start catchup for converted database(s)? <Y> ",resp
		if "Nn"'[$E(resp_"Y") {
			JOB ##class(SYS.Mirror).CatchupDB(list)::5
			i $T {
				w !,"CatchupDB background job is started."
				w !,"You can run Mirror Monitor to check status of the databases."
			} else {
				w !,"Failed to start CatchupDB background job."
			}
		}
		w !!,"It is recommened to remove the converted databases from the shadow"
		w !,"database mapping. Otherwise the Shadow may try to apply journal records"
		w !,"to mirrored databases.",!
		r !,"Remove the converted database(s) from shadow database mapping? <Y> ",resp
		if "Nn"'[$E(resp_"Y") {
			s nextdb=$o(ConvertedDB(""))
			while nextdb'="" {
				d shdwobj.SetDatabaseNotToShadow(nextdb)
				s nextdb=$o(ConvertedDB(nextdb))
			}
			s rc=shdwobj.%Save()
			if (''rc) {
				w !,"Converted shadow databases are removed from shadow database mapping."
			} else {
				w !,"Failed to remove shadow database mapping. Error:",$SYSTEM.Status.GetErrorText(rc)
			}
		}
	}
}
AddNewMember() {
	if 0 w !!,"Managed by Enterprise Manager, operation not allowed." Quit
	s mirname=##class(Config.Mirrors).GetMirrorName()
	if mirname="" w !,"Could not find mirror set name." q
	s rs=##class(%Library.ResultSet).%New("SYS.Mirror:PendingNewMembers")
	d rs.Execute()
	while rs.Next() {
		s name=rs.Data("Name")
		s mlist($i(mlist)) = rs.Data("Name")_" ("_rs.Data("MemberTypeDisplay")_")"
		s minfo(name,"Name")=rs.Data("Name")
		s minfo(name,"MemberType")=rs.Data("MemberType")
		s minfo(name,"MemberTypeDisplay")=rs.Data("MemberTypeDisplay")
		s minfo(name,"AgentAddress")=rs.Data("AgentAddress")
		s minfo(name,"AgentPort")=rs.Data("AgentPort")
		s minfo(name,"ConnectsTo")=rs.Data("ConnectsTo")
		s minfo(name,"ECPAddress")=rs.Data("ECPAddress")
		s minfo(name,"GUID")=rs.Data("GUID")
		s minfo(name,"InstanceDirectory")=rs.Data("InstanceDirectory")
		s minfo(name,"MirrorAddress")=rs.Data("MirrorAddress")
		s minfo(name,"MirrorSSPort")=rs.Data("MirrorSSPort")
		s minfo(name,"SSLComputerName")=rs.Data("SSLComputerName")
		s minfo(name,"EncryptCommunication")=rs.Data("EncryptCommunication")
		s minfo(name,"AsyncMemberType")=rs.Data("AsyncMemberType")
	}
	if +$g(mlist)=0 w !,"No pending new member to be authorized." q
	s Flag=8+512+128
	s Selected=""
	s Status=##Class(%Library.Prompt).GetArray("Select a member to be "_$s($G(^SYS("MIRRORSET",mirname,"UseSSL")):"authorized",1:"added")_" or rejected?",.Selected,.mlist,,,,Flag)
 	i (+Status=0)||(Status=2)||(Selected="") q
 	s Selected=$p(Selected," (")
 	if '$d(minfo(Selected)) w !,"Selected member '",Selected,"' is not in the list." q
 	m params=minfo(Selected)
 	s savetype=params("MemberType")
 	s params("MemberType")=params("MemberTypeDisplay")
 	kill params("MemberTypeDisplay")
	; We want the ECPAddress property called superserver Address
	s params("SuperServerAddress")=$G(params("ECPAddress"))
	k params("ECPAddress")
	k params("PreferredArbiter")
	s cc2=params("ConnectsTo") k params("ConnectsTo")
	w !!,"Properties for member '",Selected,"':"
	do dumpparams(.params)
	s params("MemberType")=savetype
	s params("ECPAddress")=params("SuperServerAddress")
	k params("SuperServerAddress")
	s params("ConnectsTo")=cc2
	s name=Selected
    if savetype'=0 {
	    s ipaddr=##class(%SYSTEM.INetInfo).HostNameToAddr(params("ECPAddress"))
	    if '##class(%SYSTEM.INetInfo).CheckAddressExist(ipaddr) {
		    Set SameECPMirror=(params("ECPAddress")=params("MirrorAddress"))
		    if 'SameECPMirror {
			    s mipaddr=##class(%SYSTEM.INetInfo).HostNameToAddr(params("MirrorAddress"))
			    s SameECPMirror=(mipaddr=ipaddr)
		    }
		    if SameECPMirror||('##class(%SYSTEM.INetInfo).CheckAddressExist(mipaddr)) {
			    w !!,"The Superserver address '"_params("ECPAddress")_"'"
			    w:'SameECPMirror !,"and Mirror Private address '"_params("MirrorAddress")_"'"
			    w !,"of async member '"_name_"' "_$s(SameECPMirror:"is",1:"are")_" unreachable,"
			    w !,"so this member is rejected and removed from the pending list."
			    d ##class(SYS.Mirror).RemoveFromApprovalList(name,params("GUID"),mirname)
			    quit
		    }
	    }
    }
	w !!,"Enter 'A' to ",$s($G(^SYS("MIRRORSET",mirname,"UseSSL")):"authorize",1:"add")," the new member '"_name_"' to join."
	w !,"Enter 'R' to reject the '"_name_"' member from joining mirror,"
	w !,"     if you intend for the member '",name,"' on ",params("MirrorAddress")
	w !,"     to join this mirror (",mirname,"), but the Distinguished Name"
	w !,"     is unexpected, verify and correct the SSL configuration on that"
	w !,"     member and connect to the mirror again. Otherwise, edit the"
	w !,"     configuration of that member to remove it from '",mirname,"'."
	w !,"Enter '^' to quit."
again w !,"Select option 'A', 'R' or '^'? " r opt
	if opt="^" quit
	s opt=$E($zconvert(opt,"U")) if "AR"'[opt w "    wrong selection..." g again
	if opt="A" {
		if params("MemberType")=0,$G(^SYS("MIRRORSET",mirname,"Member"),0)'=0 {
			w !,"Failed to add new failover member '",name,"' because a backup member already existed."
			w !,"Please select 'R' to reject this pending request."
			quit
		}
		s rc=##class(Config.MapMirrors).Create(mirname,name,.params)
		if ('rc) {
			w !,"Failed to add new member '",name,"'. Error=",$SYSTEM.Status.GetErrorText(rc)
		} else {
			w !,"New member '",name,"' is added."
			d ##class(SYS.Mirror).RemoveFromApprovalList(name,params("GUID"))
			if $G(params("MemberType"))'=0 d NotifyAsyncMembers^MIRRORMGR(mirname,$G(params("Name")),1)
		}
	} else {
		if params("MemberType")=0 {
			s basedir=params("InstanceDirectory")
			s addrlist=params("AgentAddress")_"|"_params("AgentPort")
			if params("MirrorAddress")'=params("AgentAddress") {
				s addrlist=addrlist_","_params("MirrorAddress")_"|"_params("AgentPort")
			}
			if (params("ECPAddress")'=params("AgentAddress")) && (params("ECPAddress")'=params("MirrorAddress")) {
				s addrlist=addrlist_","_params("ECPAddress")_"|"_params("AgentPort")
			}
		} else {
			s addrlist=params("ECPAddress")_"|"_params("MirrorSSPort")
			s basedir=""
		}
		s targguid=params("GUID")
		s rc=$$RejectApprovalByAddr^MIRRORCTL(mirname,addrlist,targguid,basedir,$LB(name,params("GUID")))
		if $LG(rc)="OK" {
			w !,"New member '",name,"' is rejected."
		} else {
			w !,"Failed to reject member '",name,"', but it is still removed from pending list. Error=",$LG(rc,2)
		}
		d ##class(SYS.Mirror).RemoveFromApprovalList(name,params("GUID"),mirname)
	}
	q
}
PendingDNUpdates() {
	if 0 w !!,"Managed by Enterprise Manager, operation not allowed." Quit
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
	if +$G(^SYS("MIRRORSET")) {
	   s cnt=$$getAsyncMemberSources(.mirnames)
	   if 'cnt {
		   w !,"No Async member sources defined"
		   quit
	   }
	   if cnt=1 {
		   s mirname=mirnames(1)
	   } else {
		   s namelist=","
		   for i=1:1:cnt s namelist=namelist_mirnames(i)_","
		   w !,"This is an Async member tracking ",cnt," mirrors"
		   r !,"Enter name of mirror to check the DN Updates (? for list) ",mirname
		   s mirname=$zcvt(mirname,"U")
		   q:mirname=""
		   while (1) {
			   q:mirname=""||(namelist[(","_mirname_",")&&(mirname'[","))
			   if (mirname'="?") w "   does not exist!"
			   w !,"This node is tracking the following mirrors:"
			   w !,?5
			   for i=1:1:cnt w mirnames(i) w:i'=cnt ", " w:$X>75 !,?5 
	  	       r !,"Enter name of mirror to check the DN Updates? (? for list) ",mirname
			   s mirname=$zcvt(mirname,"U")
		   }
	   }
	} else {
	    s mirname=$p($G(^SYS("MIRRORSET")),"^",2)
	}
	if mirname="" {
		quit
	}
	s rs=##class(%Library.ResultSet).%New("SYS.Mirror:PendingDNUpdates")
	d rs.Execute(mirname)
	while rs.Next() {
		s mlist(mirname,$i(mlist)) = rs.Data("Name")_" ("_rs.Data("MemberType")_") ("_rs.Data("SSLComputerName")_")"
		s guid(mirname,rs.Data("Name"))=rs.Data("GUID")
	}
	if +$g(mlist)=0 w !,"No pending DN updates to be authorized." q
	d PromptForDNUpdates(mirname,.mlist,.guid)
}
PromptForDNUpdates(mirname,mlist,guid) {
	if $SYSTEM.Mirror.IsPrimary() {
		s Flag=8+512+128
		s info=""
		m mmlist=mlist(mirname)
		s Status=##Class(%Library.Prompt).GetArray("Select Member's DN to be updated or rejected?",.info,.mmlist,,,,Flag)
	 	i (+Status=0)||(Status=2)||(info="") q
		s name=$p(info," ("),DN=$p(info," (",3,999),DN=$e(DN,1,*-1)
		s idx=$o(^SYS("MIRRORSET",mirname,"Member",""),1,info)
		while idx'="" {
			if $LG(info)=name quit
			s idx=$o(^SYS("MIRRORSET",mirname,"Member",idx),1,info)
		}
		if idx="" w !,"Member '",name,"' does not exist in local mirror configuration, abort!" quit
	 	w !!,"Enter 'A' to authorize the new DN of '"_name_"' member."
	 	w !,"Enter 'R' to reject the DN update request from '"_name_"' member,"
	 	w !,"     if you intend for the member '",name,"' on ",$p($LG(info,4),"|")
	 	w !,"     to connect to this primary member, but the Distinguished Name"
	 	w !,"     is unexpected, verify and correct the SSL configuration on that"
	 	w !,"     member and connect to the mirror again. Otherwise, edit the"
	 	w !,"     configuration of that member to remove it from '",mirname,"'."
	 	w !,"Enter '^' to quit."
again 	w !,"Select option 'A', 'R' or '^'? " r opt
		if opt="^" quit
		s opt=$E($zconvert(opt,"U")) if "AR"'[opt w "    wrong selection..." g again
		if opt="A" {
			s props("SSLComputerName")=DN
			s rc=##class(Config.MapMirrors).Modify(mirname,name,.props)
			if '(''rc) {
				w !,"Failed to update member '",name,"'. DN is not updated. Error=",$SYSTEM.Status.GetErrorText(rc)
			} else {
				w !,"DN of member '",name,"' is updated."
				d ##class(SYS.Mirror).RemoveFromApprovalList(name,$g(guid(mirname,name)),mirname)
			}
		} else {
			s rc=$$RejectApproval^MIRRORCTL(mirname,idx,$LB(name,$g(guid(mirname,name))))
			if $LG(rc)="OK" {
				w !,"DN of member '",name,"' is rejected."
			} else {
				w !,"Failed to reject member '",name,"', but it is still removed from pending list. Error=",$LG(rc,2)
			}
			d ##class(SYS.Mirror).RemoveFromApprovalList(name,$g(guid(mirname,name)),mirname)
		}
		quit
	}
	w !!,"Mirror set name: ",mirname
	s total=$o(mlist(mirname,""),-1),ss=$s(total>1:"s",1:""),was=$s(total>1:" were",1:" was")
	f i=1:1:total w !,?5,i,") ",mlist(mirname,i)
	w !!,"The DN of above failover member",ss,was," changed."
	w !,"You need to authorize the DN change",ss," so the system could"
	w !,"connect to the primary member."
	i $$YN("Do you want to update DN of the member"_ss,"N")="N" {
		w !,"Aborted" 
		q
	}
	f i=1:1:total {
		s info=mlist(mirname,i)
		s name=$p(info," ("),DN=$p(info," (",3,999),DN=$e(DN,1,*-1)
		s props("SSLComputerName")=DN
		s rc=##class(Config.MapMirrors).Modify(mirname,name,.props)
		if '(''rc) {
			w !,"Failed to update member '",name,"'. DN is not updated. Error=",$SYSTEM.Status.GetErrorText(rc)
		} else {
			w !,"DN of member '",name,"' is updated."
			d ##class(SYS.Mirror).RemoveFromApprovalList(name,$g(guid(mirname,name)),mirname)
		}
	}
}
VerifySSLCertificates(IsAsync) {
	if IsAsync {
	   s cnt=$$getAsyncMemberSources(.mirnames)
	   if 'cnt {
		   w !,"No Async member sources defined"
		   quit
	   }
	   if cnt=1 {
		   s mirname=mirnames(1)
	   } else {
		   s namelist=","
		   for i=1:1:cnt s namelist=namelist_mirnames(i)_","
		   w !,"This is an Async member tracking ",cnt," mirrors"
		   r !,"Enter name of mirror to verify SSL certificates? (? for list) ",mirname
		   s mirname=$zcvt(mirname,"U")
		   q:mirname=""
		   while (1) {
			   q:mirname=""||(namelist[(","_mirname_",")&&(mirname'[","))
			   if (mirname'="?") w "   does not exist!"
			   w !,"This node is tracking the following mirrors:"
			   w !,?5
			   for i=1:1:cnt w mirnames(i) w:i'=cnt ", " w:$X>75 !,?5 
	  	       r !,"Enter name of mirror to verify SSL certificates? (? for list) ",mirname
			   s mirname=$zcvt(mirname,"U")
		   }
	   }
	} else {
	    s mirname=$p($G(^SYS("MIRRORSET")),"^",2)
	}
	if mirname="" {
		quit
	}
	w !,"Verifying Mirror SSL Certificates..."
	s rc=##class(SYS.MirrorConfiguration).VerifyMirrorSSLCertificates(mirname,1)
	if (''rc) w !,"There is no error found while verifying mirror SSL certificates." Q
	w !!,"The following errors are found during mirror SSL certficates verification.",!
	d $SYSTEM.Status.DisplayError(rc)
	w !
	q
}
DejournalFilter() {
	if 0 w !!,"Managed by Enterprise Manager, operation not allowed." Quit
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
	s cnt=$$getAsyncMemberSources(.names)
	if 'cnt {
		w !,"No Mirror Set is configured."
		quit
	}
listMirrors ;
	w !,"Mirror",?20,"Dejournal Filter"
	w !,"---------------",?20,"-------------------"
	s namelist=","
	for i=1:1:cnt {
		s mirname=names(i)
		s namelist=namelist_mirname_","
		s status=$LG(^SYS("MIRRORSET",mirname,"Member",0),12)
		w !,mirname,?20,status
	}
	if (cnt=1) {
		w !,"Change dejournal filter setting of ",names(1),"? <No> "
		r resp
		quit:"Yy"'[$E(resp_"X")
		s resp=names(1)
	} else {
		r !,"Change dejournal filter setting of which member (return to exit)? ",resp
		quit:resp=""
		if resp="?" goto listMirrors
		s mirname=","_$zcvt(resp,"U")_","
		while (resp'="") && (resp'="?") && (namelist'[mirname) {
			w !,resp," is not a mirror this instance is tracking"
			r !,"Change dejournal filter setting of which member (return to exit)? ",resp
			s mirname=","_$zcvt(resp,"U")_","
		}
		quit:resp=""
		if resp="?" goto listMirrors
	}
	s mirname=$zcvt(resp,"U")
	s ourinfo=$G(^SYS("MIRRORSET",mirname,"Member",0))
	if ourinfo="" w !,"Mirror is not initialized." Quit
retry ;
    s FilterClass=$LG(ourinfo,12)
	w !,"Current filter class name is ",$s(FilterClass="":"cleared.",1:"'"_FilterClass_"'.")
	s prompt="Please enter the new filter class name: "
	s help="Enter dejournal filter class name, or '-' to clear the dejournal filter class name."
	s Status=##Class(%Library.Prompt).GetString(prompt,.FilterClass,0,512,.help,8)
	i (+Status=0)!(+Status=2) quit
	if FilterClass="-" s FilterClass=""
	if FilterClass'=$LG(ourinfo,12) {
		if FilterClass'="" {
			s rc=##class(%Dictionary.CacheClassname).IsValid(FilterClass)
			if ('rc) {
				w !,"The class name is invalid."
				goto retry
			}
			Set fobj=##class(%Dictionary.CompiledClass).%OpenId(FilterClass,,.rc)
			if ('rc) {
				w !,"Entered class '",FilterClass,"' does not exist or be compiled."
				r !,"Are you sure you want to use this class for mirror dejournal filter <Y>? ",resp
				if "Nn"[$E(resp_"X") goto retry
			}
		}
		s mm=##class(Config.MapMirrors).Open(mirname,$LG(ourinfo),,,.rc)
		if '$IsObject(mm) {
			w !,"Failed to open Config.MapMirrors("""_mirname_""","""_$LG(ourinfo)_""") - Error = "_$SYSTEM.Status.GetErrorText(rc) 
			quit
		}
		s mm.DejournalFilter = FilterClass
		s rc=mm.%Save()
	    if (''rc) {
		    w !,"Dejournal filter class name for ",mirname," is ",$s(FilterClass="":"cleared.",1:"set to "_FilterClass)
	    } else {
		    w !,"Failed to save Config.MapMirrors("""_mirname_""","""_$LG(ourinfo)_""") - Error = "_$SYSTEM.Status.GetErrorText(rc)
	    }
	} else {
		w !,"Dejournal filter is not changed."
	}
}
ProcessValidationFailure() PUBLIC {
	s $zt="err"
	if 0 {
		w !!,"System subscribed to EMS, the EMS must be used to resolve the problem(s)" 
		Quit
	}
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") {
		w !,"Operation requires %Admin_Manage:Use privilege" 
		q
	}
	k failure
	s matchcnt=##class(SYS.MirrorConfiguration).LookupLocalValidationFailures(.failure,0)
	if matchcnt=0 quit 1
	if matchcnt>1 {
	   w !,"This async member has validation failures for multiple mirrors which it is a member of."
	}
	;
	s mtype=+$G(^SYS("MIRRORSET")) ;0 is failover
	;
	if $D(failure("TIMEOUT")) {
		s mirname=$O(failure("TIMEOUT",""),1,info)
		s info=$LG(info,2)  ;^SYS("MIRRORSET",<name>,"Member",0) list which failed
		s sysname=$LG(info,1)  ;our name, should match MirrorMember.Name
		s basedir=$LG(info,6)
	    s ecpip=$lg(info,3)
	    s mirip=$lg(info,4)
		w !,"Local instance validation timed out trying to reach this member at"
		w !,"     """,ecpip,""""
		if ecpip'=mirip w " or """,mirip,""""
        w !,"The system will continue to retry so if the configuration is correct"
        w !,"  no further action needs to be taken (apart from resolving the network issue)."
	    w !,"If this mirror member has been copied, the mirror configuration "
	    w !,"  should be deleted or this instance should added as a new member."
        w !,"If the network configuration of this member has changed,"
        w !,"  then the address(es) of this member in the configuration must be"
        w !,"  corrected."
        w !
        do {
           w !,"Available options are: (Q)uit, (C)hange network addresses,"
           w !,"     (D)elete mirror configuration or (J)oin this mirror as a new member? "
           read resp
           s resp=$E($ZCVT(resp_"X","U"))
        } while "QCJD"'[resp
        if resp="Q" quit
        if resp="C" {
	        do {
	           w !,"Enter new network address(es) for ",sysname," in ",mirname
	           s rc=$$GetNewNetworkAddresses(mirname,sysname,1)
	           q:'rc
			   k ^SYS("MIRRORSET",":LocalValidationFailure",mirname)
		       s mirname=$O(failure("TIMEOUT",mirname),1,info)
	        } while (mtype>0) && (mirname'="")
        } elseif resp="D" {
	        s rc=$$DeleteLocalConfig()
        } else {
	        s rc=$$ResetAndAdd(mirname,mtype)
			s mirname=$O(failure("TIMEOUT",mirname),1,info)
	        while rc && (mirname'="") {
		        do {
		           w !,"Do you want also want to join ",mirname,"? "
		           r resp
		        } while "YyNn"'[$E(resp_"X")
		        if "Yy"[$E(resp) {
			        s rc=$$ResetAndAdd(mirname,mtype)
		        }
				s mirname=$O(failure("TIMEOUT",mirname),1,info)
	        }
        }
        q:'rc
	    ; If this is an async then there may be more failures to deal with
    	k failure("TIMEOUT")
        if '$D(failure) {
       	   quit 
		}
	}
	if $D(failure("BADDIR")) {
		s mirname=$O(failure("BADDIR",""))
		s info=$G(^SYS("MIRRORSET",mirname,"Member",0))
		if info="" {
			w !,"Failed to locate this system in the mirror definition for ",mirname
			quit
		}
		s basedir=$LG(info,6)
		s mgrdir=basedir_"mgr"
		s mgrdir=$ZU(12,mgrdir) ; canonize it
		S locmgr=$ZU(12)
		w !,"The local manager's directory, ",locmgr
		w !,"   does not match the configured manager's directory, ",mgrdir
		w !,"   for the mirror (",mirname,") which suggests that this instance has"
		w !,"   been copied or restored to a new location."
		w !,"If this instance is the active member being started in a new location,"
		w !,"   the base directory (and possibly network addresses) need to be"
		w !,"   updated in the mirror configuration before it can be started. If this"
		w !,"   is a copy of a mirror instance then either this needs to be defined"
		w !,"   as a new member in the mirror, with its own name, addresses, etc. or"
		w !,"   the mirror configuration should be deleted if it is not supposed to"
		w !,"   be a member of the mirror."
		w !,"If you want to build a new mirror around this copy, delete the mirror "
		w !,"   config, and create a new mirror."
		w !
        do {
           w !,"Available options are: (Q)uit, (C)hange base directory in the configuration,"
           w !,"     (D)elete mirror configuration or (J)oin this mirror as a new member? "
           read resp
           s resp=$E($ZCVT(resp_"X","U"))
        } while "QCDJ"'[resp
        if resp="Q" quit  ; return 
        if resp="C" {
			s basedir=$ZU(12,"..")
			do {
				w !,"Confirm changing base directory of this instance to ",basedir,"? "
				r resp
			} while "YyNn"'[$E(resp_"X")
			if "Nn"[$E(resp) {
				w !,"Aborted"
				quit
			}
			do {
		       s rc=$$FixBaseDirectory(mirname,sysname,basedir)
		       quit:'rc  ;there was an error
			   k ^SYS("MIRRORSET",":LocalValidationFailure",mirname)
		       s mirname=$O(failure("BADDIR",mirname),1,info)
	        } while (mtype>0) && (mirname'="")
        } elseif resp="D" {
	        s rc=$$DeleteLocalConfig()
        } else {
	        s rc=$$ResetAndAdd(mirname,mtype)
			s mirname=$O(failure("BADDIR",mirname),1,info)
	        while rc && (mirname'="") {
		        do {
		           w !,"Do you want also want to join ",mirname,"? "
		           r resp
		        } while "YyNn"'[$E(resp_"X")
		        if "Yy"[$E(resp) {
			        s rc=$$ResetAndAdd(mirname,mtype)
		        }
				s mirname=$O(failure("BADDIR",mirname),1,info)
	        }
        }
        q:'rc
	    ; If this is an async then there may be more failures to deal with
    	k failure("BADDIR")
        if '$D(failure) {
       	   quit 
		}
	}
	if $D(failure("BADADDR")) {
		s mirname=$O(failure("BADADDR",""))
		s info=$G(^SYS("MIRRORSET",mirname,"Member",0))
		if info="" {
			w !,"Failed to locate this system in the mirror definition for ",mirname
			quit
		}
		s sysname=$LG(info,1)  ;our name, should match MirrorMember.Name
		s basedir=$LG(info,6)
	    s ecpip=$lg(info,3)
	    s mirip=$lg(info,4)
		w !,"Local instance validation failed trying to reach this member at"
		w !,"     """,ecpip,""""
		if ecpip'=mirip w " or """,mirip,""""
		w !,"The system which was reached at this address was not the local instance."
	    w !,"   which suggests that this is a copy of an active mirror member."
	    w !,"Either this instance needs to be defined as a new member in the mirror,"
	    w !,"   with its own name, addresses, etc. or the mirror configuration should" 
	    w !,"   be deleted if it is not supposed to be a member of the mirror."
		w !,"If you want to build a new mirror around this copy, delete the mirror "
		w !,"   config, and create a new mirror."
		w !
        do {
           w !,"Available options are: (Q)uit, (D)elete mirror configuration "
           w !,"                            or (J)oin this mirror as a new member? "
           read resp
           s resp=$E($ZCVT(resp_"X","U"))
        } while "QDJ"'[$E(resp)
        if resp="Q" quit  ; return 
        if resp="D" {
	        s rc=$$DeleteLocalConfig()
        } else {
	        s rc=$$ResetAndAdd(mirname,mtype)
			s mirname=$O(failure("BADADDR",mirname),1,info)
	        while rc && (mirname'="") {
		        do {
		           w !,"Do you want also want to join ",mirname,"? "
		           r resp
		        } while "YyNn"'[$E(resp_"X")
		        if "Yy"[$E(resp) {
			        s rc=$$ResetAndAdd(mirname,mtype)
		        }
				s mirname=$O(failure("BADADDR",mirname),1,info)
	        }
        }
        q:'rc
	    ; If this is an async then there may be more failures to deal with
    	k failure("BADADDR")
        if '$D(failure) {
       	   quit
		}
	}
    ; If we're here then we have failures of "ERR" type where something
    ; went wrong during local validation. The best we can do is print a
    ; message and ask them to fix it up. They can use ^MIRROR config options to
    ; adjust addresses, remove this system, etc.
    w !,"The following unexpected errors were encountered during local system validation.",!
	s mirname=$O(failure("ERR",""),1,info)
	while mirname'="" {
		s status=$LG(info,2)
		s msg=$LG(info,3)
		w !,mirname,": ",msg
		if status'=0 w !,?5 do $SYSTEM.Status.DisplayError(status)
		w !
		s mirname=$O(failure("ERR",mirname),1,info)
	}
	s mirname=$O(failure("ERR",""))
	if mirname'="" {
		s info=$G(^SYS("MIRRORSET",mirname,"Member",0))
		if info="" {
			w !,"Failed to locate this system in the mirror definition for ",mirname
			Quit
		}
		s sysname=$LG(info,1)  ;our name, should match MirrorMember.Name
	    s ecpip=$lg(info,3)
	    s mirip=$lg(info,4)
		w !!,"The error is most likely casued by the wrong network address"
		w !,"     """,ecpip,""""
		if ecpip'=mirip w " or """,mirip,""""
		w !,"configured in local member. It can't reach the local instance,"
		w !,"instead it reached a different running instance."
	    w !,"If this mirror member has been copied, the mirror configuration "
	    w !,"  should be deleted or this instance should added as a new member."
        w !,"If the network configuration of this member has changed,"
        w !,"  then the address(es) of this member in the configuration must be"
        w !,"  corrected."
        w !,"If you choose to change the network address(es) you need to make sure"
        w !,"  the address(es) of this member in the expected primary member"
        w !,"  has the matching correct network address(es) before you can"
        w !,"  restart mirroring of this local instance."
        w !
        do {
           w !,"Available options are: (Q)uit, (C)hange network addresses,"
           w !,"     (D)elete mirror configuration or (J)oin this mirror as a new member? "
           read resp
           s resp=$E($ZCVT(resp_"X","U"))
        } while "QCJD"'[resp
        if resp="Q" Quit
        if resp="C" {
	        do {
	           w !,"Enter new network address(es) for ",sysname," in ",mirname
	           s rc=$$GetNewNetworkAddresses(mirname,sysname,1)
	           q:'rc
			   k ^SYS("MIRRORSET",":LocalValidationFailure",mirname)
		       s mirname=$O(failure("ERR",mirname))
	        } while (mtype>0) && (mirname'="")
        } elseif resp="D" {
	        s rc=$$DeleteLocalConfig()
        } else {
	        s rc=$$ResetAndAdd(mirname,mtype)
			s mirname=$O(failure("ERR",mirname))
	        while rc && (mirname'="") {
		        do {
		           w !,"Do you want also want to join ",mirname,"? "
		           r resp
		        } while "YyNn"'[$E(resp_"X")
		        if "Yy"[$E(resp) {
			        s rc=$$ResetAndAdd(mirname,mtype)
		        }
				s mirname=$O(failure("TIMEOUT",mirname))
	        }
        }
        q:'rc
	    ; If this is an async then there may be more failures to deal with
    	k failure("ERR")
        if '$D(failure) {
       	   quit 
		}
	}
	w !,"Please take the necessary action to correct the errors. The ^MIRROR"
	w !,"  configuration options cannot be used until the validation problem"
	w !,"  is resolved."
    quit
err ;
	w !,"Unexpected error: ",$ZE
	quit 
}
ResetAndAdd(mirname,membertype) {
	s $zt="err"
	;s mm=##class(Config.MirrorMember).Open()
	;s mm.SystemName=""
	;s mm.ValidatedMember=0
	;s mm.JoinMirror=0
	;s rc=mm.%Save()
	;i $$$ISERR(rc) {
	;	w !,"Failed to save change to clear old mirror configuration: ",$SYSTEM.Status.GetErrorText(rc)
	;	quit 0
	;}
	Set tObj = ##class(Config.Mirrors).Open(mirname,,,.status)
	if ('status) {
		w !,"Failed to open the mirror configuration for "_mirname_". Error:",$SYSTEM.Status.GetErrorText(status)
		quit 0
	}
	Set sslc=##class(Security.SSLConfigs).%OpenId("%MirrorClient",,.status)
	Set ssls=##class(Security.SSLConfigs).%OpenId("%MirrorServer",,.status)
	s sslconfigured=$isobject(sslc)||$isobject(ssls)
	if tObj.UseSSL,'sslconfigured {
		w !,"The mirror uses SSL and there is no local Mirror SSL"
		w !,"Configuration set up. This needs to be created (^SECURITY)"
		w !,"before continuing."
		quit 0
	}
	; count the # of existing failover members and locate the
	; current primary
	s failovercnt=0
	s primaryid=""
	s id=$O(^SYS("MIRRORSET",mirname,"Member", ""),1,info) 
	while ((id'="") && (+id < 100)) {  ;100 is the start of the reporting members
		s mtype=+$LG(info,8)
		if mtype=0 {
			s failovercnt=failovercnt+1
		}
		s status=$$GetStatus^MIRRORCTL(mirname,id)
		if $LG(status)="PRIMARY" {
			s primaryid=id
		}
		s id=$O(^SYS("MIRRORSET",mirname,"Member",id),1,info)
	}
	if primaryid="" {
		w !,"Cannot locate primary member for mirror: "_mirname
		if sslconfigured {
			s rc=##class(SYS.MirrorConfiguration).VerifyMirrorSSLCertificates(mirname,0)
			if '(''rc) {
				w !,"Mirror SSL certificates verification returned the following errors:",!
				d $SYSTEM.Status.DisplayError(rc)
				w !,"If the primary is running, the local SSL configuration may be the problem"
				w !,"otherwise start the primary and try again."
				quit 0
			}
		}
		w !,"Start the primary and try again"
		if tObj.UseSSL {
			w ".",!,"If the primary is running, the SSL configuration may be causing the problem."
		}
		quit 0
	}
	s info=^SYS("MIRRORSET",mirname,"Member",primaryid)
	s InstanceName=$LG(info,1)
	s BaseDirectory=$LG(info,6) ; base directory for current primary
	s agentaddr=$LG(info,5)
	s ipaddr=$P(agentaddr,"|")
	s port=$P(agentaddr,"|",2)
	s primaryInfo=$LB(ipaddr, port, BaseDirectory)
	;
	do {
	   r !,"Confirm reset of mirror information and add as new member? ",resp
	} while "YyNn"'[$E(resp_"X")
	if "Nn"[$E(resp) {
		w !,"Aborted"
		quit 0
	}
	; If the cloned member was an async (membertype'=0) or there are already
	; 2 failover members, then we only get to join as an async
	if membertype || (failovercnt = 2) {
		s newtype=2  ; join as async
	} else {
		do {
		   r !,"Join mirror as (f)ailover or (a)sync member? ",resp
		} while "FfAa"'[$E(resp_"X")
		if "Ff"[$E(resp) {
			s newtype=1
		} else {
			s newtype=2
		}
	}	
	; MirrorInfo, SystemName and AsyncMember are returned from GetLocalConfigInfo
	; AsyncMemberType is passed as zero so that GetLocalConfigInfo will ask what
	;       kind of member this instance should become
	s AsyncMemberType=0
	s ok=$$GetLocalConfigInfo(newtype,tObj,primaryInfo,.sslconfigured,.SystemName,.MirrorInfo,.AsyncMemberType)
	if 'ok quit 0
	if SystemName="" {
		;GetLocalConfigInfo returns "" for SystemName if the config lists this
		; system as an async member so ask for it now
	 	s SystemName=$$GetLocalSystemName()
	}
	do {
		w !,"Are you sure you want to join Mirror Set '",mirname,"' as "
		w $s(newtype=1:"a failover",1:"an async")," member? " 
		r resp
	} while "YyNn"'[$E(resp_"x")
	quit:"Nn"[$E(resp) 0
	;
	; clean out local mirror config but don't delete databases or remove journals
	s status=##class(SYS.MirrorConfiguration).RemoveLocalMirrorConfiguration(mirname,0,0) 
	if ('status) {
		w !,"Failed to remove the local mirror configuration for ",mirname
		w ": " do $System.Status.DisplayError(status)
		quit 0
	}
	s mm=##class(Config.MirrorMember).Open()
	if $IsObject(mm) {
		k ^SYS("MirrorVersion")
		k ^SYS("FirstMirrorStartSinceInstall")
		s mm.AsyncMemberGUID=""
		s mm.JoinMirror=0
		s mm.SystemName=""
		s mm.ValidatedMember=0
		s mm.VirtualAddressInterface = ""
		s mm.AsyncMemberType = 0
		s mm.AsyncUseSystemPurgeInterval = 0
		s rc=mm.%Save()
		s mm=""
		if ('rc) {
			w !,"Error clearing MirrorMember setting: ",$System.Status.GetErrorText(rc)
		}
	}
	s rc=$SYSTEM.Mirror.Clear()  ;remove loaded mirror config
	;Wait for the MIRRORMGR job to exit so it does not get confused by the
	;new config and because $$Join... will fail if it is still up
	for i=1:1:6 {
		quit:'$$CheckMirrorRunning^MIRRORMGR(mirname,0)
		h 5
	}
	if $$CheckMirrorRunning^MIRRORMGR(mirname,0) {
		w !,"MIRROR Manager for "_mirname_" failed to exit in 30 seconds after"
		w !,"the mirror configuration was deleted. Cannot join mirror until this"
		w !,"job exits."
		quit 0
	}
	; Config.Mirrors.Delete() kills ^SYS("MIRRORSET",mirname) but
	;   does not always reset ^SYS("MIRRORSET")
	s memberlist=$P($G(^SYS("MIRRORSET")),"^",2)
	s membercnt=$L(memberlist,",")
	if ((membertype=0) || (membercnt=1)) {
		k ^SYS("MIRRORSET")  ;we're a member of 1 mirror, kill the global
		Try { s zZzZz1245=$zu(68,28,0) Kill ^MIRROR do $zu(68,28,zZzZz1245) k zZzZz1245} catch { i $d(zZzZz1245) { do $zu(68,28,zZzZz1245) k zZzZz1245} ztrap $ze }
	} else {
		; we're a member of multiple mirrors, remove us from the list 
		s namelist=$P(^SYS("MIRRORSET"),"^",2)
		s namecnt=$L(namelist,",")
	    s newlist=""
	    f i=1:1:namecnt {
		    s name=$P(namelist,",",i)
		    if name'=mirname {
			    s:$L(newlist) newlist=newlist_","
			    s newlist=newlist_name
		    }
	    }
	    s $P(^SYS("MIRRORSET"),"^",2)=newlist
	}
	;
	if newtype=1 {
		s rc=##class(SYS.Mirror).JoinMirrorAsFailoverMember(mirname,SystemName,BaseDirectory,ipaddr,port,.MirrorInfo)
	} else {
		s rc=##class(SYS.Mirror).JoinMirrorAsAsyncMember(mirname,SystemName,BaseDirectory,ipaddr,port,AsyncMemberType,.MirrorInfo)
	}
	i ('rc) {
		w !,"Removed prior mirror configuration but failed to join"
		w !,"mirror set '",mirname,"' as ",$s(newtype=1:"a failover",1:"an async")," member."
		w !," Error:",$SYSTEM.Status.GetErrorText(rc)
		quit 0
	}
	w !,"Succesfully joined mirror set '",mirname,"' as ",$s(newtype=1:"failover",1:"async")
	if tObj.UseSSL&&(newtype=1) {
		 w !,"Don't forget to authorize this node to join the configuration on the primary member."
	}
	s tObj=""
    k ^SYS("MIRRORSET",":LocalValidationFailure",mirname)
	quit 1
err ;
	s $zt=""
	if $ZE["<INTERRUPT>" {
		w !,"Aborted."
		quit 0
	}
	d BACK^%ETN
	w !,"Unexpected error logged: ",$ZE
	quit 0	
}
FixBaseDirectory(mirname,member,newbasedir) {
	s $zt=""
	s mm=##class(Config.MapMirrors).Open(mirname,member,,,.rc)
	if ('rc) {
		w !,"Failed to open member "_member_" in "_mirname_". Error:",$SYSTEM.Status.GetErrorText(rc)
		quit 0
	}
	s mm.InstanceDirectory=newbasedir
	s rc=mm.%Save()
	if ('rc) {
		w !,"Error saving configuration for ",member," in ",mirname," (",$SYSTEM.Status.GetErrorText(rc)
		w ") - Base directory not changed"
		quit 0
	}
	quit 1
err ;
	s $zt=""
	if $ZE["<INTERRUPT>" {
		w !,"Aborted."
		quit 0
	}
	d BACK^%ETN
	w !,"Unexpected error logged: ",$ZE
	quit 0	
}
DeleteLocalConfig() {
	s $zt="err"
	w !!,"Do you also want to remove mirror attribute of"
	w !,"mirrored databases (the databases themselves will not be deleted)? <No> "
	r resp
	if "Yy"[$E(resp_"n") {
		s deleteDBs=1
		w !,"The mirrored databases' mirror attribute will be removed."
	} else { 
		s deleteDBs=0
		w !,"The mirrored databases' mirror attribute will not be removed."
	}
	s deleteJournals=1
	;	
	; Get a list of the mirrors in mirrorList()
 	Set rs=##class(%Library.ResultSet).%New("Config.Mirrors:List")
 	s rc=rs.Execute()
 	if rc {
 	   While (rs.Next()) {
	      s mirname=rs.Data("Name")
		  s mirrorList(mirname)=""
		}
 	}
	s rs=""
	s mirname=$O(mirrorList(""))
	if mirname="" {
		w !,"No mirrors found in configuration to remove"
		quit 1  ;I guess this is ok
	}
	while (mirname'="") {
		s status=##class(SYS.MirrorConfiguration).RemoveLocalMirrorConfiguration(mirname,deleteDBs,deleteJournals)
		if ('status) {
			s msg="Failed to remove the local mirror configuration for "_mirname
			s msg=msg_": "_$System.Status.GetErrorText(status)
			w !,msg
			do $ZU(9,"",msg)  ;record this in the message log
		}
		s mirname=$O(mirrorList(mirname))
	}
	s mm=##class(Config.MirrorMember).Open()
	if $IsObject(mm) {
		k ^SYS("MirrorVersion")
		k ^SYS("FirstMirrorStartSinceInstall")
		s mm.AsyncMemberGUID=""
		s mm.JoinMirror=0
		s mm.SystemName=""
		s mm.ValidatedMember=0
		s mm.VirtualAddressInterface = ""
		s mm.AsyncMemberType = 0
		s mm.AsyncUseSystemPurgeInterval = 0
		s rc=mm.%Save()
		s mm=""
		if ('rc) {
			s msg="Error clearing MirrorMember setting: "_$System.Status.GetErrorText(rc)
			w !,msg
			do $ZU(9,"",msg)
		}
	}
	; Config.Mirrors.Delete() kills ^SYS("MIRRORSET",mirname) but
	;   does not always reset all of ^SYS("MIRRORSET")
	k ^SYS("MIRRORSET") 
	s rc=$SYSTEM.Mirror.Clear()  ;remove mirror config from memory
	;
	w !,"Done"  ;let them know we succeeded
	quit 1
err ;
	s $zt=""
	if $tlevel trollback
	if $ZE["<INTERRUPT>" {
		w !,"Aborted."
		quit 0
	}
	d BACK^%ETN
	w !,"Unexpected error logged: ",$ZE
	quit 0
}
YN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YN"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"yn","YN") I "^YN"'[R W "  enter Yes or No, please"
 S POP=(R="^") W $E($S(R="N":"No",R="Y":"Yes",1:""),$L(X)+1,3) Q R

MIRRORCOMM^INT^1^67214,47330
MIRRORCOMM ;2nd half of MIRRORMGR ;$Change: 7440104 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ;; Revision: $Id: //iris/2024.1.3/databases/sys/rtn/sysconfig/mirrorcomm.mac#1 $
 ;This routine holds the subroutines of ^MIRRORMGR which
 ; are jobbed off to form the data channel and the communication
 ; channel for the mirror. These were split out of ^MIRRORMGR
 ; because MIRRORMGR.MAC/MIRRORMGR.OBJ became too large.
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/FILEINC.inc#1 $ ($Change: 7440104 $) */
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/_syMirror.inc#1 $ ($Change: 7440104 $) */
        /* Initializing is the state a member has at startup until it
           gets to wait^MIRRORMGR for the 1st time. At that point it has 
           either become the backup or primary or we set the role to null
           to indicate that it is up and running as opposed to still getting
           started */
				    /* Arbiter failover rules are in effect */
				    /* Agent contact is required */
					/* IsOtherNodeDown^ZMIRROR */
				/* The client supports the arbiter */
			 	/* This system is connected to the arbiter */
		  		/* The other failover member is connected to the arbiter */
		  		/* Either the QOSTimeout changed or the arbiter address changed.
		  		   we should look up the current values and use them */
				/* Arbiter job shoud close the connection and exit. The
				   retry routine can restart the arbiter if conditions
				   warrent. Generally used with clearing ArbiterSupported
				   when the backup is removed or demoted. Cleared when
				   the arbiter exits (eg. its a one time flag). */
Primary(mirname,io,id,options) PUBLIC {
	; Called to handle a data connection and we're the primary
	; mirror member
	;
	s entry="Primary^"_$ZN
	s $ZT="err"
	s logerr=1  ; record errors in ^%ET
	;	
    if '$SYSTEM.Security.Check("%Admin_Manage","USE") {
	   d $zu(9,"","Insufficient privilege to run "_entry,1 /* broadcast and log message*/,2  /* Severe error */)
	   quit
    }
    s cls=##class(Config.Mirrors).Open(mirname,,,.rc)
    if ('rc) {
	    d $zu(9,"","Primary failed to open mirror configuration",1 /* broadcast and log message*/,2  /* Severe error */)
	    quit
    }
	s mirguid=cls.GUID
	s cls=""
	s cls=##class(Config.MirrorMember).Open(,,.rc)
    if ('rc) {
	    d $zu(9,"","Primary failed to open mirror member configuration",1 /* broadcast and log message*/,2  /* Severe error */)
	    quit
    }
    s systemid=cls.SystemName
    s cls=""
    ;
	; Make sure the manager is running and get its pid. We don't simply
	; take the pid of the process which jobs us
	if '##class(SYS.Mirror).IsMirrorStarted(mirname) {
		d $zu(9,"",entry_" manager process not running",1 /* broadcast and log message*/,2  /* Severe error */)
		quit
	}
	s mgrpid=$G(^MIRROR(mirname,"MgrJobID"))
	l +^SYS("MIRRORSET",mirname,"PrimaryServer",id):5
	if '$T {
		d $zu(9,"",entry_": Failed to lock ^SYS("",MIRRORSET"",""PrimaryServer"","_id_")",1 /* broadcast and log message*/,2  /* Severe error */)
		quit
	}
    s ripaddr=$SYSTEM.TCPDevice.PeerAddrPort()
    d $zu(61,12,$zu(61),$lg(^SYS("MIRRORSET",mirname,"Member",id)))
    d $zu(61,15,$zu(61),$lg(ripaddr,1)_"|"_$lg(ripaddr,2))
	;
	; Up above we do not post failure messages because either
	; the manager isn't running (who reads messages) or we
	; can't get the lock for the BackupClient (another one
	; is running). From now on though until we release the
	; BackupClient lock, we call post() if we exit.
	;
	s ^SYS("MIRRORSET",mirname,"PrimaryServer",id)=+$J
	s ^MIRROR(mirname,"Status","Member",id,"Role")="BACKUP"
	;
	; options are negotiated in SendVerifyID/ReadVerifyID. This only
	; contains features we support and if the client asks for something
	; we don't know about, its ignored.
	s IncomingMember=$lg($G(^SYS("MIRRORSET",mirname,"Member",id),$LB("Unknown")))
	s ^MIRROR(mirname,"lastconnected",IncomingMember)="PRIMARY"_"^"_$ZTIMESTAMP
    s rc=$SYSTEM.Mirror.FailoverServer(mirname,options)
	s ^SYS("MIRRORSET",mirname,"PrimaryServer",id)=""
	s rcx=$SYSTEM.Mirror.SetSystemGlobal($LB("MIRROR",mirname,"lastdisconnected",IncomingMember),"PRIMARY"_"^"_$ZTIMESTAMP)
	if (rcx) {
		if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","Primary("_mirname_"): lastdisconnected of '"_IncomingMember_"' set to '"_"PRIMARY"_"^"_$ZTIMESTAMP_"' with JRNMIRSET record")
	}
    c io
    do post(mirname,+mgrpid,id,"MIRDOWN:"_rc_":SERVEREXIT")
    l -^SYS("MIRRORSET",mirname,"PrimaryServer",id)
    quit
err ;
	s $Zt=""
	s:$G(^SYS("MIRRORSET",mirname,"PrimaryServer",id))=+$J ^SYS("MIRRORSET",mirname,"PrimaryServer",id)=""
	d $zu(9,"",entry_": Unexpected error in Primary server mirror job: "_$ZE,1 /* broadcast and log message*/,2  /* Severe error */)
	i $d(IncomingMember) {
		s rc=$SYSTEM.Mirror.SetSystemGlobal($LB("MIRROR",mirname,"lastdisconnected",IncomingMember),"PRIMARY"_"^"_$ZTIMESTAMP)
		if (rc) {
			if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","Primary("_mirname_"): lastdisconnected of '"_IncomingMember_"' set to '"_"PRIMARY"_"^"_$ZTIMESTAMP_"' with JRNMIRSET record")
		}
	}
	c io
    do post(mirname,+mgrpid,id,"MIRDOWN:0:SVRERROR")
	l -^SYS("MIRRORSET",mirname,"PrimaryServer",id)
	d:logerr BACK^%ETN
	quit  
}
Backup(mirname,io,id,options,mgrpid) PUBLIC {
	/* Called either with an open tcp channel to the primary and we should
	   start the client side of mirroring or jobbed off to make an outgoing 
	   connection to the primary mirror server and then start the client 
	   side of the connection.
	   io can be null in which case id is the # of the system for us
	      to contact.
	   When io is not null then we recieved a connection request in
	     Server from another system which specified "M"_$C(1)_"R"_"d"
	     and we're a mirror backup system so it came here to handle 
	     it. id is the id of the system which contacted us.
	   Before this routine exits it posts one of several events back to
	   the MIRRORMGR job:
	      MIRDOWN - $SYSTEM.Mirror.Client() returned because the connection
	                to the primary was lost
	      BACKUPRESET - An unexpected error occured involving something that 
	                    should have already succeeded in ^MIRRORMGR. Restart
	                    ^MIRRORMGR up high to detect the error there
	      BACKUPRESTART - The state changed while we were connecting. For instance
	                    the other node is not the primary any more. Restart at
	                    the top of the Restart loop
	      BACKUPCONNECTFAILED - Failed to establish the TCP connection to the primary.
	                    Retry but delay as required.
	*/
	s entry="Backup^"_$ZN
	s $ZT="err"
	s posted=0
	s logerr=1  ; record errors in ^%ET
    if '$SYSTEM.Security.Check("%Admin_Manage","USE") {
	   d $zu(9,"","("_mirname_") Insufficient privilege to run "_entry,1 /* broadcast and log message*/,2  /* Severe error */)
	   quit
    }
	s dejournalrunning=0  ;JO2359
	s miridx=$SYSTEM.Mirror.MirrorNameToIndex(mirname,1)+1
	;	
	s mirguid=$G(^SYS("MIRRORSET",mirname,"GUID"))
    s systemid=$G(^SYS("MIRRORSET",mirname,"Member",0))
    ;
	l +^SYS("MIRRORSET",mirname,"BackupClient"):5
	if '$T {
		d $zu(9,"",entry_": Failed to lock ^SYS("",MIRRORSET"",""BackupClient"")",1 /* broadcast and log message*/,2  /* Severe error */)
		quit
	}
	s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
	if info="" {
	    do post(mirname,+mgrpid,id,"BACKUPRESET:0:Bad node info")
	    l -^SYS("MIRRORSET",mirname,"BackupClient")
	    quit
	}
	s name=$lg(info,1)
    s mtype=+$lg(info,8)  ;0 = failover, 2 = async
    s timeout=20
    if mtype=0 {
	    /* If we're connecting to a failover node then it needs to be the primary */
		do {
			s rc=$$GetStatus^MIRRORCTL(mirname,id)
			s status=$LG(rc)
			if status'="PRIMARY" {
				h 1 s timeout=timeout-1
				if 'timeout quit
			}
		} while status'="PRIMARY"
		if status'="PRIMARY" {
			do post(mirname,+mgrpid,id,"BACKUPRESTART:0:Remote is not a primary node")
			l -^SYS("MIRRORSET",mirname,"BackupClient")
			quit
		}
		if '$$SynchConfigWithPrimary(mirname,id) {
			d $zu(9,"","Mirroring is shutting down, because primary member '"_name_"' thought this system is an async member while this system is a failover member.",1 /* broadcast and log message*/,2  /* Severe error */)
			do post(mirname,+mgrpid,id,"SHUTDOWN:EXIT")
			l -^SYS("MIRRORSET",mirname,"BackupClient")
			quit
		}
    } else {
	    do post(mirname,+mgrpid,id,"BACKUPRESET:0:Not failover member")
	    l -^SYS("MIRRORSET",mirname,"BackupClient")
	    quit
    }
	;
	; Up above we do not post failure messages because either
	; the manager isn't running (who reads messages) or we
	; can't get the lock for the BackupClient (another one
	; is running). From now on though until we release the
	; BackupClient lock, we call post() if we exit.
	;
	s ^SYS("MIRRORSET",mirname,"BackupClient")=+$J
	;
	; Find the end of the last journal file we have (if we have one) and
	; send that to the primary and it will figure out what it should
	; send us next.
	;
	s lastjrncnt=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
	if +lastjrncnt=-1 {
	   d $zu(9,"","GetLastJournalFilename failed - Aborting",1 /* broadcast and log message*/,2  /* Severe error */)
	   quit
	} else {
	  if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","Backup starting with last journal file "_lastjrncnt)
	}
	s lastjrnfile=$P(lastjrncnt,",",2)  ;might be null if lastjrncnt=0
	s lastjrncnt=+lastjrncnt
	if 'lastjrncnt {
	   s lastjrnpos=0
	} else {
       s lastjrnpos=$$getMirJrnEnd^MIRRORMGR(lastjrnfile)
       if lastjrnpos=-1 {
	       ; this happens when the file doesn't exist but this file should
	       ; exist. In any case, start at 0 and we'll get the whole file.
	       d $zu(9,"","("_mirname_") Failed to find end of "_lastjrnfile_" for Mirror.Client()",1 /* broadcast and log message*/,2  /* Severe error */)
	       s lastjrnpos=0
       } elseif 'lastjrnpos {
	       ; The journal file doesn't have a valid end which means this is
	       ; the current journal file on the node we're connecting to or we had a problem
	       ; validating the file . Find the end we have and the server will 
	       ; send us the rest.
	       try {
		       s lastjrnpos=$SYSTEM.Mirror.UpdateJournalFileEnd(lastjrnfile)
		   } CATCH exceptionvar {
			   s fd=$zu(78,5,lastjrnfile,0)
			   if fd'<0 {
				   do $zu(78,6,fd)
				   s lastjrnpos=+$zu(78,18,0)
				   do $zu(78,7,fd)
				   ; if the end came back zero then set it to the 1st bit of data in
				   ; the journal (if there was any) as the file exists so we don't want
				   ; to pass 0 in to Mirror.Client for the starting position.
				   if 'lastjrnpos s lastjrnpos=65536*2
			   }
           }
       } else {
	       ; this shouldn't happen because we checked in BecomeBackup before jobbing
	       ; this off. If we find this file is compressed, log a message and stop.
		   s rc=$ZU(78,22,lastjrnfile,24)
		   if +rc,+$P(rc,",",2) {
			   d $zu(9,"","BACKUP found last file ("_lastjrnfile_") is compressed - data channel not started",1 /* broadcast and log message*/,2  /* Severe error */)
	  	  	   c:$L(io) io
			   do post(mirname,+mgrpid,id,"BACKUPFILEISCOMPRESSED:0:"_lastjrnfile)
			   l -^SYS("MIRRORSET",mirname,"BackupClient")
			   quit  ;failed
		   }
       }
	}
	s shrid=+$SYSTEM.Mirror.DejournalGetSharid(miridx)
	s posset=0  ; position has not set yet.
	if shrid>=0 {
	 	s info=$zu(78,53,shrid,64)
	 	s chkpntpos = +$p(info,",",2)
	 	s chkpntfilecnt = +$p(info,",",3)
	 	if +info,chkpntfilecnt {
		 	s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(chkpntfilecnt,mirname)
		 	if +rc>0 {
			 	s chkpntfile=$P(rc,",",2)
			 	s posset = 1  ; Position set.
			 	if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","("_mirname_") StartDejournal with position ("""_$G(chkpntfile)_""","_$G(chkpntfilecnt)_","_$G(chkpntpos)_" in jrnshare structure")
		 	}
	 	}
	}
	G:posset posset
	;
	; dejrnchkpnt is where we restored the databases to at startup.
	;   it has the format: jrnpos,mirfilecnt,jrnfilename
	s chkpnt=$G(^MIRROR(mirname,"dejrnchkpnt"))  ;jrncnt^pos
	if +chkpnt {
	   s chkpntfilecnt=+chkpnt
	   s chkpntpos=+$P(chkpnt,"^",2)
	   if chkpntfilecnt=lastjrncnt {
		   s chkpntfile=lastjrnfile
	   } else {
	      s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(chkpntfilecnt,mirname)
	      if +rc<=0 {
		     d $zu(9,"",entry_": failed to lookup file name for file #"_chkpntfilecnt,1 /* broadcast and log message*/,2  /* Severe error */)
			 c:$L(io) io
	         do post(mirname,+mgrpid,id,"BACKUPRESET:0:DEJRNSTARTFAILED")
	         l -^SYS("MIRRORSET",mirname,"BackupClient")
		     quit  ;failed
	      }
		  s chkpntfile=$P(rc,",",2)
	   }
	} else {
	   ;If "dejrnchkpnt" isn't set then we must not have any mirrored
	   ; db's on this system so start with the next journal file after
	   ; the one we have..
 	   if lastjrncnt=0 {
	 	  s chkpntfilecnt=0
	 	  s chkpntpos=0
	 	  s chkpntfile=""
 	   } else {
		  s chkpntfile=lastjrnfile
	      s chkpntfilecnt=+lastjrncnt
	      s chkpntpos=lastjrnpos
	      if chkpntpos<0 s chkpntpos=0  ;< 0 file doesn't exist
 	   }
	}
posset ;
	; Build a connection to the primary. We only have 30 seconds from
	; when we build the connection until we get to $SYSTEM.Mirror.Client()
	; so we want to do this when we're mostly done, rather than up higher.
    if (io="") {
	   s options=0
	   s status=$$EstablishConnection(mirname,mgrpid,id,"d",.io,.options)
	   if (status '= 1) {
	      d $zu(9,"",entry_": Failed to connect to primary mirror server",1 /* broadcast and log message*/,1  /* Warning */)
		  s ^SYS("MIRRORSET",mirname,"BackupClient")=""
	      do post(mirname,+mgrpid,id,"BACKUPCONNECTFAILED:0:CONNINITFAILED")
	      l -^SYS("MIRRORSET",mirname,"BackupClient")
	      quit
	   }
    }
    ;
    ; The server side will start $System.Mirror.Server() to handle this
    ; connection and we pass control to $SYSTEM.Mirror.Client()
	;
    s ripaddr=$SYSTEM.TCPDevice.PeerAddrPort()
    d $zu(61,12,$zu(61),$lg(^SYS("MIRRORSET",mirname,"Member",id)))
    d $zu(61,15,$zu(61),$lg(ripaddr,1)_"|"_$lg(ripaddr,2))
	if $System.Mirror.IsAsyncMember() &&
		(+$G(^MIRROR(mirname,"DejournalBlock"))=1) {
			d $zu(9,"","Dejournaling set not to start for mirror: "_mirname,1 /* broadcast and log message*/,1  /* Warning */)
	} else {  ;JO2553-		
		;
		; Start the dejournal jobs. These will dejournal the new
		; journal data we recieve from the primary. Periodially
		; the will report their progress in 
		;          ^MIRROR(<mirrorname>,"dejrncheckpnt")
		if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","StartDejournal("""_mirname_""","""_$G(chkpntfile)_""","_$G(chkpntfilecnt)_","_$G(chkpntpos))
		if '$$StartDejournal(entry,mirname,$g(chkpntfile),$G(chkpntfilecnt),+$g(chkpntpos),miridx) {
			d $zu(9,"",entry_": Failed to start dejournaling jobs on mirror client",1 /* broadcast and log message*/,2  /* Severe error */)
			c:$L(io) io 
			; InitDejournal is after tag reinit which is invoked by BackupReset
			do post(mirname,+mgrpid,id,"BACKUPRESET:0:DEJRNSTARTFAILED")
			l -^SYS("MIRRORSET",mirname,"BackupClient")
			quit
		}
		s dejournalrunning=1  ;JO2359
	}  ;JO2553
	; Now start the mirror client to recieve journal data from the
	; primary. 
	if lastjrnfile'="" {
		s shortfname=$p(lastjrnfile,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""),*)
	} else {
		s shortfilename=""
	}
	;
	; We need to build another connection to the primary to use
	; for sending ACKs. The primary splits the TCP I/O into a send side and
	; a receive side. We make an outgoing connection to "M"_$C(1)_"A" and
	; the primary receives that for handling ACKs. Both connections get
	; passed into Mirror_Client().
	;
	s x=$$BuildAckChannel(mirname,id,mgrpid)
	if '+x {
       d $zu(9,"",entry_"("_mirname_") : Failed to start ACK connection to primary",1 /* broadcast and log message*/,2  /* Severe error */)
	   c:$L(io) io 
	   ; this shouldn't really fail, not 100% sure where we should retry here
	   s sharid=$SYSTEM.Mirror.DejournalGetSharid(miridx)
	   if sharid'=-1 {
		  do $ZU(78,53,sharid,16,1) ;stop dejournal reader job
		  d $zu(9,"",entry_" stopped dejournal reader for #"_sharid_" after failing to build ack channel",0,0  /* Informational message */)
		  s dejournalrunning=0
	   } else {
		  d $zu(9,"",entry_": Failed to build ack channel, failed to locate dejournal reader for index #"_miridx_" to stop it",1 /* broadcast and log message*/,1  /* Warning */)
	   }
	   do post(mirname,+mgrpid,id,"BACKUPRESTART:0:ACKCHANNELFAILED")
	   l -^SYS("MIRRORSET",mirname,"BackupClient")
	   quit
	} 
	s AckIO=$P(x,"^",2)		
	;
	d $zu(9,"","("_mirname_") Starting Mirror.Client("""_$G(shortfname)_""","_$G(lastjrnpos)_","_$G(lastjrncnt)_")",0,0  /* Informational message */)
	s ^MIRROR(mirname,"Status","Member",id,"LastConnect")=$ZTIMESTAMP
	s IncomingMember=$lg($G(^SYS("MIRRORSET",mirname,"Member",id),$LB("Unknown")))
	s ^MIRROR(mirname,"lastconnected",IncomingMember)="BACKUP"_"^"_$ZTIMESTAMP
	k ^MIRROR(mirname,"PromotedNotQueried"),^MIRROR(mirname,"PromotedQueried")
	if $SYSTEM.Mirror.IsMember()=1||($SYSTEM.Mirror.AsyncMemberType()=0) {
	    do post(mirname,+mgrpid,id,"PURGEJOURNAL:")
	}
    s rc=$SYSTEM.Mirror.Client(io,AckIO,$g(lastjrnfile),+$g(lastjrnpos),+$g(lastjrncnt))
    ; Mirror.Client() waits for the dejournaling jobs to finish processing
    ; the data we have before it returns.
    do post(mirname,+mgrpid,id,"MIRDOWN:"_rc_":CLIENTEXIT")
    s posted=1
	s ^MIRROR(mirname,"Status","Member",id,"Disconnect")=$ZTIMESTAMP
	s ^MIRROR(mirname,"lastdisconnected",IncomingMember)="BACKUP"_"^"_$ZTIMESTAMP
    l -^SYS("MIRRORSET",mirname,"BackupClient")
    c:$L(io) io
    quit
err ;
	s $Zt=""
	s status=$SYSTEM.Mirror.GetStatus(mirname)
	if $ZE'["<DSCON>" {
	   d $zu(9,"",entry_": Unexpected error in Backup mirror job: "_$ZE_"  ("_status_")",1 /* broadcast and log message*/,2  /* Severe error */)
	} else {
	   if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"",entry_": Mirror client connection terminated with <DSCON> error ("_$ZE_")")
	}
	c:$L(io) io
	i $d(IncomingMember) s ^MIRROR(mirname,"lastdisconnected",IncomingMember)="BACKUP"_"^"_$ZTIMESTAMP
	; We're assuming the error came from $SYSTEM.Mirror.Client(),
	; maybe we should have a flag that indicates whether we should
	; post a MIRDOWN or a BACKUPRESET depending on where the error
	; comes from.
	if dejournalrunning {
		s dejournalrunning=0
		s $zt="err"  ;in case we hit an error here
		s sharid=$SYSTEM.Mirror.DejournalGetSharid(miridx)
		if sharid'=-1 {
			do $ZU(78,53,sharid,16,1) ;stop dejournal reader job
			d $zu(9,"",entry_": Stopped dejournal reader for #"_sharid,0,0  /* Informational message */)
		} else {
			d $zu(9,"",entry_": Failed to locate dejournal reader for index #"_miridx,1 /* broadcast and log message*/,1  /* Warning */)
		}
	}
    i 'posted do post(mirname,+mgrpid,id,"MIRDOWN:-1:CLIERROR")
	l -^SYS("MIRRORSET",mirname,"BackupClient")
	d:logerr BACK^%ETN
	quit
}
BuildAckChannel(mirname,id,mgrpid) {
	; Called from Backup() so build a 2nd TCP connection to
	; the primary we can use to send ACKs on.
	;
	; Returns: 0 = failure
	;          1^<tcp device> = success
	; get our mirror name to start with
	s io=""  ;connection doesn't exist yet
	s options=0
	s retry=0
	s status=$$EstablishConnection(mirname,mgrpid,id,"a",.io,.options)  ;a is the ack channel
	if (status'=1) {
	   if (status = -1) {
		   s retry=0
		   while (status = -1) && (retry < 5) {
		      h 3
	          s status=$$EstablishConnection(mirname,mgrpid,id,"a",.io,.options)  ;a is the ack channel
		      s retry=retry+1
		   }
	   }
	   if (status '= 1) {
	      d $zu(9,"","("_mirname_") BuildAckChannel: Failed to connect to node #"_id_" (rc="_status_")",1 /* broadcast and log message*/,1  /* Warning */)
	      quit 0
       }
	}
    s info=$G(^SYS("MIRRORSET",mirname,"Member",0))
    if info="" {
	   d $zu(9,"","("_mirname_") BuildAckChannel: Failed to locate mirror information about ourself",1 /* broadcast and log message*/,1  /* Warning */)
	   quit 0
    }
    s ourname=$lg(info,1)
	; ok, now the other side waits for us to send our mirror name and GUID
	; with a 2 byte encoded length. 
	s msg=$LB(mirname,ourname,$LG(info,2))
	w $zwchar($L(msg)),msg w *-3
	; now the other side (SvrReadDmn) waits for us to send it
	; a message from mirror_tcp_write() (eg. preceeded by a 4
	; byte length). This is so SvrReadDmn waits until Mirror_Client()
	; has heard from Mirror_Server() at which point we know Mirror_Server()
	; has built up the structures for the connection.
	quit "1^"_io
}
StartDejournal(entry,mirname,jrnfname,mirfilecnt,jrnpos,miridx) PUBLIC {
	/* Called to start the journal reader before calling
	   SYSTEM.Mirror.Client(). jrnname/jrnpos is the current end
	   of the mirror journal. We pass this when we start the dejournaling
	   job as this is where it should pick up from (generally it will
	   start with a new file but the primary may send us more of this
	   file if we shut down while it was being created).
	   Its possible that jrnfname is null and jrnpos is zero. In
	   that case we've restored all of the journal files we have
	   and mirfilecnt is the next file we expect the primary to
	   send us. 	
	*/
	s ^MIRROR(mirname,"DejournalReader","status")=""  ;clear any old status
	job DejrnReader^MIRRORMGR(miridx,jrnfname,mirfilecnt,jrnpos):(:2):2
    if '$T {
        d $zu(9,"",entry_" failed job dejournaling worker job",1 /* broadcast and log message*/,1  /* Warning */)
        quit 0 ;failed
	   }
	quit 1  ;succeeded
}
EstablishConnection(mirname,mgrpid,id,type,io,options,TimeOut=5,sslauth=1) PUBLIC {
	/* Make an outgoing connection to the target mirror member. The 
	   message protocol must match what is expected in the ^Server routine.
	   We open a TCP pipe to the remote superserver and "M"_$C(1)_"D" for data 
	   channel, M<1>A for the Ack channel or M<1>S to for a mirror server function
	   on a async member. The superserver passes control to the Server entry point. 
	   "M"_$C(1)_"V" is used for SSL certificate validation and for cloned system
	   dectection. "V" is similar to "S" except that failover members cannot use "S"
	   but can use "V" and "V" is not blocked by mblkuser in the superserver.
	   [JO2817] M<1>S and M<1>V messages end up getting handled by AsyncServerDmn
	   in ^MIRRORCOMM which handles server guid validation. The server guid should
	   be passed in the action message ($LG(<action>,<arguments>,<server guid>).
	   M<1>D and M<1>A messages have their own validation that the client has 
	   reached the correct server (eg. we must be the primary and the client must 
	   be registerd in the mirror config and connecting to our mirror).
	   This is a subroutine of Backup(), BuildAckChannel() and AsyncServerRequest().
	   Backup() is jobbed off by Start() when this mirror member is supposed to 
	   become a backup mirror member. BuildAckChannel is jobbed off from Backup to
	   build a 2nd channel for sending ACKs back to the primary. Both of the outgoing
	   connections are to the superserver on another mirror member and the 
	   superserver ends up calling Server() to handle it. As a consequence if our
	   superserver is configured to require SSL then we assume the other end is
	   as well and we enable SSL for the initial outgoing connections. If SSL is
	   not required by the superserver we make a "clear" connection to the other
	   node but we may still enable SSL for the channel if the mirror is configured
	   to use SSL.
	   AsyncServerRequest() is called by a downstream node of a async member to get
	   something from the async member in the same manner than nodes use the agent to
	   retrieve data or information from a failover member. The async members don't have
	   agents running (they might but we don't require it) so we use the superserver 
	   to provide this capability. HandleAsyncServerRequest() is started by Server() in
	   response to a M<1>S message.
	   Arguments:
	   	 mirname indicates the mirror index of the mirror member to be connected to.
	     id is the index into ^SYS("MIRRORSET",mirname,"Member",<id>) who we're contacting.
	     when id is ip|port it means the ^SYS("MIRRORSET",mirname,"Member") does not exist
	     so it would use the id as the address to connect to remote node.
	     type is 'a' or 'd' for the connection type (ack, or data). For 'd' we send
	     "M"_$C(1)_"D", for 'a' we send "M"_$C(1)_"A" and for 'S' we send "M"_$C(1)_"S" 
	     to the other side. 
	     io is passed by reference and is loaded with the TCP device if when we
	        successfully connect. NULL if no connection exists.
	     options may be omitted or may be passed by reference to receive the
	        options negotiated in $$SetVerifyID(). These are features the client/server
	        may want to use. Currently $$$MIRRORUSEZIP is the only negotiated option and
	        the client tells the server it wants to use this and the server lets
	        the client know whether it supports it although the client really doesn't care.
	        The server will use compression if the client supports it and the server will
	        tell the client which packets are compressed or not.
	   Returns:
	     1 - connection is up and good, io is the TCP device. options which was
	     	 passed by reference is set with the client/server negotiated options
	     	 from SendVerifyID()
	     0 - connection failed, don't bother retrying (it was rejected by the other
	            end for some reason)
	    -1 - connection failed but its worth retrying as either we failed to open the
	            outgoing port or there was some 'strange' failure which might be resolve
	            if we try again.
	    -2 - connection failed when reporting node tried to connect mirror set member.
	         The caller need to try to connect to another member.
	    -3 - Reporting node connected to a backup node. The caller needs to
	         connect to the primary node whose index is setup from the info back
	         from the backup node.
	   The message protocol which must match the code in Server() is:
	     a) If the superserver is configured to require SSL then specify 
	        /SSL=%MirrorClient on the open of the outgoing connection
	   	 b) send M_$C(1)_D, M_$C(1)_A, M_$C(1)_S to the superserver on the other end 
	   	    and it will pass the connection to Server^MIRRORMGR	
	     c) remote side sends a M_$C(1)_D, M_$C(1)_A or M_$C(1)_S back to indicate we've 
	    	reached the right place
	     d) For control channel, we exchange the version information and come up
	        with a common version both side supported.
	     e) send the mirror guid, our mirror system name and our system guid for validation.
	        we also receive the mirror guid, remote mirror system name and remote system guid
	        for validatiomn.
	     f) For control channel, we exchange features and all other mirror information.
	   The connection is now up and depending on whether it is a 'c' or 'd' the code
	       passes control to the correct message handler. For 'c' connections it 
	       is MsgHndlr() while for 'd' connections it is $SYSTEM.Mirror.Server or
	       $SYSTEM.Mirror.Client.
	*/		
	s $zt="err"
	s rptnode=+$G(^SYS("MIRRORSET"))
	s imsg=$case(type,"a":"M"_$C(1)_"A","d":"M"_$C(1)_"D","s":"M"_$C(1)_"S","v":"M"_$C(1)_"V",:"")
	q:imsg="" 0  ;invalid type
	s logerr=1  ; record errors in ^%ET
	; Load info about our system
	s entry="EstablishConnection^"_$ZN_"("""_mirname_""","_id_","""_type_""")"
	s mirguid=$G(^SYS("MIRRORSET",mirname,"GUID"))
    s systemid=$G(^SYS("MIRRORSET",mirname,"Member",0))
    s io=""
    ;
    ; Get info about system we're supposed to contact
    ;
    s noid=id'?.N
    if noid {
	    s usedip=$p(id,"|",1,2)
	    s nextip=$p(id,",",2)
	    s:nextip="" nextip=usedip
	    s mtype=$s(type="v":+$p(id,"|",3),1:2)
    } else {
	    s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
	    if info="" {
		    d $zu(9,"",entry_"("_mirname_") : Failed to locate information about mirror member id #"_id,1 /* broadcast and log message*/,1  /* Warning */)
		    d:type="d" SecureSetMirrorStatus($LB("NOK","Missing info"))
		    quit 0 ; don't retry
	    }
	    s name=$lg(info,1)
	    s guid=$lg(info,2)
	    s ecpip=$lg(info,3)
	    s mirip=$lg(info,4)
	    if type="s"||(type="v") {
		    s lastusedadr=+$G(^MIRROR(mirname,"lastworkingaddr",id),0) ;0=ecpip, 1=mirip
		    if lastusedadr=0 {
		       s usedip=ecpip
		       s nextip=mirip
		    } else {
		       s usedip=mirip
		       s nextip=ecpip
		    }
	    } else {
		    s usedip=mirip
		    if rptnode {
		    	s nextip=ecpip
		    } else {
			    s nextip=mirip
		    }
	    }
	    s mtype=$LG(info,8)
    }
    ;
    ; mirip is the address other mirror members contact this system on. ecpip is
    ; the address it wants ECP Mirror clients to contact it on. These may be on
    ; different networks for performance, security, etc.
    ;
	s port=$P(usedip,"|",2)
	s ip=$P(usedip,"|")
	; The Data Channel uses device 1 and the ACK channel uses device 2 
	; The ACK and Data channels are in the same process so they need different ports,
	; otherwise it it doesn't matter what we use.
	if (type="d") || (type="s") || (type="v") {
	   s io="|TCP|1"  
	} elseif type="a" {
	   s io="|TCP|2"  
	}
	if (type="s") && (mtype=0) {
		d $zu(9,"",entry_": Aborted async server connection to non async member "_name_" (type = "_mtype_") - Exiting",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0 ; don't retry
	}
	s tryecpip=0
    d:type="d" SecureSetMirrorStatus($LB("OK","Connecting"))
retry ;
	s rcvbuf=##class(SYS.Mirror).TCPReceiveBufferSize(mirname)
	o io:(/Hostname=ip:/Port=port:/STREAM=1:/TCPRCVBUF=rcvbuf:/IOTABLE="RAW"):TimeOut
	s ok=$T
	if 'ok {
		if tryecpip=0 && (usedip'=nextip) {
			s tryecpip=1
			s port=$P(nextip,"|",2)
			s ip=$P(nextip,"|")
			goto retry
		}
		s io="" quit $s(rptnode:-2,1:-1)  ; ok to retry, don't log a message, caller can periodically log
	                        ; messages if they want
	}
	if tryecpip && ((type="s") || (type ="v")) && 'noid {
		do  
		. i '($e($roles,1,$l("%All"))="%All") { n $ET,$roles s $ET="",$roles=$roles_","_"%All"}
		. s ^MIRROR(mirname,"lastworkingaddr",id)='lastusedadr
		if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","EstablishConnection set search order to "_$S(lastusedadr:"MirPrivate->ECP",1:"ECP->MirPrivate"))
	}
	;
	if type'="s",type'="v",$G(^MIRROR(mirname,"MgrJobID"))'=mgrpid {
		d $zu(9,"",entry_": MGR shut down, outgoing tcp connection job for member #"_id_" exiting",1 /* broadcast and log message*/,1  /* Warning */)
		if ok c io 
		s io=""
   	    d:type="d" SecureSetMirrorStatus($LB("NOK","MGR job "_mgrpid_" exited."))
		quit 0  ; don't retry
	}
	u io
	;M<1><x> is a mirror connection to another mirror member (<x> is A/D)
	w imsg w *-3  
	; The other side should answer with the same string
	read resp#3:30  ; give it a decent amount of time to get started
	if '$T {
		d $zu(9,"",entry_": Host at "_ip_":"_port_" failed to respond with initial ACK",1 /* broadcast and log message*/,1  /* Warning */)
    	d:type="d" SecureSetMirrorStatus($LB("NOK","Failed to receive initial ACK"))
	    c io s io=""
	    quit -1  ; ok to retry
	}
	if resp'=imsg {
		if resp=("0"_$C(0)) {
		   d $zu(9,"",entry_": Host at "_ip_":"_port_" refused connection. Check whether service is enabled",1 /* broadcast and log message*/,1  /* Warning */)
		} else {
		   d $zu(9,"",entry_": Host at "_ip_":"_port_" sent incorrect initial response /"_resp_"/",1 /* broadcast and log message*/,1  /* Warning */)
		}
    	d:type="d" SecureSetMirrorStatus($LB("NOK","Validation failed, initial ACK = "_resp))
	    c io s io=""
		quit 0 ; don't bother retrying
	}
	if type="s"||(mtype=2)||(type="v"&&(mtype'=0)) {
		w $zwchar($L(mirname)),mirname w *-3
	}
	if type="v" {
		w $zwchar($L(sslauth)),sslauth w *-3
	}
	s resp=$$SSLClient^MIRRORCTL(mirname,io,ip,port,sslauth)
	if +resp {
	    d $zu(9,"",entry_": Host at "_ip_":"_port_" failed to setup SSL Client, "_$p(resp,",",2,*),1 /* broadcast and log message*/,1  /* Warning */)
    	d:type="d" SecureSetMirrorStatus($LB("NOK","Failed to setup SSL"))
	    c io s io=""
	    quit 0
	}
	if (type="a") || (type="s") || (type="v"){
		; If this is the 2ndary ACK channel or a async server connection, we're done
		quit 1  ;success
	}
	s versionrc=$$SendVerifyVersion()
	s version = $LG(versionrc)
	i 'version {
	   d $zu(9,"",entry_": Host at "_ip_":"_port_" Failed to verify version - "_$s($p(version,"^",2)="":$LG(versionrc,2),1:$p(version,"^",2)),1 /* broadcast and log message*/,1  /* Warning */)
	   d SecureSetMirrorStatus($LB("NOK","Failed to get version"))
	   c io s io=""
	   quit 0
	}
	d
    . i '($e($roles,1,$l("%All"))="%All") { n $ET,$roles s $ET="",$roles=$roles_","_"%All"}
    . s ^MIRROR(mirname,"Status","Member",id,"Version")=version
	. if $LG(versionrc,2)'="" s ^MIRROR(mirname,"Features",id)=$LG(versionrc,2)
	; 
	; Send our identification information
	;
	; The other mirror member accepted our connection. Send the info which
	; identifies the mirror we're part of and our system id. The
	; other system may still reject us if its not a member of the same
	; mirror.
	s reqoptions=4
	s resp=$$SendVerifyID(mirname,id,entry,type="d",reqoptions)
	s options=+$P(resp,"^",2)  ;passed by reference from caller
	s resp=+resp
	if resp'=1 {
		c io s io=""
		q resp
	}
	if 'rptnode||(version>4&&##class(Config.MirrorMember).IsDRMember()) {
		s resp=$$SendVerifyEncKey()
		if 'resp {
			d $zu(9,"","Failed to match encryption keys - "_$p(resp,"^",2),1 /* broadcast and log message*/,2  /* Severe error */)
			c io s io=""
			q 0
		}
		if $p(resp,"^",2)'="" {
			d $zu(9,"","SendVerifyEncKey: "_$p(resp,"^",2),1 /* broadcast and log message*/,1  /* Warning */)
		}
	}
	if version>1 {
	   s resp=$$SendVerifyDBList(mirname,rptnode,version>5)
	   if 'resp {
		  c io s io=""
		  q resp
	   }
	}
	if 'rptnode {
		s resp=$$SendVerifyColList()
		if 'resp {
			d $zu(9,"","Failed to match collations - "_$p(resp,"^",2),1 /* broadcast and log message*/,1  /* Warning */)
			c io s io=""
			q 0
		}
	}
	if version>2 {
	   s resp=$$SendVerifyTime(mirname)
	   if 'resp {
		  c io s io=""
		  q resp
	   }
	}
	read resp#1:5
	if resp'=1 {
		c io s io=""
		q resp
	}
	quit 1 ; success, we're done.
err ;
	s $zt=""
	; The only errors we should get are unexpected write errors
	; if the connection fails for some reason.
	if $ZE["<WRITE>" {
	   d $zu(9,"",entry_": Connection failed",1 /* broadcast and log message*/,1  /* Warning */)
	   try {
	   	   d:type="d" SecureSetMirrorStatus($LB("NOK","Connection failed"))
	   } catch {}
	   c io s io=""
	   quit -1  ; ok to retry
	}
	if $ZE["<READ>" {
		if $zb(+$SYSTEM.Mirror.DebugFlags(),4,1) do $zu(9,"",entry_": Other end closed channel")
	   try {
   	      d:type="d" SecureSetMirrorStatus($LB("NOK","Connection failed"))
	   } catch {}
	   c io s io=""
	   quit 0 ; don't retry, the other end is dealing with it.		 
	}
	d $zu(9,"",entry_": Unexpected error :"_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	try {
   	   d:type="d" SecureSetMirrorStatus($LB("NOK","Unexpected error: "_$ZE))
	} catch {}
	c io s io=""
	d:logerr BACK^%ETN
	quit 0  ; don't retry
SecureSetMirrorStatus(status)
	i '($e($roles,1,$l("%All"))="%All") { n $ET,$roles s $ET="",$roles=$roles_","_"%All"}
	s ^MIRROR(mirname,"Status","Member",id)=$G(status)
	q	
}
Server(io,hdr,type) PUBLIC {
	/* Server is jobbed off from ^%SYS.SERVER when a message
	   is received with the header "M"_$C(1)_"D", "M"_$C(1)_"A" or "M"_$C(1)_"S". 
	   This system must be the primary. If its a backup then its probably
	   (only?) a reporting node which is trying to connect and we send back
	   the node # of the primary.
	   The message protocol is:
	   	a) send the header (M_$C(1)_D/M_$C(1)_A/M_$C(1)_"S"/M_$C(1)_"V") 
	   	   back to the other side so it knows we understood its message
	   	b) For data channel read the version and character size information 
	   	   and validate it then send back the supported version value.
	   	c) For the ACK channel read the mirror set name of the backup
	   	   and pass it off to SvrReadDmn^MIRRORMGR. We must be the
	   	   primary and this is the Backup establishing the 2nd 
	   	   channel -> the primary where it sends acks.
	  	d) Exchange the mirror guid and the mirror system name+guid with the 
	  	   other side and validate the value to find an 'id' for remote. If remote 
	  	   is a reporting node then we need to add it to the member list in
	  	   ^SYS("MIRRORSET",mirname,"Member",id) if it could not find it.
	  	   The ^SYS("MIRRORSET",mirname,"ReportMemberCount") will keep track of how
	  	   many reporting nodes in the member list.
	    e) For data channel, exchange the features and mirror information. 
	   	f) For data channel, if the system does not have a mirror role of Backup 
	   	   or Primary, send back reject answer. Otherwise the connection is passed
	       on to either $SYSTEM.Mirror.Client or $SYSTEM.Mirror.Server.
	*/
	s entry="Server^"_$ZN_"("_type_")"
	s mirname=$P(^SYS("MIRRORSET"),"^",2)
	s id=""
	s $zt="err"
    if '$SYSTEM.Security.Check("%Admin_Manage","USE") {
	   d $zu(9,"","Insufficient privilege to run "_entry,1 /* broadcast and log message*/,2  /* Severe error */)
	   quit
    }
	s imsg=$s(type="d":"M"_$C(1)_"D",type="s":"M"_$C(1)_"S",type="v":"M"_$C(1)_"V",1:"M"_$C(1)_"A")
	s isAsync=+$G(^SYS("MIRRORSET"))  ;True/False
	if type="s"&&('isAsync) {
		d $zu(9,"",entry_" received superserver channel request type '"_type_"' in failover member. Failover member can only receive agent channel request type.",1 /* broadcast and log message*/,1  /* Warning */)
		use io:(::/IOTABLE="RAW")
		w 0 w *-3 c io  ; terminate client connection
		quit
	}
	s logerr=1  ; record errors in ^%ET
	if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","Mirror "_$S(isAsync:"async",1:"server")_" type ("_type_") started for "_mirname)
	s origtype=$ZU(61,10,$ZU(61),53)
	;
	use io:(::/IOTABLE="RAW")
	w imsg w *-3  ; send back M_$C(1)_<x> so the other side knows it reached the right place
	if isAsync {
		s resp=$$readdata()
		if '$lg(resp) {
			; $list(0,<err text>)
			s resp=$lg(resp,2)
			d $zu(9,"",entry_": failed to read mirror set name : "_resp,1 /* broadcast and log message*/,1  /* Warning */)
			goto exit
		}
		s mirname=$LG(resp,2)
		if type="v"&&(mirname=0||(mirname=1)) {
			s sslauth=mirname
			s mirname=$P($P(^SYS("MIRRORSET"),"^",2),",")
		}
checkmirror
		if ","_$P(^SYS("MIRRORSET"),"^",2)_","'[(","_mirname_",") {
			d $zu(9,"",entry_": mirror set name '"_mirname_"' does not exist",1 /* broadcast and log message*/,1  /* Warning */)
			goto exit
		}
		if type'="s",type'="v",($LG($G(^SYS("MIRRORSET",mirname,"Member",0)),8)=2) {
			d $zu(9,"",entry_" received agent channel request type '"_type_"' through superserver channel in async member.",1 /* broadcast and log message*/,1  /* Warning */)
			goto exit
		}
		if $SYSTEM.Mirror.MirrorNameToIndex(mirname,1)<0 {
			d $zu(9,"",entry_" failed to find mirror set "_mirname_" in mirror table.",1 /* broadcast and log message*/,1  /* Warning */)
			goto exit
		}
	}
	; Make sure the manager is running and get its pid. We don't simply
	; take the pid of the process which jobs us. If type is 's' we don't
	; care about the MIRRORMGR job.
	if type="v" {
		if '$d(sslauth) {
			s resp=$$readdata()
			if '$lg(resp) {
				; $list(0,<err text>)
				s resp=$lg(resp,2)
				d $zu(9,"",entry_": failed to read sslauth value for type 'v' : "_resp,1 /* broadcast and log message*/,1  /* Warning */)
				goto exit
			}
			s sslauth=$LG(resp,2)
			if sslauth'=0&&(sslauth'=1) {
				s mirname=sslauth
				k sslauth
				goto checkmirror
			}
		}
	} else {
		s sslauth=1
	}
	if (type '= "s"),(type '= "v") {
		if '##class(SYS.Mirror).IsMirrorStarted(mirname) {
			d $zu(9,"",entry_" manager process not running",1 /* broadcast and log message*/,1  /* Warning */)
			goto exit
		}
		s mgrpid=$G(^MIRROR(mirname,"MgrJobID"))
		; We can start up while the manager is still initializing. If its
		; not in the run state then give it 30 seconds before we exit
		for i=1:1:30 {
			q:$G(^MIRROR(mirname,"Status","MGR"))="Run"
			h 1
		}
		if $G(^MIRROR(mirname,"Status","MGR"))'="Run" {
			d $zu(9,"",entry_": Manager job ("_mgrpid_") is not in Run state. Current status = "_$G(^MIRROR(mirname,"Status","MGR")),1 /* broadcast and log message*/,1  /* Warning */)
			goto exit
		}
	}
	; Load info about our system
	s mirguid=$G(^SYS("MIRRORSET",mirname,"GUID"))
    s systemid=$G(^SYS("MIRRORSET",mirname,"Member",0))
	;
	if (1) {
		s sslon=+$G(^SYS("MIRRORSET",mirname,"UseSSL"),0)
		if 'sslon {
		   ; Note that we're looking at the last value loaded here but that's
		   ; ok in this case. It would be a lot of overhead on every connection
		   ; to open the Config class to get the current value.
		   s info=$G(^SYS("MIRRORSET",mirname,"Member",0))
		   s EncryptConnection=$zb(+$LG(info,11),2,1) ; Bit #2 means encrypt incoming connections
		   if EncryptConnection {
			   s sslon=1
		   }
		}
		s sslrc=$$SSLServer^MIRRORCTL(mirname,io,$s(sslauth:sslon,1:0))
		if +sslrc<0||(+sslrc=3&&(type'="s")&&(type'="v")) {
			d $zu(9,"",entry_": failed to setup SSL Server,"_$s((+sslrc<0):$p(sslrc,",",2),1:""""_$p(sslrc,$c(0),2)_""" not authorized"),1 /* broadcast and log message*/,1  /* Warning */)
			goto exit
		}
	}
	if type="a" {
	   s resp=$$readdata()
	   if '$lg(resp) {
		  ; $list(0,<err text>)
		  s resp=$lg(resp,1)
		  d $zu(9,"",entry_": "_resp,1 /* broadcast and log message*/,1  /* Warning */)
		  goto exit
	   }
	   s msg=$LG(resp,2)
	   do SvrReadDmn(io,msg)	
	   goto exit  ;we're done, exit.
	}
	if type="s"||(type="v") {
		if ('isAsync)&&(type="s") {
			d $zu(9,"",entry_": Not a async server - role = /"_role_"/ - Connection rejected",1 /* broadcast and log message*/,1  /* Warning */)
			goto exit
		}
		do AsyncServerDmn^MIRRORCTL(io,sslrc,mirname)
		goto exit  ; we're done, exit
	}
	s versionrc=$$ReadVerifyVersion()
	s version = $LG(versionrc)
	if 'version {
		d $zu(9,"",entry_": Failed to verify version - "_$LG(versionrc,2),1 /* broadcast and log message*/,1  /* Warning */)
		goto exit
	}
	s id=$$ReadVerifyID(mirname,entry,type,.rptnode,.IsDRMember)
	s options=+$P(id,"^",2)
	s id=+id
	if id'>0 {
		; if the other node is a reporting node and we're a backup,
		; we exit here now. We've told the reporting node who the
		; primary is
		goto exit
	}
	s role=$SYSTEM.Mirror.GetInfo()
	if role'["PRIMARY" {
		d $zu(9,"",entry_": Not currently primary server - role = /"_role_"/",1 /* broadcast and log message*/,1  /* Warning */)
		goto exit
	}
	if 'rptnode||(IsDRMember&&(version>4)) {
		s resp=$$ReadVerifyEncKey()
		if 'resp {
			d $zu(9,"",entry_": Failed to match encryption keys - "_$p(resp,"^",2),1 /* broadcast and log message*/,1  /* Warning */)
			goto exit
		}
	}
	if version>1 {  ;this was added with version 2
	   s resp=$$ReadVerifyDBList(mirname,rptnode,version>5)
	   if 'resp {
		  goto exit
	   }
	}
	if 'rptnode {
		s resp=$$ReadVerifyColList()
		if 'resp {
			d $zu(9,"",entry_": Failed to match collations - "_$p(resp,"^",2),1 /* broadcast and log message*/,1  /* Warning */)
			goto exit
		}
	}
	if version>2 {
	   s resp=$$ReadVerifyTime(mirname,id)
	   if 'resp {
		  goto exit
	   }
	}
	if $LG(versionrc,2)'="" s ^MIRROR(mirname,"Features",id)=$LG(versionrc,2)
    s ^MIRROR(mirname,"Status","Member",id,"Version")=version
    s ^MIRROR(mirname,"Status","Member",id)=$LB("OK","Connected")
	;
	w 1 w *-3  ; accept data connection
	s reconfigparam=$SYSTEM.Mirror.ReconfigParams()
	s WriteTO=2*$s(rptnode:$p(reconfigparam,",",2),1:$p(reconfigparam,",",1)\1000)
	if WriteTO<30 s WriteTO=30
	Use io:(/WRITETIMEOUT=WriteTO)
	do Primary(mirname,io,id,options)
exit ;  
	c io  ;we're done
    if (type = "d")&&(id'="") {
	    s ^MIRROR(mirname,"Status","Member",id)=$LB("DOWN","Exited")
		l -^SYS("MIRRORSET",mirname,"Member",id,type)
    }
	if $zb(+$SYSTEM.Mirror.DebugFlags(),8,1) do $zu(9,"",entry_" exiting")
	do $ZU(61,10,$ZU(61),origtype)
	quit
err ;
	s $zt=""
	d $zu(9,"",entry_": Unexpected error: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	d:logerr BACK^%ETN
	goto exit
}
SvrReadDmn(io,name) {
    /* SvrReadDmn() is called by Server^MIRRORMGR when we get a "M"_$C(1)_"A"
       message from a backup node. This becomes the read side of the
       primary mirror server's TCP connection to a backup. The argument, 
       is the name of the backup. We'll look this up to find the
       index into goffmirrorsvr[] inside ServerReadDmn().
       The passed 'io' device is the TCP connection to the backup
       Before calling $SYSTEM.Mirror.ServerReadDmn() we wait here
       for a message from the backup. The backup sends us an "OK"
       after it sends the MIRROR_CONNECT message to the server
       (to Mirror_Server()). This is important because its the mirror
       connect message which causes the server to register the backup's
       name in the shared memory tables. Until this point, ServerReadDmn()
       won't find the backup's name listed.
    */
 	Set $ZT="err"
 	Use io
	read resp#4:30
	if '$T {
		d $zu(9,"","SvrReadDmn: Failed to receive initial message length",1 /* broadcast and log message*/,1  /* Warning */)
		quit
	}
	s len=$zlascii(resp)
	read resp#len:5
	if '$T {
		d $zu(9,"","SvrReadDmn: Failed to receive initial message",1 /* broadcast and log message*/,1  /* Warning */)
		quit
	}
 	s rc=$SYSTEM.Mirror.ServerReadDmn($LG(name,2),$LG(name,3))
 	quit
err ;
	s $zt=""
	d $zu(9,"","SvrReadDmn^MIRRORMGR: Unexpected error: "_$ze,1 /* broadcast and log message*/,1  /* Warning */)
	do BACK^%ETN
	quit 	
}
SendVerifyVersion() {
	s msg=$lb(6,$zbitget($zversion(0),1),1)
	w $zwchar($L(msg)),msg w *-3
	s r=$$readdata()
	i '$lg(r) quit r
	q $lg(r,2)
}
ReadVerifyVersion() {
	s r=$$readdata()
	i '$lg(r) quit r
	s v=$lg($lg(r,2)),unicode=$lg($lg(r,2),2),features=$lg($lg(r,2),3)
	if (''$zbitget($zversion(0),1))'=(''unicode) {
		s msg=$lb(0,"Mismatched UNICODE platform")
		w $zwchar($L(msg)),msg w *-3
		q msg
	}
	if v>6 s v=6
	s msg=$lb(v,1)
	w $zwchar($L(msg)),msg w *-3
	q $lb(v,features)
}
SendVerifyID(mirname,id,entry,log,options) {
    s info=^SYS("MIRRORSET",mirname,"Member",id)
    s name=$lg(info,1)
    s guid=$lg(info,2)
    s mirip=$lg(info,4)
	s mirguid=$G(^SYS("MIRRORSET",mirname,"GUID"))
	;only one option for now, otherwise add them together
	if '$$sendid(mirname,options) {
    	s:log ^MIRROR(mirname,"Status","Member",id)=$LB("NOK","Send id failed")
    	d $zu(9,"",entry_": Failed to send our id information",1 /* broadcast and log message*/,1  /* Warning */)
	    quit -1  ; ok to retry
	}
	; The other system sends back a 1 if our id info is ok or a 0 if it isn't.
	read resp#1:10
	if '$T {
timeout	s port=$P(mirip,"|",2)
		s ip=$P(mirip,"|")
		d $zu(9,"",entry_": Host at "_ip_":"_port_" failed to acknowledge our id",1 /* broadcast and log message*/,1  /* Warning */)
    	s:log ^MIRROR(mirname,"Status","Member",id)=$LB("NOK","Failed to acknolwedge our id")
	    quit -1  ; ok to retry
	}
	if 'resp {
		s port=$P(mirip,"|",2)
		s ip=$P(mirip,"|")
		d $zu(9,"",entry_": Host at "_ip_":"_port_" rejected our id string",1 /* broadcast and log message*/,1  /* Warning */)
    	s:log ^MIRROR(mirname,"Status","Member",id)=$LB("NOK","Rejected our id string")
	    quit 0 ; don't retry, we were rejected
	} ElseIf resp=2 {
		s port=$P(mirip,"|",2)
		s ip=$P(mirip,"|")
		d $zu(9,"",entry_": Host at "_ip_":"_port_" refused connection. lock not granted.",1 /* broadcast and log message*/,1  /* Warning */)
		s:log ^MIRROR(mirname,"Status","Member",id)=$LB("NOK"," Remote Failed to grant control lock.")
		quit -1   ; allow retry.
	} Elseif resp=3 {
		r resp#1:10
		if '$T g timeout
		if '$D(^SYS("MIRRORSET",mirname,"Member",resp)) {
			d $zu(9,"","Got a non-exist primary index "_resp,1 /* broadcast and log message*/,1  /* Warning */)
			quit -4  ; tell caller to get mirror set info from agent job again.
		}
		quit -3  ; tell caller to connect to the primary.
	}
	; Read the other system's id and make sure this matches
	; the system we were trying to reach.
	s resp=$$readdata()
	if '$lg(resp) {
		; $list(0,<err text>)
		s resp=$lg(resp,2)   ;JO3008
		d $zu(9,"",entry_": "_resp,1 /* broadcast and log message*/,1  /* Warning */)
    	s:log ^MIRROR(mirname,"Status","Member",id)=$LB("NOK",resp)
		quit -1  ; ok to retry
	}
	s resp=$lg(resp,2)
	; resp is now $LB(mirrorguid,remote system mirror name,remote system guid)
	s remmirguid=$lg(resp,1)
	s remname=$lg(resp,2)
	s remguid=$lg(resp,3)
	s remopts=+$lg(resp,7)
	if remmirguid'=mirguid {
		d $zu(9,"",entry_": guid from member id #"_id_" ("_remmirguid_") doesn't match this mirror ("_mirguid_")",1 /* broadcast and log message*/,1  /* Warning */)
    	s:log ^MIRROR(mirname,"Status","Member",id)=$LB("NOK","Wrong GUID")
    	quit 0  ; don't retry
	}
	if (name'=remname) {
		d $zu(9,"",entry_": Tried to contact "_name_" but remote system reports "_remname,1 /* broadcast and log message*/,1  /* Warning */)
    	s:log ^MIRROR(mirname,"Status","Member",id)=$LB("NOK","System name mismatch")
		quit 0  ; don't retry
	}
	if (guid'=remguid) {
		d $zu(9,"",entry_": Expected guid ("_guid_") for system "_name_" but remote system reports "_remguid,1 /* broadcast and log message*/,1  /* Warning */)
    	s:log ^MIRROR(mirname,"Status","Member",id)=$LB("NOK","System guid mismatch")
		quit 0  ; don't retry
	}
	w 1,*-3
	if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","SendID: Sent options 0x"_$ZH(+options)_", server replied: 0x"_$ZH(+remopts))
	q 1_"^"_remopts
}
ReadVerifyID(mirname,entry,type,reportnode,IsDRMember) {
	s mirguid=$G(^SYS("MIRRORSET",mirname,"GUID"))
	; The other side now sends us its id information, the mirror guid and
	; its system name in the mirror
	s resp=$$readdata()
	if '$lg(resp) {
		; $list(0,<err text>)
		s resp=$lg(resp,1)
		d $zu(9,"",entry_": "_resp,1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	s resp=$lg(resp,2)
	; resp is now $LB(mirrorguid,remote system mirror name,reportnode flag[,agentport,basedir])
	s remmirguid=$lg(resp,1)
	s remname=$lg(resp,2)
	s remguid=$lg(resp,3)
	s reportnode=$lg(resp,4)
	s clioptions=+$lg(resp,7)
	s clipid=$LG(resp,8)  ;pid of job we're talking to on other end, for debugging
	if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","Connected to process ("_clipid_") on other instance")
	s isAsync=+$G(^SYS("MIRRORSET"))
	s remagentport=$lg(resp,5)  ;agent address & base directory are ignored
	s rembasedir=$lg(resp,6)    ;if this isn't a reporting node
	s remssport=$lg(resp,9)
	s addrdata=$lg(resp,10)
	s IsDRMember=0
	if remssport'="" {
		s ecpip=$p(addrdata,"|")
		s mirip=$p(addrdata,"|",2)
		if mirip = "" s mirip = ecpip
		s agentip=$p(addrdata,"|",3)
		if agentip = "" s agentip = ecpip
		s SSLcn=$lg(resp,11)
		s IsDRMember=+$lg(resp,12)
		s DejrnFilter=$lg(resp,13)
		s AsyncMemberType=$lg(resp,14)
		if reportnode=2 {
			if AsyncMemberType="" s AsyncMemberType=$s(IsDRMember:0,1:1)
		} else {
			s AsyncMemberType=0
		}
	}
	if reportnode&&('isAsync) {
		s role=$SYSTEM.Mirror.GetInfo()
		if (role '[ ",PRIMARY,") {
			if (role["BACKUP")&&(type="d") {
				s found=0
				for pidx=1:1:^SYS("MIRRORSET",mirname,"Member") {
				   s r=$G(^MIRROR(mirname,"Status","Member",pidx,"Role"))
				   if (r="PRIMARY") s found=1 quit
				}
				i found {
					w 3_(pidx+1),*-3
					q 0
				}
			}
			if (role '[ ",SHADOW,") {
			   w 0 w *-3  ; tell other side we rejected its id
			   d $zu(9,"",entry_": non-primary received async member's ("_remname_") connection.",1 /* broadcast and log message*/,1  /* Warning */)
			   quit 0
			}
		}
	}
	if remmirguid'=mirguid {
		w 0 w *-3  ; tell other side we rejected its id
		d $zu(9,"",entry_": guid from connection ("_remmirguid_") doesn't match this mirror ("_mirguid_")",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	; Find remote system in list of mirror systems
	s id=0
	if reportnode {
		L +^SYS("MIRRORSET",mirname,"ReportMemberCount")
		s i=$o(^SYS("MIRRORSET",mirname,"Member",101-1),1,info)
		s abort=0
		while (i'="") {
			s name=$LG(info,1)
			s guid=$LG(info,2)
			if name=remname {
				if (guid=remguid) s id=i quit
				if (+$LG(info,10)) {
					w 0 w *-3  ; tell other side we rejected its id
					d $zu(9,"",entry_": Async member "_remname_" with GUID "_remguid_" abort due to different GUID "_guid_" is running",1 /* broadcast and log message*/,1  /* Warning */)
					s abort=1
					quit
				}
				s rc=##class(Config.MapMirrors).Delete(mirname,name)
				i ('rc) {
					k err
					Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
					d $zu(9,"",entry_": Async member "_remname_" with GUID "_remguid_" failed to be deleted error="_$g(err(1)),1 /* broadcast and log message*/,1  /* Warning */)
				}
				quit
			}
			s i=$o(^SYS("MIRRORSET",mirname,"Member",i),1,info)
		}
		if abort {
			L -^SYS("MIRRORSET",mirname,"ReportMemberCount")
			quit 0
		}
		if ('id) {
			if 0 {
				w 0 w *-3  ; tell other side we rejected its id
				d $zu(9,"",entry_": Failed to find "_remname_" in our list of mirror members while we are subscribed to EMS.",1 /* broadcast and log message*/,1  /* Warning */)
				L -^SYS("MIRRORSET",mirname,"ReportMemberCount")
				quit 0
			}
			Set props("ID") = mirname
			Set props("Name") = remname
			Set props("GUID") = remguid
			Set props("ConnectsTo") = $s(+$G(^SYS("MIRRORSET")):$LG(^SYS("MIRRORSET",mirname,"Member",0)),1:"")
			Set props("MemberType") = reportnode
			Set props("InstanceDirectory") = rembasedir
		    if remssport'="" {
			    Set props("AgentAddress") = agentip
				Set props("ECPAddress") = ecpip
			 	set props("MirrorSSPort") = remssport
				Set props("AgentPort") = remagentport
				Set props("MirrorAddress") = mirip
				Set props("SSLComputerName") = SSLcn
				Set props("DejournalFilter") = DejrnFilter
				Set props("AsyncMemberType") = AsyncMemberType
		    } else {
			    Set props("AgentAddress") = $SYSTEM.TCPDevice.PeerAddr(0) ;0=text form
				Set props("ECPAddress") = props("AgentAddress")
			 	set props("MirrorSSPort") = 1972
				Set props("AgentPort") = remagentport
				Set props("MirrorAddress") = props("AgentAddress")
		    }
		    s ipaddr=##class(%SYSTEM.INetInfo).HostNameToAddr(props("ECPAddress"))
		    if '##class(%SYSTEM.INetInfo).CheckAddressExist(ipaddr) {
			    Set SameECPMirror=(props("ECPAddress")=props("MirrorAddress"))
			    if 'SameECPMirror {
				    s mipaddr=##class(%SYSTEM.INetInfo).HostNameToAddr(props("MirrorAddress"))
				    s SameECPMirror=(mipaddr=ipaddr)
			    }
			    if SameECPMirror||('##class(%SYSTEM.INetInfo).CheckAddressExist(mipaddr)) {
					w 0 w *-3  ; tell other side we rejected its id
					d $zu(9,"",entry_": Skip adding "_remname_" in our list of mirror members because the superserver address "_props("ECPAddress")_$s('SameECPMirror:" and Mirror Private address "_props("MirrorAddress")_" are",1:" is")_" unreachable",1 /* broadcast and log message*/,1  /* Warning */)
					L -^SYS("MIRRORSET",mirname,"ReportMemberCount")
					quit 0
			    }
		    }
		    s rc=##class(Config.MapMirrors).Create(mirname,remname,.props)
			if ('rc) {
				L -^SYS("MIRRORSET",mirname,"ReportMemberCount")
				w 0 w *-3  ; tell other side we rejected its id
				d $zu(9,"",entry_": Failed to add "_remname_" in our list of mirror members. Error:"_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
				quit 0
			}
			s id=^SYS("MIRRORSET",mirname,"ReportMemberCount")+101-1
			if $SYSTEM.Mirror.IsPrimary() {
				s AddMember=1
sendsyncsignal	s primaryname=$LG($G(^SYS("MIRRORSET",mirname,"Member",0)))
				s i=$O(^SYS("MIRRORSET",mirname,"Member",0),1,info)
				while (i'="") {
					s sendsync=((+$LG(info,10))&&($G(^MIRROR(mirname,"Status","Member",i,"Version"))>3))
					if sendsync {
						s rc=$$NotifyMirrorChange^MIRRORCTL(mirname,i,primaryname)
						if ($LG(rc)'="OK") {
							d $zu(9,"",entry_": Failed to notify "_$LG(^SYS("MIRRORSET",mirname,"Member",i))_" for mirror configuration change. Error="_$LG(rc)_":"_$LG(rc,2),1 /* broadcast and log message*/,2  /* Severe error */)
						}
					} elseif i<101&&AddMember {
						s agentip = $LG(info,5)
						s basedir = $LG(info,6)
						s targguid= $LG(info,2)
						s rc=$$AddMemberToConfig^MIRRORCTL(mirname,agentip,targguid,basedir,remname,.props,1)
						if ('rc) {
							d $zu(9,"",entry_": Failed to add "_remname_" to the backup mirror member. Error:"_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
						}
					}
					s i=$O(^SYS("MIRRORSET",mirname,"Member",i),1,info)
				}
			}
		} else {
		    if ('0)&&(remssport'="") {
			    k props
				if reportnode'=$LG(info,8) Set props("MemberType")=reportnode
				if rembasedir'=$LG(info,6) Set props("InstanceDirectory") = rembasedir
				if agentip'=$p($LG(info,5),"|") Set props("AgentAddress") = agentip
				if ecpip'=$p($LG(info,3),"|") Set props("ECPAddress") = ecpip
				if remssport'=$p($LG(info,3),"|",2) set props("MirrorSSPort") = remssport
				if remagentport'=$p($LG(info,5),"|",2) Set props("AgentPort") = remagentport
				if mirip'=$p($LG(info,4),"|") Set props("MirrorAddress") = mirip
				if SSLcn'=$LG(info,7) Set props("SSLComputerName") = SSLcn
				if DejrnFilter'=$LG(info,12) Set props("DejournalFilter") = DejrnFilter
				if reportnode,AsyncMemberType'=$LG(info,13) Set props("AsyncMemberType") = AsyncMemberType
				if $d(props) {
				    s rc=##class(Config.MapMirrors).Modify(mirname,remname,.props)
					if ('rc) {
						d $zu(9,"",entry_": Failed to modify "_remname_" in our list of mirror members. Error:"_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
					} elseif $SYSTEM.Mirror.IsPrimary()&&('0) {
						s AddMember=0
						goto sendsyncsignal
					}
				}
		    }
		}
		Set $list(^SYS("MIRRORSET",mirname,"Member",id),10)=1
		L -^SYS("MIRRORSET",mirname,"ReportMemberCount")
	} else {
		s starting = 1
		s svrcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
		for i=starting:1:svrcnt {
			s info=$G(^SYS("MIRRORSET",mirname,"Member",i))
			s name=$LG(info,1)
			s guid=$LG(info,2)
			if name=remname&&(guid=remguid) s id=i quit
		}
		if ('id) {
			w 0 w *-3  ; tell other side we rejected its id
			d $zu(9,"",entry_": Failed to find "_remname_" in our list of mirror members",1 /* broadcast and log message*/,1  /* Warning */)
			quit 0
		}
		if ('0)&&(remssport'="")&&(remssport'=$p($LG(info,3),"|",2)) {
			k props
			set props("MirrorSSPort") = remssport
			s rc=##class(Config.MapMirrors).Modify(mirname,remname,.props)
			if ('rc) {
				d $zu(9,"",entry_": Failed to modify MirrorSSPort of "_remname_" in mirror set "_mirname_". Error:"_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
			} elseif $SYSTEM.Mirror.IsPrimary() {
				L +^SYS("MIRRORSET",mirname,"ReportMemberCount")
				s AddMember=0
				goto sendsyncsignal
			}
		}
		Set $list(^SYS("MIRRORSET",mirname,"Member",id),10)=1
	}
	; If we fail to lock this, we must already have a connection to this
	; member. We maybe have made an outgoing connection or there might be
	; multiple incoming connections if a prior one timed out for some reason.
	;
	l +^SYS("MIRRORSET",mirname,"Member",id,type):2
	if '$T {
		if type="d" d $zu(61,100,4)
		w 2 w *-3  ; tell other side we could not get the lock.
		if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"",entry_": Failed to lock (2) ^SYS("",MIRRORSET"",""Member"""_id_","""_type_""")")
		quit 0
	}
	; 
	; We've validated the other side's id so send back a 1 and then send
	; our id information. The other side knows who we are since it called us
	; but it verifies that what we send matches what it expects to see.
	w 1 w *-3  ; tell other side we accepted its id
	; See if the client sent us any options that we recognize. If so,
	; let the client know which ones we have in common and return this
	; information to our caller.
	s svroptions=0
	; $zb(+x,+y,1) -> and, $zb(+x,+y,7) = or
	if $zb(+clioptions,+4,1) s svroptions=$ZB(+svroptions,+4,7) 
	if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","ReadID Sending options: 0x"_$ZH(+svroptions)_", client requested: 0x"_$ZH(+clioptions))
	if '$$sendid(mirname,svroptions) {
		l
		quit 0
	}
	read resp#1:10
	if '$T {
		l
		d $zu(9,"",entry_": read id answer timed out.",1 /* broadcast and log message*/,1  /* Warning */)
	    quit 0
	}
	if 'resp {
		d $zu(9,"",entry_": remote rejected or id.",1 /* broadcast and log message*/,1  /* Warning */)
		l
	    quit 0
	}
	q id_"^"_svroptions
}
sendid(mirname,options) {
	; Send the mirror guid and our mirror system name as a $list
	; to the other side. This gets returned in readid()
	s $zt="err"
	s reportnode=+$LG($G(^SYS("MIRRORSET",mirname,"Member",0)),8)
	s mirguid=$G(^SYS("MIRRORSET",mirname,"GUID"))
    s info=$G(^SYS("MIRRORSET",mirname,"Member",0))
    s ourname=$LG(info)  ; our system name
    s ourguid=$LG(info,2) ; our guid
	s msg=$lb(mirguid,ourname,ourguid,reportnode)
	    ; reporting nodes also send the port # of their
	    ; agent process and their base directory.
	    s basedir=$LG(info,6)
 	    s agentport=$p($LG(info,5),"|",2)
 	    s $list(msg,5)=agentport
 	    s $list(msg,6)=basedir
 	    s $list(msg,9)=$p($LG(info,3),"|",2)
 	    s $list(msg,10)=$p($LG(info,3),"|")_"|"_$p($LG(info,4),"|")_"|"_$p($LG(info,5),"|")
 	    s $list(msg,11)=$LG(info,7)
 	    s asynctype=+$LG($G(^SYS("MIRRORSET",mirname,"Member",0)),13)
 	    s $list(msg,12)=(asynctype=0)   ; IsDR?
 	    s $list(msg,14)=asynctype  ;AsyncMemberType
 	    s $list(msg,13)=$LG(info,12)
	set $list(msg,7)=+$G(options)
	set $list(msg,8)=+$J  ;send our PID for logging purposes
	w $zwchar($L(msg)),msg w *-3
	quit 1
err ;
	s $zt=""
	; must have been a <WRITE> error
	d $zu(9,"","sendid^MIRRORMGR: Unexpected error: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	quit 0	
}
SendVerifyEncKey() {
	s dbenckey=$SYSTEM.Security.System.GetJrnEncKeyID(1)
	s dbenckeylist=$SYSTEM.Security.System.GetDBEncKeyIDList()
	s encryptedJournal=+##class(%SYS.Journal.System).IsJournalEncryptionEnabled()
	s msg=$lb(dbenckey,encryptedJournal,dbenckeylist)
	w $zwchar($L(msg)),msg w *-3
	s r=$$readdata()
	i '$lg(r) quit 0_"^"_$lg(r,2)
	q $lg($lg(r,2))
}
ReadVerifyEncKey() {
	s r=$$readdata()
	s val=$lg(r,2)
	i '$lg(r) {
		d $zu(9,"","Failure reading message with encryption settings",1 /* broadcast and log message*/,1  /* Warning */)
		quit "0^"_val
	}
	s ourkeyid=$SYSTEM.Security.System.GetJrnEncKeyID(1)
	s ourkeylist=","_$SYSTEM.Security.System.GetDBEncKeyIDList()_","
	s warnmsg=""
	s remotekeyid=$lg(val)
	if $LL(val)>1 {
		; if the client send the journal file encrypted
		; flag then make sure it matches our setting.
	    s encryptedJournal=+##class(%SYS.Journal.System).IsJournalEncryptionEnabled()
	    if encryptedJournal'=+$LG(val,2) {
			s warnmsg="Mismatched journal file encryption setting between mirror members, primary has it "_$s(encryptedJournal:"enabled",1:"disabled")_" while backup/DR has it "_$s(+$LG(val,2):"enabled",1:"disabled")
			d $zu(9,"","ReadVerifyEncKey: "_warnmsg,1 /* broadcast and log message*/,1  /* Warning */)
	    }
	    if $LL(val)>2 {
		    if encryptedJournal || +$LG(val,2) {
			    s remotelist=","_$LG(val,3)_","
			    if remotelist'[(","_ourkeyid_",") {
				    s v="0^"_"Backup/DR does not have primary's current journal encryption key ("_ourkeyid_") activated."
					s msg=$lb(v)
					w $zwchar($L(msg)),msg w *-3
					q v
			    } elseif ourkeylist'[(","_remotekeyid_",") {
				    s v="0^"_"Primary does not have backup/DR's current journal encryption key ("_remotekeyid_") activated."
					s msg=$lb(v)
					w $zwchar($L(msg)),msg w *-3
					q v
			    }
		    }
	    } elseif encryptedJournal&&(ourkeyid'=remotekeyid) {
			s v="0^"_"Mismatched journal encryption keys between mirror members, "_ourkeyid_"(primary) vs. "_remotekeyid_"(backup/DR)."
			s msg=$lb(v)
			w $zwchar($L(msg)),msg w *-3
			q v
	    }
	    if '($LL(val)>2)||(encryptedJournal&&+$LG(val,2)),ourkeyid'=""&&(remotekeyid'="")&&(ourkeyid'=remotekeyid) {
		    s msg="Journal encryption key ID is different "_ourkeyid_"(primary) vs. "_remotekeyid_"(backup/DR)."_$s($LL(val)>2:"",1:" It will cause problem when journal encryption is enabled.")
		    d $zu(9,"","ReadVerifyEncKey: "_msg,1 /* broadcast and log message*/,1  /* Warning */)
		    s warnmsg=warnmsg_$s(warnmsg="":"",1:"|")_msg
	    }
	} elseif ourkeyid'=remotekeyid {
		s v="0^"_"Mismatched journal encryption keys between mirror members, "_ourkeyid_"(primary) vs. "_remotekeyid_"(backup/DR)."
		s msg=$lb(v)
		w $zwchar($L(msg)),msg w *-3
		q v
	}
	s msg=$lb($s($LL(val)>2:"1^"_warnmsg,1:1))
	w $zwchar($L(msg)),msg w *-3
	q 1
}
SendVerifyDBList(mirname,rptnode,batch) {
	; send the list of mounted mirrored databases
	; with their encryption flag
	s $zt="err"
	s mirinfo=$SYSTEM.Mirror.GetNextDBBySFN(-1,mirname)
	s ok=1
	if batch s dblist=""
	while (+mirinfo '= -1) {
	   s mirdbname=$P(mirinfo,"^",2)
	   s dir=$P(mirinfo,"^",3)
	   if dir'="" && (mirdbname'="") {
	      s info=$ZU(49,dir) 
	      if +info<-1 {
		      s mirinfo=$SYSTEM.Mirror.GetNextDBBySFN(+mirinfo,mirname)
		      continue
	      }
	      s encrypted=$zb(+$p(info,",",16),$zu(40,8,27),1)
	      if (batch) {
		      s dbinfo($i(dbinfo))=$LB(+info,dir)
		      s db=$LB(encrypted_"^"_mirdbname)
		      if ($L(dblist)+$L(db))>32768 {
			      s msg=$LB(1)_$LB(dblist)
			      s dblist=db
			      goto sendout
		      }
		      s dblist=dblist_db
		      s mirinfo=$SYSTEM.Mirror.GetNextDBBySFN(+mirinfo,mirname)
		      continue
	      }
	      s msg=$LB(1,encrypted,mirdbname)
sendout   w $zwchar($L(msg)),msg w *-3
	      s r=$$readdata()
	      i '$lg(r) {
		     d $zu(9,"","SendVerifyDB failed to read response",1 /* broadcast and log message*/,1  /* Warning */)
		     quit  ; exit loop
	      }
	      s resp=$LG(r,2)  ;response value
	      if (batch) {
		      do batchcheckverifydb
		      k dbinfo
		      s dbinfo($i(dbinfo))=$LB(+info,dir)
	      } else {
		      s ans=resp,sfn=+info
		      d checkverifydb
	      }
	   }
	   s mirinfo=$SYSTEM.Mirror.GetNextDBBySFN(+mirinfo,mirname)
	}	
	if (+mirinfo'=-1) {
	   quit 0		; readdata up above returned failure
	}
	if batch,dblist'="" {
		s msg=$LB(1)_$LB(dblist)
		w $zwchar($L(msg)),msg w *-3
		s r=$$readdata()
		i '$lg(r) {
			d $zu(9,"","SendVerifyDB failed to read response",1 /* broadcast and log message*/,1  /* Warning */)
			quit 0
		}
		s resp=$LG(r,2)  ;response value
		do batchcheckverifydb
	}
	;
	s msg=$lb(2)  ;end of data
	w $zwchar($L(msg)),msg w *-3
    s r=$$readdata()
	i '$lg(r) {
	   d $zu(9,"","SendVerifyDB failed to read final status",1 /* broadcast and log message*/,1  /* Warning */)
	   quit 0
	}
	s resp=$LG(r,2)  ;response value
	if resp'=1 {
	   d $zu(9,"","SendVerifyDB, server send final error status",1 /* broadcast and log message*/,1  /* Warning */)
       quit 0
	}
	if ('ok) {
		; readdata returned failure or we hit a 
		; fatal validation error (encryption mismatch)
	   quit 0
	}
	quit 1  ;success
err ;
	s $zt=""
	d $zu(9,"","Unexpected error: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	d BACK^%ETN
	quit 0
batchcheckverifydb ;
	for i=1:1:$LL(resp) {
		s ans=$LI(resp,i),sfn=$LG(dbinfo(i)),dir=$LG(dbinfo(i),2)
		d checkverifydb
	    if $LG(ans)'=1 {
		    ; validation problem
		    if $lg(ans)=2 {
			    d $zu(9,"","Warning, remote node reports """_$LG(ans,2)_" sfn #"_$LG(dbinfo(i))_" ("_$LG(dbinfo(i),2)_")""",1 /* broadcast and log message*/,1  /* Warning */)
		    } else {
			    ; must be 3 - fatal error
			    s ok=0
			    d $zu(9,"","Error, remote node reports sfn #"_$LG(dbinfo(i))_" ("_$LG(dbinfo(i),2)_"): "_$LG(ans,2),1 /* broadcast and log message*/,1  /* Warning */)
		    }
	    }
	}
	q
checkverifydb ;
	if $lg(ans)'=1 {
		; validation problem
		if $lg(ans)=2 {
			d $zu(9,"","Warning, remote node reports """_$LG(ans,2)_" sfn #"_sfn_" ("_dir_")""",1 /* broadcast and log message*/,1  /* Warning */)
		} else {
			; must be 3 - fatal error
			s ok=0
			d $zu(9,"","Error, remote node reports sfn #"_sfn_" ("_dir_"): "_$LG(ans,2),1 /* broadcast and log message*/,1  /* Warning */)
		}
	}
	q
}
ReadVerifyDBList(mirname,rptnode,batch) {
	; send the list of mounted mirrored databases
	; with their encryption flag. This is executed
	; on the primary when a backup/reporting node
	; connects
	s $zt="err"
    k dblist
	s mirinfo=$SYSTEM.Mirror.GetNextDBBySFN(-1,mirname)
	while (+mirinfo '= -1) {
	   s mirdbname=$P(mirinfo,"^",2)
	   if (mirdbname'="") {
	      s dir=$P(mirinfo,"^",3)
	      s info=$ZU(49,dir) 
	      s encrypted=$zb(+$p(info,",",16),$zu(40,8,27),1)
	      s dblist(mirdbname)=encrypted
	   }
	   s mirinfo=$SYSTEM.Mirror.GetNextDBBySFN(+mirinfo,mirname)
	}
	s r=$$readdata()
	if '$LG(r) {
		d $zu(9,"","Failed to read database verification message",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	s ok=1
	s data=$lg(r,2)  ;
	if (batch) {
		s inputdb=$LG(data,2)
		if $LG(data)=1 s numdb=$LL(inputdb)
		s curdb=1
		s resmsg=""
	}
	while ($LG(data)=1) {
		if (batch) {
			s remencrypted=$p($LG(inputdb,curdb),"^")
			s remmirdbname=$p($LG(inputdb,curdb),"^",2)
		} else {
			s remencrypted=$LG(data,2)
			s remmirdbname=$LG(data,3)
		}
		s info=$G(dblist(remmirdbname))
		if info="" {
			d $zu(9,"","Warning, missing mirrored database "_remmirdbname,1 /* broadcast and log message*/,1  /* Warning */)
			s msg=$LB(2,"Missing database")
		} else {
			k dblist(remmirdbname)  ;remove entry
			if +info'=+remencrypted {
				d $zu(9,"","Encryption mismatch for "_remmirdbname,1 /* broadcast and log message*/,1  /* Warning */)
			   s msg=$LB(2,"Encryption mismatch")
			} else {
			   s msg=$LB(1)  ;ok
			}
		}
		if (batch) {
			s resmsg=resmsg_$LB(msg)
			if $i(curdb)<=numdb continue
			w $zwchar($L(resmsg)),resmsg w *-3
		} else {
			w $zwchar($L(msg)),msg w *-3
		}
	    s r=$$readdata()
	    if '$LG(r) {
		    d $zu(9,"","Failed to read database verification message",1 /* broadcast and log message*/,1  /* Warning */)
		    s data=$LB(0)
	    } else {
	       s data=$lg(r,2)
	       if (batch && ($LG(data)=1)) {
		       s inputdb=$LG(data,2)
		       s numdb=$LL(inputdb)
		       s curdb=1
		       s resmsg=""
	       }
	    }
	}
	; $LG(data) should be 2 to exit the loop successfully
	if '$LG(data) {
		quit 0   ;something went wrong
	}
	if 'rptnode {
	   ; its not unusual for reporting nodes to only have some
	   ; of the mirrored databases. If the client is a failover member
	   ; it probably should have all the mirrored dbs
	   ;
	   s mirdb=$O(dblist(""))
	   if mirdb'="" {
		  s msg="Warning: Failover member is missing the following mirrored databases: "
		  s cnt=0
	      while mirdb'="" {
		     if ('cnt) {
		        s msg=msg_mirdb
		     } else {
		        s msg=msg_", "_mirdb
		     }
		     s cnt=cnt+1
		     s mirdb=$O(dblist(mirdb))
	      }
	      d $zu(9,"",msg,1 /* broadcast and log message*/,1  /* Warning */)
	   }
	}
	s msg=1  ;send success after we read the last message
	w $zwchar($L(msg)),msg w *-3
	quit ok
err ;
	s $zt=""
	d $zu(9,"","Unexpected error "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	d BACK^%ETN
	quit 0
}
SendVerifyColList() {
	; send the list of collations for this node
	s $zt="err"
	; Get currently loaded collations names & numbers
	k colnames
	d ##class(%Library.Collate).MakeArray(.colnames,0,1,1)
    ; Get list of collations used in current locale
    Set loc=##class(Config.NLS.Locales).OpenCurrent()
    Set cols=loc.CollationTables
    s msg=""
    For i=1:1:cols.Count() {
        Set name=cols.GetAt(i)
        Set x=$G(colnames(name))  ;get data
        Set num=+$LG(x,3)  ;piece #3 is the collation #
		s msg=msg_$lb(num,name)
    }
    k colnames
    s cols="",loc=""
	w $zwchar($L(msg)),msg w *-3
	s r=$$readdata()
	i '$lg(r) quit 0_"^"_$lg(r,2)
	q $lg($lg(r,2))
err ;
	s $zt=""
	d $zu(9,"","Unexpected error: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	d BACK^%ETN
	quit 0
}
ReadVerifyColList() {
	s r=$$readdata()
	s val=$lg(r,2)
	i '$lg(r) {
		d $zu(9,"","Failure reading message with collation settings",1 /* broadcast and log message*/,1  /* Warning */)
		quit "0^"_val
	}
	k theirs
	for i=1:2:$ll(val) {
	   s num=$LG(val,i),name=$LG(val,i+1)
	   s theirs(num)=name
	}
	k colnames
	d ##class(%Library.Collate).MakeArray(.colnames,0,1,1)
    ; Get list of collations used in current locale
    Set loc=##class(Config.NLS.Locales).OpenCurrent()
    Set cols=loc.CollationTables
    s ourlist=""
    s missing=0
    For i=1:1:cols.Count() {
        Set name=cols.GetAt(i)
        Set x=$G(colnames(name))  ;get data
        Set num=+$LG(x,3)  ;piece #3 is the collation #
	    s ourlist=ourlist_$lb(num,name)
        if '$D(theirs(num)) {
		   s missing=1
        }
    }
    if missing goto colerr
	s msg=$lb(1)
	w $zwchar($L(msg)),msg w *-3
	q 1
colerr
	s ours="",theirs=""
	s len=$LL(ourlist)
	for i=2:2:len-2 {
		s ours=ours_""""_$lg(ourlist,i)_""","
	}
	s ours=ours_""""_$lg(ourlist,len)_""". "
	;
	s len=$LL(val)
	for i=2:2:len-2 {
		s theirs=theirs_""""_$lg(val,i)_""","
	}
	s theirs=theirs_""""_$lg(val,len)_""". "
	s v="0^"_"Mismatched collations between mirror members. Primary collations: "_ours_"Backup collations: "_theirs
	s msg=$lb(v)
	w $zwchar($L(msg)),msg w *-3
	q v
}
SendVerifyTime(mirname) {
	; send the time(0) value this node to find the delta time between the two members.
	s $zt="err"
	s msg=$LB($zu(99,0))
	w $zwchar($L(msg)),msg w *-3
	s r=$$readdata()
	i '$lg(r) quit 0_"^"_$lg(r,2)
	s delta=$lg($lg(r,2))
    s ^MIRROR(mirname,"PrimaryDeltaTime")=delta
	q 1
err ;
	s $zt=""
	d $zu(9,"","Unexpected error: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	d BACK^%ETN
	quit 0
}
ReadVerifyTime(mirname,id) {
	s r=$$readdata()
	s val=$lg(r,2)
	i '$lg(r) {
		d $zu(9,"","Failure reading message with Time settings",1 /* broadcast and log message*/,1  /* Warning */)
		quit "0^"_val
	}
	s delta=$zu(99,0)-$LG(val)
    s ^MIRROR(mirname,"Status","Member",id,"DeltaTime")=delta
	s msg=$lb(delta)
	w $zwchar($L(msg)),msg w *-3
	q 1
}
readdata() PUBLIC { ;
	s $zt="err"
	; returns $LB(0,<error text>)
	; or      $LB(1,$LB(<message>)
	read resp#2:5
	if '$T {
		quit $lb(0,"Member didn't return len of id string")
	}
	s len=$zwascii(resp)
	read resp#len:5
	if '$T {
		quit $LB(0,"Member didn't return id string")
	}
	quit $LB(1,resp)
err ;
	s $zt=""
	; must have been a <READ> error
	quit $LB(0,"Unexpected error: "_$ZE)
}
post(mirname,mgrpid,id,text,ngs=0) PUBLIC {
	i 'mgrpid {
		s mgrpid=+$G(^MIRROR(mirname,"MgrJobID"),0)
		i 'mgrpid {
			if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","post^MIRRORCOMM("_mirname_") skipped because Mirror Master is not running.")
			Quit
		}
	}
	if (ngs) {
		do $SYSTEM.Event.Signal(mgrpid, $LB("MSGQ",0,$LB(id,text)))
	} else {
		s index=$I(^MIRROR(mirname,"MSG","InQ"))
		s ^MIRROR(mirname,"MSG","InQ",index)=$LB(id,text)
		do $SYSTEM.Event.Signal(mgrpid, $LB("MSGQ",index))
	}
	quit
}
GetECPSessionData(mirname,NeedProgagateData) PUBLIC {
	/* When a failover node starts up before it checks whether it should
	   become the primary, it tries to retrieve the ECP Session data from
	   the other node if it looks like the other node has been the primary
	   since this node was the primary. This is in case the other node was up
	   and failed and we then become the primary. We want to have the current
	   copy of the session data to support ECP rollover. We can't ensure that
	   we've replayed the journal file(s) that contain this data since we may
	   not have needed to replay that part of the file in order to recover
	   our databases so we retrieve it directly from the other node. Once
	   we've done this once we never have to do it again because we'll receive
	   any updates to this via the journal data we replay
	   NeedProgagateData = 1, get ECP session data and progagated data.
	   NeedProgagateData = 2, don't get ECP session data, get only progagated data. 
	   Returns 1/0 for whether we succeeded in retrieving the ECP session data
	   (if we decide we were the last primary we also return 1 because there is
	   no data to retrieve). If we return 0 we can still become the primary however
	   we log a message because ECP Clients will fail to reconnect so they will
	   reset their sessions (most likely).   
	*/
	s $zt="err"
    s lastjrn=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
	if +lastjrn<=0 {
	   d $zu(9,"","GetECPSessionData: GetLastJournalFilename failed",1 /* broadcast and log message*/,1  /* Warning */)
	   Quit 0
	}
	s lastjrn=$P(lastjrn,",",2)
	s jrninfo=$zu(78,22,lastjrn,99)
	if +jrninfo'=1 {
	   d $zu(9,"","GetECPSessionData: Failed to get "_lastjrn_" header info",1 /* broadcast and log message*/,1  /* Warning */)
	   Quit 0
	}
	s guid=$p(jrninfo,",",14+1)
	s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
	for ix=0:1:systemcnt {
	   s info=$G(^SYS("MIRRORSET",mirname,"Member",ix))
	   if $lg(info,2)=guid Quit
	}
	if $lg(info,2)'=guid {
	   d $zu(9,"","GetECPSessionData: no matching GUID "_guid_" found",1 /* broadcast and log message*/,1  /* Warning */)
	   Quit 0  ;this is odd, shouldn't happen
	}
	if ix=0 {
	   d $zu(9,"","GetECPSessionData: this is the latest primary",0,0  /* Informational message */)
       Quit 1  ;no need to do this again
	}
	s node=$$GetECPConnectionData^MIRRORCTL(mirname,ix,NeedProgagateData)
	s status=$LG(node)
	if status["ERR" {
	   d $zu(9,"","GetECPSessionData: Failed to get ECP data from agent "_$lg(node,2),1 /* broadcast and log message*/,1  /* Warning */)
	   Quit 0
	}
	s node=$LG(node,2)
	if NeedProgagateData>1 {
		s start=1
		goto noecpdata
	}
	s ix=$O(^%SYS("SERVICE","ECPMIRs",""),1,value)
	while (ix'="") {
		if $LG($G(^SYS("MIRRORSET",mirname,"Member",0)),2)'=$listget(value,4) {
			k ^%SYS("SERVICE","ECPMIRs",ix)
		}
		s ix=$O(^%SYS("SERVICE","ECPMIRs",ix),1,value)
	}
	k ^%SYS("LASTSESSIONGUIDMIR")
	k ^%SYS("SERVICE","PrimaryECPSessionVersion")
	k ^%SYS("SERVICE","ECPNoRecovery")
    s len=$LG(node)
    if 'len {
	   d $zu(9,"","GetECPSessionData: $ZE in remote is "_$LG(node,2),1 /* broadcast and log message*/,1  /* Warning */)
	   Quit 0
	}
	if $LG(node,2)'="" {
		s ^%SYS("LASTSESSIONGUIDMIR")=$LG(node,2)
	}
	f i=3:1:len+1 {
	   s info=$LG(node,i)
	   s value=$lg(info,2)
	   if $lg(value,4)="" s ^%SYS("SERVICE","ECPMIRs",$lg(info,1))=value
	}
	d $zu(9,"","GetECPSessionData: Got ECP data from agent len="_len,0,0  /* Informational message */)
	s start=len+2
noecpdata
	s len=$LG(node,start)
	if (len) {    						;JO2386
	   s ourname=$LG($G(^SYS("MIRRORSET",mirname,"Member",0)))
	   f i=start+1:1:start+len {
		   s info=$LG(node,i)
		   s name=$lg(info,1),val=$lg(info,2),jcnt=$p(val,"^",2)
		   s lastjrninfo=$G(^MIRROR(mirname,"LastJrnfileSent",name))
		   if name'=ourname {
			   if lastjrninfo="" ||(+$p(lastjrninfo,"^",2)<jcnt) {
				   s ^MIRROR(mirname,"LastJrnfileSent",name)=val
			   }
		   }
	   }
	}									;JO2386
	s start=start+len+1  ;skip to the next block
	s len=+$LG(node,start)
	if (len) {
		s val=$LG(node,start+1)
		s curval=$G(^%SYS("SERVICE","ECPSessionVersion"),"<unknown>")
		s ^%SYS("SERVICE","PrimaryECPSessionVersion")=val
		if (val'=curval) {
		   ; log a message when these differ
		   d $zu(9,"","GetECPSessionData: PrimaryECPSessionVersion="_val_", local ver =  "_curval,0,0  /* Informational message */)
		}
		s start=start+len+1  ;skip to the next block
		s len=$LG(node,start)
		if (len) {
		   s ourname=$LG($G(^SYS("MIRRORSET",mirname,"Member",0)))
		   f i=start+1:1:start+len {
			   s info=$LG(node,i)
			   s name=$lg(info,1)
			   if name'=ourname {
				   s val=$lg(info,2),gt=$p(val,"^",2)
				   s lastinfo=$G(^MIRROR(mirname,"lastdisconnected",name))
				   s ot=$p(lastinfo,"^",2)
				   if lastinfo=""||($p(lastinfo,"^")="PRIMARY"&&(((gt-ot)*86400+$p(gt,",",2)-$p(ot,",",2))>0)) {
					   s ^MIRROR(mirname,"lastdisconnected",name)=val
				   }
			   }
		   }
		}
	} else {
		d $zu(9,"","GetECPSessionData: PrimaryECPSessionVersion not sent by server, set to 2",0,0  /* Informational message */)
	    s ^%SYS("SERVICE","PrimaryECPSessionVersion")=1
	}	
	s start=start+len+1  ;skip to the next block
	s len=+$LG(node,start)
	if (len) {
		s val=+$LG(node,start+1)
		if (val'=0) {
		   d $zu(9,"","GetECPSessionData: Setting ECPNoRecovery="_val,0,0  /* Informational message */)
		   s rc=$$ECPJrnSync^ECPRecovery(val,1) 
		}
	} else {
	}	
	Quit 1  ;success
err ;
	s $ZT=""
	d $zu(9,"","GetECPSessionData: Unexpected error: "_$ze,1 /* broadcast and log message*/,1  /* Warning */)
    quit 0   ;failed		
}
ValidateAgent(reportingNode,mirname) PUBLIC {
	; Called during startup to check whether agent is up and correct.
	s rc=##class(SYS.Agent).VerifyConnection()
	if ('rc) {
		if 'reportingNode {
			d $zu(9,"","Failed to verify Agent connection",1 /* broadcast and log message*/,1  /* Warning */)
			if +$G(^MIRROR(":Debug","AgentVerifyErrorOk")) {
				goto verok
			}
			quit 0
		} else {
			d $zu(9,"","ISCAgent is not available",1 /* broadcast and log message*/,1  /* Warning */)
			quit 1	; no agent is ok
		}	
	}
	s ver=##class(SYS.Agent).GetVersion()
	if ver="" {
		if 'reportingNode {
			d $zu(9,"","Failed to get Agent version",1 /* broadcast and log message*/,1  /* Warning */)
			if +$G(^MIRROR(":Debug","AgentVerifyErrorOk")) {
				goto verok
			}
			quit 0
		} else {
			d $zu(9,"","Failed to get Agent version",1 /* broadcast and log message*/,1  /* Warning */)
			quit 1	; no agent is ok
		}	
	}
	if $p(ver,".",1) > $SYSTEM.Version.GetMajor() goto verok
	if $p(ver,".",1) < $SYSTEM.Version.GetMajor() goto vererr
	if $p(ver,".",2) > $SYSTEM.Version.GetMinor() goto verok
	if $p(ver,".",2) < $SYSTEM.Version.GetMinor() goto vererr
	if +$p(ver,".",3) > +$SYSTEM.Version.GetPoint() goto verok
	if +$p(ver,".",3) < +$SYSTEM.Version.GetPoint() goto vererr
	if +$p(ver,".",4) >= +$SYSTEM.Version.GetBuildNumber() goto verok
vererr
	if $ZV["-dev" {
		d $zu(9,"","ISCAgent version "_ver_" instance version "_$zv,1 /* broadcast and log message*/,1  /* Warning */)
	} else {
		if 'reportingNode {
			d $zu(9,"","Mismatched mirror / agent versions. Agent "_ver_" Instance "_$SYSTEM.Version.GetMajor()_"."_$SYSTEM.Version.GetMinor()_"."_+$SYSTEM.Version.GetPoint()_"."_$SYSTEM.Version.GetBuildNumber(),1 /* broadcast and log message*/,1  /* Warning */)
			if +$G(^MIRROR(":Debug","AgentVerifyErrorOk")) {
				goto verok
			}
			quit 0
		} else {
			d $zu(9,"","Mismatched mirror / agent versions. Agent "_ver_" Instance "_$SYSTEM.Version.GetMajor()_"."_$SYSTEM.Version.GetMinor()_"."_+$SYSTEM.Version.GetPoint()_"."_$SYSTEM.Version.GetBuildNumber(),1 /* broadcast and log message*/,1  /* Warning */)
			quit 1	; no agent is ok
		}	
	}
verok
	s agentaddr = $LG($G(^SYS("MIRRORSET",mirname,"Member",0)),5)
	if 'reportingNode {
		if agentaddr="" {
			d $zu(9,"","ValidateAgent: Failed to find agent address/port for local system in mirror set "_mirname,1 /* broadcast and log message*/,1  /* Warning */)
			if +$G(^MIRROR(":Debug","AgentVerifyErrorOk")) {
				quit 1
			}
			Quit 0
		}
		s rc=$$InstanceLookup^MIRRORCTL(agentaddr,$P($ZU(86),"*",2))
		if $LG(rc)'="OK"||($LG(rc,2)'="OK") {
			d $zu(9,"","Failed InstanceLookup (agent probably not running): "_$s($LG(rc)'="OK":$LG(rc,2),1:$LG(rc,3)),1 /* broadcast and log message*/,1  /* Warning */)
			if +$G(^MIRROR(":Debug","AgentVerifyErrorOk")) {
				quit 1
			}
			quit 0
		}
		s instdir=$ZU(12,$LG(rc,3))
		s root = $ZU(12,$ZU(12)_"..")
		if (instdir '= root) {
			d $zu(9,"","Failed Agent instance check. Agent returned '"_instdir_"'; mirror instance is '"_root_"'",1 /* broadcast and log message*/,1  /* Warning */)
			if +$G(^MIRROR(":Debug","AgentVerifyErrorOk")) {
				quit 1
			}
			quit 0
		}
	}
    quit 1  ;validated agent
}
ValidatePromoteMembership(mirname,agentiplist,targguid,basedir,failoverlist) PUBLIC {
	s rc=$$GetMemberConfigData^MIRRORCTL(mirname,agentiplist,targguid,basedir,failoverlist)
	if $LG(rc)'>0 quit 0
	s notlisted=1  ;cleared if we find ourself in this member's config
	s memberlist=$LG(rc,2)
	if $LL(memberlist)'=$L(failoverlist,",") quit 0   ; number of member did not match.
	s mismatch=0
	for i=1:1:$LL(memberlist) {
		s item=$LG(memberlist,i)
		s membername=$lg(item,1)
		if ","_failoverlist_","'[(","_membername_",") {
			s mismatch=1
			quit
		}
		s data=$LG(item,2)
		s len=$LL(data)
		k mtype
		for j=1:1:len {
			s item=$LG(data,j)
			if $LG(item,1)="MemberType" {
				s mtype=$LG(item,2)
				quit
			}
		}
		if $G(mtype,99)'=0 {
			s mismatch=1
			quit
		}
    }
    if 'mismatch {
	   s mm=##class(Config.MirrorMember).Open(,,.rc)
	   if ('rc) {
		  d $zu(9,"","Failed to look up our mirror name while validating mirror membership",1 /* broadcast and log message*/,1  /* Warning */)
		  quit 0
	   }
	   s mm.ValidatedMember = 1
	   s rc=mm.%Save()
	   if ('rc) {
		  d $zu(9,"","Failed to save changes to set ValidatedMember flag",1 /* broadcast and log message*/,1  /* Warning */)
		  quit 0
	   }
	   s mm=""
	   quit 1
    }
    s failoverlist=","
	for i=1:1:$LL(memberlist) {
		s item=$LG(memberlist,i)
		s membername=$lg(item,1)
		s failoverlist=failoverlist_membername_","
	}
    quit 0
}
ValidateMirrorMembership(mirname) PUBLIC {
	; Called during startup to check whether we are a valid mirror
	; member or not. We're a valid mirror member if we're listed
	; in the mirror configuration of all the other mirror members
	; who are marked valid and if they are listed in our configuration.
	; If we're a valid member then we set the ValidatedMember flag in
	; our configuration and we don't need to call this routine again.
	s mm=##class(Config.MirrorMember).Open(,,.rc)
	if ('rc) {
		d $zu(9,"","Failed to look up our mirror name while validating mirror membership",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	s ourname=mm.SystemName
	s mm=""
	s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
	if 'systemcnt {
		d $zu(9,"","Failed to validate mirror membership: No other nodes are defined",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	s errorflag = 0 ; a member marked valid is missing from our config
	s info=$G(^SYS("MIRRORSET",mirname,"Member",1))
    if info="" quit 0
	s name=$lg(info,1)
	s agentip=$$BuildAgentAddrlist^MIRRORCTL(info)
	s basedir=$lg(info,6)
	s targguid=$LG(info,2)
    ; Retrieve the mirror config so we can figure out whether this is a valid
    ; member or not.
	s rc=$$GetMemberConfigData^MIRRORCTL(mirname,agentip,targguid,basedir,"*",1)
	if '$LG(rc) {
		if $LG(rc,2)="LOCALSSLERR" {
			s rc=$$AddPendingDNUpdates(mirname,name,agentip,targguid,basedir)
			if '+$LG(rc) {
				d $zu(9,"","Validation error: (LOCALSSLERR) Failed to add pending DN updates list for member """_name_""" reason: "_$lg(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
			}
			quit 0
		}
		d $zu(9,"","Validation error: Failed to get configuration data of Mirror member """_name_""" reason: "_$lg(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	if '(+$LG(rc)>0) {
		d $zu(9,"","Validation error: ValidatedMember in """_name_""" is not set.",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	s ListedType=-1  ;The member type found match in the list.
	s memberdata=$LG(rc,2)  ;list of $LIST(name,<list of key/value pairs>)
	s membercnt=$LL(memberdata)
	f ii=1:1:membercnt {
		s info=$LG(memberdata,ii)
		s membername=$LG(info,1)
		s data=$lg(info,2)
		s len=$LL(data)
		for i=1:1:len {
			s item=$LG(data,i)
			s p=$LG(item,1)
			s v=$LG(item,2)
			s MapMirrors(membername,p)=v
		}
		if membername=ourname {
			s ListedType=MapMirrors(membername,"MemberType")
			s ListedDN=MapMirrors(membername,"SSLComputerName")
		} elseif MapMirrors(membername,"MemberType")=0&&(membername'=name) {
			if $D(FailoverMember) {
				s BadFailoverMember=membername
				s ListedType=-1  ; in case it has been set to non -1.
				quit
			}
			s FailoverMember=membername
		}
	}
	if ListedType<0 {
		if $G(BadFailoverMember)'="" {
			d $zu(9,"","Validation error: Mirror member """_name_""" has two other failover members ("_FailoverMember_" and "_BadFailoverMember_")",1 /* broadcast and log message*/,1  /* Warning */)
		} else {
			d $zu(9,"","Validation error: Mirror member """_name_""" does not list us as a mirror member",1 /* broadcast and log message*/,1  /* Warning */)
			s rc=$$SetApproval^MIRRORCTL(mirname,1,$G(^SYS("MIRRORSET",mirname,"Member",0)))
		}
		quit 0
	}
	if ListedType=0 {
		If +$G(^SYS("MIRRORSET",mirname,"UseSSL"))&&(ListedDN'=$LG($G(^SYS("MIRRORSET",mirname,"Member",0)),7)) {
			d $zu(9,"","Validation error: DN of local system not matched with DN in Mirror member """_name_""".",1 /* broadcast and log message*/,1  /* Warning */)
			s rc=$$SetApproval^MIRRORCTL(mirname,1,$G(^SYS("MIRRORSET",mirname,"Member",0)))
			quit 0
		}
		quit 1
    }
    if $G(FailoverMember)'="" {
	    s index=101-1
	    f  {
		    s index=$O(^SYS("MIRRORSET",mirname,"Member",index),1,info)
		    q:index=""
		    if $lg(info)=FailoverMember quit
		}
		if index="" {
			d $zu(9,"","Validation error: This member was demoted in "_name_" and failover member """_FailoverMember_""" in remote does not exist in local configuration, this member will be demoted to async member. Demoting this member '"_ourname_"'.",1 /* broadcast and log message*/,1  /* Warning */)
			quit 3_","_ListedType_","_$LB(FailoverMember,$G(MapMirrors(FailoverMember,"GUID")),$G(MapMirrors(FailoverMember,"ECPAddress"))_"|"_$G(MapMirrors(FailoverMember,"MirrorSSPort")),$G(MapMirrors(FailoverMember,"MirrorAddress"))_"|"_$G(MapMirrors(FailoverMember,"MirrorSSPort")),$G(MapMirrors(FailoverMember,"AgentAddress"))_"|"_$G(MapMirrors(FailoverMember,"AgentPort")),$G(MapMirrors(FailoverMember,"InstanceDirectory")),$G(MapMirrors(FailoverMember,"SSLComputerName")),$G(MapMirrors(FailoverMember,"MemberType")),$G(MapMirrors(FailoverMember,"ConnectsTo")),0,$G(MapMirrors(FailoverMember,"EncryptCommunication")))
		}
    } else {
	    s index=""
    }
    quit "2,"_ListedType_","_index
}
CompareJournalBlock(mirname,jrnfile,mirfilecnt,id,endoff,datablk) {
	s $zt="err"
	if endoff<=(65536*2) quit 1
	s blockoff=$s(endoff#65536:endoff\65536*65536,1:endoff-65536)
	s length=endoff-blockoff
	s failed=0
	if $L(datablk) {	
		if $L(datablk)<length {
			if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","CompareJournalBlock: len of passed datablk smaller than expected for #"_mirfilecnt_" offset "_blockoff_" len "_length_", $L(datablk)="_$L(datablk)_".")
			quit 0
		}
		;If the server's block is longer than ours, truncate it
		if length'=$l(datablk) {
			s datablk=$E(datablk,1,length)
		}
	} else {	
		s rc=$$GetJournalBlock^MIRRORCTL(mirname,id,mirfilecnt,blockoff,length)
		i $LG(rc)'="OK" {
			if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","CompareJournalBlock: GetJournalBlock failed for for #"_mirfilecnt_" offset "_blockoff_" len "_length_", error: "_$LG(rc,2))
			goto done
		}
		s datablk=$LG(rc,2)
		if (datablk="") {
			if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","CompareJournalBlock: GetJournalBlock returned null for block content for #"_mirfilecnt_" offset "_blockoff_" len "_length_".")
			goto done
		}
		if $L(datablk)'=length {
			if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","CompareJournalBlock: len of fetched datablk smaller than expected for #"_mirfilecnt_" offset "_blockoff_" len "_length_", $L(datablk)="_$L(datablk)_".")
			quit 0
		}
	}
	s fd=$zu(78,5,jrnfile,0)
	if fd<0 {
		d $zu(9,"","("_mirname_") Failed to open journal file "_jrnfile_" in CompareJournalBlock",1 /* broadcast and log message*/,1  /* Warning */)
		quit 1
	}
	do $zu(78,6,fd)
	s ourdata=$zu(78,65,blockoff,length)
	do $zu(78,7,fd)
	if ourdata="" {
		if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","CompareJournalBlock: local journal returned null for block content for #"_mirfilecnt_" offset "_blockoff_" len "_length_".")
		quit 1
	}
	if ourdata'=datablk {
		s failed=1
	}
done ;	
	q:failed 0
	if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","CompareJournalBlock comparison succeeds on #"_mirfilecnt_" endoff "_endoff)
	quit 1
err d $zu(9,"","CompareJournalBlock: Got error, $ZE="_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	quit 1
}
SetValidJournalFileEnd(mirname,jrnfcnt,jrnfile,lastflag,forceBecomePrimary=0) PUBLIC {
	/* The end of this journal file isn't marked valid. We need to 
	   talk to the mirror member(s) to figure out what it should be. 
	   Returns: 1 = success, caller should continue
	            0 = serious error, caller should return failure
	   Updates ^MIRROR(mirname,"lastvalidjrnfile")=<mirjrncnt>^<jrnfilename>
	   "lastvalidjrnfile" is the last file on this node with a valid end.
       There are several possibilities here:
             Node(s) do not respond (agent is down)
             File is beyond end of log
             File is missing in log
             File has valid end
             File end is not valid
             File is current mirror journal file
          a) Other node doesn't respond => 
             forceBecomePrimary = 0 -> Report "failed to validate", Return FAILURE
             forceBecomePrimary = 1 -> mark current end as valid
          b) File is missing in other node's log file => 
                                   Report failed to validate, Return Failure
	      c) File is beyond the end of the other node's log file
			  Is this our last not-valid journal file?
				-> Yes: Mark current journal end as valid, Return SUCCESS
                -> No: Report Error. Check to see if we can find file 
                           on other system. return FAILURE - something is wrong
                           here, the file should have been in the other node's 
                           log or it should be our last not-valid file....
          d) File is the current journal file
             Is this our last not-valid journal file?
                -> No: Shut down mirror, big troubles, return FAILURE
                -> Yes: Return Success
          e) If other size > our size
                -> Retrieve missing parts of file
                -> If end is not marked valid, set valid end to 
                    the end of file (on all nodes)
          f) other size <= our size
				 -> if not valid end, set valid end to
				 	our size otherwise set our valid
					end to the valid end reported by
					the other node.
	*/
	; Determine the end of our file
	s $zt="err"
	s fd=$zu(78,5,jrnfile,0)
    if fd<0 {
       d $zu(9,"","("_mirname_") Failed to open journal file "_jrnfile_" to validate its end",1 /* broadcast and log message*/,1  /* Warning */)
       quit 0
    }
	do $zu(78,6,fd)
	s ourendoff=$zu(78,18,0)
	do $zu(78,7,fd)
	s jrninfo=$zu(78,22,jrnfile,99)
	if +jrninfo'=1 {
		d $zu(9,"","("_mirname_") Failed to read header of "_jrnfile_" to validate its end",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	s jrnguid=$P(jrninfo,",",7+1)
	s sysguid=$P(jrninfo,",",14+1)  ;mirror system guid that created jrnfile
	s mirfilecnt=$P(jrninfo,",",13+1)
	s lastvalidfilecnt=+$G(^MIRROR(mirname,"lastvalidjrnfile"))
    s info=$G(^SYS("MIRRORSET",mirname,"Member",0))
    s ourguid=$LG(info,2) ; our guid
    if '$D(^SYS("MIRRORSET"),reportingNode) {
	    d $zu(9,"","("_mirname_") SetValidJournalFileEnd called before ^SYS(""MIRRORSET"") loaded",1 /* broadcast and log message*/,1  /* Warning */)
	    quit 0
    }
    s reportingNode=+reportingNode  ;1st piece is 1 for reporting node or 0 for failover node
    s dbmaxinfo=$$GetMaxDBJrnInfo^MIRRORMGR(mirname)
    if '$LG(dbmaxinfo) {
	    d $zu(9,"","("_mirname_") SetValidJournalFileEnd failed to look up db max info",1 /* broadcast and log message*/,1  /* Warning */)
	    s dbmaxinfo=$LB(0,0,0)  ;dbjrnfilecnt=0, dbjrnpos=0
    }
	; dbmaxinfo=$Lb(rc,<jrnfilecnt>,<jrnendoff>)
	s dbjrnfilecnt=$lg(dbmaxinfo,2)
	if mirfilecnt=dbjrnfilecnt {
		s dbmaxjrnpos=$LG(dbmaxinfo,3)
	} else {
		s dbmaxjrnpos=0
	}
	s AllowSet=forceBecomePrimary||('reportingNode&&($G(^SYS("MIRRORSET",mirname,"Member"),-1)=0))
	k results
	s results=0,missing=0
	s maxendoff=0,bestid=0
	s primaryid=+$G(^MIRROR(mirname,"PrimaryMember"))
	s lastid=+$G(^SYS("MIRRORSET",mirname,"Member"))
	for id=1:1:lastid {
 	   if primaryid&&(primaryid'=id) continue
	   s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
	   if info="" {
	      d $zu(9,"","Missing node information for member #"_id_" - SetValidJrnFileEnd aborted",1 /* broadcast and log message*/,1  /* Warning */)
		  s missing=1
		  quit  ;exit loop
	   }
 	   s name=$lg(info,1)
       s rc=$$GetJournalEnd^MIRRORCTL(mirname,id,jrnguid,mirfilecnt)
       ; -1 = error, 
       ; 0 = jrnfile not on server & beyond end of log, 
       ; 1 = jrnfile found
       if $LG(rc)=-1 {
	      ; some error - abort
	       d $zu(9,"","("_mirname_") SetValidJrnFileEnd: GetJournalEnd from "_name_" returned: "_$LG(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
	       s missing=1
	       s errstr=$LG(rc,2)
	       if errstr["GUID "&&(errstr[" doesn't match") {
		       d $zu(9,"","This member has detected that its data is inconsistent with the mirror "_mirname_". If the primary is running and has the correct mirrored data, this member, including its mirrored databases, must be rebuilt. See 'Rebuilding a Mirror Member' in the Mirroring chapter of documentation for details.",1 /* broadcast and log message*/,2  /* Severe error */)
		       s ^MIRROR(mirname,"Status","MGR")="Exit"  ; to quit the MIRRORMGR routine.
		       quit
	       }
	       if reportingNode continue
	       quit  ;exit loop
       }
       s results=results+1
	   s results(id)=rc
	   if $LG(rc)=1 {
		   s validend=$LG(rc,2)  ;we'll exit the loop if validend is non-zero
		   s endoff=$LG(rc,3)
		   if validend {
		      s bestid=id
		   	  quit   ;exit loop once we find a valid endpoint
	   	   }
	   	   if (endoff>maxendoff) {
		   	   s maxendoff=endoff
		   	   s bestid=id  ;don't override id from validend
	   	   }
	   }
	   ; code 7 = Return GetMaxDBJrnInfo()
       s rc=$$GetJournalInfo^MIRRORCTL(mirname,id,7)
       if $LG(rc)="OK" {
	       s res=$LG(rc,2)
	       s dbjrnfilecnt=$LG(res,1)
	       s dbjrnpos=$LG(res,2)
		   if mirfilecnt=dbjrnfilecnt,dbjrnpos>dbmaxjrnpos {
			   s dbmaxjrnpos=dbjrnpos
		   }
       } else {
	       ;ignore error from earlier servers whihc don't recognize this message
	       s msg=$LG(rc,2)
	       if msg'["Unrecognized function code" {
		       d $zu(9,"","("_mirname_") SetValidJrnFileEnd: GetJournalInfo returned: "_msg,1 /* broadcast and log message*/,1  /* Warning */)
	       }
       }
	}
	if $G(^MIRROR(mirname,"Status","MGR"))="Exit" quit 0
	if missing&&'reportingNode {
		if (dbmaxjrnpos > ourendoff) {
			s msg="Journal file "_jrnfile_" (#"_mirfilecnt_") ends at "_ourendoff_" but databases are current as of "_dbmaxjrnpos_"."
			s msg=msg_$C(13,10)_"If the original journal file cannot be recovered, the mirror will need to be rebuilt."
			d $zu(9,"",msg,1 /* broadcast and log message*/,1  /* Warning */)
			quit 0  ;failure
		}
		if forceBecomePrimary {
			d $zu(9,"","Ignoring error: Setting valid end of "_jrnfile_" (#"_mirfilecnt_") to "_ourendoff,0,0  /* Informational message */)
	        s x=$SYSTEM.Mirror.SetMirrorJournalFileEnd(jrnfile,ourendoff,AllowSet)
	        if x {
			    if mirfilecnt>lastvalidfilecnt {
				    s ^MIRROR(mirname,"lastvalidjrnfile")=mirfilecnt_"^"_jrnfile
			    }
		        quit 1 ; success
	        }
		    d $zu(9,"","Failed to set valid end of file "_jrnfile_" to "_ourendoff,1 /* broadcast and log message*/,1  /* Warning */)
		}
		quit 0
	}
	if 'results {
	   if reportingNode {
		   d $zu(9,"","Async member failed to find "_jrnfile_" on any other node",1 /* broadcast and log message*/,1  /* Warning */)
		   quit 0  
	   }
	   if (dbmaxjrnpos > ourendoff) {
		   s msg="Journal file "_jrnfile_" (#"_mirfilecnt_") ends at "_ourendoff_" but databases are current as of "_dbmaxjrnpos_"."
		   s msg=msg_$C(13,10)_"If the original journal file cannot be recovered, the mirror will need to be rebuilt."
		   d $zu(9,"",msg,1 /* broadcast and log message*/,1  /* Warning */)
		   quit 0  ;failure
	   }
	   ;We're the only mirror member, our end must be correct
	   if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","Sole mirror member marking end ("_ourendoff_") of "_jrnfile_" as valid.")
	   s x=$SYSTEM.Mirror.SetMirrorJournalFileEnd(jrnfile,ourendoff,AllowSet)
	   if 'x {
	      d $zu(9,"","Failed to set valid end of file "_jrnfile_" (#"_mirfilecnt_") to "_ourendoff,1 /* broadcast and log message*/,1  /* Warning */)
		  quit 0
	   }
	   s:mirfilecnt>lastvalidfilecnt ^MIRROR(mirname,"lastvalidjrnfile")=mirfilecnt_"^"_jrnfile
	   quit 1  ; success
	}
	s id=""
	for  {
		s id=$O(results(id),1,info)
		quit:id=""
		if $LG(info) {
		   s creguid=$LG(info,4)  ;sysguid of system which created this file
		   if creguid'=sysguid {
			   quit
		   }
		}
	}
	if id'="" {
	   d $zu(9,"","Duplicate primaries detected - System guid mismatch ("_creguid_" v. "_sysguid_") found for file #"_mirfilecnt_" ("_jrnfile_")",1 /* broadcast and log message*/,1  /* Warning */)
	   d $zu(9,"","This member has detected that its data is inconsistent with the mirror "_mirname_". If the primary is running and has the correct mirrored data, this member, including its mirrored databases, must be rebuilt. See 'Rebuilding a Mirror Member' in the Mirroring chapter of documentation for details.",1 /* broadcast and log message*/,2  /* Severe error */)
	   s ^MIRROR(mirname,"Status","MGR")="Exit"  ; to quit the MIRRORMGR routine.
	   quit 0  ;failed
	}
	if 'bestid {
	    if reportingNode {
		   d $zu(9,"","Async member failed to find any copies of file #"_mirfilecnt_" ("_jrnfile_")",1 /* broadcast and log message*/,1  /* Warning */)
		   quit 0  
	    }
	    if lastflag {
	       if sysguid=ourguid {
			  if (dbmaxjrnpos > ourendoff) {
			      s msg="Journal file "_jrnfile_" (#"_mirfilecnt_") ends at "_ourendoff_" but databases are current as of "_dbmaxjrnpos_"."
			      s msg=msg_$C(13,10)_"If the original journal file cannot be recovered, the mirror will need to be rebuilt."
			      d $zu(9,"",msg,1 /* broadcast and log message*/,1  /* Warning */)
			      quit 0  ;failure
			  }
			  s rc=$$GetStatus^MIRRORCTL(mirname,1)
			  if $LG(rc)="PRIMARY" {
				  if +$LG(rc,2)<=mirfilecnt {
					  d $zu(9,"","Local last journal file "_jrnfile_" (#"_mirfilecnt_") exceeds last journal file #"_$LG(rc,2)_" in primary.",1 /* broadcast and log message*/,1  /* Warning */)
					  d $zu(9,"","This member has detected that its data is inconsistent with the mirror "_mirname_". If the primary is running and has the correct mirrored data, this member, including its mirrored databases, must be rebuilt. See 'Rebuilding a Mirror Member' in the Mirroring chapter of documentation for details.",1 /* broadcast and log message*/,2  /* Severe error */)
					  s ^MIRROR(mirname,"Status","MGR")="Exit"  ; to quit the MIRRORMGR routine.
					  quit 0
				  }
				  /* The primary's last file is beyond this member's last file and it does not exist in primary,
				     should we just set valid end to it or error out and let user fix this situation? */
				  d $zu(9,"","SetValidJournalFileEnd: Local last journal file "_jrnfile_" (#"_mirfilecnt_") does not exist in primary.",1 /* broadcast and log message*/,1  /* Warning */)
				  quit 0
			  } elseif (($LG(rc)'="TIMEOUT") && ($LG(rc)'="ERR")),$LG(rc,2) {
				  s fcnt=+$LG(rc,2)
				  if fcnt<mirfilecnt {
					  s fn=$SYSTEM.Mirror.GetJournalFileByMjrncnt(fcnt,mirname)
					  if +fn>0 {
						  s fninfo=$zu(78,22,$p(fn,",",2),99)
						  if +fninfo {
							  s rc=$$GetJournalInfo^MIRRORCTL(mirname,1,3,fcnt)
							  if $LG(rc)="OK"&&(+$LG($LG(rc,2),2)) {
								  if $p($LG($LG(rc,2),2),",",14+1)'=$p(fninfo,",",14+1) {
									  d $zu(9,"","The SYSGUID '"_$p(fninfo,",",14+1)_"' of local journal file "_fcnt_" (#"_$p(fn,",",2)_") mismatched with the file in other failover member '"_$p($LG($LG(rc,2),2),",",14+1)_"'.",1 /* broadcast and log message*/,1  /* Warning */)
									  d $zu(9,"","This member has detected that its data is inconsistent with the mirror "_mirname_". If the primary is running and has the correct mirrored data, this member, including its mirrored databases, must be rebuilt. See 'Rebuilding a Mirror Member' in the Mirroring chapter of documentation for details.",1 /* broadcast and log message*/,2  /* Severe error */)
									  s ^MIRROR(mirname,"Status","MGR")="Exit"  ; to quit the MIRRORMGR routine.
									  quit 0
								  }
							  }
						  }
					  }
				  }
			  }
	          if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","Other node doesn't have file we created. Marking end ("_ourendoff_") of "_jrnfile_" as valid.")
	          s x=$SYSTEM.Mirror.SetMirrorJournalFileEnd(jrnfile,ourendoff,AllowSet)
	          if 'x {
		          d $zu(9,"","Failed to set valid end of "_jrnfile_" to "_ourendoff,1 /* broadcast and log message*/,1  /* Warning */)
		          quit 0  ;failed
	          }
			  s:mirfilecnt>lastvalidfilecnt ^MIRROR(mirname,"lastvalidjrnfile")=mirfilecnt_"^"_jrnfile
	   	      quit 1  ;success
           }
           d $zu(9,"","File #"_mirfilecnt_" ("_jrnfile_") is beyond other node's log file but we did not create it. End not marked valid",1 /* broadcast and log message*/,1  /* Warning */)
		   quit 0       
	    }
	    ; if we have multiple systems we should check all of them before declaring failure
        d $zu(9,"","File #"_mirfilecnt_" ("_jrnfile_") is beyond other node's log file but it is not our last file. End not marked valid",1 /* broadcast and log message*/,1  /* Warning */)
        quit 0
    }
	; bestid '= 0, some system had the journal file
	s info=$G(^SYS("MIRRORSET",mirname,"Member",bestid))
 	s name=$lg(info,1)
    s mtype=+$LG(info,8)  
    ;
	s rc=results(bestid)
	s validflag=$LG(rc,2)
	s endoff=$LG(rc,3)
	if (ourendoff\65536)=(endoff\65536) {
		; save the data blk from GetJournalEnd() since its from the same journal block
		s datablk=$LG(rc,5)  ;$LG(rc,4) is the sysguid
	} else {
		if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","Ignoring datablk from GetJournalEnd, ends are different: "_ourendoff_"/"_endoff)
		s datablk=""
	}
	if validflag=2 {
	   if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","("_mirname_") journal file #"_mirfilecnt_" is the active file on node: "_name)
	   if 'lastflag {
		  if reportingNode {
              if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","Async member found current ""non-last"" file #"_mirfilecnt_" ("_jrnfile_") on "_name)
	          quit 0  
	      }
	      d $zu(9,"","Node file is its current file however this is not our last file. Forcing down the other node.",1 /* broadcast and log message*/,1  /* Warning */)
		  ; Should we really force it down?
		  s rc=$$ForceNodeDown^MIRRORCTL(mirname,bestid,1)
		  s reason=$LG(rc,2)
		  d $zu(9,"","Force status = "_$LG(rc)_$S($L(reason):" ("_reason_")",1:""),0,0  /* Informational message */)
		  quit 0
		}
		if endoff<ourendoff {
			d $zu(9,"","Primary's current journal file #"_mirfilecnt_" offset ("_endoff_") is shorter than current journal file end in local system ("_ourendoff_").",1 /* broadcast and log message*/,1  /* Warning */)
			d $zu(9,"","This member has detected that its data is inconsistent with the mirror "_mirname_". If the primary is running and has the correct mirrored data, this member, including its mirrored databases, must be rebuilt. See 'Rebuilding a Mirror Member' in the Mirroring chapter of documentation for details.",1 /* broadcast and log message*/,2  /* Severe error */)
			s ^MIRROR(mirname,"Status","MGR")="Exit"
			quit 0
		}
		if '$$CompareJournalBlock(mirname,jrnfile,mirfilecnt,bestid,ourendoff,datablk) {
			d $zu(9,"","Journal block content of file #"_mirfilecnt_" endoff: "_ourendoff_" mismatched.",1 /* broadcast and log message*/,1  /* Warning */)
			d $zu(9,"","This member has detected that its data is inconsistent with the mirror "_mirname_". If the primary is running and has the correct mirrored data, this member, including its mirrored databases, must be rebuilt. See 'Rebuilding a Mirror Member' in the Mirroring chapter of documentation for details.",1 /* broadcast and log message*/,2  /* Severe error */)
			s ^MIRROR(mirname,"Status","MGR")="Exit"
			quit 0
		}
		quit 1  ;success
	} 
	if 'validflag,reportingNode {
       d $zu(9,"","Async member failed to find valid copy of file #"_mirfilecnt_" ("_jrnfile_")",1 /* broadcast and log message*/,1  /* Warning */)
	   quit 0  
	}
	; If the other file is larger than ours, retrieve the missing part
	; from the other node.
	if endoff>ourendoff {
		if '$$CompareJournalBlock(mirname,jrnfile,mirfilecnt,bestid,ourendoff,datablk) {
			d $zu(9,"","Journal block content of file #"_mirfilecnt_" endoff: "_ourendoff_" mismatched.",1 /* broadcast and log message*/,1  /* Warning */)
			d $zu(9,"","This member has detected that its data is inconsistent with the mirror "_mirname_". If the primary is running and has the correct mirrored data, this member, including its mirrored databases, must be rebuilt. See 'Rebuilding a Mirror Member' in the Mirroring chapter of documentation for details.",1 /* broadcast and log message*/,2  /* Severe error */)
			s ^MIRROR(mirname,"Status","MGR")="Exit"
			quit 0
		}
	   if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","("_mirname_") For "_jrnfile_" (#"_mirfilecnt_") we have "_ourendoff_" out of "_endoff_" bytes")
	   if '$$RetrieveJournalFile^MIRRORMGR(mirname,mirfilecnt,ourendoff,1,1) {
	      d $zu(9,"","("_mirname_") SetValidJrnFileEnd failed to retrieve end of journal file #"_mirfilecnt,1 /* broadcast and log message*/,1  /* Warning */)
	      quit 0
 	   }
 	   s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(mirfilecnt,mirname)
 	   if +rc'=1 {
	      d $zu(9,"","("_mirname_") SetValidJrnFileEnd failed to lookup name for file #"_mirfilecnt,1 /* broadcast and log message*/,1  /* Warning */)
	      quit 0
 	   }
 	   s jrnfile=$P(rc,",",2)
	   if (dbmaxjrnpos > endoff) {
		   s msg="Journal file "_jrnfile_" (#"_mirfilecnt_") ends at "_endoff_" but databases are current as of "_dbmaxjrnpos_"."
		   if validflag {
			   s msg=msg_$C(13,10)_"This file is marked valid by the other node so it may have been running without some data from our databases."
			   d $zu(9,"",msg,1 /* broadcast and log message*/,1  /* Warning */)
			   d $zu(9,"","This member has detected that its data is inconsistent with the mirror "_mirname_". If the primary is running and has the correct mirrored data, this member, including its mirrored databases, must be rebuilt. See 'Rebuilding a Mirror Member' in the Mirroring chapter of documentation for details.",1 /* broadcast and log message*/,2  /* Severe error */)
			   s ^MIRROR(mirname,"Status","MGR")="Exit"
		   } else {
			   s msg=msg_$C(13,10)_"If the original journal file cannot be recovered, the mirror will need to be rebuilt."
			   d $zu(9,"",msg,1 /* broadcast and log message*/,1  /* Warning */)
		   }
		   quit 0  ;failure
	   }
	   ; Set end as valid across all nodes.
	   if 'validflag {
	      if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","("_mirname_") For "_jrnfile_" (#"_mirfilecnt_") setting "_endoff_" as valid end across all nodes")
	   } else {
	      if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","("_mirname_") For "_jrnfile_" (#"_mirfilecnt_") setting "_endoff_" as valid end")
	   }
	   s x=$SYSTEM.Mirror.SetMirrorJournalFileEnd(jrnfile,endoff,AllowSet)
	   if 'x {
	      d $zu(9,"","Failed to set end of file "_jrnfile_" to "_endoff,1 /* broadcast and log message*/,1  /* Warning */)
	      quit 0
	   }
	   s:mirfilecnt>lastvalidfilecnt ^MIRROR(mirname,"lastvalidjrnfile")=mirfilecnt_"^"_jrnfile
       if 'validflag { ;file wasn't valid before, send it the valid end now
          ; now update the other node's copy of the file.
          s rc=$$SendJournalEndInfo^MIRRORCTL(mirname,bestid,jrnguid,mirfilecnt,endoff)
          s status=$LG(rc)
          if 'status {
	         ; This isn't fatal because our journal file is ok and the other node
	         ; will resolve this issue when it needs this file.
             if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","("_mirname_") Warning: failed seting valid end of journal file: "_jrnfile_" on node "_name_" (err: "_$LG(rc,2)_")")
          }
       }
	   quit 1
	}
	if '$$CompareJournalBlock(mirname,jrnfile,mirfilecnt,bestid,endoff,datablk) {
		d $zu(9,"","Journal block content of file #"_mirfilecnt_" endoff: "_endoff_" mismatched.",1 /* broadcast and log message*/,1  /* Warning */)
		d $zu(9,"","This member has detected that its data is inconsistent with the mirror "_mirname_". If the primary is running and has the correct mirrored data, this member, including its mirrored databases, must be rebuilt. See 'Rebuilding a Mirror Member' in the Mirroring chapter of documentation for details.",1 /* broadcast and log message*/,2  /* Severe error */)
		s ^MIRROR(mirname,"Status","MGR")="Exit"
		quit 0
	}
	if validflag {
	   s validsize=endoff
	   if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"",jrnfile_" from "_name_" is valid, setting validsize to "_validsize_", oursize ="_ourendoff)
	} else {
	   s validsize=ourendoff
	   if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"",jrnfile_" from "_name_" is not valid, setting validsize to "_validsize_", oursize="_ourendoff_", remote size = "_endoff)
	}
	if (dbmaxjrnpos > validsize) {
		s msg="Journal file "_jrnfile_" (#"_mirfilecnt_") ends at "_validsize_" but databases are current as of "_dbmaxjrnpos_"."
		if validflag {
			s msg=msg_$C(13,10)_"This file is marked valid by the other node so it may have been running without some data from our databases."
			d $zu(9,"",msg,1 /* broadcast and log message*/,1  /* Warning */)
			d $zu(9,"","This member has detected that its data is inconsistent with the mirror "_mirname_". If the primary is running and has the correct mirrored data, this member, including its mirrored databases, must be rebuilt. See 'Rebuilding a Mirror Member' in the Mirroring chapter of documentation for details.",1 /* broadcast and log message*/,2  /* Severe error */)
			s ^MIRROR(mirname,"Status","MGR")="Exit"
		} else {
			s msg=msg_$C(13,10)_"If the original journal file cannot be recovered, the mirror will need to be rebuilt."
			d $zu(9,"",msg,1 /* broadcast and log message*/,1  /* Warning */)
		}
		quit 0  ;failure
	}
	s rc=$SYSTEM.Mirror.SetMirrorJournalFileEnd(jrnfile,validsize,AllowSet)
	if 'rc {
	   d $zu(9,"","Failed to set end of file "_jrnfile_" to "_validsize,1 /* broadcast and log message*/,1  /* Warning */)
	   quit 0
    }
	s:mirfilecnt>lastvalidfilecnt ^MIRROR(mirname,"lastvalidjrnfile")=mirfilecnt_"^"_jrnfile
    if 'validflag,endoff=validsize {
       s rc=$$SendJournalEndInfo^MIRRORCTL(mirname,bestid,jrnguid,mirfilecnt,validsize)
       s status=$LG(rc)
       if 'status {
          d $zu(9,"","("_mirname_") Warning: failed seting valid end of journal file: "_jrnfile_" on node "_name_" (err: "_$LG(rc,2)_")",1 /* broadcast and log message*/,1  /* Warning */)
       }
    }
    quit 1
err ;
	d $zu(9,"","Unexpected error: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	d BACK^%ETN
	quit 0
}
GetMirroredDBList(mirname="",List,mflag=0) PUBLIC {
	s $zt="err"
	if 'mflag goto NotMounted
	s found=0
	s foundactive=0
	s mirdbinfo=$SYSTEM.Mirror.GetNextDBBySFN(-1,mirname)
	while (+mirdbinfo'=-1) {
	   s dbname=$P(mirdbinfo,"^",3)
	   s dbsfn=+$P(mirdbinfo,"^",4)
	   if dbsfn&&(dbsfn'=$ZU(40,0,41)) {
	      s info=$SYSTEM.Mirror.DBGetInfo(0,dbsfn)
	      if info'="" {
		     s List(dbname)=info,found=1
	   		 if $P(info,"^",20) s foundactive=1
	      } else {
		     ; see if database is dismounted
		     s sfn=$ZU(49,dbname)
		     if +sfn'=-1 {
			   s err="Failed to read Mirror DBInfo for database "_dbsfn
		   	   goto fail
		     }
	      }
	   }
	   s mirdbinfo=$SYSTEM.Mirror.GetNextDBBySFN(+mirdbinfo,mirname)
	}
	if found||(mflag=2) quit $LB(1+foundactive)
NotMounted ;
	/* If there is no mounted mirrored DB found then we need to look
	   through the ^SYS("UCI") to look all the dismounted mirrored DB. */
	s dir=""
 	s mirrorbit=+$ZU(40,8,28)
	for  {
		s dir=$$GetNextDatabaseByUCI^%SYS.CONFIG(dir)
		q:dir=""
		s info=$ZU(49,dir)
		continue:(+info<-1)  ;doesn't exist, can't be read
 	    s dbattrib=+$p(info,",",17)  ;even when not mounted, $ZU(49) data is returned
	    ;skip this db if its not marked as mirrored
 	    continue:($zb(+dbattrib,+mirrorbit,1)=0) ;'$$$isMirroredDb
 	    s info=$SYSTEM.Mirror.DBGetInfoByName(0,dir)
 	    if info="DOWN" {
	 	   	s err="Failed to read Mirror DBInfo for database "_dir_" encrypted"
	 	   	goto fail
 	    }
        continue:((info="") || (mirname'="" && (mirname'=$P(info,"^",8))))
        s List(dir)=info
	}
	quit $LB(1) ;succeeded.
err ;
	quit $LB(0,$ZE)	
fail ;
    quit $LB(0,err)	
}
 /*	Restarts the DejournalReader after we moved a journal file because the disk was full
 	Returns 1 = success
		    0 = failure
 */
RestartDejrn(dejrnstate,oldpath,newpath) PUBLIC {
	;JO2363+
	if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","RestartJrn("""_dejrnstate_""","""_oldpath_""","""_newpath_""")")
	if +dejrnstate=0 {
		; Dejournaling wasn't running before, don't start it now
		quit 1
	}
	set mirname=$p(dejrnstate,",",2)
	set mirfilecnt=$p(dejrnstate,",",3)
	set jrnpos=$p(dejrnstate,",",4)
	if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","restartjrn: mirname="_mirname_", mirfilecnt="_mirfilecnt_", jrnpos="_jrnpos)
	if ('mirfilecnt) {
		s tmp=^MIRROR(mirname,"dejrnchkpnt")
		set mirfilecnt=$p(tmp,"^",1)
		set jrnpos=$p(tmp,"^",2)
		if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","restartjrn: mirfilecnt="_mirfilecnt_", jrnpos="_jrnpos)
	}
	s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(mirfilecnt,mirname)
	if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","restartjrn: lookup jrnfile result = /"_rc_"/")
	if rc<=0 {
		// Shouldn't get here!!
		d $zu(9,"","("_mirname_") RestartDejrn failed to read log info for file #"_mirfilecnt,1 /* broadcast and log message*/,1  /* Warning */)
		Quit 0	// unexpected and unrecoverable error force the connection down
	}
	s jrnfname=$P(rc,",",2)
	// Restart from the new location
	if (jrnfname = oldpath) {
		if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","oops: jrn.log has incorrect entry, exp("_newpath_") logentry("_jrnfname_"), file num-"_mirfilecnt)
		s jrnfname=newpath 
	}
	if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"",mirname_": Restart dejournaling: "_mirname_" f("_jrnfname_"), fnum("_mirfilecnt_"),pos("_jrnpos_")")
	if '$$StartDejournal("Restart Dejrn",mirname,jrnfname,mirfilecnt,jrnpos,$SYSTEM.Mirror.MirrorNameToIndex(mirname,1)+1) {
		d $zu(9,"","Failed to restart dejournaling job at: "_jrnfname_","_jrnpos,1 /* broadcast and log message*/,1  /* Warning */)
		Quit 0	// unexpected and unrecoverable error force the connection down
	}
	Quit 1
}
 /*	Returns 1 = success
		    0 = failure
 */
UpdateMirrorJournalLog(mirrorname,oldpath,newpath) Private {
	s tmplogf=""
	s miridx=$SYSTEM.Mirror.MirrorNameToIndex(mirrorname,0)
	i miridx<0 {
		d $zu(9,"","("_mirrorname_") mirror info structure could not be found.",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	s miridx=miridx+1
	try {
	   do $zu(78,79,1,1,miridx)
	   do $zu(78,79,2,1,miridx)
	   set dejrnstate=$system.Mirror.DejournalStop()
	   d ##class(%Library.File).Delete(oldpath)
	   s logf=$zu(12)_"mirrorjrn-"_mirrorname_".log"
	   // bld the temp mirror log file name
	   s tmplogf=$zu(12)_"mirrorjrn-"_mirrorname_"-"_+$J_".tmp"
	   // Save the mirror log file in case it failed.
	   do ##class(%Library.File).CopyFile(logf,tmplogf,1)
	   s filecopied=1
	   s rc=##class(SYS.Mirror).BuildJournalLog(mirrorname,,,,,1)
	   if ('rc) {
		   d $zu(9,"","UpdateMirrorJournalLog: Failed to rebuild mirror journal log file. Error: "_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
		   do ##class(%Library.File).CopyFile(tmplogf,logf,1)
		   do ##class(%Library.File).Delete(tmplogf)
		   do ##class(%Library.File).CopyFile(newpath,oldpath,1)
		   goto fail
	   }
	   d ##class(%Library.File).Delete(tmplogf)
	} catch excv {
		d $zu(9,"","Caught error: "_excv.Name_excv.Location_" updating journal log",1 /* broadcast and log message*/,1  /* Warning */)
		do ##class(%Library.File).CopyFile(newpath,oldpath,1)
		if $g(filecopied) do ##class(%Library.File).CopyFile(tmplogf,logf,1)
		if $g(tmplogf)'="" do ##class(%Library.File).Delete(tmplogf)
	    goto fail		 
	}
    do $zu(78,79,1,0,miridx)
    do $zu(78,79,2,0,miridx)
	if ($E(oldpath,*)="z") && ($E(newpath,*)="z") {
		s oldpath=$E(oldpath,1,*-1)
		s newpath=$E(newpath,1,*-1)
	}
	try {
	   s x=$$RestartDejrn(dejrnstate,oldpath,newpath)
	} catch excv {
	   d $zu(9,"","Caught error: "_excv.Name_excv.Location_" restarting journaling",1 /* broadcast and log message*/,2  /* Severe error */)
	   s x=0
	}
	if 'x {
		d $zu(9,"","Failed to restart dejournal jobs after moving journal file",1 /* broadcast and log message*/,2  /* Severe error */)
	}
	Quit 1  ;delete original file, log is updated with new copy
fail
	do $zu(78,79,1,0,miridx)
	do $zu(78,79,2,0,miridx)
	s x=$$RestartDejrn(dejrnstate,"","")
	quit 0  ;caller will delete the new file it created, log still contains old copy
}
MoveMirrorJournal(args) PUBLIC {
    try {
	   	// client failed to save the received journal, switch to the alternate dir
	   	// the args are:
	   	//    <original journal file>,<alternate journal dir>,
	   	//				<journal file name>,<mirror name>,<target file size>
	   	// returns "1" on success
		set rc=0
		s orig=$p(args,",",1)
		s alt=$p(args,",",2)
		s fname=alt_$p(args,",",3)
		s mirrorname=$p(args,",",4)
		s targsize=+$P(args,",",5)  
		s jrnsize=$zu(140,1,orig)
		; Use the larger of the current file size or the target file size.
		; The target filesize is sometimes omitted which is why we don't
		; simply always use it.
		if jrnsize<targsize {
			s jrnsize = targsize
		}	
		d $zu(9,"","MoveMirrorJournal("_mirrorname_"): attempting to move "_jrnsize_" bytes from ("_orig_") to ("_fname_")",0,0  /* Informational message */)
		if (jrnsize < 0) goto jrnswfailed
		// Chk if the alternate file doesn't exist
		if ($zu(140,1,fname) > 0) {
			// alt journal already exists!!
			d $zu(9,"","MoveMirrorJournal: Alternate journal file already exists "_fname,1 /* broadcast and log message*/,1  /* Warning */)
			goto jrnswfailed
		}
		// Validate the alternate FS has enough space
		s fssz=$zu(140,13,alt)
		if (((+fssz)*$p(fssz,",",4)) <= jrnsize) {
			d:($zu(140,1,fname)=0) $ZU(140,5,fname) ; remove the zero len failed copy
			d $zu(9,"","MoveMirrorJournal: Alternate journal directory is not big enough - "_alt,1 /* broadcast and log message*/,1  /* Warning */)
			goto jrnswfailed
		}
		// Copy the journal file from the source to alt
		s rc=$zu(140,11,orig,fname)
		if (rc '= 0) {
			// failed to copy
			d $zu(9,"","MoveMirrorJournal: failed (rc="_rc_") to create the alternate journal - "_fname_" from "_orig,1 /* broadcast and log message*/,1  /* Warning */)
		    s delrc=$ZU(140,5,fname) ;; remove the failed copy
			if delrc'=0 {
			   d $zu(9,"","MoveMirrorJournal: Error code "_delrc_" removing the failed copy "_fname,1 /* broadcast and log message*/,1  /* Warning */)
			}
			s rc=0
			goto jrnswfailed
		}
		s jrnfilecopied=1
		// Update the mirror jrn log
		s rc=$$UpdateMirrorJournalLog(mirrorname,orig,fname)
		if (rc = 1) {
			s delrc=$ZU(140,5,orig) ; remove the original
		} else {
			;#if we fail to update the mirror journal log then we must remove
			;#the copy we created
			s delrc=$ZU(140,5,fname) ; remove the original
			if delrc'=0 {
			   d $zu(9,"","MoveMirrorJournal: Error code "_delrc_" removing the original mirror journal file: "_orig_" - Ignored",1 /* broadcast and log message*/,1  /* Warning */)
			}
		}
    } catch err {
		d:$G(jrnfilecopied)||($zu(140,1,fname)=0) $ZU(140,5,fname) ;; remove the zero len failed copy
		d $zu(9,"","MoveMirrorJournal: unexpected error - "_err.Name_" at "_err.Location_"("_err.Data_")",1 /* broadcast and log message*/,1  /* Warning */)
	    s rc=0  ;signal an error
    }
jrnswfailed ;	
    quit rc_""
}
CheckMirrorDBName(mirdbname,uppercase = 1) PUBLIC {
	s $zt="errhnd"
	s mname=$ZCVT($P(mirdbname,":",3),"U")  ;mirror names are uppercase
	s dbname=$P(mirdbname,":",4)
	s rc=$$GetMirroredDBList^MIRRORCOMM(mname,.dblist,0)
	if '$LG(rc) {
		d $zu(9,"","CheckMirrorDBName: "_$LG(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
		s errmsg=$LG(rc,2)
		goto fail
	}
	s dir=$o(dblist(""),1,infostr)
	while dir'="" {
		s dirdbname=$P(infostr,"^",2)
		s dirmname=$P(infostr,"^",8)
		if dirmname=mname,$s(uppercase:$ZCVT(dirdbname,"U")=$ZCVT(dbname,"U"),1:dirdbname=dbname) {
			s path=$P(infostr,"^",1)
			s zu49info=$ZU(49,path)
			goto found
		}
		s dir=$o(dblist(dir),1,infostr)
	}
	quit $LB("NOTFOUND")
found ;
	quit $LB("FOUND",dir,infostr,zu49info)
errhnd ;
	s $zt=""
	s errmsg="Caught error: "_$ze
fail ;
	quit $LB("ERR",errmsg)	   
}
	/* Called from CheckForExtraJournalFiles^MIRRORMGR when we find that 
	   there are journal files in the journal directory(ies) which follow
	   the files in the log. Here we add them to the end of the log.
	   This is here (in MIRRORCOMM) because the other routines which
	   manipulate the journal log are here and it seemed best to keep
	   things together.
	   newfiles(<jrnfilecnt>)=<long journal file name> is the list of
	   journal files to add to the log for 'mirname' and we already know
	   that they:
	   a) belong to this mirror (mirror guid matches)
	   b) follow the files in the existing log although we double check
	      this after acquiring the write lock on the log file
	   Returns: 0 - failure
	            1 - success
	*/
AddNewFilesToJournalLog(mirname,newfiles) PUBLIC {
	s $zt="Error"
	s miridx=$SYSTEM.Mirror.MirrorNameToIndex(mirname,0)
	i miridx<0 s miridx=0
	s miridx=miridx+1
	do $zu(78,79,1,1,miridx)
	do $zu(78,79,2,1,miridx)
	s filelocked=1
    s jcnt=$o(newfiles(""),1,file)
    s lastfcnt=+$SYSTEM.Mirror.GetLastJournalFilename(mirname)
    i lastfcnt>0&&(lastfcnt+1'=jcnt) {
	    d $zu(9,"","AddNewFilesToJournalLog expected first file cnt "_(lastfcnt+1)_" got "_jcnt,1 /* broadcast and log message*/,2  /* Severe error */)
	    goto failed
    }
	s LogFile=$zu(12)_"mirrorjrn-"_mirname_".log"
    s rc=$zu(78,85,LogFile,miridx) 
    i rc<1 {
	    d $zu(9,"","AddNewFilesToJournalLog failed to open mirror log file "_LogFile,1 /* broadcast and log message*/,2  /* Severe error */)
	    goto failed
    }
    s fileopened=1
    s FileIndex=""
    f  {
	    s FileIndex=$o(newfiles(FileIndex),1,JrnFile)
	    i FileIndex="" q
	    s rc=$zu(78,86,JrnFile,miridx)
	    i rc<0 {
		    d $zu(9,"","AddNewFilesToJournalLog: "_JrnFile_" doesn't exist or is not a journal file, rc="_rc,1 /* broadcast and log message*/,2  /* Severe error */)
		    quit
	    } elseif 'rc {
		    d $zu(9,"","AddNewFilesToJournalLog: Failed to update the log with an entry about "_JrnFile,1 /* broadcast and log message*/,2  /* Severe error */)
		    quit
	    }
    }
    do $zu(78,87,miridx)
    s fileopened=0
    ; Success!
	do $zu(78,79,1,0,miridx)
	do $zu(78,79,2,0,miridx)
    q rc=1 
Error ;
	s $zt=""
	d $zu(9,"","AddNewFilesToJournalLog Unexpected error: "_$ze,1 /* broadcast and log message*/,2  /* Severe error */)
failed ;
	if $g(fileopened) do $zu(78,87,miridx)
	if $g(filelocked) {
		do $zu(78,79,1,0,miridx)
		do $zu(78,79,2,0,miridx)
	}
	quit 0  ;failed
}
BuildMirrorLogFromJournalFiles(mirname,mirjcnt=0,loc="") PUBLIC {
	/* Create mirror journal log file for a mirror set from the mirror journal
	   files located in a specific set of locations. This is called when
	   the mirror journal log doesn't exist, it appears to be corrupted (can't
	   be read) or the guid in the file doesn't match the local 
	   system. Any existing file has been deleted and here we create
	   a new one.
	   mirname is the mirror set name of the mirror journal files.
	   mirjcnt is the starting journal count for the range, 0 means all.
	   loc is a $list() of the directory(ies) containing the mirror journal files.
	   Before this is called, make sure this mirror journal log file does not exist.
	   Return -1,error The error could be:
	                  The mirror journal log already existed.
	                  Failed to access mirror log file.
	                  One of the mirror journal file has different mirror set GUID.
	                  The journal files are not contiguous with journal count.
	                  Problem reading a journal file
	   Return n>=0 if we built the mirror log file. The log file could be empty if
	   			there are no matching journal files. 'n' is the count of the # of
	   			files we found
	*/
	/* Look through the directory and find all the mirror journal file
	   for the specific mirror set and find its journal count and sort it.
	*/
	s rc=##class(SYS.Mirror).BuildJournalLog(mirname,mirjcnt,loc,.filecnt,1)
	if '('rc) quit filecnt
	quit "-1,"_$SYSTEM.Status.GetErrorText(rc)
}
 /* The Retrieve Daemon is to retrieve journal files from 'id' member,
 	mirname is the mirror set name of the mirror journal files.
 	mirjcnt is the starting journal count to retrieve.
 	endjcnt is the endinging journal count to retrieve.
 	id is the member to retrieve file from.
 	ValidEndRequired must be set to 1 if this is an async member connecting
	to a failover member and we're not connecting to the primary.
 */
CatchupRetrieveDMN(mirname,mirjcnt,endjcnt,id,ValidEndRequired) PUBLIC {
	L +^MIRROR(mirname,"CatchupRetrieveFiles"):0
	q:$T
	s ^MIRROR(mirname,"CatchupRetrieveDMNID")=+$J_","_$ZU(61)_","_$ZU(61,30,$ZU(61))
	For jcnt=mirjcnt:1:endjcnt Lock +^MIRROR(mirname,"CatchupFiles",jcnt)
	s Startid=$p(id,"^",2),systemcnt=$p(id,"^",3),JrnFiles=1
	For id=Startid:1:systemcnt {
		s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
		s name=$lg(info,1)
		For jcnt=mirjcnt:1:endjcnt {
			s rc=$$GetMissingJournalFiles^MIRRORCTL(mirname,id,jcnt,0,jcnt,.JrnFiles,ValidEndRequired)
			s status=$LG(rc)
			if status="OK" {
				if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("40"),1) do $zu(9,"","CatchupRetrieveDMN ("_mirname_") Retrieved journal file #"_jcnt_" from "_name)
				s ^MIRROR(mirname,"CatchupFiles",jcnt)=$p(JrnFiles(jcnt),",")
				k JrnFiles(jcnt)
				Lock -^MIRROR(mirname,"CatchupFiles",jcnt)
				L +^MIRROR(mirname,"CatchupRetrieveFiles"):0
				If $T goto Exit
			} else {
				s errlist(name)=$LB(jnt,$LG(rc,2))  ;record reason in case we never find a copy of this file
				s mirjcnt=jcnt
				q
			}
		}
		q:status="OK"
	}
    if status'="OK" {
	    s name=$O(errlist(""),1,rc)
	    while (name'="") {
		    d $zu(9,"","CatchupRetrieveDMN ("_mirname_") Failed to retrieve journal file #"_$LG(rc)_" from "_name_": "_$LG(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
		    s name=$O(errlist(name),1,rc)
	    }
	    Quit
    }
	if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("40"),1) do $zu(9,"","CatchupRetrieveDMN ("_mirname_") finished retrieving, exiting.")
	L +^MIRROR(mirname,"CatchupRetrieveFiles")
	L -^MIRROR(mirname,"CatchupRetrieveFiles")
	k ^MIRROR(mirname,"CatchupRetrieveDMNID")
	if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("40"),1) do $zu(9,"","CatchupRetrieveDMN ("_mirname_") exited.")
	Quit
Exit ;
	Lock   ; unlock all nodes.
	k ^MIRROR(mirname,"CatchupRetrieveDMNID")
	if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("40"),1) do $zu(9,"","CatchupRetrieveDMN ("_mirname_") exited.")
	Quit
}
CatchupGetJournalFiles(mirname,mirjcnt) PUBLIC {
	/* Called from CatchupDB by mirror member to get all the missing journal files.
	   This could be called only when the mirjcnt is less than the first
	   entry in mirror log. This function rretrieves first file then return.
	   If there are more files to be retrieved, it starts CatchupRetrieveDMN
	   to retrieve rest of the files.
	   The ^MIRROR(mirname,"CatchupRetrieveFiles") is locked before entering this function.
	   mirname is the mirror set name of the mirror journal files.
	   mirjcnt is the starting journal count for the range.
	   Return 0,error text : Failed.
	   Return -1 : First file is retrieved but failed to start daemon.
	   Return 1,EndFileCount,FirstFileName,DaemonPID : Retrieve Daemon is started.
	*/
	s JrnFile="",omirjcnt=mirjcnt
	if $d(^MIRROR(mirname,"CatchupFiles")) {
		s jcnt=$o(^MIRROR(mirname,"CatchupFiles",""),1,jf)
		while jcnt'=""&&(jcnt<mirjcnt) {
			do $ZU(78,23,jf)
			k ^MIRROR(mirname,"CatchupFiles",jcnt)
			s jcnt=$o(^MIRROR(mirname,"CatchupFiles",jcnt),1,jf)
		}
		if jcnt>mirjcnt {
			do {
				do $ZU(78,23,jf)
				s jcnt=$o(^MIRROR(mirname,"CatchupFiles",jcnt),1,jf)
			} while jcnt'=""
			k ^MIRROR(mirname,"CatchupFiles")
		} elseif jcnt'="" {
			do {
				q:'$ZU(78,22,jf)  ; File is not retrieved yet.
				q:'$$getMirJrnEnd^MIRRORMGR(jf)
				s:JrnFile="" JrnFile=jf  ; record the first requesting file which was retriueved before.
				s jcnt=$o(^MIRROR(mirname,"CatchupFiles",jcnt),1,jf)
			} while jcnt'=""
			if jcnt'="" {
				s mirjcnt=jcnt
				do {
					d $ZU(78,23,jf)  ; this should not happen , but remove it in case it existed.
					k ^MIRROR(mirname,"CatchupFiles",jcnt)
					s jcnt=$o(^MIRROR(mirname,"CatchupFiles",jcnt),1,jf)
				} while jcnt'=""
			} else {
				s mirjcnt=$o(^MIRROR(mirname,"CatchupFiles",""),-1)+1
			}
		}
	}
	s getf=$s(JrnFile="":1,1:2)
	s rc=$$GetJournalFiles(mirname,mirjcnt,.getf)
	if 'rc q rc
	s endjcnt=$p(rc,",",2)
	s ValidEndRequired=$p(rc,",",3)
	s id=$p(rc,",",4)
	if '$increment(getf,-1) {
		s JrnFile=$p(rc,",",5)
	    s ^MIRROR(mirname,"CatchupFiles",mirjcnt)=JrnFile
	}
    if endjcnt>(mirjcnt-getf) {
	    Job CatchupRetrieveDMN(mirname,mirjcnt+1-getf,endjcnt,id,ValidEndRequired)::5
	    if '$T q -1
	    s child=+$zchild
	    if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("40"),1) do $zu(9,"","Catchup: RetrieveDaemon("_child_") is started, range is ("_(mirjcnt+1-getf)_","_endjcnt_"), retrieved file is "_omirjcnt)
    }
    q "1,"_endjcnt_","_JrnFile_","_$g(child)
errret ;	
	k JrnFile
	quit "0,"_errstr
}
 /* Called by CatchupDB job to rebuild the mirror log file after all
    journal files have been retrieved from primary by RetrieveDaemon.
    The files retrieved by RetrieveDaemon are stored in ^MIRROR(mirname,"CatchupFiles")
    array. We need to get merge this list with the existing journal files
    in mirror log to rebuild a new mirror log.
 */
CatchupRebuildMirrorLog(mirname) PUBLIC {
	s OrigStorage=$ZSTORAGE
	s $ZSTORAGE=2147483647
	s miridx=$SYSTEM.Mirror.MirrorNameToIndex(mirname,0)+1
	merge JrnFiles=^MIRROR(mirname,"CatchupFiles")
	s lastfile=$o(JrnFiles(""),-1)
	if lastfile="" q "0,no retrievd file found" g errret
	/* Read the 1st journal file out of the log */
	s logf=$zu(12)_"mirrorjrn-"_mirname_".log"
	s checksum=$zu(78,83,logf,miridx)
	if checksum=-1 {
		s rc=##class(SYS.Mirror).BuildJournalLog(mirname,0,"",,1)
		if ('rc) s errstr=$SYSTEM.Status.GetErrorText(rc) g errret
	}
	/* Lock file so we can read it */
	do $zu(78,79,0,1,miridx)
	s rlocked=1
	if '$ZU(78,22,logf) s errstr="File does not exist" g failedR
	o logf:"RSK\UTF8\"
	s rc=##class(%SYS.Journal.History).GetHeader(logf,.header,1)
	i 'rc s errstr="Failed to get header" g failedR
	s zusav=$zu(68,40,1)
	f  {
		use logf 
		read line
		q:$zeof
		if $p(line,",",2)<=lastfile continue
		if +$zu(78,22,$p(line,",",1),99)'=1 {
			s errstr="file #"_$p(line,",",2)_" was purged while retrieve daemon was get files"
			g failedR
		}
		s JrnFiles($p(line,",",2))=line
	}
	c logf
	d $zu(68,40,zusav)
	do $zu(78,79,0,0,miridx)
	s rc=$$RebuildMirrorLogWithFiles(mirname,.JrnFiles)
	k JrnFiles
	s $ZSTORAGE=OrigStorage
	if rc k ^MIRROR(mirname,"CatchupFiles")
	q rc
failedR ;
	do $zu(78,79,0,0,miridx)
errret ;
	s $ZSTORAGE=OrigStorage
	q "0,"_errstr
}
 /* GetJournalFiles: Find the last journal file we need to retrieve from failover
    members.
	   mirname is the mirror set name of the mirror journal files.
	   mirjcnt is the starting journal count we want to retrieve.
	   CurrentFiles is an array to accommadate all the files for
	       rebuilding the mirror log. The files includes existing journal files
	       and retrieved journal files from failover member.
	       When CurrentFiles is set to 0, we want the CurrentFiles to include
	       all existing files and retrieved files.
	       When it is set to 1 then we don't need it to return existing files,
	       we only need this function to retrieve the first file (mirjcnt), and
	       the last file needs to be retrieved. But if CurrentFiles is set to 2
	       then we don't need to retrieve the first file becasue the first file
	       is not the first requesting file in caller, the retrieve daemon will
	       start retrieving the fist file.
	       The return value is:
	       1,LastFileCount,ValidEndRequired,id^Startid^systemcnt,File name of the first file.
 */
GetJournalFiles(mirname,mirjcnt,CurrentFiles) {
	s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
	if 'systemcnt {
		quit "0,"_"("_mirname_") Can't retrieve journal files - no other failover mirror members"
	}
	s miridx=$SYSTEM.Mirror.MirrorNameToIndex(mirname,0)
	i miridx<0 {
		quit "0,"_"("_mirname_") mirror info structure could not be found."
	}
	s miridx=miridx+1
	/* Read the 1st journal file out of the log */
	s logf=$zu(12)_"mirrorjrn-"_mirname_".log"
	s checksum=$zu(78,83,logf,miridx)
	if checksum=-1 {
		s rc=##class(SYS.Mirror).BuildJournalLog(mirname,0,"",,1)
		if ('rc) s errstr=$SYSTEM.Status.GetErrorText(rc) g errret
	}
	/* Lock file so we can read it */
	do $zu(78,79,0,1,miridx)
	s rlocked=1
	if '$ZU(78,22,logf) s errstr="File does not exist" g failedR
	o logf:"RSK\UTF8\"
	s rc=##class(%SYS.Journal.History).GetHeader(logf,.header,1)
	i 'rc s errstr="Failed to get header" g failedR
	s first=0  ; the first existing file has not been found yet.
	s zusav=$zu(68,40,1)
	f  {
		use logf 
		read line
		q:$zeof
		if first||+$zu(78,22,$p(line,",",1),99)=1 {
			if '$G(CurrentFiles) {
				s CurrentFiles($p(line,",",2))=line
				s first=1
			} else {
				if $p(line,",",2)<mirjcnt continue
				s first=$p(line,",",2)
				Quit
			}
		}
	}
	c logf
	d $zu(68,40,zusav)
	do $zu(78,79,0,0,miridx)
	s rlocked=0
	s:'$G(CurrentFiles) first=$o(CurrentFiles(""))
	i +first&&(mirjcnt'<first) s errstr="File count ("_mirjcnt_") is greater than first ("_+first_") in log" g errret
	s $zt="err"
	s status="",JrnFiles=1
	k errlist
	s ValidEndRequired=0,Startid=1
	if systemcnt>1&&(+$G(^SYS("MIRRORSET"))) {
		s primaryid=$$GetCurrentPrimaryID^MIRRORMGR(mirname)
		if primaryid<0 {
			Set ValidEndRequired=1
		} else {
			s (Startid,systemcnt)=primaryid
		}
	}
    for id=Startid:1:systemcnt {
	   s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
       if info'="" {
	      s name=$lg(info,1)
          if first="" {
			  s rc=$$GetStatus^MIRRORCTL(mirname,id)
			  s status=$LG(rc)
		      s endjcnt=$s(status'["ERR":+$LG(rc,2),1:0)
		      if mirjcnt>endjcnt {
				  d $zu(9,"","GetJournalFiles ("_mirname_") GetLastJrnFile Failed, mirjcnt="_mirjcnt_" rc="_$LG(rc,3),1 /* broadcast and log message*/,1  /* Warning */)
			      s status="ERR"
			      continue
		      }
          } else {
	          s endjcnt=first-1
          }
          if $G(CurrentFiles)=2 s status="OK",JrnFiles(mirjcnt)="" quit
	      s rc=$$GetMissingJournalFiles^MIRRORCTL(mirname,id,mirjcnt,0,$s('$G(CurrentFiles):endjcnt,1:mirjcnt),.JrnFiles,ValidEndRequired)
	      s status=$LG(rc)
	      if status="OK" {
		      if '$G(CurrentFiles) {
		          if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","GetJournalFiles ("_mirname_") Retrieved journal file #"_mirjcnt_","_endjcnt_" from "_name)
		      } else {
		          if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","GetJournalFiles ("_mirname_") Retrieved journal file #"_mirjcnt_" from "_name)
		      }
		      quit  ; we succeeded
	      }
	      s errlist(name)=$LG(rc,2)  ;record reason in case we never find a copy of this file
       }
    }
    if status'="OK" {
	    s name=$O(errlist(""),1,rc)
	    while (name'="") {
		    if '$G(CurrentFiles) {
			    d $zu(9,"","GetJournalFiles ("_mirname_") Failed to retrieve journal file #"_mirjcnt_","_endjcnt_" from "_name_": "_rc,1 /* broadcast and log message*/,1  /* Warning */)
		    } else {
			    d $zu(9,"","GetJournalFiles ("_mirname_") Failed to retrieve journal file #"_mirjcnt_" from "_name_": "_rc,1 /* broadcast and log message*/,1  /* Warning */)
		    }
	      s name=$O(errlist(name),1,rc)
	    }
	    s errstr="Failed to retrieve journal file #"_mirjcnt 
	    g errret
    }
    if '$G(CurrentFiles) {
	    merge CurrentFiles=JrnFiles
	    kill JrnFiles
	    quit 1
    }
    quit "1,"_endjcnt_","_ValidEndRequired_","_id_"^"_Startid_"^"_systemcnt_","_$p(JrnFiles(mirjcnt),",")
err ;
	d $zu(9,"","Unexpected error: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	d BACK^%ETN
	s errstr=$ZE
	i '$g(rlocked) goto errret
failedR ;
	do $zu(78,79,0,0,miridx)
errret ;
	q "0,"_errstr
}
 /* RebuildMirrorLogWithFiles: Rebuild mirror journal log file with
    files in an array.
	   mirname is the mirror set name of the mirror journal files.
	   JrnFiles is array of files to build the mirorr log.
 */
RebuildMirrorLogWithFiles(mirname,JrnFiles) {
	s tmplog=$zu(12)_"mirrorjrn-"_mirname_"."_$J
	s logf=$zu(12)_"mirrorjrn-"_mirname_".log"
	s $zt="err"
	do $zu(140,5,tmplog)
	s rc=##class(SYS.Mirror).BuildJournalLogWithFiles(mirname,tmplog,.JrnFiles)
	s lastfilecnt=$o(JrnFiles(""),-1)
	k JrnFiles
	if ('rc) quit "0,"_$SYSTEM.Status.GetErrorText(rc)
	s miridx=$SYSTEM.Mirror.MirrorNameToIndex(mirname,0)+1
	; now delete the old log and rename our temporary log file and we're done
	do $zu(78,79,1,1,miridx)
	do $zu(78,79,2,1,miridx)
	s rwlocked=1
	o logf:"RSK\UTF8\"
	s rc=##class(%SYS.Journal.History).GetHeader(logf,.header,1)
	i +rc {
		s zusav=$zu(68,40,1)
		f  {
			use logf 
			read line
			q:$zeof
			s x=$p(line,",",2)
			if x>lastfilecnt s CurrentFiles(x)=$p(line,",",1)
		}
		d $zu(68,40,zusav)
		c logf
		if $d(CurrentFiles) {
			s rc=$zu(78,85,tmplog,miridx) 
			i rc<1 {
				d $zu(9,"","("_mirname_") RebuildMirrorLogWithFiles: can't open temp file "_tmplog_" to apend new entries",1 /* broadcast and log message*/,1  /* Warning */)
			} else {
				s FileIndex="",PrevIndex=""
				f  {
					s FileIndex=$o(CurrentFiles(FileIndex),1,JrnFile)
					i FileIndex="" q
					s rc=$zu(78,86,JrnFile,miridx)
					i rc<0 {
						d $zu(9,"","("_mirname_") RebuildMirrorLogWithFiles: "_JrnFile_" doesn't exist to be appended to "_tmplog_" file.",1 /* broadcast and log message*/,1  /* Warning */)
					} elseif 'rc {
						d $zu(9,"","("_mirname_") RebuildMirrorLogWithFiles: Failed to update the "_tmplog_" log with an entry about "_JrnFile,1 /* broadcast and log message*/,1  /* Warning */)
					} else {
						d $zu(9,"","("_mirname_") RebuildMirrorLogWithFiles: "_JrnFile_" is appended after rebuilt",0,0  /* Informational message */)
					}
				}
				i $zu(78,87,miridx)
			}
		}
	} else {
		c logf
	}
	s rc=$zu(140,5,logf) ;delete the original
  	i rc<0 {
    	s errstr="Error ("_rc_") deleting old log file "_logf
    	goto failed
	}
    s rc=$zu(140,6,tmplog,logf) ;rename the temp one to original
    i rc<0 {
	  s errstr="Error "_rc_" renaming /"_tmplog_"/ to /"_logf_"/"
      d $zu(9,"","RebuildMirrorLogWithFiles: "_errstr,1 /* broadcast and log message*/,1  /* Warning */)
      g failed
    }
    ; Success!
	do $zu(78,79,1,0,miridx)
	do $zu(78,79,2,0,miridx)
    q 1 
err ;
	k JrnFiles ;in case we got a <STORE> error
	d $zu(9,"","Unexpected error: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	d BACK^%ETN
	s errstr=$ZE
	i '$g(rwlocked) goto errret
failed ;
	do $zu(78,79,1,0,miridx)
	do $zu(78,79,2,0,miridx)
errret ;	
	k JrnFiles
	if tmplog'="" {
		s rc=$zu(140,5,tmplog)
		if 'rc {
			d $zu(9,"","RebuildMirrorLogWithFiles: Error deleting temporary log file /"_tmplog_"/ cleaning up from error: "_errstr,1 /* broadcast and log message*/,1  /* Warning */)
		}
		s tmplog=""
	}
	quit "0,"_errstr
}
GetJournalFilesAndUpdateLog(mirname,mirjcnt) PUBLIC {
	/* Called from CatchupDB by mirror member to get all the missing journal files
	   and update the mirror journal log file with the new journal files.
	   This could be called only when the mirjcnt is less than the first
	   entry in mirror log.
	   mirname is the mirror set name of the mirror journal files.
	   mirjcnt is the starting journal count for the range.
	   Return 0 if failed.
	   Return 1 if succeed.
	*/
	L +^MIRROR(mirname,"CatchupRetrieveFiles"):5
	i '$T q "0,Another CatchupDB job is retrieving files."
	s OrigStorage=$ZSTORAGE
	s $ZSTORAGE=2147483647
	s CurrentFiles=0
	s rc=$$GetJournalFiles(mirname,mirjcnt,.CurrentFiles)
	if 'rc {
		L -^MIRROR(mirname,"CatchupRetrieveFiles")
		k CurrentFiles
		s $ZSTORAGE=OrigStorage
		q rc
	}
	s rc=$$RebuildMirrorLogWithFiles(mirname,.CurrentFiles)
	L -^MIRROR(mirname,"CatchupRetrieveFiles")
	k CurrentFiles
	s $ZSTORAGE=OrigStorage
	q rc
}
CheckRequiredDatabases(noisy,lastjrnfilecnt,lastjrnend) PUBLIC {
	/* Invoked from ^MIRRORMGR when a node wants to become the
	   primary to check whether we have the required databases to
	   be the primary. The required databases are all databases which
	   are marked "mount required" in the .cpf file and for mirrored
	   databases, they not only have to be mounted, they have to be
	   "active" (eg. caught up). 
	   JO3079: If lastjrnfilecnt is -1 the db's must be active to 
	   pass the test - we do not care how far along the dejounaling
	   is or isn't.
	*/
	s $zt="err"
	k mirrorlist
	s cnt=0
	s ok=1
	Set rs=##class(%Library.ResultSet).%New("Config.Databases:List")
	do rs.Execute()
 	While rs.Next() {
		s mountrequired=rs.Get("MountRequired")
		if mountrequired {
		   s name=rs.Get("Name")
		   s dir=rs.Get("Directory")
		   s info=$ZU(49,dir)
		   s sfn=+info
		   if (sfn<0)||(sfn=$zu(40,0,41)) {
		      if noisy d $zu(9,"","Required database "_name_" ("_dir_") is not mounted",1 /* broadcast and log message*/,1  /* Warning */)
			  s ok=0
		   } else {
		      s mirrored=$Case($zb(+$p(info,",",17),$zu(40,8,28),1),0:0,:1)
			  s active=$Case($zb(+$p(info,",",18),$zu(40,8,29),1),0:0,:1)
			  s activatereq=$Case($zb(+$p(info,",",18),$zu(40,8,32),1),0:0,:1)
			  if mirrored {
				  if active {
				     if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","Required mirrored database "_name_" ("_dir_") is active")
				  } elseif activatereq {
					  if noisy {
						  d $zu(9,"","Required mirrored database "_name_" ("_dir_") requires activation",1 /* broadcast and log message*/,1  /* Warning */)
					  } else {
						  if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","Required mirrored database "_name_" ("_dir_") requires activation")
					  }
					  s ok=0
				  } elseif lastjrnfilecnt=-1 {
					  if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","Required mirrored database "_name_" ("_dir_") is not active")
				      s ok=0
				  } else {
				     ; Check whether the database is up to date as of our last
				     ; journal file. if so it will be activated when we become
				     ; the primary.
				     s dbinfo=$SYSTEM.Mirror.DBGetInfo(0,sfn)
				     s dbfilecnt=$P(dbinfo,"^",3)
				     s dbfileoff=$P(dbinfo,"^",4)
				     s targdejrnfilecnt=$P(dbinfo,"^",18)
				     s targdejrnfileoff=$P(dbinfo,"^",19)
				     if ((dbfilecnt<lastjrnfilecnt)!
				        ((dbfilecnt=lastjrnfilecnt)&(dbfileoff<lastjrnend))) {
				        if noisy {
					       d $zu(9,"","Required mirrored database "_name_" ("_dir_") requires catchup ("_dbfilecnt_"/"_lastjrnfilecnt_", "_dbfileoff_"/"_lastjrnend_")",1 /* broadcast and log message*/,1  /* Warning */)
				        } else {
					       if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","Required mirrored database "_name_" ("_dir_") requires catchup ("_dbfilecnt_"/"_lastjrnfilecnt_", "_dbfileoff_"/"_lastjrnend_")")
				        }
				        s ok=0
			         } else {
						 if ((targdejrnfileoff) && 
							 ((targdejrnfileoff '= dbfileoff) || (targdejrnfilecnt '= dbfilecnt))) {
							 d $zu(9,"","Required mirrored database "_name_" ("_dir_") appears to have an end past the end of our journal file ("_targdejrnfilecnt_"/"_lastjrnfilecnt_", "_targdejrnfileoff_"/"_lastjrnend_")",1 /* broadcast and log message*/,1  /* Warning */)
							 s ok=0
						 } else {
				            if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","Required mirrored database "_name_" ("_dir_") is caught up")
						 }
			         }
			      }
			  }
		   }
	 	}
 	}
 	s rs=""
 	quit ok
err ;
	s $zt=""
	if noisy d $zu(9,"","Unexpected error checking required databases: "_$ze,1 /* broadcast and log message*/,1  /* Warning */)
	quit 0  ;failed 	
}
 /*	GetJournalFileFromAsync()
	; Purpose: Called when we need to retrieve one or more journal files from our
	;          our async member either at startup or during catchup. We know the 
	;		   mirror journal sequence # of the last file we have and we looked up
	;          the highest journal file the server has. Based on these we can figure 
	; 		   out how many journal files we need to get up to date. 
	;
	; 		   Here we request journal files by # since we don't know their names. 
	; 		   If we have part of a journal file we can tell the server how much we 
	; 		   have and it will send us the rest rather than the entire file. When
	;		   we have part of the journal file, "localendpos" is the end of the
	; 		   file we have and "srcendpos" is the $ZU(78,101) value from the journal
	;		   file which is the corresponding position from the block header of that
	;          location in the source file on the server.
	;
	; 	       Any time we retrive a file beyond the end of the current log,
	;	       $SYSTEM.Mirror.GetJrnfileFromAsync() will it to the end of the
	;          log for us
	;
	;		   array is passed by reference. If its passed, the value of the scalar
	;          should be 1 to indicate we want the files retrieved loaded into the
	;          array: array(<mir seq #>) = <filename>,<mir seq #>,<guid>,<timestamp>
	; 		   This is used when we're retrieving journal files that preceed the end
	; 		   of the log because $SYSTEM.Mirror.GetJrnfileFromAsync() only adds
	;          files to the log when they can be appended; when they come after the last
	;          file in the log. We'll rewrite the entire log with the new files added
	;          in at the start.
	;
	; Returns: Success: $LB("OK")
	;          Failure: $LB("ERR",reason)
	*/
GetJournalFilesFromAsync(mirname,id,fname,localendpos,srcendpos,first,last,array) PUBLIC {
	s $zt="err"
	s saveio=$I
	s io=""
    s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
    if info="" {
	    d $zu(9,"","GetJournalFilesFromAsync failed to locate information about "_mirname_" member id #"_id,1 /* broadcast and log message*/,1  /* Warning */)
	    quit $LB("ERR","Failed to find Member info for node #"_id_" in "_mirname)
    }
    s name=$lg(info,1)
    s guid=$lg(info,2)
    s ecpip=$lg(info,3)
    s mirip=$lg(info,4)
    s mtype=$LG(info,8)
    ;
    s mirguid=$G(^SYS("MIRRORSET",mirname,"GUID"))
    ;
    s status=$$EstablishConnection(mirname,0,id,"s",.io,.options)
	if (status '= 1) {
		d $zu(9,"","GetJournalFilesFromAsync failed to open connection to "_mirname_":"_name,1 /* broadcast and log message*/,1  /* Warning */)
		s rc=$LB("ERR","Failed to open connection to "_name)
		quit rc
    }
    ; Send GETJRNFILE and the server side will start
    ;  $System.Mirror.SendJrnfileFromAsync() to handle this
    ; connection. We pass control to $SYSTEM.Mirror.GetJrnfileFromAsync()
    s msg=$LB("GETJRNFILE",$LB(mirname,mirguid),guid)
    do tcpsend^MIRRORCTL(io,msg)
    ;
	if '$D(array) s array=0
	for filecnt=first:1:last {
		Lock +^%ISC.FetchMirrorFile(filecnt):2
		i '$T {
			s rc=$LB("ERR","File #"_filecnt_" is currently retrieved by another job")
			quit
		}
		s FileLocked=1
    	s msg=$LB("SEND",filecnt)
	    do tcpsend^MIRRORCTL(io,msg)
	    s rc=$$tcpread^MIRRORCTL(io)
	    if ($LG(rc)'="OK") || ($LG($LG(rc,2))'="GO") {
		    s:$LG(rc)="OK" rc=$LG($LG(rc,2))
		    d $zu(9,"","Failed to receive initial ok retrieving journal file #"_filecnt_" for mirror "_mirname_" from "_name,1 /* broadcast and log message*/,1  /* Warning */)
			Lock -^%ISC.FetchMirrorFile(filecnt)
			k FileLocked
		    goto exit
	    }
		d $zu(9,"","Retrieving journal file #"_filecnt_" for mirror "_mirname_" from "_name,0,0  /* Informational message */)
		use io
		if filecnt'=first {
			s fname=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)
			s fname=$s('+fname:"",1:$P(fname,",",2))
			if fname'="" s localendpos=65536*2
		}
		s rc=$SYSTEM.Mirror.GetJrnfileFromAsync(io, mirname, filecnt, fname, srcendpos, localendpos)
		use saveio
		Lock -^%ISC.FetchMirrorFile(filecnt) k FileLocked
		if $LG(rc)'="OK" {
			d $zu(9,"","Error retriving async journal file #"_filecnt_" ("_$LG(rc,2)_")",1 /* broadcast and log message*/,1  /* Warning */)
			quit
		}
		if +$G(array) {
			/* Return the string for the log file in the array. */
			s fname=$lg(rc,3)  ;3rd piece is filename
			s jrninfo=$zu(78,22,fname,99)
			if +jrninfo'=1 {
				s rc=$LB("ERR","Failed to get journal header info") Quit
			}
			s jcnt=$P(jrninfo,",",13+1)
			if jcnt'=filecnt {
				s rc=$LB("ERR","Journal count mis-match, "_jcnt_" in file vs. "_filecnt_" in reuqest") Quit
			}
			s jguid=$P(jrninfo,",",7+1)
			s array(filecnt)=fname_","_jcnt_","_jguid_","_$zdate($h,3)_" "_$ztime($p($h,",",2),1)
		}
		s localendpos = 0  ;after 1st file, we request the entire file
		s srcendpos = 0
		s fname=""  ; we only specify a fname for the 1st file and then, only if we
		            ; already have part of it (eg.srcendpos is non-zero)
	}
    do tcpsend^MIRRORCTL(io,$LB("DONE"))
exit
	c io
	use saveio 
	quit rc  ;$LB("OK") or $LB("ERR",<reason>)
err ;
	s $zt=""
	s err=$ZE
	try {
     	do tcpsend^MIRRORCTL(io,$LB("DONE"))
	} catch {}
	Lock:$G(FileLocked) -^%ISC.FetchMirrorFile(filecnt)
	c io
	use saveio
	quit $LB("ERR","Unexpected error: "_err)		
}
 /* SendJrnfileFromAsync()
    Invoked by AsyncServerDmn() in a job started by the superserver
    on a Async member to send a journal file to another system.
    */
SendJrnfileFromAsync(io,arg) PUBLIC {
	s mirname=$LG(arg,1)
	s mirguid=$LG(arg,2)
	try {
		for {
			u io
			s resp=$$tcpread^MIRRORCTL(io)
			s rc=$LG(resp)
			quit:rc'="OK"
			s resp=$LG(resp,2)
			s function=$LG(resp)
			if function="DONE" quit
			if function="SEND" {
			   s fcnt=$LG(resp,2)
			   do tcpsend^MIRRORCTL(io,$LB("GO"))
			   s rc=$SYSTEM.Mirror.SendJrnfileFromAsync(mirname, mirguid, fcnt, 0)
			}
			; ignore unrecognized function names
		}
		s rc=1
	} catch {
		s rc=$ZE
	}
	quit rc
}
SynchConfigWithPrimary(mirname,id,agentip,targguid,basedir) PUBLIC {
	quit:0 1
	if id'="" {
		s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
		s basedir=$lg(info,6)
		s agentip=$$BuildAgentAddrlist^MIRRORCTL(info)
		s targguid=$LG(info,2)
	}
	s rc=$$GetMemberConfigData^MIRRORCTL(mirname,agentip,targguid,basedir,"*")
	if $LG(rc)'>0 {
		d $zu(9,"","Failed to synch configuration with primary during GetMemberConfigData, Error: "_$s($LG(rc)=-1:"Member not validated",1:$lg(rc,2)),1 /* broadcast and log message*/,1  /* Warning */)
		quit 1
	}
	s MirrorsData=$LG(rc,5)
	if MirrorsData="" {
		s rcx=$$GetMirrorConfigData^MIRRORCTL(mirname,agentip,targguid,basedir)
		if '$LG(rcx) {
			d $zu(9,"","Failed to synch 'Mirrors' configuration with primary, Error:"_$LG(rcx,2),1 /* broadcast and log message*/,1  /* Warning */)
			quit 1
		}
		s MirrorsData=$LG(rcx,2)
	}
	Quit $$UpdateMirrorConfig(mirname,MirrorsData,$LG(rc,2),"SynchConfigWithPrimary")
}
UpdateMirrorConfig(mirname,MirrorsData,memberdata,caller) PUBLIC {
	s IsAsync=+$G(^SYS("MIRRORSET")),ourname=$LG($G(^SYS("MIRRORSET",mirname,"Member",0))),ourguid=$LG($G(^SYS("MIRRORSET",mirname,"Member",0)),2)
	s len=$LL(MirrorsData)
	for i=1:1:len {
		s item=$LG(MirrorsData,i)
		s p=$LG(item,1)
		s v=$LG(item,2)
		s MirrorsParams(p)=v
	}
	s membercnt=$LL(memberdata)
	s rc=##class(Config.MapMirrors).GetClassProperties("",.ClassProperties)
	s ClassProperties=","_ClassProperties_","
	s Skip=0
	f ii=1:1:membercnt {
		s info=$LG(memberdata,ii)
		s name=$LG(info,1)
		s data=$lg(info,2)
		s len=$LL(data)
		for i=1:1:len {
			s item=$LG(data,i)
			s p=$LG(item,1)
			continue:ClassProperties'[(","_p_",")
			s v=$LG(item,2)
			s MapMirrorsParams(name,p)=v
		}
		s MapMirrorsParams(name,"Name")=name
		if '$d(MapMirrorsParams(name,"EncryptCommunication")) s Skip=1 quit
	}
	i Skip quit 1
	s obj=##class(Config.Mirrors).Open(mirname)
	k ClassProperties
	s rc=##class(Config.Mirrors).GetClassProperties("",.ClassProperties)
	s modified=0
	f i=1:1:$l(ClassProperties,",") {
		s Property=$p(ClassProperties,",",i)
		if Property="DefinedPrimary" continue
		i $d(MirrorsParams(Property),val)&&(val'=$zobjproperty(obj,Property)) {
			s $zobjproperty(obj,Property)=val
			s modified = 1
		}
	}
	if modified {
		s rc=obj.%Save()
		if ('rc) {
			d $zu(9,"",caller_": Failed to modify Mirrors section, Error: "_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
			quit 1
		}
	}
	s obj=""
	k ClassProperties,MirrorsParams
 	Set rs=##class(%Library.ResultSet).%New("Config.MapMirrors:List")
 	s rc=rs.Execute(mirname)
	if ('rc) {
		d $zu(9,"","Failed to synch configuration with primary while querying MapMirrors, Error: "_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
		quit 1
	}
	while (rs.Next()) {
	   Set name=rs.Data("Name")
	   k values
	   s x=##class(Config.MapMirrors).Get(mirname,name,.values)
	   if +x m LocalParams(name)=values
	}
	s rs=""
	s rc=##class(Config.MapMirrors).GetClassProperties("",.ClassProperties)
	s AddressProperties=",AgentAddress,AgentPort,ECPAddress,MirrorAddress,MirrorSSPort,"
	s name=$o(MapMirrorsParams(""))
	s BadMemberType=0
	while name'=""&&(BadMemberType=0) {
		if $d(LocalParams(name)) {
			f i=1:1:$l(ClassProperties,",") {
				s Property=$p(ClassProperties,",",i)
				i $d(MapMirrorsParams(name,Property),val1)&&$d(LocalParams(name,Property),val2)&&(val1'=val2) {
					if name=ourname,AddressProperties'[(","_Property_",") {
						if IsAsync || (Property="SSLComputerName") {
							s MapMirrorsParams(name,Property)=val2
							continue
						}
					}
					s MapMirrorsParams(name)=1
					if 'IsAsync,name=ourname,Property="MemberType",val1'=0 s BadMemberType=1
				}
			}
			if '+$G(MapMirrorsParams(name)) {
				k MapMirrorsParams(name)
			}
			k LocalParams(name)
		}
		s name=$o(MapMirrorsParams(name))
	}
	if BadMemberType Quit 0
	s name=$o(MapMirrorsParams(""))
	while name'="" {
		k props
		merge props=MapMirrorsParams(name)
		if +$G(MapMirrorsParams(name)) {
			s rc=##class(Config.MapMirrors).Modify(mirname,name,.props)
			if ('rc) {
				d $zu(9,"",caller_": Failed to modify MapMirrors for "_name_" in mirror set "_mirname_", Error: "_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
			} else {
				d $zu(9,"",caller_": MapMirrors for "_name_" in mirror set "_mirname_" modified",0,0  /* Informational message */)
			}
		} else {
			s rc=##class(Config.MapMirrors).Create(mirname,name,.props)
			if ('rc) {
				d $zu(9,"",caller_": Failed to create MapMirrors for "_name_" in mirror set "_mirname_", Error: "_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
			} else {
				d $zu(9,"",caller_": MapMirrors for "_name_" in mirror set "_mirname_" created",0,0  /* Informational message */)
			}
		}
		s name=$o(MapMirrorsParams(name))
	}
	k LocalParams($LG(^SYS("MIRRORSET",mirname,"Member",0)))
	s name=$o(LocalParams(""))
	while name'="" {
		s rc=##class(Config.MapMirrors).Delete(mirname,name)
		if ('rc) {
			d $zu(9,"",caller_": Failed to delete MapMirrors for "_name_" in mirror set "_mirname_", Error: "_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
		} else {
				d $zu(9,"",caller_": MapMirrors for "_name_" in mirror set "_mirname_" deleted",0,0  /* Informational message */)
		}
		s name=$o(LocalParams(name))
	}
	quit 1
}
RebuildJournalLog(mirname) PUBLIC {
	s $zt="err"
	s corrupt=$SYSTEM.Mirror.JournalLogCorrupted(mirname)
	quit:corrupt<=0 "1"
	s miridx=$SYSTEM.Mirror.MirrorNameToIndex(mirname,0)
	i miridx<0 quit "0"
	s miridx=miridx+1
	do $zu(78,79,1,1,miridx)
	do $zu(78,79,2,1,miridx)
	if $SYSTEM.Mirror.JournalLogCorrupted(mirname)<=0 {
		do $zu(78,79,1,0,miridx)
		do $zu(78,79,2,0,miridx)
		quit "1"
	}
	s rc=##class(SYS.Mirror).BuildJournalLog(mirname,0,"",,1,1)
	do $zu(78,79,1,0,miridx)
	do $zu(78,79,2,0,miridx)
	if ('rc) {
		d $zu(9,"","RebuildJournalLog: failed to rebuild log file for "_mirname_": error: "_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
		quit "0"
	}
	quit "1"
err s $zt=""
	d $zu(9,"","RebuildJournalLog: caught error $ze: "_$ze,1 /* broadcast and log message*/,1  /* Warning */)
	if $d(miridx) {
		do $zu(78,79,1,0,miridx)
		do $zu(78,79,2,0,miridx)
	}
	quit "0"
}
MonitorArbiterConnection(mirname) PUBLIC {
	if ($SYSTEM.Mirror.IsMember()'=1) {
		quit 1
	}
	s info=$SYSTEM.Mirror.GetInfo()
	if (info["SHADOW") {
		quit 1
	}
	if (info["EXIT")||(info["STOPPED") {
		quit 0
	}
	;
	s params=$SYSTEM.Mirror.ReconfigParams()
	s arbiterAddr=$P(params,",",6) ;address, port is piece 7
	if arbiterAddr="" {
		quit 0
	}
	s bits=$SYSTEM.Mirror.ArbiterState()
	if '$ZB(+bits,+1,1) {
		quit 0 
	}
	if $ZB(+bits,+2,1) {
		l +^MIRROR(mirname,"ArbiterLock"):0
		if '$T {
			; can't get the lock, the arbiter should be still running
			quit 0
		}
		; reload bits so we see value after we get the lock
		s bits=$SYSTEM.Mirror.ArbiterState()
		l -^MIRROR(mirname,"ArbiterLock")
		if $ZB(+bits,+2,1) {
			d $zu(9,"","Restarting Arbiter job - Acquired arbiter lock while arbiter connected flag is set.",1 /* broadcast and log message*/,1  /* Warning */)
		} 
	}
	if $ZB(+bits,+2,1) {
 	   s curpid=$G(^MIRROR(mirname,"Arbiter","pid"))
	   d $zu(9,"","Cleared PeerConnected: Arbiter job appears to have died without clearing peer connected (old pid = "_curpid_")",1 /* broadcast and log message*/,1  /* Warning */)
	   s rc=$SYSTEM.Mirror.ArbiterState(2,0)
 	}
 	if $SYSTEM.Mirror.FailoverRule()=1 {
	 	if '$G(%ArbiterModeMsg) {
			s %ArbiterModeMsg=1
		 	d $zu(9,"","Skipping connection to arbiter while still in Arbiter Controlled failover mode.",0,0  /* Informational message */)
	 	}
		quit 0	
	}
	k %ArbiterModeMsg
 	s lastStarted=$G(^MIRROR(mirname,"ArbiterMonitor","laststarted"))
	if lastStarted'="" {
		s elapsed=$$elapsedSec(lastStarted)
		if elapsed<60 {
			quit 0
		}
	} 	
	s ^MIRROR(mirname,"ArbiterMonitor","laststarted")=$ztimestamp
 	j ArbiterConnection(mirname)::5
 	if '$T {
	 	d $zu(9,"","ArbiterMonitor: Failed to create mirror arbiter job for """_mirname_"""",1 /* broadcast and log message*/,1  /* Warning */)
 	}
 	quit 0
}
ArbiterConnection(mirname) PUBLIC {
	s saveio=$I  ;restored on exit in case we're not jobbed off
	s io=""  ;tcp channel is closed
	s timeout=5
	s $zt="err"
	l ^MIRROR(mirname,"ArbiterLock"):5
	if '$T {
		quit
	}
 	if $SYSTEM.Mirror.FailoverRule()=1 {
		d $zu(9,"","Arbiter client can not start in Arbiter Controlled failover mode.",1 /* broadcast and log message*/,1  /* Warning */)
		quit
	}
	k ^MIRROR(mirname,"Arbiter") ;erase any old data
	s ^MIRROR(mirname,"Arbiter","pid")=+$J
	s ^MIRROR(mirname,"Arbiter","started")=$ZTIMESTAMP_"^"_$ZDATETIME($ZTIMESTAMP)
	s ^MIRROR(mirname,"Arbiter","msgcnt")=0
	s origtype=$ZU(61,10,$ZU(61),58)  ;Set our jobtype
	s switchmsgtime=0
	s peerid=""
	if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","Arbiter job started")
top ;	
	s msgcnt=0
	s anscnt=0
	s BackupConnectionLostAt=0
	s notifyOnExit=0  ;set if we exit while the connection is still up
	;
	s isPrimary=$SYSTEM.Mirror.IsPrimary()
	s mirguid=$G(^SYS("MIRRORSET",mirname,"GUID"))
	if mirguid="" {
		d $zu(9,"","Arbiter initialization failed to find mirror guid for "_mirname,1 /* broadcast and log message*/,2  /* Severe error */)
		quit
	}
	s localinfo=$G(^SYS("MIRRORSET",mirname,"Member",0))
	if localinfo="" {
		d $zu(9,"","Arbiter initialization failed to find local information for "_mirname,1 /* broadcast and log message*/,2  /* Severe error */)
		quit
	}
	s qostimeout=$G(^SYS("MIRRORSET",mirname,"QOSTimeout"))
	if qostimeout="" {
		d $zu(9,"","Arbiter initialization failed to find QOS Timeout for "_mirname,1 /* broadcast and log message*/,2  /* Severe error */)
		quit
	}
	s params=$SYSTEM.Mirror.ReconfigParams()
	s arbiterIP=$P(params,",",6)
	s arbiterPort=$P(params,",",7)
	;
	do setArbiterTimeouts(qostimeout,.waittime,.keepalive)
	s localname=$LG(localinfo,1)  ;Our member name
	s localguid=$LG(localinfo,2)  ;Member GUID
	;
	s io=$$buildArbiterConnection(mirname,timeout)
	if io="" {
		goto doneNoMsg   ;failed
	}
	s rc=$$sendArbiterMessage(io,0, mirguid, localguid)
	if 'rc goto done
	s rc=$$sendArbiterMessage(io,1, "ConnectionTimeout", keepalive)
	if 'rc goto done
	s rc=$SYSTEM.Mirror.ArbiterState(4,0) ;clear bit
	s rc=$SYSTEM.Mirror.ArbiterState(2,1) ;set bit
	do {
		s msgcnt=$I(msgcnt)  ;msgcnt gets sent back in answer
		s rc=$$sendArbiterMessage(io,2,msgcnt) 
		if 'rc goto done
		do {
			s result=$$readArbiterMessage(io,waittime)
			if '$LG(result) goto done
			s code=$LG(result,2)
			s msg=$LIST(result,3,*)  ;pick up the message data
		    do $case(code,
						6:PeerConnected(io,mirname,msg,.peerid),
						7:PeerConnected(io,mirname,msg,.peerid),
						9:PeerDisconnected(io,mirname,msg,peerid),
						10:PeerDisconnected(io,mirname,msg,peerid),
						8:PeerMessage(io,mirname,msg,peerid),
						:ArbiterNoop(result))
		} while (code '= 5)
		s anscnt=+$LG(msg)  ;msg for StillAlive is the sequence # we sent
		if $SYSTEM.Mirror.IsPrimary() && '$SYSTEM.Mirror.GetInfo(5) &&
			($SYSTEM.Mirror.FailoverRule()=1) {
			s state=$SYSTEM.Mirror.ArbiterState()
			s bits=4+2
			if $zb(+state,+bits,1)=2 {  ;Peer has disconnected
				do $SYSTEM.Mirror.FailoverRule(2)
				d $zu(9,"","Primary switched to agent contact mode: Data channel lost, backup lost arbiter connection",0,0  /* Informational message */)
			} else {
				s elapsed=$$elapsedSec(switchmsgtime)
				if ((elapsed < 0) || (elapsed > 30)) {
					if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","Primary sending request to switch from arbiter mode to agent contact mode")
					s rc=$$sendArbiterMessage(io,4,"PrimarySwitchToAgentContact")
					if 'rc {
						d $zu(9,"","Failed to send switch to agent contact message via arbiter to backup",1 /* broadcast and log message*/,2  /* Severe error */)
					}
					s switchmsgtime=$ztimestamp
				}
			}
		}
		s msg=$SYSTEM.Event.WaitMsg("",waittime) ;"" = our "$J" resource
		s rc=$LG(msg)
		if rc=1 {
			; we got a message rather than a timeout
			s msg=$LG(msg,2)  ; pick up the message
			s text=$LG(msg)
			if text="BackupConnectionLost" {
				if $SYSTEM.Mirror.GetInfo(5)=1 {
				   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","DataChannel is up - ignoring BackupConnectionLost")
				} elseif $SYSTEM.Mirror.IsPrimary() {
				   s BackupConnectionLostAt=msgcnt
			       s AgentContactMessageSent=0			
				   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","Received BackupConnectionLost at msg #"_msgcnt)
				}
			 } else {
			   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","Arbiter ignoring unrecognized message /"_text_"/")
			 }
		}
		if (BackupConnectionLostAt '= 0) && (anscnt < BackupConnectionLostAt) {
			if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","Aribter waiting for cur msg #"_anscnt_" to reach "_BackupConnectionLostAt)
		} elseif (BackupConnectionLostAt '= 0) {
    	   s failoverRule=$SYSTEM.Mirror.FailoverRule()
    	   if failoverRule'=1 {
	    	   s BackupConnectionLostAt=0
	    	   if (AgentContactMessageSent=0) {
	    	      if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","Mirror not in arbiter controlled mode, backup disconnect ignored")
	    	   } else {
		    	   /* probably the backup sent us a BackupSwitchToAgentContact message so
		    	      that's why we're not in arbiter controlled mode any more */
		    	  if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","Mirror no longer in arbiter controlled mode")
	    	   }    
	    	   continue
    	   }
		   /* GetInfo(5) returns 1 if the data channel is up, 0 if it is down */
		   if $SYSTEM.Mirror.GetInfo(5)=1 {
	    	   s BackupConnectionLostAt=0
			   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","Arbiter found data channel restarted - ignoring connection lost message")
	    	   continue
    	   }
		   s state=$SYSTEM.Mirror.ArbiterState()
		   if '$ZB(+state,+4,1) {
			   d $zu(9,"","Backup has disconnected from Arbiter - waiting for reconnection.",0,0  /* Informational message */)
			   s BacupConnectionLostAt=0
		   } else {
			   if (AgentContactMessageSent=0) {  ; only ask once
				   s AgentContactMessageSent=msgcnt  ;might be interesting for debugging, any nonzero value is fine
				   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","Asking backup to switch to agentcontactmode")
				   s rc=$$sendArbiterMessage(io,4,"PrimarySwitchToAgentContact")
				   if 'rc goto done
			   } else {
		    	   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","Still waiting for switchtoagentcontact response")
			   }
		   }
		}
		if $ZB(+$SYSTEM.Mirror.ArbiterState(),+8,1) {
			do $SYSTEM.Mirror.ArbiterState(8,0)
			s newqostimeout=+$G(^SYS("MIRRORSET",mirname,"QOSTimeout"))
			if newqostimeout'=qostimeout {
				if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","Arbiter detected new qos timeout"_newqostimeout)
				s qostimeout=newqostimeout
				do setArbiterTimeouts(qostimeout,.waittime,.keepalive)
			}
			s params=$SYSTEM.Mirror.ReconfigParams()
			s newarbiterIP=$P(params,",",6)
			s newarbiterPort=$P(params,",",7)
			if (newarbiterIP'=arbiterIP) || (newarbiterPort'=arbiterPort) {
				if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","Arbiter client resetting - arbiter address or port changed.")
				s rc=$SYSTEM.Mirror.ArbiterState(2,0) ;clear bit
				close io
				goto top
			}
		}
	} while ($$arbiterEnabled()) 
	if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","Arbiter client exiting.")
	s notifyOnExit=1  ;tell the primary to switch to agent contact
	goto doneNoMsg
done
    d $zu(9,"","Arbiter connection lost",1 /* broadcast and log message*/,2  /* Severe error */)
doneNoMsg
	s rc=$SYSTEM.Mirror.ArbiterState(2,0)  ;clear bit
	if ('$SYSTEM.Mirror.IsPrimary()) && '$SYSTEM.Mirror.GetInfo(5) &&
			($SYSTEM.Mirror.FailoverRule()=1) {
		do $SYSTEM.Mirror.FailoverRule(2,1)
		if ($SYSTEM.Mirror.FailoverRule()=2) {
		   d $zu(9,"","Backup switched from Arbiter Controlled failover mode to Agent Controlled - arbiter client exiting",0,0  /* Informational message */)
		   d $zu(9,"","IsPrimary: "_$SYSTEM.Mirror.IsPrimary()_", Info = "_$SYSTEM.Mirror.GetInfo(),0,0  /* Informational message */)
		   if notifyOnExit {
			   s rc=$$sendArbiterMessage(io,4,"BackupSwitchToAgentContact")
			   if 'rc {
				  d $zu(9,"","Arbiter@done failed to send BackupSwitchToAgentContact msg back to primary",1 /* broadcast and log message*/,1  /* Warning */)
			   } else {
				  if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","Sent BackupSwitchToAgentContact @ exit")
			   }
		   }
		}
	}
	; arbiter connection closed
	do $ZU(61,10,$ZU(61),origtype)  ;Restore our jobtype
	s ^MIRROR(mirname,"Arbiter","pid")=""
	s ^MIRROR(mirname,"Arbiter","done")=$ZTIMESTAMP_"^"_$ZDATETIME($ZTIMESTAMP)
	if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","Arbiter connection closed")
	l
	if io'="" {
		close io
		s io=""
	}
	try {
		use saveio  ;in case we're not jobbed off
	} catch {}
	quit	
err ;
	s $zt=""
	use 0
	d $zu(9,"","Arbiter connection exited, caught unexpected error: "_$ZE,1 /* broadcast and log message*/,2  /* Severe error */)
	d BACK^%ETN
	s rc=$SYSTEM.Mirror.ArbiterState(2,0)  ;clear bit
	if ('$SYSTEM.Mirror.IsPrimary()) && '$SYSTEM.Mirror.GetInfo(5) &&
			($SYSTEM.Mirror.FailoverRule()=1) {
		do $SYSTEM.Mirror.FailoverRule(2,1)
	    if ($SYSTEM.Mirror.FailoverRule()=2) {
			if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","Backup switched from Arbiter Controlled to Agent Controlled failover mode")
	    }
	}
	do $ZU(61,10,$ZU(61),origtype)  ;Restore our jobtype
	s ^MIRROR(mirname,"Arbiter","pid")=""
	s ^MIRROR(mirname,"Arbiter","errcode")=$ZE
	s ^MIRROR(mirname,"Arbiter","done")=$ZTIMESTAMP_"^"_$ZDATETIME($ZTIMESTAMP)
	l
	if $G(io)'="" {
		close io
		s io=""
	} 
	try {
		use saveio
	} catch {}
	quit	
}
arbiterEnabled() {
	; returns 1 if the arbiter should keep running
	;         0 if the arbiter should exit
	;
	if '$ZB(+$SYSTEM.Mirror.ArbiterState(),+1,1) {
		; The data channel reformed and the new failover member
		; doesn't support the arbiter
		quit 0
	}
	if $ZB(+$SYSTEM.Mirror.ArbiterState(),+16,1) {
	    if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","Arbiter client found exit requsted set.")
	    quit 0
	}
	if ($SYSTEM.Mirror.IsMember()'=1) {
		quit 0
	}
	s info=$SYSTEM.Mirror.GetInfo()
	if (info["SHADOW") {
		quit 0
	}
	if (info["EXIT")||(info["STOPPED") {
		quit 0
	}
	quit 1
}
    ;waittime and keepalive are passed by reference and are set
    ; based on qostimeout.
setArbiterTimeouts(qostimeout,waittime,keepalive) {
	s waittime=qostimeout/1000 ; convert msec to seconds
	s waittime=waittime/2
	if waittime<1 s waittime=1
	if waittime<5 {
		s keepalive=waittime*2
	} else {
		s keepalive=waittime+5
	}
	s keepalive=keepalive*1000  ;convert to msec
}
PeerConnected(io,mirname,msg,retpeerid) PUBLIC {
	s $zt="err"
	s peerinfo=$G(^SYS("MIRRORSET",mirname,"Member",1))
	if peerinfo="" {
		d $zu(9,"","Arbiter peer connected handler failed to find peer information for "_mirname,1 /* broadcast and log message*/,2  /* Severe error */)
		quit
	}
	s peername=$LG(peerinfo,1)
	s peerid=$LG(peerinfo,2)
	s id=$LG(msg)  ;1 argument, peer id
	if id'=peerid {
		d $zu(9,"","Arbiter peer connected handler received incorrect peer id. Got /"_id_"/ not /"_peerid_"/ for "_peername_" in "_mirname,1 /* broadcast and log message*/,2  /* Severe error */)
		quit
	}
	s retpeerid=$LB(peername,peerid) 
	if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","Received peer connected message from "_peername_" ("_peerid_")")
	s rc=$SYSTEM.Mirror.ArbiterState(4,1)  ;set bit
	quit
err ;
	s $zt=""
	d BACK^%ETN
	d $zu(9,"","Unexpected arbiter error caught: "_$ze,1 /* broadcast and log message*/,1  /* Warning */)
	quit
}
PeerDisconnected(io,mirname,msg,peerinfo) PUBLIC {
	s $zt="err"
    ;
	s peername=$LG(peerinfo,1)
	s peerid=$LG(peerinfo,2)
	s id=$LG(msg)  ;1 argument, peer id
	if id'=peerid {
		d $zu(9,"","Arbiter peer disconnected handler received incorrect peer id. Got /"_id_"/ not /"_peerid_"/ for "_peername_" in "_mirname,1 /* broadcast and log message*/,2  /* Severe error */)
		quit
	}
	if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","Received peer disconnected message from "_peername_" ("_peerid_")")
	s rc=$SYSTEM.Mirror.ArbiterState(4,0)  ;clear bit
	if $SYSTEM.Mirror.IsPrimary() &&
	           ($SYSTEM.Mirror.FailoverRule()=1) { 
		if '$SYSTEM.Mirror.GetInfo(5) {
			d $zu(9,"","Arbiter reports to primary that backup disconnected - switching to AgentContact mode",0,0  /* Informational message */)
			do $SYSTEM.Mirror.FailoverRule(2)
		}
	}
	quit
err ;
	s $zt=""
	d BACK^%ETN
	d $zu(9,"","Unexpected arbiter error caught: "_$ze,1 /* broadcast and log message*/,1  /* Warning */)
	quit
}
PeerMessage(io,mirname,msg,peerinfo) PUBLIC {
	s peername=$LG(peerinfo,1)
	s peerid=$LG(peerinfo,2)
	s id=$LG(msg)  ;1st argument, peer id
	s text=$LG(msg,2)  ;2nd arg, message text
	if id'=peerid {
		if text="PrimarySwitchToAgentContact",$SYSTEM.Mirror.IsPrimary() {
		    d $zu(9,"","Primary recieved message via arbiter channel from old primary with bad guid ("_id_" not "_peerid_"). Telling old primary to shut down.",0,0  /* Informational message */)
			s rc=$$sendArbiterMessage(io,4,"DuplicatePrimaryHalt")
			if 'rc {
				d $zu(9,"","Arbiter failed to send DuplicatePrimaryHalt msg back to former primary ("_id_")",1 /* broadcast and log message*/,2  /* Severe error */)
				s $ZERROR="<ZFAILDuplicatePrimaryHalt>"  ;throw doesn't set $ZE
				throw ##class(%Exception.General).%New("FailedToSendArbiterMsg","1",,"Arbiter failed to send DuplicatePrimaryHalt msg to former primary")
			}
		    quit
		}
		if text="DuplicatePrimaryHalt",$SYSTEM.Mirror.IsPrimary(),+$p($SYSTEM.Mirror.GetInfo(2),",",12),$SYSTEM.Mirror.FailoverRule()=1 {
			goto shutdown
		}
		d $zu(9,"","Arbiter peer message handler received incorrect peer id. Got /"_id_"/ not /"_peerid_"/ for "_peername_" in "_mirname,1 /* broadcast and log message*/,2  /* Severe error */)
		quit
	}
	if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","Received peer message """_text_""" from "_peername_" ("_peerid_")")
	if text="PrimarySwitchToAgentContact" {
		; Set the failover rule to agent contact required and
		; if we're the backup, send the same message back to the
		; primary.
		do $SYSTEM.Mirror.FailoverRule(2,1)
		if ($SYSTEM.Mirror.FailoverRule()'=2) {
			d $zu(9,"","Backup ignored switch to Agent Controlled message from primary at "_peername,0,0  /* Informational message */)
			quit
		}
		if $SYSTEM.Mirror.GetInfo()["PRIMARY" {
		    d $zu(9,"","Primary recieved message via arbiter channel from old primary. Notifying other member ("_peerid_")",0,0  /* Informational message */)
			s rc=$$sendArbiterMessage(io,4,"DuplicatePrimaryHalt")
			if 'rc {
				d $zu(9,"","Arbiter failed to send DuplicatePrimaryHalt msg back to old primary",1 /* broadcast and log message*/,2  /* Severe error */)
				s $ZERROR="<ZFAILDuplicatePrimaryHalt>"  ;throw doesn't set $ZE
				throw ##class(%Exception.General).%New("FailedToSendArbiterMsg","1",,"Arbiter failed to send DuplicatePrimaryHalt msg to old primary: "_peerid)
			}
		    quit
		}
		d $zu(9,"","Switched primary "_peername_" to Agent Controlled failover mode as result of arbiter message",0,0  /* Informational message */)
		s rc=$$sendArbiterMessage(io,4,"BackupSwitchToAgentContact")
		if 'rc {
			d $zu(9,"","Arbiter failed to send BackupSwitchToAgentContact msg back to primary",1 /* broadcast and log message*/,2  /* Severe error */)
			s $ZERROR="<ZFAILSendAgentContactToPrimary>"  ;throw doesn't set $ZE
			throw ##class(%Exception.General).%New("FailedToSendMsgtoPrimary","1",,"Arbiter failed to send BackupSwitchToAgentContact msg back to primary")
		}
		if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","Sent ""BackupSwitchToAgentContact"" request to "_peername_" ("_peerid_")")
		quit
	}
	if text="BackupSwitchToAgentContact" {
		; Set the failover rule to agent contact required
		; (ignored by the backup)
		if '$SYSTEM.Mirror.IsPrimary() {
			d $zu(9,"","Ignored unexpected SwitchToAgentContact arbiter message from backup: "_peername,0,0  /* Informational message */)
			quit 1
		}
		d $zu(9,"","Primary switched to Agent Controlled failover mode as result of arbiter message from "_peername,0,0  /* Informational message */)
		do $SYSTEM.Mirror.FailoverRule(2)
	}
	if (text="DuplicatePrimaryHalt") && $SYSTEM.Mirror.IsPrimary() {
shutdown ;
		/* This gets sent to us when the other node becomes the primary after a
		   network outage and then the network connections are re-established and
		   it figures out that we're still up as the primary (although we should be
		   still frozen in a trouble state). The current primary sends this via the
		   arbiter channel (because the agent channel may still be down) to tell us
		   to force ourselves down. We tests SYSTEM.Mirror.IsPrimary() because we
		   might be the backup if there is an old primary which was network isolated
		   which just regained connectivity. If we're the backup we should ignore this. */
		d $zu(9,"","Current primary """_peername_""" told us via arbiter channel to shut down ",1 /* broadcast and log message*/,1  /* Warning */)
		l  ; release all locks
		if $G(^SYS("MIRRORSET",mirname,"VirtualAddress"))'="" {
			s x=$$DeleteVirtualAddress^MIRRORMGR(mirname)
    	}
		s info=$G(^SYS("MIRRORSET",mirname,"Member",0))
		s rc=$$ForceNodeDown^MIRRORCTL(mirname,0,1)
		if $LG(rc)'="OK" {
			d $zu(9,"","Attempt to force ourself down returned error: "_$$Format^%qcr(rc,1)_". Trying shutdown instead",1 /* broadcast and log message*/,1  /* Warning */)
			do INT^SHUTDOWN
		} else {
			h 10  ;if we're still running after a few seconds, something went wrong
			d $zu(9,"","Force may have failed - still running after 10 seconds (rc="_$$Format^%qcr(rc,1)_")",1 /* broadcast and log message*/,1  /* Warning */)
		}
		halt
	}
	quit
err ;
	s $zt=""
	d BACK^%ETN
	d $zu(9,"","Unexpected arbiter error caught: "_$ze,1 /* broadcast and log message*/,1  /* Warning */)
	quit
}
ArbiterNoop(msg) PUBLIC {
	; handler for messages we ignore
	quit
}
buildArbiterConnection(mirname,timeout) {
	s io=""  ;device not open
	s $zt="err"
	if timeout<=0 {
		s timeout=10
	}
	s connectionFailCnt=0
top ;	
	s params=$SYSTEM.Mirror.ReconfigParams()
	s arbiterIP=$P(params,",",6)
	s arbiterPort=$P(params,",",7)
	if arbiterIP="" {
		d $zu(9,"","Arbiter address not found for "_mirname,1 /* broadcast and log message*/,2  /* Severe error */)
		quit ""
	}
	; Add a 2 before the port so we don't conflict with ^MIRRORCTL names
	s tmp="|TCP|2"_arbiterPort
	if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","Attempting arbiter connection to "_arbiterIP_":"_arbiterPort)
	s start=$ztimestamp
	o tmp:(/Hostname=arbiterIP:/Port=arbiterPort:/STREAM=1:/IOTABLE="RAW"):timeout
	s ok=$T
	if 'ok {
		if 'connectionFailCnt {
			d $zu(9,"","Timed out building initial connection to arbiter at "_arbiterIP_":"_arbiterPort_" for "_mirname,1 /* broadcast and log message*/,2  /* Severe error */)
		}
		if '($I(connectionFailCnt)#360) {  ;not more than once/hour
			d $zu(9,"","Still failing to build initial connection to arbiter at "_arbiterIP_":"_arbiterPort_" for "_mirname,1 /* broadcast and log message*/,1  /* Warning */)
		}
		s elapsed=$$elapsedSec(start)
		if elapsed<10 h 10-elapsed
		goto top
	}
	s io=tmp  ;device is open
	if connectionFailCnt {
		s connectionFailCnt=0
		d $zu(9,"","Successfully built initial connection to arbiter at "_arbiterIP_":"_arbiterPort_" for "_mirname,0,0  /* Informational message */)
	}
	u io 
	w "ISC1ARBITER " w *-3
	read okstr#2:timeout  ; wait for server to fork a connection handler
	s ok=$t
	if 'ok {
		c io s io=""
		d $zu(9,"","Timed out waiting for initial OK from arbiter at "_arbiterIP_":"_arbiterPort_" for "_mirname,1 /* broadcast and log message*/,2  /* Severe error */)
		quit ""
	}
	if okstr'="OK" {
		c io s io=""
		d $zu(9,"","Received /"_okstr_"/ not /OK/ from arbiter at "_arbiterIP_":"_arbiterPort_" for "_mirname,1 /* broadcast and log message*/,2  /* Severe error */)
		quit ""
	}
	d $zu(9,"","Arbiter connection established ("_arbiterIP_":"_arbiterPort_")",0,0  /* Informational message */)
	quit io  ;connection has been built!
err ;
	s $zt=""
	use 0
	d $zu(9,"","Arbiter connection for "_mirname_" caught unexpected error: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	d BACK^%ETN
	if io'="" {
		close io
		s io=""
	} 
	quit ""  ;not open
}
sendArbiterMessage(io,code, args...) {
	/* The arbiter message format is:
	        <0x01> - 1 byte format version (currently 1) 
	        <0x02> - 1 byte # of bytes of size args (2 bytes ea)
	        <lsb item cnt> - count of # of items including msg code
	        <msg item cnt>
	        <0x01> - lsb size of message code (must be 1)
	        <0x00> - msb size of message code (must be 0)
	        <1 byte message code value (eg. 0x01 = code #1)>
	        <lsb # of bytes of arg (n)> - 
	        <msg # of bytes of arg (n)> - 
	        <bytes for string representing arg (n)>
	   The message code is passed as a single character which is the
	   ascii value of the message code, 0-255. The rest of the arguments
	   are passed as strings including numerics which are passed as a
	   string of digits
	*/
	s $zt="err"
	s argcnt=$G(args,0)
	s msg=$C(1,2)  ;version 1, values are 2 bytes
	s msg=msg_$zwchar(argcnt+1)  ; +1 for item code
	s msg=msg_$zwchar(1)_$char(code)  ;code is 1 byte, 0-255
	for i=1:1:argcnt {
		s arg=$G(args(i))
		s msg=msg_$zwchar($L(arg))_arg
	}
	try {
		use io
		write msg w *-3
		s rc=1
	} catch {
		s rc=0
		if $ZE'["<WRITE>" {
			d BACK^%ETN
			d $zu(9,"","Unexpected error writting to arbiter: "_$ze,1 /* broadcast and log message*/,2  /* Severe error */)
		}
	}
	quit rc
err ;
	s $zt=""
	do BACK^%ETN
	quit 0  ;failed
}
readArbiterMessage(io, timeout) {
	s $zt="err"
	try {
		use io
		read msghdr#2:timeout
		s ok=$t
	} catch {
		s ok=0
	}
	if 'ok {
		quit $LB(0)  ;failed to read a message within timeout
	}
	s msgver=$A(msghdr)
	s bytesize=$A(msghdr,2)
	; shorten the timeout for subsequent reads to 1 second
	; because the entire message should now be available
	read bytes#bytesize:1
	if '$T quit $LB(0)  ;failed
	s argcnt=$$cvtbytes(bytes) ; this includes the code
	s resp=$LB(1)  ;success code
	; read the message code which should be 1 byte
	read len#bytesize:1
	if '$T {
		s resp=$LB(0)  ;failed
		quit
	}
	s len=$$cvtbytes(len)
	if len'=1 {
		d $zu(9,"","Invalid length returned for arbiter code: "_len,1 /* broadcast and log message*/,2  /* Severe error */)
		s resp=$LB(0)
		quit
	}
	read code#1:1
	if '$T {
		s resp=$LB(0)  ;failed
		quit
	}
	s code=$A(code)  ;convert ascii character to numeric value
	s resp=resp_$LB(code)
	s argcnt=argcnt-1
	for i=1:1:argcnt {
		read len#bytesize:1
		if '$T {
			s resp=$LB(0)  ;failed
			quit
		}
		s len=$$cvtbytes(len)
		read str#len:1
		if '$T {
			s resp=$LB(0)  ;failed
			quit
		}
		s resp=resp_$LB(str)
	}
	quit resp
err ;
	s $zt=""
	do BACK^%ETN
	quit $LB(0)  ;failed
}
elapsedSec(start) public {
	s cur=$ztimestamp
	s days=+cur-start
	s sec=+$P(cur,",",2)-$P(start,",",2)
	s sec=sec+(days*86400) ;60*60*24
	quit sec
}
cvtbytes(str) public {
	s l=$L(str)
	s res=$Case(l,1:$a(str),
				2:$zwascii(str),
				3:$zlascii(str_$C(0)),
				4:$zlascii(str),
				5:$zqascii(str_$C(0,0,0)),
				6:$zqascii(str_$C(0,0)),
				7:$zqascii(str_$C(0)),
				8:$zqascii(str),
				:"")
	quit res
}
AddPendingDNUpdates(mirname,name,agentip,targguid,basedir) PUBLIC {
	s rc=$$GetMemberConfigData^MIRRORCTL(mirname,agentip,targguid,basedir)
	if '$LG(rc) quit rc
	s memberdata=$LG(rc,2)  ;list of $LIST(name,<list of key/value pairs>)
	s membercnt=$LL(memberdata)
	f ii=1:1:membercnt {
		s info=$LG(memberdata,ii)
		s membername=$LG(info,1)
		if membername'=name continue
		s data=$lg(info,2)
		s len=$LL(data)
		for i=1:1:len {
			s item=$LG(data,i)
			s p=$LG(item,1)
			s v=$LG(item,2)
			s MapMirrors(membername,p)=v
		}
	}
	if '$d(MapMirrors) quit $LB(0,"Could not find member '"_name_"' in its configiuration.")
	s guid=MapMirrors(name,"GUID"),membertype=MapMirrors(name,"MemberType"),DN=MapMirrors(name,"SSLComputerName")
	s ^MIRROR(mirname,"PendingDNUpdates",name_":"_guid)=$LB(name,guid,DN,membertype)
	quit $LB(1)
}

MIRRORCTL^INT^1^67214,47330
MIRRORCTL ;Client side of agent process for mirroring  ;Change #: $Change: 7440104 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ; Revision: $Id: //iris/2024.1.3/databases/sys/rtn/sysconfig/mirrorctl.mac#1 $
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/_syMirror.inc#1 $ ($Change: 7440104 $) */
        /* Initializing is the state a member has at startup until it
           gets to wait^MIRRORMGR for the 1st time. At that point it has 
           either become the backup or primary or we set the role to null
           to indicate that it is up and running as opposed to still getting
           started */
				    /* Arbiter failover rules are in effect */
				    /* Agent contact is required */
					/* IsOtherNodeDown^ZMIRROR */
				/* The client supports the arbiter */
			 	/* This system is connected to the arbiter */
		  		/* The other failover member is connected to the arbiter */
		  		/* Either the QOSTimeout changed or the arbiter address changed.
		  		   we should look up the current values and use them */
				/* Arbiter job shoud close the connection and exit. The
				   retry routine can restart the arbiter if conditions
				   warrent. Generally used with clearing ArbiterSupported
				   when the backup is removed or demoted. Cleared when
				   the arbiter exits (eg. its a one time flag). */
 ;
 ; Entry points in this module are for internal use only and are
 ; subject to change in future versions.
 ; 
TEST(mirname, agentaddrlist, targguid, basedir, timeout = 5, hangtime = 0) PUBLIC {
	s $zt="err"
	s saveio=$I
	s rc=$$tcpopen(mirname,agentaddrlist,targguid,basedir,timeout,0,2)
	if +rc {
		if +rc=1 quit $LB(0,"TIMEOUT")
		if +rc=3 quit $LB(0,"LOCALSSLERR",$P(rc,",",2,999))
		if +rc=4 quit $LB(0,"SSLERR",$P(rc,",",2,999))
		quit $LB(0,"ERR",$P(rc,",",2,999))
	}
	s io=$P(rc,",",2)
	s version=+$P(rc,",",3)
	use io
	s:hangtime<0 hangtime=0
	s:hangtime>60 hangtime=60
	do tcpsend(io,$LB("TESTAGENT",$LB(+hangtime)))
	s rc=$$tcpread(io)	
	close io
	use saveio 
	s status=$LG(rc)
	if status'="OK" {
	    q $LB(0,"ERR",$LG(rc,2))
	}
	s result=$LG(rc,2)
	;returns $LB(OK,<result>,...)
	if $LG(result)="OK" quit $LB(1,"SUCCESS")
	quit $LB(0,$LG(result),$LG(result,2))
err ;
	s $zt=""
	use saveio 
	c io
	quit $LB("ERR",0,$ZE)		
}
InstanceLookup(addr,instance,timeout=10,mirname="") PUBLIC {
	s $zt="err"
	s command="ISC2QUERYINS"
	s addr=$P(addr,",",1)  ;only supports a single address
	s port=$P(addr,"|",2)
	s ip=$P(addr,"|")
	s saveio=$I
	s io="|TCP|1"_port
	s timeout=+timeout
	if 'timeout s timeout=10
again ;
	o io:(/Hostname=ip:/Port=port:/STREAM=1:/IOTABLE="RAW"):timeout
	s ok=$T
	if 'ok {
		quit $LB("ERR","Timed out opening connection to "_ip_":"_port)
	}
	; Send the string "ISC2QUERYINS " to indicate we're going to send
	; an instance name we want translated. The message format is 
	;  <1 byte version - must be 1>
	;  <1 byte size of length field = we use 2 - this is 'n'>
	;  <n byte count of # of fields in message - we use 1>
	;  <n byte # of bytes in field>
	;  < bytes for field>
	u io 
	w command
	w $C(1) ; version code
	w $C(2) ; size of prefix fields (# of pieces, piece size)
	w $zwchar(1)  ; # of pieces we're sending
	w $zwchar($L(instance))
	w instance
	w *-3  ;flush output
	s done=0
	read id#2:timeout
	if '$t {
		s errtext="Failed to read version id"
		goto fail
	}
	if id="un" {
		close io
		if command="ISC2QUERYINS" {
			s command="ISC1QUERYINS"
			goto again
		}
		use saveio
		quit $LB("ERR","unknown application")
	}
	s version=$A(id)
	s bytesize=$a(id,2)
	read str#bytesize:timeout
	if '$t {
		s errtext="Failed to "_bytesize_" byte argcount"
		goto fail
	}
	s argcnt=$case(bytesize,1:$A(str),2:$zwascii(str),4:$zlascii(str))
	for i=1:1:argcnt {
	   read str#bytesize:timeout
	   if '$t {
		   s errtext="Failed to read size of arg #"_i
		   goto fail
	   }
	   s arglen=$case(bytesize,1:$A(str),2:$zwascii(str),4:$zlascii(str))
	   read arg(i)#arglen:timeout
	   if '$t {
		   s errtext="Failed to read "_arglen_" bytes for arg #"_i
		   goto fail
	   }
	}
	use saveio
	close io
	if argcnt<2 {
		quit $LB("ERR","Insufficient args returned - expected 2, got "_argcnt)
	}
	if arg(1)="ERR",arg(2)["instance not found",command="ISC2QUERYINS" {
		s command="ISC1QUERYINS"
		goto again
	}
	if mirname'=""&&(arg(1)="OK")&&(command=$s($zv["IRIS":"ISC2QUERYINS",1:"ISC1QUERYINS")) {
		s x=$$TEST(mirname,ip_"|"_port,"",arg(2))
		if '$LG(x)&&($LG(x,3)[("Mirror name "_mirname_" could not be found in memory")||($LG(x,3)[("Mirror name "_mirname_" is not configured"))) {
			s command=$s($zv["IRIS":"ISC1QUERYINS",1:"ISC2QUERYINS")
			goto again
		}
	}
	quit $LB("OK",arg(1),arg(2))		   
err ;
	s $zt=""
	s errtext="Unexpected error: "_$ZE
fail ;	
	use saveio
	close io 
	quit $LB("ERR",errtext)
}
GetStatus(mirname,index,timeout=5) PUBLIC {
	s info=$G(^SYS("MIRRORSET",mirname,"Member",index))
	if info="" {
		quit $LB("ERR",0,"Missing "_$name(^SYS("MIRRORSET",mirname,"Member",index)))
	}
	s addrlist=$$BuildAgentAddrlist(info)
	s targguid=$LG(info,2)
	s basedir=$LG(info,6)
	s status=$$GetStatusByAddr(mirname,addrlist,targguid,basedir,timeout)
	quit status
}
GetStatusByAddr(mirname,addrlist,targguid,basedir,timeout=5) PUBLIC {
	; Purpose: Determine the status of Cache' on another mirror member
	;          Used when a node is starting up and it needs to determine whether
	;          it is the only mirror member running as if so, it wants to become
	;          the primary if it can. Also used on running mirror members to determine
	;          the state of the mirror (eg. is the primary up and running, etc...).
	;
	; Returns: Success: $LB(<state>,[<state dependent args...>...])
	;            where  state = "PRIMARY",<jrncnt>,<troubleflag>,<failovermode>,<systemGUID>
    ;                                      the node is the active primary server and
	;                                      jrnfilecnt is current mirror journal
	;                                      file count. troubleflag is gmirrortrouble flag which could
	;                                      be 1 if the primary is waiting in trouble state (if 2 then it
	;                                      would report hung) and failovermode is arbiter v. agent mode.
	;                                      systemguid is $SYSTEM.ECP.SystemGUID() which we use to detect
	;                                      loopbacks in the network tables to avoid thinking there are two
	;                                      primaries because the other address loops back to us.
	;                           "UP",<jrnfilecnt>
	;                                      cache is up, the system is not an active backup nor is
	;                                      it the primary. It could be a backup which is
	;                                      catching up, it could be hung. jrnfilecnt is from 
	;                                      the last file in the mirror journal log
	;                           "DOWN",<jrnfilecnt>
	;                                      Cache' is not running. jrnfilecnt is from the last 
	;                                      file in the mirror journal log
	;                           "HUNG",<jrncnt>,<reason>
	;                                      Node is the primary but something is wrong
	;                                      jrnfilecnt is the current mir journal file count,
	;                                      <reason> is why the node is considered hung
	;                           "TIMEOUT",0
	;                                      Timed out trying to open a connection to
	;                                      the othe rnode. jrnfilecnt is 0
	;                           "ERR",0,<reason>
	;                                      some error occured trying to talk to
	;                                      or while talking to the server. We don't know what
	;                                      its status is. jrnfilecnt is 0 (this matches the format
	;                                      from HUNG)
	s $zt="err"
	s saveio=$I
	s io=""
	s nextlogmsg=60
	s loopcnt=0
retry ;
	s rc=$$tcpopen(mirname,addrlist,targguid,basedir,timeout,,2)
	if +rc {
		; GetStatus() returns "TIMEOUT" if we timeout trying to 
		; establish a connection to the remote node. All other
		; errors return $LB("ERR",<reason>")
		if +rc=1 quit $LB("TIMEOUT",0)
		if +rc=3 quit $LB("LOCALSSLERR",0,$P(rc,",",2,999))
		if +rc=4 quit $LB("SSLERR",0,$P(rc,",",2,999))
		quit $LB("ERR",0,$P(rc,",",2,999))
	}
	s io=$P(rc,",",2),version=+$P(rc,",",3)
	use io
	do tcpsend(io,$LB("STATUS",""))
	s rc=$$tcpread(io)	
	;returns $LB(OK,<result>,...)
	;    <status> = ERR - something unexpected happened, 2nd element is <text>
	;    <status> = OK,<result> = success, <result> has more details
	s status=$LG(rc)
	if status'="OK" {
		c io 
	 	use saveio
	    q $LB("ERR",0,$LG(rc,2))
	}
	do tcpclose(io)
	s io=""
	s result=$LG(rc,2)
	if $lg(result)="TRANSIT" {
		s transittime=$lg(result,3)
		if transittime>300 {
			quit $LB("HUNG",$lg(result,2),"Transition timeout expired")
		}
		s loopcnt=loopcnt+1
		if (loopcnt>nextlogmsg) {
			d $zu(9,"","GetStatus() waiting for transition state to clear or timeout to expire (elapsed time = "_(nextlogmsg/60)_" minutes, current transition time = "_transittime_" seconds)",0,0  /* Informational message */)
			; after 5 minutes, generate a message every 5 minutes
			if nextlogmsg<300 {
				s nextlogmsg=nextlogmsg+60
			} else {
				s nextlogmsg=nextlogmsg+300
			}
		}
		h 1  ;we expect the other node to become the primary
		goto retry
	}
	use saveio 
	quit result ; $LL(result) is 2 or 3 depending on msg type
err ;
	s $zt=""
	use saveio 
	if io'="" c io
	quit $LB("ERR",0,$ZE)		
}
SetApproval(mirname,index,memberinfo) PUBLIC {
	s info=$G(^SYS("MIRRORSET",mirname,"Member",index))
	if info="" {
		quit $LB("ERR","Missing "_$name(^SYS("MIRRORSET",mirname,"Member",index)))
	}
	s addrlist=$$BuildAgentAddrlist(info)
	s targguid=$LG(info,2)
	s basedir=$LG(info,6)
	s status=$$SetApprovalByAddr(mirname,addrlist,targguid,basedir,memberinfo)
	quit status
}
SetApprovalByAddr(mirname,addrlist,targguid,basedir,memberinfo) PUBLIC {
	s $zt="err"
	s saveio=$I
	s io=""
	s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,0,2)
	if +rc {
		if +rc=1 quit $LB("TIMEOUT")
		quit $LB("ERR",$P(rc,",",2,999))
	}
	s io=$P(rc,",",2),version=+$P(rc,",",3)
	use io
	do tcpsend(io,$LB("SETAPPROVAL",$LB(mirname,memberinfo)))
	s rc=$$tcpread(io)	
	;returns $LB(OK,<result>,...)
	;    <status> = ERR - something unexpected happened, 2nd element is <text>
	;    <status> = OK,<result> = success, <result> has more details
	s status=$LG(rc)
	if status'="OK" {
		c io 
	 	use saveio
	    q $LB("ERR",$LG(rc,2))
	}
	do tcpclose(io)
	s io=""
	s result=$LG(rc,2)
	use saveio 
	quit result
err ;
	s $zt=""
	use saveio 
	if io'="" c io
	quit $LB("ERR",$ZE)		
}
RejectApproval(mirname,index,memberinfo) PUBLIC {
	s info=$G(^SYS("MIRRORSET",mirname,"Member",index))
	if info="" {
		quit $LB("ERR","Missing "_$name(^SYS("MIRRORSET",mirname,"Member",index)))
	}
    s mtype=+$LG(info,8)
    if +$LG(info,8)=0 {
		s addrlist=$$BuildAgentAddrlist(info)
		s basedir=$LG(info,6)
    } else {
	    s addrlist=$LG(info,3)
	    s basedir=""
    }
    s targguid=$LG(info,2)
	s status=$$RejectApprovalByAddr(mirname,addrlist,targguid,basedir,memberinfo)
	quit status
}
RejectApprovalByAddr(mirname,addrlist,targguid,basedir,memberinfo) PUBLIC {
	s $zt="err"
	s saveio=$I
	s SSconn=(basedir="")
	if SSconn {
	    s rc=$$EstablishConnection^MIRRORCOMM(mirname,0,$P(addrlist,","),"s",.io,.options,5,0)
		if (rc '= 1) {
			quit $LB("TIMEOUT")
	    }
	} else {
		; Passing sslauth as 0 will bypass the GUID check
		s io=""
		s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,0,2)
		if +rc {
			if +rc=1 quit $LB("TIMEOUT")
			quit $LB("ERR",$P(rc,",",2,999))
		}
		s io=$P(rc,",",2),version=+$P(rc,",",3)
	}
	use io
	do tcpsend(io,$LB("REJAPPROVAL",$LB(mirname,memberinfo),targguid))
	s rc=$$tcpread(io)	
	;returns $LB(OK,<result>,...)
	;    <status> = ERR - something unexpected happened, 2nd element is <text>
	;    <status> = OK,<result> = success, <result> has more details
	s status=$LG(rc)
	if status'="OK" {
		if SSconn { close io } else { d tcpclose(io) } 
	 	use saveio
	    q $LB("ERR",$LG(rc,2))
	}
	if SSconn { close io } else { d tcpclose(io) }
	s io=""
	s result=$LG(rc,2)
	use saveio 
	quit result
err ;
	s $zt=""
	use saveio 
	if $d(io) if SSconn { close io } else { d tcpclose(io) }
	quit $LB("ERR",$ZE)		
}
CheckRequiredDatabases(mirname,index) PUBLIC {
	s $zt="err"
	s saveio=$I
	;
	s info=$G(^SYS("MIRRORSET",mirname,"Member",index))
	if info="" {
		quit $LB("ERR","Missing "_$name(^SYS("MIRRORSET",mirname,"Member",index)))
	}
	s addrlist=$$BuildAgentAddrlist(info)
	s targguid=$LG(info,2)
	s basedir=$LG(info,6)
	;
	s io=""
	s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,1,2)
	if +rc {
		if +rc=1 quit $LB("TIMEOUT")
		quit $LB("ERR",$P(rc,",",2,999))
	}
	s io=$P(rc,",",2),version=+$P(rc,",",3)
	use io
	do tcpsend(io,$LB("CHKREQUIREDDBS"))
	s rc=$$tcpread(io)	
	;returns $LB(OK,<result>,...)
	;    <status> = ERR - something unexpected happened, 2nd element is <text>
	;    <status> = OK,<result> = success, <result> has more details
	s status=$LG(rc)
	if status'="OK" {
		c io 
	 	use saveio
	    q $LB("ERR",$LG(rc,2))
	}
	do tcpclose(io)
	s io=""
	s result=$LG(rc,2)
	use saveio 
	quit result
err ;
	s $zt=""
	use saveio 
	if io'="" c io
	quit $LB("ERR",$ZE)		
}
ValidateLocalInstance(mirname) PUBLIC {
	s saveio=$I
	s id=0
	s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
	if info="" {
		quit $LB("ERR",0,"Missing "_$name(^SYS("MIRRORSET",mirname,"Member",id)))
	}
	s targguid=$LG(info,2)
	s basedir=$LG(info,6)
		s mgrdir=basedir_"mgr"
	s mgrdir=$ZU(12,mgrdir) ; canonize it
	S locmgr=$ZU(12)
	if mgrdir'=locmgr {
		quit $LB("BADDIR","Local manager's directory """_locmgr_""" does not match base directory """_basedir_""" in the mirror configuration")
	}
	;
	s rc=$$EstablishConnection^MIRRORCOMM(mirname,0,id,"v",.io,"",2,0)
	if (rc '= 1) quit $LB("TIMEOUT",info)
	s GUID=$SYSTEM.Util.CreateGUID()
	s ^SYS("MIRRORSET",mirname,"MemberZeroGUID",$J)=GUID
	use io
	do tcpsend(io,$LB("FETCHMEMBERZEROGUID",$LB(mirname,$J),targguid))
	s rc=$$tcpread(io)
	close io
 	use saveio
 	;
	s status=$LG(rc)	 ; status of the read
	if status'="OK" {
	    q $LB("ERR",0,$LG(rc,2))
	}
	s result=$LG(rc,2)
	s status=$LG(result) ; status of FETCHMEMBERZEROGUID()
	if status'="OK" {
	    q $LB("ERR",0,$LG(result,2))
	}
	s remguid=$LG(result,2)
	s remmgr=$LG(result,3) ;$ZU(12) from remote system
	zk ^SYS("MIRRORSET",mirname,"MemberZeroGUID",$J)
	if remguid'=GUID {
		quit $LB("BADADDR","Remote guid /"_remguid_"/ does not match expected value of /"_GUID_"/")
	}
	if locmgr'=remmgr {
		quit $LB("BADADDR","Remote manager's db """_remmgr_""" does not match local manager's db """_locmgr_"""")
	}
	;
	quit $LB("OK")
}
GetJournalInfo(mirname,id,code,arg="",timeout=5,TryAgent=0) PUBLIC {
	; Purpose: Return information from the mirror journal log or from
	;          journal files themselves from this mirror member.
	;          Function codes: 1 - get min/max/maxvalid jrnfile counts of files that exist. 
	;                              arg is ignored  
	;                          2 - return up to 16KB of information from 
	;								$SYSTEM.Mirror.GetJournalFileByMjrncnt() 
	; 	                            starting at the jrncnt specified by 'arg'.
	;                          3 - return $LB(loginfo,hdrinfo) for journal file 
	;                               specified by arg where loginfo comes from
	;  								$SYSTEM.Mirror.GetJournalFileInfo() and header
	;                               info comes from $$$JRNHDRALL. arg is the journal
	;                               file count we want information about. 0 gets
	;                               us info on the 1st file listed in the log. The
	;                               header info can be "0" if the file is in the log
	;                               but not on disk.
	;                          4 & 5 - return jrnfilecnt of minimum required journal file
	;                               for this node. This is the earliest tp rollback point
	;                               of a mirrored db or the the journal file we have which
	;                               isn't validated - which ever is less. Also returns the 
	;                               value of^MIRROR(<mirname>,"LastConnected") which is the
	;                               last time this node was a mirror member as the primary or a backup
	;                               Function 4 returns $LB("DBINFO",<
	;                          6 - +$G(^MIRROR(<mirname>,"LastJrnfileValidated"),0) [JO2434]
	;                          7 - return GetMaxDBJrnInfo (jrnfilecnt/jrnfilepos of maximum "up to 
	;							    date as of" point. Used when setting the valid end of a journal 
	;                               to detect a journal file which is shorter than it should be [JO2478]
	;  
	; Returns; $LB("OK",$LB(value)) where <value> is a function dependent result
	;          $LB("NOTFOUND") - function 3 didn't find journal file count in log
	;          $LB("ERR",<reason>)
	;
	; See GetJRNINFO for structure of values returned from the various subfunctions
	;
	s $zt="err"
	s saveio=$I
	s io=""
	s info=id
	if id?.N {
		s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
	}
    if info="" {
	    d $zu(9,"","GetJournalInfo failed to locate information about "_mirname_" member id #"_id,1 /* broadcast and log message*/,1  /* Warning */)
	    quit $LB("ERR","Failed to find Member info for node #"_id_" in "_mirname)
    }
    if code=4 || (code=5) s arg=$LG(^SYS("MIRRORSET",mirname,"Member",0))
    s mtype=+$LG(info,8)
    if TryAgent,mtype=2 {
	    s addrlist = $LG(info,5)
    } else {
	    s TryAgent = 0
	    if mtype'=0 g superserver
		s addrlist=$$BuildAgentAddrlist(info)
    }
	s targguid=$LG(info,2)
    s basedir=$lg(info,6)
	s rc=$$tcpopen(mirname,addrlist,targguid,basedir,timeout,,2)
	if TryAgent,+rc=1 goto superserver
	if +rc quit $LB($s(+rc=3:"LOCALSSLERR",+rc=4:"SSLERR",1:"ERR"),$P(rc,",",2,999))
	s io=$P(rc,",",2),version=+$P(rc,",",3)
	use io
	do tcpsend(io,$LB("GETJRNINFO",$LB(mirname,code,arg)))
	s rc=$$tcpread(io)	
	;returns $LB(OK,<result>,...)
	;    <status> = ERR - something unexpected happened, 2nd element is <text>
	;    <status> = OK,<result> = success, <result> has more details
	s status=$LG(rc)
	if status'="OK" {
		c io 
		use saveio
	    q $LB("ERR",$LG(rc,2))
	}
	do tcpclose(io)
	use saveio 
	s result=$LG(rc,2)
	quit result ; $LL(result) is 2 or 3 depending on msg type
superserver ;
    s name=$lg(info,1)
	s targguid=$LG(info,2)
    s status=$$EstablishConnection^MIRRORCOMM(mirname,0,id,"s",.io,.options,timeout)
	if (status '= 1) {
		d $zu(9,"","GetJournalInfo failed to open connection to "_mirname_":"_name,1 /* broadcast and log message*/,1  /* Warning */)
		s rc=$LB("ERR","Failed to open connection to "_name)
		quit rc
    }
    s msg=$LB("GETJRNINFO",$LB(mirname,code,arg),targguid)
    do tcpsend(io,msg)
    s resp=$$tcpread(io)
	c io
	use saveio 
	if $LG(resp)'="OK" quit $LB("ERR",$LG(resp,2))
	q $LG(resp,2)
err ;
	s $zt=""
	c:io'="" io s io=""
	use saveio
	quit $LB("ERR",$ZE)		
}
GetMissingJournalFiles(mirname,index,first,startbyte,last,array,ValidEndRequired=0,TryAgent=0) PUBLIC {
	; Purpose: Called when there aren't any other mirror members running
	;          and we need to become the primary but we don't have all the
	;          journal data we need yet. We know the mirror journal sequence
	;          # of the last file we have and the GetStatus() message will tell
	;          us the highest journal file a given member has, even when it is
	;          is down. Based on these we can figure out how many journal files
	;          we need to get up to date. Here we request journal files by # since
	;          we don't know their names. If we have part of a journal file we
	;          can tell the server how much we have and it will send us the rest
	;          rather than the entire file. 
	;
	;          ValidEndRequired must be set to 1 if this is an async member connecting
	;	       to a failover member and we're not connecting to the primary. It is
	;          very important that an async member doesn't connect to the backup, or 
	;          to a failover member which is down and specify this as zero or we may 
	;          receive journal data which is not 'committed' by the mirror yet (JO2624)
	;
	; 	       Any time we retrive a file beyond the end of the current log,
	;	       $SYSTEM.Mirror.GetJournalFileFromAgent() adds it to the end of the
	;          log.
	;
	;		   Also used when we're starting up and we find we're missing part of
	;          a file we should have.
	;
	;		   array is passed by reference. If its passed, the value of the scalar
	;          should be 1 to indicate we want the files retrieved loaded into the
	;          array: array(<mir seq #>) = <filename>,<mir seq #>,<guid>,<timestamp>
	; 		   This is used when we're retrieving journal files that preceed the end
	; 		   of the log because $SYSTEM.Mirror.GetJournalFileFromAgent() only adds
	;          files to the log when they can be appended; when they come after the last
	;          file in the log. We'll rewrite the entire log with the new files added
	;          in at the start.
	;
	; Returns: Success: $LB("OK")
	;          Failure: $LB("ERR",reason)
	s $zt="err"
	s info=$G(^SYS("MIRRORSET",mirname,"Member",index))
	if info="" quit $LB("ERR","Missing "_$name(^SYS("MIRRORSET",mirname,"Member",index)))
    if TryAgent,$LG(info,8)=2 {
	    s addrlist = $LG(info,5)
	    goto Agent
    } else {
	    s TryAgent = 0
    }
SuperServer ;
	if ($LG(info,8)'=0) {
		s jrnfile=$SYSTEM.Mirror.GetJournalFileByMjrncnt(first,mirname)
		s jrnfile=$s('+jrnfile:"",1:$P(jrnfile,",",2))
		if jrnfile'="" {
			s fd=$zu(78,5,jrnfile,0)
			if fd'<0 {
				if startbyte=0 {
			    	s startbyte=65536*2
			    	s origpos=0
				} else {
					do $zu(78,7,fd)
					s origpos=startbyte
				}
			} else {
				s startbyte=0
				s origpos=0
			}
		} else {
			s startbyte=0
			s origpos=0
		}
		i origpos=0 s origpos=65536*2
		quit $$GetJournalFilesFromAsync^MIRRORCOMM(mirname,index,jrnfile,startbyte,origpos,first,last,.array)
	}
	s addrlist=$$BuildAgentAddrlist(info)
Agent ;
	s targguid=$LG(info,2)
	s basedir=$LG(info,6)
	s saveio=$I
	if '$D(array) s array=0
	for filecnt=first:1:last {
		Lock +^%ISC.FetchMirrorFile(filecnt):2
		i '$T {
			s rc=$LB("ERR","File #"_filecnt_" is currently retrieved by another job")
			quit
		}
		s FileLocked=1
		d $zu(9,"","Retrieving journal file #"_filecnt_" for mirror "_mirname_" from "_addrlist,0,0  /* Informational message */)
		s rc=$$tcpopen(mirname,addrlist,targguid,basedir,$s(TryAgent:2,1:5),,2)
		if +rc {
			if TryAgent,+rc=1 {
				Lock -^%ISC.FetchMirrorFile(filecnt)
				k FileLocked
				s TryAgent = 0
				goto SuperServer
			}
			s rc=$LB($s(+rc=3:"LOCALSSLERR",+rc=4:"SSLERR",1:"ERR"),$P(rc,",",2,999))
			Lock -^%ISC.FetchMirrorFile(filecnt)
			k FileLocked
			quit
		}
		s io=$P(rc,",",2)
		use io
		s cmpmode=##class(SYS.MirrorConfiguration).GetCompressionMode(mirname,##class(Config.MirrorMember).isAsyncMember(),1)
		s ValidEndRequiredSet=(''ValidEndRequired)+(''TryAgent*2)
		s numblk=$G(^MIRROR(mirname,"NumberOfBlocksForAgentTransfer"),512)
		s NumAIOBuf=$G(^MIRROR(mirname,"AgentAIOBufNum"),4)
		s rc=$SYSTEM.Mirror.GetJournalFileFromAgent(filecnt, startbyte, mirname,cmpmode, numblk, ValidEndRequiredSet, NumAIOBuf)
		Lock -^%ISC.FetchMirrorFile(filecnt) k FileLocked
		do tcpclose(io)
		use 0
		if $LG(rc)="ERR"&&($LG(rc,2)="RemoveAndRetrieve") {
			d $zu(9,"","GetMissingJournalFiles: Remove file #"_filecnt_" ("_$LG(rc,3)_") and re-retrieve it again due to mismatched encryption key",0,0  /* Informational message */)
			s rcx=$ZU(78,23,$LG(rc,3))
			if 'rcx {
				d $zu(9,"","GetMissingJournalFiles: Failed to remove file "_$LG(rc,3),1 /* broadcast and log message*/,1  /* Warning */)
				quit
			}
			s startbyte = 0
			s filecnt=filecnt-1  ; reduce it so it can be incremented in the for loop.
			continue
		}
		quit:$LG(rc)'="OK"
		s fname=$lg(rc,2)
		s jrninfo=""
		if +$G(array) {
			/* Return the string for the log file in the array. */
			s jrninfo=$zu(78,22,fname,99)
			if +jrninfo'=1 {
				s rc=$LB("ERR","Failed to get journal header info") Quit
			}
			s jcnt=$P(jrninfo,",",13+1)
			if jcnt'=filecnt {
				s rc=$LB("ERR","Journal count mis-match, "_jcnt_" in file vs. "_filecnt_" in reuqest") Quit
			}
			s jguid=$P(jrninfo,",",7+1)
			s array(filecnt)=fname_","_jcnt_","_jguid_","_$zdate($h,3)_" "_$ztime($p($h,",",2),1)
		}
		if $ZU(69,86) {
			;journal file compression is enabled & its not the last file
		    s:jrninfo="" jrninfo=$zu(78,22,fname,99)
			s cengine=+$P(jrninfo,",",25+1)
			s validend=+$P(jrninfo,",",16+1) ;will be zero if '+jrninfo
			do:'cengine&validend compressone^JRNZIP(fname)
		}
		s startbyte = 0  ;after 1st file, we request the entire file
		if $zu(61,10,$zu(61))=44,$G(^MIRROR(mirname,"Status","MGR"))="Exit" {
			s rc=$LB("ERR","Mirror shutting down") Quit
		}
	}
	use saveio 
	quit rc  ;$LB("OK") or $LB("ERR",<reason>)
err ;
	s $zt=""
	c:$d(io) io
	Lock:$G(FileLocked) -^%ISC.FetchMirrorFile(filecnt)
	use:$d(saveio) saveio
	quit $LB("ERR",$ZE)		
}
GetJournalEnd(mirname,index,guid,filecnt) PUBLIC {
	; Purpose: Called while validating journal files when a mirror member
	;          is starting up and one or more of its journal files don't have
	;          valid end points. Either the node was the primary the last time
	;          it was running or it was a backup which shut down before the
	;          primary did (eg. it never became the active primary).
	;
	; Returns: Success: $LB(1,<validflag>,<endoff>,<sysguid of creator>)
	;                             <validflag> = 2 if this system is still
	;                               writing to this file
	;                   $LB(0) - Journal file never received/requested
	;                              by this system (eg. hasn't gotten there yet)
	;                   $LB(-1,<text>) = unexpected error
	s $zt="err"
	s saveio=$I
	s info=$G(^SYS("MIRRORSET",mirname,"Member",index))
	if info="" quit $LB("ERR","Missing "_$name(^SYS("MIRRORSET",mirname,"Member",index)))
	s addrlist=$$BuildAgentAddrlist(info)
	s targguid=$lg(info,2)
	s basedir=$LG(info,6)
	s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
	if +rc quit $LB(-1,$P(rc,",",2,999))
	s io=$P(rc,",",2),version=+$P(rc,",",3)
	use io
	do tcpsend(io,$LB("GETJRNEND",$LB(filecnt,guid)))
	s rc=$$tcpread(io)	
	;returns $LB(OK,<result>,...)
	;    <status> = ERR - something unexpected happened, 2nd element is <text>
	;    <status> = OK,<result> = success, <result> has more details
	;      <result> = NOTFOUND means the journal file is beyond the end of the
	;                  journal log
	;      <result> = OK means the backup has the journal file. Also returns 4 other
	;                 pieces: <validflag>,<endoff>,<datablk>.
	;                    <validend> indicates whether the end of the file is marked 
	;				                valid. If it isn't valid then the highest "end" 
	;					   	 	    in the mirror is ok to use. If it is valid then 
	;							    this is the "end" in the mirror. <validend> is set
	;                               to 2 if this system is still writing to this journal
	;                               file.
	;					<endoff> is the ending offset of the journal file ($ZU(78,18,0))
	;					<datablk> is the journal block containing endoff
	s status=$LG(rc)
	if status'="OK" {
		c io 
		use saveio
	    q $LB(-1,$LG(rc,2))
	}
	s result=$LG(rc,2)
	s status=$lg(result) 
	if status="NOTFOUND" {
	   do tcpclose(io)
	   use saveio
	   quit $LB(0)  ;Not in range of log file
	}
	if status["SSLERR"||($LG(result,2)["SSL ID") {
		s $li(result,1)="SSLERR"
		quit result
	}
	if status="ERR" {
		do tcpclose(io)
		use saveio
		quit $LB(-1,$LG(result,2))
	}
	s datablk=""
	if ($LG(result,2)=-1) {
		do tcpclose(io)
		s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
		if +rc quit $LB(-1,$P(rc,",",2,999))
		s io=$P(rc,",",2),version=+$P(rc,",",3)
		u io
		s rc=$SYSTEM.Mirror.GetJournalEndFromAgent(filecnt,$LG(result,3),1)
	    if $LG(rc)=0 {		
			do tcpclose(io)
			use saveio
			quit $LB(-1,$LG(rc,2)) ;$LG(rc,2) is error text
		}
		s offset=$LG(rc,2)
		s datablk=$LG(rc,3)
		s $list(result,2)=0,$list(result,3)=+offset
	}
	do tcpclose(io)
	use saveio
	; $LB(1,<validflag>,<endoff>,<sysguid>,<datablk>)
	quit $LB(1,$LG(result,2),$LG(result,3),$LG(result,4),datablk) 
err ;
	s $zt=""
	c io
	use saveio
	quit $LB(-1,$ZE)		
}
SendJournalEndInfo(mirname,index,guid,filecnt,endoff) PUBLIC {
	; Purpose: Called while validating journal files when a mirror member
	;          is starting up and GetJournalEnd() indicated that the other
	;          mirror member didn't have a valid end for its copy of the journal
	;          file either. Now that we've seen all the copies of this journal file
	;          in the mirror we want to set the valid end across the mirror. This
	;          message goes to the other mirror members so they can write the
	;          valid end point to their copy of the file, assuming they have
	;          at least that much of the file.
	; Returns $LB(0,<text>) = failed
	;         $LB(1) = succeeded
	s $zt="err"
    if +$G(^SYS("MIRRORSET")) {
	    quit $LB(0,"SendJournalEndInfo should not be called by an async member")
    }
	s saveio=$I
	s info=$G(^SYS("MIRRORSET",mirname,"Member",index))
	if info="" quit $LB("ERR","Missing "_$name(^SYS("MIRRORSET",mirname,"Member",index)))
	s addrlist=$$BuildAgentAddrlist(info)
	s targguid=$lg(info,2)
	s basedir=$LG(info,6)
	s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
	if +rc quit $LB(0,$P(rc,",",2,999))
	s io=$P(rc,",",2),version=+$P(rc,",",3)
	use io
	do tcpsend(io,$LB("SETJRNEND",$LB(filecnt,guid,endoff)))
	s rc=$$tcpread(io)	
	s status=$LG(rc)
	if status'="OK" {
		c io 
		use saveio
	    q $LB(0,$LG(rc,2))
	}
	do tcpclose(io)
	use saveio 
	quit $LB(1)
err ;
	s $zt=""
	c io
	use saveio
	quit $LB(0,$ZE)		
}
ForceNodeDown(mirname,index,Restart=0) PUBLIC {
	; Purpose: Called when we're taking over the role of the primary mirror
	;          server and we want to ensure the prior primary is shut down. Also
	;          used if we detect that the current primary is hung to force a
	;          mirror failover or, if the user simply decides they want to force
	;          a node down for some reason (although maybe we should create a shutdown
	; 		   method for that).
	;
	;		   The mirjrncnt/iocomplete/jrnoff returned are the values from the primary
	;          after the force declared a trouble state. iocomplete represents the maximum
	;          amount of journal data which a process on the primary could have considered
	;		   persistent in the journal file. gjrnoff probably includes data not yet
	;          written to the databases (and maybe not to the journal) and is provided in 
	;		   case it becomes interesting to know this value at some point. Currently it is
	;          ignored.
	; 
	; Returns: Success: $LB("OK",mirjrncnt,jrniocomplete,gjrnoff)
	;          Failure: $LB("ERR",text)
	;
	s $zt="err"
	s info=$G(^SYS("MIRRORSET",mirname,"Member",index))
	if info="" quit $LB("ERR","Missing "_$name(^SYS("MIRRORSET",mirname,"Member",index)))
	s addrlist=$$BuildAgentAddrlist(info)
	s targguid=$lg(info,2)
	s basedir=$LG(info,6)
	s rc=$$ForceNodeDownByAddr(mirname,addrlist,targguid,basedir,Restart)
	quit rc
err ;
	s $zt=""
	quit $LB("ERR",$ZE)		
}
ForceNodeDownByAddr(mirname,addrlist,targguid,basedir,Restart=0) PUBLIC {
	s saveio=$I,io=""
	s $zt="err"
	s Restart=0
	s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
	if +rc quit $LB($s(+rc=3:"LOCALSSLERR",+rc=4:"SSLERR",1:"ERR"),$P(rc,",",2,999))
	s io=$P(rc,",",2),version=+$P(rc,",",3)
	use io
	If +$G(^MIRROR(mirname,"NoRestartAfterForceDown")) s Restart=0
	do tcpsend(io,$LB("FORCE",$LB(Restart,$LG($G(^SYS("MIRRORSET",mirname,"Member",0))))))
	s rc=$$tcpread(io)	
	;returns $LB(OK,<result>,...)
	;    <status> = ERR - something unexpected happened, 2nd element is <text>
	;    <status> = OK,<result> = success, <result> has more details
	s status=$LG(rc)
	if status'="OK" {
		c io 
		use saveio
	    q $LB("ERR",$LG(rc,2))
	}
	do tcpclose(io)
	use saveio 
	s result=$LG(rc,2)
	quit result ; result is either $LB("OK",mirfilecnt,jrnoff) or $LB("ERR",text)
err ;
	s $zt=""
	c io
	use saveio
	quit $LB("ERR",$ZE)		
}
ResetTrouble(mirname,index) PUBLIC {
	; Purpose: Called by backup member when it could not take over as primary while
	;          primary is in 'permanent trouble' state.
	;          This request will be sent to hung primary to reset its gmirrortroubleflag
	;          from 2 to 1.
	; 
	; Returns: Success: $LB("OK")
	;          Failure: $LB("ERR",text)
	;
	s $zt="err"
	s saveio=$I
	s info=$G(^SYS("MIRRORSET",mirname,"Member",index))
	if info="" quit $LB("ERR","Missing "_$name(^SYS("MIRRORSET",mirname,"Member",index)))
	s addrlist=$$BuildAgentAddrlist(info)
	s targguid=$lg(info,2)
	s basedir=$LG(info,6)
	s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
	if +rc quit $LB($s(+rc=3:"LOCALSSLERR",+rc=4:"SSLERR",1:"ERR"),$P(rc,",",2,999))
	s io=$P(rc,",",2),version=+$P(rc,",",3)
	use io
	do tcpsend(io,$LB("RESETTROUBLE"))
	s rc=$$tcpread(io)	
	;returns $LB(OK,<result>,...)
	;    <status> = ERR - something unexpected happened, 2nd element is <text>
	;    <status> = OK,<result> = success, <result> has more details
	s status=$LG(rc)
	if status'="OK" {
		c io 
		use saveio
	    q $LB("ERR",$LG(rc,2))
	}
	do tcpclose(io)
	use saveio 
	s result=$LG(rc,2)
	quit result ; result is either $LB("OK") or $LB("ERR",text)
err ;
	s $zt=""
	c io
	use saveio
	quit $LB("ERR",$ZE)		
}
SetAgentContactMode(mirname,index,jrnfilecnt) PUBLIC {
	;
	s $zt="err"
	s saveio=$I
	s info=$G(^SYS("MIRRORSET",mirname,"Member",index))
	if info="" quit $LB("ERR","Missing "_$name(^SYS("MIRRORSET",mirname,"Member",index)))
	s addrlist=$$BuildAgentAddrlist(info)
	s targguid=$lg(info,2)
	s basedir=$LG(info,6)
	s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
	if +rc quit $LB($s(+rc=3:"LOCALSSLERR",+rc=4:"SSLERR",1:"ERR"),$P(rc,",",2,999))
	s io=$P(rc,",",2),version=+$P(rc,",",3)
	use io
	do tcpsend(io,$LB("SETAGENTCONTACTMODE",$LB(jrnfilecnt)))
	s rc=$$tcpread(io)	
	;returns $LB(OK,<result>,...)
	;    <status> = ERR - something unexpected happened, 2nd element is <text>
	;    <status> = OK,<result> = success, <result> has more details
	s status=$LG(rc)
	if status'="OK" {
		c io 
		use saveio
	    q $LB("ERR",$LG(rc,2))
	}
	do tcpclose(io)
	use saveio 
	s result=$LG(rc,2)
	quit result ; $LL(result) is 2 or 3 depending on msg type
err ;
	s $zt=""
	c:$G(io)'="" io s io=""
	use saveio
	quit $LB("ERR",$ZE)		
}
GetLastJournalBlock(mirname,index,filecnt,blockoff,length) PUBLIC {
	; Purpose: Called by backup/async member to get raw content of 
	;		   the last journal block in the specific journal which
	;		   starts at 'blockoff'. 'blockoff' is derived from a prior
	;		   call to get the journal end which indicated that the file
	;		   is encrypted & the server is down so it cannot be decrypted
	;		   on the server.
	; 
	; Returns: Success: $LB("OK",content of the journal block)
	;          Failure: $LB("ERR",text)
	;
	s $zt="err"
	s saveio=$I
	s info=$G(^SYS("MIRRORSET",mirname,"Member",index))
	if info="" quit $LB("ERR","Missing "_$name(^SYS("MIRRORSET",mirname,"Member",index)))
	s addrlist=$$BuildAgentAddrlist(info)
	s targguid=$lg(info,2)
	s basedir=$LG(info,6)
	s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
	if +rc quit $LB(-1,$P(rc,",",2,999))
	s io=$P(rc,",",2),version=+$P(rc,",",3)
	use io
	do tcpsend(io,$LB("GETJRNBLK",$LB(mirname,filecnt,blockoff,length,$SYSTEM.Mirror.IsAsyncMember())))
	s rc=$$tcpread(io)	
	;returns $LB(OK,<result>,...)
	;    <status> = ERR - something unexpected happened, 2nd element is <text>
	;    <status> = OK,<result> = success, <result> has more details
	;      <result> = ENC means the journal file is encrypted need to decrypt it.
	;      <result> = OK means the content of the block is received and it is in the next $list.
	s status=$LG(rc)
	if status'="OK" {
		c io 
		use saveio
	    q $LB("ERR",$LG(rc,2))
	}
	s rc=$SYSTEM.Mirror.GetJournalEndFromAgent(filecnt,blockoff,1)
	if $LG(rc)=0 {		
		do tcpclose(io)
		use saveio
		quit $LB("ERR",$LG(rc,2)) ;$LG(rc,2) is error text
	}
	s offset=$LG(rc,2)
	s datablk=$LG(rc,3)
	do tcpclose(io)
	use saveio
	quit $LB("OK",datablk) 
err ;
	s $zt=""
	c io
	use saveio
	quit $LB("ERR",$ZE)		
}
GetJournalBlock(mirname,index,filecnt,blockoff,length) PUBLIC {
	; Purpose: Called by backup/async member to get raw content of specific journal
	;          block with 'length' bytes in the content.
	; 
	; Returns: Success: $LB("OK",content of the journal block)
	;          Failure: $LB("ERR",text)
	;
	s $zt="err"
	s saveio=$I,io=""
	s info=$G(^SYS("MIRRORSET",mirname,"Member",index))
	if info="" quit $LB("ERR","Missing "_$name(^SYS("MIRRORSET",mirname,"Member",index)))
	s addrlist=$$BuildAgentAddrlist(info)
	s targguid=$lg(info,2)
	s basedir=$LG(info,6)
	s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
	if +rc quit $LB(-1,$P(rc,",",2,999))
	s io=$P(rc,",",2),version=+$P(rc,",",3)
	use io
	do tcpsend(io,$LB("GETJRNBLK",$LB(mirname,filecnt,blockoff,length,$SYSTEM.Mirror.IsAsyncMember())))
	s rc=$$tcpread(io)	
	;returns $LB(OK,<result>,...)
	;    <status> = ERR - something unexpected happened or file is encrypted, 2nd element is <text>
	;    <status> = OK,<result> = success, <result> has more details
	;      <result> = ENC means the journal file is encrypted need to decrypt it.
	;      <result> = OK means the content of the block is received and it is in the next $list.
	s status=$LG(rc)
	do tcpclose(io)
	use saveio
	s io=""
	if status'="OK" {
	    q $LB("ERR",$LG(rc,2))
	}
	s result=$LG(rc,2)
	s status=$lg(result) 
	if status["SSLERR"||((status="ERR")&&($LG(result,2)["SSL ID")) {
		s $li(result,1)="SSLERR"
		quit result
	}
	if status="ERR" {
		s reason=$LG(result,2)
		if reason'["encrypted" {
			quit $LB("ERR",reason)
		}
		s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
		if +rc quit $LB(-1,$P(rc,",",2,999))
		s io=$P(rc,",",2),version=+$P(rc,",",3)
		u io
		s rc=$SYSTEM.Mirror.GetJournalBlockFromAgent(filecnt,blockoff)
		do tcpclose(io)
		use saveio
		s io=""
	    if $LG(rc)=0 {		
			quit $LB(-1,$LG(rc,2)) ;$LG(rc,2) is error text
		}
		;$LG(rc,2) is the base offset of the block
		s datablk=$LG(rc,3)
		if $L(datablk)<length quit $LB(-1,"Datablk fetched from agent is too short ("_$L(datablk)_" out of "_length)
		quit $LB("OK",$E(datablk,1,length))
	}
	if status="ENC" {
		s enckey=$LG(result,2),data=$LG(result,3)
		s data=$zu(78,95,enckey,data,blockoff)
		if data'="" Quit $LB("OK",$E(data,1,length))
		quit $LB("ERR","Failed to decrypt journal block from remote")
	}
	quit $LB("OK",$LG(result,2)) 
err ;
	s $zt=""
	s err=$ZE
	if $L(io) {
		try {
		  use saveio
	c io
		} catch {}
	}
	quit $LB("ERR",err)		
}
ClearLastFileValidFlag(mirname,index,forceBecomePrimary) PUBLIC {
	; Purpose: Called from BecomePrimary just before we create a new
	;          mirror journal file (PrimaryInit) to clear the LastFileValid
	;          flag in the memory of the other mirror member, in case it is
	;          set.
	;
	; Returns: Success: $LB("OK")
	;          Failure: $LB("ERR",text)
	;          old version which doesn't support message: $LB("UNKNCMD")
	;
	s $zt="err"
	s saveio=$I
	s info=$G(^SYS("MIRRORSET",mirname,"Member",index))
	if info="" quit $LB("ERR","Missing "_$name(^SYS("MIRRORSET",mirname,"Member",index)))
	s addrlist=$$BuildAgentAddrlist(info)
	s targguid=$lg(info,2)
	s basedir=$LG(info,6)
	s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
	if +rc=1 quit $LB("OK")  ;Timeout here is ok
	if forceBecomePrimary,+rc=2 {
		if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","ClearLastFileValidFlag treating ERR as Timeout for force become primary")
		quit $LB("OK")
	}
	if +rc quit $LB($s(+rc=3:"LOCALSSLERR",+rc=4:"SSLERR",1:"ERR"),$P(rc,",",2,999))
	s io=$P(rc,",",2),version=+$P(rc,",",3)
	use io
	do tcpsend(io,$LB("CLRLASTFILEVALID"))
	s rc=$$tcpread(io)	
	;returns $LB(OK,<result>,...)
	;    <status> = ERR - something unexpected happened, 2nd element is <text>
	;    <status> = OK,<result> = success, <result> has more details
	s status=$LG(rc)
	if status'="OK" {
		c io 
		use saveio
	    q $LB("ERR",$LG(rc,2))
	}
	do tcpclose(io)
	use saveio 
	s result=$LG(rc,2)
	if $LG(result)["SSLERR"||($LG(result,2)["SSL ID") {
		s $li(result,1)="SSLERR"
		quit result
	}
	if $LG(result)="ERR" {
		s reason=$LG(result,2)
		if $E(reason,1,8)="UNKNCMD:" {
			; We must be talking to an old version which doesn't
			; understand this message.
			quit $LB("UNKNCMD")
		}
	}
	quit result ; result will be either $LB("OK") or $LB("ERR",text)
err ;
	s $zt=""
	if $G(io)'="" {
		c io
	}
	use saveio
	quit $LB("ERR",$ZE)		
}
ClearActiveBackup(mirname,index) PUBLIC {
	; Purpose: Called when a mirror starts up after it verfies that it is
	;          healthy enough to evaluate whether it should try to become
	;          the primary (eg. just about when we're ready to fall into restart)
	;          to clear the active backup flag in the memory of the other
	;          mirror member should it be set. Once this is cleared the other
	;          member needs to talk with this node before it can become the
	;          primary unless it is already in BecomePrimary at the time (in
	;          which case it continues and may become the primary anyway). The
	;          active backup flag was a note that the other node could become
	;          the primary without talking with this node but now that this node
	;          is up and healthy, that isn't necessary any more and, if this node
	;          becomes the primary, would be a bad idea.
	; 
	; Returns: Success: $LB("OK")
	;          Failure: $LB("ERR",text)
	;          old version which doesn't support message: $LB("UNKNCMD")
	;
	s $zt="err"
	s saveio=$I
	s info=$G(^SYS("MIRRORSET",mirname,"Member",index))
	if info="" quit $LB("ERR","Missing "_$name(^SYS("MIRRORSET",mirname,"Member",index)))
	s addrlist=$$BuildAgentAddrlist(info)
	s targguid=$lg(info,2)
	s basedir=$LG(info,6)
	s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
	if +rc=1 {
		;The ForceBecomePrimaryFlag might force us to become the primary
		; without contacting the other node to clear the activebackup flag
		; however in the absence of that, we'll retry until we get in touch
		; with the node
		quit $LB("TIMEOUT")
	}
	if +rc quit $LB($s(+rc=3:"LOCALSSLERR",+rc=4:"SSLERR",1:"ERR"),$P(rc,",",2,999))
	s io=$P(rc,",",2),version=+$P(rc,",",3)
	use io
	do tcpsend(io,$LB("CLRACTIVEBACKUP"))
	s rc=$$tcpread(io)	
	;returns $LB(OK,<result>,...)
	;    <status> = ERR - something unexpected happened, 2nd element is <text>
	;    <status> = OK,<result> = success, <result> has more details
	s status=$LG(rc)
	if status'="OK" {
		c io 
		use saveio
	    q $LB("ERR",$LG(rc,2))
	}
	do tcpclose(io)
	use saveio 
	s result=$LG(rc,2)
	if $LG(result)["SSLERR"||($LG(result,2)["SSL ID") {
		s $li(result,1)="SSLERR"
		quit result
	}
	if $LG(result)="ERR" {
		s reason=$LG(result,2)
		if $E(reason,1,8)="UNKNCMD:" {
			; We must be talking to an old version which doesn't
			; understand this message.
			quit $LB("UNKNCMD")
		}
	}
	quit result ; result will be either $LB("OK") or $LB("ERR",text)
err ;
	s $zt=""
	if $G(io)'="" {
		c io
	}
	use saveio
	quit $LB("ERR",$ZE)		
}
SetMirrorNoFailover(targname,mirname="",MemberToBeSet="") PUBLIC {
	; Purpose: Called as part of "cstop nofailover" which can be executed on
	;          the primary mirror member to shut it down but block the mirror
	;          from failing over. This works via the DefinedPrimary [Mirror]
	;          server. DefinedPrimary is set on each mirror member to the node
	;		   name of the node which must be the primary. This is cleared when
	;		   that node starts up next time or manually via ^MIRROR (or the portal
	; 		   page) via ClearNoFailover().
	; MemberToBeSet is a list of member name to be set with DefinedPrimary name, it
	;          is separate by ",". If it is a null string then it will set all
	;          the members.
	; 
	; Returns: Success: $LB("OK")
	;          Failure: $LB("ERR",text)
	;
	s io=""
	s saveio=$I
	s $zt="err"
	s ValidatedMemberOnly=$s(MemberToBeSet'="":1,1:0)
	if MemberToBeSet="" {
		if $SYSTEM.Mirror.GetInfo()'[",DEFINED," {
			; we're not configured as a mirror member, ignore this request
			quit $LB("OK")
		}
		if targname="",$SYSTEM.Mirror.GetInfo()'[",PRIMARY," {
			quit $LB("ERR","Only the active primary can specify nofailover")
		}
	}
	if mirname="" {
		s mirname=##class(Config.Mirrors).GetMirrorName()
		if mirname="" {
			quit $LB("ERR","Failed to determine mirror name from Config.Mirrors")
		}
	} else {
		s mm=##class(Config.Mirrors).Open(mirname)
		if '$isobject(mm) {
			quit $LB("ERR","Mirror set name "_mirname_" is not configured")
		}
		s mm=""
	}
	s cls=##class(Config.MirrorMember).Open(,,,.rc)
	if ('rc) {
		quit $LB("ERR","Failed to open [MirrorMember] section")
	}
	s membername=cls.SystemName
	s cls=""
 	Set rs=##class(%Library.ResultSet).%New("Config.MapMirrors:List")
 	s rc=rs.Execute(mirname)
 	if ('rc) {
 	 	quit $LB("ERR","Failed to read list of mirror set members for "_mirname_": "_rc)
 	}
 	k memberlist
 	s memberlist=0  ;in case there aren't any other members
	while (rs.Next()) {
	   Set name=rs.Data("Name")
	   if rs.Data("MemberType")'=0 continue
	   if MemberToBeSet'=""&&((","_MemberToBeSet_",")'[(","_name_",")) continue
	   if name'=membername {
	      s addrlist=rs.Data("AgentAddress")_"|"_rs.Data("AgentPort")
	      if rs.Data("MirrorAddress")'=rs.Data("AgentAddress") {
	      	 s addrlist=addrlist_","_rs.Data("MirrorAddress")_"|"_rs.Data("AgentPort")
	      }
	      if (rs.Data("ECPAddress")'=rs.Data("AgentAddress")) &&
	      			(rs.Data("ECPAddress")'=rs.Data("MirrorAddress")) {
	      	 s addrlist=addrlist_","_rs.Data("ECPAddress")_"|"_rs.Data("AgentPort")
	      }
	      s base=rs.Data("InstanceDirectory")
	      s targguid=rs.Data("GUID")
	      s memberlist=$I(memberlist)
	      s memberlist(memberlist)=$LB(name,addrlist,base,targguid)
	   }
	}
	do rs.Close()
	s rs=""
	if $G(targname)="" {
		; defaults to us if not specified.
		s targname=membername
	}
	if ValidatedMemberOnly {
	    if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","Clear ValidatedMember in '"_MemberToBeSet_"' for mirror set '"_mirname_"'")
	} else {
	    if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","Setting defined primary for "_mirname_" mirror to """_targname_"""")
	}
	for i=1:1:memberlist {
	   s name=memberlist(i)
	   s addrlist=$LG(name,2)
	   s basedir=$LG(name,3)
	   s targguid=$lg(name,4)
	   s name=$LG(name)
	   s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
	   if +rc {
		   s rc=$P(rc,",",2,999)
		   goto abort  ;rc = error text, i = # node we failed at
	   }
	   s io=$P(rc,",",2),version=+$P(rc,",",3)
	   use io
	   do tcpsend(io,$LB("SETNOFAILOVER",$LB(targname,mirname,ValidatedMemberOnly)))
	   s rc=$$tcpread(io)	
  	   do tcpclose(io)
	   s io=""
	   ;returns $LB(OK,<result>,...)
	   ;    <status> = ERR - something unexpected happened, 2nd $LIST element is <text>
	   ;    <status> = OK,<result> = success, <result> has more details
	   if $LG(rc)="OK" {
		   s rc=$LG(rc,2)
	   } else {
		   s rc="0,"_$LG(rc)_": "_$LG(rc,2)
	   }
	   if '+rc {
		   s rc=$P(rc,",",2,$L(rc,","))  ; rc = error text, i = node # we failed at
		   goto abort
	   }
	}
	if MemberToBeSet=""  {
		; Great, we got the nofailover flag set on all the
		; other mirror members. Set it on ourselves and we're good to go.
		s cls=##class(Config.Mirrors).Open(mirname,,,.rc)
		if ('rc) {
			s rc="Mirror member '"_membername_"' failed to open Config.Mirrors("_mirname_"), error = /"_$SYSTEM.Status.GetErrorText(rc)_"/"
			s i=memberlist+1 ; +1 because i is the node we failed to send a message to
			goto abort
		}
		s cls.DefinedPrimary=targname
		s rc=cls.%Save()
		if ('rc) {
			s rc="Mirror member '"_membername_"' failed to save Config.Mirrors("_mirname_"), error = /"_$SYSTEM.Status.GetErrorText(rc)_"/"
			s i=memberlist+1 ; +1 because i is the node we failed to send a message to
			goto abort
		}
		s cls=""
	}
	use saveio
	quit $LB("OK")  ;succeeded
err ;
	s $zt=""
	if io'="" c io s io=""
	use saveio
	quit $LB("ERR",$ZE)		
abort ;    
	s origerr=rc
    d $zu(9,"","Failed to set DefinedPrimary flag in mirror"_$C(10,13,9)_rc,1 /* broadcast and log message*/,1  /* Warning */)
	if io'="" c io s io=""
	s end=i-1  ; i is the node we failed to set so end at the one before it
	for i=1:1:end {
	   s name=memberlist(i)
	   s addr=$LG(name,2)
	   s basedir=$LG(name,3)
	   s targguid=$LG(name,4)
	   s name=$LG(name)
	   s rc=$$tcpopen(mirname,addr,targguid,basedir,5)
	   if +rc {
		   s rc=$P(rc,",",2,999)
		   d $zu(9,"","Connection to "_name_" to clear defined primary failed. "_rc,1 /* broadcast and log message*/,1  /* Warning */)
	   } else {
	      s io=$P(rc,",",2),version=+$P(rc,",",3)
	      use io
	      do tcpsend(io,$LB("CLEARNOFAILOVER",$lb(membername,mirname,ValidatedMemberOnly)))
	      s rc=$$tcpread(io)	
	      do tcpclose(io)
	      s io=""
	      ;returns $LB(OK,<result>,...)
	      ;    <status> = ERR - something unexpected happened, 2nd element is <text>
	      ;    <status> = OK,<result> = success, <result> has more details
	      if $LG(rc)="OK" {
		     s rc=$LG(rc)
		  } else {
		     s rc="0,"_$LG(rc)_": "_$LG(rc,2)
	      }
		  if '+rc {
		     s rc=$P(rc,",",2,$L(rc,","))  ; rc = error text, i = node # we failed at
		     d $zu(9,"","Error clearing defined primary on "_name_". Text = "_rc,1 /* broadcast and log message*/,1  /* Warning */)
	      }
	   }
	}
	use saveio
    if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","DefinedPrimary flag reset to clear")
    quit $LB("ERR","Failed to set nofailover state: "_origerr)
}
ClearMirrorNoFailover(reason="",MemberToBeCleared="") PUBLIC {
	; Purpose: Called when DefinedPrimary is set and we want to clear it.
	;          This can be because we're the system defined as the primary
	;          and we're starting up or because the user has made an explicit
	;          request to do this.
	;
	; Reason = "Primary" when called MIRRORMGR because we're becoming the primary
	;          and DefinedPrimary is set or because we're the primary and we set
	;          the no failover flag but now we changed our mind. 
	; 
	; Returns: Success: $LB("OK")
	;          Failure: $LB("ERR",text)
	;
	s io=""
	s saveio=$I
	s $zt="err"
	s cls=##class(Config.MirrorMember).Open(,,.rc)
	if ('rc) {
		quit $LB("ERR","Failed to open [MirrorMember] section")
	}
	s membername=cls.SystemName
	s mirname=##class(Config.Mirrors).GetMirrorName()
	if mirname="" {
		quit $LB("ERR","Failed to determine mirror name from [Mirrors] configuration")
	}
	s cls=##class(Config.Mirrors).Open(mirname,,,.rc)
	if ('rc) {
		quit $LB("ERR","Failed to open [Mirrors] section for "_mirname)
	}
	s curval=cls.DefinedPrimary
	s reason=$zcvt(reason,"L")  ;lowercase for string comparisons
	if reason="primary" {
		if curval="" quit $LB("OK")
		if (curval '= membername) {
		   d $zu(9,"","ClearMirrorNoFailover(""STU"") aborting, current defined primary """_curval_""" is not local node ("""_membername_""")",1 /* broadcast and log message*/,1  /* Warning */)
		   quit $LB("ERR","Local node is not the current defined primary")
		}
	}
 	Set rs=##class(%Library.ResultSet).%New("Config.MapMirrors:List")
 	s rc=rs.Execute(mirname)
 	if ('rc) {
 	 	quit $LB("ERR","Failed to read list of mirror set members for "_mirname_": "_rc)
 	}
	k errlist
	s errlist=0  ;its useful to have the count available
 	k memberlist
 	s memberlist=0  ;avoid errors when there are no other members
	while (rs.Next()) {
	   Set name=rs.Data("Name")
	   if rs.Data("MemberType")'=0 continue
	   if (name'=membername)&&(MemberToBeCleared=""||((","_MemberToBeCleared_",")[(","_name_","))) {
	      s addrlist=rs.Data("AgentAddress")_"|"_rs.Data("AgentPort")
	      if rs.Data("MirrorAddress")'=rs.Data("AgentAddress") {
	      	 s addrlist=addrlist_","_rs.Data("MirrorAddress")_"|"_rs.Data("AgentPort")
	      }
	      if (rs.Data("ECPAddress")'=rs.Data("AgentAddress")) &&
	      			(rs.Data("ECPAddress")'=rs.Data("MirrorAddress")) {
	      	 s addrlist=addrlist_","_rs.Data("ECPAddress")_"|"_rs.Data("AgentPort")
	      }
	      s base=rs.Data("InstanceDirectory")
	      s targguid=rs.Data("GUID")
	      s memberlist=$I(memberlist)
	      s memberlist(memberlist)=$LB(name,addrlist,base,targguid)
	   }
	}
	do rs.Close()
	s rs=""
    if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","Clearing defined mirror primary of """_curval_"""")
    if reason="primary" {
       s newmembername=curval
    } else {
	   s newmembername=""
    }
    s timeout=0
	for i=1:1:memberlist {
	   s name=memberlist(i)
	   s addrlist=$LG(name,2)
	   s basedir=$LG(name,3)
	   s targguid=$lg(name,4)
	   s name=$LG(name)
	   s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
	   if +rc {
		   if +rc=1,MemberToBeCleared="",memberlist=1 s timeout=1
		   s rc=$P(rc,",",2,999)
		   s errlist=$I(errlist)
		   s errlist(errlist)="Failed to connect to "_name_". Error = "_rc
		   continue
	   }
	   s io=$P(rc,",",2),version=+$P(rc,",",3)
	   use io
	   do tcpsend(io,$LB("CLEARNOFAILOVER",$lb(newmembername,mirname,MemberToBeCleared'="")))
	   s rc=$$tcpread(io)	
	   do tcpclose(io)
	   s io=""
	   ;returns $LB(OK,<result>,...)
	   ;    <status> = ERR - something unexpected happened, 2nd element is <text>
	   ;    <status> = OK,<result> = success, <result> has more details
	   if $LG(rc)="OK" {
		   s rc=$LG(rc,2)
	   } else {
		   s rc="0,"_$LG(rc)_": "_$LG(rc,2)
	   }
	   if '+rc {
		   s rc=$P(rc,",",2,$L(rc,","))  ; rc = error text, i = node # we failed at
		   s errlist=$I(errlist)
		   s errlist(errlist)="Failed to clear defined primary on  "_name_". Error = "_rc
	   }
	}
	use saveio
	if curval'=""&&('errlist||(MemberToBeCleared'="")) {
		s cls.DefinedPrimary=""
		s rc=cls.%Save()
		if ('rc) {
			quit $LB("ERR","Failed to save cleared DefinedPrimary flag, rc = "_$System.Status.GetErrorText(rc))
		}
		if reason'="primary" {
		; When we clear the DefinedPrimary flag for some reason other
		; than the primary is starting then s an event to MIRRORMGR 
		; so it re-evaluates whether we should become the primary.
		; ClearNoFailover() does the same thing on the other nodes when
		; it receives this message.
	    d post^MIRRORCOMM(mirname,0,0,"CLRDEFPRIMARY:")
	}
	}
	if errlist {
		s summary=errlist_" errors encountered clearing defined primary flag"
		f i=1:1:errlist s summary=summary_$C(10,13)_errlist(i)
	    quit $LB($s(timeout:"TIMEOUT",1:"ERR"),summary)		
	}
	quit $LB("OK")  ;succeeded
err ;
	s $zt=""
	if io'="" c io s io=""
	use saveio
	quit $LB("ERR",$ZE)		
}
GetDBList(mirname,id,info="",Flag=0) PUBLIC {
	; Purpose: Get the list of mirror database names and the corresponding
	;          local sfn's (for the local db) mounted on a node
	;
	; Returns: Success: $LB(<rc>,multiple copies of [<sfn>^<mirrordbname>])
	;                where  rc = "DOWN" - reached the node but it is down
	;                            "OK" - the node is up, the rest of the list are a set of
	;                                      sfn^dbname pairs
	;                            "TIMEOUT" - timed out trying to reach the node
	;                            "ERR",0,<reason> - some error occured trying to talk to
	;                                       or while talking to the server. We don't know what
	;                                       its status is. jrnfilecnt is 0
	s $zt="err"  
	s saveio=$I
	if $G(info)="" {
	    s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
	    if info="" {
		    d $zu(9,"","GetDBList failed to locate information about "_mirname_" member id #"_id,1 /* broadcast and log message*/,1  /* Warning */)
		    quit $LB("ERR","Failed to find Member info for node #"_id_" in "_mirname)
	    }
	    s SSconn=(+$LG(info,8)'=0)
	} else {
	    s SSconn=(id'<101)
	    if SSconn s id=$lg(info,3) s:id="" SSconn=0
	}
	s targguid=$lg(info,2)
    if SSconn {
	    s status=$$EstablishConnection^MIRRORCOMM(mirname,0,id,"s",.io,.options)
	    if (status = 0) S SSConn=0,addrlist=$LG(info,5) goto tryagent
	    if (status = -2) {
		    quit $LB("TIMEOUT",0)
	    }
		if (status '= 1) {
			s rc=$LB("ERR",0,"Error code "_status_" establishing a connection to "_$lg(info,1))
			quit rc
	    }
    } else {
		s addrlist=$$BuildAgentAddrlist(info)
tryagent s basedir=$lg(info,6)
		s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
		if +rc {
			; Return "TIMEOUT" if we timeout trying to 
			; establish a connection to the remote node. All other
			; errors return $LB("ERR",<reason>")
			if +rc=1 quit $LB("TIMEOUT",0)
			quit $LB($s(+rc=3:"LOCALSSLERR",+rc=4:"SSLERR",1:"ERR"),0,$P(rc,",",2,999))
		}
		s io=$P(rc,",",2)
    }
	use io
	do tcpsend(io,$LB("GETDBLIST",$LB(mirname,Flag),targguid))
	s rc=$$tcpread(io)	
	;returns $LB(OK,<result>,...)
	;    <status> = ERR - something unexpected happened, 2nd element is <text>
	;    <status> = OK,<result> = success, <result> has more details
	s status=$LG(rc)
	if status'="OK" {
		if SSconn { close io } else { d tcpclose(io) }
		use saveio
	    q $LB("ERR",0,$LG(rc,2))
	}
	if SSconn { close io } else { d tcpclose(io) }
	use saveio 
	s result=$LG(rc,2)
	quit result ; $LL(result) is 1 or more depending on msg type
err ;
	s $zt=""
	if $d(io) if SSconn { close io } else { d tcpclose(io) }
	use saveio
	quit $LB("ERR",0,$ZE)		
}
GetNodeInfo(mirname,id,info="") PUBLIC {
	; Purpose: Get the state of the mirror member 
	;
	; Returns: $LB(state,$LB(status),[various parameters depending on node type])
	; Status is the status string returned by $SYSTEM.Mirror.GetInfo(1)
	; The various parameters are similar to what's returned from 
	; $SYSTEM.Mirror.GetInfo(2)
	; For the primary the values are:
	;        mirror journal filecount of current file
	;        current ending offset of current file
	;        <unused> (0)
	;        <unused> (0)
	;        mirror journal file # of transaction rollback search point
	;        journal index of transaction rollback search point
	;        name of current journal file
	; For a backup node the values are:
	;     	mirror journal file # the system is currently receiving
	;       end of journal file written to disk
	;	    mirror journal file # of journal file being restored to dbs
	;       position of last journal checkpoint in file being restore to dbs
	;       mirror journal file # of transaction rollback search point
	;       journal index of transaction rollback search point
	s $zt="err"
	s saveio=$I
	if $G(info)="" {
	    s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
	    if info="" {
		    d $zu(9,"","GetNodeInfo failed to locate information about "_mirname_" member id #"_id,1 /* broadcast and log message*/,1  /* Warning */)
		    quit $LB("ERR","Failed to find Member info for node #"_id_" in "_mirname)
	    }
	    s SSconn=(+$LG(info,8)'=0)
	} else {
	    s SSconn=(id'<101)
	    if SSconn s id=$lg(info,3) s:id="" SSconn=0
	}
	s targguid=$lg(info,2)
    if SSconn {
	    s status=$$EstablishConnection^MIRRORCOMM(mirname,0,id,"s",.io,.options,3)
	    if (status = 0) S SSConn=0,addrlist=$LG(info,5) goto tryagent
	    if (status = -2) {
		    quit $LB("TIMEOUT",0)
	    }
		if (status '= 1) {
			s rc=$LB("ERR",0,"Error code "_status_" establishing a connection to "_$lg(info,1))
			quit rc
	    }
    } else {
		s addrlist=$$BuildAgentAddrlist(info)
tryagent s basedir=$lg(info,6)
		s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
		if +rc {
			; Return "TIMEOUT" if we timeout trying to 
			; establish a connection to the remote node. All other
			; errors return $LB("ERR",<reason>")
			if +rc=1 quit $LB("TIMEOUT",0)
			quit $LB($s(+rc=3:"LOCALSSLERR",+rc=4:"SSLERR",1:"ERR"),0,$P(rc,",",2,999))
		}
		s io=$P(rc,",",2)
    }
	use io
	do tcpsend(io,$LB("GETNODEINFO",$LB(mirname),targguid))
	s rc=$$tcpread(io)	
	;returns $LB(OK,<result>,...)
	;    <status> = ERR - something unexpected happened, 2nd element is <text>
	;    <status> = OK,<result> = success, <result> has more details
	s status=$LG(rc)
	if status'="OK" {
		if SSconn { close io } else { d tcpclose(io) }
		use saveio
	    q $LB("ERR",0,$LG(rc,2))
	}
	if SSconn { close io } else { d tcpclose(io) }
	use saveio 
	s result=$LG(rc,2)
	quit result ; $LL(result) is 1 or more depending on msg type
err ;
	s $zt=""
	if $d(io) if SSconn { close io } else { d tcpclose(io) }
	use saveio
	quit $LB("ERR",0,$ZE)		
}
CheckDBNameInUse(mirname,index,dbname) PUBLIC {
	s info=$G(^SYS("MIRRORSET",mirname,"Member",index))
	if info="" quit $LB("ERR","Missing "_$name(^SYS("MIRRORSET",mirname,"Member",index)))
	s addrlist=$$BuildAgentAddrlist(info)
	s targguid=$lg(info,2)
	s basedir=$LG(info,6)
	s rc=$$CheckDBNameInUseByAddr(mirname,addrlist,targguid,basedir,dbname)
	quit rc
}
CheckDBNameInUseByAddr(mirname,addrlist,targguid,basedir,dbname) PUBLIC {
	; Purpose: Check whether the passed mirror database name is in use
	;          by a mirror member
	; Returns: $LB("NOTFOUND") - dbname not found
	;          $LB("FOUND",<directory>,<Mirror.DBGetInfo(sfn)>,<$zu(49,dirpath>)
	;                               - dbname is in use by the specified db
	;          $LB("TIMEOUT") - failed to contact this node
	;          $LB("ERR",<reason>)
	;
	s $zt="err"
	s saveio=$I
	s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
	if (+rc) {
	   if +rc=1 quit $LB("TIMEOUT",0)
	   quit $LB($s(+rc=3:"LOCALSSLERR",+rc=4:"SSLERR",1:"ERR"),$P(rc,",",2,999))
	}
	s io=$P(rc,",",2),version=+$P(rc,",",3)
	use io
	do tcpsend(io,$LB("LOOKUPDBINFO",$LB(mirname,dbname,1)))
	s rc=$$tcpread(io)	
	;returns $LB(OK,<result>,...)
	;    <status> = ERR - something unexpected happened, 2nd element is <text>
	;    <status> = OK,<result> = success, <result> has more details
	s status=$LG(rc)
	if status'="OK" {
		c io 
		use saveio
	    q $LB("ERR",$LG(rc,2))
	}
	do tcpclose(io)
	use saveio 
	s result=$LG(rc,2)  ;$LB("NOTFOUND") or $LB("FOUND",<directory name>",...)
	quit result ; 
err ;
	s $zt=""
	c io
	use saveio
	quit $LB("ERR",$ZE)		
}
SynchDBInfo(mirname,id,dbname,dbguid,moredb="") PUBLIC {
	s $zt="err"
	s saveio=$I
    s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
    if info="" {
	    d $zu(9,"","SynchDBInfo failed to locate information about "_mirname_" member id #"_id,1 /* broadcast and log message*/,1  /* Warning */)
	    quit $LB("ERR","Failed to find Member info for node #"_id_" in "_mirname)
    }
    s SSconn=(+$LG(info,8)'=0)
	s targguid=$lg(info,2)
    if SSconn {
	    s status=$$EstablishConnection^MIRRORCOMM(mirname,0,id,"s",.io,.options)
	    if (status = 0) S SSConn=0,addrlist=$LG(info,5) goto tryagent
	    if (status = -2) {
		    quit $LB("TIMEOUT",0)
	    }
		if (status '= 1) {
			s rc=$LB("ERR",0,"Error code "_status_" establishing a connection to "_$lg(info,1))
			quit rc
	    }
    } else {
		s addrlist=$$BuildAgentAddrlist(info)
tryagent s basedir=$lg(info,6)
		s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
		if +rc {
			; Return "TIMEOUT" if we timeout trying to 
			; establish a connection to the remote node. All other
			; errors return $LB("ERR",<reason>")
			if +rc=1 quit $LB("TIMEOUT",0)
			quit $LB($s(+rc=3:"LOCALSSLERR",+rc=4:"SSLERR",1:"ERR"),0,$P(rc,",",2,999))
		}
		s io=$P(rc,",",2)
    }
	use io
	s id=-1  ;ignored on receiving end
	do tcpsend(io,$LB("SYNCHDBINFO",$LB(mirname,dbname,dbguid,id,moredb),targguid))
	s rc=$$tcpread(io)	
	s status=$LG(rc)
	if status'="OK" {
		if SSconn { close io } else { d tcpclose(io) }
		use saveio
	    q $LB("ERR",$LG(rc,2))
	}
	if SSconn { close io } else { d tcpclose(io) }
	use saveio 
	s result=$LG(rc,2)
	quit result ; 
err ;
	s $zt=""
	if $d(io) if SSconn { close io } else { d tcpclose(io) }
	use saveio
	quit $LB("ERR",$ZE)		
}
GetDBInfo(mirname,addrlist,targguid,basedir,dbname,function) PUBLIC {
	s $zt="err"
	s saveio=$I
	s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
	if (+rc) {
	   if +rc=1 quit $LB("TIMEOUT",0)
	   quit $LB($s(+rc=3:"LOCALSSLERR",+rc=4:"SSLERR",1:"ERR"),0,$P(rc,",",2,999))
	}
	s io=$P(rc,",",2),version=+$P(rc,",",3)
	use io
	do tcpsend(io,$LB("GETDBINFO",$LB(mirname,dbname,function)))
	s rc=$$tcpread(io)	
	s status=$LG(rc)
	if status'="OK" {
		c io 
		use saveio
	    q $LB("ERR",$LG(rc,2))
	}
	do tcpclose(io)
	use saveio 
	s result=$LG(rc,2)
	quit result ; 
err ;
	s $zt=""
	c io
	use saveio
	quit $LB("ERR",$ZE)		
}
GetMultipleDBInfo(mirname,id,dblist) PUBLIC {
	s $zt="err"
	s saveio=$I
    s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
    if info="" {
	    d $zu(9,"","SynchDBInfo failed to locate information about "_mirname_" member id #"_id,1 /* broadcast and log message*/,1  /* Warning */)
	    quit $LB("ERR","Failed to find Member info for node #"_id_" in "_mirname)
    }
	s addrlist=$$BuildAgentAddrlist(info)
	s targguid=$lg(info,2)
	s basedir=$lg(info,6)
	s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
	if (+rc) {
	   if +rc=1 quit $LB("TIMEOUT")
	   quit $LB($s(+rc=3:"LOCALSSLERR",+rc=4:"SSLERR",1:"ERR"),$P(rc,",",2,999))
	}
	s io=$P(rc,",",2),version=+$P(rc,",",3)
	use io
	do tcpsend(io,$LB("GETMULTIDBINFO",$LB(mirname,dblist)))
	s rc=$$tcpread(io)	
	s status=$LG(rc)
	if status'="OK" {
		c io 
		use saveio
	    q $LB("ERR",$LG(rc,2))
	}
	do tcpclose(io)
	use saveio 
	s result=$LG(rc,2)
	quit result ; 
err ;
	s $zt=""
	c io
	use saveio
	quit $LB("ERR",$ZE)		
}
NewFailOverMember(mirname,id,msg) PUBLIC {
	s $zt="err"
	s saveio=$I
    s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
    if info="" {
	    d $zu(9,"","NewFailOverMember failed to locate information about "_mirname_" member id #"_id,1 /* broadcast and log message*/,1  /* Warning */)
	    quit $LB("ERR","Failed to find Member info for node #"_id_" in "_mirname)
    }
    s SSconn=(+$LG(info,8)'=0)
	s targguid=$lg(info,2)
    if SSconn {
	    s status=$$EstablishConnection^MIRRORCOMM(mirname,0,id,"s",.io,.options)
	    if (status = 0) S SSConn=0,addrlist=$LG(info,5) goto tryagent
	    if (status = -2) {
		    quit $LB("TIMEOUT",0)
	    }
		if (status '= 1) {
			s rc=$LB("ERR","Error code "_status_" establishing a connection to "_$lg(info,1))
			quit rc
	    }
    } else {
		s addrlist=$$BuildAgentAddrlist(info)
tryagent s basedir=$lg(info,6)
		s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
		if +rc {
			; Return "TIMEOUT" if we timeout trying to 
			; establish a connection to the remote node. All other
			; errors return $LB("ERR",<reason>")
			if +rc=1 quit $LB("TIMEOUT",0)
			quit $LB($s(+rc=3:"LOCALSSLERR",+rc=4:"SSLERR",1:"ERR"),$P(rc,",",2,999))
		}
		s io=$P(rc,",",2)
    }
	use io
	s id=-1  ;ignored on receiving end
	do tcpsend(io,$LB("ADDFOMEMBER",$LB(mirname,msg,id),targguid))
	s rc=$$tcpread(io)	
	s status=$LG(rc)
	if status'="OK" {
		if SSconn { close io } else { d tcpclose(io) } 
		use saveio
	    q $LB("ERR",$LG(rc,2))
	}
	if SSconn { close io } else { d tcpclose(io) }
	use saveio 
	s result=$LG(rc,2)
	quit result ; 
err ;
	s $zt=""
	i $d(io) if SSconn { close io } else { d tcpclose(io) }
	use saveio
	quit $LB("ERR",$ZE)		
}
GetDBStatus(mirname,id,sfn,info="") PUBLIC {
	; Purpose: Get the state of a mirrored database from a mirror member 
	; The sfn is the local sfn of the database on the remote node
	;
	; Returns: $LB(state,$LB(status),[various parameters depending on node type])
	s $zt="err"
	s saveio=$I
	if $G(info)="" {
	    s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
	    if info="" {
		    d $zu(9,"","GetDBStatus failed to locate information about "_mirname_" member id #"_id,1 /* broadcast and log message*/,1  /* Warning */)
		    quit $LB("ERR","Failed to find Member info for node #"_id_" in "_mirname)
	    }
	    s SSconn=(+$LG(info,8)'=0)
	} else {
	    s SSconn=(id'<101)
	    if SSconn s id=$lg(info,3) s:id="" SSconn=0
	}
	s targguid=$lg(info,2)
    if SSconn {
	    s status=$$EstablishConnection^MIRRORCOMM(mirname,0,id,"s",.io,.options)
	    if (status = 0) S SSConn=0,addrlist=$LG(info,5) goto tryagent
		if (status '= 1) {
			s rc=$LB("DOWN")
			quit rc
	    }
    } else {
		s addrlist=$$BuildAgentAddrlist(info)
tryagent s basedir=$lg(info,6)
		s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
		if +rc {
			; Return "TIMEOUT" if we timeout trying to 
			; establish a connection to the remote node. All other
			; errors return $LB("ERR",<reason>")
			if +rc=1 quit $LB("TIMEOUT",0)
			quit $LB($s(+rc=3:"LOCALSSLERR",+rc=4:"SSLERR",1:"ERR"),0,$P(rc,",",2,999))
		}
		s io=$P(rc,",",2)
    }
	use io
	do tcpsend(io,$LB("GETDBSTATUS",$LB(sfn),targguid))
	s rc=$$tcpread(io)	
	;returns $LB(OK,<result>,...)
	;    <status> = ERR - something unexpected happened, 2nd element is <text>
	;    <status> = OK,<result> = success, <result> has more details
	s status=$LG(rc)
	if status'="OK" {
		if SSconn { close io } else { d tcpclose(io) }
		use saveio
	    q $LB("ERR",0,$LG(rc,2))
	}
	if SSconn { close io } else { d tcpclose(io) }
	use saveio 
	s result=$LG(rc,2)
	quit result ; $LL(result) is 1 or more depending on msg type
err ;
	s $zt=""
	if $d(io) if SSconn { close io } else { d tcpclose(io) }
	use saveio
	quit $LB("ERR",0,$ZE)		
}
ActivateSSLConfig(mirnameIN) PUBLIC {
	; This is called from AuthorizeSSL (which is called by the Agent)
	; when SSL is enabled for the connection to load the Server side 
	; SSL configuration for mirror connections into memory. 
	; 
	; Returns success/failure
    i '$SYSTEM.Security.Check("%Admin_Secure","USE") q 0  ;failed
    if +$G(^SYS("MIRRORSET")) {
	    s mirname=mirnameIN
	    goto skipname
    }
	s mirname=##class(Config.Mirrors).GetMirrorName()
	if mirname="" {
		quit 0
	}
	s cls=##class(Config.Mirrors).Open(mirname,,,.rc)
	if ('rc) {
		quit 0
	}
skipname
	s config="%MirrorServer"  ;
    Set cls=##class(Security.SSLConfigs).%OpenId(config,,.status)
	i '(''status) {
		quit 0  ;failed to open the config
	}
	i cls.Enabled=0 {
		s cls=""
		quit 0  ;config not active
	}
	s status=cls.Activate()
	s cls=""
	i '(''status) {
		quit 0  ;failed to activate
	}
	quit 1 ;success
}
GetSSLDNField(type="client",category="%Mirror") PUBLIC {
	; opens the %Mirror<type> or %ECP<type> configuration and finds
	; the value of the DN field in the Subject line. This is the
	; name other nodes see us as when we connect via SSL.
	;
	; Type is "server" or "client" for %MirrorServer or %MirrorClient
	;
	; Returns:  $LB(1,<name>)
	;           $LB(0,<error text>)
	;
	s $zt="err"
	; convert type so we capitalize the 1st letter
	s type=$zcvt(type,"l")
	s $E(type,1)=$zcvt($E(type),"U")
	if (type'="Client") && (type '= "Server") {
		quit $LB(0,"Invalid value for node type """_type_"""")
	}
	;
	s sslconfig=category_type
    s x=##class(Security.SSLConfigs).%OpenId(sslconfig,,.rc)
    if '(''rc) {
	    k err 
		Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
		quit $LB(0,err(1))
    }
	s file=x.CertificateFile
  	s x=""
    o file:"R":2
    if '$T {
	    quit $LB(0,"Failed to open certificate file: "_file)
    }
    s begin=0  ;JO2953
	try {
		use file 
		for lines=1:1 {
			read lines(lines) 
			q:$ZEOF
			if lines(lines)["BEGIN" {
				quit:begin  ;Found the end of the 1st certificate, we're done ;JO2953
				s begin=lines
			}
		}
	} catch {
		if $ZE'["<ENDOFFILE>" goto err
	}
    close file
    if begin=0 {
	    quit $LB(0,"Failed to find certificate block in file: "_file)
	}
    s lines=lines-1
	s block=""
  	for i=begin:1:lines s block=block_lines(i)_$C(10)
  	s val=$SYSTEM.Encryption.X509GetField(block,"Subject")
  	if val="" {
	  	quit $LB(0,"Failed to find subject field in certficate file: "_file)
  	}
 	if $l(val)>1024 {
	 	quit $LB(0,"Subject line in file "_file_" is too long (over 1024 characters)")
 	}
  	quit $LB(1,val)
err ;
	s $zt=""
	quit $LB(0,"Unexpected error: "_$ze)
}
RetrieveMirrorConfig(mirname,index) PUBLIC {
	s info=$G(^SYS("MIRRORSET",mirname,"Member",index))
	if info="" quit $LB("ERR","Missing "_$name(^SYS("MIRRORSET",mirname,"Member",index)))
	s addrlist=$$BuildAgentAddrlist(info)
	s targguid=$lg(info,2)
	s basedir=$LG(info,6)
	s rc=$$RetrieveMirrorConfigByAddr(mirname,addrlist,targguid,basedir)
	quit rc
}
RetrieveMirrorConfigByAddr(mirname,addrlist,targguid,basedir) PUBLIC {
	s $zt="err"
	s saveio=$I
	s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,0,2)
	if +rc {
		; GetStatus() returns "TIMEOUT" if we timeout trying to 
		; establish a connection to the remote node. All other
		; errors return $LB("ERR",<reason>")
		if +rc=1 quit $LB("ERR","TIMEOUT")
		quit $LB($s(+rc=3:"LOCALSSLERR",+rc=4:"SSLERR",1:"ERR"),$P(rc,",",2,999))
	}
	s io=$P(rc,",",2),version=+$P(rc,",",3)
	use io
	do tcpsend(io,$LB("GETCONFIGURATION",$LB(mirname)))
	s rc=$$tcpread(io)	
	s status=$LG(rc)
	if status'="OK" {
		c io 
		use saveio
	    q $LB("ERR",$LG(rc,2))
	}
	do tcpclose(io)
	use saveio 
	s rc=$LG(rc,2)
	quit rc  ;$LB(OK,primindex,nodes)  or $LB(xxx,error text)
err s $zt=""
	quit $LB("ERR","Unexpected error: "_$ZE)
}
ListToNode(list,name) Private {
	i $e(name,$l(name))=")" {
		s $e(name,$l(name))=","
	} else {
		s name=name_"("
	}
	s len=$LL(list)
	f i=1:1:len {
		s node=$LG(list,i),sl=$LG(node),tn=name
		f j=2:1:sl+1 s sub=$LG(node,j) s:sub["""" sub=$replace(sub,"""","""""") s tn=tn_""""_sub_""","
		s $e(tn,$l(tn))=")"
		s @tn=$LG(node,sl+2)
	}
}
ListToLocal(list,%array) Public {
	; Same as ListToNode but builds results in a local array passed
	; by reference
	s len=$LL(list)
	f i=1:1:len {
		s node=$LG(list,i),sl=$LG(node),tn="%array("
		f j=2:1:sl+1 s sub=$LG(node,j) s:sub["""" sub=$replace(sub,"""","""""") s tn=tn_""""_sub_""","
		s $e(tn,$l(tn))=")"
		s @tn=$LG(node,sl+2)
	}
}
IsMirrorServiceEnabled() PUBLIC {
	; Invoked by the Agent code when it accepts a connection to
	; determine whether it should proceed or not. If the mirror service
	; is not enabled then the Agent won't process mirror connection requests
	; 
	; Returns 1/0 (for Yes/No)
	s x=##class(Security.Services).%OpenId($ZCVT("%Service_Mirror","L"),.rc)
 	if ('rc) {
	 	quit 0  ;failure
 	}
	s enabled=$S(x.Enabled:1,1:0)
	s x=""
	quit enabled
}
RemoveMemberFromConfig(mirname,id,nametoremove) PUBLIC {
	s $zt="err"
	s saveio=$I
	if $D(^SYS("MIRRORSET",":LocalValidationFailure",mirname)) {
	    quit "0,Cannot remove member from mirror "_mirname_" until validation failure is resolved"
	}
    s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
    if info="" {
	    d $zu(9,"","RemoveMemberFromConfig failed to locate information about "_mirname_" member id #"_id,1 /* broadcast and log message*/,1  /* Warning */)
	    quit $LB("ERR","Failed to find Member info for node #"_id_" in "_mirname)
    }
    s SSconn=(+$LG(info,8)'=0)
	s targguid=$lg(info,2)
    if SSconn {
	    s status=$$EstablishConnection^MIRRORCOMM(mirname,0,id,"s",.io,.options)
	    if (status = 0) S SSConn=0,addrlist=$LG(info,5) goto tryagent
	    if (status '= 1) {
		    quit "0,TIMEOUT"
	    }
    } else {
		s addrlist=$$BuildAgentAddrlist(info)
tryagent s basedir=$lg(info,6)
		s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
		if +rc {
			; Return "TIMEOUT" if we timeout trying to 
			; establish a connection to the remote node. All other
			; errors return $LB("ERR",<reason>")
			if +rc=1 quit "0,TIMEOUT"
			quit "0,"_$P(rc,",",2,999)
		}
		s io=$P(rc,",",2)
    }
	use io
	do tcpsend(io,$LB("DELMEMBER",$LB(nametoremove,mirname),targguid))
	s rc=$$tcpread(io)	
	s status=$LG(rc)
	if status'="OK" {
		if SSconn { close io } else { d tcpclose(io) }
	    use saveio
	    q "0,"_$LG(rc,2)
	}
	if SSconn { close io } else { d tcpclose(io) }
	use saveio
	s rc=$LG(rc,2)
	s status=$LG(rc)
	if status="NOTFOUND" q -1  ;we weren't listed
	i status'="OK" {
		q "0,"_$LG(rc,2)
	}
	quit 1
err ;
	s $zt=""
	use saveio
	if $d(io) if SSconn { close io } else { d tcpclose(io) }
	quit "0,"_$ZE		
}
GetMemberConfigData(mirname,addrlist,targguid,basedir,memberlist="",GetDefinedPrimary=0) PUBLIC {
	s $zt="err"
	s saveio=$I
	s SSconn=(basedir="")
	if SSconn {
	    s rc=$$EstablishConnection^MIRRORCOMM(mirname,0,$P(addrlist,","),"s",.io,.options,5,$s(GetDefinedPrimary||(memberlist'=""&&(memberlist'="**")):1,1:0))
		if (rc '= 1) {
			quit $LB(0,"TIMEOUT")
	    }
	} else {
		; Passing sslauth as 0 will bypass the GUID check
		s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,$s(GetDefinedPrimary||(memberlist'=""&&(memberlist'="**")):1,1:0),2)
		if +rc {
			if +rc=3 quit $LB(0,"LOCALSSLERR")
			if +rc=4 quit $LB(0,"SSLERR")
			quit $LB(0,"Connection failed: "_$P(rc,",",2,999))
		}
		s io=$P(rc,",",2),version=+$P(rc,",",3)
	}
	s:memberlist="**" memberlist="*"
	use io
	do tcpsend(io,$LB("GETMEMBERS",$LB(mirname,memberlist,GetDefinedPrimary),targguid))
	s rc=$$tcpread(io)	
	s status=$LG(rc)
	if status'="OK" {
		if SSconn { close io } else { d tcpclose(io) }
		use saveio
	    q $LB(0,"Network read error: "_$LG(rc,2))
	}
	if SSconn { close io } else { d tcpclose(io) }
	use saveio
	s rc=$LG(rc,2)  ;rc is now $LB("ERR",<text>), $LB("OK",<data>) or $LB("OK-NOTVALID",<data>)
	s val=$LG(rc,2)
	s val2=$LG(rc,3)  ; this is the MirrorMember section info.
	s val3=$LG(rc,4)
	s val4=$LG(rc,5)
	s val5=+$LG(rc,6)   ; This is the UNICODE value on the remote member.
	s val6=+$LG(rc,7)   ; This is the EMSManaged value on the remote member.
	s rc=$LG(rc)
	if rc="OK-NOTVALID" {
		quit $LB(-1,val,val2,val3,val4,val5,val6)
	}
	if rc="OK" {
		quit $LB(1,val,val2,val3,val4,val5,val6)
	}
	quit $LB(0,val)
err ;
	s $zt=""
	use saveio
	if $d(io) if SSconn { close io } else { d tcpclose(io) }
	quit $LB(0,"Unexpected error: "_$ZE)
}
AddMemberToConfig(mirname,addrlist,targguid,basedir,nametoadd,paramarray,NewVer=0) PUBLIC {
	s $zt="err"
	s saveio=$I
	k valuelist
	s index=0
	s p=$O(paramarray(""),1,v)
	if p="" quit $LB(0,"No values specified in parameter array for new member: "_nametoadd)
	do {
		s index=index+1
		s $list(valuelist,index)=$LB(p,v)
	    s p=$O(paramarray(p),1,v)
	} while (p'="")
	s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
	if +rc {
		quit "0,"_$P(rc,",",2,999)
	}
	s io=$P(rc,",",2),version=+$P(rc,",",3)
	use io
	do tcpsend(io,$LB($s(NewVer:"ADDMEMBEX",1:"ADDMEMBER"),$LB(nametoadd,valuelist,mirname)))
	s rc=$$tcpread(io)	
	s status=$LG(rc)
	if status'="OK" {
		c io 
	    use saveio
	    q "0,"_$LG(rc,2)
	}
	do tcpclose(io)
	use saveio
	s rc=$LG(rc,2)  ;$LB("OK") or $LB("ERR",<reason>)
	if $LG(rc)="OK" {
		s rc=1
	} else {
		s rc="0,"_$LG(rc,2)
	}
	quit rc  ;
err ;
	s $zt=""
	use saveio
	c io
	quit "0,"_$ZE
}
GetMirrorConfigData(mirname,addrlist,targguid,basedir) PUBLIC {
	s $zt="err"
	s saveio=$I
	s SSconn=(basedir="")
	if SSconn {
	    s rc=$$EstablishConnection^MIRRORCOMM(mirname,0,$P(addrlist,","),"s",.io,.options)
		if (rc '= 1) {
			quit $LB(0,"TIMEOUT")
	    }
	} else {
		; Passing sslauth as 0 will bypass the GUID check
		s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,0,2)
		if +rc {
			quit $LB(0,"Connection failed: "_$P(rc,",",2,999))
		}
		s io=$P(rc,",",2),version=+$P(rc,",",3)
	}
	use io
	do tcpsend(io,$LB("GETCONFIG2",$LB(mirname),targguid))
	s rc=$$tcpread(io)	
	s status=$LG(rc)
	if status'="OK" {
		if SSconn { close io } else { d tcpclose(io) }
	    use saveio
	    q $LB(0,"Network read error: "_$LG(rc,2))
	}
	if SSconn { close io } else { d tcpclose(io) }
	use saveio
	s rc=$LG(rc,2)
	s val=$LG(rc,2)
	s EMSManaged=$LG(rc,3)
	s rc=$LG(rc)
	if rc="OK" quit $LB(1,val,EMSManaged)
	quit $LB(0,val,EMSManaged)
err ;
	s $zt=""
	use saveio
	if $d(io) if SSconn { close io } else { d tcpclose(io) }
	quit $LB(0,"Unexpected error: "_$ZE)
}
SetRecoveryParameters(mirname,index,qostimeout,rpunused,smunused,ttoutunused,arbiterAddrList,compressmode="") PUBLIC {
	s $zt="err"
	s saveio=$I
	s info=$G(^SYS("MIRRORSET",mirname,"Member",index))
	if info="" quit $LB("ERR","Missing "_$name(^SYS("MIRRORSET",mirname,"Member",index)))
    s targguid=$lg(info,2)
    s SSconn=(+$LG(info,8)'=0)
    if SSconn {
	    s status=$$EstablishConnection^MIRRORCOMM(mirname,0,index,"s",.io,.options,1)
		if (status '= 1) goto useagent
    } else {
useagent
		s addrlist=$$BuildAgentAddrlist(info)
	    s basedir=$lg(info,6)
		s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
		if +rc {
			quit "0,Connection failed: "_$P(rc,",",2,999)
		}
		s io=$P(rc,",",2)
    }
	use io
	do tcpsend(io,$LB("SETRECOVPARAM",$LB(qostimeout,0,2,0,mirname,arbiterAddrList,compressmode)))
	s rc=$$tcpread(io)	
	s status=$LG(rc)
	if status'="OK" {
		if SSconn { close io } else { d tcpclose(io) }
	    use saveio
	    q "0,Network read error: "_$LG(rc,2)
	}
	if SSconn { close io } else { d tcpclose(io) }
	use saveio
	s rc=$LG(rc,2)  ;$LB("OK") or $LB("ERR",<reason>)
	if $LG(rc)="OK" {
		s rc=1
	} else {
		s rc="0,"_$LG(rc,2)
	}
	quit rc  ;
err ;
	s $zt=""
	use saveio
	if SSconn { close io } else { d tcpclose(io) }
	quit "0,"_$ZE
}
GetECPConnectionData(mirname,index,NeedProgagateData) PUBLIC {
	s $zt="err"
	s saveio=$I
	s info=$G(^SYS("MIRRORSET",mirname,"Member",index))
	if info="" quit $LB("ERR","Missing "_$name(^SYS("MIRRORSET",mirname,"Member",index)))
	s addrlist=$$BuildAgentAddrlist(info)
	s targguid=$lg(info,2)
	s basedir=$LG(info,6)
	s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
	if +rc {
		; GetStatus() returns "TIMEOUT" if we timeout trying to 
		; establish a connection to the remote node. All other
		; errors return $LB("ERR",<reason>")
		if +rc=1 quit $LB("ERR","TIMEOUT")
		quit $LB($s(+rc=3:"LOCALSSLERR",+rc=4:"SSLERR",1:"ERR"),$P(rc,",",2,999))
	}
	s io=$P(rc,",",2),version=+$P(rc,",",3)
	use io
	do tcpsend(io,$LB("GETECPCONDATA",$LB(mirname,NeedProgagateData)))
	s rc=$$tcpread(io)	
	s status=$LG(rc)
	if status'="OK" {
		c io 
	    use saveio
	    q $LB("ERR",$LG(rc,2))
	}
	do tcpclose(io)
	use saveio
	s rc=$LG(rc,2)
	quit $LB("OK",rc)  ;$LB(OK,nodes)
err s $zt=""
	c io
	use saveio
	quit $LB("ERR","Unexpected error: "_$ZE)
}
GetMirrorVersion(mirname,index) PUBLIC {
	s $zt="err"
	s saveio=$I
	s info=$G(^SYS("MIRRORSET",mirname,"Member",index))
	if info="" quit $LB("ERR","Missing "_$name(^SYS("MIRRORSET",mirname,"Member",index)))
	s addrlist=$$BuildAgentAddrlist(info)
	s targguid=$lg(info,2)
	s basedir=$LG(info,6)
	s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
	if +rc {
		; GetStatus() returns "TIMEOUT" if we timeout trying to 
		; establish a connection to the remote node. All other
		; errors return $LB("ERR",<reason>")
		if +rc=1 quit $LB("ERR","TIMEOUT")
		quit $LB($s(+rc=3:"LOCALSSLERR",+rc=4:"SSLERR",1:"ERR"),$P(rc,",",2,999))
	}
	s io=$P(rc,",",2),version=+$P(rc,",",3)
	use io
	do tcpsend(io,$LB("GETCACHEMIRRORVER",$LB(mirname)))
	s rc=$$tcpread(io)	
	s status=$LG(rc)
	if status'="OK" {
		c io 
	    use saveio
	    q $LB("ERR",$LG(rc,2))
	}
	do tcpclose(io)
	use saveio
	s rc=$LG(rc,2)
	quit rc  ;$LB("OK",<value>) or $LB("ERR",<text")
err s $zt=""
	c io
	use saveio
	quit $LB("ERR","Unexpected error: "_$ZE)
}
ChangeVirtualAddress(mirname,addrlist,targguid,basedir,Type,IPAddr="",Iface="") PUBLIC {
	s $zt="err"
	s saveio=$I
	s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
	if +rc {
		; GetStatus() returns "TIMEOUT" if we timeout trying to 
		; establish a connection to the remote node. All other
		; errors return $LB("ERR",<reason>")
		if +rc=1 quit $LB("ERR","TIMEOUT")
		quit $LB($s(+rc=3:"LOCALSSLERR",+rc=4:"SSLERR",1:"ERR"),$P(rc,",",2,999))
	}
	s io=$P(rc,",",2),version=+$P(rc,",",3)
	use io
	do tcpsend(io,$LB("CHANGEVIP",$LB(mirname,Type,IPAddr,Iface)))
	s rc=$$tcpread(io)	
	s status=$LG(rc)
	if status'="OK" {
		c io 
		use saveio
	    q $LB("ERR",$LG(rc,2))
	}
	do tcpclose(io)
	use saveio
	s rc=$LG($LG(rc,2))
	quit $LB("OK",rc)  ;$LB(OK,nodes)
err s $zt=""
	c io
	use saveio
	quit $LB("ERR","Unexpected error: "_$ZE)
}
GetAsyncMemberInfo(mirname,id,info="") PUBLIC {
	s $zt="err"
	s saveio=$I
	if $G(info)="" {
	    s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
	    if info="" {
		    d $zu(9,"","GetAsyncMemberInfo failed to locate information about "_mirname_" member id #"_id,1 /* broadcast and log message*/,1  /* Warning */)
		    quit $LB("ERR","Failed to find Member info for node #"_id_" in "_mirname)
	    }
	    if (+$LG(info,8)=0) {
		    d $zu(9,"","GetAsyncMemberInfo called to retrieve info about failover member ("_mirname_" member id #"_id_")",1 /* broadcast and log message*/,1  /* Warning */)
		    s $ZE="<NOT AN ASYNC MEMBER>" 
		    d BACK^%ETN
		    quit $LB("ERR","Node #"_id_" in "_mirname_" is not an async member")
	    }		    
	    s SSconn=1
	} else {
	    if (id<101) {
		    d $zu(9,"","GetAsyncMemberInfo called to retrieve info about failover member ("_mirname_" member id #"_id_")",1 /* broadcast and log message*/,1  /* Warning */)
		    s $ZE="<NOT AN ASYNC MEMBER>" 
		    d BACK^%ETN
		    quit $LB("ERR","Node #"_id_" in "_mirname_" is not an async member")
	    }		    
	    s id=$lg(info,3)
	    s SSconn=(id'="")
	}
    s targguid=$lg(info,2)
    if SSconn {
	    s status=$$EstablishConnection^MIRRORCOMM(mirname,0,id,"s",.io,.options)
	    if (status = 0) S SSConn=0 goto tryagent
	    if (status = -2) {
		    quit $LB("TIMEOUT",0)
	    }
		if (status '= 1) {
			s rc=$LB("ERR",0,"Error code "_status_" establishing a connection to "_$lg(info,1))
			quit rc
	    }
    } else {
tryagent s addr=$lg(info,5)
	    s basedir=$lg(info,6)
		s rc=$$tcpopen(mirname,addr,targguid,basedir,5)
		if +rc {
			; Return "TIMEOUT" if we timeout trying to 
			; establish a connection to the remote node. All other
			; errors return $LB("ERR",<reason>")
			if +rc=1 quit $LB("TIMEOUT",0)
			quit $LB($s(+rc=3:"LOCALSSLERR",+rc=4:"SSLERR",1:"ERR"),0,$P(rc,",",2,999))
		}
		s io=$P(rc,",",2)
    }
	use io
	do tcpsend(io,$LB("GETASYNCINFO",$LB(mirname),targguid))
	s rc=$$tcpread(io)	
	;returns $LB(OK,<result>,...)
	;    <status> = ERR - something unexpected happened, 2nd element is <text>
	;    <status> = OK,<result> = success, <result> has more details
	s status=$LG(rc)
	if status'="OK" {
		if SSconn { close io } else { d tcpclose(io) } 
		use saveio
	    q $LB("ERR",0,$LG(rc,2))
	}
	if SSconn { close io } else { d tcpclose(io) }  ;Always an SScon (Super Server connection)
	use saveio 
	s result=$LG(rc,2)
	quit result 
err ;
	s $zt=""
	i $d(io) if SSconn { close io } else { d tcpclose(io) }
	use saveio
	quit $LB("ERR",0,$ZE)		
}
PromoteToFailover(mirname,addrlist,targguid,basedir,ourname,ourguid,ourtype,CheckConnection=0,DemoteName="") PUBLIC {
	s $zt="err"
	s saveio=$I
	s io=""
	s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
	if +rc {
		; GetStatus() returns "TIMEOUT" if we timeout trying to 
		; establish a connection to the remote node. All other
		; errors return $LB("ERR",<reason>")
		if +rc=1 quit $LB("TIMEOUT")
		quit $LB($s(+rc=3:"LOCALSSLERR",+rc=4:"SSLERR",1:"ERR"),$P(rc,",",2,999))
	}
	s io=$P(rc,",",2),version=+$P(rc,",",3)
	use io
	do tcpsend(io,$LB("PROMOTE",$LB(mirname,ourname,ourguid,ourtype,CheckConnection,DemoteName)))
	s rc=$$tcpread(io)	
	s status=$LG(rc)
	if status'="OK" {
		d tcpclose(io)
	 	use saveio
	    q $LB("ERR",$LG(rc,2))
	}
	do tcpclose(io)
	s io=""
	use saveio 
	quit $LG(rc,2)
err ;
	s $zt=""
	use saveio 
	if io'="" c io
	quit $LB("ERR",$ZE)		
}
DemoteToAsync(mirname,addrlist,targguid,basedir,newfailover,asynctype,StartMirror=0,Standalone=0,DemoteName="") PUBLIC {
	s $zt="err"
	s saveio=$I
	s io=""
	s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
	if +rc {
		; GetStatus() returns "TIMEOUT" if we timeout trying to 
		; establish a connection to the remote node. All other
		; errors return $LB("ERR",<reason>")
		if +rc=1 quit $LB("TIMEOUT")
		quit $LB($s(+rc=3:"LOCALSSLERR",+rc=4:"SSLERR",1:"ERR"),$P(rc,",",2,999))
	}
	s io=$P(rc,",",2),version=+$P(rc,",",3)
	use io
	do tcpsend(io,$LB("DEMOTE",$LB(mirname,newfailover,asynctype,StartMirror,Standalone,DemoteName)))
	s rc=$$tcpread(io)	
	s status=$LG(rc)
	if status'="OK" {
		d tcpclose(io)
	 	use saveio
	    q $LB("ERR",$LG(rc,2))
	}
	do tcpclose(io)
	s io=""
	use saveio 
	quit $LG(rc,2)
err ;
	s $zt=""
	use saveio 
	if io'="" c io
	quit $LB("ERR",$ZE)		
}
NotifyMirrorChange(mirname,id,PrimaryName) PUBLIC {
	s $zt="err"
	s saveio=$I
    s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
    if info="" {
	    d $zu(9,"","NotifyMirrorChange failed to locate information about "_mirname_" member id #"_id,1 /* broadcast and log message*/,1  /* Warning */)
	    quit $LB("ERR","Failed to find Member info for node #"_id_" in "_mirname)
    }
    s targguid=$lg(info,2)
    s SSconn=(+$LG(info,8)'=0)
    if SSconn {
	    s status=$$EstablishConnection^MIRRORCOMM(mirname,0,id,"s",.io,.options,1)
	    if (status = -2) {
		    quit $LB("TIMEOUT",0)
	    }
		if (status '= 1) {
			s rc=$LB("ERR","Error code "_status_" establishing a connection to "_$lg(info,1))
			quit rc
	    }
    } else {
		s addrlist=$$BuildAgentAddrlist(info)
	    s basedir=$lg(info,6)
		s rc=$$tcpopen(mirname,addrlist,targguid,basedir,1,,1)
		if +rc {
			; Return "TIMEOUT" if we timeout trying to 
			; establish a connection to the remote node. All other
			; errors return $LB("ERR",<reason>")
			if +rc=1 quit $LB("TIMEOUT",0)
			quit $LB($s(+rc=3:"LOCALSSLERR",+rc=4:"SSLERR",1:"ERR"),$P(rc,",",2,999))
		}
		s io=$P(rc,",",2)
    }
	use io
	do tcpsend(io,$LB("SYNCHCONFIG",$LB(mirname,PrimaryName),targguid))
	s rc=$$tcpread(io)	
	s status=$LG(rc)
	if status'="OK" {
		if SSconn { close io } else { d tcpclose(io) }
		use saveio
	    q $LB("ERR",$LG(rc,2))
	}
	if SSconn { close io } else { d tcpclose(io) }
	use saveio 
	s result=$LG(rc,2)
	quit result ; 
err ;
	s $zt=""
	if $d(io) if SSconn { close io } else { d tcpclose(io) }
	use saveio
	quit $LB("ERR",$ZE)		
}
GetFailoverTimestamp(mirname,index) PUBLIC {
	s $zt="err"
	s saveio=$I
	s io=""
	s info=$G(^SYS("MIRRORSET",mirname,"Member",index))
	if info="" quit $LB("ERR","Missing "_$name(^SYS("MIRRORSET",mirname,"Member",index)))
	s addrlist=$$BuildAgentAddrlist(info)
    s targguid=$lg(info,2)
	s basedir=$LG(info,6)
retry ;
	s rc=$$tcpopen(mirname,addrlist,targguid,basedir,3,,2)
	if +rc {
		; GetStatus() returns "TIMEOUT" if we timeout trying to 
		; establish a connection to the remote node. All other
		; errors return $LB("ERR",<reason>")
		if +rc=1 quit $LB("TIMEOUT",0)
		quit $LB($s(+rc=3:"LOCALSSLERR",+rc=4:"SSLERR",1:"ERR"),$P(rc,",",2,999))
	}
	s io=$P(rc,",",2),version=+$P(rc,",",3)
	use io
	do tcpsend(io,$LB("MIRRORTIME",$LB(mirname)))
	s rc=$$tcpread(io)	
	;returns $LB(OK,<result>) or $LB(ERR,<reason>)
	s status=$LG(rc)
	if status'="OK" {
		do tcpclose(io)
		use saveio
	    q $LB("ERR",$LG(rc,2))
	}
	do tcpclose(io)
	s io=""
	use saveio 
	s result=$LG(rc,2)
	if $LG(result)["SSLERR"||($LG(result,2)["SSL ID") {
		s $li(result,1)="SSLERR"
		quit result
	}
	if $LG(result)="ERR" {
		s reason=$LG(result,2)
		if $E(reason,1,8)="UNKNCMD:" {
			; We must be talking to an old version which doesn't
			; understand this message.
			quit $LB("UNKNCMD",0)
		}
	}
	quit result
err ;
	s $zt=""
	use saveio 
	if io'="" c io
	quit $LB("ERR",$ZE)		
}
GetLastJournalInfo(mirname) {
	s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
	if +rc<=0 {
nofile	s jrninfo=$lb(0)
	} else {
		s jrnfile=$P(rc,",",2)
		s jrninfo=$$getjrninfo^MIRROR(jrnfile)  ;returns $LB(1,<mirfilecnt>,<jrnend>,<validflag>,
										 ;							<jrnguid>,<createguid>,<mirguid>)
	    if '$LG(jrninfo) {
		    s endfilecnt=+rc-1
		    if endfilecnt<1 goto nofile
		    s filecnt=endfilecnt - 5
		    if filecnt<1 s filecnt=1
		    for i=endfilecnt:-1:filecnt {
			    s jrnfile=$SYSTEM.Mirror.GetJournalFileByMjrncnt(i,mirname)
			    q:'+jrnfile
			    s jrnfile=$P(jrnfile,",",2)
			    s jrninfo=$$getjrninfo^MIRROR(jrnfile)
			    q:$LG(jrninfo)
		    }
	    }					
	    if '$LG(jrninfo) goto nofile
	    ; dont send return code.
	    s jrninfo=$li(jrninfo,2,$ll(jrninfo))
	}
	q jrninfo
}
ValidatePartner(mirname,addrlist,targguid,basedir,membername,memberguid) PUBLIC {
	s $zt="err"
	s saveio=$I
	s jrninfo=$$GetLastJournalInfo(mirname)
	s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
	if +rc=1 {
		;The ForceBecomePrimaryFlag might force us to become the primary
		; without contacting the other node to clear the activebackup flag
		; however in the absence of that, we'll retry until we get in touch
		; with the node
		quit $LB("TIMEOUT")
	}
	if +rc quit $LB($s(+rc=3:"LOCALSSLERR",1:"ERR"),$P(rc,",",2,999))
	s io=$P(rc,",",2),version=+$P(rc,",",3)
	use io
	do tcpsend(io,$LB("VALIDATEPARTNER",$LB(mirname,membername,memberguid,$G(^SYS("MIRRORTIME",mirname)),jrninfo)))
	s rc=$$tcpread(io)	
	;returns $LB(OK,<result>,...)
	;    <status> = ERR - something unexpected happened, 2nd element is <text>
	;    <status> = OK,<result> = success, <result> has more details
	s status=$LG(rc)
	if status'="OK" {
		c io 
		use saveio
	    q $LB("ERR",$LG(rc,2))
	}
	do tcpclose(io)
	use saveio 
	s result=$LG(rc,2)
	if $LG(result)["SSLERR"||($LG(result,2)["SSL ID") {
		s $li(result,1)="UNKNCMD"
		quit result
	}
	if $LG(result)="ERR" {
		s reason=$LG(result,2)
		if $E(reason,1,8)="UNKNCMD:" {
			; We must be talking to an old version which doesn't
			; understand this message.
			quit $LB("UNKNCMD")
		}
	}
	quit result ; result will be either $LB("OK") or $LB("ERR",text)
err ;
	s $zt=""
	if $G(io)'="" {
		c io
	}
	use saveio
	quit $LB("ERR",$ZE)		
}
VerifySSLCertificate(mirname,info,Cert,ReportingMember,NeedCAFile) PUBLIC {
	s $zt="err"
	s saveio=$I
	s id=$LG(info,3)_"|"_$LG(info,8)_","_$LG(info,4)
	s rc=$$EstablishConnection^MIRRORCOMM(mirname,0,id,"v",.io,"",2,0)
	if (rc '= 1) quit $LB("TIMEOUT")
	s membername=$LG(info)
	s targguid=$LG(info,2)
	use io
	do tcpsend(io,$LB("VERIFYCERT",$LB(mirname,Cert,ReportingMember,membername,NeedCAFile),targguid))
	s rc=$$tcpread(io)	
	;returns $LB(OK,<result>,...)
	;    <status> = ERR - something unexpected happened, 2nd element is <text>
	;    <status> = OK,<result> = success, <result> has more details
	s status=$LG(rc)
	if status'="OK" {
		close io 
		use saveio
	    q $LB("ERR",$LG(rc,2))
	}
	close io
	use saveio 
	s result=$LG(rc,2)
	quit result 
err ;
	s $zt=""
	i $d(io) close io
	use saveio
	quit $LB("ERR",$ZE)		
}
NotifyAsyncTypeChanged(mirname,index,membername,asynctype) PUBLIC {
	s $zt="err"
	s saveio=$I
	s io=""
	s info=$G(^SYS("MIRRORSET",mirname,"Member",index))
	if info="" quit $LB("ERR","Missing "_$name(^SYS("MIRRORSET",mirname,"Member",index)))
	s addrlist=$$BuildAgentAddrlist(info)
    s targguid=$lg(info,2)
	s basedir=$LG(info,6)
retry ;
	s rc=$$tcpopen(mirname,addrlist,targguid,basedir,5,,2)
	if +rc {
		; GetStatus() returns "TIMEOUT" if we timeout trying to 
		; establish a connection to the remote node. All other
		; errors return $LB("ERR",<reason>")
		if +rc=1 quit $LB("TIMEOUT",0)
		quit $LB($s(+rc=3:"LOCALSSLERR",+rc=4:"SSLERR",1:"ERR"),$P(rc,",",2,999))
	}
	s io=$P(rc,",",2),version=+$P(rc,",",3)
	use io
	do tcpsend(io,$LB("ASYNCTYPE",$LB(mirname,membername,asynctype)))
	s rc=$$tcpread(io)	
	;returns $LB(OK,<result>) or $LB(ERR,<reason>)
	s status=$LG(rc)
	if status'="OK" {
		do tcpclose(io)
		use saveio
	    q $LB("ERR",$LG(rc,2))
	}
	do tcpclose(io)
	s io=""
	use saveio 
	s result=$LG(rc,2)
	if $LG(result)["SSLERR"||($LG(result,2)["SSL ID") {
		s $li(result,1)="SSLERR"
		quit result
	}
	if $LG(result)="ERR" {
		s reason=$LG(result,2)
		if $E(reason,1,8)="UNKNCMD:" {
			; We must be talking to an old version which doesn't
			; understand this message.
			quit $LB("UNKNCMD",0)
		}
	}
	quit result
err ;
	s $zt=""
	use saveio 
	if io'="" c io
	quit $LB("ERR",$ZE)		
}
DeleteMirrorMember(arg) PUBLIC {
	s $zt="err"
	s singleuser=$LG(arg)
	s arg=$LG(arg,2)
	s name=$LG(arg)
	s mirname=$LG(arg,2)  ;is missing in older versions
	if mirname="" {
		s mirname=##class(Config.Mirrors).GetMirrorName()
		if mirname="" {
			quit $LB("NOTFOUND")  ;must not be a mirror member
		}
	}
	s x=##class(Config.MapMirrors).Open(mirname,name)
	if x="" {
		; name doesn't exist - see if this is an async member
		s mirname=$P($G(^SYS("MIRRORSET")),"^",2)
		; return status if we don't find the node to remove
		s rc=$LB("NOTFOUND") 
		s id=100  ;Async members start at id #101
		for  {
			s info=""
			s id=$O(^SYS("MIRRORSET",mirname,"Member",id),1,info)
			q:id=""
			if $LG(info,1)=name {
				k ^SYS("MIRRORSET",mirname,"Member",id)
		 	    s rc=$SYSTEM.Mirror.ServerRemove(name,$LG(info,2))
			    if rc=-1 {
			       d $zu(9,""," ServerRemove() failed for deleted async member"_name,1 /* broadcast and log message*/,1  /* Warning */)
			    }
				s rc=$LB("OK")
				quit  ;exit for loop
			}
		}
		quit rc
	}
	s x=""  ;close class
	s x=##class(Config.MapMirrors).Delete(mirname,name)
	s rc=+x
	if 'rc {
		k err 
		Do DecomposeStatus^%apiOBJ(x,.err,"-d") 
		quit $LB("ERR",$G(err(1)))  ;error text
	}
	quit $LB("OK")
err ;
	s $ZT=""
	quit $LB("ERR","Unexpected error: "_$ZE)
}
AddMirrorMember(arg) PUBLIC {
	;
	s $zt="err"
	;
	s singleuser=$LG(arg)
	s arg=$LG(arg,2)
	s name=$LG(arg)
	s values=$LG(arg,2)
	s mirname=$LG(arg,3)  ;is missing in older versions
	if mirname="" {
		s mirname=##class(Config.Mirrors).GetMirrorName()
		if mirname="" {
			quit $LB("ERR","Mirror name not found")
		}
	}
	k p
	for i=1:1:$LL(values) {
		s pair=$LG(values,i)
		s key=$LG(pair,1)
		s val=$LG(pair,2)
		s p(key)=val
	}		
	if $SYSTEM.Mirror.IsPrimary(),+$G(p("MemberType"))=0,$G(^SYS("MIRRORSET",mirname,"Member"),0)'=0 {
		Quit $LB("ERR","Backup member already existed in primary member")
	}
	s x=##class(Config.MapMirrors).Create(mirname,name,.p)
	s rc=+x
	if 'rc {
		k err 
		Do DecomposeStatus^%apiOBJ(x,.err,"-d") 
		quit $LB("ERR",$G(err(1)))  ;error text
	}
	quit $LB("OK")
err ;
	s $ZT=""
	quit $LB("ERR","Unexpected error: "_$ZE)
}
GetMirrorMembers(arg) PUBLIC {
	;
	s $zt="err"
	s singleuser=$LG(arg)
	s arg=$LG(arg,2)
	s mirname=$LG(arg)  ;is missing in older versions
	if mirname="" {
		s mirname=##class(Config.Mirrors).GetMirrorName()
		if mirname="" {
			quit $LB("ERR","Mirror name not found")
		}
	}
	s mlist=$lg(arg,2),GetDefinedPrimary=+$lg(arg,3)
	if +singleuser {
	   S Status=##Class(Config.CPF).Read(,1024)
	   if ('Status) quit $LB("ERR","Failed to load the cpf file: "_$SYSTEM.Status.GetErrorText(Status))
	}
	if GetDefinedPrimary {
		s cls=##class(Config.Mirrors).Open(mirname,,,.rc)
		if ('rc) quit $LB("ERR","Failed to open Config.Mirrors("_mirname_") to get defined primary: "_$SYSTEM.Status.GetErrorText(rc))
		s definedprimary = cls.DefinedPrimary
		s cls=""
	}
	;
	; Validflag indicates whether we're listed in the config of the
	; active mirror members. Until then, our information can't be
	; trusted because there could be nodes we don't know about (who
	; are active members).
	s mm=##class(Config.MirrorMember).Open(,,.rc)
	if (''rc) {
		s validflag=mm.ValidatedMember
		s ourname=mm.SystemName
	} else {
		s validflag=0
		s ourname=""
	}
	s mm=""
 	k errlist
 	s errlist=0
	if mlist="*" {
		k value s MirrorsData=""
		s x=##class(Config.Mirrors).Get(mirname,.values)
		s rc=+x
		if 'rc {
			s errlist=$i(errlist)
			s errlist(errlist)=$LB(mirname,$SYSTEM.Status.GetErrorText(x))  ;error text
		} else {
			s index=0
			s key=$O(values(""),1,val)
			s MirrorsData=""
			while key'="" {
				s index=index+1
				s $list(MirrorsData,index)=$LB(key,val)
				s key=$O(values(key),1,val)
			}
		}
	}
 	Set rs=##class(%Library.ResultSet).%New("Config.MapMirrors:List")
 	s rc=rs.Execute(mirname)
 	if 'rc quit $LB(0,"Failed locating defined mirror set members of "_mirname_": "_rc)
 	s mirdata=""
 	s mircnt=0
 	s totalmember=0
	while (rs.Next()) {
	   Set name=rs.Data("Name")
	   Set totalmember=totalmember+1
	   if mlist'="*" {
		   if $s(mlist="":rs.Data("MemberType")'=0,1:(","_mlist_",")'[(","_name_",")) {
			   continue
		   }
	   }
	   k values
	   s x=##class(Config.MapMirrors).Get(mirname,name,.values)
	   s rc=+x
	   if 'rc {
		  k err 
		  Do DecomposeStatus^%apiOBJ(x,.err,"-d")
		  s errlist=$i(errlist)
		  s errlist(errlist)=$LB(name,$G(err(1)))  ;error text
	   } else {
	      s index=0
	      s key=$O(values(""),1,val)
	      s retval=""
		  while key'="" {
		     s index=index+1
		     s $list(retval,index)=$LB(key,val)
			 s key=$O(values(key),1,val)
		  }
		  s $list(mirdata,$i(mircnt))=$LB(name,retval)
		}
	}
	do rs.Close()
	s rs=""
	if errlist {
		quit $LB("ERR",errlist(1))  ;return one of the errors
	}
	s memberfull=(totalmember>=$zu(40,0,106))  ; MAXMIRRORSVR
	;
	s UNICODE=''$zbitget($zversion(0),1),EMSManaged=0
	if validflag {
	    quit $lb("OK",mirdata,"",$G(definedprimary),$G(MirrorsData),UNICODE,EMSManaged,memberfull)
	} else {
	    quit $lb("OK-NOTVALID",mirdata,"",$G(definedprimary),$G(MirrorsData),UNICODE,EMSManaged,memberfull)
	}	
err ;
	s $ZT=""
	quit $LB("ERR","Unexpected error: "_$ZE)
}
GetMirrorConfig2(arg) PUBLIC {
	;
	s $zt="err"
	s singleuser=$LG(arg)
	s arg=$LG(arg,2)
	s mirname=$LG(arg)  ;is missing in older versions
	s EMSManaged=0
	if mirname="" {
		s mirname=##class(Config.Mirrors).GetMirrorName()
		if mirname="" {
			quit $LB("ERR","Mirror name not found",EMSManaged)
		}
	}
	k values
	s x=##class(Config.Mirrors).Get(mirname,.values)
	s rc=+x
	if 'rc {
		k err 
		Do DecomposeStatus^%apiOBJ(x,.err,"-d")
		quit $LB("ERR",$G(err(1)),EMSManaged)  ;error text
	}
	s values("MirrorName")=mirname
	s index=0
	s key=$O(values(""),1,val)
	s retval=""
	while key'="" {
		s index=index+1
		s $list(retval,index)=$LB(key,val)
		s key=$O(values(key),1,val)
	}
	s index=index+1,$list(retval,index)=$LB("UNICODE",''$zbitget($zversion(0),1))
	quit $LB("OK",retval,EMSManaged)
err ;
	s $ZT=""
	quit $LB("ERR","Unexpected error: "_$ZE,EMSManaged)
}
GetReportingIDs(arg) PUBLIC {
	s $zt="err"
	quit $lb("OK","")
err ;
	s $ZT=""
	quit $LB("ERR","Unexpected error: "_$ZE)
}
SetNoFailover(arg) PUBLIC {
	s singleuser=$LG(arg)
	s arg=$LG(arg,2)
	s name=$LG(arg)
	if name="" quit "0,Missing mirror name in defined primary message"
	s mirname=$LG(arg,2)  ;is missing in older versions
	if mirname="" {
		s mirname=##class(Config.Mirrors).GetMirrorName()
		if mirname="" {
			quit "0,Mirror name not found"
		}
	}
	s cls=##class(Config.MirrorMember).Open(,,,.rc)
	s membername=$s(('rc):"",1:cls.SystemName)
	s cls=""
	if +singleuser {
	   ; load the .cpf file so we don't fail if its changed on disk but not in "memory"
	   S Status=##Class(Config.CPF).Read(,1024)
	   if ('Status) quit "0,Mirror member '"_membername_"' failed to load the cpf file. Error:/"_$SYSTEM.Status.GetErrorText(Status)_"/"
	}
	if +$LG(arg,3) {
		s cls=##class(Config.MirrorMember).Open()
		if $isobject(cls) {
			s cls.ValidatedMember=0
			s rc=cls.%Save()
			s cls=""
			if ('rc) quit "0,Mirror member '"_membername_"' failed to clear Config.MirrorMember.ValidatedMember. Error:/"_$SYSTEM.Status.GetErrorText(rc)_"/"
		}
		quit 1
	}
	s cls=##class(Config.Mirrors).Open(mirname,,,.rc)
	if ('rc) quit "0,Mirror member '"_membername_"' failed to open Config.Mirrors("_mirname_"). Error:/"_$SYSTEM.Status.GetErrorText(rc)_"/"
	s cls.DefinedPrimary=name
	s rc=cls.%Save()
	s cls=""
	if ('rc) quit "0,Mirror member '"_membername_"' failed to save Config.Mirrors("_mirname_"). Error:/"_$SYSTEM.Status.GetErrorText(rc)_"/"
	quit 1
}
ClearNoFailover(arg) PUBLIC {
	s singleuser=$LG(arg)
	s arg=$LG(arg,2)
	s expectedname=$LG(arg)
	s mirname=$LG(arg,2)  ;is missing in older versions
	if mirname="" {
		s mirname=##class(Config.Mirrors).GetMirrorName()
		if mirname="" {
			quit "0,Mirror name not found"
		}
	}
	if +singleuser {
	   ; load the .cpf file so we don't fail if its changed on disk but not in "memory"
	   S Status=##Class(Config.CPF).Read(,1024)
	   if ('Status) quit "0,Failed to load the cpf file"
	}
	if +$LG(arg,3) {
		s cls=##class(Config.MirrorMember).Open()
		if $isobject(cls) {
			s cls.ValidatedMember=1
			s rc=cls.%Save()
			s cls=""
			if ('rc) quit "0,Failed to clear Config.MirrorMember.ValidatedMember. Error:"_$SYSTEM.Status.GetErrorText(rc)
		}
		quit 1
	}
	s cls=##class(Config.Mirrors).Open(mirname,,,.rc)
	if ('rc) quit "0,Failed to open Config.Mirrors("_mirname_") to set defined primary. Error:"_$SYSTEM.Status.GetErrorText(rc)
	if cls.DefinedPrimary'="" {
	   if (expectedname'="") && (cls.DefinedPrimary '= expectedname) {
		  quit "0,DefinedPrimary value ("_cls.DefinedPrimary_") doesn't match expected value ("_expectedname_"). Not cleared"
	   }
	   s cls.DefinedPrimary=""
	   s rc=cls.%Save()
	   if ('rc) quit "0,Failed to save Config.Mirrors("_mirname_") with cleared DefinedPrimary. Error:"_$SYSTEM.Status.GetErrorText(rc)
	}
	s cls=""
	if '+singleuser,expectedname="" {
		; If we're attached to the running version and we weren't passed an
		; expected name then post an event to MIRRORMGR so it re-evaluates whether
		; we should become the primary. When expectedname isn't null that means
		; that a node started up and found it was listed as the DefinedPrimary.
		; There's no need to see if we should become the primary in that case
		; because the other node will either become the primary or we'll get
		; notified if it fails & shuts down.
	    d post^MIRRORCOMM(mirname,0,0,"CLRDEFPRIMARY:")
	}
	quit 1
}
GetJournalFileRange(mirname,GetJrnEnd=0) {
	;Get the journal file count of the last file in the log
	s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)
	if rc<1 {
		if rc=0 quit $LB("NOTFOUND")
		quit $LB("ERR","Error reading journal log to locate last file: "_rc)
	}
	s lastfilecnt=+rc
	; Now find the journal file count of the 1st file in the log
	s info=$SYSTEM.Mirror.GetJournalFileInfo(mirname,"")
	if +info<1 {
		; it shouldn't be 0 because we already found the log once already
		quit $LB("ERR","Failed to read 1st file in journal log: "_info)
	}
	s fname=$P(info,",",2)
	s filecnt=$p(info,",",3)
	s jrnhdr=$zu(78,22,fname,99)
	while ('+jrnhdr),(filecnt<=lastfilecnt) {
		s filecnt=filecnt+1
		s file=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)
		if +file {  ;should be non-zero because the prior file was in the log
			s fname=$P(file,",",2)
			s jrnhdr=$zu(78,22,fname,99)
		}
	}
	if '+jrnhdr {
		; there are files in the log but none found on disk
		quit $LB("NOTFOUND")
	}
	if GetJrnEnd {
		s fd=$zu(78,5,fname,0)
		if fd'<0 {
			do $zu(78,6,fd)
			s FirstEnd=$zu(78,18,0)
			do $zu(78,7,fd)
		} else {
			s FirstEnd=-1
		}
	}
	s firstfilecnt=filecnt
	s filecnt=lastfilecnt+1
	s jrnhdr=""
	do {
		s filecnt=filecnt-1
		s file=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)
		if +file {  ;should be in the log because lastfilecnt>filecnt>firstfilecnt
			s fname=$P(file,",",2)
			s jrnhdr=$zu(78,22,fname,99)
		}
	} while ('+jrnhdr) && (filecnt > firstfilecnt)
	s lastfilecnt=filecnt
	if GetJrnEnd {
		s fd=$zu(78,5,fname,0)
		if fd'<0 {
			do $zu(78,6,fd)
			s LastEnd=$zu(78,18,0)
			do $zu(78,7,fd)
		} else {
			s LastEnd=-1
		}
		quit $LB("OK",$LB(firstfilecnt,lastfilecnt,FirstEnd,LastEnd))
	} else {
		quit $LB("OK",$LB(firstfilecnt,lastfilecnt))
	}
}
GetJRNINFO(args) PUBLIC {
	; Invoked by the agent in response to a GETJRNINFO message which
	; is set from GetJournalInfo().
	; 
	; See GetJournalInfo() for the arguments in 'args'
	;
	s $ZT="err"
	s singleuser=$LG(args)
	s args=$LG(args,2)
	s mirname=$LG(args,1)
	s func=$LG(args,2)
	s val=$LG(args,3)  ;value varies with function code
	if func=1 {  ;Get jrnfilecnt of oldest/most recent files which we have
		Quit $$GetJournalFileRange(mirname,val)
	}
	if func=2 {
		; return $SYSTEM.Mirror.GetJournalFileByMjrncnt() info on a set of files
		; starting with the jrncnt passed and going until we reach the end
		; or our return string is >16KB. 16KB is an arbitrary value that is
		; small enough to be handled by all systems and large enough so that
		; if there's lots of data, we're sending it back in reasonably sized
		; chunks.
		s start=val
		s result=""
		s cnt=0
		s info=$SYSTEM.Mirror.GetJournalFileByMjrncnt(val,mirname)
		while (+info>0) && ($L(result)<16000) {
			s cnt=cnt+1
			s $LIST(result,cnt)=$P(info,",",2,$L(info,","))
			s val=val+1
			s info=$SYSTEM.Mirror.GetJournalFileByMjrncnt(val,mirname)
		}
		quit $LB("OK",$LB(start,cnt,result))
	}
	if func=3 {
		; Send back $LB(log journal info,jrnhdr info) for the specified
		; filecount. If the filecount is 0, then send back info for
		; the 1st file we know about.
		if val=0 {
			s info="1,"  ;null filename will get 1st file in log
		} else {
		   s info=$SYSTEM.Mirror.GetJournalFileByMjrncnt(val,mirname)
		}
		if +info>0 {
			s fname=$P(info,",",2)
			; both jrninfo & hdrinfo start with a return status but
			; we pass that status back
			s jrninfo=$SYSTEM.Mirror.GetJournalFileInfo(mirname,fname)
			if fname="" {
				s fname=$P(jrninfo,",",2)
			}
			s hdrinfo=$zu(78,22,fname,99)
			s res=$lb(jrninfo,hdrinfo)
			quit $LB("OK",res)
		} else {
			if info=0 {
				quit $LB("NOTFOUND") ; file not found
			} else {
				quit $LB("ERR","Error "_info_" finding id #"_val_" in log file")
			}
		}
	}
	if (func=4) || (func=5) {  
	   ;                                                                   ;JO2367+
	   ;Send back min journal file # required by this node to recover
	   ; its mirrored databases. The minimum required point is the transaction
	   ; rollback point required by the database with the minimum checkpoint
	   ; value. Since the transaction rollback point is in the journal file we
	   ; may not be able to look it up. 
	   ; Returns: func 4: $LB("DBINFO",<minfilecnt>,<minendoff>,<lastconnected>) 
	   ;          func 5: $LB("OK",<minfilecnt>,<minendoff>,<lastconnected>) 
	   ;  
	   ;          <minfilecnt> and <minendoff> represent the earliest journal file
	   ;                 position required for transaction of a db from this mirror.
	   ;          <lastconnected> is "<role>^$ztimestamp" from the last time this
	   ;              node connected as a backup or was the primary.
	   ; 
	   ; The intention is that func=4 becomes obsolete and removed but for now,
	   ; we add func 5 with $LB("OK",...) and then in 2012.1 we can change the callers
	   ; to use func 5 and then we can remove support for func=4 the release after
	   ; that...
	   ;                                                                   ;JO2367-
	   s mindbinfo=$$GetMinDBJrnInfo^MIRRORMGR(mirname)
	   if '$LG(mindbinfo) {
		   quit $LB("ERR","Failed to read minimum db info, err="_$LG(mindbinfo,2))
	   }
	   if val'="" {
		   s lastconnected=$G(^MIRROR(mirname,"lastconnected",val))
	   } else {
		   s lastconnected=""
		   s x=$o(^MIRROR(mirname,"lastconnected",""),1,lastconnected)
	   }
	   s minjrncnt=$LG(mindbinfo,2)
	   s minendoff=$LG(mindbinfo,3)
	   if (func=4) quit $LB("DBINFO",minjrncnt,minendoff,lastconnected)  
 	   quit $LB("OK",minjrncnt,minendoff,lastconnected)  
	}
	if (func = 6) {
 	   s val=+$G(^MIRROR(mirname,"lastvalidjrnfile"))
	   quit $LB("OK",$LB(val))
	}
	if (func = 7) {
	   s dbmaxinfo=$$GetMaxDBJrnInfo^MIRRORMGR(mirname)
	   if '$LG(dbmaxinfo) {
		   s dbmaxinfo=$LB(0,0,0)  ;dbmaxjrnfilecnt=0, dbmaxjrnpos=0
	   }
	   ; dbmaxinfo=$Lb(rc,<jrnfilecnt>,<jrnendoff>)
	   s dbmaxjrnfilecnt=$lg(dbmaxinfo,2)
	   s dbmaxjrnpos=$LG(dbmaxinfo,3)
	   quit $LB("OK",$LB(dbmaxjrnfilecnt,dbmaxjrnpos))
	}
	if (func = 8) {
		s minjrnfile=$LG(val,2),Type=$LG(val)
		s:Type=2 Type=Type_","_$LG(val,3)
		s minjrnfile=##class(SYS.Mirror).PrimaryPurgeCriteria(mirname,minjrnfile,"",Type,.ReasonToKeep)
		if 'minjrnfile Quit $LB("NOTFOUND",ReasonToKeep)
		quit $LB("OK",$LB(minjrnfile,ReasonToKeep))
	}
	quit $LB("ERR","Unrecognized function code #"_func)
err ;
	s $zt=""
	quit $LB("ERR","Unexpected error: "_$ZE)	
}
LookupDBInfo(arg) PUBLIC {
	; Invoked by the agent in response to a LOOKUPDBINFO message which
	; is sent from GetDBInfo(). 
	;
	s arg=$LG(arg,2)
	s val=$LG(arg,2)  ;mirror database name ":mirror:<mirname>:dbname"
	s uppercase=+$LG(arg,3)
	s rc=$$CheckMirrorDBName^MIRRORCOMM(val,uppercase)
	if $LG(rc)="FOUND" {
		s rcx=$$GetJournalFileRange($LG(arg,1))
		if $LG(rcx)="OK" {
			s range=$LG(rcx,2)
			s rc=rc_$LB($LG(range)_","_$LG(range,2))
		} else {
			s rc=rc_$LB(0)
		}
	}
	Quit rc
}
SendDBInfo(arg) PUBLIC {
	s $zt="err"
	s singleuser=$LG(arg)
	s arg=$LG(arg,2)
	s mirname=$LG(arg,1)
	s dbname=$LG(arg,2)
	s dbguid=$LG(arg,3)
	s id=$LG(arg,4)
	s moredb=$LG(arg,5)
	s msg="SENDDBINFO:"_dbname_":"_dbguid_$s(moredb'="":":"_moredb,1:"")
	d post^MIRRORCOMM(mirname,0,id,msg)
	q $LB("OK","MultiDB")
err ;
	quit $LB("ERR",$ze)	   
}
AgentGetDBInfo(arg) PUBLIC {
	s $zt="err"
	s singleuser=$LG(arg)
	s arg=$LG(arg,2)
	s mirname=$LG(arg,1)
	s mirdbname=$LG(arg,2)  ;:mirror:<mirname>:<dbname>
	s func=$LG(arg,3)
	; Find the mirrored db by name
	s mname=$ZCVT($P(mirdbname,":",3),"U")  ;mirror names are uppercase
	s dbname=$P(mirdbname,":",4)
	s rc=$$GetMirroredDBList^MIRRORCOMM(mname,.dblist,0)
	if '$LG(rc) {
		s errmsg=$LG(rc,2)
		goto fail
	}
	s dir=$o(dblist(""),1,infostr)
	while dir'="" {
		s dirdbname=$P(infostr,"^",2)
		s dirmname=$P(infostr,"^",8)
		if dirmname=mname,dirdbname=dbname {
			goto found
		}
		s dir=$o(dblist(dir),1,infostr)
	}
	quit $LB("ERR","NOTFOUND")
found ;
	s info=$ZU(49,dir)
	quit $LB("OK",dir,info)
err ;
	s $zt=""
	s errmsg=$ZE
fail ;	
	quit $LB("ERR",errmsg)	   
}
GETMULTIDBINFO(arg) PUBLIC {
	s $zt="err"
	s singleuser=$LG(arg)
	s arg=$LG(arg,2)
	s mirname=$LG(arg,1)
	s dblist=$LG(arg,2)
 	s mirrorbit=+$ZU(40,8,28)
 	s result=""
	for i=1:1:$listlength(dblist) {
		s dir=$li(dblist,i)
		s info=$ZU(49,dir)
		if (+info<-1) {
			s result=result_$LB("")
			continue
		}
 	    s dbattrib=+$p(info,",",17)  ;even when not mounted, $ZU(49) data is returned
	    ;skip this db if its not marked as mirrored
 	    if $zb(+dbattrib,+mirrorbit,1)=0 {
			s result=result_$LB("")
			continue
 	    }
 	    s info=$SYSTEM.Mirror.DBGetInfoByName(0,dir)
 	    if info="DOWN" {
			s result=result_$LB("")
			continue
 	    }
 	    if (info="") || (mirname'="" && (mirname'=$P(info,"^",8))) {
			s result=result_$LB("")
			continue
 	    }
        s result=result_$LB(info)
	}
	quit $LB("OK",result)
err ;
	quit $LB("ERR",$ze)	   
}
AddFOMember(arg) PUBLIC {
	s $zt="err"
	s singleuser=$LG(arg)
	s arg=$LG(arg,2)
	s mirname=$LG(arg,1)
	s msg=$LG(arg,2)
	s id=$LG(arg,3)
	i '0 {
		d ##Class(Config.CPF).FileToName(.CPFFile,.CPFName)
		i $g(^|"^^"_$zu(12)|SYS("CONFIG",CPFName,"CPFSHA256Hash"))'=##Class(%Library.File).GetFileSHA256Hash(CPFFile) {
			Quit $LB("ERR","Restart or reactivation required because the CPF file "_CPFFile_" has been modified, but not activated")
		}
	}
	if $SYSTEM.Mirror.IsMember()=1,msg'[":" {
		if $e(msg,*)=$c(0) {
			s msg=$e(msg,1,*-1)
			s newtype=0
			s idx=$O(^SYS("MIRRORSET",mirname,"Member",101-1),1,info)
			while idx'="" {
				i msg=$LG(info) s found=1 q
				s idx=$O(^SYS("MIRRORSET",mirname,"Member",idx),1,info)
			}
			if idx="" {
				Quit $LB("ERR","The "_msg_" is not found, could not change its type to failover")
			}
		} else {
			s newtype=2
			if $LG($G(^SYS("MIRRORSET",mirname,"Member",1)))'=msg {
				s idx=$O(^SYS("MIRRORSET",mirname,"Member",101-1),1,info)
				while idx'="" {
					i msg=$LG(info) q
					s idx=$O(^SYS("MIRRORSET",mirname,"Member",idx),1,info)
				}
				if idx'="",$LG(info,8)=newtype Quit $LB("OK")
				Quit $LB("ERR","The "_msg_" is not found, could not change its type to async")
			}
		}
		s props("MemberType")=newtype
		s rc=##class(Config.MapMirrors).Modify(mirname,msg,.props)
		if ('rc) {
			Quit $LB("ERR","Failed to change "_msg_"'s type to "_$s(newtype=2:"async",1:"failover"))
		}
		if newtype=2 {
			d post^MIRRORCOMM(mirname,0,id,"DELMEMBER:"_msg)
		} else {
			d post^MIRRORCOMM(mirname,0,idx,"ADDMEMBER:")
		}
		quit $LB("OK")
	}
	s msg=$s(msg[":":"NEWFOMEMBER:",1:"DELFOMEMBER:")_msg
	d post^MIRRORCOMM(mirname,0,id,msg)
	q $LB("OK")
err ;
	quit $LB("ERR",$ze)	   
}
SetRECOVPARAM(arg) PUBLIC {
	s $zt="err"
	s singleuser=$LG(arg)
	s arg=$LG(arg,2)
	s mirname=$lg(arg,5)
	if mirname="" {
		s mirname=##class(Config.Mirrors).GetMirrorName()
		if mirname="" {
			quit $LB("ERR","Mirror name not found")
		}
	}
	if singleuser {
		S Status=##Class(Config.CPF).Read(,1024)
		if ('Status) quit $LB("ERR","SetRECOVPARAM: Failed to load the cpf file")
	}
	s p("QOSTimeout")=$LG(arg,1)
	if $LL(arg)>=6 {  ;arbiteraddreslist is #6
		s p("ArbiterNode")=$LG(arg,6)
	}
	if $LG(arg,7)'="" {
		Set rc=##class(Config.Mirrors).GetClassProperties("",.ClassProperties)
		If (''rc),ClassProperties["CompressionForFailoverMembers" {
			s p("CompressionForFailoverMembers")=+$p($LG(arg,7),"^",1)
			s p("CompressionForAsyncMembers")=+$p($LG(arg,7),"^",2)
		}
		If (''rc),$L($LG(arg,7),"^")>2,ClassProperties["CompressionTypeForFailoverMembers" {
			s p("CompressionTypeForFailoverMembers")=+$p($LG(arg,7),"^",3)
			s p("CompressionTypeForAsyncMembers")=+$p($LG(arg,7),"^",4)
		}
	}
	s x=##class(Config.Mirrors).Modify(mirname,.p)
	s rc=+x
	if 'rc {
		k err 
		Do DecomposeStatus^%apiOBJ(x,.err,"-d") 
		quit $LB("ERR",$G(err(1)))  ;error text
	}
	quit $LB("OK")
err ;
	s $ZT=""
	quit $LB("ERR","Unexpected error: "_$ZE)
}
AuthorizeSSL(arg) PUBLIC {
	s $zt="err"
	s singleuser=$LG(arg)
	s arg=$LG(arg,2)
	s mirname=$p(arg,","),io=$p(arg,",",2),sslon=$p(arg,",",3)
	s x=##class(Security.Services).%OpenId($ZCVT("%Service_Mirror","L"),,.rc)
	if ('rc) {
	 	k err
    	Do DecomposeStatus^%apiOBJ(rc,.err,"-d")
    	s msg="Failed to check status of MirroringingService: "_err(1)
    	d $zu(9,"",msg)
    	d tcpsend(io,$LB("ERR",msg))
    	quit -1
	}
	if 'x.Enabled {
    	s msg="Mirror Service is disabled"
    	d $zu(9,"",msg)
    	d tcpsend(io,$LB("ERR",msg))
		quit -1
	}
	i sslon="" {
		s sslon=+$G(^SYS("MIRRORSET",mirname,"UseSSL"),0)
		if 'sslon {
		   ; Note that we're looking at the last value loaded here but that's
		   ; ok in this case. It would be a lot of overhead on every connection
		   ; to open the Config class to get the current value.
		   s info=$G(^SYS("MIRRORSET",mirname,"Member",0))
		   s EncryptConnection=$zb(+$LG(info,11),2,1) ; Bit #2 means encrypt incoming connections
		   if EncryptConnection {
			   s sslon=1
		   }
		}
	}
	s requireAuthorization=0
	if sslon || requireAuthorization {
		if '$$ActivateSSLConfig(mirname) {
			s msg="Failed to load SSL configuration"
			d $zu(9,"",msg)
			d tcpsend(io,$LB("ERR",msg))
			q -1
		}
	}
	s rc=$$SSLServer(mirname,io,sslon,requireAuthorization)
	if +rc < 0 {
		if +rc>-3 {
			d $zu(9,"",$p(rc,",",2,*))
		} else {
			d tcpsend(io,$LB("ERR",$p(rc,",",2,*)))
		}
		q -1
	}
	quit +rc
err ;
	s $ZT="",ref=$ZR,rs="",msg="AuthorizeSSL error $ZE="_$ze
	;s singleuser=$LG(arg)
	;s arg=$LG(arg,2)
	;s mirname=$p(arg,","),io=$p(arg,",",2),sslon=$p(arg,",",3)
	do logerr(ref,$ZE,$G(singleuser),$G(arg))
	d $zu(9,"",msg)
	d tcpsend(io,$LB("ERR",msg))
	quit -1
}
logerr(ref,err,singleuser,arg) PUBLIC {
	try {
	  s io=$i
	  s logf=$ZU(12)_"agent-errlog.txt"
	  o logf:"WSEA"
	  u logf
	  w $ZDATETIME($H)," Pid: ",$J,", Error: ",err,", $ZU(56,2): ",$ZU(56,2),", $ZR=/",ref,"/"
	  w ", suser=",singleuser,", arg=/",arg,"/",!
	  c logf
	  u io
	  quit
	} catch {do $ZU(9,"","Agent caught "_$ZE_" logging error",1)} ;,1 sends to o/s logger
}
GetMirrorConfig(mirname) PUBLIC {
	s $zt="err"
	s res=""
	m ^||mirconfig=^SYS("MIRRORSET",mirname)
	s Status=##Class(Security.Servers).GetDefaultServer(.ServerObj)
	s ^||mirconfig("SSLReq")=ServerObj.SSLSupportLevel
	s query=$q(^||mirconfig(""),1,value)
	while query'="" {
		s ql=$ql(query),sub=$LB(ql)
		for i=1:1:ql s sub=sub_$LB($qs(query,i))
		s sub=sub_$LB(value)
		s res=res_$LB(sub)
		s query=$q(@query,1,value)
	}
	quit res
err quit ""
}
SendECPConnectionData(arg) PUBLIC {
	s $zt="err"
	s mirname=$LG($LG(arg,2))
	s NeedECPData=$LG($LG(arg,2),2),res=""
	if NeedECPData=""||(NeedECPData=1) {
		s res=$LB($G(^%SYS("LASTSESSIONGUIDMIR"))),cnt=1
		s sys=$O(^%SYS("SERVICE","ECPMIRs",""),1,data)
		while sys'="" {
			if $listget(data,4)="" s res=res_$LB($LB(sys,data)),cnt=cnt+1
			s sys=$O(^%SYS("SERVICE","ECPMIRs",sys),1,data)
		}
		quit:NeedECPData="" $LB(cnt)_res
		s res=$LB(cnt)_res
	}
	s res2="",cnt=0
	if +NeedECPData>0 {
		s sys=$O(^MIRROR(mirname,"LastJrnfileSent",""),1,data)
		while sys'="" {
			s res2=res2_$LB($LB(sys,data)),cnt=cnt+1
			s sys=$O(^MIRROR(mirname,"LastJrnfileSent",sys),1,data)
		}
		s res=res_$LB(cnt)_res2
	} else {                        ;JO2386+
		s res=res_$LB(0)            ;JO2386-
	}
	; The ECPSessionVersion global gets set when a node starts up.
	; In a mirror we want to propagate it from the primary to the
	; backup so that when the backup parses the data in the ^%SYS("SERVICE")
	; tree, it uses the session version # from the primary which created
	; that data.
	s res=res_$LB(1)_$LB($G(^%SYS("SERVICE","ECPSessionVersion")))
	s res2="",cnt=0
	if +NeedECPData>0 {
		s sys=$O(^MIRROR(mirname,"lastdisconnected",""),1,data)
		while sys'="" {
			if $p(data,"^")="PRIMARY" s res2=res2_$LB($LB(sys,data)),cnt=cnt+1
			s sys=$O(^MIRROR(mirname,"lastdisconnected",sys),1,data)
		}
		s res=res_$LB(cnt)_res2
	} else {
		s res=res_$LB(0)
	}
	if +$G(^%SYS("SERVICE","ECPNoRecovery","mirrorok")) {
	   s res=res_$LB(1)_$LB(+$G(^%SYS("SERVICE","ECPNoRecovery"),0))
	} else {
	   s res=res_$LB(0)
	}
	quit $s(res="":$LB(0),1:res)
err quit $LB(0,$ZE)
}
ChangeVIP(arg) PUBLIC {
	s $zt="err"
	s info=$LG(arg,2)
	s mirname=$LG(info)
	s Type=$LG(info,2)
	s IPAddr=$LG(info,3)
	s Iface=$LG(info,4)
	if Type {
		s rc=$$AddVirtualAddress^MIRRORMGR(mirname,IPAddr,1)
	} else {
		s rc=$$DeleteVirtualAddress^MIRRORMGR(mirname,IPAddr,1,Iface)
	}
	Quit rc
err quit $LB("0,"_$ZE)
}
AsyncMemberInfo(arg) PUBLIC {
	s $zt="err"
	s singleuser=$LG(arg)
	s arg=$LG(arg,2)
	s mirname=$LG(arg,1)
	s obj=##class(Config.MirrorMember).Open(,,,.rc)
	if ('rc) {
		s Type = 0
	} else {
		s Type = obj.AsyncMemberType
	}
	s rc=##class(SYS.MirrorConfiguration).DoSSLConfigurationsExist(.dn)
	if '(''rc) s dn=""
	q $LB("OK",Type,$g(dn),"")
err ;
	quit $LB("ERR",$ze)	   
}
PROMOTE(arg) PUBLIC {
	s $zt="err"
	if $SYSTEM.Mirror.GetInfo()'["PRIMARY" quit $LB("ERR","Promote request could not be processed by non-primary member")
	s singleuser=$LG(arg)
	if singleuser quit $LB("ERR","Promote could not be run on a single user mode.")
	s trouble=+$p($SYSTEM.Mirror.GetInfo(2),",",12)
	if trouble quit $LB("ERR","Promote request could not be processed by primary member in trouble state ("_trouble_")")
	s arg=$LG(arg,2)
	s mirname=$LG(arg,1)
	s sysname=$LG(arg,2)
	s guid=$LG(arg,3)
	s asynctype=$LG(arg,4)
	s CheckConnection=+$LG(arg,5)
	s DemoteName=$LG(arg,6)
	s obj=##class(Config.MapMirrors).Open(mirname,sysname,,,.status)
	if ('status) {
		Quit $LB("ERR","Promote could not find the matched name "_sysname_" in mirror set "_mirname_" error:"_$SYSTEM.Status.GetErrorText(status))
	}
	if obj.MemberType=0 {
		Quit $LB("ERR","Promote failed. Member "_sysname_" is already a failover member")
	}
	if obj.GUID'=guid {
		Quit $LB("ERR","Promote failed. Member "_sysname_" has different GUID "_obj.GUID_" vs "_guid)
	}
	s id=$o(^SYS("MIRRORSET",mirname,"Member",101-1),1,minfo)
	while (id'="") {
		quit:$lg(minfo)=sysname
		s id=$o(^SYS("MIRRORSET",mirname,"Member",id),1,minfo)
	}
	if id="" {
		Quit $LB("ERR","Promote could not find the matched name "_sysname_" in ^SYS(""MIRRORSET"")")
	}
	if $G(^SYS("MIRRORSET",mirname,"Member"))>0 {
		s info=$G(^SYS("MIRRORSET",mirname,"Member",1))
		s name=$LG(info)
		if CheckConnection {
			s clientcnt=$SYSTEM.Mirror.ClientQuery()
			if +clientcnt {
				s found=0
				for id=1:1:clientcnt {
					s infox=$SYSTEM.Mirror.ClientQuery(id)
					if +infox,name=$P(infox,",",2) {
						s found=1
						quit
					}
				}
				if found {
					Quit $LB("ERR","Primary found "_name_" is connected while its agent is not accessible by promoting DR.")
				}
			}
			s addrlist=$$BuildAgentAddrlist(info)
			s basedir=$LG(info,6)
			s targguid=$LG(info,2)
			s status=$$TEST(mirname,addrlist,targguid,basedir,2)
			if $LG(status) {
				Quit $LB("ERR","Primary found agent of "_name_" is accessible while its agent is not accessible by promoting DR.")
			}
		}
		s StartMirror=(+$LG(info,10))
		k props s props("MemberType")=asynctype
		s status=##class(Config.MapMirrors).Modify(mirname,name,.props)
		if ('status) {
			Quit $LB("ERR","Promote could not demote another failover member "_name_", error:"_$SYSTEM.Status.GetErrorText(status))
		}
		s $list(minfo,8)=0
		s addrlist=$$BuildAgentAddrlist(info)
		s basedir=$LG(info,6)
		s targguid=$LG(info,2)
		s status=$$DemoteToAsync(mirname,addrlist,targguid,basedir,minfo,asynctype,StartMirror,0,DemoteName)
		if $LG(status)'="OK" {
			d $zu(9,"","DemoteToAsync for "_name_" failed with "_$lg(status,2),1 /* broadcast and log message*/,1  /* Warning */)
		}
	}
	s obj.MemberType=0
	s status=obj.%Save()
	if ('status) {
		Quit $LB("ERR","Promote failed. Failover to save the new failover member "_sysname_". Error:"_$SYSTEM.Status.GetErrorText(status))
	}
	s msg="PROMOTE:"_sysname
	d post^MIRRORCOMM(mirname,0,0,msg)
	quit $LB("OK")
err ;
	quit $LB("ERR",$ze)	   
}
DEMOTE(arg) PUBLIC {
	if $SYSTEM.Mirror.GetInfo()["PRIMARY" quit $LB("ERR","Demote request could not be processed by primary member")
	s singleuser=$LG(arg)
	s arg=$LG(arg,2)
	s DemoteName=$LG(arg,6)
	if singleuser {
		if (DemoteName="") quit $LB("ERR","Demote could not be run on single user mode.")
		S Status=##Class(Config.CPF).Read(,1024)
		if ('Status) quit $LB("ERR","DEMOTE: Failed to load the cpf file")
	}
	s mirname=$LG(arg,1)
	s cls=##class(Config.Mirrors).Open(mirname)
	s cls.DefinedPrimary=""
	s rc=cls.%Save()
	s cls=""
	if singleuser {
		s MemberObj=##class(Config.MirrorMember).Open()
		if '$isobject(MemberObj)||(DemoteName'=MemberObj.SystemName) Quit $LB("ERR","Failed to demote '"_DemoteName_"', member not exists")
		if MemberObj.AsyncMemberGUID'="" Quit $LB("ERR","Failed to demote '"_DemoteName_"', member already is an async member")
		s mobj=##class(Config.MapMirrors).Open(mirname,DemoteName,,,.rc)
		if '(''rc) Quit $LB("ERR","Failed to demote '"_DemoteName_"', failed to open MapMirrors object, err="_$SYSTEM.Status.GetErrorText(rc))
		s ourguid=mobj.GUID
		if mobj.MemberType'=0 Quit $LB("ERR","Failed to demote '"_DemoteName_"', member is not a failover member")
		s mobj.MemberType = 2
		s rc=mobj.%Save()
		if '(''rc) Quit $LB("ERR","Failed to demote '"_DemoteName_"', failed to save MapMirrors object, err="_$SYSTEM.Status.GetErrorText(rc))
		s MemberObj.AsyncMemberGUID = ourguid
		s MemberObj.AsyncMemberType = 0
		s MemberObj.ValidatedMember = 0
		s rc=MemberObj.%Save()
		if '(''rc) {
			s mobj.MemberType = 0
			d mobj.%Save()
			Quit $LB("ERR","Failed to demote '"_DemoteName_"', failed to save MirrorMember object, err="_$SYSTEM.Status.GetErrorText(rc))
		}
		quit $LB("OK")
	}
	if +$LG(arg,5),$SYSTEM.Mirror.GetInfo()[",DEFINED," {
		s othername=$LG($G(^SYS("MIRRORSET",mirname,"Member",1)))
		if othername'="" {
			s mobj=##class(Config.MapMirrors).Open(mirname,othername,,,.rc)
			if (''rc) {
				s mobj.MemberType = 2
				s rc=mobj.%Save()
				s mobj=""
			}
		}
	}
	s status=##class(SYS.MirrorConfiguration).DemoteToAsyncMember(mirname,$LG(arg,2),$LG(arg,3),0,+$LG(arg,4))
	if ('status) {
		Quit $LB("ERR","Failed to Demote to Async member. Error:"_$SYSTEM.Status.GetErrorText(status))
	}
	Quit $LB("OK")
err ;
	quit $LB("ERR",$ze)	   
}
SYNCHCONFIG(arg) PUBLIC {
	s singleuser=$LG(arg)
	if singleuser quit $LB("ERR","SYNCHCONFIG could not be run on a single user mode.")
	s arg=$LG(arg,2)
	s mirname=$LG(arg,1)
	s primaryname=$LG(arg,2)
	s msg="SYNCHCONFIG:"_primaryname
	d post^MIRRORCOMM(mirname,0,0,msg)
	quit $LB("OK")
err ;
	quit $LB("ERR",$ze)	   
}
FETCHMEMBERZEROGUID(args) PUBLIC {
	s $ZT="err"
	s singleuser=$LG(args)
	if singleuser quit $LB("ERR","FETCHMEMBERZERODGUID is not expected to be run on a single user mode.")
	s arg=$LG(args,2)
	s mirname=$LG(arg,1)
	s processpid=$LG(arg,2)
	s guid=$G(^SYS("MIRRORSET",mirname,"MemberZeroGUID",processpid))
	s mgrdir=$ZU(12)
	quit $LB("OK",guid,mgrdir)
err ;
	s $zt=""
	quit $LB("ERR",$ze)	   
}
MIRRORTIME(arg) PUBLIC {
	s $zt="err"
	s singleuser=$LG(arg)
	if +singleuser {
		S Status=##Class(Config.CPF).Read(,1024)
		if ('Status) quit $LB("ERR","Failed to load the cpf file: "_$SYSTEM.Status.GetErrorText(Status))
	}
	s mm=##class(Config.MirrorMember).Open(,,.rc)
	if '(''rc)||('mm.ValidatedMember) {
		quit $LB("OK","")
	}
	s mm=""
	s arg=$LG(arg,2)
	s mirname=$LG(arg,1)
	s rc=$G(^SYS("MIRRORTIME",mirname))
	s definedprimary=""
	s cls=##class(Config.Mirrors).Open(mirname,,,.rcx)
	if '('rcx) {
		s definedprimary = cls.DefinedPrimary
		s cls=""
	}
	s FailoverNode=0
	s MemberObj=##class(Config.MirrorMember).Open()
	if $isobject(MemberObj) {
		s ourname=MemberObj.SystemName
		s MemberObj=""
		if ourname'="" {
			s OurMember=##class(Config.MapMirrors).Open(mirname,ourname,,,.rcx)
			if '('rcx) {
				s FailoverNode=(OurMember.MemberType=0)
			}
			s OurMember=""
		}
	}
	quit $LB("OK",rc,definedprimary,FailoverNode,+$G(^MIRROR(mirname,"PromotedYetPrimary")))
err ;
	quit $LB("ERR",$ze)	   
}
GETJRNBLK(arg) PUBLIC {
	s $zt="err"
	s singleuser=$LG(arg)
	s arg=$LG(arg,2)
	s mirname=$LG(arg,1)
	s filecnt=$LG(arg,2)
	s offset=$LG(arg,3)
	s len=$LG(arg,4)
	s isasync=$LG(arg,5)
	s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)
	if +rc<=0 quit $LB("ERR","File #"_filecnt_" is not found in mirror log file.")
	s jrnfile=$P(rc,",",2)
	if singleuser {
		s info=$zu(78,22,jrnfile,99)
		s enckey=$P(info,",",23+1) ;$$$JRNENCKEYID(jrnfile)
		if enckey'="" {
			if isasync quit $LB("ERR","Journal file "_jrnfile_" is encrypted.")
			s iscompressed=$P(info,",",24+1)
			if iscompressed {
				quit $LB("ERR","Journal file "_jrnfile_" is encrypted and compressed")
			}
			s size=len+2048-1\2048*2048
			Open jrnfile:("RUK\RAW\"):3 s dt=$t
			if 'dt quit $LB("ERR","Failed to open encrypted journal file "_jrnfile_" in GETJRNBLK")
			Use jrnfile:offset Read data#size
			Close jrnfile
			Quit $LB("ENC",enckey,data)
		}
	}
    s fd=$zu(78,5,jrnfile,0)
    if fd<0 {
       quit $LB("ERR","Failed to open journal file "_jrnfile_" in GETJRNBLK.")
    }
	do $zu(78,6,fd)
	s ourdata=$zu(78,65,offset,len)
	do $zu(78,7,fd)
	quit $LB("OK",ourdata)
err ;
	quit $LB("ERR",$ze)	   
}
SETAPPROVAL(arg) PUBLIC {
	s $zt="err"
	s singleuser=$LG(arg)
	i singleuser quit $LB("ERR","Instance is not running")
	s arg=$LG(arg,2)
	s mirname=$LG(arg,1)
	s memberinfo=$LG(arg,2)
	i '$SYSTEM.Mirror.IsPrimary() quit $LB("ERR","Operation not allowed by non-primary member")
	i 0 quit $LB("ERR","Mirror configuration is controlled by EMS")
	s name=$LG(memberinfo,1),guid=$LG(memberinfo,2)
	s key=name_":"_guid
	s idx=$o(^SYS("MIRRORSET",mirname,"Member",0),1,info)
	while idx'="" {
		if name=$LG(info),guid=$LG(info,2) quit
		s idx=$o(^SYS("MIRRORSET",mirname,"Member",idx),1,info)
	}
	if idx'="" {
		s info=$LB(name,guid,$lg(memberinfo,7),$lg(memberinfo,8))
		Lock +^MIRROR("PendingDNUpdates")
		if $G(^MIRROR(mirname,"PendingDNUpdates",key))'=info {
			if $G(^MIRROR(mirname,"PendingDNUpdates"),0)<8 {
				s ^MIRROR(mirname,"PendingDNUpdates",key)=info
				s x=$I(^MIRROR(mirname,"PendingDNUpdates"))
			} else {
				Lock -^MIRROR("PendingDNUpdates")
				quit $LB("ERR","Pending queue overflown")
			}
		}
		Lock -^MIRROR("PendingDNUpdates")
	} else {
		if $LG(memberinfo,8)=0,$G(^SYS("MIRRORSET",mirname,"Member"),0)'=0 {
			Quit $LB("ERR","Backup member already existed in primary member")
		}
        if $G(^SYS("allowMemberWithSameDN")),$d(^SYS("MIRRORSET",mirname,"sslDN",$lg(memberinfo,7))) {
            s params("AgentAddress") = $p($LG(memberinfo,5),"|")
            s params("AgentPort") = $p($LG(memberinfo,5),"|",2)
            s params("ConnectsTo") = $LG(memberinfo,9)
            s params("ECPAddress") = $p($LG(memberinfo,3),"|")
            s params("GUID") = $LG(memberinfo,2)
            s params("InstanceDirectory") = $LG(memberinfo,6)
            s params("MemberType") = $LG(memberinfo,8)
            s params("MirrorAddress") = $p($LG(memberinfo,4),"|")
            s params("MirrorSSPort") = $p($LG(memberinfo,3),"|",2)
            s params("Name") = $LG(memberinfo,1)
            s params("SSLComputerName") = $LG(memberinfo,7)
            s params("EncryptCommunication") =$LG(memberinfo,11)
            s params("AsyncMemberType") =+$LG(memberinfo,13)
            s rc=##class(Config.MapMirrors).Create(mirname,name,.params)
            if ('rc) {
                Quit $LB("ERR","Failed to add backup member '"_name_"'. Error="_$SYSTEM.Status.GetErrorText(rc))
            }
            Quit $LB("OK")
        }
		Lock +^MIRROR("PendingNewMember")
		if $G(^MIRROR(mirname,"PendingNewMember",key))'=memberinfo {
			if $G(^MIRROR(mirname,"PendingNewMember"),0)<8 {
				s ^MIRROR(mirname,"PendingNewMember",key)=memberinfo
				s x=$I(^MIRROR(mirname,"PendingNewMember"))
			} else {
				Lock -^MIRROR("PendingNewMember")
				quit $LB("ERR","Pending queue overflown")
			}
		}
		Lock -^MIRROR("PendingNewMember")
	}
	Quit $LB("OK")
err ;
	Lock -^MIRROR("PendingDNUpdates")
	Lock -^MIRROR("PendingNewMember")
	quit $LB("ERR",$ze)	   
}
REJAPPROVAL(arg) PUBLIC {
	s $zt="err"
	s singleuser=$LG(arg)
	i singleuser quit $LB("ERR","Instance is not running")
	i 0 quit $LB("ERR","Mirror configuration is controlled by EMS")
	s arg=$LG(arg,2)
	s mirname=$LG(arg,1)
	s memberinfo=$LG(arg,2)
	s name=$LG(memberinfo,1),guid=$LG(memberinfo,2)
	s key=name_":"_guid
	s info=$G(^SYS("MIRRORSET",mirname,"Member",0))
	if info=""||(name'=$LG(info))||(guid'=$LG(info,2)) quit $LB("ERR","Member not exist")
	d ##class(SYS.Mirror).StopMirror(mirname)
	Quit $LB("OK")
err ;
	quit $LB("ERR",$ze)	   
}
VALIDATEPARTNER(arg) PUBLIC {
	s $zt="err"
	s singleuser=$LG(arg)
	if +singleuser {
		S Status=##Class(Config.CPF).Read(,1024)
		if ('Status) quit $LB("ERR","Failed to load the cpf file: "_$SYSTEM.Status.GetErrorText(Status))
	}
	s mm=##class(Config.MirrorMember).Open(,,.rc)
	if '(''rc) quit $LB("ERR","Failed to open MirrorMember class, error="_$SYSTEM.Status.GetErrorText(rc))
	s ValidatedMember = mm.ValidatedMember
	s ourname = mm.SystemName
	s mm=""
	s arg=$LG(arg,2)
	s mirname=$LG(arg,1),name=$LG(arg,2),guid=$LG(arg,3)
	s othertime=$p($LG(arg,4),"^",2)
	s mm=##class(Config.MapMirrors).Open(mirname,name,,,.rc)
	if ('rc) {
		if ValidatedMember Quit $LB("ERR","'"_name_"' is not a failover partner of '"_ourname_"'.")
		Quit $LB("OK",ValidatedMember,"")
	}
	if ValidatedMember {
		if (guid'=mm.GUID) Quit $LB("ERR","'"_name_"' has mismtached GUID "_mm.GUID_" vs "_guid)
		if (mm.MemberType'=0) Quit $LB("ERR","'"_name_"' is not Failover member type")
	}
	s ConfigData="",mytime=$p($G(^SYS("MIRRORTIME",mirname)),"^",2)
	s hisjrninfo=$LG(arg,5),DP=$LB(0)
	if hisjrninfo'="" {
		s cls=##class(Config.MirrorMember).Open(,,.rc)
		if (''rc),cls.AsyncMemberGUID="" {
			s myname=cls.SystemName
			if $SYSTEM.Mirror.IsPrimary() {
iamprimary		s cls=##class(Config.Mirrors).Open(mirname,,,.rc)
				if '('rc) {
					s DP=$LB(1,cls.DefinedPrimary)
				}
			} else {
				s myjrninfo=$$GetLastJournalInfo(mirname)
				if $LG(myjrninfo)>$LG(hisjrninfo) goto iamprimary
				if $LG(hisjrninfo),$LG(myjrninfo)=$LG(hisjrninfo) {
					s myguid=$LG($G(^SYS("MIRRORSET",mirname,"Member",0)),2)
					if myguid="" {
						s cls=##class(Config.MapMirrors).Open(mirname,myname,,,.rc)
						if (''rc) s myguid=cls.GUID
					}
					if myguid=$LG(myjrninfo,5) goto iamprimary
				}
			}
		}
	}
	quit $LB("OK",ValidatedMember,mm.SSLComputerName,ConfigData,$SYSTEM.Mirror.IsPrimary()&&$G(^SYS("MIRRORSET",mirname,"UseSSL"),0),DP)
err ;
	quit $LB("ERR",$ze)	   
}
ASYNCTYPE(arg) PUBLIC {
	s singleuser=$LG(arg)
	if singleuser quit $LB("ERR","ASYNCTYPE could not be run on a single user mode.")
	if '$SYSTEM.Mirror.IsPrimary() quit $LB("ERR","System is not a primary member.")
	s arg=$LG(arg,2)
	s mirname=$LG(arg,1)
	s membername=$LG(arg,2)
	s newasynctype=$LG(arg,3)
	s cls=##class(Config.MapMirrors).Open(mirname,membername,,,.rc)
	if '(''rc) quit $LB("ERR","Failed to open Config.MapMirrors error="_$SYSTEM.Status.GetErrorText(rc))
	s cls.AsyncMemberType = newasynctype
	s rc=cls.%Save()
	if '(''rc) quit $LB("ERR","Failed to save Config.MapMirrors error="_$SYSTEM.Status.GetErrorText(rc))
	quit $LB("OK")
err ;
	quit $LB("ERR",$ze)	   
}
CHKREQUIREDDBS(arg) PUBLIC {
	s singleuser=$LG(arg)
	if singleuser quit $LB("ERR","CHKREQUIREDDBS should not be run when the system is down")
	if '$SYSTEM.Mirror.IsBackup() quit $LB("ERR","System is not the backup member.")
	s rc=$$CheckRequiredDatabases^MIRRORCOMM(0,-1,0)
	quit $LB("OK",rc)
err ;
	quit $LB("ERR",$ze)	   
}
UpdateStoredDN(mirname,newDN,oldDN,nodetype) PUBLIC {
	try {
		s singleuser=$ZU(69,81)
	} catch {
		s singleuser=1  ;function doesn't exist, assume single user version
	}
	q:singleuser  ; single user instances skip updating the DN string
	;
	s id=""
	s id=$O(^SYS("MIRRORSET",mirname,"Member",id),1,info)
	while id'="" {
		if $LG(info,7)=oldDN {
			s name=$LG(info,1)
			s cls=##class(Config.MapMirrors).Open(mirname,name,,,.rc)
			if (''rc) {
				s cls.SSLComputerName=newDN
				s rc=cls.%Save()
				s cls=""
				if ('rc) {
					k err
					Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
					s rc="Failed to save "_mirname_":"_name_" to convert to new style DN value"
					s rc=rc_" ("_$G(err(1))_")"
					d $zu(9,"",rc,1 /* broadcast and log message*/,1  /* Warning */)
				}
			} else {
				d $zu(9,"","Failed to open "_mirname_":"_name_" to convert to new style DN value",1 /* broadcast and log message*/,1  /* Warning */)
			}
		}
		s id=$O(^SYS("MIRRORSET",mirname,"Member",id),1,info)
	}
}
SetupDNString(DN) PUBLIC {
  	s DN="/"_$TR(DN,",","/")
	s res="",len=$length(DN,"/"),na=""
	for i=2:1:len {
		s ele=$p(DN,"/",i)
		s na=$p(ele,"=") q:na=""
		s array(na)=$p(ele,"=",2)
	}
	i na="" quit ""
	s na=$o(array(""),1,val)
	while (na'="") {
		s res="/"_na_"="_val_res
		s na=$o(array(na),1,val)
	}
	quit res
}
ValidateSSLName(mirname,io) PUBLIC {
	use io 
	s certData=$System.Security.Users.SSLGetPeerCertificate()
	if certData="" quit 0
	s DN=$System.Encryption.X509GetField(certData,"Subject")
	if DN="" quit 0
	if $D(^SYS("MIRRORSET",mirname,"sslDN",DN),nodetype) {
		quit nodetype + $s($g(^SYS("allowMemberWithSameDN")):10,1:0)
	} 
	s oldDN=$$SetupDNString(DN)
	if $D(^SYS("MIRRORSET",mirname,"sslDN",oldDN),nodetype) {
		do UpdateStoredDN(mirname,DN,oldDN,nodetype)
		quit nodetype + $s($g(^SYS("allowMemberWithSameDN")):10,1:0)
	}
	Set rs=##class(%Library.ResultSet).%New("Config.MapMirrors:List")
	Do rs.Execute(mirname)
	While (rs.Next()) {
		Set sslDN=rs.Data("SSLComputerName")
    	s:sslDN'="" x=$i(CNA(sslDN),$s(rs.Data("MemberType")=0:1,1:10))
	}
	if $d(CNA(DN),val) Quit val + $s($g(^SYS("allowMemberWithSameDN")):10,1:0)
	quit 3_$c(0)_DN
}
SSLClient(mirname,io,ip,port,sslauth) PUBLIC {
	s saveIO=$I
	if 'sslauth {
		s sslon = 0
	} else {
	    s sslon=+$G(^SYS("MIRRORSET",mirname,"UseSSL"),0)
	}
	s x=$$tcpread(io,30)
	s resp=$LG(x,2)
	if $LG(x)'="OK" {
		quit "2,Host at "_ip_":"_port_" failed to send SSLON/SSLOFF /"_$LG(x)_": "_resp_"/"
	}
	if (resp="SSLOFF") {
		if sslon {
		   d $zu(9,"","SSLClient: Host at "_ip_":"_port_" does not have SSL enabled while it is enabled in local system",1 /* broadcast and log message*/,1  /* Warning */)
		   quit "2,Host at "_ip_":"_port_" sent SSLOFF but we require SSLON"
		}
	} elseif (resp="SSLON") {
		s configname="%MirrorClient"
		if 'sslon {
		   ; Even if we're not configured to use SSL, see if we can do it anyway
    	   Set cls=##class(Security.SSLConfigs).%OpenId(configname,,.status)
		   i '(''status) {
			   d $zu(9,"","SSLClient: Host at "_ip_":"_port_" requested SSL but configuration "_configname_" doesn't exist",1 /* broadcast and log message*/,1  /* Warning */)
			   quit "2,Host at "_ip_":"_port_" requested SSL but configuration "_configname_" doesn't exist"
		   }
		   i cls.Enabled=0 {
			   d $zu(9,"","SSLClient: Host at "_ip_":"_port_" requested SSL but configuration "_configname_" is disabled",1 /* broadcast and log message*/,1  /* Warning */)
			   quit "2,Host at "_ip_":"_port_" requested SSL but configuration "_configname_" is disabled"
		   }
		   k cls,status
		}
		use io:(::/SSL=configname)
		use saveIO
		s x=$$tcpread(io,30)
	    s resp=$LG(x,2)
		if $LG(x)'="OK" {
		   use io s sslerr=$system.Security.Users.SSLGetLastError() use saveIO
		   d $zu(9,"","SSLClient: Host at "_ip_":"_port_" failed to send SSLAUTH /"_$LG(x)_": "_resp_"/"_sslerr,1 /* broadcast and log message*/,1  /* Warning */)
		   quit "2,Host at "_ip_":"_port_" failed to send SSLAUTH /"_$LG(x)_": "_resp_"/"_sslerr
	    }
	    if resp="SSLAUTHONLY" {
	    } else {
		    if resp'="SSLAUTH" {
			   d $zu(9,"","SSLClient: Host at "_ip_":"_port_" sent /"_resp_"/ not SSLAUTH",1 /* broadcast and log message*/,1  /* Warning */)
		   		quit "2,Host at "_ip_":"_port_" sent /"_resp_"/ not SSLAUTH"
		    }
	    }
		; The agent has validated us, now make sure we have it
		; listed as an authorized mirror set member
	    if sslon {
		    s rc=$$ValidateSSLName(mirname,io)
			use saveIO
			if +rc=0 {
			   d $zu(9,"","SSLClient: Failed to read SSL DN for host at "_ip_":"_port,1 /* broadcast and log message*/,1  /* Warning */)
			   quit "2,Failed to read SSL DN for host at "_ip_":"_port
			}
			if +rc=3 {
			   d $zu(9,"","SSLClient: DN ("_$p(rc,$c(0),2)_") for host at "_ip_":"_port_" not found in authorization list",1 /* broadcast and log message*/,1  /* Warning */)
				quit "3,DN ("_$p(rc,$c(0),2)_") for host at "_ip_":"_port_" not found in authorization list"
			}
	    }
		do tcpsend(io,$LB("OK"))  
		; great, we're good to go
	} else {
	    try {
		    s lv=$LG(resp)
	    } catch exceptionv {
		    s lv=""
	    }
		if lv'="" {
			quit "2,Host at "_ip_":"_port_" ISCAgent answered :"_lv_":"_$LG(resp,2)
		}
		quit "2,Host at "_ip_":"_port_" sent "_resp_" not SSLON or SSLOFF"
	}
	quit 0
}
SSLServer(mirname,io,sslon="",requireAuthorization=0) PUBLIC {
	; Now the server tells us whether it requires this to be an 
	; SSL connection or not. It sends "SSLON" or "SSLOFF".
	s saveIO=$I
	i sslon="" s sslon=+$G(^SYS("MIRRORSET",mirname,"UseSSL"),0)
	if 'sslon && 'requireAuthorization {
		d tcpsend(io,"SSLOFF")
		quit 0
	}
	d tcpsend(io,"SSLON")
	s configname="%MirrorServer"
	use io:(::/SSL=configname)
	if 'sslon {
		d tcpsend(io,"SSLAUTHONLY")
	} else {
		d tcpsend(io,"SSLAUTH")
	}
	s x=$$tcpread(io,30)
	if $LG(x)'="OK" {
		use io s sslerr=$system.Security.Users.SSLGetLastError() use saveIO
		quit "-1,SSL Auth failed, "_$LG(x,2)_", SSLerror="_sslerr
	}
	s resp=$LG($LG(x,2))
	if resp'="OK" {
		quit "-2,Expected OK, got "_resp
	}
	; now make sure we have it listed as an authorized mirror set member
	s rc=$$ValidateSSLName(mirname,io)
	use saveIO
	if +rc=0 {
		quit "-3,Failed to read SSL name from remote client"
	}
	quit rc
}
tcpopen(mirname,addrlist,targguid,basedir,timeout,sslauth=1,timeout2=0,xdebug=0) {
	; Establish an outgoing connection to the agent at the
	; target address:port, exchange version information and 
	; validate the mirror guid of the remote end matches ours.
	; 
	; TCP Open does not change the current device if it returns
	; an error (1 or 2).
	;
	; addrlist is a comma separated list of addresses.
	; targguid is the guid of the target system. This can be null.
	; timeout2 when non-zero is the timout to use for alternative
	;          addresses in the addr. 'addr' can be a comma seperated
	;          list of addresses to try. when timeout2 is 0, only
	;          the 1st address is tried. When timeout2 is non-zero,
	;          all of the addresses are tried using timeout2 as the
	;          timeout after the 1st failed attempt (JO2562).
	;
	; Returns:
	;    0,io,<version> - success
	;    1,<text> - timed out opening connection to remote system
	;    2,<text> - other error communicating with remote system
	;    3,<text> - SSL failure.
	s $zt="err"
	i 'xdebug s xdebug=+$G(^MIRROR(mirname,"DebugRemoteISCAgent"))
	s command="ISC2REMCTRL "
	s connected=0
	s reportnode=+$G(^SYS("MIRRORSET"))
	if reportnode {
		s guid=$G(^SYS("MIRRORSET",mirname,"GUID"))
	} else {
		s cls=##class(Config.Mirrors).Open(mirname,,,.rc)
		if ('rc) {
			if sslauth {
				quit "2,Failed to open Config.Mirrors("_mirname_") in tcpopen"
			}
			s guid=""
		} else {
			s guid=cls.GUID
		}
	}
	s cls=""
	if guid=""&&sslauth quit "2,Local copy of Mirror GUID undefined"
	;
	s addr=$P(addrlist,",",1) ;pull off 1st address if its a list
	s port=$P(addr,"|",2)
	s ip=$P(addr,"|")
	s saveio=$I
	s jobtype=$ZU(61,10,$ZU(61))
	if (jobtype'=44) {
	   s io="|TCP|"_port
  	   s saveversion=0
	} else {
	   s io=$G(^||MirrorComm(ip,port,basedir),"")
	   s saveversion=1
	   if io="" {
		   s iodev=$I(^||MirrorComm)
		   ; devices 1 & 2 are used by ^MIRRORCOMM for the data and
		   ; ack jobs and while those jobs probably never call the agent
		   ; code, there's no sense in conflicting with them. Here devices
		   ; 1-10 are reserved for ^MIRRORMGR/^MIRROR/^MIRRORCOMM...
		   if iodev<10 {
			  s iodev=10
			  s ^||MirrorComm = iodev
		   }
		   s io="|TCP|"_iodev
		   s ^||MirrorComm(ip,port,basedir)=io
		   s ^||MirrorComm(io)=$LB(ip,port)
		   s connected=0
	   } else {
		  ; device is already open, see if we're still connected
		  try {
		     u io s za=$za
		     s connected=$Zboolean(+za,+8192,1)
		     if 'connected {
			     close io
		     }
		  } catch except {
			  ; most likely notopen
			  s connected=0
		  }
		  if connected {
		     try {
			    ; we're looking for a <WRITE> error here to figure
			    ; out whether the other side is still connected or not
			    do tcpsend(io,$LB("PING"))
				s x=$$tcpread(io,0)  ;should get back "OK"
				if $LG(x)'="OK" {
					c io
					s connected=0
				}
		     } catch exceptionv {
		        s connected=0
		        close io
		     }
		  }
		  if connected {
		     s version=$G(^||MirrorComm(ip,port,basedir,"version"),"")
		     quit "0,"_io_","_version  ;succeeded
		  }
	   }
	}
	s rcvbuf=##class(SYS.Mirror).TCPReceiveBufferSize(mirname)
again ;
	o io:(/Hostname=ip:/Port=port:/STREAM=1:/TCPRCVBUF=rcvbuf:/IOTABLE="RAW"):timeout
	s ok=$T
	if 'ok {
		if (timeout2) {
			s addrnum=2
			for  {
				s addr=$P(addrlist,",",addrnum)
				quit:addr=""  ;we're done, no more addresses
				s port=$P(addr,"|",2)
				s ip=$P(addr,"|")
				o io:(/Hostname=ip:/Port=port:/STREAM=1:/TCPRCVBUF=rcvbuf:/IOTABLE="RAW"):timeout2
				s ok=$T
				q:ok  ;it worked, we're done!
				s addrnum=addrnum+1  ;try next one
			}
		}
	    ; here we return 1, for an error code to indicate we timed
		; out trying to connect to the remote system as opposed to
		; some other (more unexpected error).
		if 'ok {
			quit "1,Timed out opening connection to "_ip_":"_port
		}
	}
	s connected=1
	; Send the string "ISC2REMCTRL " to indicate we want a CacheRemoteControl()
	; connection. This is followed by the manager's directory we want to 
	; connect to and then finally, we'll send the connection sub-type, 
	; M<1>C to indicate its a mirror connection
	; 
	u io w command w *-3
	u io read okstr#2:timeout u 0  ; wait for server to fork a connection handler
	if '$t {
	   c io 
	   s connected=0
	   ; restore original IO device
	   try {
	      use saveio
	   } catch exceptionv {
	   }
	   quit "2,Timed out waiting for initial ""OK"" from "_ip_":"_port
	}
	if okstr'="OK" {
	   c io 
	   s connected=0
	   ; restore original IO device
	   try {
	      use saveio
	   } catch exceptionv {
	   }
	   if okstr="un",command="ISC2REMCTRL " {
		   s command="ISC1REMCTRL "
		   goto again
	   }
	   quit "2,Server at "_ip_":"_port_" sent /"_okstr_"/ not /OK/"
	}
	;
	; Send the directory specification of the mgr directory on the server
	; we want to connect to with a $zwchar() length.
	u io w $zwchar($l(basedir)),basedir w *-3 u 0
	; Now the server will fire up the target version of Cache' and
	; pass it our connection. When Cache' is ready for us to send data
	; it will send us another "OK".
	Try {
		u io read okstr#2:timeout u 0  ; wait for Cache to start up
		if '$t {
		   c io 
		   s connected=0
		   ; restore original IO device
		   try {
		      use saveio
		   } catch exceptionv {
		   }
		   s okstr="TO"
		}
	} catch {
		if $ZE["<READ>" {
			s okstr="NE"
		} else {
			s okstr=$ZE
		}
	}
	if okstr'="OK" {
       c io 
	   s connected=0
	   ; restore original IO device
	   try {
	      use saveio
	   } catch exceptionv {
	   }
	   quit:okstr="TO" "2,Timed out waiting for 2nd ""OK"" from "_ip_":"_port_" ("_basedir_")"
	   if okstr="NE",command="ISC2REMCTRL " {
		   s command="ISC1REMCTRL "
		   goto again
	   }
       quit "2,Server at "_ip_":"_port_" ("_basedir_") sent /"_okstr_"/ not /OK/"
	}
	; 		
	; Now send the 3 character connection type: 
	;     M<1>C is a mirror connection
	if (xdebug) {
		do tcpsend(io,"M"_$C(1)_"D")
	} else {
		do tcpsend(io,"M"_$C(1)_"C")
	}
	; The other side should answer with M_$C(1)_C. 
	s x=$$tcpread(io,30)
	s resp=$LG(x,2)
	if $LG(x)'="OK" {
		close io
	    s connected=0
	    ; restore original IO device
	    try {
	      use saveio
	    } catch exceptionv {
	    }
		quit "2,Host at "_ip_":"_port_" failed to send initial ACK /"_$LG(x)_": "_resp_"/"
	}
	if resp'=("M"_$C(1)_"C") {
		close io
	    s connected=0
	    ; restore original IO device
	    try {
	      use saveio
	    } catch exceptionv {
	    }
		quit "2,Host at "_ip_":"_port_" sent incorrect initial ACK /"_resp_"/"
	}
	if ('sslauth) {
	   do tcpsend(io,$LB(""_mirname,-1))
	} else {
	   s usessl=+$G(^SYS("MIRRORSET",mirname,"UseSSL"),0)
	   if 'usessl {
		   s info=$G(^SYS("MIRRORSET",mirname,"Member",0))
		   s EncryptConnection=$zb(+$LG(info,11),1,1) ; Bit #1 means encrypt outgoing connections
		   if EncryptConnection {
			   s usessl=1
		   }
	   }
	   do tcpsend(io,$LB(""_mirname,usessl))
	}
	s resp=$$SSLClient(mirname,io,ip,port,sslauth)
	i resp {
		close io
	    s connected=0
		q resp
	}
	; Now we send our protocol version and the server send us back its 
	; protocol version
	s ourversion=$ZU(40,0,86) ;$$$REMOTE_MIRROR_CONNECTION_VERSION
	do tcpsend(io,$LB("VERSION",ourversion,reportnode))
	s x=$$tcpread(io,30)
	if $LG(x)'="OK" {
		close io
	    s connected=0
 	    ; restore original IO device
	    try {
	       use saveio
	    } catch exceptionv {
	    }
		quit "2,Host at "_ip_":"_port_" failed to send initial ACK /"_$LG(x)_": "_$LG(x,2)_"/"
	}
	s x=$LG(x,2) ; gets back $LB("VERSION",version)
	if (+$LL(x)'=2) || ($LG(x)'="VERSION") {
		c io
	    s connected=0
 	    ; restore original IO device
	    try {
	       use saveio
	    } catch exceptionv {
	    }
       quit "2,Host at "_ip_":"_port_" failed to send version"
	}
	s version=+$LG(x,2)
	if saveversion {
	   s ^||MirrorComm(ip,port,basedir,"version")=version
	}
	do tcpsend(io,$LB("GUID",guid,targguid))
	s x=$$tcpread(io)
	if $LG(x)'="OK" {
	   close io
	   s connected=0
 	   ; restore original IO device
	   try {
	      use saveio
	   } catch exceptionv {
	   }
	   quit "2,Server refused GUID:"_$LG(x,1)_": "_$LG(x,2)
	}
	s x=$LG(x,2)
	if $LG(x)'="OK" {
	   close io
	   s connected=0
 	   ; restore original IO device
	   try {
	      use saveio
	   } catch exceptionv {
	   }
	   quit $s($LG(x,1)="SSLERR"||($LG(x,2)["SSL DN"):"4",1:"2")_",Server refused GUID:"_$LG(x,1)_": "_$LG(x,2)
	}
	quit "0,"_io_","_version  ;succeeded
err ;
	s $ZT=""
	if $G(connected) s connected=0 close io
	quit "2,Unexpected error: "_$ze
}
tcpread(io,timeout=60) public {
	try {
	   s:'$L(timeout) timeout=60  ;if its specified as "", set it to the default
	   use io
	   read clen#4:timeout
	   if '$T {
		   s ret=$LB("TIMEOUT","Read on "_io_" timed out. No data sent in "_timeout_" seconds")
		   quit
	   }
	   s len=$zlascii(clen)
	   read str#len:5  ;short timeout because the data should be available.
	   if '$T {
		   s ret=$LB("ERR","Timed out waiting to read "_len_" characters")
	   } else {
		   s ret=$LB("OK",str)
	   }
	} catch exceptv {
		s ret=$LB("ERR",exceptv.DisplayString())	
	}
	quit ret
}
tcpsend(io,str) public {
	try {
	   use io
	   s len=$l(str)
	   s clen=$zlchar(len)
	   write clen,str
	   write *-3  ;force send
	} catch excptv {
	   ;
	}
}
tcpclose(io) {
	s jobtype=$ZU(61,10,$ZU(61))
	//if (jobtype'=$$$MIRRORMASTER) {
	    // SML2873 do tcpsend(io,$LB("QUIT"))
	    try {
		   close io
	    } catch exceptv {
		   ;
		}
	//}
}
 /*	AsyncServerDmn()
	Called from Server^MIRRORCOMM() when we receive a "M"_$C(1)_"S" message after
	we've validated the connection (eg. SSL state)
	We read a message from the client which should have the form:
	    $ZLCHAR(LEN),$LB(<msg code>,$LB(...args...),<local system guid>)
	where <local system guid> is our guid and we check this to ensure that
	   the client has reached the intended server (JO2817)
	tcpread/tcpwrite in MIRRORCTL are used to send/receive messages with this
	     routine 
 */
AsyncServerDmn(io,sslrc,mirname) PUBLIC {
	use 0
    if '$SYSTEM.Security.Check("%Admin_Manage","USE") {
	   d $zu(9,"","Insufficient privilege to run AsyncServerDmn",1 /* broadcast and log message*/,2  /* Severe error */)
	   quit
    }
	try {
		u io
		s resp=$$tcpread(io)
		s rc=$LG(resp)
		s text=$LG(resp,2)
		if $LG(resp)'="OK" {
			d $zu(9,"","AsyncServerDmn got an error on initial read: "_text,1 /* broadcast and log message*/,1  /* Warning */)
			quit
		}
		s function=$LG(text,1)
		s args=$LG(text,2)
		s targguid=$LG(text,3)
		if targguid'="" {
			s expected=$G(^SYS("MIRRORSET",mirname,"SYSGUID"))
			if $L(expected) && ($E(expected,1,$L(targguid))'=targguid) {
				s ourname=$P(expected,"^",2)
				d $zu(9,"","AsyncServerDmn: Ignored "_function_" message which specified a target system guid of "_targguid_" when ours is "_expected,0,0  /* Informational message */)
				s msg="Incorrect system guid ("_targguid_") specified. Local system guid for "_ourname_" in "_mirname_" is "_$P(expected,"^")
				do tcpsend(io,$LB("ERR",msg))
				quit
			}
		}
		if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","AsyncServerDmn: Received function: "_function)
		if function="GETCONFIGURATION" {
			s msg=$$GetMirrorConfig($LG(args))
			do tcpsend(io,$LB("OK",1,msg))
			quit
		}
		if function="GETCONFIG2" {
			s args=$LB(0,args)
			s msg=$$GetMirrorConfig2(args)
			do tcpsend(io,msg)
			quit
		}
		if function="GETMEMBERS" {
			s args=$LB(0,args)
			s msg=$$GetMirrorMembers(args)
			do tcpsend(io,msg)
			quit
		}
		if function="REJAPPROVAL" {
			s args=$LB(0,args)
			s msg=$$REJAPPROVAL(args)
			do tcpsend(io,msg)
			quit
		}
		if function="VERIFYCERT" {
			s msg=$$VerifyCert(args)
			do tcpsend(io,msg)
			quit
		}
		If +sslrc=3 do tcpsend(io,$LB("SSLERR","Request Rejected - SSL ID is not in list of authorized mirror members"))
		if function="GETJRNFILE" {
			do SendJrnfileFromAsync^MIRRORCOMM(io,args)
			quit
		}
		if function="GETJRNINFO" {
			s args=$LB(0,args)  ;0 = singleuser flag
			s msg=$$GetJRNINFO(args)
			do tcpsend(io,msg)
			quit
		}
		if function="GETDBSTATUS" {
			s msg=$$RSDGetDBStatus(io,args)
			do tcpsend(io,msg)
			quit
		}
		if function="GETDBLIST" {
			s msg=$$RSDGetDBList(io,args)
			do tcpsend(io,msg)
			quit
		}
		if function="SYNCHDBINFO" {
			s args=$LB(0,args)  ;0 = singleuser flag
		    s msg=$$SendDBInfo(args)
		    do tcpsend(io,msg) ;rc is $LB(status)
			quit
		}
		if function="GETNODEINFO" {
			s msg=$$RSDGetNodeInfo($LB(0,args))
			do tcpsend(io,msg)
			quit
		}
		if function="GETASYNCINFO" {
			s args=$LB(0,args)  ;0 = singleuser flag
			s msg=$$AsyncMemberInfo(args)
			do tcpsend(io,msg)
			quit
		}
		if function="ADDFOMEMBER" {
			s args=$LB(0,args)  ;0 = singleuser flag
			s msg=$$AddFOMember(args)
			do tcpsend(io,msg)
			quit
		}
		if function="DELMEMBER" {
			s args=$LB(0,args)
			s msg=$$DeleteMirrorMember(args)
			do tcpsend(io,msg)
			quit
		}
		if function="SYNCHCONFIG" {
			s args=$LB(0,args)
			s msg=$$SYNCHCONFIG(args)
			do tcpsend(io,msg)
			quit
		}
		if function="FETCHMEMBERZEROGUID" {
			s args=$LB(0,args)
			s msg=$$FETCHMEMBERZEROGUID(args)
			do tcpsend(io,msg)
			quit
		}
		if function="SETRECOVPARAM" {
			s args=$LB(0,args)
			s msg=$$SetRECOVPARAM(args)
			do tcpsend(io,msg)
			quit
		}
		if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","AsyncServerDmn received unrecognized message: "_function)
		do tcpsend(io,$LB("UNKNCMD",function))
	} catch {
		d $zu(9,"","AsyncServerDmn caught unexpected error: "_$ze,1 /* broadcast and log message*/,1  /* Warning */)
		d BACK^%ETN
	}
	quit  ;and we're done	
}
RSDGetDBStatus(io,args) {
	/* 	Async member version of GetDBStatus in remote.c.
			$LG(args,1) = local sfn to retrieve info for
			send back $LB(<reason>,<msg>) for failure or
	          $LB("OK",$LB(<dbstatus list>),cursizeinblks,maxsizeinblks)
 	*/
	s sfn=$lg(args,1)
	s dbinfo=$ZU(49,+sfn)
	if +dbinfo<0 {
		quit $LB("ERR","Invalid sfn - "_sfn)
	}
	if '+$zb(+$p(dbinfo,",",17),$zu(40,8,28),1) {	
		quit $LB("ERR","SFN #"_sfn_" is not mirrored")
	}
	s rc=$ZU(13,1,sfn)
	quit rc
}
RSDGetDBList(io,args) {
	/* 	Async member version of GetDBList in remote.c.
			$LG(args,1) = mirror name to retrieve info for
			send back $LB(<reason>,<msg>) for failure or
	          $LB("OK",[local sfn^mirror db name,]...pairs)
 	*/
	s mirname=$lg(args,1)
	s flag=+$LG(args,2)
	s rc=$ZU(13,2,mirname,flag)
	quit rc
}
RSDGetNodeInfo(args) PUBLIC {
	/* 	Called by ISCAgent or Async server for GETNODEINFO request.
			$LG(args,1) = mirror name to retrieve info for
			send back $LB(<reason>,<msg>) for failure or
	          $LB("OK",[local sfn^mirror db name,]...pairs)
 	*/
	s mirname=$LG($lg(args,2))
	Quit $$GetNodeInfoDetail(mirname,$LG(args))
}
GetNodeInfoDetail(mirname,single=0) PUBLIC {
	s rc=$ZU(13,3,mirname)
	if $LG(rc)="OK" {
		s info=$LG(rc,2)
		if info'["PRIMARY",info'["BACKUP"||($LG(rc,13)="SYNCHRONIZING")||($LG(rc,13)="TRANSITION"&&($SYSTEM.Mirror.IsMember()=1)) {
			s jrntime=##class(SYS.Mirror).GetJournalBlockTime(mirname)
			if jrntime {
				s jrntime=$zu(99,0)#$zh("100000000")-jrntime
				if jrntime<0 s jrntime=0
			} else {
				s jrntime=-1 ; Can't find the latency.
			}
			s dbinfo=$$GetMaxDejrnStart^MIRRORMGR(mirname,$s(single:4,1:3))
			if '$LG(dbinfo) {
				s dbtime=-1 ; Can't find the latency.
			} else {
				s dbtime=##class(SYS.Mirror).GetJournalBlockTime(mirname,$lg(dbinfo,2),$lg(dbinfo,3))
				if dbtime {
					s dbtime=$zu(99,0)#$zh("100000000")-dbtime
					if dbtime<0 s dbtime=0
				} else {
					s dbtime=-1 ; Can't find the latency.
				}
			}
			if $LL(rc)'>8 {
				s $list(rc,7)=jrntime
				s $list(rc,8)=dbtime
			} else {
				s $list(rc,11)=jrntime
				s $list(rc,12)=dbtime
			}
		}
	}
	quit rc
}
 /* BuildAgentAddrlist(info string)
    Takes a $list value from the ^SYS("MIRRORSET",<mirname>,"Member",<index>)
    global and returns a string of addresses which could be passed to
    tcpopen^MIRRORCTL() to try and contact the agent. The addresses all
    include the agent port #. The 1st address in the list (or the only
    address) is the agent address. If the mirror address/ecp addresses
    are different, they are included (seperated by commas) as alternatives
    which could be tried. The agent port is used with all of the addresses.
    The point is that when there are multiple networks, the agent may
    accept requests on all networks (fairly typical) however the agent
    network might be broken but the mirror network could be up and running.
    In this case we might even have a mirror connection established.
 */
BuildAgentAddrlist(info) PUBLIC {
	s addrlist=$LG(info,5)
	s agentaddr=$P(addrlist,"|")
	s agentport=$P(addrlist,"|",2)
	s miraddr=$P($LG(info,4),"|")
	s ecpaddr=$P($LG(info,3),"|")
	if miraddr'=agentaddr {
		s addrlist=addrlist_","_miraddr_"|"_agentport
	}
	if (ecpaddr'=agentaddr) && (ecpaddr'=miraddr) {
		s addrlist=addrlist_","_ecpaddr_"|"_agentport
	}
	quit addrlist
}
VerifyCert(Args) {
	s membername=$LG(Args,4),NeedCAFile=$LG(Args,5)
	s mm=##class(Config.MirrorMember).Open()
	s ourname=mm.SystemName
	if ourname=""||(ourname'=membername) {
		quit $LB("OK",$$Error^%apiOBJ(736,membername),0,"","")
	}
	s ReportingMember=(mm.AsyncMemberGUID'="")&&mm.AsyncMemberType
	s mm=""	
	s ssl=##class(Security.SSLConfigs).%OpenId("%MirrorServer",,.rc)
	if ('rc) {
		if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","MIRRORCTL: "_ourname_" failed to open MirrorSSL error = "_$SYSTEM.Status.GetErrorText(rc))
		quit $LB("OK",$$Error^%apiOBJ(735,ourname),ReportingMember,"","")
	}
	s RemoteIsReporting=+$LG(Args,3),Cert=$LG(Args,2),rqmember=$LG(Cert,3),cer=$LG(Cert)
	s Result=""
	s rc=ssl.%OnValidateObject(1)
	if ('rc) s Result=$$Error^%apiOBJ(739,ourname,$SYSTEM.Status.GetErrorText(rc))
	if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","MIRRORCTL: Local ("_ourname_") SSL validation result = "_$s(Result="":"OK",1:$SYSTEM.Status.GetErrorText(Result)))
	if cer'="",'RemoteIsReporting||('ReportingMember) {
		s rc = $SYSTEM.Encryption.X509VerifyCertChain(cer,ssl.CAFile)
		if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","MIRRORCTL: SSL verification from "_rqmember_" in "_ourname_", result="_rc)
		if rc'="OK" {
			s Result=$$Error^%apiOBJ(734,rqmember_":"_$LG(Cert,2),ourname_":"_ssl.CAFile,rc)
		}
	}
	quit $LB("OK",Result,ReportingMember,$LB(ssl.GetCertificate(),ssl.CertificateFile),$s(NeedCAFile:$LB(ssl.GetCAFile(),ssl.CAFile),1:""))
}
GetFIPSMode() PUBLIC {
	s $zt="err",FIPSMode=0
	s CPF=$p($zu(86),"*")
	o CPF:"RK\UTF8\":20
	u CPF
	s oldeof=$zu(68,40,1)
	f {
		r Record q:$ZEOF
		i $zcvt($e(Record,1,8),"U")="FIPSMODE" {
			s FIPSMode=+$p(Record,"=",2)
			q
		}
	}
	d $zu(68,40,oldeof) 
	c CPF
err quit FIPSMode
}

MIRRORMGR^INT^1^67214,47330
MIRRORMGR ;Mirror manager process for this system ;$Change: 7440104 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ; Revision: $Id: //iris/2024.1.3/databases/sys/rtn/sysconfig/mirrormgr.mac#1 $
 ;
 ; Entry points in this module are for internal use only and are
 ; subject to change in future versions.
 ; ---------------------------------------------------------------
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/_syMirror.inc#1 $ ($Change: 7440104 $) */
        /* Initializing is the state a member has at startup until it
           gets to wait^MIRRORMGR for the 1st time. At that point it has 
           either become the backup or primary or we set the role to null
           to indicate that it is up and running as opposed to still getting
           started */
				    /* Arbiter failover rules are in effect */
				    /* Agent contact is required */
					/* IsOtherNodeDown^ZMIRROR */
				/* The client supports the arbiter */
			 	/* This system is connected to the arbiter */
		  		/* The other failover member is connected to the arbiter */
		  		/* Either the QOSTimeout changed or the arbiter address changed.
		  		   we should look up the current values and use them */
				/* Arbiter job shoud close the connection and exit. The
				   retry routine can restart the arbiter if conditions
				   warrent. Generally used with clearing ArbiterSupported
				   when the backup is removed or demoted. Cleared when
				   the arbiter exits (eg. its a one time flag). */
 /* Revision: $Id: //iris/2024.1.3/databases/sys/inc/FILEINC.inc#1 $ ($Change: 7440104 $) */
 	q
Start(mirname) PUBLIC {
	d $zu(115,15,0)   ; Disable SQL ECP Sync.
	if mirname="" {
		s mirname=##class(Config.Mirrors).GetMirrorName()
		if mirname="" {
			d $zu(9,"","Mirroring not started, no mirror members defined",1 /* broadcast and log message*/,2  /* Severe error */)
			quit
		}
	}
	Lock +^MIRROR("PromoteDemote"):5
	If '$T {
		d $zu(9,"","Mirroring not started, another job is in the middle of Promote/Demote this member",1 /* broadcast and log message*/,1  /* Warning */)
		quit
	}
	if $$CheckMirrorRunning(mirname,1) {
		Lock -^MIRROR("PromoteDemote")
		d $zu(9,"",$ZN_" already running in process: "_$G(^MIRROR(mirname,"MgrJobID")),1 /* broadcast and log message*/,1  /* Warning */)
		quit
	}
	Lock -^MIRROR("PromoteDemote")
	s origtype=$ZU(61,10,$ZU(61),44)  ;Set our jobtype
    do $ZU(68,40,1) ; Use $ZEOF, not <ENDOFFILE> for reading files
	if $System.License.NoMirror() {					/* RFD2026 */
	  d $zu(9,"","Mirroring not started, license does not allow Mirroring.",1 /* broadcast and log message*/,2  /* Severe error */)
	  goto dmnexit
	}
	s $zt="err"
	s logerr=1  ; record errors in ^%ET
	if ($zu(78,3)="") {
		d $zu(9,"","Mirroring not started, journal directory path is not initialized in the system.",1 /* broadcast and log message*/,2  /* Severe error */)
		goto dmnexit
	}
revalidate ;
	s cls=##class(Config.MirrorMember).Open(,,.rc)
	if ('rc) {
		d $zu(9,"","Mirroring not started, failed to read mirror member configuration",1 /* broadcast and log message*/,2  /* Severe error */)
		goto dmnexit
	}
	s reportingNode=cls.isAsyncMember()
	s systemid=cls.SystemName
	s validmember=cls.ValidatedMember
	if 'reportingNode {
	   s asyncmembertype=-1  ;not an async member 
	} else {
	   ; 0 = DR, non-zero = reporting (see class doc for details)
	   s asyncmembertype=cls.AsyncMemberType
	}
	s info=0
	s status=cls.CheckSecurity(.info)
	if ('status) {
		d $zu(9,"","Mirroring not started, error during security check. Status= "_$SYSTEM.Status.GetErrorText(status),1 /* broadcast and log message*/,2  /* Severe error */)
		goto dmnexit
	}
	if '+info {
		; STU^MIRROR checks this but we want to check this here as well in case
		; this is kicked off manually at some point.
		d $zu(9,"","Mirror service is not enabled. Mirroring not started.",1 /* broadcast and log message*/,2  /* Severe error */)
		goto dmnexit
	}
	s cls=""
	if ($D(^MIRROR(mirname,"donotstart"))) {
		d $zu(9,"","Mirroring not started; the mirror management interface has been used to stop mirroring on this member until further notice",1 /* broadcast and log message*/,1  /* Warning */)
		goto dmnexit
	} 
	if '$$CheckForCopiedInstance(mirname) {
		d $zu(9,"","Mirroring not started, this instance appears to have been copied. See ^MIRROR",1 /* broadcast and log message*/,2  /* Severe error */)
		goto dmnexit  ;set STOPPED state and indicate we're not running
	}
	s encryptedJournal=##class(%SYS.Journal.System).IsJournalEncryptionEnabled(3)
	if 'reportingNode {
	   s cls=##class(Config.Mirrors).Open(mirname,,,.rc)
	   if ('rc) {
		  d $zu(9,"","Mirroring not started, failed to open Config.Mirrors("_mirname_")",1 /* broadcast and log message*/,2  /* Severe error */)
		  goto dmnexit
	   }
	   if encryptedJournal,'cls.UseSSL {
		  d $zu(9,"","Mirroring not started - encrypted journal file requires use of SSL",1 /* broadcast and log message*/,2  /* Severe error */)
		  goto dmnexit
	   }
	   do $SYSTEM.Mirror.FailoverRule(2)
	   Set mytime=$G(^SYS("MIRRORTIME",mirname))
	   Set PrimaryTime=$p(mytime,"^",2)
	   Set id=$o(^SYS("MIRRORSET",mirname,"Member",101-1),1,info)
	   while (id'="") {
		   s name=$LG(info,1)
		   if $LG(info,8)'=0 {
			   s rc=$$GetFailoverTimestamp^MIRRORCTL(mirname,id)
			   if ($LG(rc)="OK") {
				   s time=$LG(rc,2)
				   if '(time=""||'(time-mytime>0||((time-mytime)=0&&($p(time,",",2)>$p(mytime,",",2)))))||$LG(rc,4) {
					   s PromotedDR(id)=$LB(info,rc),PromotedDR=$i(PromotedDR)
				   }
			   }
		   }
		   Set id=$o(^SYS("MIRRORSET",mirname,"Member",id),1,info)
	   }
	   if $G(PromotedDR)>2 {
		   d $zu(9,"","Mirroring not started, more than two promoted async members exist.",1 /* broadcast and log message*/,2  /* Severe error */)
		   goto dmnexit
	   }
	   if $G(PromotedDR)=2 {
		   s id=$o(PromotedDR(""))
		   if $d(^SYS("MIRRORSET",mirname,"Member",1),info) {
			   s mobj=##class(Config.MapMirrors).Open(mirname,$lg(info),,,.rc)
			   if '('rc) {
				   s mobj.MemberType=$LG($LG(PromotedDR(id)),8)
				    s rc=mobj.%Save()
				    if ('rc) {
					    d $zu(9,"",$ZN_" failed to demote "_$lg(info)_" when mirror starting, Error="_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
					}
					s mobj=""
			   }
		   }
		   s info=$lg(PromotedDR(id))
		   s mobj=##class(Config.MapMirrors).Open(mirname,$lg(info),,,.rc)
		   if '('rc) {
			   s mobj.MemberType=0
			   s rc=mobj.%Save()
			   if ('rc) {
				   d $zu(9,"",$ZN_" failed to promote first "_$lg(info)_" when mirror starting, Error="_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
			   }
			   s mobj=""
		   }
		   s id=$o(PromotedDR(id))
		   s info=$lg(PromotedDR(id))
		   s NewAsyncType=$LG(info,8)
		   s $list(info,8)=0
		   s ^MIRROR(mirname,"MgrJobID")=""
		   s rc=##class(SYS.MirrorConfiguration).DemoteToAsyncMember(mirname,info,NewAsyncType,0,1)
		   if ('rc) {
			   d $zu(9,"","Failed to demote to async member "_$lg(info)_". Error:"_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
			   d $zu(9,"","Mirroring not started, demote to async failed. There may be a mirror configuration problem.",1 /* broadcast and log message*/,2  /* Severe error */)
			   goto dmnexit
		   } else {
			   Halt
		   }
	   }
	   if $G(PromotedDR) {
		   s id=$o(PromotedDR(""),1,info)
		   s rc=$LG(info,2)
		   s info=$LG(info)
		   s name=$LG(info)
		   s IamDefinedPrimary=cls.DefinedPrimary'=""&&(cls.DefinedPrimary=$LG($G(^SYS("MIRRORSET",mirname,"Member",0))))
		   if IamDefinedPrimary&&(cls.DefinedPrimary=$LG(rc,3)) {
			   if (+$G(^SYS("MIRRORSET",mirname,"Member"),0) > 0) {
				   s bname=$LG(^SYS("MIRRORSET",mirname,"Member",1))
				   s mobj=##class(Config.MapMirrors).Open(mirname,bname,,,.rc)
				   if '('rc) {
					   s mobj.MemberType=$LG(info,8)
					   s rc=mobj.%Save()
					   if ('rc) {
						   d $zu(9,"",$ZN_" failed to demote "_bname_" when mirror starting, Error="_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
					   }
					   s mobj=""
				   }
			   }
			   s mobj=##class(Config.MapMirrors).Open(mirname,name,,,.rc)
			   if '('rc) {
				   s mobj.MemberType=0
				   s rc=mobj.%Save()
				   if ('rc) {
					   d $zu(9,"",$ZN_" failed to promote "_name_" when mirror starting, Error="_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
				   }
				   s mobj=""
			   }
			   if 'validmember {
				   s clsx=##class(Config.MirrorMember).Open(,,.rc)
				   s clsx.ValidatedMember=1
				   s validmember=1
				   s rc=clsx.%Save()
				   s clsx=""
			   }
		   } elseif validmember {
			   d $zu(9,"","Mirroring not started, because async member '"_name_"' has been promoted to a failover member or it is supposed to be demoted to an async member but remains as a failover member. You must manually edit the "_"iris"_".cpf configuration file, and in the [MirrorMember] section set ValidatedMember=0.",1 /* broadcast and log message*/,2  /* Severe error */)
			   goto dmnexit
		   }
	   }
	   if validmember Set $p(^SYS("MIRRORTIME",mirname),"^")=$ZTS,TimestampSet=1
	} else {
		Kill ^SYS("MIRRORTIME",mirname)
	}
	s cls=""
	s mirguid=$G(^SYS("MIRRORSET",mirname,"GUID"))
	if ('$L(mirguid)&&('reportingNode))||'$L(systemid) {
		d $zu(9,"","Mirror manager failed to start: Missing mirror configuration information",1 /* broadcast and log message*/,2  /* Severe error */)
		goto dmnexit
	}
	k ^MIRROR(mirname,"PendingNewMember"),^MIRROR(mirname,"PendingDNUpdates")
	k ^MIRROR(mirname,"PrimaryDeltaTime")
	k ^MIRROR(mirname,"DejournalWorker")
	k ^MIRROR(mirname,"PrimaryMember")
	k ^MIRROR(mirname,"DejournalReader")
	k ^MIRROR(mirname,"StartBackupDmnFailed")
	;
	s miridx=$SYSTEM.Mirror.MirrorNameToIndex(mirname,1)+1
	d $SYSTEM.Mirror.GetInfo(6,miridx-1)
	if (reportingNode) ! (+$G(^SYS("MIRRORSET",mirname,"Member"),0) < 1) {
		s NeedProgagateData=0
	} else {
		s NeedProgagateData=1
	}
	k ConnectHistory  ;tracks 10 most recent connections to the primary
	;
	if '$$CheckVersion(mirname) {
		goto dmnexit
	}
	s localinfo=^SYS("MIRRORSET",mirname,"Member",0)
	if 'reportingNode {
		s x=##class(Config.Startup).Open()
		s locssp=x.DefaultPort
		s x=""
		if ($p($LG(localinfo,3),"|",2)'=locssp) || ($p($LG(localinfo,4),"|",2)'=locssp) {
			d $zu(9,"","Mirror manager failed to start: Mismatching superserver port ("_locssp_" vs "_$p($LG(localinfo,3),"|",2)_")",1 /* broadcast and log message*/,2  /* Severe error */)
			goto dmnexit
		}
		if $G(^SYS("MIRRORSET",mirname,"Member"),0)'=0 {
			s cls=##class(Config.Mirrors).Open(mirname,,,.rc) 
			if ('rc) {
				d $zu(9,"","Mirroring not started, failed to read mirror configuration for "_mirname,1 /* broadcast and log message*/,2  /* Severe error */)
				goto dmnexit
			}
			if cls.VirtualAddress'="" {
			    s otherinfo=$G(^SYS("MIRRORSET",mirname,"Member",1))
				if ($p($LG(otherinfo,3),"|",2)'=locssp) || ($p($LG(otherinfo,4),"|",2)'=locssp) {
					s msg = "There is a virtual address defined and the superserver port of this member is different than the other member. "
					s msg = msg_"Client applications may not be able to connect to both mirror members using the virtual address."
					d $zu(9,"",msg,1 /* broadcast and log message*/,1  /* Warning */)
				}
			}
			s cls=""
		}
	}	
    if 'reportingNode || (asyncmembertype=0) {
		s sec=##Class(Security.System).%OpenId("SYSTEM",,.rc)
		if ('rc) {
			d $zu(9,"","Failed to open "_"SYSTEM"_" security class to reset InactiveLogin limit: "_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
		} else {
			if sec.InactiveLimit {
				d $zu(9,"",$s('reportingNode:"Failover",1:"DR")_" mirror member changed the InactiveLimit system security property from "_sec.InactiveLimit_" to 0.",0,0  /* Informational message */)
				s sec.InactiveLimit=0
				s rc=sec.%Save()
				if ('rc) {
					d $zu(9,"","Failed to save zeroed InactiveLimit: "_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
				}
			}
			s sec=""
		}
    }
    d $zu(9,"","Mirror manager for "_mirname_" starting",0,0  /* Informational message */)
	;
	do $SYSTEM.Mirror.ModifyControlJob(miridx,1)  ;1 = set us as ctrl job
	;
    ; ("State") is just for informational purposes. 
    ; ("Status") tracks the status of other members
    ; ("MSG") is the message queue used by the communication channel
    ;
	s ^MIRROR(mirname,"State")="Starting"
	k ^MIRROR(mirname,"Status")  ;reset our view of the other nodes
	k ^MIRROR(mirname,"MSG")     ;and our messaging i/o queue
	k ^MIRROR(mirname,"DejournalProcessor")
	k ^MIRROR(mirname,"retry")
	k ^||MIRROR(mirname,"retry")
	;
	do AddMonitorEntry(mirname,"(""(rc) { s rc=$$MonitorJournalLogSize("""""_mirname_""""") }"", .rc)")
	s ^MIRROR(mirname,"Role")=""
	s role=""
	s forceBecomePrimary=0
	s signalpid=0  ;used in the waitloop as the pid to wakeup
	;
    s logSevereFailureMessage=1
    s wasBackup=0  ;Set when we used to be the backup
	if $G(^SYS("MIRRORSET",mirname,"Member"),0)>0 {
		do CheckForExtraJournalFiles(mirname)
rechecklastfile
		s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
		if +rc>0 {
			s info=$zu(78,22,$P(rc,",",2),99)
			if info<1 {
				/* Someone deleted the last journal file without rebuild the mirror journal log, lets rebuild it and check again. */
				s x=$$BuildMirrorLogFromJournalFiles^MIRRORCOMM(mirname,0,"")
				if +x<0 {
					d $zu(9,"","CheckForDuplicateLastJournalfiles failed to rebuild mirror journal log file: "_$P(x,",",2,*),1 /* broadcast and log message*/,2  /* Severe error */)
					goto dmnexit
				}
				goto rechecklastfile
			}
			s validend=+$P(info,",",16+1)
			if validend'>0 {
				/* The last file has no valid end, check for duplicate last file, the last file could be removed. */
				do CheckForDuplicateLastJournalfiles(mirname,+rc,$P(rc,",",2),info)
				/* In case the last file was removed, let's get the new last file. */
				s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)
				if +rc'>0 {
					d $zu(9,"","After CheckForDuplicateLastJournalfiles, can't find last journal file in log.",1 /* broadcast and log message*/,2  /* Severe error */)
					goto dmnexit
				}
				s info=$zu(78,22,$P(rc,",",2),99)
				if info<1 {
					/* This should not happen, but if it did then abort mirroring. */
					d $zu(9,"","After CheckForDuplicateLastJournalfiles, last journal file disappeared.",1 /* broadcast and log message*/,2  /* Severe error */)
					goto dmnexit
				}
				s validend=+$P(info,",",16+1)
			}
			if validend>0 {
				do ClearLastFileValidEnd(mirname)
				d $zu(9,"","Mirror Startup: valid end ("_validend_") of last journal file "_$P(rc,",",2)_"("_(+rc)_") is cleared.",0,0  /* Informational message */)
			}
		}
	}
	d $system.Util.SetInterruptEnable(1)
    do $SYSTEM.Mirror.SetStatus("TRANSITION",mirname)
    if 'reportingNode,$G(^SYS("MIRRORSET",mirname,"VirtualAddress"))'="" {
	    s x=$$DeleteVirtualAddress(mirname,"",0,"",1)
    }
	Kill ^MIRROR(mirname,"DejournalFile") Set ^MIRROR(mirname,"DejournalStarted")=-1
	Kill ^MIRROR(mirname,"DejournalRunning")
	Lock +^MIRROR(mirname,"DejournalBlock")
	s x=$SYSTEM.Mirror.DejournalBlock(mirname,+$G(^MIRROR(mirname,"DejournalBlock")))
	Lock -^MIRROR(mirname,"DejournalBlock")
reinit ;come back here if we're not a valid member or we have a problem
	S CompletedReinit=0
	do $SYSTEM.Mirror.LastFileValidFlag(0)
	do $SYSTEM.Mirror.ActiveBackupFlag(0)
	do $SYSTEM.Mirror.SetStatus("TRANSITION",mirname)
	s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
	if reportingNode&&($LG(localinfo,9)="") {
		s rc=$$PrimaryDiscovery(mirname)
		if 'rc {
			do AddRetryEntry(mirname,"(""(rc) { s rc=$$PrimaryDiscovery("""""_mirname_""""") }"", .rc)","PrimaryFound1","Cannot determine primary mirror member")
			goto wait
		}
PrimaryFound1 s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
	}
	if 'reportingNode,validmember,systemcnt,'$G(PromotedDR) {
		s rc=$$ValidateFailoverPartner(mirname,forceBecomePrimary)
		if 'rc {
			do AddRetryEntry(mirname,"(""(rc) { s rc=$$ValidateFailoverPartner("""""_mirname_""""","_forceBecomePrimary_") }"", .rc)","reinit","Failed to validate failover partner")
			goto wait
		}
	}
	; reading the mirrored db's to get the starting point or validating the
	; mirror journal log
	if 'reportingNode,'validmember {
	   ; if we're not a valid mirror member then try to contact the other 
	   ; mirror members to see if we're valid now
	   if $G(^SYS("MIRRORSET",mirname,"DefinedPrimary"))'=":NOPARTNER" {
		   s cls=##class(Config.Mirrors).Open(mirname,,,.rc)
		   if ('rc) {
			   d $zu(9,"","Failed to read [Mirrors] configuration section for "_mirname,1 /* broadcast and log message*/,1  /* Warning */)
			   do AddRetryEntry(mirname,"(""(rc) { s rc=$$ValidateMirrorMembership^MIRRORCOMM("""""_mirname_""""") }"", .rc)","reinit","Failed to read [Mirrors] configuration section")
			   goto wait
		   }
		   s cls.DefinedPrimary=""
		   s rc=cls.%Save()
		   s cls=""
		   if ('rc) {
			   d $zu(9,"","Failed to Clear DefinedPrimary for "_mirname,1 /* broadcast and log message*/,1  /* Warning */)
			   do AddRetryEntry(mirname,"(""(rc) { s rc=$$ValidateMirrorMembership^MIRRORCOMM("""""_mirname_""""") }"", .rc)","reinit")
			   goto wait
		   }
	   }
	   if '$G(PromotedDR) {
		   s validmember=$$ValidateMirrorMembership^MIRRORCOMM(mirname)
		   if 'validmember {
			   do AddRetryEntry(mirname,"(""(rc) { s rc=$$ValidateMirrorMembership^MIRRORCOMM("""""_mirname_""""") }"", .rc)","reinit","Failed to validate mirror membership")
			   goto wait
		   }
		   s rc=$$CheckOutOfSyncJournalFiles(mirname,1)
		   if 'rc {
			   s validmember=0
			   do AddRetryEntry(mirname,"(""(rc) { s rc=$$ValidateMirrorMembership^MIRRORCOMM("""""_mirname_""""") }"", .rc)","reinit","Failed to run CheckOutOfSyncJournalFiles")
			   goto wait
		   } elseif rc<0 {
			   goto dmnexit
		   }
		   if validmember=1 {
				s mm=##class(Config.MirrorMember).Open(,,.rc)
				if '('rc) {
					s mm.ValidatedMember = 1
					s rc=mm.%Save()
				}
				if ('rc) {
					s validmember=0
					do AddRetryEntry(mirname,"(""(rc) { s rc=$$ValidateMirrorMembership^MIRRORCOMM("""""_mirname_""""") }"", .rc)","reinit","Failed to set ValidatedMember=1")
					goto wait
				}
				k mm
				goto goodmember
		   }
		   if +validmember=2 {
			   s id=$p(validmember,",",3)
			   s NewAsyncType=$p(validmember,",",2)
			   if id'="" {
				   s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
				   s $list(info,8)=0
			   } else {
				   s info=""
			   }
			   s NotifyPrimary=1
			   goto demotemember
		   }
		   if +validmember=3 {
			   s info=$p(validmember,",",3,999)
			   s NewAsyncType=$p(validmember,",",2)
			   s NotifyPrimary=0
			   goto demotemember
		   }
	   }
	   s id=$o(PromotedDR(""),1,info)
	   s rc=$LG(info,2)
	   s info=$LG(info)
	   s definedPrimary=$LG(info)
	   if $LG(rc,3)'=":NOPARTNER"&&('$LG(rc,5)) {
		   s oldtype=$li(info,8)
		   s $li(info,8)=0
		   s rc=$$CheckOutOfSyncJournalFiles(mirname,info)
		   if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","CheckOutOfSyncJournalFiles returned rc="_rc)
		   if 'rc {
			   do AddRetryEntry(mirname,"(""(rc) { s rc=$$RetryCheckOutOfSyncJournalFiles^MIRRORMGR("""""_mirname_""""","_id_") }"", .rc)","reinit","Failed to check out-of-sync journal files")
			   goto wait
		   } elseif rc<0 {
			   goto dmnexit
		   }
		   s $li(info,8)=oldtype
	   }
	   s NewAsyncType=$LG(info,8)
	   if NewAsyncType=0 s NewAsyncType=2
	   s mlist=definedPrimary_","_$lg(^SYS("MIRRORSET",mirname,"Member",0))
	   s targguid=$lg(info,2)
	   s basedir=$lg(info,6)
	   s agentip=$$BuildAgentAddrlist^MIRRORCTL(info)
	   s validmember=$$ValidatePromoteMembership^MIRRORCOMM(mirname,agentip,targguid,basedir,.mlist)
	   if validmember {
		   if systemcnt>0 {
			   s mobj=##class(Config.MapMirrors).Open(mirname,$LG(^SYS("MIRRORSET",mirname,"Member",1)),,,.rc)
			   if ('rc) {
				   d $zu(9,"","Failed to open failover member "_$LG(^SYS("MIRRORSET",mirname,"Member",1))_" Error:"_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
DFfailed		   s cls=##class(Config.MirrorMember).Open(,,.rc)
				   s cls.ValidatedMember=0
				   s rc=cls.%Save()
				   s cls=""
				   s validmember=0
				   do AddRetryEntry(mirname,"(""(rc) { s rc=1 }"", .rc)","reinit","Failed to open [MapMirrors] section in the configuration")
				   goto wait
			   }
			   s mobj.MemberType = NewAsyncType
			   s rc=mobj.%Save()
			   if ('rc) {
				   d $zu(9,"","Failed to demote failover member "_$LG(^SYS("MIRRORSET",mirname,"Member",1))_" Error:"_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
				   goto DFfailed
			   }
			   s mobj=""
		   } 
		   s obj=##class(Config.MapMirrors).Open(mirname,definedPrimary,,,.rc)
		   if ('rc) {
			   d $zu(9,"","Failed to open failover member "_definedPrimary_" Error:"_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
			   goto DFfailed
		   } else {
			   s obj.MemberType=0
			   s rc=obj.%Save()
			   s obj=""
			   if ('rc) {
				   d $zu(9,"","Failed to modify failover member "_definedPrimary_" Error:"_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
				   goto DFfailed
			   }
		   }
		   kill PromotedDR goto reinit
	   } else {
		   s rmtisfailover=mlist[(","_definedPrimary_",")
		   s localisfailover=($LG(info,8)=0)
		   if rmtisfailover'=localisfailover {
			   s $list(info,8)=$s(rmtisfailover:0,1:2)
		   } else {
			   s info = ""
		   }
		   s othername=$LG($G(^SYS("MIRRORSET",mirname,"Member",1)))
		   if othername'="",mlist'[(","_othername_",") {
			   s mobj=##class(Config.MapMirrors).Open(mirname,othername,,,.rc)
			   if (''rc) {
				   s mobj.MemberType = 2
				   s rc=mobj.%Save()
				   s mobj=""
			   }
		   }
		   s NotifyPrimary=0
demotemember ;
		   s ^MIRROR(mirname,"MgrJobID")=""
		   L -^MIRROR(mirname,"MgrJobID")
		   do $SYSTEM.Mirror.ModifyControlJob(miridx,0)   ; clear us as control job.
		   s rc=##class(SYS.MirrorConfiguration).DemoteToAsyncMember(mirname,info,NewAsyncType,NotifyPrimary,1)
		   if ('rc) {
			   d $zu(9,"","Failed to demote to async member. Error:"_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
			   L +^MIRROR(mirname,"MgrJobID")
			   do $SYSTEM.Mirror.ModifyControlJob(miridx,1)   ; clear us as control job.
			   goto DFfailed
		   } else {
			   Halt
		   }
	   }
	}
	k PromotedDR
goodmember ;
	s rc=$$ValidateAgent^MIRRORCOMM(reportingNode,mirname)
	if 'rc {
	   do AddRetryEntry(mirname,"(""(rc) { s rc=$$ValidateAgent^MIRRORCOMM("""""_reportingNode_""""","""""_mirname_""""") }"", .rc)","reinit","Failed to validate local agent")
	   goto wait
	}
    if '$$InitDejournal(miridx,mirname) {  ; id=1 is failover backup node connection -> primary
	    d $zu(9,"","("_mirname_") Failed to initialize dejournal memory. Mirror manager exited",1 /* broadcast and log message*/,2  /* Severe error */)
		do $SYSTEM.Mirror.ModifyControlJob(miridx,0)  ;0 = clear ctrl job
		goto dmnexit
    }
	; 
	do MountMirroredDBs("Mirror startup",mirname)
	k ^MIRROR(mirname,"dejrnchkpnt")  ;set by GetMirrorDejournalInformation
	k ^MIRROR(mirname,"firstdejrnchkpnt")  ;set by GetMirrorDejournalInformation
	k ^MIRROR(mirname,"transroll")    ;set by ValidateMirrorJournalLog
	k ^MIRROR(mirname,"lastvalidjrnfile") ;set by ValidateMirrorJournalFiles
	k ^MIRROR(mirname,"DBDejournaled")  ; set when DejournalProcessFile is called on the mirrored databases.
	s rc=$$GetMirrorDejournalInformation(mirname,1)
	if 'rc {
	   do AddRetryEntry(mirname,"(""(rc) { s rc=$$GetMirrorDejournalInformation("""""_mirname_""""",1) }"", .rc)","reinit","Failed to determine dejournaling start point")
	   goto wait
	}
    s rc=$$ValidateMirrorJournalLog(mirname)
    if 'rc {
       do AddRetryEntry(mirname,"(""(rc) { s rc=$$RetryValidateMirrorJournalLog("""""_mirname_""""",1) }"", .rc)","reinit","Failed to validate mirror journal log")
        d StopDejournalProcessor(mirname,0)
	   goto wait
	}
	s useOldActiveBackupCode=0
	if 'reportingNode {
		s info=$G(^SYS("MIRRORSET",mirname,"Member",1))
		if info'="" {
			s mtype=+$LG(info,8)
			if mtype'=0 {
				d $zu(9,"","ActiveBackup not cleared for member #1 (type "_mtype_") which is not a failover member",1 /* broadcast and log message*/,1  /* Warning */)
			} else {
				s name=$lg(info,1)
				s rc=$$ClearActiveBackup^MIRRORCTL(mirname,1)
				if $LG(rc)="UNKNCMD" {
			        d $zu(9,"","ClearActiveBackup not supported by other mirror member - using old failover logic",1 /* broadcast and log message*/,1  /* Warning */)
	        		s useOldActiveBackupCode=1
				} elseif $LG(rc)="ERR" {
					if forceBecomePrimary {
						d $zu(9,"","Ignoring connection ERR clearing active backup flag because forceBecomePrimary flag is set",1 /* broadcast and log message*/,1  /* Warning */)
					} else {
						; We can't continue until we get an OK back from this routine
						d $zu(9,"","ClearActiveBackup failed: "_$LG(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
						do AddRetryEntry(mirname,"(""(rc) { s rc=$$RetryClearActiveBackup("""""_mirname_""""") }"", .rc)","Restart","Error contacting other failover member to clear active backup state")
						d StopDejournalProcessor(mirname,0)
						goto wait
					}
				} elseif $LG(rc)="TIMEOUT" {
					if forceBecomePrimary {
						d $zu(9,"","Ignoring timeout clearing active backup flag because forceBecomePrimary flag is set",1 /* broadcast and log message*/,1  /* Warning */)
					} else {
						d $zu(9,"","Failed to contact other failover member to clear active backup flag - waiting for other node to become available",1 /* broadcast and log message*/,1  /* Warning */)
						do AddRetryEntry(mirname,"(""(rc) { s rc=$$RetryClearActiveBackup("""""_mirname_""""") }"", .rc)","Restart","Timed out contacting other failover member to clear activate backup state")
				        d StopDejournalProcessor(mirname,0)
						goto wait
					}
				}
			}
		}
	   if '$G(TimestampSet) Set $p(^SYS("MIRRORTIME",mirname),"^")=$ZTS,TimestampSet=1
	}
	s CompletedReinit=1
Restart ; 
	k ^||MIRROR(mirname,"BackupClient"),^MIRROR(mirname,"BackupClient")
	if '$G(CompletedReinit) goto reinit
	do $SYSTEM.Mirror.ModifyDecidingState(0)
	if '$$CheckValidFailoverMember() {
         d StopDejournalProcessor(mirname,0)
		g revalidate
	}
	if reportingNode {
		s rc=$$PrimaryDiscovery(mirname)
		if 'rc {
			do AddRetryEntry(mirname,"(""(rc) { s rc=$$PrimaryDiscovery("""""_mirname_""""") }"", .rc)","PrimaryFound2","Failed to locate the primary mirror member")
			d StopDejournalProcessor(mirname,0)
			goto wait
		}
PrimaryFound2 s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
	}
	if $SYSTEM.Mirror.ActiveBackupFlag() {
		; When activebackupflag is set we know we have all the journal data
		; so we can skip directly to ActiveBackupRestart
		if useOldActiveBackupCode {
			; If the other mirror member doesn't support the new code then we need
			; to clear the activebackup flag ourselves here. At topDecisionLoop we
			; will need to try to contact the other member to figure out its status
			; because the ActiveBackupFlag doesn't tell us whether it has started or
			; not.
			do $SYSTEM.Mirror.ActiveBackupFlag(0)
			d $zu(9,"","ActiveBackup state cleared - Old failover code still in effect",0,0  /* Informational message */)
		}
		if $$Updatelastjvalidjrnfile(mirname) {
			goto ActiveBackupRestart
		}
		do $SYSTEM.Mirror.ActiveBackupFlag(0)
		if $SYSTEM.Mirror.LastFileValidFlag() do ClearLastFileValidEnd(mirname)
	}
    if '$$InitDejournal(miridx,mirname) {  ; id=1 is failover backup node connection -> primary
	    d $zu(9,"","("_mirname_") Failed to re-initialize dejournal memory. Mirror manager exited",1 /* broadcast and log message*/,2  /* Severe error */)
		do $SYSTEM.Mirror.ModifyControlJob(miridx,0)  ;0 = clear ctrl job
		d StopDejournalProcessor(mirname,0)
	    goto wait
    }
    if forceBecomePrimary {
	    d $zu(9,"","Attempting startup with forceBecomePrimary flag set",1 /* broadcast and log message*/,1  /* Warning */)
    }
    i 'reportingNode do CheckNewDataForPromotedStandalone(mirname)
    Do CheckStartDejournalProcessor(mirname,0,0)
    ; Non-backups and backups which are not active start here.
    ; "Active" backups skip this step because they know they have all the
    ;    journal files
 	s rc=$$GetMissingMirrorJournalFiles(mirname,forceBecomePrimary)
 	d StopDejournalProcessor(mirname,0)
	if 'rc {
	   if $SYSTEM.Mirror.GetStatus(mirname)="SYNCHRONIZING" d $SYSTEM.Mirror.SetStatus("TRANSITION",mirname)
	   if $G(^MIRROR(mirname,"Status","MGR"))="Exit" {
		   do ClearRetryList(mirname)
		   goto waitnext
	   }
	   ;RetryGetMissingJournalFiles tries to retrieve the missing
	   ; files again but it also watches for changes in the earliest
	   ; file we require as that may affect what files we need to get
 	   do AddRetryEntry(mirname,"(""(rc) { s rc=$$RetryGetMissingMirrorJournalFiles("""""_mirname_""""") }"", .rc)","Restart","Failed to retrieve missing journal files")
	   goto wait
	}
	;Set $SYSTEM.MIRROR.LastFileValidFlag() = 0/1
	s rc=$$SetLastFileValidFlag(mirname)
	if ('rc) {
 	   do AddRetryEntry(mirname,"(""(rc) { s rc=$$RetrySetLastFileValidFlag("""""_mirname_""""") }"", .rc)","Restart","Failed to mark last journal file as valid")
	   goto wait
	}
ActiveBackupRestart ;
	/* Active backups come back to this tag when they lose their
	   connection to the primary. Inactive backups, and non-backups,
	   start up higher */
	s rc=$$ApplyJournalFiles(mirname) ; may update ^MIRROR("dejrnchkpnt")
	if rc'=1 {
		if 'rc {
	       do AddRetryEntry(mirname,"(""(rc) { s rc=$$RetryApplyJournalFiles("""""_mirname_""""") }"", .rc)","Restart","Failed to apply existing journal files")
		} else {
		 ; rc = -1 which means retry ValidateJournalFiles
	        do AddRetryEntry(mirname,"(""(rc) { s rc=$$RetryValidateMirrorJournalFiles("""""_mirname_""""") }"", .rc)","Restart","Must re-validate journal files to continue")
		}
	    goto wait
	}
	if NeedProgagateData {
	   ; If GetECPSessionData() returns 0 we don't add it to the retry list, we'll just
	   ; call it again if we get back here or log an error that ECP Client sessions
	   ; may be dropped if we become the primary
	   s rc=$$GetECPSessionData^MIRRORCOMM(mirname,NeedProgagateData)
	   if rc {
		   s NeedProgagateData=0  ;succeeded, we don't need to do this again
	   }
	}
	if reportingNode {
		s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
		if (systemcnt=0) goto wait  ;no other node to talk to
		s info=$G(^SYS("MIRRORSET",mirname,"Member",1))
		s mtype=+$LG(info,8)
		if mtype'=0 {
			; We're an async member connecting to another async member
			s id=1  ;node to connect to
		} else {
		   ; become backup checks whether the other node is the primary. If so
		   ; we try to become the backup.
		   s id=$$GetCurrentPrimaryID(mirname)
		   if id=-1 {
	          do AddRetryEntry(mirname,"(""(rc) { s rc=($$GetCurrentPrimaryID("""""_mirname_""""")'=-1) }"", .rc)","Restart","Failed to locate current primary")
	          goto wait
		   }
		}
		do BecomeBackup(mirname,id)
    	s role=$G(^MIRROR(mirname,"Role"))  ;Become backup updated Role if it succeeded
		goto wait
	}
	if '$SYSTEM.Mirror.LastFileValidFlag() {
		if forceBecomePrimary {
			d $zu(9,"","Failed to validate journal files - ForceBecomePrimary aborting",1 /* broadcast and log message*/,1  /* Warning */)
			goto wait  ;don't try to become the backup (yet) if ForceBecomePrimary is set
		}
	}
	if role="" {
	   d $zu(9,"","Manager initialized for "_mirname,0,0  /* Informational message */)
	}
	s role="Starting"  /* Entered the top of the decision loop */
topDecisionLoop ;
	/* If there's no primary, we should become the primary */
	do $SYSTEM.Mirror.ModifyDecidingState(1)  ;1 = enter transition state
	if $SYSTEM.Mirror.ActiveBackupFlag() {
		s NeedProgagateData=0
		do BecomePrimary(mirname,forceBecomePrimary,wasBackup)
		s forceBecomePrimary=0 ; this gets cleared after we try once
		s role=$G(^MIRROR(mirname,"Role"))  ;Become primary updated Role if it succeeded
		do QueueCheckForDuplicatePrimary(mirname)
		goto wait
	}
	; Retrieve state of other node
	s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
	if (systemcnt=0) {
		; We're the only node in the mirror, become the primary
        d $zu(9,"","No other failover mirror members configured, becoming primary mirror server",0,0  /* Informational message */)
        if NeedProgagateData=1 {
	       d $zu(9,"","Missing current ECP Client data - ECP client sessions may reset rather than recover",0,0  /* Informational message */)
        } elseif NeedProgagateData=2 {
	       d $zu(9,"","Missing progagated data - mirror journal file purge might be inaccurate.",0,0  /* Informational message */)
        }
		s NeedProgagateData=0
		do BecomePrimary(mirname,forceBecomePrimary,wasBackup)
		s forceBecomePrimary=0 ; this gets cleared after we try once
        s role=$G(^MIRROR(mirname,"Role"))  ;Become primary updated Role if it succeeded
		goto wait
	}
	s ourguid=$LG($G(^SYS("MIRRORSET",mirname,"Member",0)),2)
getStatus ;          
	; There are a max of 2 failover nodes in a mirror so systemcnt
	; is 1 here. If this changes, this logic needs to be updated to
	; scan the status of all the members.
	s id=1  ;this is the other node
	s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
    if info="" {
	   do $SYSTEM.Mirror.ModifyDecidingState(0)
	   d $zu(9,"","Missing information for mirror member #"_id,1 /* broadcast and log message*/,1  /* Warning */)
	   do AddRetryEntry(mirname,"(""(rc) { s info=$G(^SYS(""""MIRRORSET"""","""""_mirname_""""",""""Member"""","_id_")) s rc=$L(info) }"", .rc)","Restart","Internal error: ^SYS(""MIRRORSET"") missing information for mirror member")
	   goto wait
    }
	s name=$lg(info,1)
    s guid=$lg(info,2)
    s rc=$$GetStatus^MIRRORCTL(mirname,id)
    s status=$LG(rc)  
checkStatus 
	if status="ERR" {
		h 1
		s rc=$$GetStatus^MIRRORCTL(mirname,id)
		s status=$LG(rc)  
		if status="ERR" {
			if forceBecomePrimary {
				if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","ERR on status request treated as TIMEOUT for forceBecomePrimary")
				s status="TIMEOUT"
			} else {
				d $zu(9,"","Cannot takeover, error fetching status of "_name_": "_$LG(rc,3),1 /* broadcast and log message*/,1  /* Warning */)
				do AddRetryEntry(mirname,"(""(rc) { s rc=$$RetryGetStatus("""""_mirname_""""","""""_id_""""","""""_status_""""") }"", .rc)","Restart","GetStatus returned ""ERR"" - Unable to determine state of other failover member")
				goto wait
			}
		}
		; fall into rest of checkStatus now that status is not ERR
	}
	if '$get(resolved) {
		s resolved=$$ResolveFrozenPrimary(mirname,rc)
		if (resolved<0) || (resolved>1) {
			goto Restart ; state has changed
		}
	}
    if status="PRIMARY" {
	   do $SYSTEM.Mirror.ModifyDecidingState(0) ; clear transition state
	   d $zu(9,"","Found "_name_" as primary, becoming backup",0,0  /* Informational message */)
	   do BecomeBackup(mirname,1)  ;other node is id #1
       s role=$G(^MIRROR(mirname,"Role"))  ;Become backup updated Role if it succeeded
	   goto wait
    }
    if status="HUNG" {
	   s lastjrninfo=$$GetDejrnChkpntInfo(mirname)  ;returns cnt^pos
	   if '+lastjrninfo {
		   s lastjrnfilecnt=0
		   s lastjrnend=0  ;no journal files yet	
	   } else {
		   s lastjrnend=+$P(lastjrninfo,"^",2)
		   s lastjrnfilecnt=+lastjrninfo
	   }
	   if '$$CheckRequiredDatabases^MIRRORCOMM(1,lastjrnfilecnt,lastjrnend) {
		   d $zu(9,"","HUNG primary not forced down - Backup missing one or more required databases",1 /* broadcast and log message*/,2  /* Severe error */)
		   do AddRetryEntry(mirname,"(""(rc) { s rc=$$RecheckRequiredDatabases("""""_mirname_""""","_lastjrnfilecnt_","_lastjrnend_") }"", .rc)","Restart","Hung primary not forced down because one or more required databases are missing")
		   goto wait
	   }
	   if $$CheckDefinedPrimary(1)'=1 {
		   d $zu(9,"","HUNG primary not forced down - 'No Failover' is set.",1 /* broadcast and log message*/,2  /* Severe error */)
		   do AddRetryEntry(mirname,"(""(rc) { s x=$$ReCheckDefinedPrimary("""""_mirname_""""") s rc=(x=1) }"", .rc)","Restart","'No Failover' is set")
		   goto wait
	   }
	   ; force it down and wait until status is not hung
	   d $zu(9,"","("_mirname_") Forcing down hung node "_name_" (#"_id_")",1 /* broadcast and log message*/,1  /* Warning */)
	   s status=$$ForceNodeDown^MIRRORCTL(mirname,id,1)
	   s waittime=120  ;two minutes, then we give up and go to wait
	   do {
	      h 1
	      s rc=$$GetStatus^MIRRORCTL(mirname,id)
          s status=$LG(rc)  ; PRIMARY/UP/DOWN/HUNG/TIMEOUT/ERR
          s waittime=waittime-1
	   } while waittime && ((status="HUNG") || (status="ERR"))
	   if ((status="HUNG") || (status="ERR")) {
		  d $zu(9,"","Member "_name_" failed to be forced down, code="_$lg(rc,3),1 /* broadcast and log message*/,1  /* Warning */)
		  do AddRetryEntry(mirname,"(""(rc) { s rc=$$RetryGetStatus("""""_mirname_""""","""""_id_""""",""""HUNG"""") }"", .rc)","Restart","Waiting for other failover member to report it is down")
		  goto wait
	   }
	   d $zu(9,"","Forced member "_name_" now reports status: "_status,0,0  /* Informational message */)
	   goto Restart
    } 
    if (status="UP")!(status="DOWN") {
	   s dejrnfilecnt=+$SYSTEM.Mirror.GetLastJournalFilename(mirname)
	   if dejrnfilecnt>0&&(dejrnfilecnt<(+$LG(rc,2))) {
		  d $zu(9,"","Checking for additional journal files from #"_dejrnfilecnt_" to #"_$LG(rc,2),0,0  /* Informational message */)
		  goto Restart
	   }
	   if $LG(rc,3)="ACTIVEBACKUPFLAGSET" {
		   s rc2=$$ClearActiveBackup^MIRRORCTL(mirname,id)
		   if $LG(rc2)="ERR" {
			   ; We can't continue until we get an OK back from this routine
			   d $zu(9,"","Error clearing active backup flag of ""UP"" backup ("_$LG(rc,2)_") - cannot become primary",1 /* broadcast and log message*/,1  /* Warning */)
		       do AddRetryEntry(mirname,"(""(rc) { s rc=$$RetryClearActiveBackup("""""_mirname_""""") }"", .rc)","Restart","Failed to clear the active backup state on other failover member")
			   goto wait
		   }
		   d $zu(9,"","Cleared active backup flag of ""UP"" system - continuing",0,0  /* Informational message */)
	   }
	   d $zu(9,"",name_" reports it is "_status_", becoming primary mirror server",0,0  /* Informational message */)
       if NeedProgagateData=1 {
	      d $zu(9,"","Missing current ECP Client data - ECP client sessions may reset rather than recover",0,0  /* Informational message */)
	   } elseif NeedProgagateData=2 {
	       d $zu(9,"","Missing progagated data - mirror journal file purge might be inaccurate.",0,0  /* Informational message */)
       }
       s NeedProgagateData=0
	   do BecomePrimary(mirname,forceBecomePrimary,wasBackup)
	   s forceBecomePrimary=0 ; this gets cleared after we try once
       s role=$G(^MIRROR(mirname,"Role"))  ;Become primary updated Role if it succeeded
	   goto wait
    }
    if status="DECIDING" {
	   if $$CompareGUIDs(ourguid,guid)<0 {
	      ; if we have the lower guid, then we're the decider
		  ; we keep our status as "DECIDING" and wait for the
		  ; other node to do something.
		  hang 1
		  goto getStatus
	   }
	   do $SYSTEM.Mirror.ModifyDecidingState(0) ; clear transition state
	   d $zu(9,"","Waiting for "_name_" to become primary",0,0  /* Informational message */)
	   do {
	      hang 1
	      s rc=$$GetStatus^MIRRORCTL(mirname,id)
          s status=$LG(rc)  
       } while (status = "DECIDING")
       goto Restart
	}
	if status="TIMEOUT" {
	   if 'forceBecomePrimary {
		   d $zu(9,"","("_mirname_") Failed to contact other node's agent - Waiting",0,0  /* Informational message */)
		   do AddRetryEntry(mirname,"(""(rc) { s rc=$$CheckOtherNodeIsReachable("""""_mirname_""""") }"", .rc)","Restart","Waiting to contact agent on other failover member")
		   goto wait
	   }
	   d $zu(9,"","("_mirname_") Becoming Primary - ForceBecomePrimary flag is set",0,0  /* Informational message */)
       if NeedProgagateData=1 {
	      d $zu(9,"","Missing current ECP Client data - ECP client sessions may reset rather than recover",0,0  /* Informational message */)
	   } elseif NeedProgagateData=2 {
	       d $zu(9,"","Missing progagated data - mirror journal file purge might be inaccurate.",0,0  /* Informational message */)
       }
       s NeedProgagateData=0
	   do BecomePrimary(mirname,forceBecomePrimary,wasBackup)	
	   s forceBecomePrimary=0
       s role=$G(^MIRROR(mirname,"Role"))  ;Become primary updated Role if it succeeded
       ; CheckForDuplicatePrimary will keep trying to contact the agent on the
       ; other node and if it succeeds & the other node is the primary, it will
       ; force down the mirror
       do QueueCheckForDuplicatePrimary(mirname)
	   goto wait
	}
	d $zu(9,"","Unknown status /"_status_"/ from GetStatus - Ignored",1 /* broadcast and log message*/,1  /* Warning */)
    do AddRetryEntry(mirname,"(""(rc) { s rc=$$RetryGetStatus("""""_mirname_""""","""""_id_""""","""""_status_""""") }"", .rc)","Restart","Other failover member is in an unknown state")
wait ;
	do $SYSTEM.Mirror.ModifyDecidingState(0)
	s status=$SYSTEM.Mirror.GetStatus(mirname)
	if status="TRANSITION"||(status="SYNCHRONIZING") {
		/* TRANSITION  is set when the mirror configuration is loaded and if
		   it is still set here, we change it to waiting */
		do $SYSTEM.Mirror.SetStatus("WAITING",mirname)
		s ^MIRROR(mirname,"Role")=""
		s role=""
	}
	g:$G(^MIRROR(mirname,"Status","MGR"))="Exit" waitnext
	if forceBecomePrimary {
	   d $zu(9,"","Failed to force this node to become the primary",1 /* broadcast and log message*/,1  /* Warning */)
	   s forceBecomePrimary=0
	   do AddRetryEntry(mirname,"(""(rc) { s rc=$$CheckOtherNodeIsReachable("""""_mirname_""""") }"", .rc)","Restart")
	}
	if +$G(logSevereFailureMessage) {
		s logSevereFailureMessage=0
		if (role'="PRIMARY") && (role'="BACKUP") {
		   if wasBackup {
		      d $zu(9,"","Backup failed to take over as primary",1 /* broadcast and log message*/,2  /* Severe error */)
		   } else {
			  if reportingNode {
		         d $zu(9,"","Async member for "_mirname_" started but failed to connect to primary",1 /* broadcast and log message*/,2  /* Severe error */)
			  } else {
		         d $zu(9,"","Failed to become either Primary or Backup at startup",1 /* broadcast and log message*/,2  /* Severe error */)
			  }
		   }
		   if 'reportingNode {
			   d RunZMIRROR(4)
		   }
		}
	}
	; If MIRROR_STATUS_RESTART is still set then clear it now. This is
	; set at startup and when a backup resets. While this is set
	; we hold incoming ECP connections in case we're about to become
	; the primary. At this point if we're not the primary then we want
	; to reject these so they get redirected to the primary. 
	; Its not an error to call ClearRestart() when MIRROR_STATUS_RESTART 
	; isn't set.
	do $SYSTEM.Mirror.ClearRestart() 
	;
	s ^MIRROR(mirname,"Status","MGR")="Run"  ; can be killed or set to shut down MGR node and all TCP readers
waitloop ;	
	; Main work loop. Sit here waiting for messages to be posted
	; to the incomming queue. 
	s cls=##class(Config.MirrorMember).Open(,,.rc)
	if ((''rc)&&(reportingNode'=cls.isAsyncMember()))||$$DejournalUpdaterChanged(mirname) {
		if '$$BackupDaemonExit(mirname,0,$G(^||MIRROR(mirname,"BackupClient"))) {
			do $SYSTEM.Mirror.Shutdown(10,mirname)
			while '$$BackupDaemonExit(mirname,1,$G(^||MIRROR(mirname,"BackupClient"))) {
				do $SYSTEM.Mirror.Shutdown(10,mirname)
				q:$G(^MIRROR(mirname,"Status","MGR"))="Exit"
			}
		}
		S ^MIRROR(mirname,"Status","MGR")="Exit"
		s RestartMirror=1
		goto waitnext
	}
	s cls=""
	If wasBackup,role'="PRIMARY",+$G(OrigECPRecoveryTimeout)'=0 {
		if OrigECPRecoveryTimeout<60 d $SYSTEM.ECP.SetProperty("ECPRecoveryTimout",OrigECPRecoveryTimeout)
		k OrigECPRecoveryTimeout
	}
	if $get(resolved)<1 {
		if (reportingNode) || (role="PRIMARY") || (role="BACKUP") || ('systemcnt) {
			set resolved=1 
		} else {
			set resolved=$$ResolveFrozenPrimary(mirname)
		}
	}
	if '$SYSTEM.Util.GetSwitch(16) {
		s tag=$$CheckRetryList(mirname)
	} else {
		s tag=""
	}
	if tag'="" {
	   if $zb(+$SYSTEM.Mirror.DebugFlags(),4,1) do $zu(9,"","Returning to """_tag_"""")
	   if $SYSTEM.Mirror.GetStatus(mirname)="WAITING" {
		   do $SYSTEM.Mirror.SetStatus("TRANSITION",mirname)
	   }
	   goto $case(tag,"Restart":Restart,
					   "reinit":reinit,
					   "PrimaryFound1":PrimaryFound1,
					   "PrimaryFound2":PrimaryFound2,
					   :retryTagErr)
	} 
	if signalpid {
		do $SYSTEM.Event.Signal(signalpid)
		s signalpid=0
	}
	if role="PRIMARY" {
		do UpdateJournalFilesSent(mirname,.sentfilelist)
	} elseif '$G(^MIRROR(mirname,"StartBackupDmnFailed")) {
		s x=$SYSTEM.Mirror.GetStatus(mirname)
		if x["BACKUP"||(x["CONNECTED"),$$BackupDaemonExit(mirname,0,$G(^||MIRROR(mirname,"BackupClient"))) {
			S ^MIRROR(mirname,"Status","MGR")="Exit"
			s RestartMirror=1
			goto waitnext
		}
	}
	Do CheckAsyncJrnfilePurge(mirname)
	if '$SYSTEM.Util.GetSwitch(16) && $d(sw16MSGQ) {
		s x=$o(sw16MSGQ(""),1,msg)
		k sw16MSGQ(x)  ; remove it.
		s id=$LG(msg,1)
		s text=$LG(msg,2)
		if $zb(+$SYSTEM.Mirror.DebugFlags(),8,1) do $zu(9,"",mirname_" msg: from #"_id_" text = /"_text_"/ resumed.")
		goto EVENT
	}
	; 5 seconds if role is still Starting, otherwise 30
	s msgwait=$S($G(role)="Starting"  /* Entered the top of the decision loop */:5,1:30)
	s msg=$SYSTEM.Event.WaitMsg("",msgwait)  ;no args = our $J event
	if (msg="") ! ($LL(msg)'=2) {
		d $zu(9,"","MIRRORSVR: Invalid result from EventWait, exiting",1 /* broadcast and log message*/,2  /* Severe error */)
		do $SYSTEM.Mirror.ModifyControlJob(miridx,0)  ;0 = clear ctrl job
		quit
	}
	if $Lg(msg)=1 {
	   s msg=$LG(msg,2)  ; extract the useful part
	   ; The message itself is a list which has a command and an optional value
	   s cmd=$LG(msg,1) 
	   if $LL(msg)>1 s val=$LG(msg,2)
	   if cmd="STOP" {
		  d $zu(9,"","MIRRORSVR: Stop request received, exiting",0,0  /* Informational message */)
	  	  do $SYSTEM.Mirror.ModifyControlJob(miridx,0)  ;0 = clear ctrl job
		  quit
	   }
	   if cmd="MSGQ" {
		   if ('val)&&($LL(msg)>2) {
			   s msg=$LG(msg,3)
		   } else {
			   ; most common message, there is a message from another member for us 
			   s msg=$G(^MIRROR(mirname,"MSG","InQ",val))
			   k ^MIRROR(mirname,"MSG","InQ",val)  ;delete old messages
		   }
		   if msg'="" {
			   s id=$LG(msg,1)
			   s text=$LG(msg,2)
			   if $zb(+$SYSTEM.Mirror.DebugFlags(),8,1) do $zu(9,"",mirname_" msg: from #"_id_" text = /"_text_"/")
			   if '$SYSTEM.Util.GetSwitch(16)||($E(text,1,9)="SHUTDOWN:") goto EVENT  ;comes back to waitnext or Restart
			   if $zb(+$SYSTEM.Mirror.DebugFlags(),8,1) do $zu(9,"",mirname_" msg: from #"_id_" text = /"_text_"/ queued and skipped.")
			   s sw16MSGQ($i(sw16MSGQidx))=msg
		   }
	   }
	   if cmd="REQ" {
		   ; this is a message with the text in the message itself
		   ; these come from our system's C code via $SYSTEM.Event.Signal()
		   ; and have the form $LB("REQ",<sending pid>,<text>)
		   s id=val
		   s text=$LG(msg,3)
		   if $zb(+$SYSTEM.Mirror.DebugFlags(),8,1) do $zu(9,"",mirname_" REQ: from pid"_id_" text = /"_text_"/")
		   goto REQMSG
	   }
	}
waitnext ;		
	; Check our status node and wait again
	g:$G(^MIRROR(mirname,"Status","MGR"))="Run" waitloop
dmnexit ;	
	If $SYSTEM.Mirror.GetInfo()["BACKUP" do $SYSTEM.Mirror.BackupStartupAbort()
	; Time to Exit
	s ^MIRROR(mirname,"Status","MGR")="Stop"
	s ^MIRROR(mirname,"State")="Halted"
	s ^MIRROR(mirname,"MgrJobID")=""
	if $G(miridx)>0 {
		k ^||MIRROR(mirname,"DejournalRunning")
		k ^MIRROR(mirname,"DejournalRunning")
        s x=$SYSTEM.Mirror.DejournalFree(miridx)
	}
    do StopDejournalProcessor(mirname,0)
	do:$g(miridx)>0 $SYSTEM.Mirror.ModifyControlJob(miridx,0)  ;0 = clear ctrl job
	if $G(RestartMirror) {
		do $SYSTEM.Mirror.SetStatus("TRANSITION",mirname)
	} else {
	do $SYSTEM.Mirror.SetStatus("STOPPED",mirname)
	}
	do $ZU(61,10,$ZU(61),origtype)
	if $G(RestartMirror) {
		s rc=$$Startup(mirname)
		if (''rc) {
			d $zu(9,"","Mirror: Manager restarted mirroring ("_mirname_")",0,0  /* Informational message */)
		} else {
			d $zu(9,"","Mirror: Manager failed to restart mirroring ("_mirname_") error="_$SYSTEM.Status.GetErrorText(rc),0,0  /* Informational message */)
		}
	}
	d $zu(9,"","Mirror: Manager for "_mirname_" exited.",0,0  /* Informational message */)
	quit	
err ;
	s $zt=""
	if $ze["EXTERNAL INTERRUPT" {
		if $zb(+$SYSTEM.Mirror.DebugFlags(),4,1) do $zu(9,"","Got external interrupt signal to shutdown. $ze="_$ze)
		s ^MIRROR(mirname,"Status","MGR")="Exit"
		g waitnext
	}
	If $SYSTEM.Mirror.GetInfo()["BACKUP" do $SYSTEM.Mirror.BackupStartupAbort()
	if $G(mirname)="" s mirname="<:unknown>"
	s ^MIRROR(mirname,"State")="ErrorHalt"
	s ^MIRROR(mirname,"MgrJobID")=""
    s:$G(miridx)'="" x=$SYSTEM.Mirror.DejournalFree(miridx)
    do StopDejournalProcessor(mirname,0)
	d $zu(9,"","MIRRORSVR: Unexpected error /"_$ZE_"/ - Halted",1 /* broadcast and log message*/,2  /* Severe error */)
	do $SYSTEM.Mirror.ModifyControlJob(miridx,0)  ;0 = clear ctrl job
	do $ZU(61,10,$ZU(61),origtype)
	d:logerr BACK^%ETN
	quit	
retryTagErr ;	
	d $zu(9,"","MIRRORSVR: Missing target for retry /"_tag_"/ in goto $case",1 /* broadcast and log message*/,1  /* Warning */)
	goto Restart  
	; These are message handlers for the keywords posted on the MSGQ
EVENT ;
    if $E(text,1,9)="RUNCYCLE:" {
	    s signalpid=id
	    g waitnext
    }
	if $E(text,1,8)="MIRDOWN:" {
		; MIRDOWN is posted by Backup() and Server() when the $SYSTEM.Mirror
		; .Client() or .Server() returns because the connection to the other
		; node was terminated. 
		; 
		; $SYSTEM.Mirror.Client() waits for the dejournaling jobs to finish 
		; processing the received journal data before it returns.
		;
		if role="Pause"  /* Stop sending messages to other systems */ {
            do $SYSTEM.Mirror.ActiveBackupFlag(0)
			goto waitnext  ; ignore this if we're shutting down
		}
		; One of the connections from Backup() or Primary()
		; has exited (or failed while initializing). The message
		; contains details on what happened.
		; 
		; The message is "MIRDOWN:<reason>:<text>" where <reason> is 0 for 
		; an unknown error or one of the MIR_SHUTDOWN_ codes. <text>
		; is more information if we know it.
		s ^MIRROR(mirname,"Status","Member",id,"Role")=text
		if $zb(+$SYSTEM.Mirror.DebugFlags(),8,1) do $zu(9,"","MIRDOWN: ("_mirname_")Set member #"_id_" role to "_text)
		s reason=+$P(text,":",2)
		s cliexit=$p(text,":",3),cliexit=(cliexit="CLIENTEXIT"||(cliexit="CLIERROR"))
		if role="BACKUP"&&cliexit {
	 	   ; Clear Role and we'll reset it if we become the primary or
	 	   ; reconnect as a backup. If we fail to reconnect though we want
	 	   ; it clear when we reach wait so that we know to generate a message
	 	   s ^MIRROR(mirname,"Role")=""
	 	   s role=""
		   ; If we're a backup and the primary shut down then the
		   ;	 remaining backups want to elect a new primary. Before starting
		   ; that process we need to figure out whether the primary died
		   ; or whether we just lost our connection.
		   s state=$SYSTEM.Mirror.GetInfo()
		   s dejrninfo=$SYSTEM.Mirror.GetInfo(2)  ;save info cleared by ResetBackup()
		   do $SYSTEM.Mirror.ResetBackup() ;clears BACKUP sets RESTART status
		   if (reason = 5) {
			   if '$G(^SYS("MIRRORSET")) {
				   s cls=##class(Config.MirrorMember).Open(,,.rc)
				   if (''rc) {
					   s cls.ValidatedMember = 0
					   s rc = cls.%Save()
					   if ('rc) {
						   d $zu(9,"","("_mirname_") ERROR: Failed to clear ValidatedMember: "_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
					   }
				   }
			   }
			   d $zu(9,"","("_mirname_"): Primary removed this member from its mirror configuration",1 /* broadcast and log message*/,1  /* Warning */)
			   s ^MIRROR(mirname,"Status","MGR") = "Exit"
			   goto waitnext
		   }
		   ; We use the stored dejournal checkpoint when calling ApplyJournalFiles
		   ; but it may be behind if the dejournal job did not update it as it exited.
		   ; Lookup the current value in memory and publish it before we might return
		   ; to restart.
		   s chkpntjrncnt=$P(dejrninfo,",",6)
		   s chkpntjrnpos=$P(dejrninfo,",",7)
		   if 'chkpntjrncnt {
			   s chkpntjrncnt=+$P($P(text,":",2),",",2)
			   s chkpntjrnpos=+$P($P(text,":",2),",",3)
		   }
		   if chkpntjrncnt {
			   s (^MIRROR(mirname,"dejrnchkpnt"),^MIRROR(mirname,"firstdejrnchkpnt"))=chkpntjrncnt_"^"_chkpntjrnpos
			   Do GetTransactionRollbackPoint(mirname,chkpntjrncnt)
		   }
		   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","Set last checkpoint to "_chkpntjrncnt_", "_chkpntjrnpos_", transroll to "_$G(^MIRROR(mirname,"transroll")))
		   if reportingNode {
			  ; Note that non-failover nodes always take this pathway
			  ; because they are never considered active by the primary.
			  s ^MIRROR(mirname,"State")="Restarting"
			  goto Restart
		   }
		   if (reason = 4) {
			   d SynchConfigWithPrimary^MIRRORCOMM(mirname,1)
			   do AddRetryEntry(mirname,"(""(rc) { s rc=$$ValidateFailoverPartner("""""_mirname_""""",0) }"", .rc)","Restart","UseSSL updated in primary")
			   goto wait
		   }
		   if state'["BACKUP" {
			  ; ouch we thought we were a backup but we weren't.
			  s role=""
	    	  d $zu(9,"","("_mirname_") ERROR: Non Backup is down (node #"_id_")",1 /* broadcast and log message*/,2  /* Severe error */)
			  s ^MIRROR(mirname,"State")="Restarting"
			  do $SYSTEM.Mirror.ActiveBackupFlag(0) ;probably already clear in this case
			  goto Restart
		   }
	   	   s logSevereFailureMessage=1  ;post a SevereMsg if we fail to become primary
	   	   s wasBackup=1  ;the message will say we failed to become the primary
	 	   s OrigECPRecoveryTimeout = $SYSTEM.ECP.GetProperty("ECPRecoveryTimout")
	 	   if OrigECPRecoveryTimeout<60 d $SYSTEM.ECP.SetProperty("ECPRecoveryTimout",60)
	 	   s resolved=""
	 	   s rawactivebackupflag=$SYSTEM.Mirror.ActiveBackupFlag(-1)
		   if rawactivebackupflag=0 {
		      ; if we weren't considered an active backup at the time 
			  ; of the failure then go back to the top. We may become the
			  ; primary but 1st we need to get more journal data.
	    	  d $zu(9,"","("_mirname_") Non-active Backup is down (node #"_id_")",0,0  /* Informational message */)
			  s ^MIRROR(mirname,"State")="Restarting"
			  do $SYSTEM.Mirror.ActiveBackupFlag(0) ;almost certainly already clear
		 	  s failoverRule=$SYSTEM.Mirror.FailoverRule()
   			  if failoverRule=1 {
			     do $SYSTEM.Mirror.FailoverRule(2)
	   			 if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","Non active backup switched to agent contact mode before restarting")
   			  }
			  goto Restart
		   }
			if rawactivebackupflag=2 {
				if reason = 6 {
					d $zu(9,"","Backup taking over due to clean shutdown of primary",0,0  /* Informational message */)
				} else {
					d $zu(9,"","Backup taking over for primary in permanent trouble",0,0  /* Informational message */)
				}
				s (forced,svrfilecnt)=0
				goto checkJournalData
			}
		    s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
    	    if info="" {
	    	   ; this shouldn't ever happen
	    	   d $zu(9,"","("_mirname_") ERROR: Missing configuration information old primary (node #"_id_")",1 /* broadcast and log message*/,1  /* Warning */)
			   s ^MIRROR(mirname,"State")="Restarting"
			   do $SYSTEM.Mirror.ActiveBackupFlag(0) ;don't restart w/out talking with other instance
	    	   goto Restart
    	   }
		   if '$$BackupWaitForArbiterChange(mirname) {
			   do $SYSTEM.Mirror.ActiveBackupFlag(0) 
			   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","Restarting: BackupWaitForArbiterChange signaled failure")
			   goto Restart
		   }
    	   s failoverRule=$SYSTEM.Mirror.FailoverRule()
    	   if failoverRule=1 {
	    	   s arbiterState=$SYSTEM.Mirror.ArbiterState()
	    	   if '$ZB(+arbiterState,+2,1) {
		    	   ; we lost our arbiter connection, reset
			   	   do $SYSTEM.Mirror.ActiveBackupFlag(0) 
			   	   do $SYSTEM.Mirror.FailoverRule(2)
				   d $zu(9,"","Backup switched from Arbiter Controlled failover mode to Agent Controlled due to lost arbiter connection - lost arbiter connection",0,0  /* Informational message */)
		    	   goto Restart
	    	   }
			   if $ZB(+arbiterState,+4,1) {
				   ; primary still has its arbiter connection!
				   d $zu(9,"","Backup found primary still connected to the arbiter unexpectedly and won't become primary",1 /* broadcast and log message*/,1  /* Warning */)
				   do $SYSTEM.Mirror.ActiveBackupFlag(0)
				   goto Restart
			   }
			   s forced=0 
			   s svrfilecnt=0 ; we will mark journal end as valid w/out checking it
			   do $SYSTEM.Mirror.ActiveBackupFlag(1)
			   d $zu(9,"","Backup taking over for primary in arbiter controlled mode",0,0  /* Informational message */)
			   goto checkJournalData
    	   }
	       s name=$lg(info,1)
	       s rc=$$GetStatus^MIRRORCTL(mirname,id)
           s status=$LG(rc)  ; PRIMARY/UP/DOWN/HUNG/TIMEOUT/ERR
		   if status="ERR" {
           	   if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","("_mirname_") Old primary reports ERR - fetching new status")
			   h 1
			   s rc=$$GetStatus^MIRRORCTL(mirname,id)
			   s status=$LG(rc)  
			   if status="ERR" {
				   d $zu(9,"","Error fetching status of "_name_" in "_mirname_": "_$LG(rc,3),1 /* broadcast and log message*/,1  /* Warning */)		
				   s ^MIRROR(mirname,"State")="Restarting"
				   goto Restart
			   }
			   ; keep going now that status is not ERR
		   }
           if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","("_mirname_") Old primary reports status: "_status_", filecnt="_$LG(rc,2)_", code="_$lg(rc,3))
           if status="PRIMARY" {
	           d $zu(9,"","("_mirname_") Lost connection to node "_name_" (#"_id_") which reports it is still the primary",1 /* broadcast and log message*/,1  /* Warning */)
			   s ^MIRROR(mirname,"State")="Restarting"
			   if $SYSTEM.Mirror.ActiveBackupFlag() {
				   ; Just a sanity check, this shouldn't be set
				   d $zu(9,"","ActiveBackupFlag found set when other instance reports it is still the primary",1 /* broadcast and log message*/,2  /* Severe error */)
			   }
			   do $SYSTEM.Mirror.ActiveBackupFlag(0)
	           goto Restart
           }
           if (status="HUNG") {
	          ;If the primary is hung we need to force it down. If we get an
	          ; OK back from the force then the force code declared a permenant
	          ; trouble state so we know the other node won't do any more 
	          ; "mirror work" even if the force doesn't shut it down for
	          ; some reason.
			  s lastjrninfo=$$GetDejrnChkpntInfo(mirname)  ;returns cnt^pos
			  if '+lastjrninfo {
				  s lastjrnfilecnt=0
				  s lastjrnend=0  ;no journal files yet	
			  } else {
				  s lastjrnend=+$P(lastjrninfo,"^",2)
				  s lastjrnfilecnt=+lastjrninfo
			  }
			  if '$$CheckRequiredDatabases^MIRRORCOMM(1,lastjrnfilecnt,lastjrnend) {
				  d $zu(9,"","Backup found primary is hung but takover is blocked because the backup missing one or more required databases",1 /* broadcast and log message*/,2  /* Severe error */)
			      do $SYSTEM.Mirror.ActiveBackupFlag(0)
			      do AddRetryEntry(mirname,"(""(rc) { s rc=$$RecheckRequiredDatabases("""""_mirname_""""","_lastjrnfilecnt_","_lastjrnend_") }"", .rc)","Restart","Cannot become primary because one or more required databases are missing")
			      goto Restart
			  }
			  if $$CheckDefinedPrimary(1)'=1 {
				  d $zu(9,"","Backup found primary is hung but takover is blocked because 'No Failover' is set",1 /* broadcast and log message*/,2  /* Severe error */)
			      do $SYSTEM.Mirror.ActiveBackupFlag(0)
			      do AddRetryEntry(mirname,"(""(rc) { s x=$$ReCheckDefinedPrimary("""""_mirname_""""") s rc=(x=1) }"", .rc)","Restart","Failed to locate current primary")
			      goto Restart
			  }
	          d $zu(9,"","("_mirname_") Forcing down failed primary, node "_name_" (#"_id_")",1 /* broadcast and log message*/,1  /* Warning */)
		      s status=$$ForceNodeDown^MIRRORCTL(mirname,id,$s(reason=1:0,1:1))
		      if $LG(status)'="OK" {
			      d $zu(9,"","Failed to force down failed primary ("_name_"). Reason: "_$LG(status,2),1 /* broadcast and log message*/,1  /* Warning */)
			      ; This is pretty unusual, we're not sure what state the 
			      ; other node is in so its best if we don't take over without
			      ; talking to it and confirming that it isn't still the primary
			      do $SYSTEM.Mirror.ActiveBackupFlag(0)
			      goto Restart
		      }
		      if $LL(status)=1 {
			      d $zu(9,"","Forced down older primary ("_name_") - Must contact old primary to determine current journal file",0,0  /* Informational message */)
			      ; This is pretty unusual, we're not sure what state the 
			      ; other node is in so its best if we don't take over without
			      ; talking to it and confirming that it isn't still the primary
			      do $SYSTEM.Mirror.ActiveBackupFlag(0)
			      goto Restart
		      }
			  s svrfilecnt=$LG(status,2)
			  s svrfileoff=$LG(status,3)
			  ; We can take over without talking with the other node if we have
			  ; the journal point which the server said was current at the time
			  ; the trouble condition was declared by the cforce.
			  s forced=1
			  goto checkJournalData
           }
		   d $zu(9,"","Returning to restart, old primary reported: """_status,0,0  /* Informational message */)
		   goto Restart
           ;
checkJournalData ;JO2559           
		   s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
		   if +rc=-1 {
		      ; This is an error reading the log file other than the log file
		      ; doesn't exist. This shouldn't happen. 
		      d $zu(9,"","("_mirname_") Take over failed, failed to read last journal file from mirror journal log",1 /* broadcast and log message*/,2  /* Severe error */)
			  s ^MIRROR(mirname,"State")="Restarting"
			  do $SYSTEM.Mirror.ActiveBackupFlag(0) ;clear this if we run into an error
		      goto Restart
		   }
		   if +rc=0 {
	          d $zu(9,"","("_mirname_") Take over failed, failed to open mirror journal file to lookup last journal file",1 /* broadcast and log message*/,2  /* Severe error */)
			  s ^MIRROR(mirname,"State")="Restarting"
			  do $SYSTEM.Mirror.ActiveBackupFlag(0) ;clear this if we run into an error
	          goto Restart
		   }
		   s jrnfilecnt=+rc    ;1st piece = jrnfilecnt
		   s jrnfile=$P(rc,",",2)  ; 2nd piece = jrnfilename
		   if $SYSTEM.Mirror.LastFileValidFlag() {
			   ; If the active backup marked the file as valid because the primary
			   ; exited due to a permenant trouble state, then skip to setting up
			   ; the globals and return to Restart so we can take over
 			   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","File already marked valid, skipping to JournalDataOk")
 			   goto JournalDataOk
		   }
		   if +svrfilecnt,+svrfilecnt'=jrnfilecnt {
			   ; The GetStatus message included the last journal file the primary
			   ; was writing and this is different (presumably beyond) our journal
			   ; file. Return to the top so we retrieve whatever we're missing before
			   ; becoming the primary
	           d $zu(9,"","("_mirname_") Take over failed: The failed primary reports last journal file is #"_svrfilecnt_" but the local last file is #"_jrnfilecnt,1 /* broadcast and log message*/,2  /* Severe error */)
			   s ^MIRROR(mirname,"State")="Restarting"
			   do $SYSTEM.Mirror.ActiveBackupFlag(0) ;clear this if we run into an error
	           goto Restart
		   }
		   if (forced) {
			   s fd=$zu(78,5,jrnfile,0)
			   if fd<0 {
				   d $zu(9,"","("_mirname_") Take over failed: failed to open "_jrnfile_" to validate the end after a force ("_svrfileoff_")",1 /* broadcast and log message*/,1  /* Warning */)
				   s ^MIRROR(mirname,"State")="Restarting"
				   do $SYSTEM.Mirror.ActiveBackupFlag(0) ;clear this if we run into an error
				   goto Restart
			   }
			   do $zu(78,6,fd)
			   s endoff=+$zu(78,18,0)
			   do $zu(78,7,fd)
			   if endoff<svrfileoff {
				   d $zu(9,"","Local copy of "_jrnfile_" requires more data (local end= "_endoff_", end reported by primary = "_svrfileoff_"). Must contact old primary before continuing",0,0  /* Informational message */)
				   s ^MIRROR(mirname,"State")="Restarting"
				   do $SYSTEM.Mirror.ActiveBackupFlag(0) ;clear this if we run into an error
				   goto Restart
			   }
			   d $zu(9,"","Node eligible to take over after force: Local copy of "_jrnfile_" contains end reported by primary ("_svrfileoff_")",0,0  /* Informational message */)
			   do $SYSTEM.Mirror.ActiveBackupFlag(1)
		   }
		   if '$SYSTEM.Mirror.ActiveBackupFlag() {
			   goto Restart
		   }
           s rc=$SYSTEM.Mirror.MarkJournalFileEndValid(jrnfile)
           if '+rc {
	           d $zu(9,"","("_mirname_") Take over failed, failed to mark end of "_jrnfile,1 /* broadcast and log message*/,1  /* Warning */)
			   s ^MIRROR(mirname,"State")="Restarting"
			   do $SYSTEM.Mirror.ActiveBackupFlag(0) ;clear this if we run into an error
	           goto Restart
           }
JournalDataOk ;
		   s ^MIRROR(mirname,"lastvalidjrnfile")=jrnfilecnt_"^"_jrnfile 
           do $SYSTEM.Mirror.LastFileValidFlag(1)  ;set flag in case its not set yet
		   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","Set last valid file to "_jrnfile_" (#"_jrnfilecnt_")")
           ; Ok, we're ready to become the primary (assuming that's
           ; ok with the other backups). If the primary is up, try and
           ; kill it.
           ;
           ; we can become the primary now since our journal file is
           ; up to date. restart will negotiate with the other backup,
           ; if there is one, who should be the primary
		   s ^MIRROR(mirname,"State")="Restarting"
		   if $zb($g(^MIRROR(mirname,"Features",id),0),1,1) {
			   s NeedProgagateData=0
		   } else {
			   s NeedProgagateData=2
		   }
		   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","Set dejrn checkpoint to offset "_chkpntjrnpos_" in mirror journal file #"_chkpntjrncnt)
		   goto Restart
		} elseif role="PRIMARY" {
			; We're the primary and a connection to a backup node exited.
			; It could be that the backup shut down and we're still the
			; primary or it could be our side of the connection died. If
			; we're shutting down role would be "Paused" so we know that's
			; not the case here. If we're in arbiter controlled mode then 
			; we need to ask the backup via the arbiter channel to switch
			; to agent controlled mode. Other than that, we log a message and
			; wait to see what happens (the trouble time out may expire, we
			; may get forced down by the backup, the data channel might
			; be rebuilt).
			s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
			if info'="" {
				Set $list(info,10)=0
				s ^SYS("MIRRORSET",mirname,"Member",id)=info
				if $LG(info,8)=0 {
					s failoverRule=$SYSTEM.Mirror.FailoverRule()
					if failoverRule=1 {
						s arbiterPid=$G(^MIRROR(mirname,"Arbiter","pid"),"")
						if arbiterPid="" {
							d $zu(9,"","Cannot locate arbiter pid to signal lost backup connection",1 /* broadcast and log message*/,1  /* Warning */)
						} else {
							do $SYSTEM.Event.Signal(arbiterPid,$LB("BackupConnectionLost"))
							if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","Signaled arbiter (pid: "_arbiterPid_") lost data channel to backup")
						}
					}
				}
			}
			if $zb(+$SYSTEM.Mirror.DebugFlags(),4,1) do $zu(9,"","Connection to member #"_id_" exited for reason #"_reason) 
		} elseif (role="BACKUP"&&'cliexit) {
			s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
			if info'="" {
				Set $list(info,10)=0
				s ^SYS("MIRRORSET",mirname,"Member",id)=info
			}
			if $zb(+$SYSTEM.Mirror.DebugFlags(),4,1) do $zu(9,"","Connection to async member node #"_id_" exited for reason #"_reason) 
		} else {
			; I don't think we should get down messages if we're not
			; activly involved in the mirror (primary/backup).
		    d $zu(9,"","MIRRORSVR: Message /"_text_"/ recived from "_id_" but current role is: "_role,0,0  /* Informational message */)
		}
		goto waitnext
	}
	if $E(text,1,6)="BACKUP" {
		s state=$SYSTEM.Mirror.GetInfo()
		if state["BACKUP" {
			s rc=$SYSTEM.Mirror.BackupStartupAbort()
			if 'rc {
				d $zu(9,"","Failed to abort backup startup - Node may fail to reconnect",1 /* broadcast and log message*/,1  /* Warning */)
			}
		}
		s rest=$E(text,7,*)
		s rest=$P(rest,":")
		if rest="RESET" {
			; some unexpected error occured in Backup^MIRRORCOMM that we
			; should have caught here before we ever tried to become a backup.
			; Start over at reinit and hopefull we catch it this time.
			goto reinit
		}
		if rest="RESTART" {
			; Something changed and we should restart from the top and
			; presumably something different will happen this time.
		    goto Restart
		}
		if rest="CONNECTFAILED" {
			; id here is the system we were trying to connect to.
			; This is posted by Backup^MIRRORCOMM
	        s ok=$$TrackReconnections(mirname,id,.ConnectHistory)
	        if 'ok {
	           do AddRetryEntry(mirname,"(""(ConnectHistory, rc) { s rc=$$TrackReconnections("""""_mirname_""""","_id_",.ConnectHistory) }"", .ConnectHistory, .rc)","Restart","Failed to build a connection")
	        }
	        goto Restart
	    }
		d $zu(9,"","Ignored unrecognized BACKUP event /"_text_"/",0,0  /* Informational message */)
		goto waitnext
	}
	if $E(text,1,9)="SHUTDOWN:" {
		; These are sent from SHUTDOWN. There are 2 messages, SHUTDOWN:SUSPEND
		; and SHUTDOWN:EXIT. SUSPEND is set when SHUTDOWN doesn't want us to talk
		; to other systems any more (tell them we're the primary) and :EXIT is sent
		; when we should terminate, after $SYSTEM.Mirror.Shutdown() has returned.
		s text=$E(text,10,$L(text))
		if text="SUSPEND" {
			; If we set our role to pause we'll stop answering
			; "START" messages
			s delVIP=(role="PRIMARY")
		    s role="Pause"  /* Stop sending messages to other systems */
		    if delVIP set ok=$$DeleteVirtualAddress(mirname)
		}
		if text="EXIT" {
			s ^MIRROR(mirname,"Status","MGR")="Exit"
		}
		do ClearRetryList(mirname)  ;if there's a retry list, reset it now
		goto waitnext
	}
	if $E(text,1,10)="ADDMEMBER:" {
		s cur=$ZU(190,13)  ;wdpass,wdqsize,wdwritesiz
		do $ZU(51,1) ;wake wd
		s wdpass=+cur
		s reqpass=wdpass+2
		do {
		   hang 1
		   do $ZU(51,1)
		   s cur=$ZU(190,13)
		   s wdpass=+cur
		   s blks=$P(cur,",",2)+$P(cur,",",3)
		} while (blks && (wdpass <= reqpass))
		s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
		d NotifyAsyncMembers(mirname,id,0)
		s status=$SYSTEM.Mirror.GetInfo()
		if (role'="PRIMARY") && (role '= "BACKUP") {
		   ; A new node was added and we're not the primary nor
		   ; a backup. We should restart at Restart to see if we should
		   ; change our role. Presumably there is already something posted
		   ; to the retry list, but if not, add one.
		   s ^MIRROR(mirname,"State")="Restarting"
		   goto Restart
		}		
		goto waitnext
	}
	if $E(text,1,10)="DELMEMBER:" {
		s cur=$ZU(190,13)  ;wdpass,wdqsize,wdwritesiz
		do $ZU(51,1) ;wake wd
		s wdpass=+cur
		s reqpass=wdpass+2
		do {
		   hang 1
		   do $ZU(51,1)
		   s cur=$ZU(190,13)
		   s wdpass=+cur
		   s blks=$P(cur,",",2)+$P(cur,",",3)
		} while (blks && (wdpass <= reqpass))
		s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
		s id=$p(text,":",2)
		d NotifyAsyncMembers(mirname,id,1)
		s status=$SYSTEM.Mirror.GetInfo()
		if (role'="PRIMARY") && (role '= "BACKUP") {
		   ; A new node was deleted and we're not the primary nor
		   ; a backup. We should restart at Restart to see if we should
		   ; change our role. Presumably there is already something posted
		   ; to the retry list, but if not, add one.
		   s ^MIRROR(mirname,"State")="Restarting"
		   goto Restart
		}		
		goto waitnext
	}
	if $E(text,1,14)="CLRDEFPRIMARY:" {
		; Ignore this message. It should be removed. We needed it
		; before the retry code to get the node to re-test whether it
		; should become the primary
		goto waitnext
	}
	if $e(text,1,12)="UPDATEIPADDR" {
		If ($zversion(1)=3) {
			s cur=$ZU(190,13)  ;wdpass,wdqsize,wdwritesiz
			do $ZU(51,1) ;wake wd
			s wdpass=+cur
			s reqpass=wdpass+2
			do {
				hang 1
				do $ZU(51,1)
				s cur=$ZU(190,13)
				s wdpass=+cur
				s blks=$P(cur,",",2)+$P(cur,",",3)
			} while (blks && (wdpass <= reqpass))
		}
		s oip=$p(text,",",2),oiface=$p(text,",",3)
		s nip=$p(text,",",4)
		if (oip'=""||(oiface'="")) {
			s ok=$$DeleteVirtualAddress(mirname,oip,0,oiface)
			if '$lg(ok) {
				d $zu(9,"","Could not delete virtual address ip="_$s(oip="":$G(^SYS("MIRRORSET",mirname,"VirtualAddress")),1:oip)_" iface="_$s(oiface="":$G(^SYS("MIRRORSET","%VIPInterface")),1:oiface)_" - IP address update failed",1 /* broadcast and log message*/,1  /* Warning */)
			}	
		}
		s ok=$$AddVirtualAddress(mirname,nip,0)
		if '$lg(ok) {
			d $zu(9,"","Could not add virtual address ip="_$s(nip="":$G(^SYS("MIRRORSET",mirname,"VirtualAddress")),1:nip)_" iface="_$G(^SYS("MIRRORSET","%VIPInterface"))_" - IP address update failed, error="_$p($lg(ok),",",2,999),1 /* broadcast and log message*/,1  /* Warning */)	
		} else {
			s ^||FirstVIPMonitor=1
		}
		if $SYSTEM.Mirror.IsPrimary() d NotifyAsyncMembers(mirname,"",1)
		goto waitnext
	}
	if $E(text,1,10)="SENDDBINFO" {
		k dbarray s dbname=":mirror:"_mirname_":"
		for ii=2:2:$L(text,":") {
			s dbarray(1,dbname_$P(text,":",ii))=""
			s dbarray(2,dbname_$P(text,":",ii))=$P(text,":",ii+1)_"^"
		}
		s info=$SYSTEM.Mirror.GetNextDBBySFN(0)
		while +info'=-1 {
			s dbname=$P(info,"^",2)
			if $d(dbarray(1,dbname)) {
				k dbarray(1,dbname)
				s sfn=$P(info,"^",4)
				if sfn=$zu(40,0,41) {
					if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","SENDDBINFO message for dismounted database """_$p(dbname,":",4)_""" ignored")
					k dbarray(2,dbname)
				} else {
					s dbarray(2,dbname)=dbarray(2,dbname)_sfn
				}
				q:'$d(dbarray(1))
			}
			s info=$SYSTEM.Mirror.GetNextDBBySFN(+info)
		}
		if $d(dbarray(1)) {
			s dbname=$o(dbarray(1,""))
			while (dbname'="") {
				if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","Received SENDDBINFO message for unknown database: """_$p(dbname,":",4)_""" ("_$p($G(dbarray(2,dbname)),"^")_")")
				k dbarray(2,dbname)
				s dbname=$o(dbarray(1,dbname))
			}
		}
		s dbname=$o(dbarray(2,""),1,info)
		while (dbname'="") {
			s sfn=$P(info,"^",2)
			s fullinfo=$SYSTEM.Mirror.DBGetInfo(0,sfn)
			s dbguid=$P(fullinfo,"^",6)
			if dbguid'=$p(info,"^") {
				d $zu(9,"","In SENDDBINFO found "_dbguid_" for mirrored db """_$p(dbname,":",4)_""". Expected "_$p(info,"^"),1 /* broadcast and log message*/,1  /* Warning */)
			} else {
				do $SYSTEM.Mirror.SendDBInfo(sfn)
			}
			s dbname=$o(dbarray(2,dbname),1,info)
		}
		k dbarray
		goto waitnext
	}
	if $E(text,1,11)="NEWFOMEMBER" {
		s idx=$P(text,":",2)
		s md=$LG($P(text,":",3,9999))
		if idx'=($G(^SYS("MIRRORSET",mirname,"Member"))) {
			d $zu(9,"","NEWFOMEMBER: mis-match index idx="_idx_" member "_$G(^SYS("MIRRORSET",mirname,"Member")),1 /* broadcast and log message*/,1  /* Warning */)
			goto waitnext
		}
		s mobj=##Class(Config.MapMirrors).%New()
		if '$isobject(mobj) {
			d $zu(9,"","NEWFOMEMBER: Config.MapMirror.%New failed",1 /* broadcast and log message*/,1  /* Warning */)
			goto waitnext
		}
		s mobj.ID = mirname
		s mobj.Name = $LG(md,1)
		s mobj.GUID = $LG(md,2)
		s mobj.AgentAddress = $p($LG(md,5),"|")
		s mobj.AgentPort = $p($LG(md,5),"|",2)
		s mobj.ECPAddress = $p($LG(md,3),"|")
		s mobj.MirrorAddress = $p($LG(md,4),"|")
		s mobj.MirrorSSPort = $p($LG(md,4),"|",2)
		s mobj.InstanceDirectory = $LG(md,6)
		s mobj.SSLComputerName = $LG(md,7)
		s mobj.MemberType = +$LG(md,8)
		s mobj.ConnectsTo = $LG(md,9)
		s rc=mobj.%Save()
		if ('rc) {
			s mobj=""
			k err
			Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
			d $zu(9,"","NEWFOMEMBER: add new failover member idx="_idx_" error="_$g(err(1)),1 /* broadcast and log message*/,1  /* Warning */)
			goto waitnext
		}
		s mobj=""
		s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"))
		goto waitnext
	}
	if $E(text,1,11)="DELFOMEMBER" {
		s membername=$P(text,":",2),mcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
		if mcnt'=2&&($SYSTEM.Mirror.GetInfo()'["PRIMARY") {
			d $zu(9,"","DELFOMEMBER: Could not delete the only failover mirror member "_membername,1 /* broadcast and log message*/,1  /* Warning */)
			goto waitnext
		}
		if $e(membername,*)=$c(0) {
			s membername=$e(membername,1,*-1)
			s newtype=0
		} else {
			s newtype=2
		}
		s found=0
		f idx=1:1:mcnt i membername=$LG($G(^SYS("MIRRORSET",mirname,"Member",idx))) s found=1 q
		if 'found {
			d $zu(9,"","DELFOMEMBER: Could not find mirror member "_membername,1 /* broadcast and log message*/,1  /* Warning */)
			goto waitnext
		}
		if $SYSTEM.Mirror.IsPrimary() {
			k props s props("MemberType")=newtype
			s rc=##class(Config.MapMirrors).Modify(mirname,membername,.props)
			if ('rc) {
				d $zu(9,"","DELFOMEMBER: failed to demote failover to async for index="_idx,1 /* broadcast and log message*/,1  /* Warning */)
				goto waitnext
			}
			s systemcnt=^SYS("MIRRORSET",mirname,"Member")
			d NotifyAsyncMembers(mirname,membername,1)
		} else {
			s rc=##class(Config.MapMirrors).Delete(mirname,membername)
			if ('rc) {
				d $zu(9,"","DELFOMEMBER: failed to delete failover for index="_idx,1 /* broadcast and log message*/,1  /* Warning */)
				goto waitnext
			}
			s systemcnt=^SYS("MIRRORSET",mirname,"Member")
		}
		goto waitnext
	}
    if $e(text,1,12)="ForcePrimary" {
	   if role="Pause"  /* Stop sending messages to other systems */ {
	      d $zu(9,"","ForcePrimary message ignored - node is shutting down",1 /* broadcast and log message*/,1  /* Warning */)
  	   } elseif role="BACKUP" {
          ; This shouldn't happen because DesignatePrimary forces
          ; the primary down before sending the ForcePrimary message
          ; so we shouldn't be connected right now. If we are just abort.
         d $zu(9,"","ForcePrimary message rejected - Node is currently a backup member",1 /* broadcast and log message*/,1  /* Warning */)
       } elseif role="PRIMARY" {
	      ; If we forced down the other node and sent a ForcePrimary message
	      ; then its possible we're already the primary in which caes we
	      ; just ignore this.
	      if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","Current primary ignored ForcePrimary message")
       } else {
	      ; Setting forceBecomePrimary causes the routine which
	      ; marks journal files as valid to go ahead and use the
	      ; current end of the file as the valid end if the other node 
	      ; can't be contacted.
	      s forceBecomePrimary=1
	      do ClearRetryList(mirname)  ;if there's a retry list, reset it
	      if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","Setting forceBecomePrimary flag and returning to restart")
	      goto Restart
       }
	   goto waitnext
    }
	if $E(text,1,8)="PROMOTE:" {
		s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"))
		s sysname=$p(text,":",2,999)
		s found=0
		f idx=1:1:systemcnt i sysname=$LG($G(^SYS("MIRRORSET",mirname,"Member",idx))) s found=1 q
		if 'found {
			d $zu(9,"","PROMOTE: Could not find mirror member "_sysname,1 /* broadcast and log message*/,1  /* Warning */)
			goto waitnext
		}
		d NotifyAsyncMembers(mirname,idx,0)
		goto waitnext
	}
	if $E(text,1,12)="SYNCHCONFIG:" {
		s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"))
		s primary=$p(text,":",2,999)
		s found=0
		f idx=1:1:systemcnt i primary=$LG($G(^SYS("MIRRORSET",mirname,"Member",idx))) s found=1 q
		if 'found {
			d $zu(9,"","SYNCHCONFIG: Could not find primary mirror member "_primary,1 /* broadcast and log message*/,1  /* Warning */)
			goto waitnext
		}
		d SynchConfigWithPrimary^MIRRORCOMM(mirname,idx)
		goto waitnext
	}
	if $E(text,1,8)="UPDATEDN" {
		s sysname=$p(text,":",2)
		s DN=$p(text,":",3,9999)
		s cls=##class(Config.MapMirrors).Open(mirname,sysname)  ;open primary's configuration
		if '$IsObject(cls) {
			d $zu(9,"","UPDATEDN Event: Failed to open Config.MapMembers("_mirname_","_sysname_")",1 /* broadcast and log message*/,1  /* Warning */)
		} else {
			set cls.SSLComputerName = DN
			s rc=cls.%Save()
			if (''rc) {
				if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","UPDATEDN Event: updated DN of "_sysname_" with "_DN)
			} else {
				d $zu(9,"","UPDATEDN Event: Failed to save Config.MapMembers("_mirname_","_sysname_") Error:"_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
			}
		}
		goto waitnext
	}
	if $E(text,1,14)="NOTIFYMEMBERS:" {
		if $SYSTEM.Mirror.IsPrimary() d NotifyAsyncMembers(mirname,id,1)
		goto waitnext
	}
	if $E(text,1,13)="PURGEJOURNAL:" {
		d PURGE^JRNUTIL
		goto waitnext
	}
	if $E(text,1,13)="NOTIFYBACKUP:" {
		if 0 goto waitnext
		if $SYSTEM.Mirror.IsPrimary(),systemcnt>0 {
			s info=$G(^SYS("MIRRORSET",mirname,"Member",1))
			if (+$LG(info,10)) {
				s rc=$$NotifyMirrorChange^MIRRORCTL(mirname,1,$LG($G(^SYS("MIRRORSET",mirname,"Member",0))))
				if $LG(rc)'="OK" d $zu(9,"","NOTIFYBACKUP event: NotifyMirrorChange failed with "_$LG(rc)_","_$LG(rc,2),1 /* broadcast and log message*/,2  /* Severe error */)
			}
		}
		goto waitnext
	}
	if $E(text,1,17)="ASYNCTYPECHANGED:" {
		if 0 goto waitnext
		s primaryid=1
		if systemcnt>1 {
			s primaryid=$$GetCurrentPrimaryID(mirname)
			if primaryid<0 goto waitnext
		}
		s rc=$$NotifyAsyncTypeChanged^MIRRORCTL(mirname,primaryid,$LG($G(^SYS("MIRRORSET",mirname,"Member",0))),id)
		if $LG(rc)'="OK" if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","ASYNCTYPECHANGED event: NotifyAsyncTypeChanged failed with "_$LG(rc)_","_$LG(rc,2))
		goto waitnext
	}
	if $E(text,1,14)="DEJOURNALSTOP:" {
		k ^||MIRROR(mirname,"DejournalRunning")
		k ^MIRROR(mirname,"DejournalRunning")
		if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","Dejournaling marked as stopped in response to DEJOURNALSTOP message")
		goto waitnext
	}
	if $E(text,1,16)="SETLASTVALIDFILE" {
		d Updatelastjvalidjrnfile(mirname)
		goto waitnext
	}
	; error case (text="ERR")
	goto waitnext	
UNKNOWN ;
	d $zu(9,"","MIRRORSVR found unknown message on queue: "_keyword_" from "_id_" ("_text_")",1 /* broadcast and log message*/,1  /* Warning */)
	goto waitnext
REQMSG ;
	; Come here to process REQ messages
	if $e(text,1,10)="ASYNCDONE:" {
		if +$G(^SYS("MIRRORSET",0,"AsyncUseSystemPurgeInterval"))'=0 goto waitnext
		s jrnfilecnt=+$E(text,11,*)
		if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","Dejournaling complete for mirror: "_mirname_", file #"_jrnfilecnt_" - Queuing to be deleted")
		; Post this to the list of files which can be purged
		s ^MIRROR(mirname,"PendingPurgeList",jrnfilecnt)=""
		goto waitnext
	}
	d $zu(9,"","MIRRORSVR received unknown REQ msg: from "_id_" ("_text_")",1 /* broadcast and log message*/,1  /* Warning */)
	goto waitnext	
}  ;End of Start()
 /* BackupWaitForArbiterChange() 
    When MIRDOWN is called because the data channel on the backup
    is lost and we're in arbiter mode and both arbiter connections
    exist we come here to wait for something to change. At the
    expiration of the mirrortimeout (worst case) we expect either one
    or both arbiter connections will be dropped or we'll switch to 
    agent controlled mode (if the primary can talk to us over the
    arbiter channel).  If we wait here for twice the mirror timeout
    we assume something has gone wrong and we clear the ActiveBackup
    flag so we can't take over without talking to the primary.
       1 -> We can continue with failover in mirdown. Either we're 
            now in agent contact mode or one or both of the arbiter
            connections has gone down
	   0 -> ActiveBackupFlag has been cleared and we should contact
	        the agent on the other member to find out what to do
 */
BackupWaitForArbiterChange(mirname) {
	s $zt="err"
top ;
	s failoverRule=$SYSTEM.Mirror.FailoverRule()
   	if failoverRule'=1 {
		quit 1
   	}
	s arbiterState=$SYSTEM.Mirror.ArbiterState()
	s bits=2+4
	if ($ZB(+arbiterState,+bits,1)'=bits) {
		quit 1  ; one of the nodes disconnected
	}
	s rc=$SYSTEM.Mirror.TroubleTimeoutExpired()
	;rc=success/fail,timeout(msec),endtime(usec),starttime(usec)
	s tout=+$P(rc,",",2)/1000  ;msec->sec
	s elapsed=($P(rc,",",3)-$P(rc,",",4))/1000000  ;usec->sec
	if rc {
	    d $zu(9,"","Mirror wait time of "_elapsed_" seconds in Arbiter Controlled mode with both connections up exceeded trouble timeout of "_tout_" seconds. Clearing ActiveBackup state and restarting",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	s rc=$$MonitorArbiterConnection^MIRRORCOMM(mirname)
	hang 0.1
	goto top
err ;
	s $zt=""
	d $zu(9,"","BackupWaitForArbiterChange caught "_$ze,1 /* broadcast and log message*/,2  /* Severe error */)
	d BACK^%ETN
	quit 0 
}
 /* AsyncJrnfilePurge()
    Called to check the list of mirror journal files queued to
         ^MIRROR(<mirname>,"PendingPurgeList",<mirjrnfile count 1>)
         ^MIRROR(<mirname>,"PendingPurgeList",<mirjrnfile count 2>)
         .
         .
         .
         ^MIRROR(<mirname>,"PendingPurgeList",<mirjrnfile count n>)
    to see if they can be purged. The files can be purged when they are
    no longer required for transaction rollback. 
    When the dejournaling reader finishes with a journal file on an
    async member it sends a REQ+ASYNCDONE message to the MIRRORMGR process
    on the machine via $SYSTEM.Event.Signal(). The MIRRORMGR process then
    issues a set to add an entry to the PurgeList. In the idle loop (at waitloop)
    any time there's an entry in the list, this routine is called...as
    the journal files are purged, they are removed from the list.
 */
AsyncJrnfilePurge(mirname) [PUBLIC] {
    ; Get the transaction rollback point for the databases which
    ; are part of this mirror
	s mindbinfo=$$GetMinDBJrnInfo^MIRRORMGR(mirname)
	if '$LG(mindbinfo) {
	   s txt=$LG(mindbinfo,2)
	   k err
	   Do DecomposeStatus^%apiOBJ(txt,.err,"-d") 	
	   s msg=""
  	   for i=1:1:err s msg=msg_err(i)_". "
	   d $zu(9,"","AsyncJrnfilePurge("_mirname_") failed to read minimum db info: "_msg,1 /* broadcast and log message*/,1  /* Warning */)
	   quit 1  ;remove retry entry
	}
	s minjrncnt=+$LG(mindbinfo,2)
	; When $LG(mindbinfo,2) and $LG(mindbinfo,3) are both 0 then
	; this system doesn't have any mirrored db's so technically it
	; doesn't require any journal files. However, someone is probably
	; going to add some soon so don't delete any files yet in case
	; they're needed. Once we get a database then we can delete any
	; files we didn't need.
	if 'minjrncnt {
		quit
	}
	;
loop ;
	s mirfilecnt=$O(^MIRROR(mirname,"PendingPurgeList",""))
	if mirfilecnt="" quit  ; nothing to do
	if minjrncnt<=mirfilecnt {
		; the minimum required file for transaction rollback is earlier
		; than the file we want to delete. Queue a retry entry and we'll
		; come back to check this later on the next cycle (this routine
		; is called from the wait loop if the list isn't empty).
	   quit
	}
	; Remove this from the list now so if we run into an error,
	; we don't retry it over and over forever
	k ^MIRROR(mirname,"PendingPurgeList",mirfilecnt)
	;
	s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(mirfilecnt,mirname)
   	if +rc<=0 {
	   d $zu(9,"","AsyncJrnfilePurge failed ("_rc_") looking up journal file #"_mirfilecnt_" from "_mirname_" in log",1 /* broadcast and log message*/,1  /* Warning */)
	   goto loop
   	}
    s jrnfile=$P(rc,",",2)
    s rc=$ZU(78,22,jrnfile)
    if 'rc {
	   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","AsyncJrnfilePurge("_mirname_") found file "_jrnfile_" (#"_mirfilecnt_") doesn't exist")
	   goto loop
    }
	; Great, this file is ripe and ready to be deleted
    s rc=$ZU(78,23,jrnfile)
    if 'rc {
      d $zu(9,"","Error deleting "_jrnfile_" (file #"_mirfilecnt_" from "_mirname_") after dejournaling completed",1 /* broadcast and log message*/,1  /* Warning */)
    } else {
	  d $zu(9,"","Mirror ("_mirname_") journal file "_jrnfile_" (#"_mirfilecnt_") deleted after dejournal completed",0,0  /* Informational message */)
    }
    goto loop
}
UpdateJournalFilesSent(mirname,filesentlist) {
	s $zt="err"
	s clientcnt=$SYSTEM.Mirror.ClientQuery()
	if '$D(filesentlist) {
		s name=$O(^MIRROR(mirname,"LastJrnfileSent",""),1,val)
		while (name '= "") {
			s filecnt=$P(val,"^",2)
			s filesentlist(name)=filecnt
			s name=$O(^MIRROR(mirname,"LastJrnfileSent",name),1,val)
		}
	}
	if +clientcnt {
		for id=1:1:clientcnt {
			s info=$SYSTEM.Mirror.ClientQuery(id)
			if +info {
				s name=$P(info,",",2)
				s mirfilecnt=$P(info,",",4)
				s mirackpos=+$P(info,",",6)
				if mirackpos,$G(filesentlist(name))'=mirfilecnt {
			        s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(mirfilecnt,mirname)
		   	        if +rc>0 {
			  	       s jrnfile=$P(rc,",",2)
			  	       s shortname=$p(jrnfile,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""),*)
		   	        } else {
			   	       s shortname=""
		   	        }
		   	        s str=$ZTS_"^"_mirfilecnt_"^"_shortname
		   	        s rc=$SYSTEM.Mirror.SetSystemGlobal($LB("MIRROR",mirname,"LastJrnfileSent",name),str)
					s filesentlist(name)=mirfilecnt
					if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","Updated lastfilesent for "_name_" to "_str_$s(rc:" with JRNMIRSET record",1:""))
				}
				s checked(name)=mirfilecnt
			}
		}
	}
	s clientcnt=$SYSTEM.Mirror.ClientInfo()
	if +clientcnt {
		for id=1:1:clientcnt {
			s info=$SYSTEM.Mirror.ClientInfo(id)
			if +info {
				s name=$P(info,",",2)
				s mirfilecnt=$P(info,",",4)
				if '$d(checked(name)),mirfilecnt>$p($G(^MIRROR(mirname,"LastJrnfileSent",name)),"^",2) {
			        s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(mirfilecnt,mirname)
		   	        if +rc>0 {
			  	       s jrnfile=$P(rc,",",2)
			  	       s shortname=$p(jrnfile,$s(($zversion(1)=3):"/",($zversion(1)=2):"\",1:""),*)
		   	        } else {
			   	       s shortname=""
		   	        }
		   	        s str=$ZTS_"^"_mirfilecnt_"^"_shortname
		   	        s rc=$SYSTEM.Mirror.SetSystemGlobal($LB("MIRROR",mirname,"LastJrnfileSent",name),str)
					s filesentlist(name)=mirfilecnt
					if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","Updated lastfilesent from ClientInfo for "_name_" to "_str_$s(rc:" with JRNMIRSET record",1:""))
				}
			}
		}
	}
	quit
err ;
	d $zu(9,"","UpdateJournalFilesSent^MIRRORMGR: Caught error: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	d BACK^%ETN
	ztrap $ze  ;resignal error
}
LogClassError(msg,rc,logonly=1) {
	/* msg is some text message we want to display
	   $$$ISERR(rc) is true (rc is the status from a ##class()
	   logonly is 1/0 (0 = display error message on current output device)
	*/
	Do DecomposeStatus^%apiOBJ(rc,.err,"-d") 
	if 'logonly {
		w !,msg
		for i=1:1:err w !,?5,err(i)
	}
	d $zu(9,"",msg_$C(13,10)_"         ErrorText: "_err,1 /* broadcast and log message*/,1  /* Warning */)
}
CompareGUIDs(guid1,guid2) PUBLIC {
	/* Takes 2 GUIDs in string form and returns:
	       -1 -> first<second
	        0 -> first=second
	        1 -> first>second
	*/
	; GUID = xxxxxxxx-xxxx-xxxx-xxxxxxxxxxxx
	s pieces=$L(guid1,"-")
	if pieces'=$L(guid2,"-") ztrap "BGUID"  ;<ZBDUI> error
	f i=1:1:pieces {
		s hex1=$P(guid1,"-",i)
		s hex2=$P(guid2,"-",i)
		q:hex1'=hex2
	}
	if hex1=hex2 quit 0  ;all pieces are equal
	s val1=+$ZH(hex1_" ")
	s val2=+$ZH(hex2_" ")
	if (val1 < val2) {
		quit -1  ;first < second
	}
	quit 1 ; first > second
}
    /* RetryCheckBecomePrimaryOK is added to the retry list in
       BecomePrimary when $$CheckBecomePrimaryOK^ZMIRROR() returns
       0. Here we retry the call to CheckBecomePrimaryOk until it
       return 1 or until we find that the other node has started up
       and is the primary */
RetryCheckBecomePrimaryOK(mirname) PUBLIC {
	s ok=$$RunZMIRROR(2,1)
	if ok {
		d $zu(9,"","CheckBecomePrimaryOK now reports it is ok to proceed",0,0  /* Informational message */)
		quit 1
	}
	s ok=$$CheckPrimaryIsUp(mirname)
	if ok quit 1  ;we can try to become the backup
	quit 0
}
CheckPrimaryIsUp(mirname) PUBLIC {
	/* Returns TRUE if the other node is the primary.
	   Returns FALSE if the other node is not the primary.
	   Call this when retrying some operation that blocks us
	   from becoming the primary if we want to give up if we
	   can become the backup instead 
	*/
    s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"))
    if systemcnt=0 {
	   quit 0  ;no other failover members
    }
    s id=1  ;this is the id of the other failover node
    s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
   	if info="" {
	   d $zu(9,"","CheckPrimaryIsUp missing info for node #"_id,1 /* broadcast and log message*/,1  /* Warning */)
	   quit 0  ;failed to contact it
   	}
   	s name=$lg(info,1)
   	;
   	s rc=$$GetStatus^MIRRORCTL(mirname,id)
   	s status=$LG(rc) 
   	if status="PRIMARY" {
		quit 1  ;we can try to become a backup
   	}
   	quit 0
}
RecheckArbiterControlledFailover(mirname) PUBLIC {
   /* RecheckArbiterControlledFailover returns:
        1 - Not in arbiter controlled failover mode, data channel 
            exists, or we're connected to the arbiter but the other 
            node is not - we can retry failover
        0 - continue to wait
      This is queued in the decision loop when we're in arbiter
      controlled failover mode and the data channel doesn't exist
      but either we're not connected to the arbiter or the primary
      is still connected to the arbiter. We're in a wait state until
      either we're not in arbiter controled mode any more or we're
      in a state where we can try to become the primary.
   */
   if '$SYSTEM.Mirror.ActiveBackupFlag() {
	   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","RecheckArbiterMode found ActiveBackupFlag cleared - continuing")
	   quit 1
   }
   if +$SYSTEM.Mirror.GetInfo(5)'=0 {
	   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","RecheckArbiterMode found data channel up - continuing")
	   quit 1
   }
   s mode=$SYSTEM.Mirror.FailoverRule()
   if (mode'=1) {
	   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","RecheckArbiterMode found system in "_mode_" mode - continuing")
	   quit 1
   }
   s state=$SYSTEM.Mirror.ArbiterState()
   s mask=2+4
   s state=$zb(+state,+mask,1)  ;mask off other bits
   if state=2 {
	   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("800000"),1) do $zu(9,"","RecheckArbiterMode found state bits 0x"_state_" - continuing")
	   quit 1
   }
   quit 0  ;keep waiting
}
RecheckCanNodeStartToBecomePrimary(mirname) PUBLIC {
   /* RecheckIsOtherNodeDown returns:
        1 - other node is primary or CanNodeStartToBecomePrimary returns 1
        0 - continue to wait
      This entry point is added to the retry queue when 
      CanNodeStartToBecomePrimary^ZMIRROR returns failure at the top of
      BecomePrimary(). In that case the node was all ready to become the 
      primary but the user has decided that we should wait for a while.
	  We know the other node isn't the primary at this point so there must 
	  have been some other reason they aborted (eg. they may require manual 
	  intervention before a node becomes the primary).
      In any case we wait until either the other node is the primary and we
      can become the backup or CanNodeStartToBecomePrimary returns true.
    */
   s ok=$$RunZMIRROR(1,1)
   if ok {
	   quit 1  ;we can try to become the primary again
   }
   If $$CheckNewDataForPromotedStandalone(mirname) quit 1
   ; If the other node is the primary, we should stop waiting and become the backup
   s rc=$$CheckPrimaryIsUp(mirname)
   quit rc
 }
CheckOtherNodeIsReachable(mirname) PUBLIC {
   /* CheckOtherNodeIsReachable returns:
        1 - other node is Reachable (agent)
        0 - we couldn't reach other node
      This is called by the retry logic when we can't contact the
      other node or if we fail in some manner which requires that
      we can reach the other node in order to recover (continue).
      This routine returns TRUE when we successfully contact the agent
      on the other node. 
   */
   ; If there is only one node in the mirror, the other node
   ; must have been deleted
   s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"))
   if systemcnt=0 {
	   d $zu(9,"","Only one node remaining in mirror - OtherNodeIsReachable passes",0,0  /* Informational message */)
	   quit 1
   }
   s id=1  ;this is the id of the other failover node
   s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
   if info="" {
	   d $zu(9,"","CheckOtherNodeIsReachable missing info for node #"_id,1 /* broadcast and log message*/,1  /* Warning */)
	   quit 0  ;failed to contact it
   }
   s name=$lg(info,1)
   ;
   s info=$$GetStatus^MIRRORCTL(mirname,id)
   s status=$LG(info) 
   if ((status'="TIMEOUT") && (status'="ERR")) {
	   quit 1  ;we reached the other node, execute the Restart loop
   }
   quit 0  
}
QueueCheckForDuplicatePrimary(mirname) PUBLIC {
   s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"))
   if systemcnt=0 {
	   quit ;only one node nothing to do
   }
   s ourinfo=$SYSTEM.Mirror.GetInfo()
   if ourinfo'["PRIMARY" {
	  ;The other node is the primary but we're not. This is ok although
	  ; it is strange that this is called while we're not the primary
      quit
   }
   s id=1  ;this is the id of the other failover node
   s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
   if info="" {
	   d $zu(9,"","QueueCheckForDuplicatePrimary("_mirname_") cannot locate other failover member",1 /* broadcast and log message*/,1  /* Warning */)
	   quit 
   }
   k ^MIRROR(mirname,"ConsoleLog","CheckForDuplicatePrimaryNetworkErr")
   s name=$lg(info,1)
   s addrlist=$$BuildAgentAddrlist^MIRRORCTL(info)  ; comma delimited list of addresses
   s basedir=$LG(info,6)
   s targguid=$LG(info,2)
   do AddMonitorEntry(mirname,"(""(rc) { s rc=$$CheckForDuplicatePrimary("""""_mirname_""""","""""_name_""""","""""_addrlist_""""","""""_targguid_""""","""""_basedir_""""") }"", .rc)")
}
CheckForDuplicatePrimary(mirname,name,addrlist,targguid,basedir) PUBLIC {
   /* CheckOtherNodeIsDown returns:
          1 - agent on other node contacted and node is not Primary
          0 - agent on other node failed to respond
      When a node becomes the primary when agent contact required is
      set to 0 (eg. $$IsOtherNodeDown^ZMIRROR() reported 1) we add
      a retry entry to call this routine where we recheck to see
      if we can contact the agent on the other node periodically. When
      we contact the agent on the other node if we find the other node
      is the primary then we declare a problem and halt the mirror.
      Otherwise we return 1 so that this entry gets removed from the
      retry list. 
   */
   s ourinfo=$SYSTEM.Mirror.GetInfo()
   if ourinfo'["PRIMARY" {
	  ;The other node is the primary but we're not. This is ok although
	  ; it is strange that this retry entry is queued while we're not
	  ; the primary
      quit 1
   }
   s rc=$$GetStatusByAddr^MIRRORCTL(mirname,addrlist,targguid,basedir)
   s status=$LG(rc)
   if (status="TIMEOUT") || (status="ERR") {
	   quit 0
   }
   if status="HUNG" {
	   if $G(^SYS("MIRRORSET",mirname,"VirtualAddress"))'="" {
		   s x=$$ChangeVirtualAddress^MIRRORCTL(mirname,addrlist,targguid,basedir,0)
	   }
	   s rc=$$ForceNodeDownByAddr^MIRRORCTL(mirname,addrlist,targguid,basedir,1)
	   d $zu(9,"","Status from forcing down old (now hung) primary ("""_name_"""): "_$$Format^%qcr(rc,1),0,0  /* Informational message */)
	   quit 1  ;other node is not the primary
   }
   if status'="PRIMARY" {
	   quit 1  ;success, other node is not the primary
   }
   if $LL(rc)>4 {
	   s remoteSystemGUID=$LG(rc,5)
	   if remoteSystemGUID=$SYSTEM.ECP.SystemGUID() {
		   if $G(^MIRROR(mirname,"ConsoleLog","CheckForDuplicatePrimaryNetworkErr"))="" {
			   s ^MIRROR(mirname,"ConsoleLog","CheckForDuplicatePrimaryNetworkErr")=1
			   d $zu(9,"","Check for duplicate primary reached local system. Ignored. Consider re-configuring mirror network addresses using numeric IP values to avoid DNS problems",0,0  /* Informational message */)
		   }
		   if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","Check for duplicate primary reached local system. Will be retried later")
		   quit 0
	   }
   }
   s failoverMode=$SYSTEM.Mirror.FailoverRule()
   if failoverMode'=3 {
	   if $LL(rc)>=3 {
		   s trouble=+$LG(rc,3)  ;3rd element is trouble flag
	   } else {
		   s trouble=1  ;assume its set
	   }
	   if trouble {
	      d $zu(9,"","Forcing down old primary ("""_name_""") which is currently in a trouble state",0,0  /* Informational message */)
	   } else {
		  d $zu(9,"","Duplicate Primary Detected: Forcing down old primary ("""_name_""") which is NOT in a trouble state",1 /* broadcast and log message*/,2  /* Severe error */)
	   }
   } else {
	   s $ZE="<ZDUPLICATE PRIMARY>"
	   d BACK^%ETN
	   d $zu(9,"","Two primaries detected in the mirror - Forcing node """_name_""" and shutting down",1 /* broadcast and log message*/,1  /* Warning */)
   }
   if $G(^SYS("MIRRORSET",mirname,"VirtualAddress"))'="" {
	   s x=$$ChangeVirtualAddress^MIRRORCTL(mirname,addrlist,targguid,basedir,0)
   }
   s status=$$ForceNodeDownByAddr^MIRRORCTL(mirname,addrlist,targguid,basedir,1)
   if failoverMode'=3 {
	   quit 1
   }
   d $zu(9,"","Shutting down",1 /* broadcast and log message*/,1  /* Warning */)
   l  ; release all locks
   do INT^SHUTDOWN
   halt
}
RecheckRequiredDatabases(mirname,lastjrnfilecnt,lastjrnend) PUBLIC {
	/* Added to the retry list when CheckRequiredDatabases() fails.
       This returns success when either CheckRequiredDatabases
       succeeds or CheckForDuplicatePrimary() is true
    */
    if $$CheckRequiredDatabases^MIRRORCOMM(0,lastjrnfilecnt,lastjrnend) {
	    quit 1
    }
    if '$$CheckValidFailoverMember() Quit 1
	s ok=$$CheckPrimaryIsUp(mirname)
	if ok quit 1  ;we can try to become the backup
	d $zu(9,"","Required Database checks still failing, waiting for primary to start",1 /* broadcast and log message*/,1  /* Warning */)
	quit 0
}
CheckValidFailoverMember() {
	s cls=##class(Config.MirrorMember).Open(,,.rc)
	if ('rc) {
		quit 1  ; Failure means no condition changed, so return code as if this is still a valid member.
	}
	if cls.isAsyncMember() quit 1  ; This is an async member
	s validmember=cls.ValidatedMember
	s cls=""
	quit validmember
}
ReCheckDefinedPrimary(mirname) PUBLIC {
	/* Added to the retry list when CheckRequiredDatabases() fails.
       This returns success when either CheckRequiredDatabases
       succeeds or CheckForDuplicatePrimary() is true
    */
    if $$CheckDefinedPrimary(1)=1 {
	    quit 1
    }
    if '$$CheckValidFailoverMember() Quit 1
    If $$CheckNewDataForPromotedStandalone(mirname) quit 1
	s ok=$$CheckPrimaryIsUp(mirname)
	if ok quit 1  ;we can try to become the backup
	d $zu(9,"","'No Failover' checks still failing, waiting for primary to start",1 /* broadcast and log message*/,1  /* Warning */)
	quit 0
}
AddRetryEntry(mirname,cmd,tag,reasonMSG="") {
	; Warning: Any tags (routines) referenced in the command need to be listed
	;          in the goto $case where $$$CheckRetryList() returns a value.
	;		   Any tags passed need to be accessible from an execute
	;          statement at the "level" of tag 'wait:'
	s ri=$I(^||MIRROR(mirname,"retry","list"))
	s ^||MIRROR(mirname,"retry","list",ri)=cmd
	if $G(tag)'="" {
		s ^||MIRROR(mirname,"retry","list",ri,"goto")=tag
	}
	; Update non-ppg version so we can see the list
	s ^MIRROR(mirname,"retry","list")=ri
	s ^MIRROR(mirname,"retry","list",ri)=cmd
	s:$G(tag)'="" ^MIRROR(mirname,"retry","list",ri,"goto")=tag
	k ^MIRROR(mirname,"retry","lasttime")
	s ^MIRROR(mirname,"RetryReason")=$G(reasonMSG,"")
}
AddMonitorEntry(mirname,cmd) {
	s ri=$I(^||MIRROR(mirname,"retry","monitor"))
	s ^||MIRROR(mirname,"retry","monitor",ri)=cmd
	; Update non-ppg version so we can see the list
	s ^MIRROR(mirname,"retry","monitor")=ri
	s ^MIRROR(mirname,"retry","monitor",ri)=cmd
}
GetCurrentPrimaryID(mirname) PUBLIC {
	/* Called on a reporting node to get the id of the
	   current primary which it should connect to.
	   Returns: -1 -> some problem or no current primary
	           >=0 -> MIRRORSET Member # (0/1) of current primary
	*/
	s $zt="err"
	;
	s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"))
	if systemcnt="" quit -1  ;no failover nodes configured
	s status=""
	Set id=+$G(^MIRROR(mirname,"PrimaryMember"))
	If 'id||(id>1&&(systemcnt<2)) s id=1
	while (systemcnt) {
	   s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
       if info'="" {
	      s name=$lg(info,1)
          s rc=$$GetStatus^MIRRORCTL(mirname,id)
          s status=$LG(rc)  
	      if status="PRIMARY" {
		      Set ^MIRROR(mirname,"PrimaryMember")=id
		      quit
	      }
       }
       if $i(systemcnt,-1) Set id=$s(id=1:2,1:1)
	}	
	if status="PRIMARY" quit id
	quit -1  ;no primary found
err ;
	s $zt=""
	d $zu(9,"","Unexpected error in GetCurrentPrimaryID: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	quit -1	
}
ClearRetryList(mirname) {
	; This is called when a node begins the process of becoming
	; the primary or a backup. Up to that point the retry list contains
	; things that need to be retried to get to the point of becoming
	; the primary or backup (if there is anything). When the node starts
	; becoming the primary or the backup if there's anything still on the
	; list it can be removed as we may add new items related to 
	; failures becoming the backup/primary.
	k ^||MIRROR(mirname,"retry")
	k ^MIRROR(mirname,"retry")
}
CheckRetryList(mirname) ;
	/* This is NOT a procedure block routine because we want it
	   executed with the same private variable list as the
	   main mirror manager loop because a couple of arrays need
	   to be passed (obviously by reference) to a couple of the
	   functions. We could just declare those variables 
	   (RequiredRecoveryAction and ConnectHistory) as public so we
	   can see their values, or even pass them in by reference but
	   this seems easier.
	   If there is an item on the retry list we execute it.
	   If it returns TRUE (non-zero) we remove it from the list
	   and if it has an associated goto target, we return that 
	   target. If it doesn't have a goto target then we repeat the
	   process until the list is empty.
	   Note that many, if not all, of the commands we execute expect
	   mirname set to the mirror name we're processing and they return
	   with 'rc' set to TRUE/FALSE for PASS/FAIL.
	   We read the commands from the PPG because we don't want someone
	   to be able to set a string into the ^MIRROR global which we then
	   execute.
	*/
	s index=$O(^||MIRROR(mirname,"retry","monitor",""),1,cmd)
	while (index '= "") {
		s rc=0  ; cmd returns its status in rc
		x @cmd
		if rc {
		   if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","Monitor item /"_cmd_" (index "_index_") succeeded - Removed from list")
		   k ^||MIRROR(mirname,"retry","monitor",index)
		   k ^MIRROR(mirname,"retry","monitor",index)
		}
		s index=$O(^||MIRROR(mirname,"retry","monitor",index),1,cmd)
	}
top ;	
	s index=$O(^||MIRROR(mirname,"retry","list",""),1,cmd)
	if index="" quit ""
	; 
	s rc=0  ; cmd returns its status in rc
	x @cmd
	q:'rc ""  ; failed
	s tag=$G(^||MIRROR(mirname,"retry","list",index,"goto"))
	if $zb(+$SYSTEM.Mirror.DebugFlags(),4,1) do $zu(9,"","Retried cmd /"_cmd_" (index "_index_") succeeded. Restart tag = /"_tag_"/")
	k ^||MIRROR(mirname,"retry","list",index)
	k ^MIRROR(mirname,"retry","list",index)
	k ^MIRROR(mirname,"RetryReason")
	if tag'="" quit tag
	goto top	
TakeOverAsPrimary() PUBLIC {
	/* TakeOverPrimary() is invoked by a user or script when the
	   mirror is up, this node is a backup, and they want this node 
	   to take over as the primary. We force the other node down
	   which should trigger a takeover by this node.
	   If this node fails to become the primary, or it is not 
	   currently a backup and you want it to become the primary,
	   DesignatePrimary() should be used instead. This routine will
	   not force this node to become a primary if doing so would 
	   mean we then have to rebuild the other node. DesignatePrimary()
	   can ignore certain types of errors to force a node to become
	   the primary in disaster type situations where the concern is
	   getting back up rather than preserving the mirror state of the
	   other node. This may involve loosing some data which was present
	   on the other node. The user is responsible for understanding the
	   state of the mirror and the consequences of their actions.
	   returns $LB(0,<error text>)
	           $LB(1)
	*/
	s $zt="err"
	s info=$SYSTEM.Mirror.GetInfo()
	if info'[",DEFINED," {
		quit $LB(0,"Not configured as a mirror member")
	}
	if info["PRIMARY" {
		quit $LB(1,"This system is already a primary member.")  ;we're currently the primary, signal success
	}
	if info'["BACKUP" {
		quit $LB(0,"TakeOverAsPrimary failed - not currently a backup node")
	}
	;
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") {
		quit $LB(0,"Operation requires %Admin_Manage:Use privilege")
	}
 	s mirname=##class(Config.Mirrors).GetMirrorName()
 	if mirname="" {
		quit $LB(0,"Failed to locate current mirror name in [Mirrors] section")
	}
	s cls=##class(Config.Mirrors).Open(mirname,,,.rc)
	if ('rc) {
		quit $LB(0,"Failed to read [Mirrors] configuration section for "_mirname)
	}
	s definedPrimary=cls.DefinedPrimary
	s cls=""
	;
	s cls=##class(Config.MirrorMember).Open(,,.rc)
	if ('rc) {
		quit $LB(0,"Failed to read [MirrorMember] configuration section")
	}
	s reportingNode=cls.isAsyncMember()
	s systemid=cls.SystemName
	s validmember=cls.ValidatedMember
	s cls=""
	if reportingNode {
		quit $LB(0,"Reporting nodes are not eligible to become the primary mirror member")
	}
	if 'validmember {
		; this test is silly because we already know we're a backup...
		quit $LB(0,"Current node is not eligible to become the primary as it is not a validated mirror member")
	}
	;
	s lastjrninfo=$$GetMaxDejrnStart(mirname,3)  ;returns $LB(rc,<jrnfilecnt>,<jrnendoff>)
    if '$LG(lastjrninfo)||($LG(lastjrninfo,2)=0) {
	    s lastjrnfilecnt=0
	    s lastjrnend=""  ;no journal files yet	
    } else {
	    s lastjrnend=+$LG(lastjrninfo,3)
	    s lastjrnfilecnt=+$LG(lastjrninfo,2)
    }
	if '$$CheckRequiredDatabases^MIRRORCOMM(1,lastjrnfilecnt,lastjrnend) {
		quit $LB(0,"One or more required mirrored databases are not active - see console log")
	}
	if definedPrimary'="",definedPrimary'=systemid {
		; try to clear this since we're going to take over 
		; as the primary
	   s rc=$$ClearMirrorNoFailover^MIRRORCTL("Primary")
	   if $LG(rc)="ERR" {
		   s rc=$LG(rc,2)
		   quit $LB(0,"Cannot become primary - Failed to clear the nofailover state. Error = /"_rc_"/")
	   }
	}
	s id=1  ;The other failover member which we know already exists
	s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
    if info="" {
	   quit $LB(0,"Cannot become primary - Failed to read current primary information from MIRRORSET Member id #1")
    }
    s name=$lg(info,1)
	s rc=$$GetStatus^MIRRORCTL(mirname,id)
	s status=$LG(rc)  
	if status="ERR" {
		h 1
		s rc=$$GetStatus^MIRRORCTL(mirname,id)
		s status=$LG(rc)  
		; we'll continue and return failure
	}
	if (status'="PRIMARY")&&(status'="HUNG") {
	   quit $LB(0,"Cannot force other node, status is """_status_""" - not HUNG or PRIMARY")
	}
	s force=0
	if (status = "HUNG") {
	    d $zu(9,"","TakeOverAsPrimary forcing down hung primary """_name_"""",0,0  /* Informational message */)
	} elseif (status="PRIMARY") {
	   d $zu(9,"","TakeOverAsPrimary forcing down current primary """_name_"""",0,0  /* Informational message */)
	}
	s status=$$ForceNodeDown^MIRRORCTL(mirname,id)
	s waittime=15
	do {
	   h 1
	   s rc=$$GetStatus^MIRRORCTL(mirname,id)
       s status=$LG(rc)  ; PRIMARY/UP/DOWN/HUNG/TIMEOUT/ERR
       s waittime=waittime-1
	} while waittime && (status'="DOWN")
	if (status'="DOWN") {
	   d $zu(9,"","Primary "_name_" failed to shut down (status="""_status_""")",1 /* broadcast and log message*/,1  /* Warning */)
	} else {
	   d $zu(9,"","Primary "_name_" killed",0,0  /* Informational message */)
	}
	;
	;Should trigger a takeover by this node so
	;   we should see this node become the primary	
	s waittime=15
	do {
	   h 1
	   s info=$SYSTEM.Mirror.GetInfo()
       s waittime=waittime-1
	} while waittime && (info'["PRIMARY")
	if info[",PRIMARY," {
	   quit $LB(1,"Success.")  ;succeeded
	}
	quit $LB(1,"This system did not become a primary after 15 seconds wait, please check mirror status later.")
err ;
	s $zt=""
	quit $LB(0,"Caught error: /"_$ZE_"/")	
}
DesignatePrimary(forcetakeover=0) PUBLIC {
	/* DesignatePrimary() is invoked by the system manager when there
	   is some problem with the mirror that prevents a node from becoming
	   a primary and they want to force this node to become the primary
	   regardless of the consequences. This may result in this node starting
	   up without some of the data which was present on the old primary 
	   and it may result in being unable to start the other node without
	   restoring all of its mirrored db's from a new backup of this node. 
	   This is designed to be used in situations where the user has 
	   knowledge of the state of the journal files on this node (with
	   respect to the other node) or in situations where the data from
	   the other node has been lost and the best we can do is restart
	   with what we have on this one. 
	   This can still fail if we find we run into some problem we
	   can't get around (eg. we can't read the journal log, we have
	   some databases which require some journal file(s) we don't have,
	   etc...)
	   returns $LB(0,<error text>)
	           $LB(1)
	*/ 
	s $zt="err"
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") Quit $LB(0,"Required %Admin_Manage:USE privilege")
	s info=$SYSTEM.Mirror.GetInfo()
	if info'[",DEFINED," {
		quit $LB(0,"Not configured as a mirror member")
	}
	if info["PRIMARY" {
		quit $LB(1)  ;we're currently the primary, signal success
	}
	if 'forcetakeover,info["BACKUP" {
		quit $LB(0,"This node is an active backup, cannot force takeover")
	}
	;
 	s mirname=##class(Config.Mirrors).GetMirrorName()
 	if mirname="" {
		quit $LB(0,"Failed to locate current mirror name in [Mirrors] section")
	}
	s cls=##class(Config.Mirrors).Open(mirname,,,.rc)
	if ('rc) {
		quit $LB(0,"Failed to read [Mirrors] configuration section for "_mirname)
	}
	s definedPrimary=cls.DefinedPrimary
	s cls=""
	;
	s cls=##class(Config.MirrorMember).Open(,,.rc)
	if ('rc) {
		quit $LB(0,"Failed to read [MirrorMember] configuration section")
	}
	s reportingNode=cls.isAsyncMember()
	s systemid=cls.SystemName
	s validmember=cls.ValidatedMember
	s cls=""
	if reportingNode {
		quit $LB(0,"Reporting nodes are not eligible to become the primary mirror member")
	}
	if 'validmember {
		quit $LB(0,"Current node is not eligible to become the primary as it is not a validated mirror member")
	}
	;
	if definedPrimary'="",definedPrimary'=systemid {
		; try to clear this since we're going to take over as the primary
	   s rc=$$ClearMirrorNoFailover^MIRRORCTL("Primary")
	   if $LG(rc)="ERR" {
		   s rc=$LG(rc,2)
		   d $zu(9,"","Warning: "_systemid_" is taking over as the primary but we failed to clear the nofailover state. Error = /"_rc_"/",1 /* broadcast and log message*/,1  /* Warning */)
	   }
	}
	s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
	s status=""
	for id=1:1:systemcnt {
	   s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
       if info'="" {
	      s name=$lg(info,1)
          s rc=$$GetStatus^MIRRORCTL(mirname,id)
          s status=$LG(rc)  
	      if (status="PRIMARY") || (status="HUNG") {
		      quit
	      }
       }
	}
	s origstatus=status
	if (status="HUNG" || (status="PRIMARY")) {
	   d $zu(9,"","DesignatePrimary forcing down current primary """_name_""" (status = """_status_""")",0,0  /* Informational message */)
	   s status=$$ForceNodeDown^MIRRORCTL(mirname,id)
	   s waittime=15
	   do {
		  h 1
	      s rc=$$GetStatus^MIRRORCTL(mirname,id)
          s status=$LG(rc)  ; PRIMARY/UP/DOWN/HUNG/TIMEOUT/ERR
          s waittime=waittime-1
	   } while waittime && (status'="DOWN")
	   if (status'="DOWN") {
	      d $zu(9,"","Primary "_name_" failed to shut down (status="""_status_""")",1 /* broadcast and log message*/,1  /* Warning */)
	   } else {
		  d $zu(9,"","Primary "_name_" killed",0,0  /* Informational message */)
	   }
	   ;should trigger a takeover by this node now.
    }
    if (origstatus'="PRIMARY") {
	   d $zu(9,"","DesignatePrimary marking this node as the primary",0,0  /* Informational message */)
       do post(mirname,0,0,"ForcePrimary")
    }
	;
	; We should see this node become the primary but it will take
	; at least 30 seconds, probaby 60, because it has to time out
	; once or twice while starting up (eg. assuming the other node can't
	; be reached).
	s waittime=70
	do {
	   h 1
	   s info=$SYSTEM.Mirror.GetInfo()
       s waittime=waittime-1
	} while waittime && (info'[",PRIMARY,")
	if info[",PRIMARY," {
	   quit $LB(1)  ;succeeded
	}
	; Maybe we should post a forceprimary message here and
	; wait again?
	quit $LB(0,"Failed to become the primary - reason unknown")
err ;
	s $zt=""
	quit $LB(0,"Caught error: /"_$ZE_"/")	
}
BecomeBackup(mirname,id) {
	/* Invoked when a node wants to try and become a backup mirror
	   member. Most of the work is done after we job off ^Backup
	   but we do some prelimary checking here. */
	s $zt="err"
	s status=$SYSTEM.Mirror.GetInfo()
	if (status["BACKUP") || (status["PRIMARY") {
	   ; this node shouldn't be either a primary or a backup at this
	   ; point unless this is an async member
	   if (status'["SHADOW") {
		   d $zu(9,"","BecomeBackup: Member is already in 'Primary' or 'Backup' state.",1 /* broadcast and log message*/,1  /* Warning */)
		   do AddRetryEntry(mirname,"(""(rc) { s rc=($SYSTEM.Mirror.IsPrimary()||$SYSTEM.Mirror.IsBackup()) }"", .rc)","Restart")
	      quit 
	   }
	}
	if '$$CheckJournalingStatus(mirname) {
      d $zu(9,"","Journaling must be started before this "_$S(status["SHADOW":"DR",1:"failover")_" member will connect to the primary",1 /* broadcast and log message*/,2  /* Severe error */)
      do AddRetryEntry(mirname,"(""(rc) { s rc=$$CheckJournalingStatus^MIRRORMGR("""""_mirname_""""") }"", .rc)","Restart")
      quit
	}
	if +$SYSTEM.Mirror.GetInfo(5)'=0 {
		if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","BecomeBackup: Found data channel already exists - ignoring request")
		quit
	}
	if $SYSTEM.Mirror.GetStatus(mirname)="WAITING" {
	    do $SYSTEM.Mirror.SetStatus("TRANSITION",mirname)
	}
	; this is here rather than in Backup because it is hard avoid the code which
	; kicks in when the data channel fails if we detect this in Backup 	   
	s lastjrncnt=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
	if +lastjrncnt=-1 {
	   d $zu(9,"","BecomeBackup: GetLastJournalFilename failed, data channel not started",1 /* broadcast and log message*/,2  /* Severe error */)
	   quit
	}
	s file=$P(lastjrncnt,",",2)  ;might be null if lastjrncnt=0
	s rc=$ZU(78,22,file,24)
	if +rc,+$P(rc,",",2) {
		d $zu(9,"","Decompressing "_file_" before starting data channel job",0,0  /* Informational message */)
		s rc=$$decompressone^JRNZIP(file)
		if '+$LG(rc) {
			d $zu(9,"","Error decompressing last journal file ("_$LG(rc,2)_")",1 /* broadcast and log message*/,2  /* Severe error */)
			do AddRetryEntry(mirname,"(""(rc) { s rc=$$RetryDecompressJournalFile("""""_mirname_""""","""""_file_""""") }"", .rc)","Restart","Failed to decompress: "_file)
	        quit
	    }
	}
	s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
	s mtype=+$LG(info,8)
	if status[",SHADOW" {
       d $zu(9,"","("_mirname_") Becoming an async mirror member",0,0  /* Informational message */)
	} else {
       d $zu(9,"","("_mirname_") Becoming a backup mirror member",0,0  /* Informational message */)
	   if ($system.License.NoMirror()) {					/* RFD2026 */
	      d $zu(9,"","Failed to become backup mirror member, license does not allow Mirroring.",1 /* broadcast and log message*/,2  /* Severe error */)
	      do AddRetryEntry(mirname,"(""(rc) { s rc=('$system.License.NoMirror()) }"", .rc)","Restart")
	      quit
	   }
	}
	if mtype=0 {
	   if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","BecomeBackup: Set member #"_id_" role to "_"PRIMARY")
	   s ^MIRROR(mirname,"Status","Member",id,"Role")="PRIMARY"
	} else {
	   d $zu(9,"","Failed to become backup mirror member, connecting to bad member type = "_mtype,1 /* broadcast and log message*/,2  /* Severe error */)
	   quit
	}
	do ClearRetryList(mirname)  ;if there's a retry list, reset it now
	if $d(^SYS("FirstMirrorStartSinceInstall"))&&(mtype=0) {
	   do updateMirrorVersion($G(^SYS("MirrorVersion")))
	}
	do ResolveDBRollbackState(mirname)
	do $SYSTEM.Mirror.LastFileValidFlag(0)
	do $SYSTEM.Mirror.InitBackup()
	s ^MIRROR(mirname,"Role")="BACKUP"
	do AddMonitorEntry(mirname,"(""(rc) { s rc=$$MonitorArbiterConnection^MIRRORCOMM("""""_mirname_""""") }"", .rc)")
	do AddMonitorEntry(mirname,"(""(rc) { s rc=$$MonitorJournalLogSize("""""_mirname_""""") }"", .rc)")
	k ^||DejournalMonitor(mirname)
	s guid=$SYSTEM.Util.CreateGUID()
	s ^MIRROR(mirname,"DejournalMonitorGUID")=guid
	s miridx=$SYSTEM.Mirror.MirrorNameToIndex(mirname,0)+1
    do AddMonitorEntry(mirname,"(""(rc) { s rc=$$DejournalMonitor^MIRRORMGR("""""_mirname_""""","""""_miridx_""""","""""_guid_""""") }"", .rc)")
	job Backup^MIRRORCOMM(mirname,"",id,0,$G(^MIRROR(mirname,"MgrJobID"))):(:2):10  ;pass "" for io so it establishs a connection
	if '$T {
	   d $zu(9,"","MIRRORSVR failed to job backup client",1 /* broadcast and log message*/,2  /* Severe error */)
	   ; Not sure what to do here for AddRetryEntry(). I don't think we want to
	   ; retry jobbing the backup routine, nor am I sure we just want to post
	   ; a backup retry so we come here over and over...
	   do AddMonitorEntry(mirname,"(""(rc) { s rc=$$RestartBackup^MIRRORMGR("""""_mirname_""""","""""_id_""""","""""_$G(^MIRROR(mirname,"MgrJobID"))_""""") }"", .rc)")
	   s ^MIRROR(mirname,"StartBackupDmnFailed")=1
	} else {
		k ^MIRROR(mirname,"StartBackupDmnFailed")
		s (^||MIRROR(mirname,"BackupClient"),^MIRROR(mirname,"BackupClient"))=$LB($ZC,$zu(67,30,$ZC))
	   if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","Backup client started ("_$ZC_")")
	}
	q
err ;
	s $zt=""
	d $zu(9,"","Unexpected error in BecomeBackup: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	d BACK^%ETN
	q
}
BecomePrimary(mirname,forceBecomePrimary,wasBackup) {
	/* BecomePrimary() is called when this node needs to become the
	   primary. This could be at startup when we can't find another
	   primary in the mirror or it could be after $SYSTEM.Mirror.Client()
	   exited and this node (formerly a backup) has decided it should
	   become the new primary. 
	   If something goes wrong in the process of becoming the primary
	   we try to recover by aborting the process and returning to an
	   "idle" mirror member state. If this fails (we can't switch back to
	   a normal journal file) we have to shut down the system.
	   Should be called with the DECISION state (ModifyDecisionState(1))
	   Set. Exits with the DECISION state clear regardless of whether we
	   successfully become the primary. If we do succeed though we were careful
	   not to clear the DECISION state until AFTER we set the PRIMARY state.
	   Idealy when something goes wrong we should signal the other mirror
	   member that it should become the primary if it can. Currently we don't 
	   do this.
	   Return values
	     0 - exit routine, something went wrong
	     1 - continue running. If we're the primary, ^MIRROR("role") is
	          now set to $$$Primary
	    -1 - This node is not the Designate Primary node.
	*/
	; We need to pass the last journal file into PrimaryStartupComplete() so
	; it can figure out which mirrored db's are up to date enough to become
	; part of the active mirror.
	s $zt="err"
	s blkuser=0  ; logins not blocked yet
	s vipacquired=0 ;flag to drop vip if we abort
	s info=$SYSTEM.Mirror.GetInfo()
	if info["BACKUP" {
		; If we're a backup that means we're connected to the primary
		; so this is a problem.
		d $zu(9,"","Backup node needs to reset before becoming primary member",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	s DemotingFlag=0
	try {
		s DemotingFlag=$SYSTEM.Mirror.DemotingFlag()
	} catch {}
	if DemotingFlag {
		d $zu(9,"","BecomePrimary: Demoting in progress, cannot become primary.",1 /* broadcast and log message*/,1  /* Warning */)
		do AddRetryEntry(mirname,"(""(rc) { s rc='$SYSTEM.Mirror.DemotingFlag() }"", .rc)","Restart")
		quit 0
	}
    do $SYSTEM.Mirror.SetStatus("TRANSITION")
	do ClearRetryList(mirname)  ;if there's a retry list, reset it now
	do AddMonitorEntry(mirname,"(""(rc) { s rc=$$MonitorJournalLogSize("""""_mirname_""""") }"", .rc)")
	s ok=$$CheckDefinedPrimary(0)  ;0 = Clear definedPrimary setting if its us
	if ok'=1 {
		do AddRetryEntry(mirname,"(""(rc) { s x=$$ReCheckDefinedPrimary("""""_mirname_""""") s rc=(x=1) }"", .rc)","Restart","Failed to locate current primary")
		quit ok  ;0 or -1 depending on what went wrong
	}
	if '$SYSTEM.Mirror.LastFileValidFlag() {
		if forceBecomePrimary {
			d $zu(9,"","BecomePrimary continuing due to force flag when LastFileValid is clear",0,0  /* Informational message */)
		} else {
			d $zu(9,"","BecomePrimary aborted - Other failover member may have created a new journal file",0,0  /* Informational message */)
			; Since lastfilevalid is clear we need to talk with the other node so ensure
			; activebackupflag is clear as well.
			do $SYSTEM.Mirror.ActiveBackupFlag(0)
			; The following will cause us to return to restart and activebackupflag 
			; is clear so we will contact the other system to find the last jrnfile
			do AddRetryEntry(mirname,"(""(rc) { s rc=1 }"", .rc)","Restart")
			quit 0
		}
	}
		s Ok2Continue=$$RunZMIRROR(1)
		if 'Ok2Continue {
			d $zu(9,"","("_mirname_") CanNodeStartToBecomePrimary^ZMIRROR returned ""NO"" - Aborting BecomePrimary and Waiting",0,0  /* Informational message */)
			do AddRetryEntry(mirname,"(""(rc) { s rc=$$RecheckCanNodeStartToBecomePrimary("""""_mirname_""""") }"", .rc)","Restart","CanNodeStartToBecomePrimary aborted process of becoming the primary failover member")
			quit 1
		}
	; Lookup VIP address to see if there is one
	s cls=##class(Config.Mirrors).Open(mirname)
	if '$IsObject(cls) {
		d $zu(9,"","BecomePrimary aborted - Failed to open Config.Mirrors("_mirname_") to read virtual IP information",1 /* broadcast and log message*/,1  /* Warning */)	
		do AddRetryEntry(mirname,"(""(rc) { s x=$$ReCheckDefinedPrimary("""""_mirname_""""") s rc=(x=1) }"", .rc)","Restart","Failed to open [Mirrors] configuration section")
	    quit 0
	}
	s vipAddr=cls.VirtualAddress  ;"" if there isn't one
	s cls=""
	;
	; We're trying to become the primary so dejrnchkpnt/transroll, the end of our
	; last journal file is valid and we've finished ApplyJournalFiles.
	;
	s lastjrninfo=$$GetDejrnChkpntInfo(mirname)  ;returns cnt^pos
    if '+lastjrninfo {
	    s lastjrnfilecnt=0
	    s lastjrnend=0  ;no journal files yet	
	    s transrollindex=0
	    s transrolljrnfilecnt=0   
    } else {
	    s lastjrnend=+$P(lastjrninfo,"^",2)
	    s lastjrnfilecnt=+lastjrninfo
	    ; 
	    ; If any of the db's which have been caught up to the dejrnchkpnt
	    ; have a lastfilecntrestored set then we need to back up the
	    ; transaction rollback point to the earliest file
		k dblist
		s rc=$$GetMirroredDBList^MIRRORCOMM(mirname,.dblist,1)
		if '$LG(rc) {
		   d $zu(9,"","BecomePrimary: Failed to read list of mirrored databases, GetMirrorDBList returned: "_$LG(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
		   quit 0
	    }
	    s minxjrnfilecnt=lastjrnfilecnt
		s index=""
		for {
		   s index=$o(dblist(index),1,info)
		   q:index=""
	   	   s dbmirname=$P(info,"^",8)
	   	   s dbjrncnt=$P(info,"^",3)
	   	   if (dbmirname=mirname) && (dbjrncnt=lastjrnfilecnt) {
		      s dblastfilecnt=+$P(info,"^",11)
		      if dblastfilecnt && (dblastfilecnt < minxjrnfilecnt) {
		         s dbpath=$P(info,"^",1)
				 if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","Rollback point changed from "_minxjrnfilecnt_" to "_dblastfilecnt_" based on 1st restored file for "_dbpath)
		         s minxjrnfilecnt = dblastfilecnt
		      }
	   	   }
		}
		k dblist  ;clean up
		;
	    s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(minxjrnfilecnt,mirname)
	    if +rc<=0 {
		    d $zu(9,"","BecomePrimary failed to lookup file name for file #"_minxjrnfilecnt,1 /* broadcast and log message*/,1  /* Warning */)
		    ; can't ignore this error
			do AddRetryEntry(mirname,"(""(rc) { s x=$SYSTEM.Mirror.GetJournalFileByMjrncnt("_minxjrnfilecnt_","""""_mirname_""""") s rc=(x>0) }"", .rc)","Restart","Failed looking up next journal file to apply in the mirror journal log")
		    quit 0  ;failed
	    }
		s minxjrnfile=$P(rc,",",2)
		;
		s info=$zu(78,22,minxjrnfile,99)
		if '+info {
		   d $zu(9,"","Primary startup failed, failed to read header of "_minxjrnfile_" (file #"_minxjrnfilecnt_")",1 /* broadcast and log message*/,1  /* Warning */)
		   ; $$$JRNHDRALL(x) = $ZU(78,22,x,99)
		   do AddRetryEntry(mirname,"(""(rc) { s info=$zu(78,22,"""""_minxjrnfile_""""",99),rc=+info }"", .rc)","Restart","Failed to read header of next journal file to apply")
		   quit 0
		}
		s transrollindex=+$P(info,",",21+1)  ;+1 to skip status code
		s transrolljrnfilecnt=+$P(info,",",20+1)
	    if '+transrolljrnfilecnt {
		   ; if there's no tp restore point listed then we must not have had TP rollback
		   ; information when the file was created so if we scan back to the start of
		   ; this file, we should find all the open transactions, if there are any
		   ; 
		   d $zu(9,"","Journal file "_minxjrnfile_" is missing tp rollback information, using start of file",0,0  /* Informational message */)
		   s transrolljrnfilecnt=minxjrnfilecnt
		   s transrollindex=65536*2  ; set position to 1st real record in the file
	    }
	    if transrolljrnfilecnt'=minxjrnfilecnt {
	       s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(transrolljrnfilecnt,mirname)
	       if +rc<=0 {
		      d $zu(9,"","BecomePrimary failed to lookup file name for file #"_transrolljrnfilecnt_" for rollback",1 /* broadcast and log message*/,1  /* Warning */)
			  do AddRetryEntry(mirname,"(""(rc) { s x=$SYSTEM.Mirror.GetJournalFileByMjrncnt("_transrolljrnfilecnt_","""""_mirname_""""") s rc=(x>0) }"", .rc)","Restart","Failed to locate journal file for transaction rollback in the mirror journal log")
		      quit 0  ;failed
	       }
		   s minxjrnfile=$P(rc,",",2)
 		   ;
		   s info=$zu(78,22,minxjrnfile,99)
		   if '+info {
		      d $zu(9,"","Primary startup failed, failed to read header of "_minxjrnfile_" (file #"_transrolljrnfilecnt_") for rollback",1 /* broadcast and log message*/,1  /* Warning */)
		      ; $$$JRNHDRALL(x) = $ZU(78,22,x,99)
		      do AddRetryEntry(mirname,"(""(rc) { s info=$zu(78,22,"""""_minxjrnfile_""""",99),rc=+info }"", .rc)","Restart","Failed to read the header of journal file for transaction rollback")
		      quit 0
		   }
	    }
    }
    if '$$CheckRequiredDatabases^MIRRORCOMM(1,lastjrnfilecnt,lastjrnend) {
		if 'forceBecomePrimary {
			; we're missing one or more required database or one or more
			; of the required mirrored databases is not active. 
			; If we can become a backup we'll do that otherwise we retry 
			; to see if the issues with the required databases have been resolved.
			d $zu(9,"","Primary startup failed, one or more required databases are missing",1 /* broadcast and log message*/,1  /* Warning */)
	 	    do AddRetryEntry(mirname,"(""(rc) { s rc=$$RecheckRequiredDatabases("""""_mirname_""""","_lastjrnfilecnt_","_lastjrnend_") }"", .rc)","Restart","Cannot become primary because one or more required databases are missing")
		    quit 0
		}
		d $zu(9,"","ForceBecomePrimary set - ignoring required databases troubles",1 /* broadcast and log message*/,1  /* Warning */)
	}
	if $SYSTEM.Mirror.ActiveBackupFlag()=0 {
		s info=$G(^SYS("MIRRORSET",mirname,"Member",1))
		if info'="" {
			s mtype=+$LG(info,8)
			if mtype'=0 {
				d $zu(9,"","ClearLastFileValid skipped, member #1 (type "_mtype_") is not a failover member",1 /* broadcast and log message*/,1  /* Warning */)
			} else {
				s name=$lg(info,1)
				s rc=$$ClearLastFileValidFlag^MIRRORCTL(mirname,1,forceBecomePrimary)
				; Just ignore $LG(rc)="UNKNCMD", its not an error
				if $LG(rc)="ERR" {
					; We can't continue until we get an OK back from this routine
					d $zu(9,"","Aboting BecomePrimary: ClearLastFileValid("""_mirname_""") for """_name_""" failed ("_$LG(rc,2)_")",1 /* broadcast and log message*/,1  /* Warning */)
					do AddRetryEntry(mirname,"(""(rc) { s rc=$$RetryClearLastFileValid("""""_mirname_""""") }"", .rc)","Restart","Error signaling to other failover member that its does not have the last journal file")
					quit 0
				}
			}
		}
	}
    ;
    ;From here down if we fail at some step we don't create a Retry list
    ; entry because there isn't any one thing that can fix the problem.
    ; These are fairly serious issues and we don't really expect to be 
    ; failing here (other than perhaps if the customer's code tells us not
    ; to become the primary) so if we do fail we'll return to our idle loop
    ; where we'll become a backup if we see the primary start up or we'll retry
    ; beoming the primary if the user tells us to.
    ;
    if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","Primary starting up with last journal file #"_lastjrnfilecnt_" and TP rollback index "_transrollindex_" in file #"_transrolljrnfilecnt)
    s blkuser=1  ;indicate we've suspended logins
    Lock +^SYS("UpdateMblkuserInSTU")
    s origmblkuser=$V($ZU(40,2,93),-2,1)
    v $ZU(40,2,93):-2:1:3   ;set mblkuser=3
    Lock -^SYS("UpdateMblkuserInSTU")
	if vipAddr="" {    
	   if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","info: Primary startup, no vip address specified")
	} else {
	   s ok=$$releaseVIPonAllMembers(mirname)
       if '$lg(ok) {
	 	   d $zu(9,"","Virtual IP address could not be released on failover members: "_$p($lg(ok),",",2,999),0,0  /* Informational message */)
	 	  ;Try to add it anyway 
       }
       s ok=$$AddVirtualAddress(mirname)
       if '$lg(ok) {
	      d $zu(9,"","AddVirtualAddress failed, cannot become primary: "_$p($lg(ok),",",2,999),1 /* broadcast and log message*/,2  /* Severe error */)
	      do AddRetryEntry(mirname,"(""(rc) { hang 5 s rc=1 }"", .rc)","Restart","Failed to establish virtual network address")
	      do RestoreMBlkuser(origmblkuser)
	      quit 0
       }
       s vipacquired=1
	}
	k ^MIRROR(mirname,"PendingNewMember"),^MIRROR(mirname,"PendingDNUpdates")
	s rc=$SYSTEM.Mirror.PrimaryInit() 
	; Now that the primary state is set, clear the decision state
	do $SYSTEM.Mirror.ModifyDecidingState(0)
	if 'rc {  ;uh oh, init primary failed
	   d $zu(9,"","Primary initialization failed",1 /* broadcast and log message*/,2  /* Severe error */)
	   ; Not sure what to do here. as hopefully we don't end up spinning,
	   ; calling this over and over. 
	   do AddRetryEntry(mirname,"(""(rc) { hang 5 s rc=1 }"", .rc)","Restart","Primary initialization failed")
	   if (vipacquired) {
	      s rc=$$DeleteVirtualAddress(mirname)
	      s vipacquired=0
	   }
	   do RestoreMBlkuser(origmblkuser)
	   quit 0
	}
	do $SYSTEM.Mirror.LastFileValidFlag(0) ; we have a new file now
	;
	; If we abort after this point we need to re-initialize the dejournal memory
	; as SYSTEM.Mirror.PrimaryInit() releated it.
	;
	s debugflags=$G(^SYS("MIRRORSET","Debug","ecpflags"))
	s debugflags=+$ZH("0"_debugflags)
	if debugflags {
	   s curflags=$SYSTEM.ECP.Debug()
	   ; leave the current bits set and or in the bits we want
	   ; on during ecprecovery
	   s newflags=$zb(+curflags,debugflags,7) ; 7=inclusive or
	   do $SYSTEM.ECP.Debug(newflags)
	}
    s ok=$$Mirror^ECPRecovery(mirname,lastjrnfilecnt,transrolljrnfilecnt,transrollindex) 
    if debugflags do $SYSTEM.ECP.Debug(curflags)  ;reset 
    if 'ok {
	    d $zu(9,"","ECPRecovery failed, cannot become primary - Waiting to become the backup",1 /* broadcast and log message*/,2  /* Severe error */)
		do AddRetryEntry(mirname,"(""(rc) { s rc=$$CheckPrimaryIsUp("""""_mirname_""""") }"", .rc)","Restart","ECPRecovery failed, waiting to become the backup")  ;JO2401
	    goto failed
    }
    ;Transaction rollback succeeded so go through and clear the rollback
    ; point for all databases which are current as of the current last
    ; journal file.
    do TransactionRollbackComplete(mirname)
	;
    ; Before we complete the transition to become the active
    ; primary, call CheckBecomePrimaryOK^ZMIRROR in case the
    ; user has somethings they want to check as well. If this
    ; returns 0 we'll abort the process of taking over as the primary.
    ;
    ; It is ok if ^ZMIRROR doesn't exist or if the tag in ^ZMIRROR is
    ; missing but any other error is treated as a failure.
	s ok=$$RunZMIRROR(2)
    if 'ok {
	   d $zu(9,"","CheckBecomePrimaryOK^ZMIRROR() returned 0, aborting primary startup",1 /* broadcast and log message*/,2  /* Severe error */)
       do AddRetryEntry(mirname,"(""(rc) { s rc=$$RetryCheckBecomePrimaryOK("""""_mirname_""""") }"", .rc)","Restart","CheckBecomePrimaryOk indicated instance should not become the primary")
 	   goto failed
    }
	if 'wasBackup,'lastjrnfilecnt {
		s lastjrninfo=$$GetDejrnChkpntInfo(mirname,1)  ;returns cnt^pos
		if +lastjrninfo {
			s lastjrnend=+$P(lastjrninfo,"^",2)
			s lastjrnfilecnt=+lastjrninfo
		}
	}
	if '$SYSTEM.Mirror.PrimaryStartupComplete(lastjrnfilecnt,lastjrnend) { 
	    d $zu(9,"","Failed to complete primary startup process",1 /* broadcast and log message*/,2  /* Severe error */)
        ;probably need to drop ecp sessions or something
        do AddRetryEntry(mirname,"(""(rc) { s rc=$$CheckOtherNodeIsReachable("""""_mirname_""""") }"", .rc)","Restart","PrimaryStartupComplete failed")
        goto failed
	}
	; Mirrored db's are now read/write - see if we have post install
	; upgrade tasks before we allow ECP
	if $G(^SYS("FirstMirrorStartSinceInstall")) {
		if '$$RunMirrorUpgradeProcedure() {
			d $zu(9,"","Post-install Mirror upgrade procedure failed - The trouble must be resolved before restarting this node to become the primary",1 /* broadcast and log message*/,2  /* Severe error */)
			; If the other node becomes the primary we'll try to become
			; the backup but otherwise we need the user to fix some problem
			; and tell us to retry becoming the primary when they 
			; resolve the trouble
		    do AddRetryEntry(mirname,"(""(rc) { s rc=$$CheckPrimaryIsUp("""""_mirname_""""") }"", .rc)","Restart","Mirror upgrade procedure failed")
			goto failed
		}
	    k ^SYS("FirstMirrorStartSinceInstall")
	}
	; Finish the final sync point of ECPRecovery to transition the
	; connections to a normal state and let them resume processing.
	; This will set mserver_lockphase to 0 to complete recovery.
	do MirrorStartupComplete^ECPRecovery()
	do RestoreMBlkuser(origmblkuser)
    s blkuser=0
    do $SYSTEM.Mirror.ActiveBackupFlag(0) ; in case this is still set @ this poi
	do AddMonitorEntry(mirname,"(""(rc) { s rc=$$MonitorArbiterConnection^MIRRORCOMM("""""_mirname_""""") }"", .rc)")
	; 
	; If we're an ensemble system, start the productions which are
	; configured to be run @ startup. This is a no-op if we're not
	; an ensemble system.
	do Ensemble^STU()
	;
	d ##Class(DataMove.Data).STURestart(1)
	do BecomePrimary^%SYS.SHARDSRV() 
    ; Now that we've completed the transition to become the active
    ; primary, call NotifyBecomePrimary^ZMIRROR in case the site has
    ; "startup" code they want run.
    d RunZMIRROR(3)
	do ZMRelease^STU()
	if wasBackup {
		d $zu(9,"","Becoming primary mirror server",1 /* broadcast and log message*/,2  /* Severe error */)
	} else {
		d $zu(9,"","Becoming primary mirror server",1 /* broadcast and log message*/,1  /* Warning */)
	}
    s ^MIRROR(mirname,"Role")="PRIMARY"
    s $p(^SYS("MIRRORTIME",mirname),"^",2)=$ZTS_"|"_forceBecomePrimary
	s ^||FirstVIPMonitor=1
	k ^MIRROR(mirname,"PromotedNotQueried"),^MIRROR(mirname,"PromotedQueried")
	k ^MIRROR(mirname,"PromotedYetPrimary")
    do AddMonitorEntry(mirname,"(""(rc) { s rc=$$MonitorVIPAddress("""""_mirname_""""") }"", .rc)")
	quit 1  ;caller will check ^MIRROR("Role")
err ;
	s $zt=""
	d $zu(9,"","Unexpected error in BecomePrimary: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	d BACK^%ETN
failed ;    
    if vipacquired {
	   ; drop vip before allowing logins
	   s rc=$$DeleteVirtualAddress(mirname)
	   s vipacquired=0
    }
	do MirrorStartupAbort^ECPRecovery()
    if blkuser,$d(origmblkuser) {
	    do RestoreMBlkuser(origmblkuser)
	    s blkuser=0
    }
	if '$SYSTEM.Mirror.PrimaryStartupAbort() {
	   d $zu(9,"","PrimaryAbort failed, shutting down instance",1 /* broadcast and log message*/,3  /* Fatal */)
	   l  ; release all locks
	   do INT^SHUTDOWN
	   halt
	}
	if $SYSTEM.Mirror.ActiveBackupFlag() {
		s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
		if +rc>0 {
			if $$getMirJrnEnd($P(rc,",",2))>0 {
				s ^MIRROR(mirname,"lastvalidjrnfile")=(+rc)_"^"_$P(rc,",",2)
			} else {
				d $zu(9,"","BecomePrimary abort: last journal file "_$P(rc,",",2)_"("_(+rc)_") did not have valid end",1 /* broadcast and log message*/,1  /* Warning */)
			}
		} else {
			d $zu(9,"","("_mirname_") BecomePrimary abort: failed to look up last valid file in journal log",1 /* broadcast and log message*/,1  /* Warning */)
		}
		s rc=$$SetLastFileValidFlag(mirname)
		if '$SYSTEM.Mirror.LastFileValidFlag() {
			d $zu(9,"","BecomePrimary failed to mark last file valid while resetting - Must contact other node to become primary",1 /* broadcast and log message*/,1  /* Warning */)
			do $SYSTEM.Mirror.ActiveBackupFlag(0)
		}
	}
	s miridx=$SYSTEM.Mirror.MirrorNameToIndex(mirname,0)+1
	if (miridx<1) {  ;<1 because of the +1 above.
	   d $zu(9,"","BecomePrimary failed to locate mirror index for "_mirname_" to reinit dejournaling memory - Aborting",1 /* broadcast and log message*/,3  /* Fatal */)
	   halt
	} else {
       if '$$InitDejournal(miridx,mirname) {
	      d $zu(9,"","BecomePrimary failed to re-initialize dejournal memory - Aborting",1 /* broadcast and log message*/,3  /* Fatal */)
	      ; maybe we should just retry here instead of halting?
	      halt
	   }
	}
	quit 0
}
RestoreMBlkuser(origmblkuser) {
    Lock +^SYS("UpdateMblkuserInSTU")
    if $d(^SYS("MblkuserSetInSTU")) {
	    v $ZU(40,2,93):-2:1:origmblkuser   ;set with original value
    } else {
	    v $ZU(40,2,93):-2:1:0   ;clear it.
 	    i ($zversion(1)=2) d $zu(149)
    }
    Lock -^SYS("UpdateMblkuserInSTU")
}
GetDejrnChkpntInfo(mirname,Type=2) PUBLIC {
	/* Returns mirjrnfilecnt^jrnpos of the place our mirrored db's are
	   current as of or 0^<undefined> if we don't have any journal files
	   and/or mirrored dbs yet */
    s lastjrninfo=$G(^MIRROR(mirname,"dejrnchkpnt"))  ;cnt^pos
	if '+lastjrninfo {
		s rc=$$GetMirrorDejournalInformation(mirname,Type)
		s lastjrninfo=$G(^MIRROR(mirname,"dejrnchkpnt"))  ;cnt^pos
	}
	quit lastjrninfo
}
RunMirrorUpgradeProcedure() {
	/* This is the 1st time this system has become the primary since
	   the cache upgrade. Now that the mirrored db's are writeable 
	   figure out whether we need to run the upgrade procedure in them. */
	s $zt="err"
	s MirrorVersion=+$G(^SYS("MirrorVersion"))
	s SYSVersion=+$G(^SYS("SystemDBVersion"))
	if 'SYSVersion {
		quit 1  ;we need the version for this to work
	}
	if MirrorVersion>=SYSVersion {
		quit 1  ;nothing to do, already up to date
	}
	if $$updateMirrorVersion(MirrorVersion) {
	   s MirrorVersion=$G(^SYS("MirrorVersion"))
   	   if MirrorVersion>=SYSVersion {
          quit 1  ;nothing to do, already up to date
   	   }
   	}
   	d $zu(9,"","Running upgrade procedure to "_MirrorVersion_" for mirrored databases",0,0  /* Informational message */)
   	; Ok, the Mirror Version is less than the last version
   	; that was installed and we're the primary so we should
   	; run the database specific part of the install procedure.
	do UpdateMirrorDatabases^INSTALL()
	s ^SYS("MirrorVersion")=SYSVersion
	quit 1  ;succeeded
err	;
	s $ZT=""
	d BACK^%ETN
	d $zu(9,"","Unexpected error "_$ZE_" checking for pending mirror upgrade work",1 /* broadcast and log message*/,1  /* Warning */)
	quit 0  ;failed
}
updateMirrorVersion(currentVersion) {
	/* This routine fetches the value of ^SYS("MirrorVersion")
	   from the other failover member and if the value is greater than
	   the passed version, it updates the local copy of
	   ^SYS("MirrorVersion") with the value from the other node. If
	   there is some trouble, the current value is left unchanged.
	   Returns: 1 - version fetched and updated from other node
	            0 - version not updated, not needed or we failed
	*/
	s $ZT="err"
	; retrieve the value of ^SYS("MirrorVersion") 
	; from the other mirror member, if there is one,
	; to see if its later than the passed version
    s mirname=$p($G(^SYS("MIRRORSET")),"^",2)
    if mirname="" {
	    d $zu(9,"","updateMirrorVersion - mirname not defined",1 /* broadcast and log message*/,1  /* Warning */)
	    quit 0
    }
 	s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
	if (systemcnt=0) {
		quit 0   ;no other member - we're done 
	}
	s info=$G(^SYS("MIRRORSET",mirname,"Member",1))
    if info="" {
	   d $zu(9,"","Cannot update MirrorVersion from "_name_" - Missing information for mirror member #1",1 /* broadcast and log message*/,1  /* Warning */)
	   quit 0 
    }
    s name=$lg(info,1)
   ; Retrieve MirrorVersion from the other node
	s rc=$$GetMirrorVersion^MIRRORCTL(mirname,1)
	s status=$LG(rc)
	if status'="OK" {
	   d $zu(9,"","Error retrieving MirrorVersion from "_name_". Assuming local update is not required ("_$LG(rc,2)_")",1 /* broadcast and log message*/,1  /* Warning */)
	   quit 0
	}
    s ver=$LG(rc,2)
    if ver>currentVersion {
	   if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","MirrorVersion "_ver_" from "_name_" is higher than local version ("_currentVersion_")")
       s ^SYS("MirrorVersion")=ver
       quit 1
    }
	quit 0 ; our version is >= their version - no update needed		    
err ;
	s $ZT=""
	d BACK^%ETN
	d $zu(9,"","Unexpected error "_$ze_" in updateMirrorVersion^"_$ZN,1 /* broadcast and log message*/,1  /* Warning */)
	quit 0
}
CheckDefinedPrimary(TestOnly) PUBLIC {	
	if ('TestOnly) || (($zb(+$SYSTEM.Mirror.DebugFlags(),2,1))) {
		s log=1
	} else {
		s log=0
	}
 	s mirname=##class(Config.Mirrors).GetMirrorName()
 	if mirname="" {
	 	if (log) {
			d $zu(9,"","Failed to locate current mirror name in [Mirrors] section",1 /* broadcast and log message*/,1  /* Warning */)
	 	}
		quit 0
	}
	s cls=##class(Config.Mirrors).Open(mirname,,,.rc)
	if ('rc) {
		s definedPrimary=""
	} else {
		s definedPrimary=cls.DefinedPrimary
	}
	s cls=##class(Config.MirrorMember).Open(,,.rc)
    if ('rc) {
	    if (log) {
	       d $zu(9,"","CheckDefinedPrimary failed to open mirror member configuration",1 /* broadcast and log message*/,1  /* Warning */)
	    }
	    quit 0
    }
    s systemid=cls.SystemName
    s cls=""
	if definedPrimary'="" {
	   if definedPrimary'=systemid {
		   if (log) {
		      d $zu(9,"","Primary is configured to be "_definedPrimary_" - Waiting for primary to start",0,0  /* Informational message */)
		   }
		   quit -1
	   }
	   ; TestOnly is set when we're called from the retry code after some
	   ; kind of failure. We don't adjust the NoFailover flag in that case
	   ; because we'll be called again when the node actually tries to become
	   ; the primary.
	   if 'TestOnly {
	      s rc=$$ClearMirrorNoFailover^MIRRORCTL("Primary")
	      if $LG(rc)="ERR" {
		     s rc=$LG(rc,2)
		     d $zu(9,"","Error clearing no failover state: "_rc,1 /* broadcast and log message*/,1  /* Warning */)
	      }
	   }
	}
	quit 1  ;success
}
TrackReconnections(mirname,id,history) PUBLIC {
	/* 'history' is the ConnectHistory passed by reference
	   here we make sure that we're not trying to reconnect
	   too often by keeping track of the last 10 reconnections.
	   If the last reconnection was >5 minutes old we continue
	   without checking anything else. 
	   history = <cnt of # of entries>
	   history(n...n+10) (n>0) = last 10 time deltas between 
	            reconnections
	   history(0,"last") = $ztimestamp of last attempt
	   history(0,"sum") = sum(history(n)...history(n+10))
	   (note if history (cnt) is < 10, then we only have that
# of entries. Once cnt goes over 10, we start removing the
	    old entries so we retain the last 10).
	   Returns: 0 = abort connection to primary
	            1 = continue & try to connect to primary
	                (currently always returns 1)
	   There are 3 configuration entries in ^MIRROR which affect
	   how we behave. These are not usually defined but they are
	   present in case we need them to deal with problems that arise.
	   ^MIRROR(mirname,"reconnect","disable")=0/1
	   ^MIRROR(mirname,"reconnect","mininterval") = min # of seconds we permit
	               between reconnections. If a backup tries to connect
	               more often, we delay it. Defaults to 60 when missing.
	   ^MIRROR(mirname,"reconnect","largedelay") = If we've reconnected 10 times in
	               a row and our average connection time is less than
	               minreconnect, this is an added delay. Defaults to 
	               5 minutes.
	   ^MIRROR(mirname,"reconnect","fixeddelay") = # of seconds which every
	          reconnection attempt waits. This overrides "minreconnect"/"largedelay"
	*/	
	s curtime=$ztimestamp
	s status=$SYSTEM.Mirror.GetStatus(mirname)
	if status="TRANSITION"||(status="SYNCHRONIZING") {
		/* We end up here when we failed to become a backup due to some
		   connection problem. Set the state to waiting rather than
		   transition in this case */
		do $SYSTEM.Mirror.SetStatus("WAITING",mirname)
		s ^MIRROR(mirname,"Role")=""
		s role=""
	}
	if '$D(history(0)) {
       s history(0,"last")=curtime
	   s history(0,"sum")=0
	   quit 1  ;1st connection attempt
    }
    if $G(^MIRROR(mirname,"reconnect","disable"))=1 {
	    d $zu(9,"","Reconnections disabled for "_mirname_" node #"_id,1 /* broadcast and log message*/,1  /* Warning */)
	    quit 0
    }
	s cnt=$I(history)
	s last=history(0,"last")
	s elapsed=$$TimeDiff(last,curtime)
	s history(0,"last")=curtime
	s history(0,"sum")=history(0,"sum")+elapsed
	s history(cnt)=elapsed
	if cnt>10 {
		s val=$G(history(cnt-10))
		if val="" {
			; shouldn't ever happen but if the debugger is
			; broken, it can so recalculate the sum of the values
			s val=0,sum=0
			s x=$O(history(0),1,val)
			for  quit:x=""  s sum=sum+val s x=$O(history(x),1,val)
			s val=0
			s history(0,"sum")=sum
		}
		s history(0,"sum")=history(0,"sum")-val
		kill history(cnt-10)  ;keep the latest 10 values
		s earliestcnt=cnt-9
	} else {
		s earliestcnt=1
	}
	if cnt>=1000000 {
		; cnt is becoming quite large, reshuffle the
		; array so we can make it small again. The only
		; point here is to keep cnt from getting to the
		; place where cnt+1=cnt. 1000000 is no where close
		; to that but its large enough that we won't do this
		; that often
		s x=$O(history(0))
		for i=1:1 {
			quit:x=""
			s history(i)=history(x)
			s next=$O(history(x))
			k history(x)
			s x=next
		}
		s history=10
		s cnt=10
		s earliestcnt=1
		s x=$I(history(0,"reshufflecnt"))
	}
	if elapsed>300 {
		; its been more than 5 minutes since we last
		; reconnected, its ok to try again now
		quit 1
	}
	s sum=history(0,"sum")
	if sum>3600 {
		; its been more than an hour since the oldest
		; reconnection we're tracking, its ok to try
		; again. Since sum is the total of the last 10
		; elapsed times, it represents the time since
		; the oldest reconnection attempt
		quit 1
	}
	s avg=sum/(cnt-earliestcnt+1)
	; Figure out whether we're reconnecting to fast
	s minreconnect=+$G(^MIRROR(mirname,"reconnect","mininterval"),60)  ;in seconds
	s longdelay=+$G(^MIRROR(mirname,"reconnect","longdelay"),300)  ;in seconds
	s fixeddelay=+$G(^MIRROR(mirname,"reconnect","fixeddelay"))
	;
	if fixeddelay {
		if $zb(+$SYSTEM.Mirror.DebugFlags(),4,1) do $zu(9,"","("_mirname_") Reconnection delay enabled - Waiting "_fixeddelay_" seconds")
		hang fixeddelay
	} elseif avg<minreconnect {
		s wait=minreconnect-avg
		s wait=+$FN(wait,"",2)  ;trim to 2 decimal places
		if '(cnt#10) {
			; every 10 cycles, wait an additional 5 minutes
			if $zb(+$SYSTEM.Mirror.DebugFlags(),4,1) do $zu(9,"","("_mirname_") Too many retries recently, adding "_longdelay_" seconds to wait time")
			s wait=wait+longdelay 
		}		
		if $zb(+$SYSTEM.Mirror.DebugFlags(),4,1) do $zu(9,"","("_mirname_") Average reconnect time ("_$FN(avg,"",2)_" sec) is too short. Waiting "_wait_" seconds")
		hang wait
		; Now reset the history entry to so that it doesn't
		; include the time we waited because we want to know
		; how long the connections are lasting
		s curtime=$ztimestamp
		s history(0,"last")=curtime
	}
	quit 1
}
TimeDiff(start,end) {
	; Returns the difference between two $H (or $ztimestamp) times in seconds
	s days=+end-start
	s sec=+$P(end,",",2)-$P(start,",",2)
	if 'days quit sec
	s oneday=60*60*24
	s sec=sec+(days*oneday)
	quit sec
}
CheckVersion(mirname) {
	; Verify that ^MIRROR is in the format we require (eg. handle any
	; upgrade issues required here). If it is too old, we return 0 and
	; startup is aborted. 
	s ^MIRROR("Version")=1
	quit 1
}
post(mirname,mgrpid,id,text) {
	do post^MIRRORCOMM(mirname,mgrpid,id,text)
}
isMirroredDb(dir) public {
 	s mirrorbit=+$ZU(40,8,28)
 	s info=$zu(49,dir)
 	if info<-1 quit 0  ; doesn't exist, isn't mirrored
 	s dbattrib=+$p(info,",",17)  ;even when not mounted, $ZU(49) data is returned
 	if $zb(+dbattrib,+mirrorbit,1) quit 1
 	quit 0
}
 ; Startup^MIRRORMGR(mirname) to startup a mirror set.
 ; mirname - mirror set name to be started, use null string to startup all
 ;           mirror sets. For failover nodes it will be the default mirror set.
 ; return - $$$OK - success
 ;          $$$ERROR(<reason code>) - failed
Startup(mirname="") PUBLIC {
   if '$SYSTEM.Security.Check("%Admin_Operate","USE") {
	   quit $$Error^%apiOBJ(2049)
   }
   s status=##class(Config.MirrorMember).CheckSecurity(.enabled)
   if '(''status) Quit status
   if 'enabled quit $$Error^%apiOBJ(2066)
   quit:$SYSTEM.Mirror.GetInfo()'["DEFINED"&&('$G(^SYS("MIRRORSET"))) $$Error^%apiOBJ(2050)
   if mirname'="" {
	   if ##class(SYS.Mirror).IsMirrorStarted(mirname) q $s($SYSTEM.Mirror.GetStatus(mirname)="CRASHED":$$Error^%apiOBJ(2191,mirname),1:$$Error^%apiOBJ(2106,mirname))
	   if ","_$P(^SYS("MIRRORSET"),"^",2)_","'[(","_mirname_",") q $$Error^%apiOBJ(2051,mirname)
	   if $ZU(66,"USR","MirrorServer^STU",5,0,0,mirname)=-1 {
		   q $$Error^%apiOBJ(2052,mirname)
	   }
	   q 1
   }
   if +$G(^SYS("MIRRORSET")) {
	   s mirrorsets=$P(^SYS("MIRRORSET"),"^",2),ok=1
	   for i=1:1:$l(mirrorsets,",") {
		   s mirname=$p(mirrorsets,",",i)
		   if mirname="" continue
		   if ##class(SYS.Mirror).IsMirrorStarted(mirname) continue
		   s ok=($ZU(66,"USR","MirrorServer^STU",5,0,0,mirname)'=-1)
		   if 'ok {
			   quit
		   }
	   }
	   if '($zversion(1)=3)&&('ok) q $$Error^%apiOBJ(2052,$p(mirrorsets,",",i))
	   quit 1
   }
   s mirname=##class(Config.Mirrors).GetMirrorName()
   if mirname="" q $$Error^%apiOBJ(2051,mirname)
   if ##class(SYS.Mirror).IsMirrorStarted(mirname) q $s($SYSTEM.Mirror.GetStatus(mirname)="CRASHED":$$Error^%apiOBJ(2191,mirname),1:$$Error^%apiOBJ(2106,mirname))
   if $ZU(66,"USR","MirrorServer^STU",5,0,0,"")=-1 {
	   q $$Error^%apiOBJ(2052,"")
   }
   q 1
}
 ; Shutdown^MIRRORMGR(timeout,mirname) to stop a mirror set.
 ; timeout - time to wait on the shutdown to be completed.
 ; mirname - mirror set name to be stopped, use null string to stop all
 ;           mirror sets. For failover nodes it will be the default mirror set.
 ; return -%Status
 ;         $$$OK - success
 ;         $$$ERROR(...) - Failed
 ;          0,reason : failed.
Shutdown(timeout,mirname="") PUBLIC {
	;Called from SHUTDOWN (or other places) when we want to shut down
	; the mirror system. 
   if '$SYSTEM.Security.Check("%Admin_Operate","USE") {
	   quit $$Error^%apiOBJ(2093)
   }
   s state=$SYSTEM.Mirror.GetInfo()
   if state[",NOTINIT," quit $$Error^%apiOBJ(2050)  ; not a mirror member
   s remain=0
   if $G(^SYS("MIRRORSET")) {
	   if mirname'="" {
		   if ","_$p(^SYS("MIRRORSET"),"^",2)_","'[(","_mirname_",") {
			   quit $$Error^%apiOBJ(2051,mirname)
		   }
		   if '##class(SYS.Mirror).IsMirrorStarted(mirname) q $$Error^%apiOBJ(2107,mirname)
		   s mgrpid=+$G(^MIRROR(mirname,"MgrJobID"))
		   ; we post on id #0 which is ourself. SHUTDOWN tells the mirror manager
		   ; this node is shutting down so it should not respond to any more
		   ; connections from other nodes (eg. if we're the primary, don't tell
		   ; a new node to become the backup).
		   if mgrpid do post(mirname,mgrpid,0,"SHUTDOWN:SUSPEND")
		   if state["BACKUP" {
			   s remain=$SYSTEM.Mirror.Shutdown(timeout,mirname)
		   }
		   ; send EXIT and the MIRRORMGR will exit which will close the
		   ; connections to the other nodes and the other nodes will reform
		   ; the mirror without us.
		   if mgrpid if '$$QuitMirrorMgr(mirname,mgrpid,1) Quit $$Error^%apiOBJ(2169,mirname)
		   if remain quit $$Error^%apiOBJ(2094,mirname)
		   if '$$BackupDaemonExit(mirname,timeout) quit $$Error^%apiOBJ(2168)
		   if $SYSTEM.Mirror.GetStatus(mirname)="CRASHED" Quit $$Error^%apiOBJ(2192,mirname)
		   quit 1
	   }
 	   s mirlist=$p(^SYS("MIRRORSET"),"^",2)
 	   for i=1:1:$l(mirlist,",") {
	 	   s mirname=$p(mirlist,",",i)
	 	   if mirname="" continue
		   s mgrpid=+$G(^MIRROR(mirname,"MgrJobID"))
		   ; we post on id #0 which is ourself. SHUTDOWN tells the mirror manager
		   ; this node is shutting down so it should not respond to any more
		   ; connections from other nodes (eg. if we're the primary, don't tell
		   ; a new node to become the backup).
		   if mgrpid do post(mirname,mgrpid,0,"SHUTDOWN:SUSPEND")
 	   }
 	   if state["BACKUP" {
		   s remain=$SYSTEM.Mirror.Shutdown(timeout)
 	   }
 	   s dstatus=1
 	   for i=1:1:$l(mirlist,",") {
	 	   s mirname=$p(mirlist,",",i)
	 	   if mirname="" continue
		   s mgrpid=+$G(^MIRROR(mirname,"MgrJobID"))
		   ; send EXIT and the MIRRORMGR will exit which will close the
		   ; connections to the other nodes and the other nodes will reform
		   ; the mirror without us.
		   if mgrpid if '$$QuitMirrorMgr(mirname,mgrpid,1) s dstatus=$select(+dstatus:$$Error^%apiOBJ(2169,mirname),1:$$AppendStatus^%occSystem(dstatus,$$Error^%apiOBJ(2169,mirname)))
		   if $SYSTEM.Mirror.GetStatus(mirname)="CRASHED" s dstatus=$select(+dstatus:$$Error^%apiOBJ(2192,mirname),1:$$AppendStatus^%occSystem(dstatus,$$Error^%apiOBJ(2192,mirname)))
 	   }
 	   if '(''dstatus) Quit dstatus
  } else {
	   i mirname="" {
		   s mirname=$p(^SYS("MIRRORSET"),"^",2)
		   if mirname="" quit $$Error^%apiOBJ(2050)
	   } elseif mirname'=$p(^SYS("MIRRORSET"),"^",2) {
		   quit $$Error^%apiOBJ(2051,mirname)
	   }
	   if '##class(SYS.Mirror).IsMirrorStarted(mirname) q $$Error^%apiOBJ(2107,mirname)
	   s mgrpid=+$G(^MIRROR(mirname,"MgrJobID"))
	   ; we post on id #0 which is ourself. SHUTDOWN tells the mirror manager
	   ; this node is shutting down so it should not respond to any more
	   ; connections from other nodes (eg. if we're the primary, don't tell
	   ; a new node to become the backup).
	   if mgrpid do post(mirname,mgrpid,0,"SHUTDOWN:SUSPEND")
 	   if state["BACKUP"||(state["PRIMARY") {
		   s remain=$SYSTEM.Mirror.Shutdown(timeout)
 	   }
	   ; send EXIT and the MIRRORMGR will exit which will close the
	   ; connections to the other nodes and the other nodes will reform
	   ; the mirror without us.
	   if mgrpid if '$$QuitMirrorMgr(mirname,mgrpid,$s(state'["PRIMARY":1,1:0)) Quit $$Error^%apiOBJ(2169,mirname)
	   if $SYSTEM.Mirror.GetStatus(mirname)="CRASHED" Quit $$Error^%apiOBJ(2192,mirname)
   }
   if remain quit $$Error^%apiOBJ(2094,mirname)
   if '$$BackupDaemonExit(mirname,timeout) quit $$Error^%apiOBJ(2168)
   quit 1
}
QuitMirrorMgr(mirname,mgrpid,intr=0) {
	do post(mirname,mgrpid,0,"SHUTDOWN:EXIT")
	if $zu(67,1,+mgrpid)'=2 {
		s miridx=$SYSTEM.Mirror.MirrorNameToIndex(mirname,0)+1
		if miridx>0 s x=$SYSTEM.Mirror.DejournalFree(miridx)
	}
again ;
	Lock +^MIRROR(mirname,"MgrJobID"):$s(intr:3,1:5)
	I '$T {
		if intr {
			s ^MIRROR(mirname,"Status","MGR")="Exit"
			s miridx=$SYSTEM.Mirror.MirrorNameToIndex(mirname,0)+1
			if miridx>0 {
				s shrid=+$SYSTEM.Mirror.DejournalGetSharid(miridx)
				if shrid>=0 {
					do $ZU(78,53,shrid,16,1) ;stop reader job
					do $zu(78,53,shrid,0,1)
				}
			}
			d $system.Util.SendInterrupt(mgrpid)
			s intr=0
			g again
		}
		d $zu(9,"","MirrorMgr not quit within 5 seconds after posted to quit",1 /* broadcast and log message*/,1  /* Warning */)
		Quit 0
	} else {
		Lock -^MIRROR(mirname,"MgrJobID")#"I"
		Quit 1
	}
}
GetDBInfoFromPrimary(mirname,dblist) PUBLIC {
	;Called on an active Backup from the $ZU(17) mount code when a database
	; gets mounted to ask the primary to send us the current characteristics
	; of this database (eg. expandby/maxsize/etc).
	;
	if '$SYSTEM.Security.Check("%Admin_Manage","USE") {
	   quit "0,Insufficient privilege to shutdown mirroring"
    }
    s state=$SYSTEM.Mirror.GetInfo()
    if state'["BACKUP" quit
    if ^SYS("MIRRORSET")'[mirname {
	    d $zu(9,"","GetDBInfo: System not part of mirror "_mirname,1 /* broadcast and log message*/,1  /* Warning */)
	    quit
    }
    s mgrpid=+$G(^MIRROR(mirname,"MgrJobID"))
    if 'mgrpid {
	    d $zu(9,"","GetDBInfo: Control process not running, message not posted",1 /* broadcast and log message*/,1  /* Warning */)
	    quit
    }
	s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
	if (systemcnt=0) {
		d $zu(9,"","GetDBInfo: No other systems in the mirror at this time",0,0  /* Informational message */)
		quit
	}
    for id=1:1:systemcnt {
	      s r=$G(^MIRROR(mirname,"Status","Member",id,"Role"))
	      if (r="PRIMARY") quit
	   }
	if (r'="PRIMARY") {
		if (state'["SHADOW") {
		   d $zu(9,"","GetDBInfo failed to find primary in Member list, using id #1",1 /* broadcast and log message*/,1  /* Warning */)
		}
		s id=1
	}
	s rc=$$SynchDBInfo^MIRRORCTL(mirname,id,$p(dblist,":"),$p(dblist,":",2),$p(dblist,":",3,*))
	if $LG(rc)="OK",$LG(rc,2)="" {
		For ii=3:2:$l(dblist,":") {
			s rc=$$SynchDBInfo^MIRRORCTL(mirname,id,$p(dblist,":",ii),$p(dblist,":",ii+1),"")
		}
	}
	quit
}
 /* Return: -1 - error occurred.
            0  - Dejournal status is changed from running to stopped.
            1  - Dejournal status is unchanged.
            2  - Dejournal status is changed from stopped to running. 
 */
CheckReinitDejournal(mirname) {
	/* Always return 1 for non-async member. */
	Q:'$SYSTEM.Mirror.IsAsyncMember() 1
	s miridx=$SYSTEM.Mirror.MirrorNameToIndex(mirname,0)+1
	if miridx<=0 {
		d $zu(9,"","CheckReinitDejournal: Failed to find mirror index for mirror set "_mirname,1 /* broadcast and log message*/,1  /* Warning */)
		Quit -1
	}
	Lock +^MIRROR(mirname,"DejournalBlock")
	s dejrnblock=+$G(^MIRROR(mirname,"DejournalBlock"))
	s shrid=+$SYSTEM.Mirror.DejournalGetSharid(miridx)
	if $G(^||MIRROR(mirname,"DejournalRunning")) {
		/* Dejournaling is supposed to be running. If it does not then we need to start it. */
		if dejrnblock=1 {
			Lock -^MIRROR(mirname,"DejournalBlock")
			k ^MIRROR(mirname,"DejournalRunning")
			k ^||MIRROR(mirname,"DejournalRunning")
			s rc=$$UpdateMirrorJournalCheckPoint(mirname,3)
			if '+rc {
				d $zu(9,"","CheckReinitDejournal: UpdateMirrorJournalCheckPoint failed: "_$p(rc,",",2),1 /* broadcast and log message*/,1  /* Warning */)
			}
			Quit 0
		}
		if shrid<0 {
			if $$InitDejournal(miridx,mirname) {
				Lock -^MIRROR(mirname,"DejournalBlock")
				s rc=$$UpdateMirrorJournalCheckPoint(mirname,3)
				if '+rc {
					d $zu(9,"","CheckReinitDejournal: UpdateMirrorJournalCheckPoint failed: "_$p(rc,",",2),1 /* broadcast and log message*/,1  /* Warning */)
				}
				Quit 2   ; Dejournaling is restarted.
			}
			/* Failed to restart dejournaling. */
			Lock -^MIRROR(mirname,"DejournalBlock")
			k ^MIRROR(mirname,"DejournalRunning")
			k ^||MIRROR(mirname,"DejournalRunning")
			s rc=$$UpdateMirrorJournalCheckPoint(mirname)
			if '+rc {
				d $zu(9,"","CheckReinitDejournal: UpdateMirrorJournalCheckPoint failed: "_$p(rc,",",2),1 /* broadcast and log message*/,1  /* Warning */)
			}
			d $zu(9,"","CheckReinitDejournal: Failed to re-initialize dejournal memory",1 /* broadcast and log message*/,1  /* Warning */)
			Quit -1
		} else {
			Lock -^MIRROR(mirname,"DejournalBlock")
			quit 1    ; Status unchanged.
		}
	}
	/* Dejournal daemon is not running, and dejournal is no longer blocked, we need to start it up. */
	if dejrnblock {
		Lock -^MIRROR(mirname,"DejournalBlock")
		quit 1  ; Dejournal status is unchanged (stay blocked).
	}
	/* Now we need to restart dejournaling. */
	if $$InitDejournal(miridx,mirname) {
		Lock -^MIRROR(mirname,"DejournalBlock")
		s rc=$$UpdateMirrorJournalCheckPoint(mirname,3)
		if '+rc {
			d $zu(9,"","CheckReinitDejournal: UpdateMirrorJournalCheckPoint failed: "_$p(rc,",",2),1 /* broadcast and log message*/,1  /* Warning */)
		}
		Quit 2   ; Dejournaling is restarted.
	}
	/* Failed to restart dejournaling. */
	Lock -^MIRROR(mirname,"DejournalBlock")
	k ^MIRROR(mirname,"DejournalRunning")
	k ^||MIRROR(mirname,"DejournalRunning")
	d $zu(9,"","CheckReinitDejournal: Failed to re-initialize dejournal memory",1 /* broadcast and log message*/,1  /* Warning */)
	Quit -1
}
InitDejournal(id,mirname) public {
	/* InitDejournal() allocates memory and starts up the helper jobs for
	     the C based "shadow" dejournaling system.
	   id is the id of the mirror this is attached to. If we're a failover
	      node and this is the connection to the primary (eg. the active
	      channel) then this is 1. If we're a reporting member and this is
	      the connection to a primary, it is 2 or more indicating which 
	      primary we're connecting to. If this is for "catching up" older databases
	      then this is 0 and we assign an id here.
	   mirname is the name of the mirror this is attached to
	   Returns 0 - failed, 1 - succeeded
	         For many errors we retry in this routine until we succeed.
	         We only return failure for configuration type errors (eg.
	         mirroring not configured yet).
	  ---------------------------------------------------------------------
	   This is a slightly modified version of the shadow dejournaling system 
	   as these jobs knows they are associated with a mirror. We track the 
	   shared memory id internally and automatically set up redirection for
	   the mirrored databases in the journal files(s) as we open them. 
	   This entry point does not start an  actual "dejournaling" job to process
	   journal files. That is done with either $SYSTEM.Mirror.ProcessFile() to 
	   process a given journal file or by jobbing off StartDejournal() when a 
	   system is becoming a backup mirror member. StartDejournal() drives the 
	   dejournaling of the journal data as it is recieved from the primary.
	   The C based dejournaling system uses a global as temporary storage for
       handling 'very large' string data (HYY1255). The global is stored in 
       the shared memory structures and can have an arbitrary name. Here we 
       generate a global mapped to IRISTemp: 
                    ^IRIS.Temp("MIRROR",<mirronname>,threadid).
       This is killed off by $SYSTEM.Mirror.DejournalFree() as part of 
       shutting down the dejournaling system. $SYSTEM.Mirror.DejournalFree()
       is mostly called internally by other Mirroring functions (eg. shutdown,
       InitPrimary, etc).
    */
    s $zt="err"
	if mirname="" {
	   d $zu(9,"","Failed to initialize mirror dejournaling: mirror name not specified",1 /* broadcast and log message*/,1  /* Warning */)
	   quit 0
	}
	if (id < 1) {
		; make sure the id is >0 because 0 has special meaning
	   d $zu(9,"","("_mirname_") InitDejournal called with invalid id ("_id_"). Id's must be >0",1 /* broadcast and log message*/,1  /* Warning */)
	   quit 0
	}
	s Locked=0
	if $System.Mirror.IsAsyncMember() {
		Lock +^MIRROR(mirname,"DejournalBlock")
		s dejrnblock=+$G(^MIRROR(mirname,"DejournalBlock"))
		s Locked=1
		if dejrnblock=1 {
			Lock -^MIRROR(mirname,"DejournalBlock")
			k ^MIRROR(mirname,"DejournalRunning")
			k ^||MIRROR(mirname,"DejournalRunning")
			if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","DejrnInit Skipped - Dejournaling for "_mirname_" is marked stopped.")
			quit 1
		}
		s AsyncStopOnError=1
	} else {
		s AsyncStopOnError=0
	}
	s NoDejrnSync= 16
    s dejrnid=mirname_"("_id_"): "
	s tempglo=$name(^IRIS.Temp("MIRROR",mirname,id))
	d ##class(%SYS.Journal.System).GetDejournalSettings("mirror",mirname,.numprefetch,.quesiz,.stksiz,.sizmod,.numupd,.rangemax,.maxpref,.inorder)
 	s x=$SYSTEM.Mirror.DejournalInit(id,tempglo,numprefetch,AsyncStopOnError+sizmod+NoDejrnSync,quesiz,stksiz,maxpref)  ;JO2553
	if +x>0 {  ; x>0 means Dejounaling was already initialized
		s shrid=$P(x,",",2)  ;dejournalInit returns 1,shrid
		s i=$ZU(78,111,shrid)
		if +i=0 {
			if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","InitDejournal found memory existed but no updaters running")
			k ^MIRROR(mirname,"DejournalWorker")
			k ^MIRROR(mirname,"DejournalRunning")
			k ^||MIRROR(mirname,"DejournalRunning")
			k ^MIRROR(mirname,"DejournalReader")
			goto startjobs
		}
		Lock:Locked -^MIRROR(mirname,"DejournalBlock")
		s ^MIRROR(mirname,"DejournalRunning")=1
		s ^||MIRROR(mirname,"DejournalRunning")=1
		Quit 1
	}
	k ^MIRROR(mirname,"DejournalWorker")
	k ^||MIRROR(mirname,"DejournalRunning")
	k ^MIRROR(mirname,"DejournalRunning")
	k ^MIRROR(mirname,"DejournalReader")
	if +x<0 {
		d $zu(9,"",dejrnid_"Failed to initialize dejournaling memory, rc="_x_" retrying",1 /* broadcast and log message*/,1  /* Warning */)
		s cnt=0,nextmsg=5  ;another message in 5 minutes
		for {
			Lock:Locked -^MIRROR(mirname,"DejournalBlock")
			s Locked=0
			h 60
			if $System.Mirror.IsAsyncMember() {
				Lock +^MIRROR(mirname,"DejournalBlock")
				s dejrnblock=+$G(^MIRROR(mirname,"DejournalBlock"))
				s Locked=1
				if dejrnblock=1 {
					Lock -^MIRROR(mirname,"DejournalBlock")
					k ^MIRROR(mirname,"DejournalRunning")
					k ^||MIRROR(mirname,"DejournalRunning")
					quit
				}
			}
		 	s x=$SYSTEM.Mirror.DejournalInit(id,tempglo,numprefetch,AsyncStopOnError+sizmod+NoDejrnSync,quesiz,stksiz)  ;JO2553
		 	quit:x>=0
		 	s cnt=cnt+1
		 	if (cnt = nextmsg) {
			    d $zu(9,"",dejrnid_"Initialization of dejournaling memory still failing - Continuing to retry",1 /* broadcast and log message*/,1  /* Warning */)
			    s nextmsg=nextmsg*2
			    if nextmsg>60 s nextmsg=60  ;max 1 hour apart
			    s cnt=0
		 	}
		}
		if $System.Mirror.IsAsyncMember(),$G(dejrnblock) {
			if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","DejrnInit Skipped - Dejournaling for "_mirname_" is marked stopped.")
			quit 1
		}
	    d $zu(9,"",dejrnid_"Initialization of dejournaling memory succeeded - continuing",0,0  /* Informational message */)
	}
	; Start some prefetch jobs and the dejournalling job
	if id>0 {
	   s shrid=+$SYSTEM.Mirror.DejournalGetSharid(id)
	   ; returns shrid which is 0->n or -1 if there's a problem 
	   if shrid<0 {
		  Lock:Locked -^MIRROR(mirname,"DejournalBlock")
		  d $zu(9,"","InitDejournal exited - Failed to locate sharid for primary id #"_id,1 /* broadcast and log message*/,1  /* Warning */)
		  quit 0
	   }
	} else {
	   s shrid=-id  ;id values <=0 are already shrid values
	}
startjobs ;	
	k @tempglo  ;make sure it starts out 'missing'
	s ^||MIRROR(mirname,"UpdaterInfo")=$LB(numupd,$G(^SYS("MIRRORSET",mirname,"AllowParallelDejournaling")),$G(^%SYS("DEJOURNALING","NumUpdater")),$G(^MIRROR(mirname,"Config","NumUpdater")))
	s ^MIRROR(mirname,"UpdaterInfo")=^||MIRROR(mirname,"UpdaterInfo")
	s ^MIRROR(mirname,"DejournalWorker","status")="running"
	if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","InitDejournal starting "_numupd_" updaters")
	for updid=0:1:(numupd-1) {
	    job DejrnSetKill(id,mirname,AsyncStopOnError,updid):(:2):10 ;JO2553
        if '$T {
		   if updid { ;not the first updater to job off
		     d $zu(9,"",dejrnid_" jobbed off only "_updid_" dejournaling worker process(es)",1 /* broadcast and log message*/,1  /* Warning */)
		  	 s numupd=updid 
		  	 q
		   }
		   d $zu(9,"",dejrnid_"Failed to job dejournaling worker process - Retrying",1 /* broadcast and log message*/,1  /* Warning */)
		   s cnt=0,nextmsg=6  ;another message in 1 minute
		   for {
			  Lock:Locked -^MIRROR(mirname,"DejournalBlock")
			  s Locked=0
			  h 10  ;10 seconds between retries
			  if $System.Mirror.IsAsyncMember() {
				  Lock +^MIRROR(mirname,"DejournalBlock")
				  s dejrnblock=+$G(^MIRROR(mirname,"DejournalBlock"))
				  s Locked=1
				  if dejrnblock=1 {
					 quit
				  }
			  }
			  job DejrnSetKill(id,mirname,AsyncStopOnError,updid):(:2):10  ;JO2552
			  quit:$T
			  s cnt=cnt+1
			  if (cnt = nextmsg) {
				  d $zu(9,"",dejrnid_"Still failing to start dejournal worker - Continuing to retry",1 /* broadcast and log message*/,1  /* Warning */)
				  s nextmsg=nextmsg*2
				  if nextmsg>60 s nextmsg=60  ;max 10 minutes
				  s cnt=0
			  }
		   }
		   if $System.Mirror.IsAsyncMember(),$G(dejrnblock) quit
		   d $zu(9,"",dejrnid_"Dejournal worker job started - continuing",0,0  /* Informational message */)
	    }  ;if '$T
	}
	if $System.Mirror.IsAsyncMember(),$G(dejrnblock) {
		k ^MIRROR(mirname,"DejournalWorker")
	    s x=$SYSTEM.Mirror.DejournalFree(id)
		Lock -^MIRROR(mirname,"DejournalBlock")
		k ^MIRROR(mirname,"DejournalRunning")
		k ^||MIRROR(mirname,"DejournalRunning")
		if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","DejrnInit Skipped - Dejournaling for "_mirname_" is marked stopped.")
		quit 1
	}
        d $zu(78,111,shrid,numupd,rangemax) ;set # of updaters that are actually jobbed off
	i numupd>1,$g(inorder) {
		; apply updates in order (inorder), except (hence numupd>1)
		; those to specified db's that can be applied in parallel.
		s db="" f {
			s db=$o(^MIRROR(mirname,"APD",db))
			q:db=""
			s sfn=$zu(49,db)
			i 0<=sfn,sfn<$zu(40,0,41) d $zu(78,111,shrid,-2,sfn)
		}
	}
	for i=1:1:numprefetch {
	   job DejrnPrefetch(id,0):(:2):10  ;don't use a jobserver
	   if '$T {
		 d $zu(9,"","Warning failed to job dejournaling prefetch job #"_i_" for "_dejrnid,1 /* broadcast and log message*/,1  /* Warning */)
		 ; don't quit 0 just because we failed to start a prefetch job
	   }
	}
	Lock:Locked -^MIRROR(mirname,"DejournalBlock")
	s ^MIRROR(mirname,"DejournalRunning")=1
	s ^||MIRROR(mirname,"DejournalRunning")=1
	quit 1 ; success
err ;
	Lock:$G(Locked) -^MIRROR(mirname,"DejournalBlock")
	d $zu(9,"","Unexpected error: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	d BACK^%ETN
	quit 0
}
DejrnPrefetch(id,jobnum) PUBLIC {
	s $ZT="DejrnPrefetchErr"
	; This is jobbed off as a prefetch job for dejournaling
	do $SYSTEM.Mirror.DejournalPrefetch(id,jobnum)
	quit
DejrnPrefetchErr ;
	s $ZT=""
	d BACK^%ETN
	d $zu(9,"","Dejournal Prefetch("_id_") Job #"_jobnum_" caught an error: "_$ze,1 /* broadcast and log message*/,1  /* Warning */)
	quit	
}
DejrnSetKill(id,mirname="",AsyncStopOnError=0,updid=0) PUBLIC {
	; This is jobbed off as the "worker" (setkill) job for dejournaling
	s $zt="DejrnErr2"
	if id>0 {
	   s shrid=+$SYSTEM.Mirror.DejournalGetSharid(id)
	   ; returns shrid which is 0->n or -1 if there's a problem 
	   if shrid<0 {
		  d $zu(9,"","DejrnSetKill exited - Failed to locate sharid for primary id #"_id,1 /* broadcast and log message*/,1  /* Warning */)
		  quit
	   }
	} else {
	   s shrid=-id  ;id values <=0 are already shrid values
	}
	if $L(mirname) {
		s jobnum=$ZU(61)
		s ^MIRROR(mirname,"DejournalWorker",updid,"pid")=+$J
		s ^MIRROR(mirname,"DejournalWorker",updid,"jobnum")=jobnum
		s ^MIRROR(mirname,"DejournalWorker",updid,"jobid")=$ZH($ZU(61,30,jobnum))
		k ^MIRROR(mirname,"DejournalWorker",updid,"errtext")
	}		
	i $zu(78,51,shrid,updid,3) 
	; If we catch an error at DejrnErr then the quit in the error trap
	; returns to call DejournalWorker again. This is how errors during the
	; journal restore are handled. OTOH, if DejournalWorker returns with a value
	; because its shutting down (0) or if something is wrong (-1, -2) then we 
	; want to exit.
	s skiprec=0
	s rc=1  ;DejournalWorker() sets this if we return
	for  do  q:rc'=1
	. s $zt="DejrnErr"
	. s rc=$s(skiprec:$SYSTEM.Mirror.DejournalWorker(id,1),1:$SYSTEM.Mirror.DejournalWorker(id)),skiprec=1
	if rc=0 {
	   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","DejournalWorker("_id_") shutting down")
	   if $L(mirname) {
   	      s ^MIRROR(mirname,"DejournalWorker","status")="stopped"
	   }
	} else {
	   d $zu(9,"","DejournalWorker("_id_") shutting down due to a problem - status = "_rc,1 /* broadcast and log message*/,1  /* Warning */)
	   if $L(mirname) {
	      s ^MIRROR(mirname,"DejournalWorker","status")="error"
	      s ^MIRROR(mirname,"DejournalWorker","errtext")=rc
	   }
	}
	; This will cause the prefetch and reader jobs to exit and
	; tear down shared memory. InitDejournal() will start new
	; jobs when it is called.
	s rc=$SYSTEM.Mirror.DejournalFree(id)	;doesn't return a useful status	
	quit
DejrnErr2 ;
	s $zt=""
	d $zu(9,"","DejrnSetKill("_mirname_") caught unexpected error: "_$ZE,1 /* broadcast and log message*/,2  /* Severe error */)
	d BACK^%ETN
	try {
		; DejournalFree() will signal other jobs to exit as well
		s rc=$SYSTEM.Mirror.DejournalFree(id)	;doesn't return a useful status	
	} catch {
		d $zu(9,"","DejournalWorker("_id_") caught error shutting down dejournaling: "_$ze,1 /* broadcast and log message*/,1  /* Warning */)
	}
	quit  ;halt?
DejrnErr ;
    s $zt="DejrnErrCont"
	s info=$zu(78,53,shrid,8) ;addr,sfn,gcol,gref
	s sfn=+$P(info,",",2)   ;JO2528
	s dbinfo=$ZU(49,sfn,3)
	s dbname=$P(dbinfo,"^",2)   ;JO2552
	s addr=+info
	s globcoll=$p(info,",",3)
	s globnodelen=$p(info,",",4)
	s globnodeoff=$p(info,",",5)
	s globnode=$p(info,",",6,$l(info))
	s globref="^"_$zu(70,4,globnode,$zu(70,1,globcoll)) 
	s globnam=$qs(globref,0)
DejrnErrCont ;
	s $zt=""  ;should we have a 3rd level of error handling?
	d BACK^%ETN
	/* AsyncStopOnError is set for the main dejournaling connection
	   on a reporting async where if there's an error, rather than continuing
	   without that database, users want all databases to stop so they remain
	   more or less in sync at a given point in time. */
	if AsyncStopOnError&&$SYSTEM.Mirror.AsyncMemberType() {
		d $zu(9,"","Mirror dejournaling suspended for """_mirname_""": Caught error /"_$ZE_"/ working on "_dbname_" (sfn #"_sfn_")",1 /* broadcast and log message*/,2  /* Severe error */)
		Do $zu(78,53,shrid,0,1)
	    ; we post on id #0 which is ourself. DEJOURNALSTOP: tells the control
	    ; process to kill ^||MIRROR(mirname,"DejournalRunning") to block the
	    ; dejournal monitor from automatically restarting dejournaling after
	    ; we shut it down here. 
	    do post(mirname,0,0,"DEJOURNALSTOP:")  ;post will lookup mgrpid for mirname
		; This will cause the prefetch and reader jobs to exit and
		; tear down shared memory. InitDejournal() will start new
		; jobs when it is called.
		s rc=$SYSTEM.Mirror.DejournalFree(id)	;doesn't return a useful status	
		; rc<0 generates an error record
		s rc="-1,Caught error "_$ze_" at address "_addr_" working on "_dbname_" (sfn #"_sfn_")"
	} else {
		; Setting SFNSKIP causes future dejournaling to this sfn to be
		; skipped and removes the "db i+n active mirror" flag.
		do $zu(78,76,shrid,sfn)  
		s skiprec=1
		d $zu(9,"","DejournalWorker("_id_") "_$s($SYSTEM.Mirror.IsPrimary():"Primary",$SYSTEM.Mirror.IsBackup():"Backup",1:$SYSTEM.Mirror.GetMemberType())_" member caught error /"_$ZE_"/ working on sfn #"_sfn_". "_dbname_" requires catchup to be activated again",1 /* broadcast and log message*/,2  /* Severe error */)
	}
 	q
}
DejrnReader(id,jrnname,mirjrnfilecnt,jrnpos) PUBLIC {
	/* This is the journal reader job for the mirror dejournaling
	   process. It is jobbed off when this system becomes and active
	   backup member and it process the journal data as it is received from
	   the primary mirror member. Any existing journal data on this machine
	   has already been processed during startup with 
	   $SYSTEM.Mirror.ProcessFile(). InitDejournal() has already been called
	   to initialize shared memory and start the prefetch and setkill jobs.
	   (jrnpos might be zero and jrnname might be null if mirjrnfilecnt
	    is a file we don't have yet and DejournalReader waits for the backup
	    to start sending it to us).
	*/
	s $zt="DejrnReaderErr"
	s shrid=+$SYSTEM.Mirror.DejournalGetSharid(id)
	; returns shrid which is 0->n or -1 if there's a problem 
	if shrid<0 {
		d $zu(9,"","DejrnSetReader - Failed to locate sharid for primary id #"_id,1 /* broadcast and log message*/,1  /* Warning */)
	} else {
		s prefstrategy=$G(^MIRROR(":config:","PrefetchStrategy"),-100)
		do $ZU(78,90,shrid,prefstrategy)
		if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","DejrnReader set prefetch chunk size for sharid #"_shrid_" to "_(-prefstrategy))
	}
	s info=$SYSTEM.Mirror.GetInfo(3,id-1)
	s mirname=$P(info,",",1)
	s jobnum=$ZU(61)
	s ^MIRROR(mirname,"DejournalReader","pid")=+$J
	s ^MIRROR(mirname,"DejournalReader","jobnum")=jobnum
	s ^MIRROR(mirname,"DejournalReader","jobid")=$ZH($ZU(61,30,jobnum))
	s ^MIRROR(mirname,"DejournalReader","status")="running"
	k ^MIRROR(mirname,"DejournalReader","errtext")
	s rc=##class(SYS.Mirror).GetDejournalFilterSetting(mirname,.filter)
	if ('rc) {
		d $zu(9,"","DejournalReader ("_mirname_") failed to get filter setting, error="_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
		s ^MIRROR(mirname,"DejournalReader","errtext")="DejournalReader ("_mirname_") failed to get filter setting, error="_$SYSTEM.Status.GetErrorText(rc)
		s ^MIRROR(mirname,"DejournalReader","status")="error"
		Quit
	}
	if filter'="" {
		s FilterObj=$classmethod(filter,"%New")
		if '$isobject(FilterObj) {
			d $zu(9,"","DejournalReader ("_mirname_") failed to run %New() method of class "_filter,1 /* broadcast and log message*/,1  /* Warning */)
			s ^MIRROR(mirname,"DejournalReader","errtext")="DejournalReader ("_mirname_") failed to run %New() method of class "_filter
			s ^MIRROR(mirname,"DejournalReader","status")="error"
			Quit
		}
		s FilterObj.InCatchupDB = 0
		if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","DejournalReader ("_mirname_") is running filter class "_filter)
	}
	try {
		s:'$G(^MIRROR(mirname,"DBDejournaled")) ^MIRROR(mirname,"DBDejournaled")=1
		if filter'="" {
		   s rc=FilterObj.DejournalReader(id,jrnpos,jrnname,mirjrnfilecnt)
		} else {
		   d ##class(%SYS.Journal.System).GetDejournalReaderSettings(.cachesize,.readahead,.disableaio) 
		   s rc=$SYSTEM.Mirror.DejournalReader(id,jrnpos,jrnname,mirjrnfilecnt,cachesize,readahead,disableaio)
	   	}
	   	if +rc {
		   s ^MIRROR(mirname,"DejournalReader","status")="stopped"
	   	} else {
		   ;If DejournalReader returns 0 some trouble occured while getting started and
		   ; retrying isn't going to help so leave the status marked as "error" (we retry on
		   ; "crashed")
		   d $zu(9,"","Dejournal Read Daemon("_id_") exited abnormally with status="_$p(rc,",",2,999),1 /* broadcast and log message*/,1  /* Warning */)
		   s ^MIRROR(mirname,"DejournalReader","errtext")="Dejournal Read Daemon("_id_") exited abnormally with status="_$p(rc,",",2,999)
		   s ^MIRROR(mirname,"DejournalReader","status")="error"
	   	}
	} catch {
	    s err=$P($ZE,">")
	    if $G(^MIRROR(mirname,":errors:","DejournalReader",err))'=+$ZTS {
			s ^MIRROR(mirname,":errors:","DejournalReader",err)=+$ZTS
			d BACK^%ETN
		}
		if $ZE["<OBJECT DISPATCH>" {
			d $zu(9,"","Dejournal Read Daemon ("_mirname_") exited abnormally due to Dejournal Filter error: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
			s ^MIRROR(mirname,"DejournalReader","errtext")="Dejournal Read Daemon ("_mirname_") exited abnormally due to Dejournal Filter error: "_$ZE
			s ^MIRROR(mirname,"DejournalReader","status")="error"
			quit
		}
		d $zu(9,"","Dejournal Read Daemon ("_mirname_") caught an unexpected error: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
		s ^MIRROR(mirname,"DejournalReader","status")="crashed"
	}
	quit
DejrnReaderErr ;
	s $ZT=""
	d BACK^%ETN
	d $zu(9,"","Dejournal Read Daemon("_id_") caught an error: "_$ze,1 /* broadcast and log message*/,1  /* Warning */)
	if $d(mirname) {
		s ^MIRROR(mirname,"DejournalReader","errtext")="Dejournal Read Daemon("_id_") caught an error: "_$ze
		s ^MIRROR(mirname,"DejournalReader","status")="crashed"
	}
	quit	
}
GetTPInfoForMissingJournalFile(mirname,mirjcnt) {
	/* Called from ValidateMirrorJournalLog when the dejrnchkpnt file is
	   beyond the end of the local journal log and we need to get the
	   transaction rollback point stored in this journal file so we know
	   which journal file we need to start with.
	   Sends messages to the other node(s) and return the MAX value for the
	   TP rollback information. 
	   Returns: -1 - something went wrong and we failed to find the transroll point   
	            filecnt^offset = transroll point for specified journal file
	*/
	s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
	if 'systemcnt {
		d $zu(9,"","("_mirname_") Can't determine TP info for file #"_mirjcnt_" - no other failover mirror members",1 /* broadcast and log message*/,1  /* Warning */)
		quit -1
	}
	k errlist
	s minxfilecnt=0,found=0,minxoffset=0
    for id=1:1:systemcnt {
	   s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
       if info'="" {
	      s name=$lg(info,1)
          s addr=$lg(info,5)
          s basedir=$lg(info,6)
          s rc=$$GetJournalInfo^MIRRORCTL(mirname,id,3,mirjcnt)
          ; returns $LB(<status>,$LB($SYSTEM.Mirror.GetJournalFileInfo(),$$$JRNHDRALL))
	      s status=$LG(rc)
	      if status="OK" {
		      s val=$LG(rc,2)
		      s mirinfo=$LG(val,1)
		      s jrninfo=$LG(val,2)
		      if jrninfo=0 {
			      s errlist(name)="File #"_mirjcnt_" not found"
			      continue
		      }
			  s index=+$P(jrninfo,",",21+1)
			  s filecnt=+$P(jrninfo,",",20+1)
		      if 'found {
			      s minxfilecnt=filecnt,minxoffset=index
			      s found=1
		      } elseif (filecnt > minxfilecnt) {
			      ; use the highest minxfilecnt we see as that's
			      ; the one from the primary. If this is a failover
			      ; member, we only contact the 1 other node.
			      s minxfilecnt=filecnt,minxoffset=index
		      } elseif (filecnt = minxfilecnt && (index > minxoffset)) {
			      s minxoffset=index
		      }
	      } elseif status="NOTFOUND" {
	         s errlist(name)="File #"_mirjcnt_" not found"
	      } elseif status="ERR" {
	         s errlist(name)=$LG(rc,2)  ;record reason in case we never find a copy of this file
          }
       }
    }
    if 'found {
	    s msg="("_mirname_") Failed to lookup mintransinfo for file #"_mirjcnt
	    s name=$O(errlist(""),1,err)
	    while name'="" {
		    s msg=msg_$C(10,13)_"     "_name_" reports /"_err_"/"
		    s name=$O(errlist(name),1,err)
	    }
	    d $zu(9,"",msg,1 /* broadcast and log message*/,1  /* Warning */)
	    quit -1  ;failed
    }
    q minxfilecnt_"^"_minxoffset   ;>= 0
err ;
	s errstr=$ZE
	d $zu(9,"","Unexpected error: "_errstr,1 /* broadcast and log message*/,1  /* Warning */)
	d BACK^%ETN
	quit -1
}
GetMirrorDejournalInformation(mirname,Type=2) PUBLIC {
	/* Determine current mirror jrnroll point:
            jrnroll point = MAX(jrnroll points across mirrored databases)
            If there aren't any mirrored db's then the jrnroll
            point is zero as a signal we don't have any mirrored dbs.
	     Returns: 0 = something went wrong
	              1 = success
	                  We have at least one mirror database
	   		             ^MIRROR(mirname,"dejrnchkpnt")=<mirjrnfilecnt>^<jrnpos>
	                  We don't have any mirrored databases:
	   		             ^MIRROR(mirname,"dejrnchkpnt")=0
	   The starting point for the journal restore is recorded in the mirror
	   information block for the various mirrored databases. While all the mirrored
	   databases which were part of the active mirror should have the same starting
	   point its possible that some of the databases have been restored from backup,
	   where not accessible when the node was last running, etc. As a result we
	   check all the mirrored db's and find the maximum journal restore point. The 
	   majority (or all) of the mirrored database should have this value as in 
	   general, the databases are going to be "up to date" and only some of them 
	   (if any) will be "older".
	*/
	s $zt="err"
	s miridx=$SYSTEM.Mirror.MirrorNameToIndex(mirname,0)
	s info=$SYSTEM.Mirror.GetInfo(2,miridx)
	s nodbs=(+$SYSTEM.Mirror.GetNextDBBySFN(-1,mirname)=-1)
	if nodbs goto nodbs
	if +$p(info,",",6) {
		s jrnfilecnt=+$p(info,",",6)
		s jrnpos=+$p(info,",",7)
		goto foundchkpnt
	} elseif Type=2 {
		s Type=3
	}
    s dbinfo=$$GetMaxDejrnStart(mirname,1)
    if '$LG(dbinfo) {
	    ; something went wrong, we can't continue
	    quit 0
    }
	; dbinfo=$Lb(rc,<jrnfilecnt>,<jrnendoff>)
	s jrnfilecnt=$lg(dbinfo,2)
	s jrnpos=$LG(dbinfo,3)
    if '+jrnfilecnt {
nodbs
	   if Type=1||nodbs {
		   s ^MIRROR(mirname,"firstdejrnchkpnt")=0
		   s ^MIRROR(mirname,"dejrnchkpnt")=0
	   } else {
		   s ^MIRROR(mirname,"dejrnchkpnt")=$G(^MIRROR(mirname,"firstdejrnchkpnt"),0)
	   }
       if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","dejrnchkpnt set to maxdbjrninfo position "_^MIRROR(mirname,"dejrnchkpnt")_" when no DB found, Type="_Type)
	   quit 1  ; success but we don't have any mirrored db's so dejrnchkpnt is zero
    }
foundchkpnt
     if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","dejrnchkpnt set to maxdbjrninfo position "_jrnfilecnt_","_jrnpos_" Type="_Type)
    if Type=1 {
	    s (^MIRROR(mirname,"dejrnchkpnt"),^MIRROR(mirname,"firstdejrnchkpnt"))=+jrnfilecnt_"^"_+jrnpos
    } else {
	    s firstfcnt=+$p($g(^MIRROR(mirname,"firstdejrnchkpnt")),"^",1)
 	    s firstpos=+$p($g(^MIRROR(mirname,"firstdejrnchkpnt")),"^",2)
 	    if +jrnfilecnt<firstfcnt||(+jrnfilecnt=firstfcnt&&(+jrnpos<firstpos)) {
	 	    s ^MIRROR(mirname,"dejrnchkpnt")=^MIRROR(mirname,"firstdejrnchkpnt")
 	    } else {
	 	    s ^MIRROR(mirname,"dejrnchkpnt")=+jrnfilecnt_"^"_+jrnpos
 	    }
   }
	quit 1
err ;
	d $zu(9,"","Unexpected error: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	d BACK^%ETN
	quit 0
}
GetMaxDejrnStart(mirname="",Type=2) PUBLIC {
	/* This is called at startup when we need to bring our databases up to
	   date as far as the journal files we have before getting in touch with
	   the other mirror members. This returns the highest position
	   from the "up to date" info of the databases mirror info blocks.
	   Type: 1 - Master daemon at starting up, it looks through all mirrored DBs in SFN table (active and non-active, though there should be no active ones).
	         2 - Master daemon after starting up, it looks through all 'active' mirrored DBs. They must be in SFN table.
	         3 - Non-Master daemon jobs, it looks through all mirrored DBs in SFN table, if any one of the DB is 'active' then calculate the dejrnchkpnt with active DBs, otherwise calculate it with all DBs.
	         4 - Single user mode ISCAgent job, it looks though mirrored DBs in ^SYS("UCI") and calculate the dejrnchkpnt from them.
	   Failure: $LB(0): Something went wrong
	   Success: $LB(1,max jrnfilecnt, max jrnpos)
	   			 If there aren't any mirrored databases, the max position
	   			 is returned as 0,0
	*/
	s maxjrncnt=0,maxend=0,found=0
	s rc=$$GetMirroredDBList^MIRRORCOMM(mirname,.dblist,$s(Type=4:0,1:2))
	if '$LG(rc) {
		d $zu(9,"","GetMaxDejrnStart: "_$LG(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
		quit rc
	}
	s foundactive=($LG(rc)>1)
	s onlyactive=(Type=2||(foundactive&&(Type=3)))
	s dir=$o(dblist(""),1,info)
	while dir'="" {
	   if onlyactive,'$P(info,"^",20)&&(foundactive||('$P(info,"^",21))) {
		   s dir=$o(dblist(dir),1,info)
		   continue
	   }
	   if Type=1,$P(info,"^",22)||$P(info,"^",21) {
		   s dir=$o(dblist(dir),1,info)
		   continue
	   }
	   s dbjrncnt=$P(info,"^",3)
	   s dbend=$P(info,"^",4)
	   if 'found {
	      s maxjrncnt=dbjrncnt
		  s maxend=dbend
		  s found=1
	   } elseif dbjrncnt>maxjrncnt {
		  s maxjrncnt=dbjrncnt
		  s maxend=dbend
	   } elseif dbjrncnt=maxjrncnt,dbend>maxend {
		  s maxend=dbend
	   }
	   s dir=$o(dblist(dir),1,info)
	}
	; If we didn't find any mirrored databases we return 0,0 for
	; the 'max' info. 
	quit $LB(1,maxjrncnt,maxend) ;succeeded.
}
GetMaxDBJrnInfo(mirname="") PUBLIC {
	/* This is called at various points where we want to know what is the
	   highest journal position that we care about for databases on this
	   member. This is used to determine how much of a journal file needs
	   to be kept (eg. when setting the valid end), whether the valid end
	   is set too early, etc. This uses the DEJRNTARG point set into the
	   db's as that is the highest point each db cares about. This is 
	   not the position to start dejournaling at (GetMaxDejrnStart).
	   Failure: $LB(0): Something went wrong
	   Success: $LB(1,max jrnfilecnt, max jrnpos)
	   			 If there aren't any mirrored databases, the max position
	   			 is returned as 0,0
	*/
	s maxjrncnt=0,maxend=0,found=0
	s rc=$$GetMirroredDBList^MIRRORCOMM(mirname,.dblist,1)
	if '$LG(rc) {
		d $zu(9,"","GetMaxDBJrnInfo: "_$LG(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
		quit rc
	}
	s dir=$o(dblist(""),1,info)
	while dir'="" {
	   s dbjrncnt=$P(info,"^",18)
	   s dbend=$P(info,"^",19)
	   if 'found {
	      s maxjrncnt=dbjrncnt
		  s maxend=dbend
		  s found=1
	   } elseif dbjrncnt>maxjrncnt {
		  s maxjrncnt=dbjrncnt
		  s maxend=dbend
	   } elseif dbjrncnt=maxjrncnt,dbend>maxend {
		  s maxend=dbend
	   }
	   s dir=$o(dblist(dir),1,info)
	}
	; If we didn't find any mirrored databases we return 0,0 for
	; the 'max' info. 
	quit $LB(1,maxjrncnt,maxend) ;succeeded.
}
GetMinDBJrnInfo(mirname="") PUBLIC {
	/* This is called when we're deciding which mirror journal files can
	   be purged.  This returns the earliest journal position from the 
	   "up to date" info of the databases mirror info blocks. This routine
	   is driven off the ^SYS("UCI") list rather than $SYSTEM.Mirror.GetNextDBBySFN
	   because the later works on mounted db's and this may be run by the
	   agent code against a "down" version of Cache. In that case the
	   ^SYS("UCI") list gives us the set of db's which were mounted
	   the last time Cache' was up, or, the list that is currently
	   mounted if Cache' is up.
	   Failure: $LB(0,error) - Failed
	   Success: $LB(1,jrnfilecnt, jrnpos)
	   			 If there aren't any mirrored databases, the min position
	   			 is returned as 0,0
	*/
	s $zt="err"
	s mirname=$zcvt(mirname,"U")
	if mirname="" {
		s mirname=$G(^SYS("MIRRORSET"))
		if mirname="" quit $LB(1,0,0)  ;not a mirror member, we don't need any journal files
		if +mirname'=0 quit $LB(0,$$Error^%apiOBJ(2002))  ;reporting nodes need to pass this 
		s mirname=$P(mirname,"^",2)
		if mirname="" quit $LB(0,$$Error^%apiOBJ(2002)) ;shouldn't happen
	}
	s initialvalue=1E40  ;1E40 is > (uint)$ZH("FFFFFFFFFFFFFFFF")
	s minjrncnt=initialvalue,minend=0  
	s rc=$$GetMirroredDBList^MIRRORCOMM(mirname,.dblist,0)
	if '$LG(rc) {
		d $zu(9,"","GetMinDBJrnInfo: "_$LG(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
		quit rc
	}
 	k jrnfilelist
	s dir=""
	for {
		s dir=$o(dblist(dir),1,mirinfo)
		q:dir=""
	    s filecnt=$P(mirinfo,"^",11)
	    if 'filecnt {
		   ; If there's no lastfilecntrestored listed then we use the
		   ; tp rollback info from the journal restore point file instead
		   s filecnt=$P(mirinfo,"^",3)
	    }
	    if filecnt {
			if $D(jrnfilelist(filecnt),tpinfo) {
				s tpindex=+$P(tpinfo,"^",2)
				s tpfilecnt=+tpinfo
			} else {
				s jrnfile=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)
				if (+jrnfile<=0) {
					s err=$$Error^%apiOBJ(2000,filecnt,dir,mirname)
					goto fail
				}
				s file=$P(jrnfile,",",2)
				s jrninfo=$zu(78,22,file,99)
				if +jrninfo'=1 {
					s err=$$Error^%apiOBJ(2001,file)
					goto fail
				}
				s tpindex=+$P(jrninfo,",",21+1)
				s tpfilecnt=+$P(jrninfo,",",20+1)
				s tpinfo=tpfilecnt_"^"_tpindex
				s jrnfilelist(filecnt)=tpinfo
				if tpfilecnt<minjrncnt {
					s minjrncnt=tpfilecnt
					s minend=tpindex
				} elseif tpfilecnt=minjrncnt,tpindex<minend {
					s minend=tpindex
				}
			}
	    }
	}
	; If we didn't find any mirrored databases we return 0,0 for
	; the 'min' info. 
	if minjrncnt=initialvalue {
		s minjrncnt=0
		s minend=0
		s jrnfile=$SYSTEM.Mirror.GetLastJournalFilename(mirname)
		if (+jrnfile>0) {
			s file=$P(jrnfile,",",2)
			s jrninfo=$zu(78,22,file,99)
			if +jrninfo=1 {
				s minend=+$P(jrninfo,",",21+1)
				s minjrncnt=+$P(jrninfo,",",20+1)
			}
		}
	}
	quit $LB(1,minjrncnt,minend) ;succeeded.
err ;
	quit $LB(0,$ZE)	
fail ;
    quit $LB(0,err)	
}
GetTransactionRollbackPoint(mirname,filecnt) {
	; Giving a journal file # get the transaction rollback point
	; from that file and store it in the "transroll" node.
	if 'filecnt {
		s ^MIRROR(mirname,"transroll") = 0
		Quit 1
	}
    s jrnfile=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)
    if +jrnfile<=0 {
	    Goto NotExist
	}
	s file=$P(jrnfile,",",2)
	s jrninfo=$zu(78,22,file,99)
	if +jrninfo'=1 {
	    Goto NotExist
	}
	s minxindex=+$P(jrninfo,",",21+1)
	s minxfilecnt=+$P(jrninfo,",",20+1)
	if (minxfilecnt) {
		s ^MIRROR(mirname,"transroll")=minxfilecnt_"^"_minxindex
	} else {
		s ^MIRROR(mirname,"transroll")=$G(^MIRROR(mirname,"dejrnchkpnt"),0)
	}
	quit 1
NotExist ;
	s result=$$GetTPInfoForMissingJournalFile(mirname,filecnt)
	if +result<0 Quit 0
	s ^MIRROR(mirname,"transroll")=result
	quit 1
}
ValidateMirrorJournalLog(mirname) PUBLIC {
	/* If the mirror journal log exists, validate the header. If the
	   header is invalid or the guid's do not match, delete the file.
	   Exits with 
	      ^MIRROR(mirname,"transroll")=minxtransfilecnt^minxtranspos
	             corresponding to dejrnchkpnt or to 0 if we don't have one
	   If the file doesn't exist, create it an populate it with whatever
  	   journal files we find in the current/alternate journal directories.
	   If dejrnchkpnt is beyond the last file listed in the log then return.
	   Otherwise, open that file and pull out the mintransindex from the header.
	   If this is non-zero then use this as our 'minreqfilecnt'. If it is zero
	   then use the dejrnchkpnt file.
	   For each journal file between the minreqfilecnt point and the 
	   last file listed in the log:
          a) if record is missing from log file => report an
             error that the log file needs to be rebuild and 
             return failure
          b) if file doesn't not exist on disk, retrieve file
             from other mirror member and if we fail, report
             an error and return failure
    */
    s $zt="err"
	s mir=##class(Config.Mirrors).Open(mirname)
	s mirguid=$s($IsObject(mir):mir.GUID,1:"")
	/* Get local mirror GUID from configuration, if not configured then use the
	   Instance GUID. */
	s mir=##class(Config.MirrorMember).Open()
	s lguid=""  ;local mirror system guid
	s sysname=$s($IsObject(mir):mir.SystemName,1:"")
	i sysname'="" {
	   if (mir.isAsyncMember()) {
		   s isasync=1
		   s lguid=mir.GetAsyncMemberGUID()
		   s mirguid=^SYS("MIRRORSET",mirname,"GUID")
	   } else {
		   k params
		   s x=##class(Config.MapMirrors).Get(mirname,sysname,.params)
		   if ('x) {
			 	 k err
		   		 Do DecomposeStatus^%apiOBJ(x,.err,"-d") 
				 w !,"Failed to read mirror set member info for: ",name
				 for i=1:1:err w !,?5,err(i)
				 d $zu(9,"","Error reading mirror set member info for "_name_". Text: "_err,1 /* broadcast and log message*/,1  /* Warning */)
		   } else {
 		      s lguid=$G(params("GUID"))
		   }
	   }
	}
	if (mirguid="") || (lguid="") {
	   d $zu(9,"","ValidateMirrorJournalLog error: Configuration is missing mirror guid or local guid",1 /* broadcast and log message*/,1  /* Warning */)
	   quit 0
	}
	;
	s create=1
	s rebuild=0
	s logf=$ZU(12)_"mirrorjrn-"_mirname_".log"
	if '$zu(140,4,logf) {
		; if the file exists, open it and check the header
	    o logf:"RSK\UTF8\":5
	    if '$t quit "0,Failed to open mirror journal log file"
	    k header
	    s rc=##class(%SYS.Journal.History).GetHeader(logf,.header,1)
	    close logf
	    i 'rc {
		    ; failed to read the header, delete the file
		    d $zu(9,"","Failed to read mirror journal log header, deleting log file",1 /* broadcast and log message*/,1  /* Warning */)
	    } else {
		    for i=1:1 {
			    s x=$D(header(i),v)
			    quit:'x
			    s header($P(v,"="))=$P(v,"=",2)
		    }
		    if (header("MirrorSetGUID")'=mirguid) {
			   d $zu(9,"","Mirror GUID in log ("_header("MirrorSetGUID")_") doesn't match mirror guid ("_mirguid_")",1 /* broadcast and log message*/,1  /* Warning */)
		    } elseif (header("LocalMirrorGUID") '= lguid) {
			   d $zu(9,"","Local GUID in log ("_header("LocalMirrorGUID")_") doesn't match local guid ("_lguid_")",1 /* broadcast and log message*/,1  /* Warning */)
		    } else {
			   s create=0  ;file is ok
		    }
	    }
	}
	;
	s pass=1
rebuild ;	
	if create {
	   s rc=$$BuildMirrorLogFromJournalFiles^MIRRORCOMM(mirname,0,"")
	   if +rc<0 {
		   d $zu(9,"","Failed to build new mirror journal log file. "_$P(rc,",",2,*),1 /* broadcast and log message*/,1  /* Warning */)
		   quit 0	   
	   }
	   if rebuild {
		  s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
		  if +rc>0 {
			 s info=$zu(78,22,$P(rc,",",2),99)
	      	 do CheckForDuplicateLastJournalfiles(mirname,+rc,$P(rc,",",2),info)
		  }
	   }
	}
	s minreqfilecnt=+$G(^MIRROR(mirname,"dejrnchkpnt"),0)  ;might be 0 if we don't have any files
	if 'minreqfilecnt {
		s ^MIRROR(mirname,"transroll")=0
		quit 1
	}
    s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
	if +rc<0 {
	   d $zu(9,"","("_mirname_") ValidateMirrorJournalLog failed to read last journal file from mirror journal log",1 /* broadcast and log message*/,1  /* Warning */)
	   quit 0
	}
	s havejrncnt=+rc  ;can be 0 if we don't have any files
	s rc=$$GetTransactionRollbackPoint(mirname,minreqfilecnt)
	Quit:'rc 0
	s minreqfilecnt=+$G(^MIRROR(mirname,"transroll"))
	if minreqfilecnt>havejrncnt {
		quit 1
	}
	i +$g(isasync),$SYSTEM.Mirror.GetStatus(mirname)'="WAITING" do $SYSTEM.Mirror.SetStatus("SYNCHRONIZING",mirname)
	s rebuild=0
	for filecnt=minreqfilecnt:1:havejrncnt {
	   s jrnfile=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)
	   if +jrnfile>0 {
		  s file=$P(jrnfile,",",2)
		  if filecnt=havejrncnt {
			  ;If its the last file, we just want it to exist
	 	      s rc=+$zu(78,22,file,99)	 	     
		  } else {
			  ;If its not the last file, we want it to be complete
		      s rc=$$getMirJrnEnd(file)
		  }
          if rc <= 0 {  ;rc>0 = valid end of file
		      if '$$RetrieveJournalFile(mirname,filecnt,0,1,1) {
		         d $zu(9,"","("_mirname_") ValidateMirrorJournalLog failed to retrieve journal file #"_filecnt,1 /* broadcast and log message*/,1  /* Warning */)
		         goto failed
		      }
		      do CheckStartDejournalProcessor(mirname,filecnt,0)
		  } else {
		      do CheckStartDejournalProcessor(mirname,filecnt,$s(rc>1:rc,1:0))
		  }
	   }
	   if +jrnfile<=0 {
	      if pass=2 {
			 ; after the 1st pass if we're still missing a file, we give up
		     d $zu(9,"","("_mirname_") ValidateMirrorJournalLog still missing journal #"_filecnt,1 /* broadcast and log message*/,1  /* Warning */)
		     goto failed
		  }
		  d $zu(9,"","("_mirname_") ValidateMirrorJournalLog retrieving missing file #"_filecnt,0,0  /* Informational message */)
		  s filename=1
		  if '$$RetrieveJournalFile(mirname,filecnt,0,0,1,.filename) {
		     d $zu(9,"","("_mirname_") ValidateMirrorJournalLog failed to retrieve journal file #"_filecnt_" without checking log file",1 /* broadcast and log message*/,1  /* Warning */)
		     goto failed
		  }
		  do:$G(filename(filecnt))'="" CheckStartDejournalProcessor(mirname,filecnt_","_filename(filecnt),0)
		  s rebuild=1
	   }
	}
	if rebuild {
	   s pass=2
	   s create=1
	   goto rebuild
	}
	quit 1
failed ;
	quit 0	
err ;
	s $zt=""
	d BACK^%ETN
	d $zu(9,"","ValidateMirrorJournalLog: Unexpected error: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	quit 0
}
ValidateMirrorJournalFiles(mirname, forceBecomePrimary=0) {
	/* Validate the mirror journal files which we have. This is a two
	   part process. We want to mark the end of the journal files we
	   have as valid so we can restore them to the mirrored databases. 
	   However for the files which are already marked valid, we need
	   to verify that both members agree on who created the file and
	   where the valid end is. If there is disagreement then there's a
	   problem as the databases will be out of sync across the mirror.
	   On input, ^MIRROR(mirname,"transroll") contains the 1st
	   file which we need to have. This is the 'required' journal
	   file.
	   Returns 1 = success, caller can continue
	            0 = failure, something went wrong, caller should stop
	   Sets ^MIRROR(mirname,"lastvalidjrnfile")=<mirjrncnt>^<jrnfile>
       1) Walk backwards from last journal file. Stop when we reach the required
          journal file or a journal file who's end is marked valid (this is called
          a valid journal file).
	   2) Starting with the required file or the 1st not-valid file
	   	  retrieve the end & state from "the mirror". 
	   	  State is one of: 
              Agent is down, node can't respond
              File is beyond end of log
              File is missing in log
              File has valid end
              File end is not valid
              File is current mirror journal file
           a) Agent is down => 
                forceBecomePrimary = 0 -> Report "failed to validate", Return FAILURE
                forceBecomePrimary = 1 -> mark current end as valid & log a message
           b) File is missing in other node's log file => 
                                    Report failed to validate, Return Failure
	 	   c) File is beyond the end of the other node's log file
	 		  Is this our last not-valid journal file?
	 			 -> Yes:
	                  is other node primary? yes-> big error 
	                  Mark current journal end as valid, Return SUCCESS
                 -> No: Report Error. Check to see if we can find file 
                            on other system. return FAILURE - something is wrong
                            here, the file should have been in the other node's 
                            log or it should be our last not-valid file....
           d) File is the current journal file
              Is this our last not-valid journal file?
                 -> No: Shut down mirror, big troubles, return FAILURE
                 -> Yes: Return Success
           e) If other size > our size
                 -> Retrieve missing parts of file
                 -> If end is not marked valid, set valid end to 
                     the end of file (on all nodes)
           f) other size <= our size
	 			 -> if not valid end, set valid end to
	 			 	our size otherwise set our valid
	 				end to the valid end reported by
	 				the other node.
	*/
	s $zt="err"
	k ^MIRROR(mirname,"lastvalidjrnfile")
	s minrequiredjrncnt=+^MIRROR(mirname,"transroll")
	if 'minrequiredjrncnt {
		s minrequiredjrncnt=+^MIRROR(mirname,"dejrnchkpnt")
	}
	if (forceBecomePrimary||($SYSTEM.Mirror.IsMember()=1&&$G(^MIRROR(mirname,"CheckExtraFiles")))) {
		s rc=$$CheckForExtraJournalFiles(mirname)
		if 'rc {
			quit 0
		}
	}
    k ^MIRROR(mirname,"CheckExtraFiles") ; reset., so it won't check checked again.
    ;
    s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
	if +rc<0 {
	   ; This is an error reading the log file (rc<0). This shouldn't happen. 
	   d $zu(9,"","("_mirname_") ValidateMirrorJournalFiles failed to read last journal file from mirror journal log",1 /* broadcast and log message*/,1  /* Warning */)
	   quit 0
	}
	if '+rc {
	   ; the log file exists, but its empty, this is fine
	   quit 1  ;ok, we don't have any journal files
	}
	s lastjrncnt=+rc
	s isValid=0
	s jrncnt=+rc
	s jrnfile=$P(rc,",",2)
	k filelist
	if 'minrequiredjrncnt {
		; If neither transroll nor dejrnchkpnt are defined the
		; we only need to validate the last journal file we have
		s minrequiredjrncnt=jrncnt
		s norequiredfiles=1  ;don't require any journal files
	} else {
		s norequiredfiles=0
	}
	do {
	   s rc=$$getMirJrnEnd(jrnfile)
	   if rc>0 {
		  s validend=+rc
		  s isValid=1
	   } elseif 'rc {
	      s filelist(jrncnt)=jrnfile
	      s jrncnt=jrncnt-1
	      if jrncnt>=minrequiredjrncnt {
	         s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(jrncnt,mirname)
	         if rc<=0 {
	            d $zu(9,"","("_mirname_") ValidateMirrorJournalFiles failed to read log info for file #"_jrncnt,1 /* broadcast and log message*/,1  /* Warning */)
	            quit
	         }
		     s jrnfile=$P(rc,",",2)
	      }
	   } else {
		   ; these files should already exist and be accessible
		   if '$$RetrieveJournalFile(mirname,jrncnt,0,1,1) {
			   d $zu(9,"","("_mirname_") ValidateMirrorJournalLog failed to retrieve journal file "_jrnfile_" (#"_jrncnt_")",1 /* broadcast and log message*/,1  /* Warning */)
			   quit
		   }
		   s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(jrncnt,mirname)
		   if rc<=0 {
			   d $zu(9,"","("_mirname_") ValidateMirrorJournalFiles failed to read log info for file #"_jrncnt_" after RetrieveJournalFile",1 /* broadcast and log message*/,1  /* Warning */)
			   quit
		   }
		   s jrnfile=$P(rc,",",2)
	   }
	} while (jrncnt>=minrequiredjrncnt) && ('isValid)
	if +$G(^MIRROR(mirname,"PrimaryMember"))&&isValid&&(jrncnt=lastjrncnt) {
		s jrninfo=$zu(78,22,jrnfile,99)
		if +jrninfo'=1 {
			d $zu(9,"","("_mirname_") Failed to read header of "_jrnfile_" in ValidateMirrorJournalFiles",1 /* broadcast and log message*/,1  /* Warning */)
			quit 0
		}
		s locmirend=$P(jrninfo,",",16+1)
		s loccreguid=$P(jrninfo,",",14+1)  ;mirror system guid that created jrnfile
		s jrnguid=$P(jrninfo,",",7+1)
		s rcx=$$GetJournalEnd^MIRRORCTL(mirname,+$G(^MIRROR(mirname,"PrimaryMember")),jrnguid,jrncnt)
		if $LG(rcx)=-1 {
			s errstr=$LG(rcx,2)
			if errstr["GUID "&&(errstr[" doesn't match") {
				d $zu(9,"","("_mirname_") ValidateMirrorJournalFiles: GetJournalEnd returned: "_errstr,1 /* broadcast and log message*/,1  /* Warning */)
				d $zu(9,"","This member has detected that its data is inconsistent with the mirror "_mirname_". If the primary is running and has the correct mirrored data, this member, including its mirrored databases, must be rebuilt. See 'Rebuilding a Mirror Member' in the Mirroring chapter of documentation for details.",1 /* broadcast and log message*/,2  /* Severe error */)
				s ^MIRROR(mirname,"Status","MGR")="Exit"  ; to quit the MIRRORMGR routine.
				quit 0
			}
			if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","("_mirname_") ValidateMirrorJournalFiles: GetJournalEnd returned: "_errstr)
		} elseif $LG(rcx)'=0 {
			s validflag=$LG(rcx,2)  ;1 = validend, 2 = current journal file (shouldn't happen)
			if validflag'=1 {
				if validflag=2 {
					d $zu(9,"","ValidateMirrorJournalFiles: file # "_jrncnt_", local file has valid end while it is primary's current journal.",1 /* broadcast and log message*/,1  /* Warning */)
				} else {
					d $zu(9,"","ValidateMirrorJournalFiles: file # "_jrncnt_", local file has valid end while it has not valid end in primary.",1 /* broadcast and log message*/,1  /* Warning */)
				}
				d $zu(9,"","This member has detected that its data is inconsistent with the mirror "_mirname_". If the primary is running and has the correct mirrored data, this member, including its mirrored databases, must be rebuilt. See 'Rebuilding a Mirror Member' in the Mirroring chapter of documentation for details.",1 /* broadcast and log message*/,2  /* Severe error */)
				s ^MIRROR(mirname,"Status","MGR")="Exit"  ; to quit the MIRRORMGR routine.
				quit 0
			}
			if locmirend'=$LG(rcx,3) {
				d $zu(9,"","ValidateMirrorJournalFiles: file # "_jrncnt_", local file has valid end ("_locmirend_") while it is "_$LG(rcx,3)_" in primary.",1 /* broadcast and log message*/,1  /* Warning */)
				d $zu(9,"","This member has detected that its data is inconsistent with the mirror "_mirname_". If the primary is running and has the correct mirrored data, this member, including its mirrored databases, must be rebuilt. See 'Rebuilding a Mirror Member' in the Mirroring chapter of documentation for details.",1 /* broadcast and log message*/,2  /* Severe error */)
				s ^MIRROR(mirname,"Status","MGR")="Exit"  ; to quit the MIRRORMGR routine.
				quit 0
			}
			if $LG(rcx,4)'=loccreguid {
				d $zu(9,"","ValidateMirrorJournalFiles: file # "_jrncnt_", local file has system GUID ("_loccreguid_") while it is "_$LG(rcx,4)_" in primary.",1 /* broadcast and log message*/,1  /* Warning */)
				d $zu(9,"","This member has detected that its data is inconsistent with the mirror "_mirname_". If the primary is running and has the correct mirrored data, this member, including its mirrored databases, must be rebuilt. See 'Rebuilding a Mirror Member' in the Mirroring chapter of documentation for details.",1 /* broadcast and log message*/,2  /* Severe error */)
				s ^MIRROR(mirname,"Status","MGR")="Exit"  ; to quit the MIRRORMGR routine.
				quit 0
			}
			if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","ValidateMirrorJournalFiles: file # "_jrncnt_" is last file in async member and matched with primary.")
		}
	}
	;
	if jrncnt>=minrequiredjrncnt {
		if (rc <= 0) {
			quit 0 ;some error occured
		}
		for filecnt=minrequiredjrncnt:1:jrncnt-1 {
			 s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)
	         if rc<=0 {
	            d $zu(9,"","("_mirname_") ValidateMirrorJournalFiles failed to read log info for file #"_filecnt,1 /* broadcast and log message*/,1  /* Warning */)
	            quit
	         }
		     s filename=$P(rc,",",2)			
		     s rc=$$getMirJrnEnd(filename)
		     if rc<0 {
			    quit  ;couldn't read the file, already logged a message
		     }
			 if 'rc {
				s rc=$$SetValidJournalFileEnd^MIRRORCOMM(mirname, filecnt, filename, 0, 0) ;lastflag=0,forceBecomePrimary=0
				if (rc) {
					d $zu(9,"","("_mirname_") ValidateMirrorJournalFiles set validend of file #"_filecnt_" ("_filename_", subsequent files up to "_jrncnt_" are already marked valid)",0,0  /* Informational message */)
				} else {
					d $zu(9,"","("_mirname_") ValidateMirrorJournalFiles Aborting - found end of file #"_filecnt_" ("_filename_") is not valid but subsequent files up to "_jrncnt_" are marked valid.",1 /* broadcast and log message*/,1  /* Warning */)
					quit  ;we have to stop
				}
			 }
		}
		if (rc <= 0) {
			quit 0 ;some error occured
		}
		s ^MIRROR(mirname,"lastvalidjrnfile")=jrncnt_"^"_jrnfile
		if jrncnt=lastjrncnt {
		   quit 1
		}
	}
	; jrncnt is the earliest valid file
	s rc=1
	s jrncnt=jrncnt+1  ;jrncnt is now the 1st not valid file
	for filecnt=jrncnt:1:lastjrncnt-1 {
		s jrnfile=filelist(filecnt)
		s rc=$$SetValidJournalFileEnd^MIRRORCOMM(mirname, filecnt, jrnfile, 0, forceBecomePrimary) ;lastflag=0
		q:'rc
	}
	if rc,jrncnt<=lastjrncnt {
	   s jrnfile=filelist(lastjrncnt)
	   s rc=$$SetValidJournalFileEnd^MIRRORCOMM(mirname, lastjrncnt, jrnfile, 1, forceBecomePrimary) ;lastflag=1
	}
	if 'rc && ((jrncnt<minrequiredjrncnt) || norequiredfiles) {
  	    s delrc=$ZU(78,23,jrnfile) 
  	    if 'delrc {
	  	    d $zu(9,"","Failed to delete journal file "_jrnfile_" (#"_jrncnt_") which does not have a valid end but precedes the earliest required file #"_minrequiredjrncnt,1 /* broadcast and log message*/,1  /* Warning */)
  	    } else {
	  	   	d $zu(9,"","Deleted journal file "_jrnfile_" (#"_jrncnt_") which does not have a valid end but precedes the earliest required file #"_minrequiredjrncnt,0,0  /* Informational message */)
  	        if jrncnt=lastjrncnt {
	  	       if '$SYSTEM.Mirror.TruncateMirrorLog(mirname,jrncnt) {
		  	       d $zu(9,"","Failed to remove last entry (#"_jrncnt_") from mirror journal log file",1 /* broadcast and log message*/,1  /* Warning */)
	  	       }
  	           quit $G(^MIRROR(mirname,"Status","MGR"))'="Exit"
  	        }
  	    }
	}
	quit rc  ;0/1
err ;
	s $zt=""
	d BACK^%ETN
	d $zu(9,"","ValidateMirrorJournalFiles: Unexpected error: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	quit 0
}
RetryValidateMirrorJournalLog(mirname,Type=2) PUBLIC {
	k ^MIRROR(mirname,"dejrnchkpnt")  ;set by GetMirrorDejournalInformation
	k ^MIRROR(mirname,"transroll")    ;set by ValidateMirrorJournalLog
	k ^MIRROR(mirname,"lastvalidjrnfile") ;set by ValidateMirrorJournalFiles
	s rc=$$GetMirrorDejournalInformation(mirname,Type)
	if 'rc {
	   ; strange that this fails now but it succeeded before
	   ; (eg. because we got down to ValidateMirrorJournalFiles)
	   quit 0
	}
    s rc=$$ValidateMirrorJournalLog(mirname)
    d StopDejournalProcessor(mirname,0)
    quit rc
}
RetryValidateMirrorJournalFiles(mirname) PUBLIC {
	k ^MIRROR(mirname,"dejrnchkpnt")  ;set by GetMirrorDejournalInformation
	k ^MIRROR(mirname,"transroll")    ;set by ValidateMirrorJournalLog
	k ^MIRROR(mirname,"lastvalidjrnfile") ;set by ValidateMirrorJournalFiles
	s rc=$$GetMirrorDejournalInformation(mirname)
	if 'rc {
	   ; strange that this fails now but it succeeded before
	   ; (eg. because we got down to ValidateMirrorJournalFiles)
	   quit 0
	}
    s rc=$$ValidateMirrorJournalLog(mirname)
    d StopDejournalProcessor(mirname,0)
    if 'rc {
	   ; strange that this fails now but it succeeded before
	   ; (eg. because we got down to ValidateMirrorJournalFiles)
	   quit 0
	}
	; See whether validate journal files succeeds now
	s rc=$$ValidateMirrorJournalFiles(mirname)
	quit rc
}
RetryClearActiveBackup(mirname) PUBLIC {
	s info=$G(^SYS("MIRRORSET",mirname,"Member",1))
	if info="" {
		d $zu(9,"","RetryClearActiveBackup continuing - found 2nd failover member is no longer listed",1 /* broadcast and log message*/,1  /* Warning */)
		quit 1  ; success, we can continue
	}
	s mtype=+$LG(info,8)
	if mtype'=0 {
		d $zu(9,"","RetryClearActiveBackup continuing - found member #1 (type "_mtype_") is no longer a failover member",1 /* broadcast and log message*/,1  /* Warning */)
		quit 1  ;success
	}
	s name=$lg(info,1)
	s rc=$$ClearActiveBackup^MIRRORCTL(mirname,1)
	if $LG(rc)="OK" {
		d $zu(9,"","RetryClearActiveBackup succeeded - continuing",0,0  /* Informational message */)
		quit 1
	}
	quit 0  ;continue to retry
}
RetryClearLastFileValid(mirname) PUBLIC {
	s info=$G(^SYS("MIRRORSET",mirname,"Member",1))
	if info="" {
		d $zu(9,"","RetryClearLastFileValid continuing - found 2nd failover member is no longer listed",1 /* broadcast and log message*/,1  /* Warning */)
		quit 1  ; success, we can continue
	}
	s mtype=+$LG(info,8)
	if mtype'=0 {
		d $zu(9,"","RetryClearLastFileValid continuing - found member #1 (type "_mtype_") is no longer a failover member",1 /* broadcast and log message*/,1  /* Warning */)
		quit 1  ;success
	}
	s name=$lg(info,1)
	s rc=$$ClearLastFileValidFlag^MIRRORCTL(mirname,1,0)
	if $LG(rc)="OK" {
		d $zu(9,"","RetryClearLastFileValid succeeded - continuing",0,0  /* Informational message */)
		quit 1
	}
	quit 0  ;continue to retry
}
RetryGetMissingMirrorJournalFiles(mirname) PUBLIC {
	/* this is the entry point added to the retry list when 
	   GetMissingMirrorJournalFiles fails. This entry point will retry
	   the GetMissingMirrorJournalFiles but if that fails it will also
	   re-evaluate what journal file we require in case that has
	   changed as well (eg. someone refreshed the databases from
	   a backup). 
	*/
	s rc=$$GetMissingMirrorJournalFiles(mirname)
	if rc {
		quit 1  ;succeeded!
	}
    s rc=$$RetryValidateMirrorJournalLog(mirname,$s('$G(^MIRROR(mirname,"DBDejournaled")):1,1:2))
    if 'rc {
	   quit 0   ;failed, keep retrying
	}
	q:($G(^MIRROR(mirname,"Status","MGR"))="Exit") 0
	s rc=$$GetMissingMirrorJournalFiles(mirname)
 	d StopDejournalProcessor(mirname,0)
	if rc {
		quit 1  ;succeeded!
	}
	quit 0  ;still failed, oh well.
}
GetMissingMirrorJournalFiles(mirname,forceBecomePrimary=0) PUBLIC {
	/* If the transroll point is prior to the end of the log file then
	   all of the files from the transrollpoint through last file in log 
	   exist and are valid. If the transroll point is beyond the end of
	   the log, we don't know anything about the validity of the files
	   in the log.
	   Calculate highest journal file # across ALL mirror members
	      a) if no mirror journal files => return success
	      b) if we don't have a required journal file then get the highest
	         journal file which exists and return success
          c) retrieve the files from our required point through the highest 
	         journal file in the mirror
		     -> If we fail, log a message and return FAILURE
	*/
	s $zt="err"
	s rc=$$ValidateMirrorJournalFiles(mirname,forceBecomePrimary)
	if 'rc {
		quit 0
	}
	;^MIRROR(mirname,"transroll")=<mirjrnfilecnt>^<jrnpos>
	s reqjrncnt=+$G(^MIRROR(mirname,"transroll"))
	if 'reqjrncnt {
	   s reqjrncnt=+$G(^MIRROR(mirname,"dejrnchkpnt"))
	   ; reqjrncnt might still be 0 in which case we don't
	   ; have a required journal file but we still want to
	   ; see whether the other node (if there is one) has any
	   ; journal files we don't have.
	}
	; Figure out the last file we have, if we have any, so we
	; can figure out what range of files we want to retrieve
    s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
	if +rc<0 {
	   ; This is an error reading the log file (rc<0)
	   d $zu(9,"","("_mirname_") GetMissingMirrorJournalFiles failed to read last journal file from mirror journal log",1 /* broadcast and log message*/,1  /* Warning */)
	   quit 0
	}
	s havejrncnt=+rc  ;can be 0 if the log file is empty
	s lastjrnfile=$p(rc,",",2)
	;
	s cls=##class(Config.MirrorMember).Open(,,.rc)
	if ('rc) {
		d $zu(9,"","("_mirname_") GetMissingMirrorJournalFiles failed to read mirror member configuration",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	s reportingNode=cls.isAsyncMember()
	s cls=""
	;
	s systemcnt=+$G(^SYS("MIRRORSET",mirname,"Member"))  ;0 = only us in the mirror
	if 'systemcnt {
		; we're the only node in the mirror. If we don't have the required
		; journal file then the other node must have been deleted from the mirror
		; but we still need some files from it.
		if havejrncnt<reqjrncnt {
		   quit 0
		}
		quit 1  ;we're the only member and we have the files we need!
	}
	; There is more than one node. Node #1 is always a failover member.
	; If we're a reporting node and there are 3 nodes in the mirror,
	; then node #2 is also a failover node
	s id=1
	s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
	if info="" {
        d $zu(9,"","Missing node information for member #"_id_" - GetMissingMirrorJournalFiles aborted",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
   	s name=$lg(info,1)
    s mtype=+$lg(info,8)  ;0 = failover, 2 = async
    if mtype=0 {
	  s rc=$$GetStatus^MIRRORCTL(mirname,id)
	  s status=$LG(rc)  
      if status'="PRIMARY",reportingNode {
	    ; if we're a reporting node connecting to a failover node,
	    ; then we need to reach the primary here.
	    ; Systemcnt=1 means there are 2 nodes, systemcnt=2 means
	    ; there are 3 and id #2 is the other failover node
	    if systemcnt>1 {
		    s id=2
	  	    s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
			if info="" {
	           d $zu(9,"","Missing node information for member #"_id_" - GetMissingMirrorJournalFiles aborted",1 /* broadcast and log message*/,1  /* Warning */)
		       quit 0
	        }
		 	s name=$lg(info,1)
    		s rc=$$GetStatus^MIRRORCTL(mirname,id)
    		s status=$LG(rc)  
	    }
	    if status'="PRIMARY" {
		    ; there isn't a primary so we can't continue. 
		    d $zu(9,"","No primary for "_mirname_" to provide missing journal files to async member - waiting",1 /* broadcast and log message*/,1  /* Warning */)
		    quit 0
	    }
      }
      if status="PRIMARY",$SYSTEM.Mirror.GetStatus(mirname)'="WAITING" do $SYSTEM.Mirror.SetStatus("SYNCHRONIZING",mirname)
    } else {
	    s rc=$LB(0,0)
    }
	/*  Calculate highest journal file # across ALL mirror members
	    a) if no mirror journal files => return success
	    b) if ^MIRROR(mirname,"dejrnchkpnt") is missing (we don't
	       have any jrnfile) then get only they highest jrn file in
	       the mirror
        c) retrieve the files from dejrnchkpnt through the highest 
	       journal file in the mirror
	       -> If we fail, log a message and return FAILURE
	*/
	s maxjrncnt=+$LG(rc,2)  ;might be 0 for "ERR" or "TIMEOUT"
	if 'maxjrncnt {
	   s rc=$$GetJournalInfo^MIRRORCTL(mirname,id,1) ;get min/max jrninfo
	   s status=$LG(rc)
	   if status="ERR" {
		  if (forceBecomePrimary)&(havejrncnt>=reqjrncnt) {
			   d $zu(9,"","GetMissingMirrorJournalFiles ignoring failure to contact other node, have/req (#"_havejrncnt_"/#"_reqjrncnt_")",0,0  /* Informational message */)
			   quit 1
		   }
		   d $zu(9,"","("_mirname_") GetMissingMirrorJournalFiles error /"_$LG(rc,2)_" reading min/max journal info from "_name,1 /* broadcast and log message*/,1  /* Warning */)
		   quit 0
	   }
	   if status="NOTFOUND" {
		  if havejrncnt<reqjrncnt {
		     quit 0
		  }
		  quit 1  ;success, other node doesn't have any files, we have files we need
	   }
	   s jrninfo=$LG(rc,2)
	   s maxjrncnt=$LG(jrninfo,2)
	}
	; 
	if havejrncnt>=maxjrncnt {
		if havejrncnt=maxjrncnt {
			s dejrnchkinfo=$$GetStartingDejrnPos(mirname)
			s dejrnchkcnt=+dejrnchkinfo
			s dejrnchkoff=+$P(dejrnchkinfo,"^",2)
			if havejrncnt=dejrnchkcnt {
				s fd=$zu(78,5,lastjrnfile,0) ;lastjrnfile is the havejrncnt/dejrncnhkcnt/maxjrncnt file
				s jrnendx=0  ; In case we can't open lastjrnfile to find the end
				if fd'<0 {
					do $zu(78,6,fd)
					s jrnend=$zu(78,18,0)
					s jrnendx=jrnend
					do $zu(78,7,fd)
				}
				if (fd<0) || (dejrnchkoff>jrnendx) {
					if '$$RetrieveJournalFile(mirname,dejrnchkcnt,jrnendx,1,1) {
						d $zu(9,"","("_mirname_") GetMissingMirrorJournalFiles failed to retrieve journal file #"_dejrnchkcnt_" from offset "_jrnendx,1 /* broadcast and log message*/,1  /* Warning */)
						quit 0
					}
				}
			}
		}
		quit 1
	}
	s ok=1,startoff=0
	if 'havejrncnt {
	   s startcnt=reqjrncnt
	   if 'startcnt {
		   s rc=$$GetJournalInfo^MIRRORCTL(mirname,id,5)
		   s status=$lg(rc)
		   if (status="ERR"),($LG(rc,2)["Unrecognized function") {
		      s rc=$$GetJournalInfo^MIRRORCTL(mirname,id,4)
		      s status=$lg(rc)
		      if (status="DBINFO")||(status="TRANSINFO") s status="OK"
		   }
		   if (status="OK") {
			   s startcnt=$lg(rc,2)
			   if startcnt=0 s startcnt=maxjrncnt 
		   } else {
			   s startcnt=maxjrncnt
		   }
	   }
	} else {
		s rc=$$getMirJrnEnd(lastjrnfile)
		if (rc > 0) {
			s startcnt=havejrncnt+1
		} else {
			s fd=$zu(78,5,lastjrnfile,0) ;lastjrnfile is the havejrncnt file
			if fd'<0 {
				do $zu(78,6,fd)
				s startoff=$zu(78,18,0)
				do $zu(78,7,fd)
			}
			s startcnt=havejrncnt
		}	
	}
	if startcnt<1 s startcnt=1
	s dejrnstarted=$$CheckStartDejournalProcessor(mirname,startcnt-1,0)
newfiles  ;
	for filecnt=startcnt:1:maxjrncnt {
		; retrieve the files from our dejrncnkpnt through the highest
		; file in the mirror and update the ends to be valid. We don't
		; require the last file to have a valid end if it is the current
		; file being generated on the active primary
		s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)
		if +rc=1 {
			s jrnfile=$P(rc,",",2)
			s jrninfo=$zu(78,22,jrnfile,99)
			if +jrninfo>0 goto getend
		}
	   if '$$RetrieveJournalFile(mirname,filecnt,$s(filecnt=startcnt:startoff,1:0),1,1) {
		  if 'reqjrncnt,filecnt'=maxjrncnt,$G(^MIRROR(mirname,"Status","MGR"))'="Exit" {
			  ; if we don't have a required journal file then the only
			  ; file which we really "HAVE" to retrieve is the maxjrncnt
			  ; file because we want to have that file when we connect
			  ; as a backup or become the primary so we ask for/create
			  ; the next file in the sequence.
		      d $zu(9,"","("_mirname_") Ignoring failure to retrieve missing journal file #"_filecnt,0,0  /* Informational message */)
			  continue
		  }
	      d $zu(9,"","("_mirname_") GetMissingMirrorJournalFiles failed to retrieve journal file #"_filecnt,1 /* broadcast and log message*/,1  /* Warning */)
	      s ok=0
	      quit
 	   }
 	   s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)
 	   if +rc'=1 {
	      d $zu(9,"","("_mirname_") GetMissingMirrorJournalFiles failed to lookup name for file #"_filecnt,1 /* broadcast and log message*/,1  /* Warning */)
	      s ok=0
	      quit
 	   }
 	   s jrnfile=$P(rc,",",2)
getend s lastmirjrnend=$$getMirJrnEnd(jrnfile)
	   if lastmirjrnend<0 {
		   ; error finding, opening or reading file
	      d $zu(9,"","("_mirname_") GetMissingMirrorJournalFiles failed checking valid end of file #"_filecnt,1 /* broadcast and log message*/,1  /* Warning */)
	      s ok=0
	      quit
	   }
	   if lastmirjrnend=0 {
 	      if (filecnt=maxjrncnt) {
	 	     s lastflag=1
 	      } else {
	 	     s lastflag=0
 	      }
	      if '$$SetValidJournalFileEnd^MIRRORCOMM(mirname,filecnt,jrnfile,lastflag,forceBecomePrimary) {
	         d $zu(9,"","("_mirname_") GetMissingMirrorJournalFiles failed setting valid end of file #"_filecnt,1 /* broadcast and log message*/,1  /* Warning */)
		     s ok=0
		     quit
	      }
	   } else {
		   if filecnt>(+$G(^MIRROR(mirname,"lastvalidjrnfile"))) {
			   s ^MIRROR(mirname,"lastvalidjrnfile")=filecnt_"^"_jrnfile
		   }
	   }
	   if dejrnstarted<0 {
		   s dejrnstarted=$$CheckStartDejournalProcessor(mirname,filecnt,lastmirjrnend)
	   } elseif dejrnstarted=1 {
		   s dejrnstarted=$$AddFileToDejournalProcessor(mirname,filecnt,jrnfile)
	   }
	   Quit:$SYSTEM.Mirror.GetStatus(mirname)="WAITING"
	}
	if dejrnstarted>0 {
		while '$$StopDejournalProcessor(mirname,ok),$SYSTEM.Mirror.GetStatus(mirname)'="WAITING" {
			s rc=$$GetStatus^MIRRORCTL(mirname,id)
			if $LG(rc)="PRIMARY"||($SYSTEM.Mirror.IsMember()=1&&($LG(rc)'["ERR")&&($LG(rc)'["TIMEOUT")),+$LG(rc,2)>maxjrncnt {
				s startcnt=maxjrncnt
				s maxjrncnt=+$LG(rc,2)
				s startoff=0
				if (+$g(lastmirjrnend) > 0) {
					s startcnt=startcnt+1
				} else {
					s fd=$zu(78,5,jrnfile,0) ;jrnfile is the last file retrieved
					if fd'<0 {
						do $zu(78,6,fd)
						s startoff=$zu(78,18,0)
						do $zu(78,7,fd)
					}
				}
				if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","GetMissingJournalFiles: ("_mirname_") re-retrieving journal files from "_startoff_"/"_startcnt_" to "_maxjrncnt)
				goto newfiles
			}
			q:($G(^MIRROR(mirname,"Status","MGR"))="Exit")
			h .5
			Do CheckAsyncJrnfilePurge(mirname)
		}
		s rc=$$UpdateMirrorJournalCheckPoint(mirname)
		if '+rc {
			d $zu(9,"","GetMissingMirrorJournalFiles: UpdateMirrorJournalCheckPoint failed: "_$p(rc,",",2),1 /* broadcast and log message*/,1  /* Warning */)
		}
	}
	quit ok
err ;
	s $zt=""
	d BACK^%ETN
	if +$G(dejrnstarted)>0 {
		Do StopDejournalProcessor(mirname,0)
	}
	d $zu(9,"","GetMissingMirrorJournalFiles unexpected error: "_$ze,1 /* broadcast and log message*/,1  /* Warning */)
	quit 0	
}
 /* CheckForExtraJournalFiles() is called from ValidateMirrorJournalFiles()
	when the force become primary flag is set to see whether the user has put any
	journal files into our journal directory(ies) from the failed system. If so
	we delete the mirror journal log and rebuild it so it includes these new
	files. This must be called before we start to evaluate the "valid end" of the
	last file as we base our last file decision on the mirror journal log so we
	need the list to be accurate. 
	Returns:
		 1 - Found new journal files, rebuilt the log file
		 0 - failed, some error occured
		-1 - Succeeded but not new files were found
 */
CheckForExtraJournalFiles(mirname) PUBLIC {
	s $zt="err"
	s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
	if +rc=-1 {
		; This is an error reading the log file other than the log file
		; doesn't exist. This shouldn't happen. 
		d $zu(9,"","("_mirname_") CheckForExtraJournalFiles failed to read last journal file from mirror journal log",1 /* broadcast and log message*/,2  /* Severe error */)
		quit 0
	}
	if +rc=0 {
		if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","CheckForExtraJournalFiles found journal log empty")
	}
	s lastjrnfilecnt=+rc    ;1st piece = jrnfilecnt
	s lastjrnfile=$P(rc,",",2)  ; 2nd piece = jrnfilename
	;
	/* Get mirror set GUID from the configuration. */
    s mirguid=$G(^SYS("MIRRORSET",mirname,"GUID"))
	if mirguid="" {
		d $zu(9,"","CheckForExtraJournalFiles mirror GUID for "_mirname_" not defined.",1 /* broadcast and log message*/,2  /* Severe error */)
		quit 0		; Halt here? this is pretty serious
	}
	; Go through the primary and alternate directories looking for journal files
	; from the mirror which follow the last file listed in the mirror journal log
	; If we find one, we go off to rebuild which deletes the mirror journal log
	; and then rebuilds it.
	k dirlist
	s dir=$G(^%SYS("JOURNAL","CURDIR"),"")
	if dir'="" {
		s dirlist(dir)=""
	}
	s dir=$G(^%SYS("JOURNAL","ALTDIR"),"")
	if dir'="" {
		s dirlist(dir)=""
	}
	k newfiles  ;so we know its empty
	s dir=""
	s rc=1
	for  {
		s dir=$O(dirlist(dir))
		q:dir=""
		s cdir=$ZU(12,dir)  ;it should end in a seperator now
		s jrnf=$ZSEARCH(cdir_"MIRROR-"_mirname_"-*.*")
		while (jrnf '= "") {
	 		s:$E(jrnf,*)="z" $e(jrnf,*)=""
			s sname=$case($ZBITGET($ZVERSION(0),46),0:$case($f(jrnf,";"),0:$e(jrnf,*-8-$l($p(jrnf,".",$l(jrnf,"."))),*-$case($e(jrnf,*)="z",0:0,1:1)),:$e(jrnf,*-8-$l($p(jrnf,".",$l(jrnf,"."))),$f(jrnf,";")-2)),:jrnf)
			if (sname?8N1"."3.10N0.1"z") {
				s jrninfo=$zu(78,22,jrnf,99)
				if +jrninfo<1 {
					d $zu(9,"","CheckForExtraJournalFiles failed to read header of journal file "_jrnf,1 /* broadcast and log message*/,2  /* Severe error */)
					s rc=0  ;exit loop, return failure
					quit
				}
				s jrncnt=+$P(jrninfo,",",13+1)
				s jrnmguid=$P(jrninfo,",",15+1)
				if jrnmguid'=mirguid {
					d $zu(9,"","CheckForExtraJournalFiles: GUID ("_jrnmguid_") for file "_jrnf_" doesn't match mirror guid "_mirguid,1 /* broadcast and log message*/,2  /* Severe error */)
					s rc=0  ;exit loop, return failure
					quit
				}
				if jrncnt>lastjrnfilecnt {
					s newfiles(jrncnt)=jrnf
				}
			}
			s jrnf=$ZSEARCH("")
		}
		q:'rc
	}
	if 'rc {
		quit 0  ;error
	}
	if '$D(newfiles) {
	   ; No new files found, we can continue
	   quit -1  ;-1 = success, no new files found
	}
	; Verify that there are no missing files in the newfiles list
	s prevfcnt=lastjrnfilecnt
	s prevfile=lastjrnfile
	s jrncnt=""
	s filecnt=0
	s rc=1
	for  {
		s jrncnt=$O(newfiles(jrncnt),1,jrnf)
		q:jrncnt=""
		if +jrncnt'=(prevfcnt+1) {
			if prevfcnt {
				d $zu(9,"","CheckForExtraJournalFiles found missing new journal file. Last file "_prevfile_" is #"_prevfcnt_" but next file is #"_jrncnt_" ("_jrnf_").",1 /* broadcast and log message*/,2  /* Severe error */)
				s rc=0
				quit   ;exit loop and return failure
			}
		}
		s prevfcnt=jrncnt
		s prevfile=jrnf
		s filecnt=filecnt+1
	}
	if 'rc {
		quit 0
	}
	; Add the contents of newfiles to the end of the
	; existing log.
	s logf=$ZU(12)_"mirrorjrn-"_mirname_".log"
	d $zu(9,"","Found "_filecnt_" additional journal files, adding to "_logf,0,0  /* Informational message */)
	s rc=$$AddNewFilesToJournalLog^MIRRORCOMM(mirname,.newfiles)
	if 'rc {
		quit 0
	}
	quit 1  ; 1 = success, new files found and added to log
err ;
	s $zt=""
	d $zu(9,"","CheckForExtraJournalFiles caught unexpected error: "_$ze,1 /* broadcast and log message*/,2  /* Severe error */)
	quit 0
}
GetStartingDejrnPos(mirname) {
	/* Returns mirjrnfilecnt^jrnpos of the place we can start dejournal
	   for DejournalProcessFile to apply journal data during mirror starting.
	   If the dejournal position in jrnshare structure existed then we use
	   it otherwise we used the ^MIRROR(mirname,"dejrnchkpnt") position.
	   if dejournal is blocked this retruns zero. */
	s miridx=$SYSTEM.Mirror.MirrorNameToIndex(mirname,0)+1
	if miridx<=0 Quit $G(^MIRROR(mirname,"dejrnchkpnt"))
	s shrid=+$SYSTEM.Mirror.DejournalGetSharid(miridx)
	if shrid<0 {
		d GetMirrorDejournalInformation(mirname,1)
		Quit $G(^MIRROR(mirname,"dejrnchkpnt"))
	}
	s info=$zu(78,53,shrid,64)
	s jrnoff = $p(info,",",2) s jrnfilecnt = +$p(info,",",3)
	if +info=0 || 'jrnfilecnt Quit $G(^MIRROR(mirname,"dejrnchkpnt"))
	quit jrnfilecnt_"^"_jrnoff
}
StartDejournalProcessor(mirname,filecnt,dejrnchkcnt,dejrnchkoff,filename="") {
	/* Starting the DejournalProcessor daemon.
	   The ^MIRROR(mirname,"DejournalStarted") is the state for the daemon starting status.
	       -1 : We has not started the DejournalProcessor daemon yet.
	       0  : We tried to started the daemon but there is no mirrored DB to be restored so we don't need to start it.
	       1  : The DejournalProcessor daemon is started. We are in the middle of retrieving file from primary or the other failover.
	   The ^MIRROR(mirname,"DejournalProcessor") indicates whether the DejournalProcessor is running or not.
	       0  : The DejournalProcessor is not running.
	       Non-Zero : The PID of the DejournalProcessor daemon is running.
	   The ^MIRROR(mirname,"DejournalFile") is the file count of the last journal file has been put in the array.
	   The ^MIRROR(mirname,"DejournalFile",jrnfcnt) is the array of all journal files retrieved and
           waiting for DejournalProcessor to process, after it processed it it will be removed by DejournalProcessor.
       The above nodes are protected by ^MIRROR(mirname,"DejournalProcessor") lock.
	*/
	if filename'="",filecnt'=dejrnchkcnt {
		d $zu(9,"","StartDejournalProcessor: mismatched file count ("_filecnt_" vs "_dejrnchkcnt_") when file name ("_filename_") is not null",1 /* broadcast and log message*/,1  /* Warning */)
		Quit $G(^MIRROR(mirname,"DejournalStarted"),-1)
	}
	s rc=$$CheckReinitDejournal(mirname)
	if rc<=0 {
		if 'rc if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","StartDejournalProcessor: Dejournaling is stopped")
		Quit $G(^MIRROR(mirname,"DejournalStarted"),-1)
	}
	if rc > 1 d $zu(9,"","StartDejournalProcessor: re-initialized dejournal memory",0,0  /* Informational message */)
	Try {
		Lock +^MIRROR(mirname,"DejournalProcessor")
		s ^MIRROR(mirname,"DejournalStarted")=1
		if $d(^MIRROR(mirname,"DejournalFile"))>=10||(+$G(^MIRROR(mirname,"DejournalProcessor"))'=0) {
			d $zu(9,"","StartDejournalProcessor: DejournalProcessor is running when it should not. Stopping the daemon!",1 /* broadcast and log message*/,1  /* Warning */)
			Lock -^MIRROR(mirname,"DejournalProcessor")
			Do StopDejournalProcessor(mirname,0)
			Lock +^MIRROR(mirname,"DejournalProcessor")
			s ^MIRROR(mirname,"DejournalStarted")=1
		}
		k ^MIRROR(mirname,"DejournalFile")
		s ok=1
		s offset=dejrnchkoff
		for i=dejrnchkcnt:1:filecnt {
			s rc=$s(filename="":$SYSTEM.Mirror.GetJournalFileByMjrncnt(i,mirname),1:"1,"_filename)
			if (+rc < 1) {
				k ^MIRROR(mirname,"DejournalFile")
				d $zu(9,"","("_mirname_") StartDejournalProcessor failed to lookup name for file #"_i_" - Skipped starting dejournal process",1 /* broadcast and log message*/,1  /* Warning */)
				s ^MIRROR(mirname,"DejournalStarted")=-1
				Lock -^MIRROR(mirname,"DejournalProcessor")
				s ok=0
				quit
			}
			s xjrnfile=$P(rc,",",2)
			s ^MIRROR(mirname,"DejournalFile",i)=offset_","_xjrnfile
			s offset=0  ;after 1st file, start the rest at the beginning
		}
		if ok {
			s ^MIRROR(mirname,"DejournalFile")=filecnt
			job DejournalProcessor^MIRRORMGR(mirname)::3
			If '$T {
				k ^MIRROR(mirname,"DejournalFile")
				s ^MIRROR(mirname,"DejournalStarted")=-1
				Lock -^MIRROR(mirname,"DejournalProcessor")
				d $zu(9,"","("_mirname_") StartDejournalProcessor failed to start dejournal process",1 /* broadcast and log message*/,1  /* Warning */)
			} else {
				Lock -^MIRROR(mirname,"DejournalProcessor")
				for i=1:1:30 s running=$$IsDejournalProcessorRunning(mirname) q:running||($G(^MIRROR(mirname,"Status","MGR"))="Exit")  h 1
				if 'running {
					Lock +^MIRROR(mirname,"DejournalProcessor")
					s ^MIRROR(mirname,"DejournalStarted")=-1
					kill ^MIRROR(mirname,"DejournalFile")
					Lock -^MIRROR(mirname,"DejournalProcessor")
					d $zu(9,"","("_mirname_") StartDejournalProcessor dejournal job failed to start",1 /* broadcast and log message*/,1  /* Warning */)
				}
			}
		}
	} catch errv {
		k ^MIRROR(mirname,"DejournalFile")
		s ^MIRROR(mirname,"DejournalStarted")=-1
		L -^MIRROR(mirname,"DejournalProcessor")
		s errtext=errv.Name_" at "_errv.Location
		d $zu(9,"","StartDejournalProcessor error "_errtext,1 /* broadcast and log message*/,1  /* Warning */)
	}
	quit ^MIRROR(mirname,"DejournalStarted")	   
}
StopDejournalProcessor(mirname,checkmore) {
	/* Stop DejournalProcessor daemon, the 'checkmore' is set when the caller wants
	   to see if there are files left for daemon to process, if it is then return 0
	   to indicate the daemon is not down yet, the caller can continue to find more
	   file to dejournal. But if there is no more file to be processed then we wait
	   for the daemon to finish its curent file.
	   Return 0 - daemon is not stopped when checkmore is set.
	          1 - daemon is down. */
	if $G(^MIRROR(mirname,"DejournalStarted"),-1)<0 Quit 1
	Lock +^MIRROR(mirname,"DejournalProcessor")
	if checkmore,$d(^MIRROR(mirname,"DejournalFile"))>=10,$G(^MIRROR(mirname,"DejournalProcessor")) {
		Lock -^MIRROR(mirname,"DejournalProcessor")
		Quit 0
	}
	Kill ^MIRROR(mirname,"DejournalFile")
	Set ^MIRROR(mirname,"DejournalStarted")=-1
	Lock -^MIRROR(mirname,"DejournalProcessor")
	if 'checkmore {
		q:($G(^MIRROR(mirname,"Status","MGR"))="Exit") 1
		s miridx=$SYSTEM.Mirror.MirrorNameToIndex(mirname,0)+1
		if miridx>0 {
			s shrid=+$SYSTEM.Mirror.DejournalGetSharid(miridx)
			if shrid>=0 {
				do $ZU(78,53,shrid,16,1) ;stop reader job
				do $zu(78,53,shrid,0,1)
			}
		}
	}
	While $$IsDejournalProcessorRunning(mirname) {
		q:($G(^MIRROR(mirname,"Status","MGR"))="Exit")
		h 0.5
	}
	if 'checkmore,miridx>0,shrid>=0 {
		do $ZU(78,53,shrid,16,0) ;clear jshrdstop job
		do $zu(78,53,shrid,0,0)
		s rc=$$UpdateMirrorJournalCheckPoint(mirname)
		if '+rc {
			d $zu(9,"","StopDejournalProcessor: UpdateMirrorJournalCheckPoint failed: "_$p(rc,",",2),1 /* broadcast and log message*/,1  /* Warning */)
		}
	}
	Quit 1
}
IsDejournalProcessorRunning(mirname) {
	/* Check if DejournalProcessor is still running.
	   Return non-zero if it is running. */
	Lock +^MIRROR(mirname,"DejournalProcessor")
	s pid=+$G(^MIRROR(mirname,"DejournalProcessor"))
	Lock -^MIRROR(mirname,"DejournalProcessor")
	quit pid
}
AddFileToDejournalProcessor(mirname,filecnt,jrnfile) {
	/* This is called to add a journal file to be dejournaled by DejournalProcessor daemon.
	   It is called when ^MIRROR(mirname,"DejournalStarted")is 1. It returns the current
	   value of ^MIRROR(mirname,"DejournalStarted") in case we found the DejournalProcessor
	   daemon dies due to error occurred in DejournalProcessor daemon. */
	s rc=$$CheckReinitDejournal(mirname)
	if rc'=1 {
		do StopDejournalProcessor(mirname,0)
		if 'rc if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","AddFileToDejournalProcessor: Dejournaling is stopped")
		Quit -1
	}
	Lock +^MIRROR(mirname,"DejournalProcessor")
	if '+$G(^MIRROR(mirname,"DejournalProcessor")) {
		s ^MIRROR(mirname,"DejournalStarted")=-1
		k ^MIRROR(mirname,"DejournalFile")
		Lock -^MIRROR(mirname,"DejournalProcessor")
		Quit -1
	}
	if filecnt'=($G(^MIRROR(mirname,"DejournalFile"))+1),filecnt'=$G(^MIRROR(mirname,"DejournalFile")) {
		Lock -^MIRROR(mirname,"DejournalProcessor")
		d $zu(9,"","AddFileToDejournalProcessor: the file ("_filecnt_") to be added not following previous file ("_$G(^MIRROR(mirname,"DejournalFile"))_"), stopping DejournalProcessor.",1 /* broadcast and log message*/,1  /* Warning */)
		Do StopDejournalProcessor(mirname,0)
		Quit -1
	}
	s ^MIRROR(mirname,"DejournalFile")=filecnt
	s ^MIRROR(mirname,"DejournalFile",filecnt)="0,"_jrnfile
	Lock -^MIRROR(mirname,"DejournalProcessor")
	if filecnt#5=0 Do CheckAsyncJrnfilePurge(mirname)
	Quit 1
}
CheckStartDejournalProcessor(mirname,lastfilecnt=0,lastfilevalidend=0) {
	/* Check if we can start the DejournalProcessor daemon.
       If starting dejournal position is earlier than the last journal file then we can start it. */
    if '+$G(^SYS("MIRRORSET",mirname,"Member"))||($SYSTEM.Mirror.GetStatus(mirname)="WAITING") Quit $G(^MIRROR(mirname,"DejournalStarted"),-1)
startdejrn ;
	s dejrnstarted=$G(^MIRROR(mirname,"DejournalStarted"),-1)
	if dejrnstarted<0 {
		s x=$$GetStartingDejrnPos(mirname)
		if '+x {
			s ^MIRROR(mirname,"DejournalStarted")=0
			if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","CheckStartDejournalProcessor: dejrnchkcnt is 0, dejournaling not required")
		} elseif +$G(^MIRROR(mirname,"DejournalBlock"))=1 {
			s ^MIRROR(mirname,"DejournalStarted")=-1
			if $G(^||MIRROR(mirname,"DejournalRunning")) {
				k ^MIRROR(mirname,"DejournalRunning")
				k ^||MIRROR(mirname,"DejournalRunning")
			}
			if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","CheckStartDejournalProcessor: Dejournal is stopped, DejournalProcessor won't be started")
		} else {
			if lastfilecnt {
				s rc=$s($L(lastfilecnt,",")>1:lastfilecnt,1:$SYSTEM.Mirror.GetJournalFileByMjrncnt(lastfilecnt,mirname))
				s fcnt=$s(+rc>0:+lastfilecnt,1:0)
			} else {
				s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
				s fcnt=+rc
		    }
			if fcnt>0 {
				s:lastfilevalidend=0&&($$getMirJrnEnd($p(rc,",",2))'>0) fcnt=fcnt-1
				if fcnt>=(+x) {
					s rc=$$StartDejournalProcessor(mirname,fcnt,+x,$p(x,"^",2),$p(lastfilecnt,",",2))
					if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","CheckStartDejournalProcessor: StartDejournalProcessor returned "_rc)
				}
			}
		}
	} elseif dejrnstarted>0 {
		s rc=$$CheckReinitDejournal(mirname)
		if rc'=1 {
			do StopDejournalProcessor(mirname,0)
			if 'rc if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","CheckStartDejournalProcessor: Dejournaling is stopped")
			Quit:rc'=2 $G(^MIRROR(mirname,"DejournalStarted"),-1)
			goto startdejrn
		}
		if lastfilecnt {
			s rc=$s($L(lastfilecnt,",")>1:lastfilecnt,1:$SYSTEM.Mirror.GetJournalFileByMjrncnt(lastfilecnt,mirname))
			s fcnt=$s(+rc>0:+lastfilecnt,1:0)
		} else {
			s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
			s fcnt=+rc
	    }
		s:lastfilevalidend=0&&($$getMirJrnEnd($p(rc,",",2))'>0) fcnt=fcnt-1
		if fcnt>$G(^MIRROR(mirname,"DejournalFile")) {
			Lock +^MIRROR(mirname,"DejournalProcessor")
			if '+$G(^MIRROR(mirname,"DejournalProcessor")) {
				s ^MIRROR(mirname,"DejournalStarted")=-1
				k ^MIRROR(mirname,"DejournalFile")
				Lock -^MIRROR(mirname,"DejournalProcessor")
				d $zu(9,"","CheckStartDejournalProcessor: DejournalProcessor daemon not running, restart it.",1 /* broadcast and log message*/,1  /* Warning */)
				goto startdejrn
			}
			s failed=0,chkpurge=0
			for i=$G(^MIRROR(mirname,"DejournalFile"))+1:1:fcnt {
				if i=fcnt {
					s jrnfile=$p(rc,",",2)
				} else {
					s jrnfile=$SYSTEM.Mirror.GetJournalFileByMjrncnt(i,mirname)
					if +jrnfile<=0 {
						d $zu(9,"","CheckStartDejournalProcessor: Failed to find file count "_i_" in log file.",1 /* broadcast and log message*/,1  /* Warning */)
						s failed=1
						quit
					}
					s jrnfile=$p(jrnfile,"^",2)
				}
				s ^MIRROR(mirname,"DejournalFile",i)="0,"_jrnfile
				if i#5=0 s chkpurge=1
			}
			s ^MIRROR(mirname,"DejournalFile")=fcnt
			Lock -^MIRROR(mirname,"DejournalProcessor")
			i failed {
				Do StopDejournalProcessor(mirname,0)
				goto startdejrn
			}
			Do:chkpurge CheckAsyncJrnfilePurge(mirname)
		}
    }
    quit $G(^MIRROR(mirname,"DejournalStarted"),-1) 
}
DejournalProcessor(mirname) PUBLic {
	L +^MIRROR(mirname,"DejournalProcessor")
	if $G(^MIRROR(mirname,"DejournalProcessor"),0) {
		L -^MIRROR(mirname,"DejournalProcessor")
		d $zu(9,"","Dejournal Processor for "_mirname_" already running by PID "_$G(^MIRROR(mirname,"DejournalProcessor")),1 /* broadcast and log message*/,1  /* Warning */)
		quit
	}
	if $G(^MIRROR(mirname,"DejournalStarted"),-1)'>0 {
		L -^MIRROR(mirname,"DejournalProcessor")
		d $zu(9,"","Dejournal Processor for "_mirname_" is not started by master daemon.",1 /* broadcast and log message*/,1  /* Warning */)
		quit
	}
	s ^MIRROR(mirname,"DejournalProcessor")=+$j
	L -^MIRROR(mirname,"DejournalProcessor")
	if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","DejournalProcessor started")
	s PurgeFile=$System.Mirror.IsAsyncMember()&&$System.Mirror.AsyncMemberType()&&'$G(^SYS("MIRRORSET",0,"AsyncUseSystemPurgeInterval"))
	s miridx=$SYSTEM.Mirror.MirrorNameToIndex(mirname,1)+1
	s skip=0
	if miridx>0 {
	   s shrid=+$SYSTEM.Mirror.DejournalGetSharid(miridx)
	   ; returns shrid which is 0->n or -1 if there's a problem 
	   if shrid<0 {
		  d $zu(9,"","DejournalProcessor - Failed to locate sharid for primary id #"_miridx,1 /* broadcast and log message*/,1  /* Warning */)
		  L +^MIRROR(mirname,"DejournalProcessor")
		  k ^MIRROR(mirname,"DejournalFile"),^MIRROR(mirname,"DejournalProcessor")
		  L -^MIRROR(mirname,"DejournalProcessor")
		  Quit
	   } else {
		   s prefstrategy=$G(^MIRROR(":config:","PrefetchCatchupStrategy"),-10000)
		   do $ZU(78,90,shrid,prefstrategy)
		   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","DejournalProcessor set prefetch chunk size for sharid #"_shrid_" to "_(-prefstrategy))
	   }
	}
	s rc=##class(SYS.Mirror).GetDejournalFilterSetting(mirname,.filter)
	if ('rc) {
		d $zu(9,"","DejournalProcessor: ("_mirname_") failed to get filter setting, error="_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
		L +^MIRROR(mirname,"DejournalProcessor")
		k ^MIRROR(mirname,"DejournalFile"),^MIRROR(mirname,"DejournalProcessor")
		L -^MIRROR(mirname,"DejournalProcessor")
		Quit
	}
	if filter'="" {
		s FilterObj=$classmethod(filter,"%New")
		if '$isobject(FilterObj) {
			d $zu(9,"","DejournalProcessor: ("_mirname_") failed to run %New() method of class "_filter,1 /* broadcast and log message*/,1  /* Warning */)
			L +^MIRROR(mirname,"DejournalProcessor")
			k ^MIRROR(mirname,"DejournalFile"),^MIRROR(mirname,"DejournalProcessor")
			L -^MIRROR(mirname,"DejournalProcessor")
			Quit
		}
		s FilterObj.InCatchupDB = 0
		if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","DejournalProcessor: ("_mirname_") is running filter class "_filter)
	}
	s PrevDejrn=0
	try {
		for {
			s jrnfcnt=$o(^MIRROR(mirname,"DejournalFile",""),1,data)
			if jrnfcnt="" {
				L +^MIRROR(mirname,"DejournalProcessor")
				if $G(^MIRROR(mirname,"DejournalStarted"),-1)>0 {
					if $d(^MIRROR(mirname,"DejournalFile"))<10 h 1
					L -^MIRROR(mirname,"DejournalProcessor")
					continue
				}
				k ^MIRROR(mirname,"DejournalFile"),^MIRROR(mirname,"DejournalProcessor") 
				L -^MIRROR(mirname,"DejournalProcessor")
				quit
			}
			if skip k ^MIRROR(mirname,"DejournalFile",jrnfcnt) continue
			if +PrevDejrn=1 {
				s prevjrnfile=$p(PrevDejrn,",",2),prevfcnt=$p(PrevDejrn,",",3),prevoff=$p(PrevDejrn,",",4)
				s prevalidend=$$getMirJrnEnd(prevjrnfile)
				if jrnfcnt=(prevfcnt+1)||(prevfcnt=jrnfcnt) {
					if prevalidend<=0 {
						d $zu(9,"","DejournalProcessor: Previous file "_prevjrnfile_" without valid end. Count="_prevfcnt_" Offset="_prevoff_". Abort!!!",1 /* broadcast and log message*/,1  /* Warning */)
						s skip=1 k ^MIRROR(mirname,"DejournalFile",jrnfcnt)
						continue
					}
					s jrnfcnt=prevfcnt
					s data=prevoff_","_prevjrnfile
				} else {
					d $zu(9,"","DejournalProcessor: Next file ("_jrnfcnt_") does not follow previous file ("_prevfcnt_"). Abort!!!",1 /* broadcast and log message*/,1  /* Warning */)
					s skip=1 k ^MIRROR(mirname,"DejournalFile",jrnfcnt)
					continue
				}
			} elseif +PrevDejrn=2 {
				s prevfcnt=$p(PrevDejrn,",",3)
				if jrnfcnt=prevfcnt {
					k ^MIRROR(mirname,"DejournalFile",jrnfcnt)
					continue
				}
				if jrnfcnt'=(prevfcnt+1) {
					d $zu(9,"","DejournalProcessor: Next file ("_jrnfcnt_") does not follow previous file ("_prevfcnt_"). Abort!!!",1 /* broadcast and log message*/,1  /* Warning */)
					s skip=1 k ^MIRROR(mirname,"DejournalFile",jrnfcnt)
					continue
				}
			}
			s jrnfile=$p(data,",",2),startoff=+data
			d $zu(9,"","DejournalProcessor: Applying journal data for mirror """_mirname_""" starting at "_startoff_" in file #"_jrnfcnt_ "("_jrnfile_")",0,0  /* Informational message */)
			if filter'="" {
				s rc=FilterObj.DejournalProcessFile(miridx,startoff,jrnfile,jrnfcnt)
			} else {
				d ##class(%SYS.Journal.System).GetDejournalReaderSettings(.cachesize,.readahead,.disableaio) 
				s rc=$SYSTEM.Mirror.DejournalProcessFile(miridx,startoff,jrnfile,jrnfcnt,cachesize,readahead,disableaio)
			}
			if +rc<=0 {
				if (rc=-257||(rc=-259))&&($G(^MIRROR(mirname,"DejournalStarted"),-1)<0) {
					d $zu(9,"","("_mirname_") DejournalProcessor is stopped while dejournaling file #"_jrnfcnt_" ("_jrnfile_")",0,0  /* Informational message */)
				} else {
					d $zu(9,"","("_mirname_") DejournalProcessor error ("_rc_") dejournaling from file #"_jrnfcnt_" ("_jrnfile_")",1 /* broadcast and log message*/,1  /* Warning */)
				}
				s skip=1
			} else {
				Try {
					s info=$zu(78,53,shrid,64)
					s NoSync=+info
				} catch {
					s NoSync=0
				}
				s:'$G(^MIRROR(mirname,"DBDejournaled")) ^MIRROR(mirname,"DBDejournaled")=1
				s validend=$$getMirJrnEnd(jrnfile)
				if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","DejournalProcessor: DejournalProcessFile returned "_rc_" NoSync="_$G(info,"")_" validend="_validend)
				if validend=0 {
					s PrevDejrn="1,"_jrnfile_","_$p(rc,",",2)_","_$s(NoSync:$p(info,",",2),1:$p(rc,",",3))
				} elseif validend>0 {
					s PrevDejrn="2,"_jrnfile_","_$p(rc,",",2,3)
					if validend'=$p(rc,",",3) {
						s $p(PrevDejrn,",",1)=1
						s $p(PrevDejrn,",",4)=$s(NoSync:$p(info,",",2),1:$p(rc,",",3))
					} elseif $G(PurgeFile) {
						s ^MIRROR(mirname,"PendingPurgeList",jrnfcnt)=""
					}
				} elseif validend=-1 {
					d $zu(9,"","DejournalProcessor: Failed to open journal file #"_jrnfcnt_ "("_jrnfile_")",1 /* broadcast and log message*/,1  /* Warning */)
					s skip=1
				}
			}
			k ^MIRROR(mirname,"DejournalFile",jrnfcnt)
		}
	} catch errv {
		L +^MIRROR(mirname,"DejournalProcessor")
		k ^MIRROR(mirname,"DejournalFile"),^MIRROR(mirname,"DejournalProcessor")
		L -^MIRROR(mirname,"DejournalProcessor")
		s errtext=errv.Name_" at "_errv.Location
		d $zu(9,"","DejournalProcessor error "_errtext,1 /* broadcast and log message*/,1  /* Warning */)
	}
}
RetrySetLastFileValidFlag(mirname) PUBLIC {
	d ValidateMirrorJournalFiles(mirname)
	quit $$SetLastFileValidFlag(mirname)
}
SetLastFileValidFlag(mirname) PUBLIC {
	/* Set $SYSTEM.Mirror.LastFileValidFlag() = 0/1
	   Called after we retrieve the missing journal files (if any) to
	   check the valid/not valid status of the last file we have. The
	   valid/not valid flag controls whether we can become the primary or
	   not during startup. If this is clear we can become the backup but
	   not a primary.
    */
	do $SYSTEM.Mirror.LastFileValidFlag(0)  ; start with not valid
	s $zt="err"
    s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
	if +rc<0 {
	   ; This is an error reading the log file (rc<0)
	   d $zu(9,"","("_mirname_") SetLastFileValidFlag failed to read last journal file from mirror journal log",1 /* broadcast and log message*/,1  /* Warning */)
	   quit 0
	}
	if rc=0 {
		s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
		if 'systemcnt {
			; if there aren't any files and we're the only mirror
			; member then flag the last file as valid as otherwise
			; we won't become the primary (we'll become a backup 
			; since the last file isn't valid...)
		    ; [JAO] Review this with Simon
		}
		do $SYSTEM.Mirror.LastFileValidFlag(1)  ; its valid
		if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","LastFileValidFlagSet: Failed to read last file from journal file log")
		quit 1  ;its ok if we don't have any files
	}
	s jrnfilecnt=+rc
	s jrnfile=$P(rc,",",2)
 	s rc=$$getMirJrnEnd(jrnfile)
	if rc<0 {
	   ; error finding, opening or reading file
	   d $zu(9,"","("_mirname_") SetLastFileValidFlag failed checking valid end of file #"_jrnfile,1 /* broadcast and log message*/,1  /* Warning */)
	   quit 0
	}
	if rc {
		s expectedlastvalidfile=$G(^MIRROR(mirname,"lastvalidjrnfile"))
		if jrnfilecnt'=+expectedlastvalidfile {
			d $zu(9,"","("_mirname_") SetLastFileValidFlag found file #"_jrnfilecnt_" as the last file when """_expectedlastvalidfile_""" was expected.",1 /* broadcast and log message*/,1  /* Warning */)
			quit 0
		}
		if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","LastFileValidFlagSet: "_jrnfile_" has a valid end of "_rc)
		do $SYSTEM.Mirror.LastFileValidFlag(1)  ; its valid
	}
	quit 1  ;success, even though last file isn't valid
err ;
	s $zt=""
	d BACK^%ETN
	d $zu(9,"","SetLastFileValidFlag unexpected error: "_$ze,1 /* broadcast and log message*/,1  /* Warning */)
	quit 0	
}
RetryApplyJournalFiles(mirname) PUBLIC {
	/* this is the entry point added to the retry list when 
	   ApplyJournalFiles fails. This entry point will retry
	   the ApplyJournalFiles but if that fails it will also
	   re-evaluate what journal file we require in case that has
	   changed as well (eg. someone refreshed the databases from
	   a backup). 
	*/
	s rc=$$ApplyJournalFiles(mirname)
	if rc=1 {
		quit 1  ;succeeded!
	} elseif rc'=0 {
		s rc=$$RetryValidateMirrorJournalFiles(mirname)
		if rc=1 quit 1
		;SML2489 ;if $SYSTEM.Mirror.GetStatus(mirname)="SYNCHRONIZING" d $SYSTEM.Mirror.SetStatus("WAITING",mirname)
		quit 0
	}
	s rc=$$UpdateMirrorJournalCheckPoint(mirname)
    if 'rc {
	   quit 0   ;failed, keep retrying
	}
	s rc=$$ApplyJournalFiles(mirname)
	if rc=1 {
		quit 1  ;succeeded!
	} elseif rc'=0 {
		s rc=$$RetryValidateMirrorJournalFiles(mirname)
		if rc=1 quit 1
		quit 0
	}
	quit 0  ;still failed, oh well.
}
ApplyJournalFilesDaemon(miridx,mirname) PUBLIC {
	s EvN=mirname_$zparent
	if $e(EvN)?1N s EvN="M"_EvN
	s $zt="err"
	s x=$SYSTEM.Event.Signal(EvN)
	for  {
		s msg=$SYSTEM.Event.WaitMsg()
		s msg=$LG(msg,2),cmd=$LG(msg)
		if cmd="Q" quit
		if cmd="P" {
			s rc=##class(SYS.Mirror).GetDejournalFilterSetting(mirname,.filter)
			if ('rc) {
				d $zu(9,"","ApplyJournalFilesDaemon ("_mirname_") failed to get filter setting, error="_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
				s x=$SYSTEM.Event.Signal(EvN,0)
				continue
			}
			s startoff=$LG(msg,2)
			s jrnfile=$LG(msg,3)
			s filecnt=$LG(msg,4)
			d $zu(9,"","Applying journal data for mirror """_mirname_""" starting at "_startoff_" in file #"_filecnt_ "("_jrnfile_")",0,0  /* Informational message */)
			if filter'="" {
				s FilterObj=$classmethod(filter,"%New")
				if '$isobject(FilterObj) {
					d $zu(9,"","ApplyJournalFilesDaemon ("_mirname_") failed to run %New() method of class "_filter,1 /* broadcast and log message*/,1  /* Warning */)
					s x=$SYSTEM.Event.Signal(EvN,0)
					continue
				}
				s FilterObj.InCatchupDB = 0
		   		if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","ApplyJournalFilesDaemon ("_mirname_") is running filter class "_filter)
		   		s rc=FilterObj.DejournalProcessFile(miridx,startoff,jrnfile,filecnt)
		   	} else {
				d ##class(%SYS.Journal.System).GetDejournalReaderSettings(.cachesize,.readahead,.disableaio) 
				s rc=$SYSTEM.Mirror.DejournalProcessFile(miridx,startoff,jrnfile,filecnt,cachesize,readahead,disableaio)
		   	}
		   	if +rc<=0 {
			   	d $zu(9,"","("_mirname_") ApplyJournalFilesDaemon error ("_rc_") dejournaling from file: "_filecnt,1 /* broadcast and log message*/,1  /* Warning */)
		   	}
		   	s x=$SYSTEM.Event.Signal(EvN,rc)
		} elseif cmd="S" {
			s jrnfile=$LG(msg,2)
			s shrid=$LG(msg,3)
			s dejrnfilepos=$LG(msg,4)
			try {
				s rc=$SYSTEM.Mirror.DejournalProcessFileSync(jrnfile,shrid,dejrnfilepos)
			} catch { s rc = "0,"_$ZE }
			s x=$SYSTEM.Event.Signal(EvN,rc)
		} else {
			d $zu(9,"","ApplyJournalFilesDaemon received unknown command '"_cmd_"'",1 /* broadcast and log message*/,1  /* Warning */)
		}
	}
	q
err s $zt=""
	d $zu(9,"","ApplyJournalFilesDaemon caught error $ZE="_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	s x=$SYSTEM.Event.Signal(EvN,"0,"_$ZE)
	q
}
RequestApplyJournalFiles(AJDaemon,EvN,Msg) {
	s x=$SYSTEM.Event.Signal(AJDaemon,Msg)
wait	
	s rc=$SYSTEM.Event.WaitMsg(EvN,2)
	if '$LG(rc) {
		i '$zu(67,AJDaemon) {
			d $zu(9,"","ApplyJournalFilesDaemon "_AJDaemon_" died unexpectedly",1 /* broadcast and log message*/,1  /* Warning */)
			quit 0
		}
		g wait
	}
	quit $LG(rc,2)
}
ApplyJournalFiles(mirname) PUBLIC {
	/* Apply any journaling data we have, which has not yet been applied,
	   to the mirrored databases.
	   Returns -1 = failed, retry starting with ValidateJournalFiles (JO2359)
	            0 = failed, retry ApplyJournalFiles
	            1 = ok - all journal data we have has been applied.
	                ^MIRROR(mirname,"dejrnchkpnt")=<mir jrn cnt>^<jrnpos>
	                ^MIRROR(mirname,"transroll")=<mir jrn cnt>^<jrnpos>
	    ^MIRROR(mirname,"lastvalidjrnfile")=<mir jrn cnt>^<journal file name> 
	    			is the file where we can stop. We know this is a valid
	    			journal file because the code that sets this node is careful
	    			not to set it if the file doesn't have a valid end.
	*/
	s $zt="err"
	s startfilecnt=$G(^MIRROR(mirname,"dejrnchkpnt"))  ;filecnt^pos
	if '+startfilecnt quit 1
	s startoff=+$P(startfilecnt,"^",2)
	s startfilecnt=+startfilecnt
	s cls=##class(Config.MirrorMember).Open(,,.rc)
	if ('rc) {
		d $zu(9,"","ApplyJournalFiles failed failed to read mirror member configuration",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	s reportingNode=cls.isAsyncMember()
	s cls=""
	if reportingNode {
		if +$G(^MIRROR(mirname,"DejournalBlock"))=1 {
			if $G(^||MIRROR(mirname,"DejournalRunning")) {
				k ^MIRROR(mirname,"DejournalRunning")
				k ^||MIRROR(mirname,"DejournalRunning")
			}
			 if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","ApplyJournalFiles skipped - DejournalBlock flag is set on reporting member")
			 quit 1
		}
		if $SYSTEM.Mirror.GetStatus(mirname)'="WAITING" d $SYSTEM.Mirror.SetStatus("SYNCHRONIZING",mirname)
	}
	;
	if $G(^MIRROR(mirname,"Status","MGR"))="Exit" Quit 0
	s PurgeFile=reportingNode&&$System.Mirror.AsyncMemberType()&&'$G(^SYS("MIRRORSET",0,"AsyncUseSystemPurgeInterval"))
	s miridx=$SYSTEM.Mirror.MirrorNameToIndex(mirname,0)+1
	if miridx>0 {
		Lock +^MIRROR(mirname,"DejournalBlock")
		s rc=$$CheckReinitDejournal(mirname)
		if rc<=0 {
			Lock -^MIRROR(mirname,"DejournalBlock")
			if 'rc if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","ApplyJournalFiles: Dejournaling is stopped")
			Quit -1
		}
		s shrid=+$SYSTEM.Mirror.DejournalGetSharid(miridx)
		s startfilecnt=$G(^MIRROR(mirname,"dejrnchkpnt"))  ;filecnt^pos
		s startoff=+$P(startfilecnt,"^",2)
		s startfilecnt=+startfilecnt
		Lock -^MIRROR(mirname,"DejournalBlock")
	   ; returns shrid which is 0->n or -1 if there's a problem 
	   if shrid<0 {
		   d $zu(9,"","ApplyJournalFiles - Failed to locate sharid for primary id #"_miridx_ " - halting",1 /* broadcast and log message*/,3  /* Fatal */)
		   halt
       }
	   s prefstrategy=$G(^MIRROR(":config:","PrefetchCatchupStrategy"),-10000)
	   /* Need to trap <FUNCTION> error in case the jrnshare is freed. */
	   Try { do $ZU(78,90,shrid,prefstrategy) } catch {}
	   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","ApplyJournalFiles set prefetch chunk size for sharid #"_shrid_" to "_(-prefstrategy))
	   Try {
		   s info=$zu(78,53,shrid,64)
		   if +info {
			   s newstartoff = $p(info,",",2) s newstartfilecnt = +$p(info,",",3)
			   if newstartfilecnt > startfilecnt || (newstartfilecnt=startfilecnt && (newstartoff>startoff)) {
				   if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","ApplyJournalFiles: start position changed from "_startoff_"/"_startfilecnt_" to "_newstartoff_"/"_newstartfilecnt)
				   s startfilecnt = newstartfilecnt
				   s startoff = newstartoff
			   }
		   }
       } Catch {}
    } else {
	   d $zu(9,"","ApplyJournalFiles - Failed to locate miridx for mirror /"_mirname_ "/ - halting",1 /* broadcast and log message*/,3  /* Fatal */)
	   halt
	}
	s info=$G(^MIRROR(mirname,"lastvalidjrnfile"))  ;<mirjrncnt>^<filename>
	if info'="" {
	   s lastjrnfile=$P(info,"^",2)
	   s lastjrnfilecnt=+info
	} else {
		; If we don't have a lastvalidjrnfile it could be because
		; our start file is the current journal file on the active
		; primary. This is true if the dejrncnkpnt is the last file
		; we have.
		s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
		if +rc<=0 {
		   d $zu(9,"","("_mirname_") ApplyJournalFiles failed to look up last valid file in journal log",1 /* broadcast and log message*/,1  /* Warning */)
		   quit 0
		}
		if +rc'=startfilecnt {
		   d $zu(9,"","("_mirname_") ApplyJournalFiles failed because last valid journal file not recorded",1 /* broadcast and log message*/,1  /* Warning */)
		   quit -1  ;restart with validate journal files (JO2359)
		}
		s lastjrnfile=$P(rc,",",2)
		s lastjrnfilecnt=+rc
		; Since we didn't get this file from "lastvalidjrnfile" we need to double
		; check that its ok to restore it. This must be the current file on the
		; active primary or its an error.
		s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
		if systemcnt>0 {
			s status=""
			for id=1:1:systemcnt {
		   	   s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
	       	   if info'="" {
		          s name=$lg(info,1)
	              s mtype=+$lg(info,8)
	              s rc=$$GetStatus^MIRRORCTL(mirname,id)
	              s status=$LG(rc)  
		          if ('reportingNode) ! (status="PRIMARY") {
			          ; for failover nodes we want to get the info about the
			          ; other nodes, for reporting nodes we want to contact
			          ; the current primary. If this is an async member talking
			          ; to another async, then systemcnt is 1 and there
			          ; is only 1 other node.
			          quit
		          }
		       }
	        }
	        if reportingNode {
		       if mtype=0,status'="PRIMARY" {
				   d $zu(9,"","("_mirname_") ApplyJournalFiles failed to locate primary to validate "_lastjrnfile_" is the current journal file",1 /* broadcast and log message*/,1  /* Warning */)
				   quit 0
		       }
		       if mtype'=0 {
			       if status'="OK" {
					   d $zu(9,"","("_mirname_") ApplyJournalFiles failed to locate async server to validate "_lastjrnfile_" is the current journal file, status="_status,1 /* broadcast and log message*/,1  /* Warning */)
					   quit 0
			       }
			       s rc=$LG(rc,2)
		       }
	        }
	        s jrnfilecnt=$LG(rc,2)  ;current journal file on the primary
	        if jrnfilecnt'=lastjrnfilecnt {
			   d $zu(9,"","("_mirname_") ApplyJournalFiles cannot restore our last journal file #"_lastjrnfilecnt_" ("_lastjrnfile_") because it is not the primary's current journal file (#"_jrnfilecnt_")",1 /* broadcast and log message*/,1  /* Warning */)
			   quit -1  ;retry with validate journal files (JO2359)
	        }
		}
	}
	s EvN=mirname_+$j
	if $e(EvN)?1N s EvN="M"_EvN
	s x=$SYSTEM.Event.Delete(EvN)
	s x=$SYSTEM.Event.Create(EvN)
	if 'x {
		d $zu(9,"","("_mirname_") Failed to create event name '"_EvN_"'.",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	Job ApplyJournalFilesDaemon^MIRRORMGR(miridx,mirname)::3
	If '$T {
		d $zu(9,"","("_mirname_") Starting ApplyJournalFilesDaemon failed.",1 /* broadcast and log message*/,1  /* Warning */)
		s x=$SYSTEM.Event.Delete(EvN)
		quit 0
	}
	s AJDaemon=+$zchild
	s x=$SYSTEM.Event.Wait(EvN,5)
	if x<=0 {
		d $zu(9,"","("_mirname_") ApplyJournalFilesDaemon failed to send acknowlege.",1 /* broadcast and log message*/,1  /* Warning */)
		s x=$SYSTEM.Event.Delete(EvN)
		s x=$SYSTEM.Event.Signal(AJDaemon,$LB("Q"))
		quit 0
	}
	;
	; if the starting file count is the same as the last valid
	; filecnt then get the end of the last valid journal file and see
	; whether our starting offset is at the end or not. If it is, then
	; we're up-to-date and there's nothing to do.
	;
	if startfilecnt=lastjrnfilecnt {
	   ; Open the journal file to find its end rather than using JrnHdrMIREND 
	   ; because we want the actual end we have on this system. If JrnHdrMIREND is
	   ; set, and we have that in our file, that's what $$$JRNPREV() will return.
	   ; Otherwise JRNPREV() returns the last address we have. Compare the end
	   ; of this file to the startpoint to see if it needs to be restored.
       s fd=$zu(78,5,lastjrnfile,0)
       if fd<0 {
          d $zu(9,"","("_mirname_") ApplyJournalFiles failed to open journal file "_lastjrnfile_" to locate its end",1 /* broadcast and log message*/,1  /* Warning */)
          s rc=$$UpdateMirrorJournalCheckPoint(mirname)
          if '+rc {
	          d $zu(9,"","ApplyJournalFiles retry: "_$p(rc,",",2),1 /* broadcast and log message*/,1  /* Warning */)
	          s x=$SYSTEM.Event.Delete(EvN)
	          s x=$SYSTEM.Event.Signal(AJDaemon,$LB("Q"))
	          quit 0
          }
          s dejrnfilecnt=$G(^MIRROR(mirname,"dejrnchkpnt"))  ;filecnt^pos
          s startoff=+$P(dejrnfilecnt,"^",2)
          s dejrnfilecnt=+dejrnfilecnt
          if (startfilecnt'<dejrnfilecnt) {
	          s x=$SYSTEM.Event.Delete(EvN)
	          s x=$SYSTEM.Event.Signal(AJDaemon,$LB("Q"))
	          quit 0
          }
          d $zu(9,"","ApplyJournalFiles retried with starting journal #"_dejrnfilecnt_" from old #"_startfilecnt,0,0  /* Informational message */)
          s startfilecnt=dejrnfilecnt
          goto skip
       }
	   do $zu(78,6,fd)
	   s jrnend=$zu(78,18,0)
	   s jrnendx=jrnend
	   do $zu(78,7,fd)
	   ;
	   if startoff<jrnendx {
	      d $zu(9,"","Applying journal data for mirror """_mirname_""" starting at "_startoff_" in file #"_lastjrnfilecnt_" ("_lastjrnfile_").",0,0  /* Informational message */)
	   } else {
	      if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","("_mirname_") Databases up to date. No journal restore required")
	   }
	   s rc=$$RequestApplyJournalFiles(AJDaemon,EvN,$LB("P",startoff,lastjrnfile,lastjrnfilecnt))
       if +rc<=0 {
	      ;SML2952 ; Quit the AJDaemon.
	      s x=$SYSTEM.Event.Delete(EvN)
	      s x=$SYSTEM.Event.Signal(AJDaemon,$LB("Q"))
	      quit 0
	   } elseif PurgeFile {
		   if $$getMirJrnEnd(lastjrnfile)>0 {
			   s ^MIRROR(mirname,"PendingPurgeList",lastjrnfilecnt)=""
		   }
	   }
		s:'$G(^MIRROR(mirname,"DBDejournaled")) ^MIRROR(mirname,"DBDejournaled")=1
	   goto updatechkpnt
	}
skip ;
	if startfilecnt>lastjrnfilecnt {
		; the datatabases are up to date as of a journal file we don't have.
		; Its unclear why we're in this state but probably the databases were
		; restored from backup/copied from another system and they were 'ahead'
		; of the journal files on this node. Regardless of the reason, 
		; get the missing journal files.
		if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","("_mirname_") ApplyJournalFiles retrieving journal files "_(lastjrnfilecnt+1)_" through "_startfilecnt)
		for filecnt=lastjrnfilecnt+1:1:startfilecnt {
		  s startretrievepos=0
		  if startfilecnt=filecnt {
			  s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)
			  if +rc {
				  s rc=$P(rc,",",2)
				  s rc=$zu(78,5,rc,0) ;lastjrnfile is the havejrncnt/dejrncnhkcnt/maxjrncnt file
				  if rc'<0 {
					  do $zu(78,6,rc)
					  s startretrievepos=$zu(78,18,0)
					  do $zu(78,7,rc)
				  }
			  }
		  }
		  s rc=$$RetrieveJournalFile(mirname,filecnt,startretrievepos,1,1) 
		  if 'rc {
		     d $zu(9,"","("_mirname_") ApplyJournalFiles failed to retrieve 'missing' journal file #"_filecnt,1 /* broadcast and log message*/,1  /* Warning */)
		     quit  ;stop getting journal files
		  }
		}
		if 'rc {
	        s x=$SYSTEM.Event.Delete(EvN)
	        s x=$SYSTEM.Event.Signal(AJDaemon,$LB("Q"))
			quit -1  ;failed
		}
	    s lastjrnfilecnt=startfilecnt
	}
	; There's more than one journal file which needs to be restored. For
	; the 1st one we start at startoff. 	
	s rc=1
	s retry=0
	for filecnt=startfilecnt:1:lastjrnfilecnt {
	   s jrnfile=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)
	   if +jrnfile {
		  s jrnfile=$P(jrnfile,",",2)
	   } else {
		  ; We don't have the journal file required to update the
		  ; mirrored databases. Generally this should only happen when a
		  ; mirror is 1st built. Try to retrieve this file from any of the
		  ; mirror members.
		  s startretrievepos=0
		  if startoff {
			  s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)
			  if +rc {
				  s rc=$P(rc,",",2)
				  s rc=$zu(78,5,rc,0) ;lastjrnfile is the havejrncnt/dejrncnhkcnt/maxjrncnt file
				  if rc'<0 {
					  do $zu(78,6,rc)
					  s startretrievepos=$zu(78,18,0)
					  do $zu(78,7,rc)
				  }
			  }
		  }
		  if '$$RetrieveJournalFile(mirname,filecnt,startretrievepos,1,1) {
		     d $zu(9,"","("_mirname_") Failed to retrieve journal file #"_filecnt,1 /* broadcast and log message*/,1  /* Warning */)
		     s jrnfile=""
		     quit
		  }
	  	  s jrnfile=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)
	   	  if +jrnfile {
		     s jrnfile=$P(jrnfile,",",2)
		  } else {
		     d $zu(9,"","("_mirname_") Failed to lookup journal file #"_filecnt_" after retrieving",1 /* broadcast and log message*/,1  /* Warning */)
		     s jrnfile=""
		     quit
		  }
	   }
	   if jrnfile="" s rc=0 quit ; some error occured, exit the for loop and return failure
	   s rc=$$RequestApplyJournalFiles(AJDaemon,EvN,$LB("P",startoff,jrnfile,filecnt))
       if +rc<=0 {
          s rcx=$$UpdateMirrorJournalCheckPoint(mirname)
          if '+rcx {
	          d $zu(9,"","ApplyJournalFiles: UpdateMirrorJournalCheckPoint failed: "_$p(rcx,",",2),1 /* broadcast and log message*/,1  /* Warning */)
          }
          s text=$P(rc,",",2)  ;0,<message text>
          if ('retry) && (filecnt=startfilecnt) {
			  if ($ZCVT(text,"L")["failed to open journal file") {
				  s dejrnfilecnt=$G(^MIRROR(mirname,"dejrnchkpnt"))  ;filecnt^pos
				  s startoff=+$P(dejrnfilecnt,"^",2)
				  s dejrnfilecnt=+dejrnfilecnt
				  if (startfilecnt'<dejrnfilecnt) {
					  s rc=0		; indicate failure
					  quit
				  }
				  d $zu(9,"","ApplyJournalFiles retried with starting journal #"_dejrnfilecnt_" from old #"_filecnt,0,0  /* Informational message */)
				  s filecnt=dejrnfilecnt-1
				  s retry=1
				  continue
			  }
          }
	      quit
	   } elseif PurgeFile {
		   if $$getMirJrnEnd(jrnfile)>0 {
			   s ^MIRROR(mirname,"PendingPurgeList",filecnt)=""
		   }
		   if filecnt#5=0 Do CheckAsyncJrnfilePurge(mirname)
       }
       s startoff=0  ;start @ the beginning of the next file
		s:'$G(^MIRROR(mirname,"DBDejournaled")) ^MIRROR(mirname,"DBDejournaled")=1
	}
	if +rc>0 {
updatechkpnt ;
	   s dejrnfilecnt=+$P(rc,",",2)
	   s dejrnfilepos=+$P(rc,",",3)	
	   if shrid>=0 {
		   s jrnfile=$SYSTEM.Mirror.GetJournalFileByMjrncnt(dejrnfilecnt,mirname)
		   if +jrnfile {
			   s jrnfile=$P(jrnfile,",",2)
			   s rc=$$RequestApplyJournalFiles(AJDaemon,EvN,$LB("S",jrnfile,shrid,dejrnfilepos))
			   if 'rc d $zu(9,"","ApplyJournalFiles failed to syn dejournaling, error:"_$p(rc,",",2),1 /* broadcast and log message*/,1  /* Warning */)
		   } else {
			   d $zu(9,"","("_mirname_") DejournalSync Failed to lookup journal file #"_dejrnfilecnt,1 /* broadcast and log message*/,1  /* Warning */)
		   }
	   }
	   s x=$SYSTEM.Event.Delete(EvN)
	   s x=$SYSTEM.Event.Signal(AJDaemon,$LB("Q"))
	   If '$SYSTEM.Mirror.ActiveBackupFlag() do ResolveDBRollbackState(mirname)
	   ; Now we need to update dejrnchkpnt and transroll
	   s rc=$$UpdateMirrorJournalCheckPoint(mirname)
	   if '+rc {
		   d $zu(9,"","ApplyJournalFiles: "_$p(rc,",",2),1 /* broadcast and log message*/,1  /* Warning */)
		   quit 0
	   }
	   s dbchkpnt=$G(^MIRROR(mirname,"dejrnchkpnt"))
	   s dbfilecnt=+dbchkpnt
	   s dbfilepos=+$P(dbchkpnt,"^",2)
	   if dejrnfilecnt,dbfilecnt>dejrnfilecnt {
		   s msg="Dejournal checkpoint for "_mirname_" from the databases ("_dbchkpnt_") indicates"
		   s msg=msg_" there are more journal files to restore beyond #"_dejrnfilecnt
		   s msg=msg_$C(10,13)_"Some journal file appear to be missing - ApplyJournalFiles failed."
		   d $zu(9,"",msg,1 /* broadcast and log message*/,2  /* Severe error */)
		   quit 0
	   } elseif dbfilecnt=dejrnfilecnt,dbfilepos>dejrnfilepos {
		   s msg="Dejournal checkpoint for "_mirname_" from the journal file ("_dejrnfilecnt_","_dejrnfilepos_")"
		   s msg=msg_" is less than the last checkpoint in the databases ("_dbchkpnt_")."_$c(13,10)
		   s msg=msg_"It appears that file #"_lastjrnfilecnt_" ("_lastjrnfile_") has been truncated"
		   s msg=msg_" - ApplyJournalFiles failed."
		   d $zu(9,"",msg,1 /* broadcast and log message*/,2  /* Severe error */)
		   quit 0
	   }
	   if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","("_mirname_") ApplyJournalFiles succeeded, checkpoint = "_dejrnfilecnt_","_dejrnfilepos)
	   quit 1
	}
	s x=$SYSTEM.Event.Delete(EvN)
	s x=$SYSTEM.Event.Signal(AJDaemon,$LB("Q"))
	d $zu(9,"","("_mirname_") ApplyJournalFiles failed",1 /* broadcast and log message*/,1  /* Warning */)	
	quit 0
err ;
	if $G(AJDaemon) {
		s x=$SYSTEM.Event.Delete(EvN)
		s x=$SYSTEM.Event.Signal(AJDaemon,$LB("Q"))
	}
	d $zu(9,"","Unexpected error: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	d BACK^%ETN
	quit 0
}
UpdateMirrorJournalCheckPoint(mirname,Type=2) PUBLIC {
	s rc=$$GetMirrorDejournalInformation(mirname,Type)
	if '+rc quit "0,Reset of dejrnchkpnt failed"
	s chkpntfilecnt=+^MIRROR(mirname,"dejrnchkpnt")
	s rc=$$GetTransactionRollbackPoint(mirname,chkpntfilecnt)
	if '+rc quit "0,Reset of transroll failed"
	quit 1
}
ResolveDBRollbackState(mirname) {
	/* This is called from ApplyJournalFiles after restoring
	   the journal files to see whether we can clear the
	   rollback state in the databases so they can be activated. We
	   go through the set of databases which are marked as rollback
	   pending and if they are currently active on the primary then
	   we clear the rollback point stored in the database so that they
	   can become 'active' on the backup. If the other node is not up
	   or if the db's are not active, they remain rollback pending.
	*/
	s $zt="err"
	s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
	if (systemcnt=0) quit   ;should never happen 
    for id=1:1:systemcnt {
	    s r=$G(^MIRROR(mirname,"Status","Member",id,"Role"))
	    if (r="PRIMARY") quit
	}
	if (r'="PRIMARY") {
		; assume its system #1
		s id=1
	}
	s info=$G(^SYS("MIRRORSET",mirname,"Member",id),"")
	if info="" {
		d $zu(9,"","ResolveDBRollbackState missing information for member #"_id,1 /* broadcast and log message*/,1  /* Warning */)
		quit
	}
	s name=$lg(info,1)
	s mtype=+$lg(info,8)
	if mtype'=0 {
	   if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","("_mirname_") Transaction rollback not modified for restored databases, "_name_" is a async member")
	   quit
	}
	;
    s rc=$$GetStatus^MIRRORCTL(mirname,id)
    s status=$LG(rc)  
	if status'="PRIMARY" {
	   if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","("_mirname_") Transaction rollback remains pending for restored databases, "_name_" reports it is not the primary ("_status_")")
	   quit
	}
	; now get the list of databases
    s dirlist=$$GetDBList^MIRRORCTL(mirname,id,"",1)
    s rc=$LG(dirlist)
    if rc'="OK" {
	    d $zu(9,"","ResolveDBRollbackState failed to read current datbase list from primary. Databases remain inactive",1 /* broadcast and log message*/,1  /* Warning */)
	    quit
    }
    s len=$LL(dirlist)
    k primarydblist
	for i=2:1:len {
		s dir=$LG(dirlist,i)
		s sfn=+dir
 		s primarydblist($P(dir,"^",2))=sfn_"^"_$p(dir,"^",3)
    }
	k ourdblist
	s rc=$$GetMirroredDBList^MIRRORCOMM(mirname,.ourdblist,1)
	if '$LG(rc) {
		d $zu(9,"","ResolveDBRollbackState, GetMirrorDBList returned: "_$LG(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	s index=$o(ourdblist(""),1,info)
	while index'="" {
	   s dbpath=$P(info,"^",1)
	   s dbmirname=$P(info,"^",8)
	   s dbname=$P(info,"^",2)
	   s dblastfilecntrestored=$P(info,"^",11)
	   ;
	   if (dblastfilecntrestored && (dbmirname=mirname)) {
	      s dbname=":mirror:"_dbmirname_":"_dbname
 	      s remsfn=$G(primarydblist(dbname))
	      if remsfn="" {
	         d $zu(9,"","Rollback point for "_dbpath_" not reset - db missing on the primary",1 /* broadcast and log message*/,1  /* Warning */)
	      } else {
		      if $p(remsfn,"^",2)="" {
			      s rc=$$GetDBStatus^MIRRORCTL(mirname,id,+remsfn)
			      if $LG(rc)'="OK" {
				      d $zu(9,"","Rollback point for "_dbpath_" not reset - failed to retrieve status",1 /* broadcast and log message*/,1  /* Warning */)
				      s state=$LB("Skip")
				  } else {
					  s state=$LG(rc,2)
				  }
		      } else {
			      s state= $LB($s($p(remsfn,"^",2):"Active",1:"Inactive"))
		      }
		      if $LG(state)="Active" {
					 s sfn=+$ZU(49,dbpath)
					 if (sfn = $ZU(40,0,41)) {
						 do $ZU(17,dbpath)  ;try to mount it
						 s sfn=+$ZU(49,dbpath)
					 }
					 if (sfn<0) || (sfn = $ZU(40,0,41)) {
					     d $zu(9,"","Failed to mount "_dbpath_" to clear rollback point ("_dblastfilecntrestored_")",1 /* broadcast and log message*/,1  /* Warning */)
					 } else {
						 s rc=$SYSTEM.Mirror.DejournalClearTRollInfo(sfn)
						 if 'rc {
							 d $zu(9,"","Failed to clear rollback point ("_dblastfilecntrestored_") for "_dbpath,1 /* broadcast and log message*/,1  /* Warning */)
						 }
					 }
			  } elseif $LG(state)'="Skip" {
		 		     d $zu(9,"","Rollback point for "_dbpath_" not reset - it is not active on the primary",1 /* broadcast and log message*/,1  /* Warning */)
			  }
	       }
	   }
	   s index=$o(ourdblist(index),1,info)
    }
	quit
err ;
	s $zt=""
	d $zu(9,"","ResolveDBRollbackState("""_mirname_""") unexpected error: "_$ze,1 /* broadcast and log message*/,1  /* Warning */)
	quit		
}
TransactionRollbackComplete(mirname) {
	/* Called on the primary after Mirror^ECPRecovery succeeds to
	   clear the miblastfilecntrestored flag on all of the 'up to date'
	   databases to indicate that transaction rollback is complete 
	*/
	if $SYSTEM.Mirror.GetInfo()'["PRIMARY" quit
	s dejrnchkpnt=$G(^MIRROR(mirname,"dejrnchkpnt"))
	if dejrnchkpnt="" quit  ;didn't do any journal restore
	s lastjrncnt=+dejrnchkpnt
	k dblist
	s rc=$$GetMirroredDBList^MIRRORCOMM(mirname,.dblist,1)
	if '$LG(rc) {
		d $zu(9,"","TransactionRollbackComplete, GetMirrorDBList returned: "_$LG(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
		quit
	}
	s path=$o(dblist(""),1,info)
	while path'="" {
	   s dbpath=$P(info,"^",1)
	   s dbmirname=$P(info,"^",8)
	   s dbjrncnt=$P(info,"^",3)
	   s dbname=$P(info,"^",2)
	   if (dbmirname=mirname) && (dbjrncnt=lastjrncnt) {
		  s sfn=+$ZU(49,path)
		  if (sfn<0) || (sfn = $ZU(40,0,41)) {
		     d $zu(9,"","Invalid sfn ("_sfn_") for "_path_". Failed to mark rollback completed as of "_lastjrncnt_" in "_dbpath,1 /* broadcast and log message*/,1  /* Warning */)
		  } else {
		     s rc=$SYSTEM.Mirror.DejournalClearTRollInfo(sfn)
		     if 'rc {
		        d $zu(9,"","Failed to mark rollback completed as of "_lastjrncnt_" in "_dbpath,1 /* broadcast and log message*/,1  /* Warning */)
		     }
		  }
	   }	
	   s path=$o(dblist(path),1,info)
	}   
}
RetrieveJournalFile(mirname,jrnfilecnt,startoff,checklog=1,UpdateStatus=0,filename=0) PUBLIC {
	/* Find a mirror member who has this journal file and get it from them.
	   If the file isn't marked with a valid end, we should be able to set the
	   valid end after we retrieve it.
	   WARNING: journal file names which inlude the local path cannot be
	            cached across calls to this function as the journal file
	            may get moved to the alternate directory if there is insufficient
	            space to retrieve it. After calling this function the filename
	            needs to be looked up in the mirror journal file log using
	            the mirjrnfilecnt.
	   Returns: 1 = success, we now have the file
	            0 = failure
	*/
	if $SYSTEM.Mirror.GetInfo()'["DEFINED" {
		d $zu(9,"","Failed to retrieve journal file #"_jrnfilecnt_" because this system is not a mirror member",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0)
	if 'systemcnt {
		if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","("_mirname_") Can't retrieve journal files - no other failover mirror members")
		quit 0
	}
	s $zt="err"
	s status=""
	s ValidEndRequired=0,Startid=1
	if systemcnt>1&&(+$G(^SYS("MIRRORSET"))) {
		s primaryid=$$GetCurrentPrimaryID(mirname)
		if primaryid<0 {
			Set ValidEndRequired=1
		} else {
			s (Startid,systemcnt)=primaryid
		}
	}
    for id=Startid:1:systemcnt {
	   s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
       if info'="" {
	      s name=$lg(info,1)
	      s rc=$$GetMissingJournalFiles^MIRRORCTL(mirname,id,jrnfilecnt,startoff,jrnfilecnt,.filename,ValidEndRequired)
	      s status=$LG(rc)
	      if status="OK" {
	          if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","("_mirname_") Retrieved journal file #"_jrnfilecnt_" from "_name)
		      quit  ; we succeeded
	      }
	      s err=$I(err),err(err)=$lb(name,$LG(rc,2))
       }
    }
    if status'="OK" {
	    s errcnt=+$G(err)
	    for i=1:1:errcnt {
		    s rc=err(i)
	        d $zu(9,"","("_mirname_") Failed to retrieve journal file #"_jrnfilecnt_" from "_$LG(rc)_": "_$LG(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
	    }
	    quit 0
    }
    if 'checklog goto doneOK
    ; double check that we can read the file by validating the journal file cnt
	s jrnfile=$SYSTEM.Mirror.GetJournalFileByMjrncnt(jrnfilecnt,mirname)
	if '+jrnfile {
		d $zu(9,"","("_mirname_") Failed to find journal file #"_jrnfilecnt_" in log after retrieving it",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	s jrnfile=$P(jrnfile,",",2)
	s jrninfo=$zu(78,22,jrnfile,99)
	if +jrninfo<1 {
		d $zu(9,"","("_mirname_") Failed to read header of retrieved file # "_jrnfile,1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	s fd=$P(jrninfo,",",13+1)
    if fd'=jrnfilecnt {
	    d $zu(9,"","("_mirname_") Filecount ("_fd_") in retrieved file "_jrnfile_" doesn't match expected value: "_jrnfilecnt,1 /* broadcast and log message*/,1  /* Warning */)
	    s badf=jrnfile
	    if ''$ZU(140,4,badf) {
		    if '$ZU(140,4,badf_"z") {
			    s badf=badf_"z"
		    } else {
			    d $zu(9,"","("_mirname_") cannot locate corrupt "_jrnfile,0,0  /* Informational message */)
			    s badf=""
		    }
	    }
	    if badf'="" {
	       if '$ZU(140,6,badf,"BAD"_badf) {
	          d $zu(9,"","("_mirname_") Renamed /"_badf_"/ to /BAD"_badf,0,0  /* Informational message */)
	    } else {
		      s rc=$ZU(140,5,badf)
		      if (rc'<0) {
			     d $zu(9,"","("_mirname_") Deleted "_badf,0,0  /* Informational message */)
		    } else {
			     d $zu(9,"","("_mirname_") FAILED to delete "_badf,0,0  /* Informational message */)
		    } 
	    }
    }
    }
doneOK
	if UpdateStatus,$SYSTEM.Mirror.IsMember()=1,$SYSTEM.Mirror.GetStatus(mirname)="TRANSITION" {
		s rc=$$GetStatus^MIRRORCTL(mirname,id)
		if $LG(rc)="PRIMARY",$SYSTEM.Mirror.GetStatus(mirname)'="WAITING" d $SYSTEM.Mirror.SetStatus("SYNCHRONIZING",mirname)
	}
    quit 1  ; success
err ;
	d $zu(9,"","Unexpected error: "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	d BACK^%ETN
	quit 0
}
getMirJrnEnd(jrnfile) PUBLIC {
	/* Returns the "mirror journal end" of the file if its set and if
	   the file contains data through that spot. If the mirror journal
	   end isn't set, or if the journal file is smaller than the 
	   mirror journal end, we return 0. If the file doesn't exist, we return -1
	   If the file exists but we fail to open it, we return -2
	   Call this instead of looking up the JrnHdrMIREND directly as the valid
	   end from the header should only be used if its also present on disk.	*/
	s info=$zu(78,22,jrnfile,99)
	if info<1 quit -1  ; doesn't exist
	s validend=+$P(info,",",16+1)
	s setvalidend=0
	if 'validend {
		s mirfcnt = +$P(info,",",13+1)
		quit:'mirfcnt 0  ;end isn't valid
		s mirname=$p(jrnfile,"-",$length(jrnfile,"-")-1)
		s nextf=$SYSTEM.Mirror.GetJournalFileByMjrncnt(mirfcnt+1,mirname)
		if +nextf<=0 q 0
		s info2=$zu(78,22,$P(nextf,",",2),99)
		s validend=+$P(info2,",",11+1)
		i 'validend||($P(info,",",17+1)'=$P(info2,",",17+1)) q 0
		s setvalidend=1
	}
	; open the file and make sure the validend is a valid
	; record in the file
    s fd=$zu(78,5,jrnfile,0)
    if fd<0 {
	   d $zu(9,"","getMirJrnEnd failed to open "_jrnfile_" to validate the end ("_validend_")",1 /* broadcast and log message*/,1  /* Warning */)
	   quit -2   
    }
    do $zu(78,6,fd)
    s endpos=+$zu(78,18,0)
    do $zu(78,7,fd)
    if endpos>=validend {
	    i setvalidend s x=$SYSTEM.Mirror.SetMirrorJournalFileEnd(jrnfile,validend,1)
	    quit validend
    }
    ; 'validend' isn't in the file, return 0
	quit 0
}
MountMirroredDBs(caller,mirname="") PUBLIC {
	; In addition to getting called when MIRRORMGR starts this can
	; be called by STU after it loads the Mirror config before calling STU^JRNRESTO
	; Lock the node here to keep Config.Databases from killing it
	s dir=$$GetNextDatabaseByUCI^%SYS.CONFIG("")
	while dir'="" {
		s mirrorbit=+$ZU(40,8,28),mirnowritebit=$zu(40,8,30)
 		s info=$zu(49,dir)
 		s sfn=+info
 		s dbattrib=$s(sfn<-1:0,1:+$p(info,",",17))
 		s dbstatus=$s(sfn<-1:0,1:+$p(info,",",18))
		if sfn<0||(sfn=$zu(40,0,41)) {
			if $zb(dbattrib,mirrorbit,1) {
			   if sfn=-1,caller="Mirror startup" goto next
			   if mirname]"" {
				   s dbmirname=$p($SYSTEM.Mirror.DBGetInfoByName(0,dir),"^",8)
				   if mirname'=dbmirname goto next
			   }
remount		   do $ZU(17,dir)
			   s info=+$ZU(49,dir)
			   if (info<0)!(info=$zu(40,0,41)) {
				  d $zu(9,"",caller_": Failed to mount mirrored database: "_dir,1 /* broadcast and log message*/,1  /* Warning */)
			   } else {
				  if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"",caller_": Mounted mirrored database: "_dir)
			   }
			}
		} elseif caller="Startup"&&$zb(dbstatus,mirnowritebit,1) {
			if mirname]"" {
			   s dbmirname=$p($SYSTEM.Mirror.DBGetInfoByName(0,dir),"^",8)
			   if mirname'=dbmirname goto next
			}
			s info=$zu(3,dir)
			goto remount
		}
next	s dir=$$GetNextDatabaseByUCI^%SYS.CONFIG(dir)
	}
}
NotifyAsyncMembers(mirname,id,delete) PUBLIC {
	q:0
	s primary=$SYSTEM.Mirror.IsPrimary()
	s membername=$LG($G(^SYS("MIRRORSET",mirname,"Member",0)))
	s i=$o(^SYS("MIRRORSET",mirname,"Member",$s(primary:0,1:101-1)),1,info)
	while (i'="") {
		s info=$G(^SYS("MIRRORSET",mirname,"Member",i))
		if (+$LG(info,10))&&$s(delete:id=""||(id'=$LG(info)),1:id'=i) {
			if $G(^MIRROR(mirname,"Status","Member",i,"Version"))>3&&primary {
				s rc=$$NotifyMirrorChange^MIRRORCTL(mirname,i,membername)
			} elseif i'<101&&(id'="") {
				s msg=$s(delete:id,1:id_":"_$LB($G(^SYS("MIRRORSET",mirname,"Member",id))))
				s rc=$$NewFailOverMember^MIRRORCTL(mirname,i,msg)
			}
			if ($LG(rc)'="OK") {
				d $zu(9,"","NotifyAsyncMembers: Failed to notify "_$LG(info)_" for mirror configuration change. Error="_$LG(rc)_":"_$LG(rc,2),1 /* broadcast and log message*/,2  /* Severe error */)
			}
		}
		s i=$o(^SYS("MIRRORSET",mirname,"Member",i),1,info)
	}
}
getLocalAgentInfo(mirname,addr,basedir,sysguid) {
	s x=##class(Config.Mirrors).Open(mirname)
	if '$IsObject(x) {
		d $zu(9,"","Failed to open Config.Mirrors("_mirname_") to read virtual IP information - AddVirtualAddress failed",1 /* broadcast and log message*/,1  /* Warning */)	
		quit $LB("0,Could not read virtual IP information")
	}
	if (mirname]""),(x.Name'=mirname) {
		d $zu(9,"","Requested mirror name ("_mirname_") does not match our configured mirror name ("_x.Name_")",1 /* broadcast and log message*/,1  /* Warning */)
		quit $LB("0,Mirror name mismatch")
	}
	;Need our system name to find the interface for this system
	s x=##class(Config.MirrorMember).Open()
	if '$IsObject(x) {
		d $zu(9,"","Failed to open Config.MirrorMember to read local system information",1 /* broadcast and log message*/,1  /* Warning */)
		quit $LB("0,Could not read local system information")	
	}
	set systemName=x.SystemName
	if systemName="" {
		d $zu(9,"","Failed to read our mirror system name",1 /* broadcast and log message*/,1  /* Warning */)
		quit $LB("0,Could not read local system information")	
	}
	s x=""
	s x=##class(Config.MapMirrors).Open(mirname,systemName)  ;open our configuration
	if '$IsObject(x) {
		d $zu(9,"","Failed to open Config.MapMembers("_mirname_","_systemName_") to read virtual interface information",1 /* broadcast and log message*/,1  /* Warning */)
		quit $LB("0,Could not read virtual interface information")
	}
	set addr=x.AgentAddress_"|"_x.AgentPort
	if x.AgentAddress '= x.MirrorAddress {
		set addr=addr_","_x.MirrorAddress_"|"_x.AgentPort
	}
	if (x.AgentAddress '= x.ECPAddress) && (x.MirrorAddress '= x.ECPAddress) {
		set addr=addr_","_x.ECPAddress_"|"_x.AgentPort
	}
	set basedir=x.InstanceDirectory
	set sysguid=x.GUID
	quit $LB(1)
}
getVIPandIface(mirname,addrIn,vipOut,ifOut) {
	set mirname=$g(mirname),addrIn=$g(addrIn)
	k vipOut,ifOut
	s vipOut="",ifOut=""
	s x=##class(Config.Mirrors).Open(mirname)
	if '$IsObject(x) {
		d $zu(9,"","Failed to open Config.Mirrors("_mirname_") to read virtual IP information - AddVirtualAddress failed",1 /* broadcast and log message*/,1  /* Warning */)	
		quit $LB("0,Could not read virtual IP information")
	}
	if (mirname]""),(x.Name'=mirname) {
		d $zu(9,"","Requested mirror name ("_mirname_") does not match our configured mirror name ("_x.Name_")",1 /* broadcast and log message*/,1  /* Warning */)
		quit $LB("0,Mirror name mismatch")
	}
	set:addrIn="" addrIn=x.VirtualAddress
	if addrIn="" {
		quit $LB(1)	
	}
	;Need our system name to find the interface for this system
	s x=##class(Config.MirrorMember).Open()
	if '$IsObject(x) {
		d $zu(9,"","Failed to open Config.MirrorMember to read local system information",1 /* broadcast and log message*/,1  /* Warning */)
		quit $LB("0,Could not read local system information")	
	}
	set systemName=x.SystemName
	if systemName="" {
		d $zu(9,"","Failed to read our mirror system name",1 /* broadcast and log message*/,1  /* Warning */)
		quit $LB("0,Could not read local system information")	
	}
	set iface=x.VirtualAddressInterface
	if iface="" {
		d $zu(9,"","Interface configuration is required but missing",1 /* broadcast and log message*/,1  /* Warning */)
		quit $LB("0,Virtual interface configuration is unreadable")
	}
	set vipOut=addrIn
	set ifOut=iface
	quit $LB(1)
}
AddVirtualAddress(mirname,Addr,FromAgent=0) PUBLIC {
	s $zt="err"
	set mirname=$g(mirname),Addr=$g(Addr)
	set rc=$$getVIPandIface(mirname,Addr,.mirVIP,.mirIface)
	if '$lg(rc) quit rc
	if mirVIP="" {
		if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","No mirror Virtual IP configured - exiting AddVirtualAddress")
		quit $LB(1)	
	}
	if mirIface="NoMatchedSubnet" {
		d $zu(9,"","Virtual IP is not added because no interface support VIP '"_mirVIP_"'.",1 /* broadcast and log message*/,1  /* Warning */)
		quit $LB(1)	
	}
	s rc=##class(SYS.MirrorConfiguration).ValidateVirtualAddress(mirVIP,0,mirIface)
	if '(''rc) {
		quit $LB("0,"_$SYSTEM.Status.GetErrorText(rc))
	}
	If ($zversion(1)=3)&&('FromAgent) {
		set rc=$$getLocalAgentInfo(mirname,.addrlist,.basedir,.targguid)
		if '$lg(rc) quit rc
		set rc=$$ChangeVirtualAddress^MIRRORCTL(mirname,addrlist,targguid,basedir,1,Addr)
		set status=$LG(rc)
		if status="OK" quit $LB($lg(rc,2))
		quit $LB("0,"_$LG(rc,2))
	} else {
		if $System.INetInfo.CheckAddressExist(mirVIP) {
			d $zu(9,"","Virtual IP ("_mirVIP_") is still assigned to another system.",1 /* broadcast and log message*/,1  /* Warning */)
			quit $LB("0,Virtual IP ("_mirVIP_") is still assigned to another system.")		
		}
	}
	;s rc=$SYSTEM.INetInfo.AddIPToInterface(mirIface,mirVIP)
	s rc=##class(SYS.Mirror).AddVirtualIPAddress(mirIface,mirVIP)
	if 'rc {
		d $zu(9,"","Failed to add Virtual IP ("_mirVIP_") to interface "_mirIface_$s($l(rc,",")>1:", error: "_$p(rc,",",2,*),1:""),1 /* broadcast and log message*/,1  /* Warning */)
		quit $LB("0,AddVirtualAddress Failed - could not assign IP to interface"_$s($l(rc,",")>1:", error: "_$p(rc,",",2,*),1:""))
	}
    if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","Added virtual IP address "_mirVIP_" to interface "_mirIface)
	q $LB(1)
err set $zt="" q $LB("0,"_$ZE)
}
DeleteVirtualAddress(mirname,Addr,FromAgent=0,Iface="",NoLogFail=0) PUBLIC {
	s $zt="err"
	set mirname=$g(mirname),Addr=$g(Addr)
	If ($zversion(1)=3)&&('FromAgent) {
		set rc=$$getLocalAgentInfo(mirname,.addrlist,.basedir,.targguid)
		if '$lg(rc) quit rc
		set rc=$$ChangeVirtualAddress^MIRRORCTL(mirname,addrlist,targguid,basedir,0,Addr,Iface)
		set status=$LG(rc)
		if status="OK" quit $LB($lg(rc,2))
		quit $LB("0,"_$LG(rc,2))
	}
	set rc=$$getVIPandIface(mirname,Addr,.mirVIP,.mirIface)
	if '$lg(rc) quit rc
	if mirVIP="" {
		if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","No mirror Virtual IP configured - exiting DeleteVirtualAddress")
		quit $LB(1)	
	}
	if mirIface="NoMatchedSubnet" {
		d $zu(9,"","Virtual IP is not deleted because no interface support VIP '"_mirVIP_"'.",1 /* broadcast and log message*/,1  /* Warning */)
		quit $LB(1)	
	}
	if Iface'="" s mirIface=Iface
	;s rc=$SYSTEM.INetInfo.DeleteIPFromInterface(mirIface,mirVIP)
	s rc=##class(SYS.Mirror).DeleteVirtualIPAddress(mirIface,mirVIP)
	if 'rc {
		if 'NoLogFail d $zu(9,"","Failed to remove Virtual IP ("_mirVIP_") from interface "_mirIface_$s($l(rc,",")>1:", error: "_$p(rc,",",2,*),1:""),0,0  /* Informational message */)
		quit $LB("0,DeleteVirtualAddress Failed - could not remove IP from interface"_$s($l(rc,",")>1:", error: "_$p(rc,",",2,*),1:""))
	}
    if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","Deleted virtual IP address "_mirVIP_" from interface "_mirIface)
	q $LB(1)
err set $zt="" q $LB("0,"_$ZE)
}
releaseVIPonAllMembers(mirname) {
	set $zt="err"
	;First, check if this mirror set has a virtual IP in the first place...
	set rc=$$getVIPandIface(mirname,,.mirVIP,.mirIface)
	if '$lg(rc) quit rc
	if mirVIP="" {  ;Nothing to do...
		quit $LB(1)	
	}
	s cls=##class(Config.MirrorMember).Open(,,.rc)
	if ('rc) {
		quit $LB(0,"Failed to read [MirrorMember] configuration section")
	}
	s systemid=cls.SystemName
	s cls=""
	set rs=##class(%Library.ResultSet).%New("Config.MapMirrors:List")
	set rc=rs.Execute(mirname)
	if 'rc {
		d $zu(9,"","Failed to retrieve members of MapMirrors."_mirname,1 /* broadcast and log message*/,1  /* Warning */)
		quit $LB("0,Could not release virtual IP on other systems")	
	}
	while rs.Next() {
		set name=rs.Data("Name")
		quit:name="" 
		if rs.Data("MemberType")'=0 continue
		kill params
		set x=##class(Config.MapMirrors).Get(mirname,name,.params)
		if x {
			set agentip=$g(params("AgentAddress"))
			set basedir=$g(params("InstanceDirectory"))
			set agentport=$g(params("AgentPort"))
			set targguid=$G(params("GUID"))
			s addrlist=agentip_"|"_agentport
			if agentip'=params("MirrorAddress") {
				s addrlist=addrlist_","_params("MirrorAddress")_"|"_agentport
			}
			if (agentip'=params("ECPAddress")) && (params("MirrorAddress")'=params("ECPAddress"))  {
				s addrlist=addrlist_","_params("ECPAddress")_"|"_agentport
			}
			set rc=$$ChangeVirtualAddress^MIRRORCTL(mirname,addrlist,targguid,basedir,0)
			set status=$LG(rc)
			if status'="OK",name'=systemid s %ReleaseOtherMemberVIP=1
			if status="OK"&&+$p($lg(rc,2),",") {  ;the status will return OK if the other system was contactable - the second peice will contain the actual error (if any)...
				if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","Delete VIP on member """_name_""" succeeded.")	
			}
		}
	}
	s $ZT=""
	quit $LB(1)  ;done
err set $zt="" quit $LB("0,"_$ZE)
}
PrimaryDiscovery(mirname) PUBLIC {
	set rs=##class(%Library.ResultSet).%New("Config.MapMirrors:List")
	set rc=rs.Execute(mirname)
	if 'rc {
		d $zu(9,"","PrimaryDiscover: Failed to retrieve members of MapMirrors."_mirname,1 /* broadcast and log message*/,1  /* Warning */)
		quit 0	
	}
	s ourname=$LG($G(^SYS("MIRRORSET",mirname,"Member",0)))
	while rs.Next() {
		if rs.Data("ConnectsTo")'=""||(ourname=rs.Data("Name")) continue
		s addrlist=rs.Data("AgentAddress")_"|"_rs.Data("AgentPort")
		if rs.Data("AgentAddress") '= rs.Data("MirrorAddress") {
			set addrlist=addrlist_","_rs.Data("MirrorAddress")_"|"_rs.Data("AgentPort")
		}
		if (rs.Data("AgentAddress") '= rs.Data("ECPAddress")) && 
				(rs.Data("MirrorAddress") '= rs.Data("ECPAddress")) {
			set addrlist=addrlist_","_rs.Data("ECPAddress")_"|"_rs.Data("AgentPort")
		}
		s member($C(rs.Data("MemberType")+$A("A"))_rs.Data("Name"))=$LB(rs.Data("MemberType"),addrlist,rs.Data("InstanceDirectory"),rs.Data("GUID"))
	}
	s rs=""
	s m=$O(member(""),1,info)
	s found=0
	while m'="" {
		s mtype=$LG(info),agentip=$LG(info,2),basedir=$LG(info,3)
		s targguid=$LG(info,4)
		if mtype=0 {
checkstatus	;
			s rc=$$GetStatusByAddr^MIRRORCTL(mirname,agentip,targguid,basedir)
			if $LG(rc)="PRIMARY" {
				do SynchConfigWithPrimary^MIRRORCOMM(mirname,"",agentip,targguid,basedir)
				s ^MIRROR(mirname,"PrimaryMember")=0
				s pname=$e(m,2,*)
				f i=1:1:$G(^SYS("MIRRORSET",mirname,"Member"),0) {
					if pname=$LG($G(^SYS("MIRRORSET",mirname,"Member",i))) {
						s ^MIRROR(mirname,"PrimaryMember")=i
					}
				}
				k ^MIRROR(mirname,"PendingDNUpdates")
				s found=1
				quit
			}
			if $LG(rc)="SSLERR"||($LG(rc,2)["SSL ID") {
				d $zu(9,"","PrimaryDiscovery: Member '"_$e(m,2,*)_"' error: "_$LG(rc,$s($LG(rc)="SSLERR":3,1:2)),1 /* broadcast and log message*/,1  /* Warning */)
				s sslfail(m)=$LB(agentip,basedir,targguid)
			} elseif $LG(rc)="LOCALSSLERR" {
				s rc=$$AddPendingDNUpdates^MIRRORCOMM(mirname,$e(m,2,*),agentip,targguid,basedir)
				if '+$LG(rc) {
					d $zu(9,"","PrimaryDiscovery: (LOCALSSLERR) Failed to add pending DN updates list for member """_$e(m,2,*)_""" reason: "_$lg(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
				}
			}
		} else {
			s rc=$$TEST^MIRRORCTL(mirname,agentip,targguid,basedir,1)
			if $LG(rc) goto checkstatus
		}
		q:$G(^MIRROR(mirname,"Status","MGR"))="Exit"
		s m=$O(member(m),1,info)
	}
	i 'found,$d(sslfail),'0 {
		s ourinfo=$G(^SYS("MIRRORSET",mirname,"Member",0))
		s m=$O(sslfail(""),1,info)
		while m'="" {
			s agentip=$LG(info),basedir=$LG(info,2),targguid=$LG(info,3)
			s rc=$$SetApprovalByAddr^MIRRORCTL(mirname,agentip,targguid,basedir,ourinfo)
			s m=$O(sslfail(m),1,info)
		}
	}
	quit found
}
 /*	IsOtherNodeDown(takeoverflag)
    When takeoverflag is 1 the local node will start to become the
    primary if IsOtherNodeDown() returns "isDown" (1). When takoverflag
    is zero then IsOtherNodeDown is either being called @ startup where
    we're just trying to figure out whether the routine exists or not,
    or IsOtherNodeDown is being called in some retry code which doesn't
    want to continue until we know the other node is down. In this case
    IsOtherNodeDown() will be called again, with takeoverflag=1, before
    the node becomes the primary.
    The old form of IsOtherNodeDown^ZMIRROR() didn't take a parameter.
    The new form takes the arg parameter so the subroutine can know
    whether it is being called during mirror failover where if it returns
    1 the current node will try to become the primary or during mirror
    startup (arg=0) where we're just checking to see that the entry
    point exists. Here we have to trap the parameter error so that
    both forms continue to work.
 */
IsOtherNodeDown(arg) {
	s arg=+arg  ;should be 0 or 1
	try {
		s isDown=$$IsOtherNodeDown^ZMIRROR(arg)
	} catch exception {
	    if "<PARAMETER>"[exception.Name {
		    ; Must be the older form - try it w/no parameter
		    try {
			    s isDown=$$IsOtherNodeDown^ZMIRROR()
		    } catch exception {
				d $zu(9,"",exception.Name_" calling $$IsOtherNodeDown^ZMIRROR(). Assuming node is up",1 /* broadcast and log message*/,1  /* Warning */)
				s isDown=0  ;assume other node is up
		    }
	    } else {
			d $zu(9,"",exception.Name_" calling $$IsOtherNodeDown^ZMIRROR(1). Assuming node is up",1 /* broadcast and log message*/,1  /* Warning */)
			s isDown=0  ;assume other node is up
	    }
	}
	quit isDown
}    
CheckJournalingStatus(mirname) Public {
	s $zt="err"
	s status=$SYSTEM.Mirror.GetInfo()
	if (status["SHADOW") && ($SYSTEM.Mirror.AsyncMemberType()'=0) {
	  	quit 1
	}
	s jrnenabled=+$ZU(78,22) ;(1 if journaling running, 0 if not)
	quit jrnenabled 
err ;
	s $zt=""
  	d $zu(9,"","CheckJournalingRunning("_mirname_") recorded unexpected error ("_$ze_") in error log",1 /* broadcast and log message*/,3  /* Fatal */)
	do BACK^%ETN
	quit 0
}
DejournalMonitor(mirname,miridx,expectedguid) Public {
	s $zt="err"
	s guid=$G(^MIRROR(mirname,"DejournalMonitorGUID"))
	if guid'=expectedguid {
		if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","DJM: current guid ("_guid_") doesn't match expected value ("_expectedguid_") - this monitor instance shutting down")
	    quit 1   ;don't requeue
	}
	s alreadychecked=+$G(^||DejournalMonitor(mirname),0)
	s lastrestart=+$G(^||DejournalMonitor(mirname,"lastrestart"),0)
	k ^||DejournalMonitor(mirname)
	s status=$G(^||MIRROR(mirname,"DejournalRunning"))
	if status'=1 {
		if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","DJM: Dejournaling not marked as running - monitor shutting down")
	    quit 1   ;don't requeue
	}
	if $SYSTEM.Mirror.IsPrimary() {
		if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","DJM: Instance is primary - monitor shutting down")
		quit 1  ; don't requeue monitor
	}
	; .GetInfo(5) returns 1 if the data channel is up
	s status=$SYSTEM.Mirror.GetInfo(5,miridx-1)  ;miridx is +1 for dejournal sharid, this is the 'real' value
	if status'=1 {
		; If the data channel isn't up don't do anything. It might not have
		; been built yet or it may have failed. If it gets restarted we'll figure
		; that out and shut down then (when a new monitor has been created)
		if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","DJM: Data channel is down - monitor paused")
		quit 0  ; requeue monitor
	}
	if $System.Mirror.IsAsyncMember() {  ;DejournalBlock only works on async members
		s status=+$G(^MIRROR(mirname,"DejournalBlock"))
		if status=1 {
			if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","DJM: Dejournaling stopped by user")
			quit 0   ; requeue monitor
		}
	}
	s shrid=+$SYSTEM.Mirror.DejournalGetSharid(miridx)
	if (shrid < 0) goto restart  ;shared memory is missing, figure out what to do
	;
	; dejournaling is supposed to be running, check the updater and reader jobs
	; updater problems should be detected by the reader job so here we request
	; a dead process scan if we think one has died.
	s updid=$o(^MIRROR(mirname,"DejournalWorker",""))
	while (updid'="") {
		s jobid=$G(^MIRROR(mirname,"DejournalWorker",updid,"jobid"))
		s jobnum=$G(^MIRROR(mirname,"DejournalWorker",updid,"jobnum"))
		s updid=$o(^MIRROR(mirname,"DejournalWorker",updid))
		if jobnum'="" {  
			s curjobid=$ZH($ZU(61,30,jobnum))
			if curjobid=jobid,$ZU(61,jobnum)=0 {
	 	  	    if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","DejournalMonitor("_mirname_") Requesting dead process scan - an update job ("_jobnum_"/"_jobid_") is missing")
				do $ZU(6)  ;trigger a dead job scan
				s updid=""  ;exit the loop
			}
		}
	}
	;check the reader job	
	;jshstop is set when things go bad to shut everything down but rdstop indicates
	; we wanted to reader to shut down for some reason and that's ok
	try {
	s rdstop=$ZU(78,53,shrid,16) ;jshrdstop
	} catch {
		s rdstop=0
	}
	if rdstop {
		if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","DejournalMonitor("_mirname_") jshrdstop set ("_rdstop_"), reader expected to be down")
		quit 0  ;leave monitor queued
	}
	try {
		s stopflg=$ZU(78,53,shrid,128) ;jshstop 
	} catch {
		s stopflg = 0  ;system doesn't support $ZU(78,53,id,128) or memory got torn down
	}
	if stopflg {
		if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","DejournalMonitor("_mirname_") stop flag set, dejournaling expected to be down")
		quit 0  ;leave monitor queued
	}
	s status=$G(^MIRROR(mirname,"DejournalReader","status"))
	if status="" {
		if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","DJM: Dejournal reader not started yet - waiting")
	    quit 0   ;leave monitor running
	}
	if status="running" {
		; When status is "running" make sure its still alive
		s jobid=$G(^MIRROR(mirname,"DejournalReader","jobid"))
		s jobnum=$G(^MIRROR(mirname,"DejournalReader","jobnum"))
		if jobnum'="" {  
			s curjobid=$ZH($ZU(61,30,jobnum))
			if curjobid=jobid,$ZU(61,jobnum)'=0 {
				quit 0  ;leave monitor running, this is the expected case
			}
			do $ZU(6)  ;run a dead job scan
		}
		if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","DejournalMonitor("_mirname_") Dejournal Reader ("_jobnum_"/"_jobid_") seems to have died")
	} else {
		if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","DejournalMonitor("_mirname_") Dejournal Reader is not running, status="""_status_"""")
	}
restart ;	
	s limit=+$G(^MIRROR(mirname,"MinDejournalRestartTime"),120)
	if 'limit quit 1  ;remove monitor, restarting is disabled
	s status=$G(^MIRROR(mirname,"DejournalReader","status"))
	if status="stopped" {
		if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","DJM: Dejournal reader set status to stopped - monitor shutting down")
	    quit 1
	}
	if +lastrestart && (limit > 0) {
		s curtime=$ztimestamp
		if +curtime=+lastrestart {
			s sec=$P(curtime,",",2)-$p(lastrestart,",",2)
			if (sec < limit) {
				d $zu(9,"","Dejournal Monitor shutting down because journaling failed within "_sec_" seconds of being restarted.",0,0  /* Informational message */)
				quit 1  ; remove monitor
			}
		}
		if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","DejournalMonitor("_mirname_") last restarted dejournaling "_sec_"seconds ago")
	}
	if 'alreadychecked {  ;'$G(^||DejournalMonitor(mirname))
		h 0.5  ;generally the monitor entry won't be recheked for a bit but it could be if
		       ; a message gets processed so inject a short wait here.
		s ^||DejournalMonitor(mirname)=1
		if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","DJM: dejournaling needs restarting - double checking before restarting")
		quit 0  ;leave monitor queued
	}
	if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","DJM: Restarting dejournaling")
	s curtime=$ztimestamp
	s ^||DejournalMonitor(mirname,"lastrestart")=curtime
	s ^MIRROR(mirname,"DejournalLastRestarted")=curtime
	if shrid>=0 {
		s rc=$SYSTEM.Mirror.DejournalFree(miridx)
		if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","DejournalMonitor("_mirname_") freed dejournal memory for #"_miridx_", rc="_rc)
	}
	s rc=$$GetMirrorDejournalInformation(mirname,2) 
	if 'rc {
      	d $zu(9,"","DejournalMonitor failed calculating checkpoint location to restart from - Try stopping/starting mirror "_mirname,1 /* broadcast and log message*/,3  /* Fatal */)
	  	quit 1  ;remove monitor, don't retry anymore
	}
	s chkpnt=$G(^MIRROR(mirname,"dejrnchkpnt"))  
	if '+chkpnt {
      	d $zu(9,"","DejournalMonitor failed to locate checkpoint location to restart from - Try stopping/starting mirror "_mirname,1 /* broadcast and log message*/,3  /* Fatal */)
	  	quit 1  ;remove monitor, don't retry anymore
	}
   	s mirfilecnt=+chkpnt ;jrncnt^pos
	s jrnpos=+$P(chkpnt,"^",2)
	s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(mirfilecnt,mirname)
	if rc<=0 {
		// Shouldn't get here!!
      	d $zu(9,"","DejournalMonitor failed to read log info for file #"_mirfilecnt,1 /* broadcast and log message*/,3  /* Fatal */)
		Quit 1  ;remove the monitor
	}
	s jrnfname=$P(rc,",",2)
    if '$$InitDejournal(miridx,mirname) {
      	d $zu(9,"","DejournalMonitor failed to re-initialize dejournal memory - Try stopping/starting mirror "_mirname,1 /* broadcast and log message*/,3  /* Fatal */)
	  	quit 1  ;remove monitor, don't retry anymore
	}
	if '$$StartDejournal^MIRRORCOMM("DejournalMonitor",mirname,jrnfname,mirfilecnt,jrnpos,miridx) {
      	d $zu(9,"","DejournalMonitor failed to restart dejournal reader - Try stopping/starting mirror "_mirname,1 /* broadcast and log message*/,3  /* Fatal */)
	  	quit 1  ;remove monitor, don't retry anymore
	}
	d $zu(9,"","DejournalMonitor("_mirname_") Restarted dejournaling from "_jrnfname_"(#"_mirfilecnt_") at pos("_jrnpos_")",0,0  /* Informational message */)
	quit 0 ; leave monitor running
err ;
	s $zt=""
  	d $zu(9,"","DejournalMonitor caught unexpected error ("_$ze_") restarting dejournaling - Try stopping/starting mirror "_mirname,1 /* broadcast and log message*/,3  /* Fatal */)
	quit 1  ;remove monitor
}
MonitorVIPAddress(mirname) PUBLIC {
	s $zt="err"
	if $SYSTEM.Mirror.GetInfo()'["PRIMARY"	{
		k ^||FirstVIPMonitor
		quit 1
	}
	if $G(^||FirstVIPMonitor) k ^||FirstVIPMonitor quit 0
	s cls=##class(Config.Mirrors).Open(mirname)
	if '$IsObject(cls) {
		d $zu(9,"","MonitorVIPAddress error: Failed to open Config.Mirrors("_mirname_") to read virtual IP information",1 /* broadcast and log message*/,1  /* Warning */)	
	    quit 0
	}
	s vipAddr=cls.VirtualAddress  ;"" if there isn't one
	s cls=""
	if vipAddr="" {
		k %TroubleStartTime
		quit 0
	}
	s cls=##class(Config.MirrorMember).Open(,,.rc)
	if ('rc) {
		d $zu(9,"","MonitorVIPAddress: failed to read mirror member configuration",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	s interface=cls.VirtualAddressInterface
	s cls=""
	if interface="NoMatchedSubnet" quit 0
	if $P($SYSTEM.Mirror.GetInfo(2),",",12)'=0 {
		if $d(%TroubleStartTime) {
			if ($zh-%TroubleStartTime)>(^SYS("MIRRORSET",mirname,"QOSTimeout")/1000*2+60) {
				set ok=$$DeleteVirtualAddress(mirname)
			}
		} else {
			s %TroubleStartTime=$zh
		}
		Quit 0
	}
	k %TroubleStartTime
	if $G(%ReleaseOtherMemberVIP),$G(^SYS("MIRRORSET",mirname,"Member",1))'="" {
		s info=^SYS("MIRRORSET",mirname,"Member",1)
		s targguid=$LG(info,2)
		s basedir=$LG(info,6)
		s addrlist=$LG(info,5)
		s agentport=$p(addrlist,"|",2)
		s agentip=$p(addrlist,"|")
		if agentip'=$p($LG(info,3),"|") {
			s addrlist=addrlist_","_$p($LG(info,3),"|")_"|"_agentport
		}
		if (agentip'=$p($LG(info,4),"|")) && ($p($LG(info,3),"|")'=$p($LG(info,4),"|"))  {
			s addrlist=addrlist_","_$p($LG(info,4),"|")_"|"_agentport
		}
		set rc=$$ChangeVirtualAddress^MIRRORCTL(mirname,addrlist,targguid,basedir,0)
		if $LG(rc)="OK" {
			k %ReleaseOtherMemberVIP
			d $zu(9,"","MonitorVIPAddress: Successfully contacted '"_$LG(info)_"' for trying to release its VIP.",0,0  /* Informational message */)
		}
	}
	s rc=$SYSTEM.INetInfo.CheckAddressExist(vipAddr)
	if rc=1 {
		quit 0
	}
    s ok=$$AddVirtualAddress(mirname)
    if '$lg(ok) {
		s rc=$SYSTEM.INetInfo.CheckAddressExist(vipAddr)
		if rc=1 {
			; Generate a warning message to let someone know that something went wrong
			; (eg. a ping failed) but that its ok now
			d $zu(9,"","MonitorVIPAddress: Successfully reached VIP address "_vipAddr_" after outage",1 /* broadcast and log message*/,1  /* Warning */)
			quit 0
		}	    
        d $zu(9,"","MonitorVIPAddress error: Failed to reestablish VIP address "_vipAddr_" (reason: "_$p($lg(ok),",",2,999)_")",1 /* broadcast and log message*/,2  /* Severe error */)
	    quit 0
    }
    ; We succeeded in adding the address, make sure ping works
	s rc=$SYSTEM.INetInfo.CheckAddressExist(vipAddr)
	if rc=1 {
		d $zu(9,"","MonitorVIPAddress: Successfully reestablished VIP address "_vipAddr,1 /* broadcast and log message*/,1  /* Warning */)
	} else {
        d $zu(9,"","MonitorVIPAddress error: Ping failed for reestablished VIP address "_vipAddr,1 /* broadcast and log message*/,2  /* Severe error */)
	}
	quit 0  ;failure means this stays queued
err ;
	s $zt=""
	d $zu(9,"","MonitorVIPAddress caught unexpected error: "_$ze,1 /* broadcast and log message*/,2  /* Severe error */)
	quit 0 ;leave queued (maybe we shouldn't in this case?)
}
 /*	RetryGetStatus()
    This is queued to the retry list when we want to
    wait for the $$GetStatus() result of a mirror member
    go change.
    Returns:  1 - Current status is different than oldStatus or
                  we failed to read the status
              0 - Current status is the same as oldStatus
 */
RetryGetStatus(mirname,id,oldStatus) PUBLIC {
	s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
    if info="" {
	    quit 1  ; treat this as success - node doesn't exist any more
    }
    s rc=$$GetStatus^MIRRORCTL(mirname,id)
    s status=$LG(rc)  
	if status=oldStatus {
		quit 0  ;status hasn't changed, keep waiting
	}
	if status["ERR" {
		quit 0  ;ignore ERR, its not a useful status
	}
	quit 1  ;status has changed or we had some trouble	
}
ClearLastFileValidEnd(mirname) {
	s $zt="err"
	do $SYSTEM.Mirror.LastFileValidFlag(0)
	s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)
	if +rc<=0 q
	s jrnfcnt=+rc,jrnfile=$p(rc,",",2)
	s rc=$SYSTEM.Mirror.SetMirrorJournalFileEnd(jrnfile,0,1)
	i 'rc {
		d $zu(9,"","ClearLastFileValidEnd: Failed to clear valid end of "_jrnfile_" ("_jrnfcnt_")",1 /* broadcast and log message*/,1  /* Warning */)
		q
	}
	if $d(^MIRROR(mirname,"lastvalidjrnfile"),last),jrnfcnt=+last {
		if jrnfcnt=1 k ^MIRROR(mirname,"lastvalidjrnfile") q
		s jrnfcnt=jrnfcnt-1
		s jrnfile=$SYSTEM.Mirror.GetJournalFileByMjrncnt(jrnfcnt,mirname)
		if '+jrnfile k ^MIRROR(mirname,"lastvalidjrnfile") q
		s jrnfile=$P(jrnfile,",",2)
		s ^MIRROR(mirname,"lastvalidjrnfile")=jrnfcnt_"^"_jrnfile
	}
err q
}
Updatelastjvalidjrnfile(mirname) {
	s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
	if +rc<=0 {
	   d $zu(9,"","("_mirname_") Updatelastjvalidjrnfile failed to look up last valid file in journal log",1 /* broadcast and log message*/,1  /* Warning */)
	   quit 0
	}
	s lastjrnfile=$P(rc,",",2)
	s lastjrnfilecnt=+rc
	s dejrnchkcnt=+$G(^MIRROR(mirname,"dejrnchkpnt"))
	s dejrnchkoff=+$P($G(^MIRROR(mirname,"dejrnchkpnt")),"^",2)
	s curfcnt=+$G(^MIRROR(mirname,"lastvalidjrnfile"))
	if $SYSTEM.Mirror.LastFileValidFlag() {
		if $$getMirJrnEnd(lastjrnfile)<=0 {
			d $zu(9,"","Updatelastjvalidjrnfile: last journal file "_lastjrnfile_"("_lastjrnfilecnt_") did not have valid end",1 /* broadcast and log message*/,1  /* Warning */)
			quit 0
		}
		if curfcnt<lastjrnfilecnt {
			if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","Updatelastjvalidjrnfile: LastFileValidFlag is set and updated lastvalidjrnfile with "_lastjrnfilecnt_"^"_lastjrnfile)
			s ^MIRROR(mirname,"lastvalidjrnfile")=lastjrnfilecnt_"^"_lastjrnfile
		} elseif curfcnt>lastjrnfilecnt {
			d $zu(9,"","Updatelastjvalidjrnfile: last journal file #"_lastjrnfilecnt_" is less than current lastvalidjrnfile #"_curfcnt,1 /* broadcast and log message*/,1  /* Warning */)
			quit 0
		} else {
			if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","Updatelastjvalidjrnfile: LastFileValidFlag is set and lastvalidjrnfile match "_lastjrnfilecnt_"^"_lastjrnfile)
		}
		quit 1
	}
	s found=0
	if curfcnt {
		s endfcnt=curfcnt
	} else {
		s endfcnt=dejrnchkcnt-1
	}
	for jrnfcnt=lastjrnfilecnt:-1:endfcnt {
		s jrnfile=$SYSTEM.Mirror.GetJournalFileByMjrncnt(jrnfcnt,mirname)
		if '+jrnfile {
			d $zu(9,"","Updatelastjvalidjrnfile: journal file #"_jrnfcnt_" does not exist in mirror journal log",1 /* broadcast and log message*/,1  /* Warning */)
			quit
		}
		s jrnfile=$P(jrnfile,",",2)
		s rc=$$getMirJrnEnd(jrnfile)
		if rc>0 {
			s found=1
			if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","Updatelastjvalidjrnfile: LastFileValidFlag is NOT set and updated lastvalidjrnfile with "_jrnfcnt_"^"_jrnfile)
			s ^MIRROR(mirname,"lastvalidjrnfile")=jrnfcnt_"^"_jrnfile
			quit
		}
		if rc<0 {
			d $zu(9,"","Updatelastjvalidjrnfile: journal file "_jrnfile_"("_jrnfcnt_") does not exist",1 /* broadcast and log message*/,1  /* Warning */)
			quit
		}
	}
	quit found
}
ResolveFrozenPrimary(mirname,getstatusrc) {
	set $zt="err"
	set info=$system.Mirror.GetInfo()	
	if ($system.Mirror.IsMember()'=1) || (info["BACKUP") || (info["PRIMARY") { 
		d $zu(9,"","ResolveFrozenPrimary called in unexpected state",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	set id=1  ;the other node
	set info=$G(^SYS("MIRRORSET",mirname,"Member",id))
	if info="" {
		d $zu(9,"","Missing information for mirror member #"_id,1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	if $get(getstatusrc)="" {
		set getstatusrc=$$GetStatus^MIRRORCTL(mirname,id)
	}
	set status=$LG(getstatusrc)
	if status="PRIMARY" {
		set primarycurjrncnt=+$LG(getstatusrc,2)
		set primarytroubleflag=+$LG(getstatusrc,3)
		set primaryfailovermode=$LG(getstatusrc,4)
	} elseif status="HUNG" {		
		set primarycurjrncnt=+$LG(getstatusrc,2)
		set primarytroubleflag=+$LG(getstatusrc,4)
		set primaryfailovermode=$LG(getstatusrc,5)
	} elseif (status="ERR") || (status="TIMEOUT") {
		quit 0 ; retry on error or timeout
	} else {
		quit 1 ; nothing to resolve
	}
	if ('primarytroubleflag) || ((primarytroubleflag=1) && (primaryfailovermode'=1)) {
		quit 1 ; nothing to resolve
	}
	set lastjrncnt=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
	if +lastjrncnt=-1 {
		quit 0 ; error opening journal.log - retry later
	}
	if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","Backup found current last journal file "_lastjrncnt)
	set restart=1
	set lastjrncnt=+lastjrncnt
	if (lastjrncnt>primarycurjrncnt) {
		set force=1
		d $zu(9,"","Current journal file is "_lastjrncnt_". Forcing down frozen old primary on file #"_primarycurjrncnt,0,0  /* Informational message */)
		set status=$$ForceNodeDown^MIRRORCTL(mirname,id,1)
		if $LG(status)'="OK" {
			d $zu(9,"","Failed to force down frozen primary. Reason: "_$LG(status,2),1 /* broadcast and log message*/,1  /* Warning */)
			quit -1 ; error
		}
		set waittime=120
	} else {
		set force=0
		do $SYSTEM.Mirror.ActiveBackupFlag(0)
		if $SYSTEM.Mirror.LastFileValidFlag() { 
			do ClearLastFileValidEnd(mirname)
		}
		if primarytroubleflag=2 {
			d $zu(9,"","Clearing permanent trouble state on primary",0,0  /* Informational message */)
			set rc=$$ResetTrouble^MIRRORCTL(mirname,id)
			if $LG(rc)'="OK" {
				d $zu(9,"","Failed to clear permanent trouble: "_$LG(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
				quit -1
			}
		}
		if primaryfailovermode=1 {
			d $zu(9,"","Switching frozen primary to Agent Controlled failover mode via agent",0,0  /* Informational message */)
			do $SYSTEM.Mirror.FailoverRule(2)
			set rc=$$SetAgentContactMode^MIRRORCTL(mirname,id,primarycurjrncnt)
			if $LG(rc)'="OK" {
				d $zu(9,"","Failed to switch frozen primary to Agent Controlled failover mode: "_$LG(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
				quit -1
			}
		}
		set waittime=30
	}
	do {
		hang 1
		set getstatusrc=$$GetStatus^MIRRORCTL(mirname,id)
		set status=$LG(getstatusrc)  ; PRIMARY/UP/DOWN/HUNG/TIMEOUT/ERR
		set waittime=waittime-1
	} while (waittime>0) && 
	        ((status="HUNG") || (status="ERR") || 
	         (force && (status="PRIMARY")))
	d $zu(9,"","Frozen primary now reports status: "_status,0,0  /* Informational message */)
	quit:force 2
	quit 3
err
	set $zt=""
	d $zu(9,"","Unexpected error resolving frozen primary: "_$ze,1 /* broadcast and log message*/,1  /* Warning */)
	quit:$get(restart) -1
	quit 0
}
UpdateDNPost(args) PUBLIC {
	d post($LG(args),"",0,"UPDATEDN:"_$LG(args,2)_":"_$LG(args,3))
	q
}
ValidateFailoverPartner(mirname,forceBecomePrimary) PUBLIC {
	if '$G(^SYS("MIRRORSET",mirname,"Member"),0) quit 1
	s info=$G(^SYS("MIRRORSET",mirname,"Member",1))
	if info="" quit 1
	s localinfo=$G(^SYS("MIRRORSET",mirname,"Member",0))
	if localinfo="" {
		d $zu(9,"","ValidateFailoverPartner: Could not find local member information.",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	s name=$LG(info)
	s addrlist=$$BuildAgentAddrlist^MIRRORCTL(info)
	s basedir=$LG(info,6)
	s targguid=$LG(info,2)
	s rc=$$ValidatePartner^MIRRORCTL(mirname,addrlist,targguid,basedir,$LG(localinfo),$LG(localinfo,2))
	if $LG(rc)="OK" {
		s ListedDN=$LG(rc,3)
		If $LG(rc,2),+$LG(rc,5),(ListedDN'=$LG($G(^SYS("MIRRORSET",mirname,"Member",0)),7)) {
			d $zu(9,"","ValidateFailoverPartner error: SSL Distinguished Name of local system not matched with SSL Distinguished Name in Mirror member """_name_""".",1 /* broadcast and log message*/,1  /* Warning */)
			s rc=$$SetApproval^MIRRORCTL(mirname,1,$G(^SYS("MIRRORSET",mirname,"Member",0)))
			quit 0
		}
		if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","("_mirname_") ValidateFailoverPartner: Validation succeed.")
		s DPret=$LG(rc,6)
		if DPret'="",+$LG(DPret) {
			s DPval=$LG(DPret,2)
			s cls=##class(Config.Mirrors).Open(mirname,,,.rc)
			if '('rc),DPval'=cls.DefinedPrimary {
				s OldDP=cls.DefinedPrimary
				s cls.DefinedPrimary = DPval
				s rc=cls.%Save()
				if (''rc) {
					d $zu(9,"","The 'no failover' is "_$s(DPval="":"cleared",1:"set to '"_DPval)_"' due to primary setting",0,0  /* Informational message */) 
				} else {
					d $zu(9,"","Failed to update 'no failover' when two failover members have mismatched value, error="_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
				}
			}
		}
		quit 1
	}
	if $LG(rc)="UNKNCMD" {
		if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","("_mirname_") ValidateFailoverPartner: Remote does not recognize VALIDATEPARTNER request")
		Quit 1
	}
	if $LG(rc)="LOCALSSLERR" {
		s rc=$$AddPendingDNUpdates^MIRRORCOMM(mirname,name,addrlist,targguid,basedir)
		if '+$LG(rc) {
			d $zu(9,"","ValidateFailoverPartner: (LOCALSSLERR) Failed to add pending DN updates list for member """_name_""" reason: "_$lg(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
		}
		quit 0
	}
	if $LG(rc)="ERR" {
		if forceBecomePrimary {
			d $zu(9,"","Ignoring connection ERR in ValidateFailoverPartner because forceBecomePrimary flag is set",1 /* broadcast and log message*/,1  /* Warning */)
			Quit 1
		}
		d $zu(9,"","ValidateFailoverPartner: Failed: "_$LG(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
		Quit 0
	}
	if $LG(rc)="TIMEOUT" {
		if forceBecomePrimary {
			d $zu(9,"","Ignoring timeout of ValidateFailoverPartner because forceBecomePrimary flag is set",1 /* broadcast and log message*/,1  /* Warning */)
			Quit 1
		}
		d $zu(9,"","ValidateFailoverPartner: Failed to contact other failover member - waiting for other node to become available",1 /* broadcast and log message*/,1  /* Warning */)
		quit 0
	}
	d $zu(9,"","ValidateFailoverPartner: Unknown return code "_$LG(rc),1 /* broadcast and log message*/,1  /* Warning */)
	quit 0
}
BackupDaemonExit(mirname,timeout,PID="") {
	Lock +^SYS("MIRRORSET",mirname,"BackupClient"):timeout s rc=$T
	i rc Lock -^SYS("MIRRORSET",mirname,"BackupClient")
	if 'rc,PID'="",$zu(67,1,$LG(PID))'=2 quit 1
	if rc,PID'="",$zu(67,0,$LG(PID))=2,$zu(67,30,$LG(PID))=$LG(PID,2) s rc=0
	quit rc
}
CheckForDuplicateLastJournalfiles(mirname,mirfilecnt,jrnfile,jrninfo) {
	s $zt="err"
	Quit:+$G(^SYS("MIRRORSET"))
	s id=1  ;other failover member, if there is one
    s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
    if info="" {
	    if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","CheckForDuplicateLastJournalfiles: No other failover member defined, journal file "_jrnfile_" - retained")
	    quit
    }
    s name=$LG(info,1)
	s rc=+jrninfo  ; from $$$JRNHDRALL(jrnfile)
	if rc<1 {
		d $zu(9,"","Unable to read journal header from file #"_mirfilecnt_" to check for duplicate last journal file ("_jrnfile_")",1 /* broadcast and log message*/,1  /* Warning */)
		quit
	}
	s jrnguid=$P(jrninfo,",",7+1)
	s sysguid=$P(jrninfo,",",14+1)  ;mirror system guid that created this file
	s filecnt=$P(jrninfo,",",13+1)
	if filecnt'=mirfilecnt {
		d $zu(9,"","CheckForDuplicateLastJournalfiles found filecnt recorded in log ("_mirfilecnt_") does not match the file count in the header ("_filecnt_") for "_jrnfile,1 /* broadcast and log message*/,2  /* Severe error */)
		quit
	}
	; If we didn't create the file, then we keep it
    s ourinfo=$G(^SYS("MIRRORSET",mirname,"Member",0))
    s ourguid=$LG(ourinfo,2)
	if ourguid'=sysguid {
		if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","CheckForDuplicateLastJournalfiles: Journal file "_jrnfile_" was created by a different instance with system guid "_sysguid_" while our guid is "_ourguid_" - retained")
		quit
	}
	if +$P(jrninfo,",",32+1)=mirfilecnt||($P(jrninfo,",",2+1)'="") {
		if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","CheckForDuplicateLastJournalfiles: Journal file "_jrnfile_" has next file or this is the first file when it became primary - retained")
		quit
	}
	s rc=$$GetMaxDBJrnInfo^MIRRORMGR(mirname)
	if '$LG(rc) {
		if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","CheckForDuplicateLastJournalfiles failed to determine target dejournal position")
	} else {
		s reqfilecnt=$LG(rc,2)
		if reqfilecnt >= mirfilecnt {
			if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","CheckForDuplicateLastJournalfiles: There are databases with a filecnt ("_reqfilecnt_") >= than ("_mirfilecnt_") from "_jrnfile_" - retained")
			quit
		}
	}
    s rc=$$GetJournalInfo^MIRRORCTL(mirname,id,3,mirfilecnt)
	; returns $LB(status,$LB(loginfo,hdrinfo)) where logfile = journal log file, hdrinfo = $$$JNRHDRALL
	s status=$LG(rc)
	if status'="OK"||($LG($LG(rc,2),2)=0) {
		if status="ERR" {
			s msg=$LG(rc,2)
			if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","CheckForDuplicateLastJournalfiles: Retained file, error retrieving info for file #"_mirfilecnt_" ("_jrnfile_") from "_name_": "_msg)
		} else {
			if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","CheckForDuplicateLastJournalfiles: File #"_mirfilecnt_" ("_jrnfile_") not found on "_name_" - retained")
		}
		quit
	}
	s val=$LG(rc,2)
	s loginfo=$LG(val,1)
	s hdrinfo=$LG(val,2)
	s otherfilecnt=+$P(hdrinfo,",",13+1)
	s otherjrnguid=$P(hdrinfo,",",7+1)
	if otherjrnguid=jrnguid {
		if $zb(+$SYSTEM.Mirror.DebugFlags(),+$ZH("80"),1) do $zu(9,"","CheckForDuplicateLastJournalfiles: File #"_mirfilecnt_" has the same journal guid ("_jrnguid_") as on "_name_" - retained")
		quit
	}		
	s rc=$$GetJournalInfo^MIRRORCTL(mirname,id,7)
	if $LG(rc)'="OK" {
		s msg=$LG(rc,2)
		d $zu(9,"","Journal file #"_mirfilecnt_" ("_jrnfile_") appears to be different "_name_" however the max dejournal point for "_name_" returned "_msg_". One of these files needs to be removed before this system will connect to the mirror",1 /* broadcast and log message*/,2  /* Severe error */)
		quit
	}
	s res=$LG(rc,2)
	s otherreqfilecnt=$LG(res,1)
	s rmvjrnfile=jrnfile
	if ''$ZU(140,4,jrnfile)&&'$ZU(140,4,jrnfile_"z") s rmvjrnfile=jrnfile_"z"
	if otherreqfilecnt>=mirfilecnt {
		s x=('$zu(140,6,rmvjrnfile,rmvjrnfile_"-REMOVED"))
		if 'x {
		   d $zu(9,"","CheckForDuplicateLastJournalfiles failed to rename "_jrnfile_". It should be removed because "_name_" created the same journal file but its databases are current as of "_otherreqfilecnt_", beyond the filecnt ("_mirfilecnt_") of the local file so the local file is not required",0,0  /* Informational message */)
		   quit  ; return
		}
	   d $zu(9,"","CheckForDuplicateLastJournalfiles renamed "_jrnfile_" to """_jrnfile_"-REMOVED"" because it differs from the copy on "_name_" and "_name_"'s databases are current as of "_otherreqfilecnt_", beyond the filecnt ("_mirfilecnt_") of the local file",0,0  /* Informational message */)
	} else {
		s x=('$zu(140,6,rmvjrnfile,rmvjrnfile_"-REMOVED"))
		if 'x {
			d $zu(9,"","CheckForDuplicateLastJournalfiles failed to rename "_jrnfile_". It should be removed because it differs from the copy on the other failover member and neither failover member's databases ("_otherreqfilecnt_"/"_reqfilecnt_") are current as of this file "_mirfilecnt,0,0  /* Informational message */)
			quit  ; return
		}
		d $zu(9,"","CheckForDuplicateLastJournalfiles renamed "_jrnfile_" to """_jrnfile_"-REMOVED"" because it differs from the copy on "_name_" and neither failover member's databases ("_otherreqfilecnt_"/"_reqfilecnt_") are current as of this file "_mirfilecnt,0,0  /* Informational message */)
	}
    s x=$$BuildMirrorLogFromJournalFiles^MIRRORCOMM(mirname,0,"")
	if +x<0 {
		d $zu(9,"","CheckForDuplicateLastJournalfiles failed to rebuild mirror journal log file: "_$P(x,",",2,*),1 /* broadcast and log message*/,2  /* Severe error */)
		quit   
	}
	quit
err ;
	s $ZT=""
	d $zu(9,"","CheckForDuplicateLastJournalfiles caught error "_$ZE,1 /* broadcast and log message*/,2  /* Severe error */)
	D BACK^%ETN
	quit
}
CheckNewDataForPromotedStandalone(mirname) {
	if '$d(^MIRROR(mirname,"PromotedNotQueried")) Quit 0
	s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)
	if rc<0 {
		d $zu(9,"","CheckNewDataForPromotedStandalone Failed to find last mirror journal file rc="_rc,1 /* broadcast and log message*/,1  /* Warning */)
		Quit 0
	} elseif '+rc {
		s (lastjrnfcnt,lastjrnfend)=0
	} else {
		s lastjrnfcnt=+rc
		s fname=$p(rc,",",2)
		s fd=$zu(78,5,fname,0)
		if fd'<0 {
			do $zu(78,6,fd)
			s lastjrnfend=$zu(78,18,0)
			do $zu(78,7,fd)
		} else {
			s lastjrnfend=0
		}
	}
	s id=$O(^SYS("MIRRORSET",mirname,"Member",0),1,info)
	s curfcnt=0,curfend=0,firstfcnt=0,curid=""
	s NewData=0,oldlastjrnfcnt=lastjrnfcnt
	while (id'="") {
		set name=$LG(info)
		if '$d(^MIRROR(mirname,"PromotedNotQueried",name)) {
			s id=$O(^SYS("MIRRORSET",mirname,"Member",id),1,info)
			continue
		}
		s rc=$$GetJournalInfo^MIRRORCTL(mirname,id,1,1,2,1)
		if $LG(rc)="OK" {
			s CheckedMember(name)=id
			s rc=$LG(rc,2)  ; The $lb(firstfcnt,lastfcnt,firstjrnend,lastjrnend)
			s fcnt=$LG(rc,2),fend=+$LG(rc,4)
			if fend<0&&(fcnt>=lastjrnfcnt) {
				k CheckedMember(name)
				d $zu(9,"","CheckNewDataForPromotedStandalone: member '"_name_"' has invalid file end of "_fcnt_", the file could be encrypted.",0,0  /* Informational message */)
				goto NoValidEnd
			}
			if (fcnt>lastjrnfcnt)||(fcnt=lastjrnfcnt&&(fend>lastjrnfend)) {
				d $zu(9,"","CheckNewDataForPromotedStandalone: async member '"_name_"' has newer journal data than this member ("_fcnt_"/"_fend_")",0,0  /* Informational message */)
				if (fcnt>curfcnt)||(fcnt=curfcnt&&(fend>curfend)) {
					s curfcnt=fcnt,curfend=fend,curid=id
					if 'lastjrnfcnt,$LG(rc,1)>firstfcnt s firstfcnt=$LG(rc,1)
					s ^MIRROR(mirname,"PromotedQueried",name)=$LB(3)_rc
				} else {
					s ^MIRROR(mirname,"PromotedQueried",name)=$LB(2)_rc
				}
			} else {
				d $zu(9,"","CheckNewDataForPromotedStandalone: async member '"_name_"' does not have any newer journal data than this member ("_fcnt_"/"_fend_")",0,0  /* Informational message */)
				s ^MIRROR(mirname,"PromotedQueried",name)=$LB(1)_rc
			}
		} else {
NoValidEnd	if '$G(^MIRROR(mirname,"PromotedNotQueried",name)) {
				s ^MIRROR(mirname,"PromotedNotQueried",name)=1
				d $zu(9,"","CheckNewDataForPromotedStandalone: member '"_name_"' is unavailable to check for newer journal data.  (Request returned "_$LG(rc,2)_")",1 /* broadcast and log message*/,1  /* Warning */)
			}
		}
		s id=$O(^SYS("MIRRORSET",mirname,"Member",id),1,info)
	}
	if curfcnt {
nexttry	if 'lastjrnfcnt s lastjrnfcnt=firstfcnt
		s name=$LG(^SYS("MIRRORSET",mirname,"Member",curid))
		d $zu(9,"","CheckNewDataForPromotedStandalone: Retrieve files in async member '"_name_"' from "_lastjrnfcnt_"/"_lastjrnfend_" to "_curfcnt_"/"_fend,0,0  /* Informational message */)
		s UseAgent=1
GetAgain s rc=$$GetMissingJournalFiles^MIRRORCTL(mirname,curid,lastjrnfcnt,lastjrnfend,curfcnt,,,UseAgent)
		if $LG(rc)'="OK" {
			if $LG(rc,2)["No encryption key loaded",UseAgent,+$LG(^SYS("MIRRORSET",mirname,"Member",curid),8)'=0 {
				d $zu(9,"","CheckNewDataForPromotedStandalone: agent of member '"_name_"' can't load encryption key for encryped file. Try to talk to superserver.",0,0  /* Informational message */)
				s UseAgent=0
				goto GetAgain
			}
			d $zu(9,"","CheckNewDataForPromotedStandalone: Failed to retrieve files in async member '"_name_"', Error="_$LG(rc,2),1 /* broadcast and log message*/,1  /* Warning */)
			kill CheckedMember(name),^MIRROR(mirname,"PromotedQueried",name)
			s curfcnt=0,curfend=0,firstfcnt=0,curid="",lastjrnfcnt=oldlastjrnfcnt
			s name=$o(CheckedMember(""))
			while name'="" {
				s rc=^MIRROR(mirname,"PromotedQueried",name)
				s code=+$LG(rc)
				if code>1 {
					s fcnt=$LG(rc,3),fend=+$LG(rc,5)
					if (fcnt>lastjrnfcnt)||(fcnt=lastjrnfcnt&&(fend>lastjrnfend)) {
						if (fcnt>curfcnt)||(fcnt=curfcnt&&(fend>curfend)) {
							s curfcnt=fcnt,curfend=fend,curid=CheckedMember(name)
							if 'lastjrnfcnt,$LG(rc,2)>firstfcnt s firstfcnt=$LG(rc,2)
						}
					}
				}
				s name=$o(CheckedMember(name))
			}
			if curfcnt goto nexttry
		} else {
			d $zu(9,"","CheckNewDataForPromotedStandalone: Successfully retrieved files in async member '"_name_"' from "_lastjrnfcnt_"/"_lastjrnfend_" to "_curfcnt_"/"_fend,0,0  /* Informational message */)
			s NewData=1
		}
	}
	s name=$o(CheckedMember(""))
	while name'="" {
		k ^MIRROR(mirname,"PromotedNotQueried",name)
		s name=$o(CheckedMember(name))
	}
	Quit NewData
}
NeedToScanAsync(mirname) PUBLIC {
	s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)
	if rc<0 {
		d $zu(9,"","NeedToScanAsync Failed to find last mirror journal file rc="_rc,1 /* broadcast and log message*/,1  /* Warning */)
		Quit 0
	} elseif '+rc {
		Quit 0
	} else {
		s info=$zu(78,22,$p(rc,",",2),99)
		if (+info<1) {
			d $zu(9,"","NeedToScanAsync Failed to find info of last mirror journal file ("_$p(rc,",",2)_")",1 /* broadcast and log message*/,1  /* Warning */)
			Quit 0
		}
		s sysguid=$P(info,",",14+1)
	}
	s systemcnt=$G(^SYS("MIRRORSET",mirname,"Member"),0),found=0
	for i=0:1:systemcnt {
		if $LG($G(^SYS("MIRRORSET",mirname,"Member",i)),2)=sysguid {
			s found=1
			quit
		}
	}
	q 'found
}
CheckMirrorRunning(mirname,daemon) PUBLIC {
	s $ZT="err"
	lock +^MIRROR(mirname,"MgrJobID"):$s(daemon:5,1:0)
	if '$T Quit 1
	s mgrjobid=$G(^MIRROR(mirname,"MgrJobID"),"")
	if (+mgrjobid)&&($zu(67,+mgrjobid)=$p(mgrjobid,",",2))&&($zu(61,30,$p(mgrjobid,",",2))=$p(mgrjobid,",",3)) {
		Lock -^MIRROR(mirname,"MgrJobID")#"I"
		d $zu(9,"","The running mirror set '"_mirname_"' has lost the lock node ^MIRROR("""_mirname_""",""MgrJobID"")",1 /* broadcast and log message*/,1  /* Warning */)
		Quit 1
	}
	s state=$SYSTEM.Mirror.GetInfo()
	if state["PRIMARY"||(state["BACKUP"&&($SYSTEM.Mirror.IsMember()=1))||($SYSTEM.Mirror.GetStatus(mirname)="CRASHED") {
		Lock -^MIRROR(mirname,"MgrJobID")#"I"
		d $zu(9,"","The mirror master daemon"_$s(+mgrjobid:"(PID "_(+mgrjobid)_")",1:"")_" is gone while mirror status is "_state,1 /* broadcast and log message*/,1  /* Warning */)
		Quit 1
	}
	Lock:'daemon -^MIRROR(mirname,"MgrJobID")#"I"
	if daemon {
		s ^MIRROR(mirname,"MgrJobID")=+$J_","_$ZU(61)_","_$ZU(61,30,$ZU(61)) ;pid,job#,jobid
	}
	Quit 0
err s $zt=""
	d $zu(9,"","CheckMirrorRunning^MIRRORMGR: Unexpcted error "_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	Lock -^MIRROR(mirname,"MgrJobID")#"I"
	ZTRAP $ZERROR
	Quit 0
}
CheckForCopiedInstance(mirname) {
	s $zt="err"
	s rc=$$ValidateLocalInstance^MIRRORCTL(mirname)
	if $LG(rc)="OK" {
		; In case the localvalidateionfailure node exists from before
		k ^SYS("MIRRORSET",":LocalValidationFailure",mirname)
		quit 1    ; success
	}
	; maybe instead of killing this node, we should pick a new guid if it exists?
	k ^SYS("MIRRORSET",":LocalValidationFailure",mirname)
	s ^SYS("MIRRORSET",":LocalValidationFailure",mirname)=rc
	if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","Local validation failed for "_mirname_", Reason: /"_$$Format^%qcr(rc,1)_"/")
	while $LG(rc)="TIMEOUT" {
		d $zu(9,"","Error: "_"Mirror startup timed out contacting ourself to validate local instance - continuing to retry. See ^MIRROR",1 /* broadcast and log message*/,2  /* Severe error */),BACK^%ETN
		for i=1:1:300 {  ; retry for 5 minutes at 1 second intervals
			h 1
			s rc=$$ValidateLocalInstance^MIRRORCTL(mirname)
			quit:$LG(rc)'="TIMEOUT"
		}
	}
	if $LG(rc)="OK" {
		k ^SYS("MIRRORSET",":LocalValidationFailure",mirname)
		quit 1    ; success
	}
	; Update the reason with the new one and then we can return
	s ^SYS("MIRRORSET",":LocalValidationFailure",mirname)=rc
	; We failed for some reason other than the timeout
	d $zu(9,"","Error: "_"Mirror startup aborted, local validation failed: See ^MIRROR",1 /* broadcast and log message*/,2  /* Severe error */),BACK^%ETN
	quit 0
err ;
 	s $zt=""
 	d BACK^%ETN
 	d $zu(9,"","Error: "_"Unexpected error in CheckForCopiedInstance^MIRRORMGR: "_$ZE_". Returning failure",1 /* broadcast and log message*/,2  /* Severe error */),BACK^%ETN
 	quit 0  ; return failure
}
CheckAsyncJrnfilePurge(mirname) {
	Quit:'$System.Mirror.IsAsyncMember()||('$System.Mirror.AsyncMemberType())||$G(^SYS("MIRRORSET",0,"AsyncUseSystemPurgeInterval"))
	if $D(^MIRROR(mirname,"PendingPurgeList"))\10 {
		if +$G(^SYS("MIRRORSET",0,"AsyncUseSystemPurgeInterval"))'=0 {
			k ^MIRROR(mirname,"PendingPurgeList")
		} else {
			; If there are children, then see if we can purge them now
			; (the children are mirror journal file #'s which have been
			; fully dejournaled).
		   do AsyncJrnfilePurge(mirname)
		}
	}
}
RunZMIRROR(EntryID,Flags=0) {
	s $zt="Error"
	n $Roles
	s EntryText=$case(EntryID,1:"CanNodeStartToBecomePrimary",2:"CheckBecomePrimaryOK",3:"NotifyBecomePrimary",4:"NotifyBecomePrimaryFailed",:"Unknown")
	s rc=$$License^STU()
	if ('rc) d $zu(9,"","Unable to acquire a license for 'User Startup' for "_EntryText_"^ZMIRROR.",1 /* broadcast and log message*/,1  /* Warning */)
	s OldUsername=$SYSTEM.Security.Users.PrincipalNameGet()
	i $$ParseUsername^%SYS.SECURITY("%System",,,,1) ; Sets $username to %System. 
	s OldAutheLevel=$SYSTEM.Security.Users.SetSecurityLevel((2**10)/*1024 AutheSystem*/) 
	s rc=1
	Try {
		i (EntryID=1) s rc=$$CanNodeStartToBecomePrimary^ZMIRROR()
		i (EntryID=2) s rc=$$CheckBecomePrimaryOK^ZMIRROR()
		i (EntryID=3) do NotifyBecomePrimary^ZMIRROR()
		i (EntryID=4) do NotifyBecomePrimaryFailed^ZMIRROR()
	} catch errv {
		s rc=1
	   	if "<NOROUTINE>,<NOLINE>"[errv.Name {
			if $zb(Flags,1,1) {
				if '(EntryID=1) {
					d $zu(9,"",errv.Name_" calling "_EntryText_"^ZMIRROR - assuming success",1 /* broadcast and log message*/,1  /* Warning */)
				} else {
					d $zu(9,"",errv.Name_" calling "_EntryText_"^ZMIRROR() - continuing to wait",1 /* broadcast and log message*/,1  /* Warning */)
					s rc=0
				}
			}
	   	} else {
		   s errtext=errv.Name_" at "_errv.Location
		   If (EntryID=1)&&'$zb(Flags,1,1) {
			   d $zu(9,"","Unexpected error: "_errtext_" calling "_EntryText_"^ZMIRROR() - BecomePrimary continuing, assuming success",1 /* broadcast and log message*/,1  /* Warning */)
		   } else {
			   s rc=0
			   If '(EntryID=2)||'$zb(Flags,1,1) d $zu(9,"","Unexpected error: "_errtext_" calling "_EntryText_"^ZMIRROR()"_$s($zb(Flags,1,1):" - continuing to wait",1:""),1 /* broadcast and log message*/,1  /* Warning */)
		   }
		   If (EntryID=3) D BACK^%ETN
	   	}
	}
End
 d $zu(115,15,0)   ; Disable SQL ECP Sync.
 i $d(OldUsername) d $SYSTEM.Security.Users.PrincipalNameSet(OldUsername)
 i $d(OldAutheLevel) d $SYSTEM.Security.Users.SetSecurityLevel(OldAutheLevel)
 do ZMRelease^STU()
 q rc
Error s $zt=""
 d $zu(9,"","RunZMIRROR: Caught error $ZE="_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
 g End
}
DejournalUpdaterChanged(mirname) {
	s miridx=$SYSTEM.Mirror.MirrorNameToIndex(mirname,1)+1
	if '$SYSTEM.Mirror.IsPrimary(),$SYSTEM.Mirror.DejournalGetSharid(miridx)>=0,$d(^||MIRROR(mirname,"UpdaterInfo"),UpdaterInfo) {
		d ##class(%SYS.Journal.System).GetDejournalSettings("mirror",mirname,,,,,.numupd,,)
		q:$LG(UpdaterInfo)=numupd 0
		s APDEnabled=1		; Assume PD is enabled.
		if $system.Mirror.IsMember()'=1 {
			s APD=$G(^SYS("MIRRORSET",mirname,"AllowParallelDejournaling"))
			s oAPD=$LG(UpdaterInfo,2),IsDR=$SYSTEM.Mirror.AsyncMemberType()=0
			s APDEnabled=$s(IsDR:oAPD'=1,1:oAPD=2)
			q:$s(IsDR:APD'=1,1:APD=2)'=APDEnabled 1
		}
		q:APDEnabled&&($LG(UpdaterInfo,3)'=$G(^%SYS("DEJOURNALING","NumUpdater"))||($LG(UpdaterInfo,4)'=$G(^MIRROR(mirname,"Config","NumUpdater")))) 1
	}
	q 0
}
RestartBackup(mirname,id,mgrpid) PUBLIC {
	Quit:'$G(^MIRROR(mirname,"StartBackupDmnFailed")) 1
	job Backup^MIRRORCOMM(mirname,"",id,0,mgrpid):(:2):10
	i '$T {
		d $zu(9,"","MIRRORSVR failed to re-job backup client",1 /* broadcast and log message*/,2  /* Severe error */)
		Quit 0
	} else {
		s (^||MIRROR(mirname,"BackupClient"),^MIRROR(mirname,"BackupClient"))=$LB($ZC,$zu(67,30,$ZC))
		k ^MIRROR(mirname,"StartBackupDmnFailed")
		if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","Backup client re-started ("_$ZC_")")
		Quit 1
	}
}
 ;Used when we go to start the data channel but find the last journal file is
 ; compressed and we fail to decompress it. The data channel can't process 
 ; a compressed file.
RetryDecompressJournalFile(mirname,file) PUBLIC {
	if $E(file,*)'="z" {
		s uncompfile=file
		s file=file_"z"
	} else {
	    s uncompfile=$E(file,1,*-1)
	}
	if '$ZU(140,4,uncompfile) quit 1  ;already uncompressed
	if ''$ZU(140,4,file) quit 0
	s rc=$$decompressone^JRNZIP(file)
	quit $LG(rc)
}
MonitorJournalLogSize(mirname) PUBLIC {
	if '$d(^||MIRROR(mirname,"LogSizeThreshold"),checksize) {
		s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)
		if +rc'>0 Quit 0    ; Do nothing if can't find the last line in log.
		s checksize=($l($p(rc,",",2))+80)*2000
		s ^||MIRROR(mirname,"LogSizeThreshold")=checksize
		s ^MIRROR(mirname,"LogSizeThreshold")=checksize
	}
	s logf=$zu(12)_"mirrorjrn-"_mirname_".log"
	Quit:$zu(140,1,logf)<=checksize 0
	if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","MonitorJournalLogSize: Reducing log file size="_$zu(140,1,logf)_", checksize="_checksize)
	s rc=##class(SYS.Mirror).ReduceMirrorLogSize(mirname)
	if '(''rc) {
		d $zu(9,"","MonitorJournalLogSize: Failed to reduce size of mirror journal log "_logf_". Error: "_$SYSTEM.Status.GetErrorText(rc),1 /* broadcast and log message*/,1  /* Warning */)
	} else {
		s newsize=$zu(140,1,logf)
		if newsize>checksize {
			d $zu(9,"","MonitorJournalLogSize: mirror log file size ("_(newsize/1024)_" KB) exceeds threshold ("_(checksize/1024)_" KB). The journal purge could be malfunctioning, please check the journal purge is working as expected or not.",1 /* broadcast and log message*/,1  /* Warning */)
			s ^||MIRROR(mirname,"LogSizeThreshold")=newsize * 2
			s ^MIRROR(mirname,"LogSizeThreshold")=newsize * 2
		} else {
			if $zb(+$SYSTEM.Mirror.DebugFlags(),1,1) do $zu(9,"","MonitorJournalLogSize: Reduced log file size to "_$zu(140,1,logf))
		}
	}
	Quit 0
}
CheckOutOfSyncJournalFiles(mirname,id) {
	s $zt="error"
	if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","CheckOutOfSyncJournalFiles: entered id="_$s(id?.N:id,1:$LG(id)))
	do MountMirroredDBs("Mirror startup",mirname)
	s filecntend=0,dejrnchkfilecnt=0,dejrnchkoff=0,found=0
	s rc=$$GetMirroredDBList^MIRRORCOMM(mirname,.dblist,1)
    if $LG(rc) {
		s dir=$o(dblist(""),1,info)
		while dir'="" {
		   s dbtargjrncnt=$P(info,"^",18)
		   s dbtargend=$P(info,"^",19)
		   s dbjrncnt=$P(info,"^",3)
		   if 'found {
		      s dejrnchkfilecnt=dbtargjrncnt
			  s dejrnchkoff=dbtargend
			  s filecntend=dbjrncnt
			  s found=1
		   } else {
			  if dbtargjrncnt>dejrnchkfilecnt {
			      s dejrnchkfilecnt=dbtargjrncnt
				  s dejrnchkoff=dbtargend
			  } elseif dbtargjrncnt=dejrnchkfilecnt,dbtargend>dejrnchkoff {
				  s dejrnchkoff=dbtargend
			  }
			  if dbjrncnt>filecntend {
				  s filecntend=dbjrncnt
			  }
		   }
		   s dir=$o(dblist(dir),1,info)
		}
	}
	if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","CheckOutOfSyncJournalFiles: dejrnchkfilecnt="_dejrnchkfilecnt_", dejrnchkoff="_dejrnchkoff_", filecntend="_filecntend)
	s info=id
	if id?.N s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
	s addrlist=$$BuildAgentAddrlist^MIRRORCTL(info)
	s targguid=$LG(info,2)
	s basedir=$LG(info,6)
    s rc=$SYSTEM.Mirror.GetLastJournalFilename(mirname)  ;mirjrncnt,filename
	if +rc<=0 {
		if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","CheckOutOfSyncJournalFiles: last mirror journal file does not exist in journal log file.")
		quit 1
	}
	s filecnt=+rc,lastfilecnt=filecnt
	s filename=$p(rc,",",2)
	s retval=1
	while (filecnt) {
		s rmvfilename=filename
		if ''$ZU(140,4,filename)&&'$ZU(140,4,filename_"z") s rmvfilename=filename_"z"
		s jrninfo=$zu(78,22,filename,99)
		if (jrninfo>0) {
			s validend=+$P(jrninfo,",",16+1)
			s rc=$$GetJournalInfo^MIRRORCTL(mirname,info,3,filecnt)
			; returns $LB(<status>,$LB($SYSTEM.Mirror.GetJournalFileInfo(),$$$JRNHDRALL))
			s status=$LG(rc)
			if ($zb(+$SYSTEM.Mirror.DebugFlags(),2,1)) do $zu(9,"","CheckOutOfSyncJournalFiles: GetJournalInfo of #"_filecnt_" returned "_status)
			if status="OK" {
				s val=$LG(rc,2)
				s rmtjrninfo=$LG(val,2)
				if +rmtjrninfo=0 {
rmtnotexist			s msg="when it does not exist in remote failover member."
					if dejrnchkfilecnt,dejrnchkfilecnt>=filecnt {
						d $zu(9,"","The dejournal check point (#"__dejrnchkfilecnt_") in this member does not exist in primary member",1 /* broadcast and log message*/,2  /* Severe error */)
badmember				d $zu(9,"","This member has detected that its data is inconsistent with the mirror "_mirname_". If the primary is running and has the correct mirrored data, this member, including its mirrored databases, must be rebuilt. See 'Rebuilding a Mirror Member' in the Mirroring chapter of documentation for details.",1 /* broadcast and log message*/,2  /* Severe error */)
						s retval=-1
						quit
					}
renamefile			s x=('$zu(140,6,rmvfilename,rmvfilename_"-REMOVED"))
					if 'x {
						d $zu(9,"","CheckOutOfSyncJournalFiles failed to rename "_rmvfilename_", "_msg,1 /* broadcast and log message*/,1  /* Warning */)
					} else {
						d $zu(9,"","CheckOutOfSyncJournalFiles renamed "_rmvfilename_" to "_rmvfilename_"-REMOVED, "_msg,1 /* broadcast and log message*/,1  /* Warning */)
					}
					s anyremoved=1
				} else {
					s rmtsysguid=$P(rmtjrninfo,",",14+1)
					s rmtvalidend=+$P(rmtjrninfo,",",16+1)
					if rmtsysguid'=$P(jrninfo,",",14+1) {
						if dejrnchkfilecnt,dejrnchkfilecnt>=filecnt {
							d $zu(9,"","The GUID of journal file #"_filecnt_" is different from primary's journal file, and the dejournal check point (#"_dejrnchkfilecnt_") of this system is beyond this file.",1 /* broadcast and log message*/,2  /* Severe error */)
							goto badmember
						}
						s msg="when journal files were created by different mirror member"
						goto renamefile
					}
					if validend {
						if validend=rmtvalidend,filecntend=0||(filecnt<filecntend) quit
						if dejrnchkfilecnt,rmtvalidend,dejrnchkfilecnt>filecnt||((dejrnchkfilecnt=filecnt)&&(dejrnchkoff>rmtvalidend)) {
							d $zu(9,"","The journal file #"_filecnt_" in primary has valid end "_rmtvalidend_" and it is behind the dejournal check point "_dejrnchkfilecnt_"/"_dejrnchkoff_" in this member",1 /* broadcast and log message*/,2  /* Severe error */)
							goto badmember
						}
						if validend'=rmtvalidend {
							s msg="when journal files have different valid end ("_validend_" vs "_rmtvalidend_")."
							goto renamefile
						}
					} elseif dejrnchkfilecnt,rmtvalidend,dejrnchkfilecnt>filecnt||((dejrnchkfilecnt=filecnt)&&(dejrnchkoff>rmtvalidend)) {
						d $zu(9,"","The journal file #"_filecnt_" in primary has valid end "_rmtvalidend_" and it is behind the dejournal check point "_dejrnchkfilecnt_"/"_dejrnchkoff_" in this member",1 /* broadcast and log message*/,2  /* Severe error */)
						goto badmember
					}
				}
			} elseif status="NOTFOUND" {
				goto rmtnotexist
			} else {
				d $zu(9,"","CheckOutOfSyncJournalFiles: Failed to get journal info of file #"_filecnt_" ("_filename_") from remote failover member '"_$LG(info)_"'.",1 /* broadcast and log message*/,1  /* Warning */)
				s retval=0
				quit
			}
		}
		s filecnt=filecnt-1
		if filecnt<filecntend quit
		s rc=$SYSTEM.Mirror.GetJournalFileByMjrncnt(filecnt,mirname)
		if +rc<=0 quit
		s filename=$p(rc,",",2)
	}
	if $g(anyremoved) s x=$$BuildMirrorLogFromJournalFiles^MIRRORCOMM(mirname,0,"")
	quit retval
error s $zt=""
	d $zu(9,"","CheckOutOfSyncJournalFiles: Caught Error $ZE="_$ZE,1 /* broadcast and log message*/,1  /* Warning */)
	quit 0
}
RetryCheckOutOfSyncJournalFiles(mirname,id) PUBLIC {
	s info=$G(^SYS("MIRRORSET",mirname,"Member",id))
	if info="" quit 0
	s $li(info,8)=0
	quit $$CheckOutOfSyncJournalFiles(mirname,info)
}

MIS1^INT^1^67214,47331
MIS1 ; ADD/EDIT device to ^%IS
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
A W ?36,"Prompt",?46,"Other OPEN",?58,"Alt",!
 W "MNE",?11,"Dev",?22,"Type",?28,"Subtype",?37,"code"
 W ?46,"parameters",?58,"dev",?64,"Location",!!
B ;
 R MNE Q:MNE=""  G:MNE="?" HELP F I=1:1:7 S Z(I)=""
 I $D(^%IS(MNE,1)) S A=MNE D LOOK S A=^(1) F I=1:1:7 S Z(I)=$P(A,"^",I)
 ;I MNE?.N S DEV=+MNE,MNE=DEV G DEVCHK
 I MNE="DELETE"!(MNE="DEL") D DELETE G B
 G DEV:MNE'["?" S A=$P(MNE,"?",1)
 D LOOK W:X="" " [no such device on record]",! G B
DEV ;
 R ?11,DEV S:DEV="" DEV=Z(1) S:DEV="" DEV=MNE ;I DEV'?1N.N W " ???",! G B
DEVCHK ;
 ;I DEV>143!($V(DT+DEV)#256=255)!'DEV W " ???",! G B
TYPE ;
 R ?22,TYPE S:TYPE="" TYPE=Z(2)
 F I=1:1:6 G SUB:$P("TRM^MT^BT^SPL^IPC^OTH","^",I)=TYPE
 W !,"    [""TRM"", ""MT"", ""BT"", ""SPL"", ""IPC"", or ""OTH""]",!
 G TYPE 
SUB ;
 S (SUB,PROMPT,SEC,OTH,ALT)=""
 G PROMPT:TYPE'="TRM"&(TYPE'="SPL")&(TYPE'="MT")&(TYPE'="BT")&(TYPE'="IPC")
 R ?28,SUB S:SUB="" SUB=Z(3) G PROMPT:SUB="" I '$D(^%IS(0,"SUB",SUB)) W " [must be a defined subtype (or press RETURN)]",! G SUB
PROMPT ;
 R ?37,PROMPT S PROMPT=$S(PROMPT="":Z(4),PROMPT=0!(PROMPT="DEL"):"",1:PROMPT)
 I PROMPT'="",PROMPT'=1,PROMPT'=2 W " [0, 1 or 2 (or press RETURN)]",! G PROMPT
 G OTH:TYPE'="TRM"
SEC ;
 ;R ?46,SEC S SEC=$S(SEC="":Z(5),SEC="DEL":"",1:SEC) G ALT:SEC=""
 ;I '$D(^%IS(0,"SEC",SEC)) W " [must be a defined security code (or press RETURN)]",! G SEC
ALT ;
 R ?58,ALT I ALT="" S ALT=Z(7) G LOC
 I ALT="DEL" S ALT="" G LOC
 I '$D(^%IS(ALT,0)) W " [invalid alternate device]",! G ALT
 G LOC
OTH ;
 R ?46,OTH S OTH=$S(OTH="":Z(6),OTH="DEL":"",1:OTH)
 I OTH[":",OTH'?1"(".E1")" W " [must surround with () if there is a "":""]",! G OTH
LOC ;
 R ?64,LOC,! I LOC="",$D(^%IS(MNE,0)) S LOC=^(0)
 I LOC="DEL"!(LOC="DELETE") S LOC=""
SET ;
 S ^%IS(MNE,0)=LOC,X=DEV_"^"_TYPE_"^"_SUB_"^"_PROMPT_"^"_SEC_"^"_OTH_"^"_ALT
 S ^(1)=X I MNE'=DEV,'$D(^%IS(DEV)) S ^(DEV,0)=LOC,^(1)=X
 G B
 Q
DELETE ;
 R "  Delete device: ",A G B:A="" D LOOK W:X="" " [no such device on record]" w ! G:X="" B
 w "Is this the device to be deleted?" d NY w ! q:'$t
 K ^%IS(A) S MNE=A D DELALT I +A=A S B=0 F I=1:1 S B=$N(^%IS(B)) Q:B<0  I B'=+B,$D(^(B,1)) S C=^(1) I +C=A K ^%IS(B) S MNE=B D DELALT
 Q
DELALT ;
 S D=0 F K=1:1 S D=$N(^%IS(D)) Q:D<0  I $D(^(D,1)),$P(^(1),"^",7)=MNE S ^(1)=$P(^(1),"^",1,6)_"^"
 Q
LOOK ;
 S X="" I A]"",$D(^%IS(A,1)) S X=^(1) w !,A F J=1,2,3,4,6,7,8 W ?$P("11^22^28^37^^46^58^64","^",J)-1," ",$P(X,"^",J) W:J=8 $G(^(0)),!
 Q
 ;
NY n X,A s X=$X
NYQ r "  No=> ",A s A=$f("NnYy",$e(A)) i 'A w !?X g NYQ
 i A'<4
 q
HELP ;
 W !,"This utility is used to add or edit the %IS parameters for devices.",!
 W "Specify the device # or mnemonic for device; ""TRM"", ""MT"", ""BT"", ""SPL"",or ""OTH""",!
 W "for type; device subtype for terminals or spool.",!
 W "You may leave the prompt code empty or select one of the following codes:",!
 W ?5,"1   When %IS is called and this device is your current device, the",!
 W ?11,"device question is suppressed and your current device is selected.",!
 W ?5,"2   When %IS is called and this device is selected, the ""Right margin""",!
 W ?11,"or ""Parameter"" question is suppressed.",!
 W "You can specify additional open parameters for non-terminal devices.",!!
 W "To examine a device, put a ? at the end of the device name, e.g., ""TT?"".",!
 W "To delete a device, type ""DEL"" in the ""MNE"" field, and the computer will",!
 W "ask what device should be deleted.",!!
 W "When editing a device, unanswered questions retain their previous values.",!
 W "To delete a value, type ""DEL"".",!!
 G A

MIS2^INT^1^67214,47331
MIS2 ;(PTR,CHH,PK) ADD/EDIT DEVICE SUBTYPES
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
A W !,"Terminal subtypes are used by the %IS utility to specify terminal",!
 W "characteristics such as screen length, form feed characters, etc.  For each",!
 W "terminal there should be a subtype.  In general, you should follow these",!
 W "naming conventions:",!
 W ?5,"C-...",?15,"CRT terminal",!,?5,"P-...",?15,"Printer without keyboard",!
 W ?5,"PK-...",?15,"Printer with keyboard",!!
 W "This utility is used to add new terminal subtypes and edit existing ones."
B W !!,"Subtype",?9,"IORM",?15,"IOSL",?21,"IOBS/",?40,"IOF/",!,?21,"ZBS",?40,"ZFF",!!
 S A="" F I=1:1 S A=$O(^%IS(0,"SUB",A)) Q:A=""  S X=^(A),W=$P(X,"^",2),Y=$P(X,"^",5) W A,?10,+X,?15,$P(X,"^",3),?21,$P(X,"^",4) D B0
 G C
B0 S Z=$X I $L(W)+Z>80,Z>39 W !
B1 I $L(W)>40 W ?40,$E(W,1,40),! s W=$E(W,41,$L(W)) G B1
 W ?40,W S W=$P(X,"^",9) W:W'="" !,?21,W S W=$P(X,"^",8),Z=$X I $L(W)+Z>80,Z>39,W'="" W !
B2 I $L(W)>40 W ?40,$E(W,1,40),! S W=$E(W,41,$L(W)) G B2
 W ?40,W
B3 W:Y'="" !,?6,"XY:"
B4 I $L(Y)>70 W ?10,$E(Y,1,70),! S Y=$E(Y,71,$L(Y)) G B4
 W:Y'="" ?10,Y W !! Q
C R !,"Add/edit subtype: ",A,! Q:A=""
 I $D(^%IS(0,"SUB",A)) S X=^(A),IORT=+X,IOF=$P(X,"^",2),IOSL=$P(X,"^",3),IOBS=$P(X,"^",4),XY=$P(X,"^",5),IOZF=$P(X,"^",8),IOZB=$P(X,"^",9)
 E  R "*** Not found.  Add a new subtype?" d NY w ! G C:'$t S IORT=$S(A?1"C".E:80,1:132),IOF="#",IOSL=$S(A?1"C".E:24,1:66),IOBS="$C(8)",XY="",IOZF="",IOZB=IOBS_"_"" ""_"_IOBS
RIGHT W "Right margin: ",IORT,"=> " R C G FF:C="" I (C>255)!(C'?.N) W " ???",! G RIGHT
 S IORT=+C
FF W !,"Form feed (clear screen and home cursor): ",IOF,"=> " R C,! I C]"" S IOF=C
SL W "Screen length: ",IOSL,"=> " R C G BS:C="" I 'C!(C>100)!(C'?.N) W " ???",! G SL
 S IOSL=C
BS W !,"Backspace code (decimal value of ASCII char): ",IOBS,"=> " R C G XY:C=""
 I C?1"*".E S C=$E(X,2,9)
 I C?1"$C("1N.N1")" S C=$P(C,")",1),C=$E(C,4,9)
 I 'C!(C>143)!(C'?.N) W " ???" G BS
 S IOBS="$C("_+C_")"
XY W !,"Cursor control code: ",XY,"=> " R C I C]"" S XY=C
 ; Prompt for control sequences for the form feed and backspace that
 ; allow non-DG-standard terminals to echo these properly.
 ; After setting them here, the sequence to put them into effect is:
 ; D CURRENT^%IS
ZF D SETZF W !,"Form Feed for $ZU(22): ",IOZF,"=> " R C I C]""
 I C?1"?".E D TELLZF G ZF
 S:C]"" IOZF=$S(C="DEL"!(C="del"):"",1:C)
ZB D SETZB W !,"Backspace code for $ZU(22): ",IOZB,"=> " R C I C]""
 I C?1"?".E D TELLZB G ZB
 S:C]"" IOZB=$S(C="DEL"!(C="del"):"",1:C)
SET S ^%IS(0,"SUB",A)=IORT_"^"_IOF_"^"_IOSL_"^"_IOBS_"^"_XY_"^^^"_IOZF_"^"_IOZB_"^" W !! G C
 ;
NY n X,A s X=$X
NYQ r "  No=> ",A s A=$f("NnYy",$e(A)) i 'A w !?X g NYQ
 i A'<4
 q
SETZF Q:IOZF'=""!(IOF="#")  N I,J S I=$S($E(IOF,1,2)="#,":$E(IOF,3,$L(IOF)),1:IOF)
SETZF1 I $E(I)="*" S:IOZF'="" IOZF=IOZF_"_" S J=$F(I,","),IOZF=IOZF_"$C("_$S(J=0:$E(I,2,$L(I)),1:$E(I,2,J-2))_")" Q:J=0  S I=$E(I,J,$L(I)) G SETZF1
SETZF2 I $E(I)="""" S:IOZF'="" IOZF=IOZF_"_" D SETZF3 Q:I=""  G SETZF1
 E  S:IOZF'="" IOZF=IOZF_"_" S IOZF=IOZF_I Q
SETZF3 S J=$F(I,"""",2) S:J=0 J=$L(I)+1 S IOZF=IOZF_$E(I,1,J-1) S I=$S($E(I,J)=",":$E(I,J+1,$L(I)),J>$L(I):"",1:$E(I,J,$L(I))) G:$E(I)="""" SETZF3 Q
SETZB S:IOZB=""&(IOBS'="") IOZB=IOBS_"_"" ""_"_IOBS Q
TELLZF W !,"This formfeed sequence, entered as a single character string,"
 W !,"is used to produce formfeeds on non-DG terminals."
 W !,"E.g., $C(27)_""[2J""_$C(27)_""[H""" Q
TELLZB W !,"This destructive backspace sequence, entered as a single"
 W !,"character string, is used to produce backspaces on non-DG"
 W !,"terminals.  e.g., $C(8,32,8)" Q

MIS3^INT^1^67214,47331
MIS3 ;(?,PK) ADD/EDIT SECURITY CODES
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
A W !,"SECURITY CODES ARE USED BY THE %IS & SEC UTILITIES TO SPECIFY SIGNON AND",!
 W "SECURITY CHARACTERISTICS FOR EACH TERMINAL.  THIS UTILITY IS USED TO ADD NEW",!
 W "NEW SECURITY CODES AND EDIT EXISTING ONES.",!
 W "ALL PARTITION SIZES ARE IN K BYTES WITH INCREMENTS OF .5K",!,"SPECIFY 0 TO SELECT THE DEFAULT SIZE.",!!
B W !
C R !,"SECURITY CODE: ",CODE Q:CODE=""  S AUTO="",PAC="" I $D(^%IS(0,"SEC",CODE)) S AUTO=^(CODE),PAC=^(CODE,0)
 E  W "  REGISTER NEW CODE? NO=>" R X I X'?1"Y".E W ! G C
 W ! I AUTO]"" W "AUTOMATIC SIGNON TO ROUTINE: ",$P(AUTO,"_",2),"  IN DIRECTORY: ",^SYS("UCI",+AUTO) W:$P(AUTO,"_",3) "  IN PARTITION SIZE: ",+$P(AUTO,"_",3) W !
 I  R "DO YOU WANT TO CHANGE IT? NO=> ",A,! I A?1"Y".E S AUTO=""
 I AUTO="" R "DO YOU WANT AUTOMATIC SIGNON? NO=> ",X,! I X?1"Y".E D AUTO
 S ^%IS(0,"SEC",CODE)=AUTO I AUTO]"" S ^(CODE,0)="" W ! G C
D W "PROGRAMMER ACCESS CODE (TYPE CODE, 'NONE', OR '*' FOR STANDARD DEFAULT CODE)",!
 W "CODE: ",$S(PAC]"":PAC,1:"NONE"),"=> " R X I X]"" S PAC=$S(X="NONE":"",1:X)
 S ^%IS(0,"SEC",CODE,0)=PAC W !,"NOW SPECIFY THE DIRECTORIES THAT CAN BE ACCESSED,",!,"& THE ROUTINES THAT CAN BE STARTED UNDER EACH DIRECTORY",!
NEXUCI D UCI S X="" W ! S J=0 K Y G B:'U,ADD:'$D(^%IS(0,"SEC",CODE,U)) S X=^(U) G ADD:$P(X,"_",1)=""
 W "CURRENTLY ALLOWED ROUTINES:",! F J=1:1 S Y(J)=$P(X,"_",J) Q:Y(J)=""  W J,")",?4,$P(Y(J),":",1) W:$P(Y(J),":",2) ?20," SIZE: ",$P(Y(J),":",2)/2 W !
N1 R "DELETE ROUTINE #: ",A,! I A K Y(A) G N1
ADD W "ADD " D RT I R]"" S J=J+1,Y(J)=R_":"_SIZE G ADD
 S X="",A=-1 F I=1:1 S A=$N(Y(A)) Q:A<0  I Y(A)]"" S X=X_Y(A)_"_"
 S ^%IS(0,"SEC",CODE,U)=X
 W ! G NEXUCI
 ;
AUTO D UCI Q:'U  W ! D RT Q:R=""  S AUTO=U_"_"_R_"_"_SIZE Q
UCI S U=0 R "DIRECTORY NAME: ",A Q:A=""
 F U=1:1:^SYS("UCI") G U1:^SYS("UCI",U)=A
 S U=0 W " ???",! G UCI
U1 Q
RT R "ROUTINE: ",R I R="" W ! Q
 I R'["^" S R="^"_R
 I R'?.AN1"^"1AN.AN,R'?.AN1"^%".AN,R'?1"%".AN1"^"1AN.AN,R'?1"%".AN1"^%".AN W " ???",! G RT
A2 R "    PARTITION SIZE IN K BYTES (.5K INCREMENTS): ",SIZE I SIZE S SIZE=SIZE*2
 I SIZE'?.N!(SIZE>32) W " ???" G A2
 W ! Q

MIS4^INT^1^67214,47331
MIS4 ;(?,PK) LIST DEVICES & TABLES
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
A D OUT^%IS Q:POP  U IO W @IOF,!?30,"%IS table",?45 D ^%D W "  " D ^%T
 W !!?36,"Prompt",?46,"Other OPEN",?58,"Alt",!
 W "Device",?11,"#",?22,"Type",?28,"Subtype",?37,"code",?46,"parameters",?58,"dev",?64,"Location",!!
 S A=0 F I=1:1 S A=$N(^%IS(A)) Q:A<0  I $D(^(A,1)) S X=^(1) D A1
SUBTYPE ;
B W !!,"Subtype",?9,"IOM",?15,"IOSL",?21,"IOBS/",?40,"IOF/",!,?21,"ZBS",?40,"ZFF",!!
 S A="" F I=1:1 S A=$O(^%IS(0,"SUB",A)) Q:A=""  S X=^(A),W=$P(X,"^",2),Y=$P(X,"^",5) W A,?10,+X,?15,$P(X,"^",3),?21,$P(X,"^",4) D B0
 G B5
B0 S Z=$X I $L(W)+Z>80,Z>39 W !
B1 I $L(W)>40 W ?40,$E(W,1,40),! s W=$E(W,41,$L(W)) G B1
 W ?40,W S W=$P(X,"^",9) W:W'="" !,?21,W S W=$P(X,"^",8),Z=$X I $L(W)+Z>80,Z>39,W'="" W !
B2 I $L(W)>40 W ?40,$E(W,1,40),! S W=$E(W,41,$L(W)) G B2
 W ?40,W
B3 W:Y'="" !,?10,"XY:"
B4 I $L(Y)>66 W ?10,$E(Y,1,66),! S Y=$E(Y,67,$L(Y)) G B4
 W:Y'="" ?10,Y W !! Q
B5 ;W !!!,"Security codes",!!
 ;S CODE="" F A=1:1 S CODE=$O(^%IS(0,"SEC",CODE)) Q:CODE=""  D C
 U 0 I IO'="0",$I'=IO U IO W @IOF U 0 C IO
 Q
A1 I A=64 W !
 W A F J=1,2,3,4,6,7,8 W ?$P("11^22^28^37^^46^58^64","^",J)-1," ",$P(X,"^",J) I J=8 W $G(^(0)),!
 I A#8=7,A>63 W !
 Q
C W !,"Security code: ",CODE S AUTO="",PAC="" I $D(^%IS(0,"SEC",CODE)) S AUTO=^(CODE),PAC=^(CODE,0)
 I AUTO]"" W ?22,"Automatic signon to routine: ",$P(AUTO,"_",2)," in directory: ",^SYS("UCI",+AUTO) W:$P(AUTO,"_",3) " in partition size: ",+$P(AUTO,"_",3)/2
D I PAC]"" W ?22,"Programmer access code: ",$S(PAC="*":"DEFAULT",PAC]"":PAC,1:"NONE")
 S U=0 F I=1:1 S U=$N(^%IS(0,"SEC",CODE,U)) Q:U<0  S X=^(U) D UCI
 W ! Q
UCI W !,"Directory:  " I $D(^SYS("UCI",U)) W ^(U)
 E  W U
 F J=1:1 S Y=$P(X,"_",J) Q:Y=""  S B=$P(Y,"_",2) W:J#5=0 ! W ?J#5*15,$S($P(Y,"_",1)="":$P(B,":",1),1:$P(Y,":",1)) I $P(Y,":",2) W ":",$P(Y,":",2)/2
 W ! Q

MIS5^INT^1^67214,47331
MIS5 ;(KSO) Initialize the %IS global
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 I $D(^%IS) W !,"^%IS global already exists."
 I  I $$YN("Are you sure you want to reset it","Y")'="Y" Q
 ;
TRMTAB ;;,,,,DV,ALTOS5,ALTOS5,VT100,ANSI,ALTOS5,VT100,VT100,VT220
 ;
 N id,x,trm,MSYS,SX,VTXY,VTFF,VTEL,VTEP,VT,VTXT,DASHXY,DASHXT
 S id=$ZU(201,6),x=$P($T(TRMTAB),";;",2),x=$P(x,",",id)
 S MSYS=$S(id=1:"M/11+",id=2:"M/VX",id=3:"M/DG",id=4:"M/VM",id=5:"M/PC",id=28:"M/AV",1:"M/UX")
 S:x="" x="VT220" S trm="^TRM^C-"_x_"^^^^"
 ;
 S SX=" S $X=DX,$Y=DY"
 S VTFF="$C(27,91,72,27,91,74)" ;single string
 S VTXY="W $C(27,91)_(DY+1)_"";""_(DX+1)_""H"""_SX
 S VTEL="$C(27,91,75)",VTEP="$C(27,91,74)"
 S VT="$C(8)^"_VTXY_"^"_VTEP_"^"_VTEL ;standard VT definition
 S VTXT=VTFF_"^$C(8,32,8)" ;extra stuff for strange systems
 S DASHXY="W $C(30,70,80,DX\16+48,DX#16+48,DY\16+48,DY#16+48)"_SX
 S DASHXT="$C(12)^$C(25,32,25)"
 ;
 S ^%IS=""
 ;                 -=-=-=-= Device Subtypes =-=-=-=-
 D SUB("C-ADM3","80^#,*26^24^$C(8)^W $C(27,61,DY+32,DX+32)"_SX)
 D SUB("C-DATAMEDIA","80^#^24^$C(8)^W *30,*DX+32,*DY+32"_SX)
 D SUB("C-VT100","80^#,"_VTFF_"^24^"_VT)
 D SUB("C-VT101W","132^#,"_VTFF_"^14^"_VT)
 D SUB("C-VT132","132^#,"_VTFF_"^24^"_VT)
 D SUB("C-VT240","80^#,"_VTFF_"^24^"_VT_"^"_VTXT)
 D SUB("C-ALTOS5","80^#,"_VTFF_"^24^"_VT)
 ; Use different definition of ALTOS5 for Sequent,Sun,Motorola,Arix
 I (id=7)!(id=8)!(id=10)!(id=11) DO  ;special systems
 . D SUB("C-ALTOS5","80^#,"_VTFF_"^24^"_VT_"^"_VTXT)
 ;
 D SUB("C-ANSI","80^#,"_VTFF_"^25^"_VT_"^"_VTXT)
 I id=5 DO  ;PC uses different C-ANSI
 . D SUB("C-ANSI","79^#,"_VTFF_"^25^"_VT_"^"_VTXT)
 . D SUB("C-DV","79^#,"_VTFF_"^25^"_VT_"^"_VTXT)
 ;
 D SUB("C-VT220","80^#,"_VTFF_"^24^"_VT_"^"_VTXT)
 I id=32!(id=33) D SUB("C-NT CONSOLE","80^#,"_VTFF_"^25^"_VT_"^"_VTXT)
 D SUB("C-TV925","80^#,$C(27,44)^24^$C(8)^W $C(27,61,DY+32,DX+32)"_SX_"^^^$C(27,44)^$C(8,32,8)")
 D SUB("C-VT52","80^#,$C(27,72)_$C(27,74)^24^$C(8)^W $C(27,89,DY+32,DX+32)"_SX)
 D SUB("C-D210","255^#^24^$C(25)^"_DASHXY_"^^^"_DASHXT)
 D SUB("C-D410","255^#^24^$C(25)^"_DASHXT_"^^^"_DASHXT)
 D SUB("C-D470C","80^#^24^$C(25)^"_DASHXY)
 D SUB(MSYS,"255^#^66^$C(8)^^") ;for 'M/UX' type, etc
 D SUB("MAIL","132^#^11^$C(8)^^")
 D SUB("P-DEC","132^#^66^$C(8)^^")
 D SUB("PK-DEC","150^#^66^$C(8)^^")
 D SUB("PK-QUME","150^#^66^$C(8)^^")
 ;
 ;                  -=-=-=-= Actual Default Devices =-=-=-=-
 S ^%IS(1,0)="Console"
 S ^%IS(1,1)="1^TRM^"_trm
 I MSYS="M/UX" DO
 . S ^%IS(1,1)="/dev/console^TRM^"_trm
 . S ^%IS("/dev/console",0)="Console"
 . S ^%IS("/dev/console",1)="/dev/console"_trm
 S ^%IS(2,0)="Spool LA120"
 S ^%IS(2,1)="2^SPL^PK-DEC^^^^"
 S ^%IS("SPOOL",0)="Spool LA120"
 S ^%IS("SPOOL",1)="2^SPL^PK-DEC^^^^"
 ;
 S ^%IS(47,0)="Magnetic tape"
 S ^%IS(47,1)="47^MT^"_MSYS_"^^^(""auv"":0:2048)^"
 S ^%IS(48,0)="Magnetic tape"
 i ($zversion(1)=2) S ^%IS(48,1)="48^MT^"_MSYS_"^^^(""auv"":0:2048)^"
 e  S ^%IS(48,1)="48^MT^"_MSYS_"^^^(""avl"":0:2048)^"
 S ^%IS(49,0)="Magnetic tape"
 S ^%IS(49,1)="49^MT^"_MSYS_"^^^(""afu"":80:80)^"
 S ^%IS(50,0)="Magnetic tape"
 S ^%IS(50,1)="50^MT^"_MSYS_"^^^^"
 S ^%IS(57,0)="Cartridge tape"
 S ^%IS(57,1)="57^BT^"_MSYS_"^^^(""auv"":0:2048)^"
 ;
 S ^%IS("TERM",0)="Terminal"
 S ^%IS("TERM",1)="0"_trm
 S ^%IS("VT0:",0)="Virtual terminal"
 S ^%IS(0,0)="Principal device"
 S ^%IS(0,1)="0^TRM^C-VT220^^^^"
 ;
 I id=9 DO  ;XENIX specific devices
 . S ^%IS(47,0)="Overland Tape"
 . S ^%IS(47,1)="47^MT^M/UX^^^(""auv"":0:2048)^"
 . S ^%IS(50,0)="Cartridge Tape"
 . S ^%IS(50,1)="50^BT^M/UX^^^(""auv"":0:2048)^"
 . S ^%IS(51,0)="Floppy Disk 0"
 . S ^%IS(51,1)="51^BT^M/UX^^^(""auv"":0:2048)^"
 . S ^%IS(52,0)="Floppy Disk 1"
 . S ^%IS(52,1)="52^BT^M/UX^^^(""auv"":0:2048)^"
 . S ^%IS(53,0)="Floppy Disk 0 720K 3.5"""
 . S ^%IS(53,1)="53^BT^M/UX^^^(""auv"":0:2048)^"
 . S ^%IS(54,0)="Floppy Disk 0 1.44M 3.5"""
 . S ^%IS(54,1)="54^BT^M/UX^^^(""auv"":0:2048)^"
 . S ^%IS(55,0)="Floppy Disk 0 360K 5.25"""
 . S ^%IS(55,1)="55^BT^M/UX^^^(""auv"":0:2048)^"
 . S ^%IS(56,0)="Floppy Disk 0 1.2M 5.25"""
 . S ^%IS(56,1)="56^BT^M/UX^^^(""auv"":0:2048)^"
 . S ^%IS(58,0)="Minicartridge tape"
 . S ^%IS(58,1)="58^BT^M/UX^^^(""auv"":0:2048)^"
 . S ^%IS(59,0)="Floppy Disk 1 720K 3.5"""
 . S ^%IS(59,1)="59^BT^M/UX^^^(""auv"":0:2048)^"
 . S ^%IS(60,0)="Floppy Disk 1 1.44M 3.5"""
 . S ^%IS(60,1)="60^BT^M/UX^^^(""auv"":0:2048)^"
 . S ^%IS(61,0)="Floppy Disk 1 360K 5.25"""
 . S ^%IS(61,1)="61^BT^M/UX^^^(""auv"":0:2048)^"
 . S ^%IS(62,0)="Floppy Disk 1 1.2M 5.25"""
 . S ^%IS(62,1)="62^BT^M/UX^^^(""auv"":0:2048)^"
 ;
 I id=18 DO  ;M88K specific devices
 . S ^%IS("/dev/contty",0)="Console tty"
 . S ^%IS("/dev/contty",1)="/dev/contty"_trm
 ;
 I id=11 DO  ;ARIX specific devices
 . S ^%IS("TERM",1)="0^TRM^C-TV925^^^^" ;Arix uses TV925's
 ;
 I id=32!(id=33) DO
 . S ^%IS("CON:",0)="Windows "_$s(id=32:95,1:"NT")_" Console"
 . S ^%IS("CON:",1)="0^TRM^C-NT CONSOLE^^^^"
 ;
 W !,"Done.",! Q
SUB(n,v) ;v= wid^ff^len^backsp^xy position^e.line^e.page^alt.ff^alt del
 S ^%IS(0,"SUB",n)=v Q  ;define a sub-type
YN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YN"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"yn","YN") I "^YN"'[R W "  enter Yes or No, please"
 S POP=(R="^") W $E($S(R="N":"No",R="Y":"Yes",1:""),$L(X)+1,3) Q R

MOUNT^INT^1^67214,47331
MOUNT ; Make a database accessible
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 Write !,"This utility is deprecated in favor of ^DATABASE"
 Do MOUNT^DATABASE() q  
ONE(%U,CLUSFLAG) ; one directory at a time
 n db,Status
 s db=##class(SYS.Database).%OpenId(%U,,.Status)
 i ('Status) {
    w !,%U," not mounted because ",!,?10 d $SYSTEM.Status.DisplayError(Status) w !
    q
 }
 if db.Mounted {
    s Status=1
 } else {
    Set Status=db.Mount(0,$g(CLUSFLAG,0))
 }
 i ('Status) {
    W !,"Errors encountered while mounting directory - ("_%U_") error code=" d $SYSTEM.Status.DisplayError(Status) w !
 } else {
    W:$X ! W ?4,$$LJ(%U,20)_"  ... (Mounted)",! D SYS ;show & mark it
 }
 Q
SYS I '$G(^SYS("UCI",%U)) S $ZT="SYSERR^"_$ZN,$ZE="" DO
 . N NVOLS,%UN,%UU,%SU,SEQN,I,err S ^SYS("UCI",%U)=""
 . S NVOLS=$ZU(37,%U,0,$ZU(40,10,1),$ZU(40,9,1))
 . i NVOLS<0 s err=NVOLS g SYSERR
 Q
errdir S ERR=$G(ERR)+1 ;add to list of errors
 i +$ZU(49,%U)=-1 s ^NET("ERR",ERR)="Directory is dismounting - Try again later"
 e  S ^NET("ERR",ERR)="Not a valid directory on this computer!"
 q
SYSERR ;
 w !,"Error while handling volume extensions"
 i $ZE'="" W ": "_$ZE,! Q
 w " because ",$$Error^%apiOBJ(-X),!
 q
LJ(x,n) Q ($E(x_$J("",n),1,n)_$E(x,n+1,$L(x))) ;left justify text to n chars

MSU^INT^1^67214,47331
MSU ;Modify user database parms using new database system code
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 g ^DATABASE
HEADER d HEADER^DATABASE() q
ALL d ALL^DATABASE() q

NETBENCH^INT^1^67214,47331
NETBENCH ; BENCHMARK NETWORK GLOBAL USAGE
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 R "System name:",s w !
 R "Directory:",d w !
 n ENV 
 i s="" s ENV=d
 e  s ENV="^"_s_"^"_d
 N X S X=$ZU(68,28,0)
 K ^|ENV|TSA,^|ENV|TSB,^|ENV|TSC,^|ENV|TST,^|ENV|TSW,^|ENV|TSX,^|ENV|TSY
 S X=$ZU(68,28,X)
 W "This benchmark is a simple test of the ability of the global module",!
 W "to do sets in sequential, descending, and 'random' order and to retrieve",!
 W "the data so set.",!!,"A is 30 char, B is 5 char, C is 12345",!!
 H 10 ;GIVE GARBAGE COLLECTOR A CHANCE TO RUN
SET N TIME S A="" F I=1:1:30 S A=A_"A"
 S B="ABCDE",C=12345
 D TIM(0,"F I=1:1:6000 S ^|ENV|TST(I)=A",6000)
 D TIM(1,"F I=1:1:1500 S D=^|ENV|TST(I)",1500)
 D TIM(0,"F I=6000:-1:1 S ^|ENV|TSW(I)=A",6000)
 D TIM(1,"F I=1500:-1:1 S D=^|ENV|TSW(I)",1500)
 D TIM(0,"F X=1:1:40 F Y=1:1:50 S ^|ENV|TSX(X,Y,0)=A,^(1)=B,^(2)=C",6000)
 D TIM(0,"F X=1:1:40 F Y=1:1:50 S ^|ENV|TSY(Y,X,0)=A,^(1)=B,^(2)=C",6000)
 D TIM(1,"F X=1:1:20 F Y=1:1:25 S D=^|ENV|TSX(X,Y,0),E=^(1),F=^(2)",1500)
 D TIM(1,"F X=1:1:20 F Y=1:1:25 S D=^|ENV|TSY(Y,X,0),E=^(1),F=^(2)",1500)
 D TIM(0,"F I=1:1:2000 S ^|ENV|TSA(I)=A,^|ENV|TSB(I)=B,^|ENV|TSC(I)=C",6000)
 D TIM(1,"F I=1:1:500 S D=^|ENV|TSA(I),E=^|ENV|TSB(I),F=^|ENV|TSC(I)",1500)
 S X=$ZU(68,28,0)
 K ^|ENV|TSA,^|ENV|TSB,^|ENV|TSC,^|ENV|TST,^|ENV|TSX,^|ENV|TSY,^|ENV|TSW w !
 S X=$ZU(68,28,X)
 W TIME(0)," seconds for ",TIME(2)," SETS, "
 W TIME(2)*100+.5\TIME(0)/100," SETS per second",!
 W TIME(1)," seconds for ",TIME(3)," GETS, "
 W TIME(3)*100+.5\TIME(1)/100," GETS per second",!
 q
TIM(rcv,xec,n) s TIME=$P($H,",",2) x xec s TIME=$P($H,",",2)-TIME
 w TIME," seconds for: ",xec,!
 s TIME(rcv)=$G(TIME(rcv))+TIME,TIME(rcv+2)=$G(TIME(rcv+2))+n
 q

NETDATA^INT^1^67214,47331
NETDATA ;compile ^dsclient into ^NET (like STUCNFG)
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 q
NetDirectorySets(Config,Computer,Alias) Public {
 s ^NET(2,Config,"CO",Computer,"NA",Alias)=""
}
NetServers(Config,Device,Computer,Address,Port,Index,ReqVersion,DefVersion,Peer,Mir,batchmode) Public {
 s ^NET(2,Config,"CO",Computer,"AC")="P"
 s numservers=^NET(2,Config,"DV",Device,"TO",0)+1
 s ^NET(2,Config,"DV",Device,"TO",0)=numservers ; Add this server
 s ^NET(2,Config,"DV",Device,"TO",numservers,"CP")=Computer
 s ^NET(2,Config,"DV",Device,"TO",numservers,"DEFVERSION")=$s($d(DefVersion):DefVersion,1:0)
 s ^NET(2,Config,"DV",Device,"TO",numservers,"NOTPEER")=$s($d(Peer):Peer,1:0)
 s ^NET(2,Config,"DV",Device,"TO",numservers,"PA")="P"
 s ^NET(2,Config,"DV",Device,"TO",numservers,"RE")=Address
 s ^NET(2,Config,"DV",Device,"TO",numservers,"REQVERSION")=$s($d(ReqVersion):ReqVersion,1:0)
 s ^NET(2,Config,"DV",Device,"TO",numservers,"RP")=Port
 s ^NET(2,Config,"DV",Device,"TO",numservers,"MIR")=$s($d(Mir):Mir,1:0)
 s ^NET(2,Config,"DV",Device,"TO",numservers,"BatchMode")=$g(batchmode,0)	// GK1574
}
NetPorts(Config,Device,Type,Addr,Decnet,Port) Public {
 s ^NET(2,Config,"DV",Device,"BPS")=Port
 s ^NET(2,Config,"DV",Device,"DV")=Device
 s ^NET(2,Config,"DV",Device,"EA")=Addr
 s ^NET(2,Config,"DV",Device,"NON")=Decnet
 s ^NET(2,Config,"DV",Device,"TO",0)=+$g(^NET(2,Config,"DV",Device,"TO",0))        
 s ^NET(2,Config,"DV",Device,"TY")=Type
}
Configuration(Config,Desc) Public {
 s:'$d(Desc) Desc=Config_" Configuration"
 s ^NET(2,Config,"DES")=Desc
 s ^NET(2,Config,"DCR")=$p($h,",",1)
 s ^NET(2,Config,"DED")=$p($h,",",1)
}

NETWORK^INT^1^67214,47331
NETWORK ;
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
Start() Public {
 s $zt="Error"
 d $zu(9,"","Activating Network",0,0  /* Informational message */)
 D APPLY^SETQUOTA("NETDAEMON")  ;Set quotas for network daemons (VMS only)
 s ConfigName=$p($zu(86),"*",2)
 i '$d(^NET(2,$p($zu(86),"*",2),"CO")) g ECPSTART
 I '$D(^NET(0,"INIT")) {
	i ($zversion(1)=3)  J ^RECEIVE:(:2:"/dev/null")
	i ($zversion(1)=2) J ^RECEIVE:(:2:"//./nul")
	S ^NET(0,"INIT")=ConfigName_"\"_$H
 } 
 F SUB="CPNU","DELCP","DELDV","DELNU","DELPO","DVPO","NACP","NUCP","PODV","PORTJOB" {
	 k ^NET(2,ConfigName,SUB)
	 Merge ^NET(2,ConfigName,SUB)=^NET(1,"ACTIVE",SUB) 
 }
 n %ConfigName s %ConfigName=ConfigName
 D RECOMP("^NET(1,""ACTIVE"")","^NET(2,%ConfigName)",.CP,1)
 D RECMPDV(.DV) ;COMPARE DEVICES FROM ACTIVE TO NEW CONFIGURATION.
 D PORT(.DV)
 d DVDOWN(.DV)
 s Status=$$CP(.CP)
 i '(''Status) q Status
 d DVUP(.DV)
 d NHASH()
 S ^NET(2,ConfigName,"DAC")=$H ;DATE ACTIVATED
 K ^NET(1) Merge ^NET(1,"ACTIVE")=^NET(2,ConfigName)
 S ^NET(1)=ConfigName
ECPSTART
 If $System.ECP.SetProperty("ReconnectInterval",$g(^NET(0,"ClientReconnectInterval"),5))
 If $System.ECP.SetProperty("ReconnectDuration",$g(^NET(0,"ClientReconnectDuration"),1200))
 If $System.ECP.SetProperty("ServTrblDuration",$g(^NET(0,"ServerTroubleDuration"),60))
 If $d(^NET(0,"EnableServer")),$$Server^ECPClient()
 D DEFAULT^SETQUOTA("PROCESS")  ;Reset to defaults (VMS only)
 Q 1
Error s $zt=""
 q $$Error^%apiOBJ(5002,$ze)
}
RECMPDV(DV) Private { 
 K DV
 s ConfigName=$p($zu(86),"*",2)
 n %C
 D ACTIVE1^RECPRI("%C(1)"),ACTIVE2^RECPRI(ConfigName,"%C(2)") ;SET %C(1,NA)=DV\TO FOR ACTIVE CONFIG, %C(2,NA)=DV\TO FOR NEW CONFIG
 F A=1,2 S NA="" F J=0:0 S NA=$O(%C(A,NA)) Q:NA=""  S D(A,$P(%C(A,NA),"\",1),NA)=$P(%C(A,NA),"\",2) ;SET D(1,DV,NA)=TO FOR ACTIVE CONFIG'S ACTIVE ROUTES, D(2,DV,NA)=TO FOR NEW CONFIG'S ACTIVE ROUTES
 S DV="" F J=0:0 S DV=$O(D(1,DV)) Q:DV=""  D DV
 S DV="" F J=0:0 S DV=$O(D(2,DV)) Q:DV=""  I '$D(D(1,DV)) S DV("ADD",DV)=""
 Q
DV I '$D(D(2,DV)) S DV("DEL",DV)="" q
 S A="" F J=0:0 S A=$O(^NET(1,"ACTIVE","DV",DV,A)) Q:A=""  S X1=$S($D(^(A))#10:^(A),1:"\\\"),X2=$S($D(^NET(2,ConfigName,"DV",DV,A))#10:^(A),1:"\\\") I X1'=X2 S DV("EDIT",DV)="" G DV2
DV2 S NA="" F J=0:0 S NA=$O(D(1,DV,NA)) Q:NA=""  I $D(D(2,DV,NA)) S TO1=D(1,DV,NA),TO2=D(2,DV,NA) S A="" F J=0:0 S A=$O(^NET(1,"ACTIVE","DV",DV,"TO",TO1,A)) Q:A=""  S X1=$S($D(^(A))#10:^(A),1:"\\\"),X2=$S($D(^NET(2,ConfigName,"DV",DV,"TO",TO2,A))#10:^(A),1:"\\\") I X1'=X2 S CP("EDIT",NA)="" Q  ;SOMETHING ABOUT THIS REMOTE COMPUTER MUST BE EDITED.
 S JOB=$P($G(^NET(1,"ACTIVE","PORTJOB",DV)),"\")
 S $ZT="Down"
 I JOB'="" {
	s PGM=$P($V(-1,JOB),"^",6)
	I PGM="DMNNET"!(PGM="DMNET") Q ; Job is up
 }
Down S DV("ADD",DV)="",$ze=""
 Q
}
PORT(DV) Private {
 s ConfigName=$p($zu(86),"*",2)
 s DV=""
 f  {
	s DV=$O(DV("DEL",DV)) q:DV=""
	S PO=^NET(2,ConfigName,"DVPO",DV) ;GET PO=port#
	S ^NET(2,ConfigName,"DELDV",DV)=PO,^NET(2,ConfigName,"DELPO",PO)=DV ;RECORD DELETES SO CAN RECOVER
	K ^NET(2,ConfigName,"DVPO",DV),^NET(2,ConfigName,"PODV",PO) ;DELETE FROM ACTIVE STATUS
	S NEWLYDEL(PO)=""
 }
 s DV=""
 f  {
	s DV=$O(DV("ADD",DV)) q:DV=""
	if (DV["ECPNET") {
    	S ^NET(2,ConfigName,"DVPO",DV)=0,^NET(2,ConfigName,"PODV",0)=DV
    	K ^NET(2,ConfigName,"DELDV",DV),^NET(2,ConfigName,"DELPO",0)
    	Continue
 	}
	I $D(^NET(2,ConfigName,"DELDV",DV)) S PO=^(DV) G PORTADD2
	S POMAX=64
	F PO=1:1:POMAX I '$D(^NET(2,ConfigName,"PODV",PO)),'$D(^NET(2,ConfigName,"DELPO",PO)) G PORTADD2 ;SEARCH FOR AN UNUSED PORT#
	F PO=1:1:POMAX I '$D(^NET(2,ConfigName,"PODV",PO)),'$D(NEWLYDEL(PO)) G PORTADD2 ;SEARCH FOR UNUSED PORT# WHICH WAS NOT JUST DELETED
	F PO=1:1:POMAX I '$D(^NET(2,ConfigName,"PODV",PO)) G PORTADD2 ;IF NO UNUSED AND NOT-JUST-DELETED PORT#'S, PICK 1ST DELETED ONE
	K DV("ADD",DV) s ^NET("ERR",$o(^NET("ERR",""),-1)+1)="DEVICE """_DV_""" NOT USED FOR NETWORKING - NOT ENOUGH PORT#'S AVAILABLE" Continue  ;ALL IN USE.
PORTADD2 ;GET HERE WITH PO=port#, DV=device name. PUT INTO DVPO/PODV
	S ^NET(2,ConfigName,"DVPO",DV)=PO,^NET(2,ConfigName,"PODV",PO)=DV ;PUT INTO DVPO/PODV SUBFILES.
	K ^NET(2,ConfigName,"DELDV",DV),^NET(2,ConfigName,"DELPO",PO) ;DELETE FROM DELETE-SUBFILES (IN CASE THEY WERE THERE)
 }
}
CP(CP) Private {
 s Status=1
 Set CP="" 
 For {
	Set CP=$O(CP("DEL",CP)) Quit:CP=""
	If $$isECP(CP,$name(^NET(1,"ACTIVE","DV"))) {
		Do ECPDEL(CP)
	}
 }
 f {
	Set CP=$O(CP("EDIT",CP)) Quit:CP=""  
	s Status=$$ECPEDIT(CP)
 }
 f {
	Set CP=$O(CP("ADD",CP)) Quit:CP=""
	If $$isECP(CP) {
		s Status=$$ECPADD(CP)
	}
 }
 For {
	Set CP=$O(^%SYS("SERVICE","ECPCLU",CP)) Quit:CP=""
	If '($$isECP(CP)) Kill ^%SYS("SERVICE","ECPCLU",CP)
 }
 For {
	Set CP=$O(^%SYS("SERVICE","ECPMIRc",CP)) Quit:CP=""
	If '($$isECP(CP)) {
		Kill ^%SYS("SERVICE","ECPMIRc",CP)
        if (($zb(+$System.ECP.Debug(),+$zh("2000"),1))) { d $ZU(9,"","NETWORK: "_"Deleted old mirror session for "_CP) }
	}
 }
 Quit Status
}
isECP(CP,glb) Private {
 Set ConfigName=$p($zu(86),"*",2),RET=0,DV="",STOP=0
 If '$d(glb) Set glb=$name(^NET(2,ConfigName,"DV"))
 For {
	Set DV=$o(@glb@(DV)) Quit:DV=""
	Set TO=$g(@glb@(DV,"TO",0))
 	For i=1:1:TO {
	 	Set NAME=$g(@glb@(DV,"TO",i,"CP"))
 		If NAME=CP Set STOP=1,RET=$s(DV?1"ECPNET".E:1,1:0) Quit
 	}
	Quit:STOP
 }
 Quit RET
} 
ECPDEL(CP) Private {
 Set SysNo=$System.ECP.GetClientIndex(CP)
 i SysNo=-1 q
 Set x=$System.ECP.SetClientState(SysNo,2,1)
 Set x=$System.ECP.SetClientState(SysNo,4,1)
 Quit
}
ECPEDIT(CP) Private {
 s Status=1
 If $$isECP(CP,$name(^NET(1,"ACTIVE","DV"))) { Do ECPDEL(CP) }
 If $$isECP(CP) { 
 	s Status=$$ECPADD(CP) 
 }
 Quit Status
}
ECPADD(CP) Private {
 s Status=1
 Set ConfigName=$p($zu(86),"*",2),RET=0,DV="",STOP=0
 For  {
	Set DV=$o(^NET(2,ConfigName,"DV",DV)) Quit:DV=""  
	If DV?1"ECPNET".E {
 		Set TO=$g(^NET(2,ConfigName,"DV",DV,"TO",0))
		For i=1:1:TO {
			Set Name=$g(^NET(2,ConfigName,"DV",DV,"TO",i,"CP")) 
 			If Name=CP {
	 			Set STOP=1,RemoteAddr=$g(^("RE")),RemotePort=$g(^("RP")),MirrorCon=$g(^("MIR"))
				Set BatchMode=$g(^("BatchMode"))
	 			Quit
 			}
		}
	}
	q:STOP
 }
 If '$S($zbitget($zversion(0)_$c(0,0,0,0),42):$SYSTEM.INetInfo.TextAddrToBinary(RemoteAddr)'="",1:(RemoteAddr?1.3N1"."1.3N1"."1.3N1"."1.3N)),$s($zbitget($zversion(0)_$c(0,0,0,0),42):$SYSTEM.INetInfo.HostNameToAddr(RemoteAddr),1:$p($zu(54,13,RemoteAddr),","))="" d $zu(9,"","ECP connection "_Name_" - "_RemoteAddr_":"_RemotePort_" is unreachable",1 /* broadcast and log message*/,1  /* Warning */)
 If '$$Init^ECPClient(RemoteAddr,RemotePort,Name,1200,300,MirrorCon,BatchMode) {
	 d $zu(9,"","ECP connection "_Name_" - "_RemoteAddr_":"_RemotePort_" failed",1 /* broadcast and log message*/,1  /* Warning */)
	 s Status=$$Error^%apiOBJ(456,+$G(^CONFIG("config","MaxServers"))+1)
 }
 Quit Status
}
DVDOWN(DV) Private { 
 S DV="" F  {S DV=$O(DV("DEL",DV)) Q:DV=""  D DVSTOP(DV)}
 S DV="" F  {S DV=$O(DV("EDIT",DV)) Q:DV=""  D DVSTOP(DV)}
 I $D(DV("DEL"))!$D(DV("EDIT")) H 3 ;WAIT LONG ENOUGH FOR JOBS TO DIE.
 Q
}
 ;         
DVUP(DV) Private {
 S DV="" F  {S DV=$O(DV("EDIT",DV)) Q:DV=""  D DVSTART(DV)}
 S DV="" F  {S DV=$O(DV("ADD",DV)) Q:DV=""  D DVSTART(DV)}
 Q
}
NHASH() Private {
 s ConfigName=$p($zu(86),"*",2)
 K ^NET(2,ConfigName,"NACP") S CP=""
 F  {
	S CP=$O(^NET(2,ConfigName,"CO",CP)) Q:CP=""
	S NA="" 
	F  {
		S NA=$O(^NET(2,ConfigName,"CO",CP,"NA",NA)) Q:NA=""
		S ^NET(2,ConfigName,"NACP",NA)=CP
	}
 }
 D RECOMP("^NET(1,""ACTIVE"",""NACP"")","^NET(2,%ConfigName,""NACP"")",.NACP,0)
 I '$D(NACP) q
 S NA="" F  S NA=$O(NACP("DEL",NA)) Q:NA=""  d $ZU(63,1,NA,255)  
 F  {
	S NA=$O(NACP("EDIT",NA)) Q:NA=""
	S SYSNUM=$$SYSNUM(^NET(2,ConfigName,"NACP",NA)) i SYSNUM="" continue
	D NHASHPUT(NA,SYSNUM)
 }
 F  {
	S NA=$O(NACP("ADD",NA)) Q:NA=""
	S SYSNUM=$$SYSNUM(^NET(2,ConfigName,"NACP",NA)) i SYSNUM="" continue
	D NHASHPUT(NA,SYSNUM)
 }
 Q
}
SYSNUM(CP) Private { Q $S(CP=$S($D(^NET(0,"THISCO")):^NET(0,"THISCO"),1:""):0,1:$G(^NET(2,$p($zu(86),"*",2),"CPNU",CP)))}
NHASHPUT(NA,SYSNUM) Private {
 S $ZT="Error"
 d $ZU(63,1,NA,SYSNUM)
 QUIT
Error s $zt=""
 d $zu(9,"","Error: "_"Network Hash Table full: Directory Set Name '"_NA_"' not added",1 /* broadcast and log message*/,2  /* Severe error */),BACK^%ETN
 q
}
NETNODE(CP) Private {
 s ConfigName=$p($zu(86),"*",2)
 S THISCO=$G(^NET(0,"THISCO"))
 n %CPDV
 I '$D(%CPDV) D ACTIVE2^RECPRI(ConfigName,"%CPDV") ;BUILD COMPUTER-TO-DV LIST
 S NU=$S(CP=THISCO:0,1:^NET(2,ConfigName,"CPNU",CP)) Q:'NU  ; NU=remote sysnum
 S DV=$P(%CPDV(CP),"\"),TO=$P(%CPDV(CP),"\",2) ;GET DV=device name,TO
 S PO=^NET(2,ConfigName,"DVPO",DV) ;GET PO=internal port#
 S TY=^NET(2,ConfigName,"DV",DV,"TY"),EA=^("TO",TO,"RE"),RP=$G(^("RP"))
 I EA="" {
	S NODEREQB=$$NODEREQB("T")
 } else {
	S NODEREQB=$$NODEREQB("E")
 }
 S ETHADDR=$$ENCUDP(EA,RP)
 S NR=NODEREQB
 S RV=$G(^NET(2,ConfigName,"DV",DV,"TO",TO,"REQVERSION"))
 S DV=$G(^("DEFVERSION"))
 S DF=$G(^("DEFFLAGS"))
 S DT=$G(^("DEFFLAGS"))
 S NP=$G(^("NOTPEER"))
 S PW=$G(^("PW"))
 S RET=$ZU(129,2,NU,RP,TY,ETHADDR,NR,PO-1,RV,DV,DF,DT,NP,PW,CP)
 I $zu(63,1,CP,NU) ; Add the name to nethash[] with correct sys #.
 Q
} 
NODEREQB(TY) Private {
 IF "^E^W^U^DSM^O^"[("^"_TY_"^") Q:$D(^NET(0,"NODEREQB"))#2 ^NET(0,"NODEREQB") Q 127
 Q $S(TY="T":3,TY="D":127)
} 
RECOMP(%OLD,%NEW,DIFF,COonly=0) Private {
 N %J,%Q,%SUB1,%SUB2
 if COonly {
	n %old,%new
 	s %old=%OLD,%new=%NEW,%OLD=$name(@%old@("CO")),%NEW=$name(@%new@("CO"))
 }
GO S %SUB1=""
 F %J=0:0 S %SUB1=$O(@%OLD@(%SUB1)) Q:%SUB1=""  D OLDSUB1
 F %J=0:0 S %SUB1=$O(@%NEW@(%SUB1)) Q:%SUB1=""  D NEWSUB1
 i COonly d compcfg ;%old and %new are used here only
 Q
OLDSUB1 I '$D(@%NEW@(%SUB1)) S DIFF("DEL",%SUB1)="" Q
 I $D(@%OLD@(%SUB1))#10,$D(@%NEW@(%SUB1))#10,@%OLD@(%SUB1)'=@%NEW@(%SUB1) S DIFF("EDIT",%SUB1)="" Q
 S %SUB2="",%Q=0
 F %J=0:0 S %SUB2=$O(@%OLD@(%SUB1,%SUB2)) Q:%SUB2=""  D OLDSUB2 Q:%Q
 Q
OLDSUB2 Q:$D(@%OLD@(%SUB1,%SUB2))#10=0
 I $D(@%NEW@(%SUB1,%SUB2))#10,@%OLD@(%SUB1,%SUB2)=@%NEW@(%SUB1,%SUB2) Q
 S DIFF("EDIT",%SUB1)="",%Q=1 Q
NEWSUB1 I '$D(@%OLD@(%SUB1)) S DIFF("ADD",%SUB1)="" Q
 S %SUB2="",%Q=0
 F %J=0:0 S %SUB2=$O(@%NEW@(%SUB1,%SUB2)) Q:%SUB2=""  D NEWSUB2 Q:%Q
 Q
NEWSUB2 Q:'$D(@%NEW@(%SUB1,%SUB2))#10=0  ;POINTER ONLY.
 Q:$D(@%OLD@(%SUB1,%SUB2))#10  ;MUST BE SAME VALUE IF BOTH DEFINED.
 S DIFF("EDIT",%SUB1)="",%Q=1 Q
 ;
compcfg ;
 s %SUB1="" f  s %SUB1=$o(@%OLD@(%SUB1)) q:%SUB1=""  d:$d(@%NEW@(%SUB1))
 . s oldcfg=$$getcfg(%old,%SUB1),newcfg=$$getcfg(%new,%SUB1)
 . i oldcfg'=newcfg s DIFF("EDIT",%SUB1)=""
 q
getcfg(g,cp) ;
 s (dev,idx)=""
 f  s dev=$o(@g@("DV",dev)) q:dev=""  d  q:+idx
 . s x=$name(@g@("DV",dev,"TO")) s idx=$$findcp(x,cp)
 i 'idx q ""  ;cp is not found? it shouldn't happen.
 q $$packcfg($name(@x@(idx)))
findcp(g,cp)  
 s idx1=0 f  s idx1=$o(@g@(idx1)) q:idx1=""  q:@g@(idx1,"CP")=cp
 q +idx1
packcfg(g) 
 s (a,ret)="" f  s a=$o(@g@(a)) q:a=""  s ret=ret_@g@(a)_";"
 q ret
}
DVSTOP(DV) Public {
 S DEMONJOB=$S($D(^NET(1,"ACTIVE","PORTJOB",DV)):+^(DV),1:0)
 I DEMONJOB,'$$INT^RESJOB(DEMONJOB) s ^NET("ERR",$o(^NET("ERR",""),-1)+1)="NETWORK DEMON FOR DEVICE "_DV_" NOT STOPPED.  ASSUMING WAS ALREADY DOWN."
 K ^NET(2,$p($zu(86),"*",2),"PORTJOB",DV)
 Q
}
DVSTART(DV) Public {
 s ConfigName=$p($zu(86),"*",2)
 S PO=^NET(2,ConfigName,"DVPO",DV),TY=^NET(2,ConfigName,"DV",DV,"TY"),NON=^("NON")
 I TY="ECP" Q
} 
ENCUDP(ADDR,PORTWORD) Public {
 S UDPADDR=$s($zbitget($zversion(0)_$c(0,0,0,0),42):$SYSTEM.INetInfo.TextAddrToBinary(ADDR),1:$ZU(54,1,ADDR))
 S UDPADDR=UDPADDR_$C(PORTWORD\256)_$C(PORTWORD#256)
 Q UDPADDR
}

NLS^INT^1^67214,47331
NLS	; Manage NLS properties (Locales)
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 If '$SYSTEM.Security.Check("%Admin_Manage","USE") {
	 Write !,"This utility requires %Admin_Manage:USE privilege",!
	 Quit
 }
 If $ZV["Apple" {
	 Set oDev=##class(%SYS.NLS.Device).%New()
	 Set xTab=oDev.XLTTable,oDev.XLTTable="UTF8"
 }
 Try { Do Main() }
 Catch { Do Error() }
 If $D(oDev),$D(xTab) Set oDev.XLTTable=xTab Kill xTab,oDev
 Kill LocProps,TabProps,SubProps,nLines,oLoc,sLoc,oMod,sMod,oSub,sSub,oTab,sTab
 Quit
Main() [oLoc,sLoc] {
 Set options(1)="Display current locale"
 Set options(2)="Select defaults"_$$EMSEditText()
 Set options(3)="Change locale"_$$EMSEditText()
 Set options(4)="Display loaded settings"
 Set options(5)="Advanced"_$$EMSEditText()
 While (1) {
	Set op="",st=##Class(%Library.Prompt).GetMenu("NLS option?",.op,.options,,128+4)
	If (st=2)||(st=3) Quit
 	Set oLoc=##class(Config.NLS.Locales).OpenCurrent(),sLoc=oLoc.Name
 	If op]"","235"[op,$$EMSManaged() continue
	If op=1 { Do DisplayLocale() }
	ElseIf op=2 { Do SelectDefs() }
	ElseIf op=3 { Do ChangeLocale() }
	ElseIf op=4 { Do Current^NLS2() }
	ElseIf op=5 { Do Advanced() }
	Else { Quit }
 }
}
SelectDefs() [oLoc,sLoc,LocProps,Reload] PUBLIC {
 Set options(1)="Internal tables"
 Set options(2)="I/O tables"
 Set options(3)="CSP files"
 Set options(4)="Date, time and number formats"
 Set Reload=0
 While (1) {
	Set op="",st=##Class(%Library.Prompt).GetMenu("Category of defaults?",.op,.options,,128+4)
	If (st=2)||(st=3) Quit
	If op>0,op<5 { Do SelCfgDefs(options(op)) }
	Else { Quit }
 }
 If Reload Do ReloadLocale(sLoc)
}
SelCfgDefs(option) [oLoc,LocProps,Reload] PUBLIC {
 Set cfgr=$Name(^|"^^"_$zu(12)|SYS("NLS","Config")),option=$E(option,1,$L(option)-1)
 Set categ=$S(option["I/O":"IODefaults",option["Internal":"InternalDefaults",option["CSP":"OtherDefaults",1:"FormatsDefaults")
 Merge config=@cfgr Set config=0
 If categ="FormatsDefaults" {
	Write ! Set def=$G(config("LocaleFormat"),0)
	Set fmt=$$YN("Use locale date/time/number formats?",def)="y"
	If fmt'=def {
		If fmt Set @cfgr@("LocaleFormat")=1
		Else  Kill @cfgr@("LocaleFormat")
		Set Reload=1
	}
	Quit
 }
 If $$GetProperties(oLoc,.LocProps)'=1 Quit
 Do GetFields(.Defaults,categ)
 Write !!,"Items marked with (*) represent the locale's original default"
 While 1 {
	Set op=1
	If Defaults>1 {
		Kill options
 		For i=1:1:Defaults {
			Set z=Defaults(i),fld=$P(z,"^",1),tag=$P(z,"^",2),pty=$P(z,"^",5)
			Set ldef=$S(categ="OtherDefaults":"UTF8",1:LocProps(fld))_" (*)",def=$G(config(pty),ldef)
			Set options(i)=$$Justify(tag,20)_def
 		}
 		Write !!,option,?23,"Current default"
 		Write !,"---------------------  --------------------"
 		Set op="",st=##Class(%Library.Prompt).GetMenu(option_":",.op,.options,,128+4)
 		If (st=2)||(st=3) Quit
	}
	Kill options
 	Set z=Defaults(op),fld=$P(z,"^",1),tag=$P(z,"^",2),avl=$P(z,"^",4),pty=$P(z,"^",5)
 	Set:avl="*" avl="XLTTables" Set:avl="s" avl=fld_"s"
 	Set ldef=$G(LocProps(fld)),cfg=$G(config(pty),ldef),op="",i=1
 	If fld="CSP",ldef="" Set ldef="UTF8" Set:cfg="" cfg=ldef
 	If avl="XLTTables" {
		Set x="RAW"
		While x'="" { Set:x=cfg op=i Set:x=ldef x=x_" (*)" Set options(i)=x,i=i+1,x=$P("RAW,UTF8,UnicodeLittle,UnicodeBig",",",i) }
 	}
 	Set x=$O(LocProps(avl,""))
 	While x'="" { Set:x=cfg op=i Set:x=ldef x=x_" (*)" Set options(i)=x,i=i+1,x=$O(LocProps(avl,x)) }
 	Set st=##Class(%Library.Prompt).GetMenu("Selection for "_tag_":",.op,.options,,128+4)
 	If (st=2)||(st=3) Quit:Defaults=1  Continue
 	If $D(config(pty)) {
	 	If options(op)["(*)" { Kill config(pty) Set config=config+1 }
	 	ElseIf config(pty)'=options(op) { Set config(pty)=options(op),config=config+1 }
 	} ElseIf options(op)'["(*)" { Set config(pty)=options(op),config=config+1 }
 	If Defaults=1 Quit
 }
 If config Do SaveCfgChanges(categ,.config)
}
EditTabDefs(fields,option) [oLoc,LocProps,Reload] PUBLIC {
 Set option=option_" table"
 While 1 {
	Set op=1
	Kill options
 	For i=1:1:fields {
		Set z=fields(i),fld=$P(z,"^",1),tag=$P(z,"^",2)
		Set def=$G(LocProps(fld)) Set:def="" def="Built-in"
		Set options(i)=$$Justify(tag,20)_def
 	}
 	Write !!,option,?23,"Current default"
 	Write !,"---------------------  --------------------"
 	Set op="",st=##Class(%Library.Prompt).GetMenu(option_":",.op,.options,,128+4)
 	If (st=2)||(st=3) Quit
	Kill options
 	Set z=fields(op),fld=$P(z,"^",1),tag=$P(z,"^",2),avl=$P(z,"^",4)
 	Set:avl="*" avl="XLTTables" Set:avl="s" avl=fld_"s"
 	Set ldef=$G(LocProps(fld)),op="",i=1 Set:ldef="" ldef="Built-in"
 	If avl="XLTTables" {
		Set x="RAW"
		While x'="" { Set:x=ldef op=i Set options(i)=x,i=i+1,x=$P("RAW,UTF8,UnicodeLittle,UnicodeBig",",",i) }
 	} ElseIf fld["Case"||(fld["Accent") {
	 	Set:ldef="Built-in" op=i Set options(i)="Built-in",i=i+1
 	}
 	Set x=$O(LocProps(avl,""))
 	While x'="" { Set:x=ldef op=i Set options(i)=x,i=i+1,x=$O(LocProps(avl,x)) }
 	Set old=op
 	Set st=##Class(%Library.Prompt).GetMenu("Default for "_tag_":",.op,.options,,128+4)
	If op'=old {
		Set new=options(op) If new="Built-in" Set new=""
		Set LocProps(fld)=new,LocProps=LocProps+1
	}
 }
 If LocProps { Do SaveLocChanges() }
 Else { Write !!,"No changes!" }
}
ChangeLocale() [sLoc,oLoc] {
 Write !!,"Current locale is: ",sLoc," (",oLoc.Description,")",!
 If $$YN("Would you like to install a new locale?")'="y" Quit
 If $$SelectLocale()="NEXT" Set ok=$$InstallLocale()
}
ISC Set @($Name(^||SYS("NLS")))@("System")=1
	Do NLS
	Kill @($Name(^||SYS("NLS")))@("System")
	Quit
Advanced() {
 Set options(1)="Locale definitions"
 Set options(2)="Table definitions"
 Set options(3)="Import Locales/Tables"
 While (1) {
 	Set op="",st=##Class(%Library.Prompt).GetMenu("Advanced option?",.op,.options,,128+4)
 	If (st=2)||(st=3) Quit
 	If op=1 { Do Locales() }
 	ElseIf op=2 { Do Tables^NLS1() }
 	ElseIf op=3 { Do ImportLocale() }
 	Else { Quit }
 }
}
Locales() [sLoc] {
 If $$SelectLocale()'="NEXT" Quit
 While (1) {
	Kill options Set op=1
	Set options(op)="Display locale",op=op+1
	If $E(sLoc)="y"||($D(@($Name(^||SYS("NLS")))@("System"))) {
		Set options(op)="Edit locale",op=op+1
		Set options(op)="Delete locale",op=op+1
	}
	Set options(op)="Install locale",op=op+1
	Set options(op)="Export locale",op=op+1
	Set options(op)="Validate locale",op=op+1
	Set options(op)="Copy locale",op=op+1
	Set options(op)="Load locale table",op=op+1
	Set options(op)="Select another locale"
	Write !!,"Selected locale: ",sLoc
	Set op="",st=##Class(%Library.Prompt).GetMenu("Locale option?",.op,.options,,128+4)
	If (st=2)||(st=3) Quit
	If options(op)["Display" { Do DisplayLocale() }
	ElseIf options(op)["Edit" { Do EditLocale() }
	ElseIf options(op)["Install" { Do InstallLocale() }
	ElseIf options(op)["Export" { Do ExportLocale() }
	ElseIf options(op)["Validate" { Do ValidateLocale() }
	ElseIf options(op)["Copy" { Do CopyLocale() }
	ElseIf options(op)["Delete" { Do DeleteLocale() }
	ElseIf options(op)["Load" { Do LoadLocaleTable() }
	ElseIf options(op)["Select" { Do SelectLocale() }
	Else { Quit }
 }
}
DisplayLocale() [nLines,oLoc,sLoc] {
 If '$D(nLines) Do GetLines()
 Write #,$$Justify(" Locale "_oLoc.Name_" ",78,2,"-")
 Set t1=3,t2=45
 Write !?t1,"      Country: ",oLoc.Country," (",oLoc.CountryAbbr,")"
 Write ?t2,"Language: ",oLoc.Language," (",oLoc.LanguageAbbr,")"
 Write !?t1,"Character set: ",oLoc.CharacterSet,?t2,"Currency: ",oLoc.Currency
 Set w1=20,w2=18,w3=78-(w1+w2)
 Write !!,$$Justify("Internal tables ",w1-2,1,"-")_"  "_$$Justify("Default ",w2-2,1,"-")_"  "_$$Justify("Additional ",w3,1,"-")
 Do DisplayTables("Pattern match",w1,oLoc.PatternTable,oLoc.PatternTables,w2)
 Do DisplayTables("Identifier",w1,oLoc.IdentifierTable,oLoc.IdentifierTables,w2)
 Do DisplayTables("Uppercase",w1,oLoc.UpperCaseTable,oLoc.UpperCaseTables,w2)
 Do DisplayTables("Lowercase",w1,oLoc.LowerCaseTable,oLoc.LowerCaseTables,w2)
 Do DisplayTables("Titlecase",w1,oLoc.TitleCaseTable,oLoc.TitleCaseTables,w2)
 Do DisplayTables("Accent",w1,oLoc.AccentTable,oLoc.AccentTables,w2)
 Do DisplayTables("Collation",w1,oLoc.CollationTable,oLoc.CollationTables,w2)
 Do DisplayTables("$X/$Y action",w1,oLoc.XYTable,oLoc.XYTables,w2)
 Set t1=15,t2=50,ps=$$Page(7)
 If ps="QUIT" Quit
 If ps="NEXT" Write !!
 Write $$Justify("Input/output tables ",78,,"-") 
 Set tab="",r=oLoc.XLTTables.GetNext(.tab),n=0
 while (tab'="") {
	Write:'(n#6) ! Write ?n#6*12+5,tab
 	Set r=oLoc.XLTTables.GetNext(.tab),n=n+1
 }
 Set t1=8,t2=38,ps=$$Page(8)
 If ps="QUIT" Quit
 If ps="NEXT" Write !!
 Write $$Justify("I/O defaults ",78,,"-")
 Write !?t1,"          Process: ",oLoc.TranZCVT
 Write ?t2,"           TCP/IP: ",oLoc.TranTCP
 Write !?t1,"   Cache Terminal: ",oLoc.TranProgrammer
 Write ?t2,"   Other terminal: ",oLoc.TranTerminal
 Write !?t1,"             File: ",oLoc.TranSequential
 Write ?t2,"      System call: ",oLoc.TranSystemCall
 Write !?t1,"          Magtape: ",oLoc.TranMagTape
 Write ?t2,"          Printer: ",oLoc.TranPrinter
 Set t1=2,t2=20,t3=30,t4=57,ps=$$Page(8)
 If ps="QUIT" Quit
 If ps="NEXT" Write !!
 Write "------ Date ------------- Time --------------------- Numbers -----------------"
 Write !?t1,"   Format: ",oLoc.DateFormat
 Write ?t2,"    Format: ",oLoc.TimeFormat
 Write ?t3,"       Minus sign: ",oLoc.MinusSign
 Write ?t4," Decimal separator: ",oLoc.DecimalSeparator
 Write !?t1,"Separator: ",oLoc.DateSeparator
 Write ?t2," Separator: ",oLoc.TimeSeparator
 Write ?t3,"        Plus sign: ",oLoc.PlusSign
 Write ?t4,"   Group separator: ",oLoc.NumericGroupSeparator
 Write !?t2," Precision: ",oLoc.TimePrecision
 Write ?t4,"        Group size: ",oLoc.NumericGroupSize
 Set ps=$$Page(6)
 If ps="QUIT" Quit
 If ps="NEXT" Write !!
 Write $$Justify("Strings ",78,,"-")
 Set t1=2,t2=7,t3=35
 Write !!?t1,$$Justify("Time ",78-t1,,"-")
 Write !?t2,"AM: ",oLoc.AM,?t3,"    Noon: ",oLoc.Noon
 Write !?t2,"PM: ",oLoc.PM,?t3,"Midnight: ",oLoc.Midnight
 Set w2=64,ps=$$Page(4)
 If ps="QUIT" Quit
 If ps="NEXT" Write !!
 Write ?t1,$$Justify("Week days ",78-t1,,"-")
 Write !?t2,"Names: ",$$Trunc(oLoc.WeekdayName,w2)
 Write !?t2,"Abbrv: ",$$Trunc(oLoc.WeekdayAbbr,w2)
 Set ps=$$Page(5)
 If ps="QUIT" Quit
 If ps="NEXT" Write !!
 Write ?t1,$$Justify("Months ",78-t1,,"-")
 Write !?t2,"Names: ",$$Trunc(oLoc.MonthName,w2)
 Write !?t2,"Abbrv: ",$$Trunc(oLoc.MonthAbbr,w2)
 Write !,$$Justify("",78,,"-")
 Set ps=$$Page(12)
}
DisplayTables(tag,tab,def,oArr,wid) {
 If def="" Set def="Built-in"
 Write !,tag,?tab,$$Justify(def,wid,1)
 Set tab=tab+wid,wid=wid-5
 For i=1:1:oArr.Count() {
	 Set table=oArr.GetAt(i)
	 If table'=def,table'="IRIS standard" {
		 If $X+wid>78 Write !,?tab
		 Write $$Justify(table,wid,1)
	 }
 }
}
EditLocale() [sLoc] {
 If '$SYSTEM.Security.Check("%Admin_Manage","USE") {
	Write !,"Sorry, you have no permission to edit locales."
	Quit
 }
 If $E(sLoc)'="y" {
	 Write !!,"You are about to edit a system locale."
	 Write !,"Any changes will be discarded during a system upgrade."
	 If $$YN("Are you sure you want to continue?")'="y" Quit
 }
 Set options(1)="Basic properties"
 Set options(2)="Date, time and number formats"
 Set options(3)="Loadable internal tables"
 Set options(4)="Loadable input/output tables"
 Set options(5)="Defaults for internal tables"
 Set options(6)="Defaults for input/output"
 Set options(7)="Strings"
 While (1) {
	Set op="",st=##Class(%Library.Prompt).GetMenu("Edit locale option?",.op,.options,,128+4)
	If (st=2)||(st=3) Quit
	If op=1 { Do EditBasics() }
	ElseIf op=2 { Do EditFormats() }
	ElseIf op=3 { Do EditIntTables() }
	ElseIf op=4 { Do EditIOTables() }
	ElseIf op=5 { Do EditIntDefs() }
	ElseIf op=6 { Do EditIODefs() }
	ElseIf op=7 { Do EditStrings() }
	Else { Quit }
 }
}
InstallLocale() [sLoc] {
 Set ok=##class(Config.NLS.Locales).IsInstallable(sLoc,.Errors,.Warns)
 Set Errors=$G(Errors),Warns=$G(Warns)
 If Errors {
	Write !!,"Cannot install locale ",sLoc
	For i=1:1:Errors Write !?5,Errors(i)
	Quit 0
 }
 If Warns {
 	Write !!,"Warning",$E("s",Warns>1)
	For i=1:1:Warns Write !?5,Warns(i)
	If $$Proceed()'="y" Quit 0
 }
 If 'ok Quit 0
 Set cfgr=$Name(^|"^^"_$zu(12)|SYS("NLS","Config"))
 If $D(@cfgr) {
	 Write !!,"There are configuration defaults for the current locale."
	 If $$YN("Would you like to delete them?")="y" {
		 Kill @cfgr Write !,"Configuration defaults deleted."
	 } Else { Write !,"Defaults compatible with ",sLoc," will be preserved." }
 }
 Do GetCacheDirs^STU(.IRISTemp)
 Set st=$$GetDatabaseInfo^%SYS.DATABASE(IRISTemp,.info)
 Set oldcol=$S(st=1:$$GetName^COLLATE(+$P(info,",",13)),1:"")
 Set st=##class(Config.NLS.Locales).Install(sLoc)
 If st=1 {
	 Write !!,"New locale set to ",sLoc
	 Kill info Set st=$$GetDatabaseInfo^%SYS.DATABASE(IRISTemp,.info)
	 Set newcol=$S(st=1:$$GetName^COLLATE(+$P(info,",",13)),1:"")
	 If newcol'="",newcol'=oldcol Write !,"Default collation of "_"IRIS"_"TEMP changed from ",oldcol," to ",newcol
 }
 Else { Write !!,"Could not load locale ",sLoc,! Do $System.OBJ.DisplayError(st) }
 Quit st
}
ReloadLocale(sLoc) PUBLIC {
	Write !!,"Reloading locale ",sLoc," to activate changes... "
	Set oldcolnum=$ZU(23,0) Do Locale^NLSLOAD(sLoc) Set newcolnum=$ZU(23,0)
	Write "done!"
	If newcolnum'=oldcolnum {
		Do GetCacheDirs^STU(.IRISTemp)
		Set st=$$GetDatabaseInfo^%SYS.DATABASE(IRISTemp,.info)
		If st=1 { Set oldcolnum=+$P(info,",",13),oldcolname=$$GetName^COLLATE(oldcolnum) }
		Else { Set oldcolnum=-1,oldcolname="" }
		If newcolnum'=oldcolnum {
			Set newcolname=$$GetName^COLLATE(newcolnum)
			Set st=$$ModifyDatabase^%SYS.DATABASE(IRISTemp,,,,,,,,,,,,newcolnum)
			If st=1 {
				Write !,"Default collation of "_"IRIS"_"TEMP changed from ",oldcolname," to ",newcolname
			}
		}
	}
}
ExportLocale() [oLoc,sLoc] {
 Set file="loc_"_sLoc_".xml",prompt="Export to file:",ans=file
 Set help(1)="Name of file to where locale "_sLoc_" will be exported in XML format."
 Set st=##Class(%Library.Prompt).GetString(prompt,.ans,,,.help,128+4)
 If st=3   ZTrap "QUIT"
 If st=2 Quit
 Set file=ans
 If $$YN("Include tables?")="y" {
	Set Locales(sLoc)=""
	Set st=##class(Config.NLS.Locales).ExportList(file,.NumExported,.Locales)
 } Else {
	Set st=##class(Config.NLS.Locales).Export(file,.NumExported,sLoc)
 }
 If st'=1 { Write !!,"Error exporting locale" Do $System.OBJ.DisplayError(st) Quit }
 Write !,"Successfully exported: "
 For t="Locales","Tables","SubTables" {
 	Set n=+$G(NumExported(t))
 	Write ?24,$J(n,2)," ",$ZCVT($E(t,1,$L(t)-(n=1)),"L"),!
 }
}
ImportLocale() [NumImported] {
 Kill NumImported
 If $$YN("Include locales?",1)="y" {
	Set implocs=1,imptabs=$$YN("Include tables?",1)="y"
 } Else {
	Set implocs=0,imptabs=1
 }
 Set selbits=implocs*2+imptabs*2+imptabs
 Write " (importing ",$Case(selbits,7:"locales and tables/subtables",4:"locales only",3:"tables/subtables only"),")"
 Set prompt="Import from file:"
 Set help(1)="Name of file from which to import locale or table definition."
 Set help(2)="Usually with extension .xml as exported by this utility or the"
 Set help(3)="portal, but .goq from earlier versions also accepted." 
filename ;
 Set ans=""
 Set st=##Class(%Library.Prompt).GetString(prompt,.ans,,,.help,128+4)
 If st=3 ZTrap "QUIT"
 If st=2||(ans="") Quit
 Set file=ans
 Set ext=$ZCVT($P(file,".",$L(file,".")),"L")
 If ext="goq" {
	If $ZCVT($E(file,$L(file)-7,*),"L")="_obj.goq" { Write !,"Object files not accepted",!,"Please select a source file" Goto filename }
	Set st=##class(Config.NLS.Locales).ImportLegacy(file,.NumImported,selbits,.warns)
	If $D(warns) {
		Write !!,"Warnings:" Set w=$O(warns(""))
		While w'="" { Write !?5,warns(w) Set w=$O(warns(w)) }
	}
 } ElseIf ext="xml" {
	Set st=##class(Config.NLS.Locales).ImportAll(file,.NumImported,selbits)
 } Else { Write " <Only .xml or .goq files>" Goto filename }
 If st'=1 Do $System.OBJ.DisplayError(st) Quit
 If ($G(NumImported("Locales"))+$G(NumImported("Tables"))+$G(NumImported("SubTables"))) {
	Write !,"Successfully imported: "
	For t="Locales","Tables","SubTables" {
		Set n=+$G(NumImported(t))
		Write ?24,$J(n,2)," ",$ZCVT($E(t,1,$L(t)-(n=1)),"L"),!
	}
 } Else { Write !,"No custom locale or table to import." }
 Kill NumImported
}
ValidateLocale() [sLoc] {
 Write ! Set dbg=$G(^%nlsmisc("DEBUG")),^%nlsmisc("DEBUG")=1
 Set st=##class(Config.NLS.Locales).Compile(sLoc)
 If st'=1 {
	Write !,"Error compiling locale ",sLoc
	Do $System.OBJ.DisplayError(st)
 }
 If 'dbg Kill ^%nlsmisc("DEBUG") 
 If ##class(Config.NLS.Locales).IsLoadable(sLoc,,.Errors) {
	Write !,"Locale ",sLoc," successfully validated."
 } Else {
	Write !,"Error",$E("s",Errors>1)," validating locale ",sLoc,":"
	For i=1:1:Errors Write !?5,Errors(i)
 }
}
CopyLocale() [sLoc,LocProps] {
as Write !,"Copy locale ",sLoc," as: " Read sNew Quit:sNew=""	
 If sNew="?" {
	 Write !?5,"Enter code for new locale"
	 Write !?5,"Must start with 'y' and end with '8' or 'w'"
	 Goto as
 }
 Set sNew=$ZCVT(sNew,"L")
 If $E(sNew)'="y" Write " <Must start with 'y'>" Goto as
 If $L(sNew)'=4 Write " <Must have 4 characters>" Goto as
 If $E(sNew,4)'="8",$E(sNew,4)'="w" Write " <Must end with '8' or 'w'>" Goto as
 If ##class(Config.NLS.Locales).Exists(sNew,.oNew) {
	 Write " <Already exists>" Kill oNew Goto as
 }
 Set def="Copy of "_sLoc
 Write !,"Description: <",def,"> " Read ans If ans="" Set ans=def
 Merge NewProps=LocProps
 Set NewProps("Name")=sNew,NewProps("Description")=ans
 Set st=##class(Config.NLS.Locales).Create(sNew,.NewProps)
 If st'=1 { Write !,"Error creating locale ",sNew Do $System.OBJ.DisplayError(st) }
 Else { Write !,"Locale ",sNew," created with success" }
}
DeleteLocale() [sLoc,oLoc,LocProps] {
 If '$SYSTEM.Security.Check("%Admin_Manage","USE") {
	Write !,"Sorry, you have no permission to delete locales."
	Quit
 }
 If $E(sLoc)'="y" {
	 Write !!,"You are about to delete a system locale."
	 If $$YN("Are you sure you want to continue?")'="y" Quit
 }
 If $G(^|"^^"_$zu(12)|%SYS("LOCALE","CURRENT"))=sLoc Write !,"Cannot delete current locale!" Quit
 Set ans=$$YN("Delete locale "_sLoc_" ?")
 If ans'="y" Write " <NOT deleted>" Quit
 Kill oLoc,LocProps
 Set st=##class(Config.NLS.Locales).Delete(sLoc) Kill sLoc
 Write $S(st=1:" Deleted",1:" Error!")
 Do SelectLocale()
}
LoadLocaleTable() [sLoc,LocProps] {
 Set oCur=##class(Config.NLS.Locales).OpenCurrent()
 If LocProps("CharacterSet")'=oCur.CharacterSet {
	 Write !!,"Locale ",sLoc," is based on ",LocProps("CharacterSet")
	 Write " but current locale (",oCur.Name,") is based on ",oCur.CharacterSet,"."
	 Write !,"Can only load tables from the same character set."
	 Quit
 }
 Kill oCur
 Write !!,"Select table to load"
 Do GetOptions(.types,"TableTypes")
seltyp Set ityp=""
 Set st=##Class(%Library.Prompt).GetMenu(types,.ityp,.types,,128+4)
 If st=2 Quit
 If st=3 ZTrap "QUIT"
 Set typ=types(ityp,1)
 Do ##class(Config.NLS.Locales).TablesExecute(.tabs,sLoc,typ)
 Set num=$LL(tabs)-1 If 'num Write !!,"No loadable ",typ," table." Goto seltyp
 For i=1:1:num Set names(i)=$LI(tabs,i+1)
 Set inam=""
 Set st=##Class(%Library.Prompt).GetMenu("Table name?",.inam,.names,,128+4)
 If st=2 Quit
 If st=3 ZTrap "QUIT"
 Set nam=names(inam)
 Write !!,"Loading table ",nam,"... "
 Set st=##class(Config.NLS.Tables).Load(sLoc,typ,nam)
 If st'=1 { Write "Error" Do $System.OBJ.DisplayError(st) }
 Else { Write "Success" }
 Write !
}
SelectLocale() [oLoc,sLoc,LocProps] {
selloc	;
 Kill obj,null
 If $D(sLoc),$D(oLoc) { Set def=sLoc }
 Else { Set def=$G(^|"^^"_$zu(12)|%SYS("LOCALE","CURRENT"),"enu8") }
 Write !!,"Select a locale: ",def, " => " Read ans
 Set ans=$ZCVT(ans,"L") If ans="" Set ans=def,null=1
 If ans'?1A2AN1"8",ans'?1A2AN1"w" {
	If ans="^" Quit "QUIT"
	Set up=$ZCVT(ans,"U")
	If "EXIT,STOP,QUIT,HALT,Q,"[(up_",") ZTrap "QUIT"
	If $E($ZCVT("Quit","U"),1,$L(up))=up ZTrap "QUIT"
	Do ShowLocales()
	Goto selloc
 }
 If '##class(Config.NLS.Locales).Exists(ans,.obj) Write " <Not available>",! Goto selloc
 If $$GetProperties(obj,.props)'=1 Goto selloc
 Kill LocProps Set sLoc=ans,oLoc=obj,LocProps=0
 Merge LocProps=props
 Write:'$D(null) " - " Write oLoc.Description
 Quit "NEXT"
}
ShowLocales() [nLines] {
 Set hdr=$$Justify(" Available locales ",78,2,"-")
 If '$D(nLines) Do GetLines()
 Write #,hdr
 Set rset=##class(%Library.ResultSet).%New("Config.NLS.Locales:List")
 If '$IsObject(rset) Quit
 Set rset.RuntimeMode=1
 Do rset.Execute("*")
 While rset.Next() {
	If nLines,$Y+3>nLines {
		Set st=##class(%Library.Prompt).GetMore()
		If st=3 ZTrap "QUIT"
		If st=2 Quit
		Write #,hdr,!
	} Else { Write ! }
	Write rset.Data("Name")," - ",rset.Data("Description")
 }
}
EditBasics() {
 Do GetFields(.Basics,"Basics")
 Do EditFields(.Basics)
}
EditFormats() {
 Do GetFields(.Formats,"Formats")
 Do EditFields(.Formats)
}
EditIntTables() {
 Write !!,"For each category, type the name of a table from the"
 Write !?5,"Locale list --> to remove it from the locale"
 Write !?5,"Choose list --> to include it in the locale"
 Do GetFields(.Tables,"IntTables")
 Do EditTables(.Tables)
}
EditIOTables() [LocProps] {
 Merge Tables=LocProps("XLTTables")
 Set chs=LocProps("CharacterSet"),new=0
rt Read !,"Table name: ",tab
 If tab="" {
	If LocProps { Do SaveLocChanges() }
	Else { Write !!,"No changes!" }
	Quit
 }
 If tab="?" {
	 Set tab=$O(Tables(""),1,lst)
	 While (tab'="") {
		 Write !?5,tab
		 Write ?20,"Output=(",$LI(lst,3),"->",$LI(lst,4),")"
		 Write ?50,"Input=(",$LI(lst,1),"->",$LI(lst,2),")"
		 Set tab=$O(Tables(tab),1,lst)
	 }
	 Write !!?5,"Enter an existing table name to edit/remove it from the locale"
	 Write !?5,"  or" 
	 Write !?5,"A new table to include it in the locale",! 
	 Goto rt
 }
 If $D(Tables(tab),lst) {
et	Write " Output=(",$LI(lst,3),"->",$LI(lst,4),")"
	Write " Input=(",$LI(lst,1),"->",$LI(lst,2),") ? "
	Read ans Set ans=$ZCVT(ans,"L") If ans="" Goto rt
	If ans'="^",ans'="r",ans'="e" {
		Write !?5,"ENTER - to select another table"
		Write !?5,"^     - to quit this level"
		Write !?5,"R     - to remove this table from the locale"
		Write !?5,"E     - to edit this table"
		Write !!,"Table name: ",tab
		Goto et
	}
	If ans="^" Quit
	If ans="r" {
		Write $E("removed",$L(ans)+1,99)
		Kill LocProps("XLTTables",tab),Tables(tab)
		Set LocProps=LocProps+1
		Goto rt
	}
	Write $E("edit",$L(ans)+1,99) Set new=0
 } Else {
	 Set ans=$$YN(" New?",1)
	 If ans'="y" Write " <Not available>" Goto rt
	 Set lst=$LB("",chs,chs,""),new=1
 }
 Write !,"Output from: ",chs 
out	Write !,?9,"to: " Set def=$LI(lst,4) Write:def'="" def," => " Read ans
 If ans="" {
	If def="" Write "<Invalid>" Goto out
	Set ans=def
 }
 If ans="^" Goto rt
 If ##class(Config.NLS.Tables).Exists("XLT",chs,ans) { Set $LI(lst,4)=ans }
 Else { Write " Table(XLT,",chs,",",ans,") is not available" Goto out }
inp Write !,"Input  from: " Set def=$LI(lst,1) Set:def="" def=ans Write def," => " Read ans
 If ans="" {
	If def="" Write "<Invalid>" Goto inp
	Set ans=def
 }
 If ans="^" Goto rt
 If ##class(Config.NLS.Tables).Exists("XLT",ans,chs) { Set $LI(lst,1)=ans }
 Else { Write " Table(XLT,",ans,",",chs,") is not available" Goto out }
 Write !?9,"to: ",chs,!
 If new||(Tables(tab)'=lst) Set Tables(tab)=lst,LocProps("XLTTables",tab)=lst,LocProps=LocProps+1
 Goto rt
}
EditIntDefs() {
 Do GetFields(.Defaults,"InternalDefaults")
 Do EditTabDefs(.Defaults,"Internal")
}
EditIODefs() {
 Do GetFields(.Defaults,"IODefaults")
 Do EditTabDefs(.Defaults,"I/O")
}
EditStrings() {
 Do GetFields(.Strings,"Strings")
 Do EditFields(.Strings)
 Do EditNames("Month")
 Do EditNames("Weekday")
}
EditTables(tables)[LocProps] {
 Set tab=1
ed1	Set seq=$$EditTable(tables(tab))
 If seq="PREV" { Set:tab>1 tab=tab-1 Goto ed1 }
 If seq="NEXT",tab<tables { Set tab=tab+1 Goto ed1 }
 If LocProps { Do SaveLocChanges() }
 Else { Write !!,"No changes!" }
}
EditTable(class) [LocProps] {
 Set tag=$P(class,"^",2),class=$P(class,"^",1),chs=LocProps("CharacterSet")
 Set ty=$E(class,1,$L(class)-6)
 Set:ty="Collation" ty="COL" Set:ty="Identifier" ty="Ident"
 Merge Tables=LocProps(class)
 Do GetTables^NLS1(.Tabs,ty,chs)
 For i=1:1:Tabs Set NewTables(Tabs(i))=""
 Kill Tabs
tb Write !!,$$Justify(tag_" ",75,1,"-")
 Write !?5,"Locale list: "
 Set tab=$O(Tables(""))
 While (tab'="") { Write:$X>65 !?10 Write tab," " Set tab=$O(Tables(tab)) }
 Write !?5,"Choose list: "
 Set tab=$O(NewTables(""))
 While (tab'="") { Write:$X>65 !?10 Write tab," " Set tab=$O(NewTables(tab)) }
 Read !!?5,"Table: ",tab
 If tab=""||(tab="^") {
	 If $O(Tables(""))'=""||(class["Case")||(class["Accent") Quit $S(tab="":"NEXT",1:"PREV")
	 Write !!?5,"The Locale list cannot be empty."
	 Write !?5,"Select a table from the ""Choose list""."
	 Goto tb
 }
 If tab="?" {
	 Write !!?5,"Enter a table from the ""Locale list"" to remove it"
	 Write !?5,"  or"
	 Write !?5,"A table from the ""Choose list"" to add it"
	 Write !
	 Write !?5,"^ - to go back to the previous class of tables"
	 Write !?5,"Q - to quit this program",!
	 Goto tb
 }
 If tab="Q"||(tab="q") ZTrap "QUIT"
 If $D(Tables(tab)) {
	 If ty="COL",tab="IRIS standard" Write " <Cannot remove IRIS standard>" Goto tb
	 Set ans=$$YN(" Remove?")
	 If ans="y" {
		 Kill Tables(tab),LocProps(class,tab) Set LocProps=LocProps+1
		 If '$D(LocProps(class)) Set LocProps(class)=""
	 }
	 Goto tb
 }
 If $D(NewTables(tab)) {
	Set Tables(tab)="",LocProps(class,tab)="",LocProps=LocProps+1
	Write " <Added to locale>"
 } Else { Write " <Not available>" }
 Goto tb
}
EditFields(fields) [LocProps] {
 Set fld=1
ed1	Set seq=$$EditField(.fields,fld)
 If seq="PREV" { Set:fld>1 fld=fld-1 Goto ed1 }
 If seq="NEXT",fld<fields { Set fld=fld+1 Goto ed1 }
 If LocProps { Do SaveLocChanges() }
 Else { Write !!,"No changes!" }
}
EditField(fields,fld) [LocProps,ans] {
 New ans
 Set z=fields(fld),fld=$P(z,"^",1),tag=$P(z,"^",2)_":",pat=$P(z,"^",3)
 Set def=$G(LocProps(fld))
 For i=1:1 Set x=$T(@(fld_"+"_i)),x=$P(x,";;",2,99) Quit:x=""  Set help(i)=x
getfield Set ans=def
 Set st=##Class(%Library.Prompt).GetString(tag,.ans,,,.help,128+4)
 If st=3   Quit "QUIT"
 If st=2 Quit "PREV"
 If pat'="*",@("ans'?"_pat) Write " <Wrong format (",pat,")>" Goto getfield
 If ans'=def Set LocProps(fld)=ans,LocProps=LocProps+1
 Quit "NEXT"
}
EditNames(type) [LocProps] {
 Set tnum=type_" # ",t1=$L(tnum)\2-2,t2=$L(tnum)+4,t3=t2+32,LocProps=0
 Set names=type_"Name",abbrs=type_"Abbr"
 Write !!,tnum," -- Name -------------------------- Abbreviation ----"
 For i=1:1:$L(LocProps(names)," ")-1 {
	Write !,?t1,$J(i,2)
	Set nxt=$$GetName(names,i,t2) If nxt Set i=nxt-1 Continue
	Set nxt=$$GetName(abbrs,i,t3) If nxt Set i=nxt-1 Continue
 }
 If LocProps { Do SaveLocChanges() }
 Else { Write !!,"No changes!" } 
} 
GetName(typ,itm,tab) [LocProps] {
 Set names=LocProps(typ),items=$L(names," ")-1,name=$P(names," ",itm+1)
 Set nxt=itm
 While (nxt=itm) {
	Write ?tab,name," ==> " Read ans If ans="" Set ans=name
	Set up=$ZCVT(ans,"U")
	If "EXIT,STOP,QUIT,HALT,Q,"[(up_",") ZTrap "QUIT"
	If $E($ZCVT("Quit","U"),1,$L(up))=up ZTrap "QUIT"
	If $E(ans)="^" {
		Set nxt=+$E(ans,2,*) Set:'nxt nxt=itm-1
		If nxt>0,nxt'>items Quit
		Else  Write " <1 to ",items,">",! Set nxt=itm
	} ElseIf ans="?" {
		Write !!?5,"Enter QUIT to quit the program"
		Write !?5,"      ^ to go back to be previous line"
		Write !?5,"      ^n to go to line #n",!!
	} Else {
		If ans'=name { Set $P(LocProps(typ)," ",itm+1)=ans,LocProps=LocProps+1 }
		Set nxt=0
	}
 }
 Quit nxt
}
SaveLocChanges() [oLoc,LocProps] {
 Write ! Set ans=$$YN(LocProps_" changed propert"_$S(LocProps=1:"y",1:"ies")_". Save?",1)
 If ans="y" {
	Set st1=oLoc.SetProperties(.LocProps)
	Set st2=oLoc.%Save()
	If st1'=1||(st2'=1) { Write " <Error saving locale>",!! Do $System.OBJ.DisplayError($S(st1'=1:st1,1:st2)) }
	Else { Write " <Saved>" }
 } Else {
	Write " <Discarded>" Set st=$$GetProperties(oLoc,.LocProps)
 }
 Set LocProps=0
}
SaveCfgChanges(categ,config) [Reload] {
 Set cfgr=$Name(^|"^^"_$zu(12)|SYS("NLS","Config"))
 Write ! Set ans=$$YN(config_" changed propert"_$S(config=1:"y",1:"ies")_". Save?",1)
 Set props=$Case(categ,"InternalDefaults":"PatternMatch,Identifier,Uppercase,Lowercase,Titlecase,PatternMatch,Alphaup,Accent"_",Collation,XYAction","IODefaults":"Process,IRISTerminal,OtherTerminal,File,Magtape,TCPIP,DSMDDP,DTMDCP,SystemCall,Printer",:"CSP")
 If ans="y" {
	For i=1:1:$L(props,",") {
		Set p=$P(props,",",i),old=$G(@cfgr@(p))
		If '$D(config(p),new) { Kill @cfgr@(p) }
		ElseIf old'=new { Set @cfgr@(p)=new }
	}
	Write " <Saved>" Set Reload=1
 }
}
GetFields(fields,class) PUBLIC {
 Kill fields Set fld=1,end=class_"End"
 For i=1:1 {
	Set t=$T(@(class_"+"_i)) Quit:t=""
	Set t1=$P(t," ",1) Quit:t1=end
	If t1'="" Set fields(fld)=t1_"^"_$P(t,";;",2,99),fld=fld+1
 }
 Set fields=fld-1
}
GetOptions(options,class) PUBLIC {
 Kill options
 Set opt=1,end=class_"End",t=$T(@class),prompt=$P(t,";;",2,99)
 For i=1:1 {
	Set t=$T(@(class_"+"_i)) Quit:t=""
	Set t1=$P(t," ",1) Quit:t1=end
	If t1'="" Set options(opt)=$P(t,";;",2,99),options(opt,1)=t1,opt=opt+1
 }
 Set options=prompt
}
GetProperties(loc,props) PUBLIC {
 Kill props Set st=loc.GetProperties(.props)
 If st=1 {
 	Set props=0
 } Else { Write " <Error accessing locale>" Do $System.OBJ.DisplayError(st) }
 Quit st
}
UsesTable(loc,ty,fr,to) PUBLIC {
 Set uses=0
 If ty="XLT" {
	Set tab="",r=loc.XLTTables.GetNext(.tab)
	while (tab'="") {
		If $LI(r,1)=fr,$LI(r,2)=to { Set uses=1 Quit }
		If $LI(r,3)=fr,$LI(r,4)=to { Set uses=1 Quit }
 		Set r=loc.XLTTables.GetNext(.tab)
	}
	Quit uses
 }
 Quit uses
}
Trunc(str,max) {
 If $L(str)'>max Quit str
 Quit $E(str,1,max-3)_"..."	
}
Page(need) [nLines] {
 If nLines,$Y+$G(need,0)+2>nLines {
	While ($Y+2<nLines) { Write ! }
	Set st=##class(%Library.Prompt).GetMore()
	If st=3 ZTrap "QUIT"
	If st=2 Quit "PREV"
	Write # Quit "PAGE"
 }
 Quit "NEXT"
}
Proceed() {
 Quit $$YN("Proceed anyway?")
}
YN(prompt,def) {
 Set ans=$G(def,0)	
 Set st=##Class(%Library.Prompt).GetYesNo(prompt,.ans,,128)
 If (st=2) Quit "n"
 If ans=1 Quit "y"
 Quit "n"
}
Justify(Str,Wid,Whr=1,Chr=" ") {
 Set len=$L(Str)
 If len=Wid Quit Str
 If len>Wid Quit $E(Str,1,Wid)
 Set $P(blnks,Chr,Wid+1)=""
 If Whr=1 {
	Set Str=Str_$E(blnks,len+1,Wid)
 } ElseIf Whr=2 {
	Set n=Wid-len\2,Str=$E(blnks,1,n)_Str_$E(blnks,1,n)
	If $L(Str)<Wid Set Str=Chr_Str
 } Else {
	Set Str=$E(blnks,len+1,Wid)_Str
 }
 Quit Str
}
GetLines() [nLines] {
 Set nLines=24
 Set st=##class(%Library.Prompt).GetNumber("Number of lines for paging (0=don't page): ",.nLines,0,200)
}
EMSManaged()	PRIVATE {
	;Q ##class(EMS.Instance).Restricted("Config.NLS.Locales")
	Quit 0  ;;
}
EMSEditText()	PRIVATE {
	;i ##class(EMS.Instance).Restricted("Config.NLS.Locales") q " (restricted)"
	q ""
}
Error() [oDev,xTab] {
 If $ZE'["<INTERRUPT>",$ZE'["<ZQUIT>" {
	If $G(%objlasterror)'="" {
		Write !
		Do $System.OBJ.DisplayError()
	} Else {
		Write !!,"An error occurred:"
		Write !?5,"$ZE=",$ZE
		Write !?5,"$ZU(56,2)=",$ZU(56,2)
	}
 }
 If $D(oDev),$D(xTab) Set oDev.XLTTable=xTab Kill xTab,oDev
}
Basics	;;
Description	;;Description^*
	;;Brief description for this locale
	;;Suggested format: <Language>, <Country>, <Character set> or
	;;                  <Comment>, <Character set>
	;;Example: English with mainframe compatibility, Latin1 (ISO 8859-1)
	;;
Currency	;;Currency sign^.10E
	;;The currency sign used in this geographical locale.
	;;Examples: $, R$
	;;
BasicsEnd	;;
Formats	;;
DateFormat	;;$ZDate format^1.2N
	;;The DateFormat code used whenever a $ZDATE, $ZDATEH,
	;;$ZDATETIME or $ZDATETIMEH function call omits its second
	;;parameter, or specifies a second parameter value of -1.
	;; 
	;;Value   Meaning         Example
	;;-----   --------------  ------------
	;;  0     DD Mmm [YY]YY   27 Mar 2002
	;;  1     MM/DD/[YY]      03/27/2002
	;;  2     DD Mmm [YY]YY   27 Mar 2002
	;;  3     YYYY-MM-DD      2002-03-27
	;;  4     DD/MM/[YY]YY    27/03/2002
	;;  5     Mmm D, YYYY     Mar 27, 2002
	;;  6     Mmm D YYYY      Mar 27 2002
	;;  7     Mmm DD [YY]YY   Mar 27 2002
	;;  8     YYYYMMDD        20020327
	;;  9     Mmmmmm D, YYYY  March 27, 2002
	;; 10     W               2 (day number for the week)
	;; 11     Www             Tue (abbreviated day name)
	;; 12     Wwwwww          Tuesday (full day name)
	;; 13     [D]D/[M]M/YYYY  27/11/2549 (Thai format)
	;; 14     nnn             354 (day numbe for the year)
	;;
DateSeparator	;;Date separator^1E
	;;The character used to delimit the months, days, and years
	;;of those dates which are otherwise entirely numeric.
	;;Example: "/"
	;;
TimeFormat	;;Time format^1N
	;;The TimeFormat code used whenever a $ZDATETIME, $ZDATETIMEH,
	;;$ZTIME or $ZTIMEH function call omits its TimeFormat parameter,
	;;or specifies a TimeFormat parameter value of -1.
	;; 
	;;Value   Meaning                    Example
	;;-----   -------------------------  ------------
	;;  1     hh:mm:ss (24-hour)         23:10:37
	;;  2     hh:mm (24-hour)            23:10
	;;  3     hh:mm:ss[AM/PM] (12-hour)  11:10 PM
	;;  4     hh:mm[AM/PM] (12-hour)     11:10     
	;;
TimeSeparator	;;Time separator^1E
	;;The character used to delimit the hours, minutes and seconds
	;;in a time value.
	;;Example: ":"
	;;
TimePrecision	;;Time precision^1N
	;;The number of fractional digits displayed in a time value
	;;whenever a $ZDATETIME or $ZTIME function call omits its
	;;Precision parameter, or specifies a Precision parameter
	;;value of -1.
	;;Example: 0
	;;
MinusSign	;;Minus sign^1E
	;;The character which may precede or follow a negative
	;;numeric quantity formatted by the $FNUMBER function.
	;;Example: "-"
	;;
PlusSign	;;Plus sign^1E
	;;The character which may optionally precede or follow a
	;;non-negative numeric quantity formatted by the $FNUMBER
	;;function.
	;;Example: "+"
	;;
DecimalSeparator	;;Decimal separator^1E
	;;The character used by the $FNUMBER function to separate
	;;the whole part of a number from the fractional part of
	;;the number. Also used by $ZDATETIME, $ZDATETIMEH, $ZTIME
	;;and $ZTIMEH to separate the whole part of the seconds from
	;;the optional fractional part of the seconds, if any.
	;;Example: "."
	;;
NumericGroupSeparator	;;Numeric group separator^1E
	;;The character used to separate groups of numeric digits
	;;within the whole number portion of a number formatted by
	;;the $FNUMBER function.
	;;Example: ","
	;;
NumericGroupSize	;;Numeric group size^1N
	;;The number of digits in a numeric group formatted by the
	;;$FNUMBER function.
	;;Example: 3
	;;
FormatsEnd	;;
IODefaults ;Prompt^Format^Available(s/*)^%SYS.NLS.Table
TranZCVT	;;Process^*^*^Process
	;;Default translation used for callin, callout and  $ZCVT()
	;;Example: RAW
	;;
TranProgrammer	;;Cache Terminal^*^*^CacheTerminal
	;;Default translation for Cache Terminal
	;;Example: UTF8
	;;
TranTerminal	;;Other terminal^*^*^OtherTerminal
	;;Default translation for terminals other than Cache Terminal
	;;Example: RAW
	;;
TranSequential	;;File^*^*^File
	;;Default translation for files and other sequential devices
	;;Example: RAW
	;;
TranMagTape	;;Magtape^*^*^Magtape
	;;Default translation for magnetic tapes
	;;Example: RAW
	;;
TranTCP	;;TCP/IP^*^*^TCPIP
	;;Default translation for TCP/IP socket
	;;Example: Unicode
	;;
TranSystemCall	;;System call^*^*^SystemCall
	;;Default translation used in OS system calls
	;;Example: RAW
	;;
TranPrinter	;;Printer^*^*^Printer
	;;Default translation for printers
	;;Example: RAW
	;;
IODefaultsEnd ;;
OtherDefaults ;Prompt^Format^Available(s/*)^%SYS.NLS.Table
CSP	;;CSP files^*^*^CSP
	;;Default encoding for CSP files
	;;Example: UTF8
	;;
OtherDefaultsEnd ;;
Strings	;;
AM	;;AM suffix^*
	;;Sufix which may optionally be appended to time values
	;;prior to 12 noon.
	;;Example: "AM"
	;;
PM	;;PM suffix^*
	;;The suffix which may optionally be appended to time values
	;;at or after 12 noon.
	;;Example: "PM"
	;;
Noon	;;Noon suffix^*
	;;The suffix which may optionally be appended to time values
	;;corresponding to exactly 12 noon.
	;;Example: "NOON"
	;;
Midnight	;;Midnight suffix^*
	;;The suffix which may optionally be appended to time
	;;values corresponding to exactly 12 midnight.
	;;Example: "MIDNIGHT"
	;;
StringsEnd	;;
InternalDefaults ;Prompt^Format^Available(s/*)^%SYS.NLS.Table
PatternTable	;;Pattern match^*^s^PatternMatch
	;;Default pattern match table
	;;Example: Latin2
	;;
IdentifierTable ;;Identifier^*^s^Identifier
	;;Default identifier table
	;;Example: Latin1
	;;
UpperCaseTable	;;Uppercase^*^s^Uppercase
	;;Default uppercase table
	;;Example: Latin1
	;;
LowerCaseTable	;;Lowercase^*^s^Lowercase
	;;Default lowercase table
	;;Example: Latin1
	;;
TitleCaseTable	;;Titlecase^*^s^Titlecase
	;;Default title case table
	;;Example: Latin1
	;;
AccentTable	;;Accent^*^s^Accent
	;;Default Accent table
	;;Example: Latin1
	;;
CollationTable	;;Collation^*^s^Collation
	;;Default collation table
	;;Examples: IRIS standard, Portuguese2, Greek3
	;;
XYTable	;;$X/$Y action^*^s^XYAction
	;;Default $X/$Y table
	;;Example: LatinC
	;;
InternalDefaultsEnd ;;
IntTables	;;Loadable tables
PatternTables	;;Pattern match tables
IdentifierTables	;;Identifier tables
UpperCaseTables	;;Uppercase tables
LowerCaseTables	;;Lowercase tables
TitleCaseTables	;;Titlecase tables
AccentTables	;;Accent tables
CollationTables	;;Collation tables
XYTables	;;$X/$Y action tables
IntTablesEnd	;;
TableTypes	;;Table type?
XLT	;;I/O
LowerCase	;;Lower case
UpperCase	;;Upper case
TitleCase	;;Title case
Accent	;;Accent
Pattern	;;Pattern match
Ident	;;Identifier
COL	;;Collation
XY	;;$X/$Y action
TableTypesEnd	;;

NLS1^INT^1^67214,47331
NLS1	; Manage NLS properties (Tables)
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 Quit
Tables() PUBLIC {
 Set options(1)="Existing table",options(2)="New table"
 While (1) {
    Set op="",st=##Class(%Library.Prompt).GetMenu("Table definition?",.op,.options,,128+4)
    If (st=2)||(st=3) Quit
    If options(op)["Existing" { If $$SelectTable()'="NEXT" Continue }
    ElseIf options(op)["New" { If $$CreateTable()'="NEXT" Continue }
    Do TableLoop()
 }
}
TableLoop() [sTab] {
 While (1) {
	Kill options Set op=1
	Set ty=$P(sTab,",",1),fr=$P(sTab,",",2),to=$P(sTab,",",3)
	Set options(op)="Display table",op=op+1
	If $E(fr)="y"||($E(to)="y")||($D(@($Name(^||SYS("NLS")))@("System"))) { 
		Set options(op)="Edit table",op=op+1
		Set options(op)="Delete table",op=op+1
	}
	Set options(op)="Export table",op=op+1
	Set options(op)="Validate table",op=op+1
	Set options(op)="Copy table",op=op+1
	Set options(op)="Select another table"
	Write !!,"Selected Table(",ty,",",fr Write:to'=fr ",",to Write ")"
	Set op="",st=##Class(%Library.Prompt).GetMenu("Table option?",.op,.options,,128+4)
	If (st=2)||(st=3) Quit
	If options(op)["Display" { Do DisplayTable() }
	ElseIf options(op)["Edit" { Do EditTable() }
	ElseIf options(op)["Export" { Do ExportTable() }
	ElseIf options(op)["Validate" { Do ValidateTable() }
	ElseIf options(op)["Copy" { Do CopyTable() }
	ElseIf options(op)["Delete" { Do DeleteTable() If '$D(sTab) Quit }
	ElseIf options(op)["Select" { Do SelectTable() }
	Else { Quit }
 } 
}
DisplayTable() [nLines,sTab,oTab,sSub,oSub,sMod,oMod] {
 If '$D(nLines) Do GetLines()
 Set ty=$P(sTab,",",1),desc=oTab.Description
 Write #,$$Justify(" Table("_sTab_") ",78,2,"-")
 Write !,"       Description: ",desc
 If $E(desc,1,8)="Built-in" Quit
 If ty="XLT" {
	Write !,"  Translation type: ",$Case(oTab.XLTType,0:"Non-modal to non-modal",1:"Non-modal to modal",2:"Modal to modal",:"Unknown")
	Write !,"    Default action: ",$Case(oTab.XLTDefaultAction,0:"Generate error",1:"Replace with replacement string/value",2:"Ignore",:"Unknown")
	Write !," Replacement value: ",oTab.XLTReplacementValue," (""",@("$C("_oTab.XLTReplacementValue_")"),""")"
	If $D(sMod) {
		Write !,"        Mode table: ",sMod
		If '$D(oSub) Do DisplayModeSubTab()
	}
	If $D(oSub) {
		Write !,"      Mapping type: ",$Case(oSub.Type,0:"Single to single",1:"Single to multi",2:"Multi to single",3:"Multi to multi",:"Unknown")
		Do DisplayFromToTab()
	}
	Quit
 }
 If ty="COL" {
	Set col=oTab.COLRules
	For i=2,3 {
		Write !!,$P(", Local,Global",",",i)," encoding rules:"
		Set rul=$LI(col,i),nr=rul\32,sr=rul#32
		Write !?5,"Numeric: ",nr," (",$P("New ANSI;Old ANSI;String;Cobra;DTM-Native;DTM-Compatible;Cobra2;DSM-Native",";",nr+1),")"
		Write !?5," String: ",sr," (",$P("No conversion, quote initial < 32;Quote 0-3 and initial < 32;Disallow 0 or initial < 32;Quote 0-31;DTM-Native string;Unicode;DSM-Native;Table+Unicode",";",sr+1),")"
	}
	Write !!,"Internal collation #: ",$LI(col)
	Do DisplayFromToTab(1) Quit
 }
 If ty["Case"||(ty["Accent") { Do DisplayFromToTab() Quit }
 If ty="Pattern" { Write !,"Pattern code table: ",sSub Do DisplayRangeTab() Quit }
 If ty="Ident" { Do DisplayIdentTab() Quit }
 If ty="XY" { Do DisplayRangeTab() Quit }
 If ty="Mode" { Do DisplayModeTab() Quit }
 If ty="Patcode" { Do DisplayPatcodeTab() Quit }
}
EditTable() [oTab,sTab] {
 If $E(oTab.Description,1,8)="Built-in" { Write !!,"This is a built-in table." Quit }
 If '$SYSTEM.Security.Check("%Admin_Manage","USE") {
	Write !,"Sorry, you have no permission to edit tables."
	Quit
 }
 If $E($P(sTab,",",2))'="y",$E($P(sTab,",",3))'="y" {
	 Write !!,"You are about to edit a system table."
	 Write !,"Any changes will be discarded during a system upgrade."
	 If $$YN("Are you sure you want to continue?")'="y" Quit
 }
 Set options(1)="Properties"
 Set options(2)="Table data"
 While (1) {
	Set op="",st=##Class(%Library.Prompt).GetMenu("Edit option?",.op,.options,,128+4)
	If (st=2)||(st=3) Quit
	If op=1 { Do EditTableProps() }
	ElseIf op=2 { Do EditTableData() }
	Else { Quit }
 } 
}
ExportTable() [oTab,sTab] {
 If $E(oTab.Description,1,8)="Built-in" { Write !!,"This is a built-in table." Quit }
 Set ty=$P(sTab,",",1),fr=$P(sTab,",",2),to=$P(sTab,",",3)
 Set file="tab_"_$TR(sTab,",","_")_".xml"
 Write !,"Export to file: ",file," => " Read ans If ans="" Set ans=file
 Set file=ans,Tables(ty,fr,to)=""
 If ty="XLT"||(ty="COL"),##class(Config.NLS.Tables).Exists(ty,to,fr) {
	Set Tables(ty,to,fr)=""
 }
 Set st=##class(Config.NLS.Tables).ExportList(file,.NumExported,.Tables)
 If st'=1 { Write !!,"Error opening file ",file Do $System.OBJ.DisplayError(st) Quit }
 Write !,"Successfully exported: "
 For t="Tables","SubTables" {
 	Set n=NumExported(t)
 	Write ?24,$J(n,2)," ",$ZCVT($E(t,1,$L(t)-(n=1)),"L"),!
 }
}
ValidateTable() [oTab,sTab] {
 If $E(oTab.Description,1,8)="Built-in" { Write !!,"This is a built-in table." Quit }
 Set ty=$P(sTab,",",1),fr=$P(sTab,",",2),to=$P(sTab,",",3)
 If ty="Mode"||(ty="Patcode") {
	Write !!,"Not applicable to ",ty," tables."
	Quit
 }
 Write !
 Set inv=0
 If ty="COL" Set inv=1
 If ty="XLT",##class(Config.NLS.Tables).Exists(ty,to,fr),$$YN("Also validate inverse table?",1)="y" Set inv=1
 Do ValidateOneTable(ty,fr,to)
 If inv Do ValidateOneTable(ty,to,fr)
}
ValidateAndReloadTable() [sTab] {
	Set ty=$P(sTab,",",1),fr=$P(sTab,",",2),to=$P(sTab,",",3)
	Set oldoid=$O(^SYS("shm","Src",1,"%nls",ty,fr,to,""),-1)
	Set oldoff=$S(oldoid="":0,1:$G(^SYS("shm","Off",0,oldoid)))
	Write !!,"Validating Table(",sTab,")"
	Do ValidateOneTable(ty,fr,to)
	If '##class(Config.NLS.Tables).IsLoadable(ty,fr,to) {
		Write !,"This table cannot be loaded"
		Quit
	}
	If oldoff,$$IsTableInLocale(ty,fr,to,.sloc,.name) {
		Write !!,"The old version of this table is currently loaded."
		If $$YN("Would you like to load the new version?",1)="y" {
			Set st=##class(Config.NLS.Tables).Load(sloc,ty,name)
			If st { Write " <Reloaded>",!,"The new version will be visible to new processes." }
			Else {
				Write !,"Error reloading table"
				Do $System.OBJ.DisplayError(st)
			}
		} Else { Write " <Not reloaded>" }
	}
}
ValidateOneTable(ty,fr,to) {
 Write !!
 Set dbg=$G(^%nlsmisc("DEBUG")),^%nlsmisc("DEBUG")=1
 Set stab=ty_","_fr_","_to
 Set st=##class(Config.NLS.Tables).Compile(ty,fr,to)
 If st'=1 {
	Write !,"Error compiling Table(",stab,")"
	Do $System.OBJ.DisplayError(st)
 }
 If 'dbg Kill ^%nlsmisc("DEBUG") 
 If ##class(Config.NLS.Tables).IsLoadable(ty,fr,to,,.Errors) {
	Write !,"Table(",stab,") successfully validated."
 } Else {
	Write !,"Error",$E("s",Errors>1)," validating Table(",stab,"):"
	For i=1:1:Errors Write !?5,Errors(i)
 }
}
IsTableInLocale(ty,fr,to,sloc,name) PUBLIC {
	Set oloc=##class(Config.NLS.Locales).OpenCurrent()
	If '$IsObject(oloc) Return 0
	Do oloc.GetProperties(.props) Set ret=0,pair=""
	If ty="XLT" {
		Set pair=$O(props("XLTTables",""),1,tabs)
		While pair'="" {
			If $LI(tabs,1)=fr,$LI(tabs,2)=to Set ret=1 Quit
			If $LI(tabs,3)=fr,$LI(tabs,4)=to Set ret=1 Quit
			Set pair=$O(props("XLTTables",pair),1,tabs)
		}
	} Elseif ty["Case"||(ty["Accent") {
		If $D(props(ty_"Tables",to)) Set ret=1,pair=to
	} Elseif ty="Ident" {
		If $D(props("IdentifierTables",to)) Set ret=1,pair=to
	}
	If ret Set sloc=oloc.Name,name=pair
	Return ret
}
CopyTable() [sTab,oTab] {
 If $E(oTab.Description,1,8)="Built-in" { Write !!,"This is a built-in table." Quit }
 Set ty=$P(sTab,",",1),fr=$P(sTab,",",2),to=$P(sTab,",",3),dfr="",dto=""
 If ty="Mode"||(ty="Patcode") { Set dto=to }
 ElseIf fr="Unicode" { Set dfr=fr }
 ElseIf to="Unicode" { Set dto=to }
 ElseIf fr?1"Unicode"1.E { Set dto=to }
 ElseIf to?1"Unicode"1.E { Set dfr=fr }
 ElseIf fr=to,fr?1"Latin"1E||(fr?1"CP"4N) { Set dfr=fr }
 ElseIf fr=to,to?1"Latin"1E||(to?1"CP"4N) { Set dto=to }
 Write !!,"Enter "
 If ty="XLT" {
	Write $S(dfr=""&&(dto'=""):"'from'",dfr'=""&&(dto=""):"'to'",dfr=""&&(dto=""):"'from' and 'to'")," encoding"
	Set hlpf="Enter new 'from' encoding",hlpt="Enter new 'to' encoding"
 } Else {
	 Write "new name"
	 Set (hlpf,hlpt)="Enter new table name"
 }
 Write " for copy of Table(",sTab,")"
getfrom Write !,$S(ty="XLT":"From: ",ty="Mode":"Mode name: ",ty="Patcode":"Table name: ",1:"Character set: ")
 If dfr="" {
	If dto'="" Write "y"
	Read ans If ans=""||(ans="^") Quit
	If ans="?" Write !,hlpf Goto getfrom 
	If ans'?1.AN Write " <Only alphanumerical characters>" Goto getfrom
	Set zfr=$S(dto'="":"y"_ans,1:ans)
 } Else { Write dfr Set zfr=dfr }
 If ty="Mode"||(ty="Patcode") { Set zto=zfr Goto create }
getto Write !,$S(ty="XLT":"To: ",ty="COL":"Collation: ",1:"Table name: ")
 If dto="" {
	If dfr'="" Write "y"
	Read ans If ans=""||(ans="^" ) Goto getfrom:dfr="" Quit
	If ans="?" Write !,hlpt Goto getto
	If ans'?1.AN Write " <Only alphanumerical characters>" Goto getto
	If dfr="",$E(zfr)'="y",$E(ans)'="y" Write " <Either source or target encoding must start with 'y'>",! Goto getfrom
	Set zto=$S(dfr'="":"y"_ans,1:ans)
 } Else { Write dto Set zto=dto }
create Set sNew="Table("_ty_","_zfr_","_zto_")"
 If ##class(Config.NLS.Tables).Exists(ty,zfr,zto) { Write " <",sNew," already exists>" Goto getfrom }
 Set st=oTab.GetProperties(.NewProps)
 If st'=1 { Write !,"Error accessing Table(",sTab,")" Do $System.OBJ.DisplayError(st) Quit }
 Set NewProps("Description")="Copy of "_NewProps("Description")
 Set st=##class(Config.NLS.Tables).Create(ty,zfr,zto,.NewProps)
 If st'=1 { Write !,"Error creating ",sNew Do $System.OBJ.DisplayError(st) Quit }
 If $$OpenTable(ty,zfr,zto) Write !!,"New ",sNew," created and selected with success"
 Else  Write !!,"Error selecting ",sNew
}
CreateTable() [sTab,oTab] PUBLIC {
 Write !!,"Create a new table"
 Do GetNewTableTypes(.Types)
gettype	;
 Set itype=""
 Set st=##Class(%Library.Prompt).GetMenu(Types,.itype,.Types,,128+4)
 If (st=2)||(itype="") Quit "PREV"
 Set ty=Types(itype,1) Write "  ",Types(itype)
getfrom ;
 If ty="XLT" {
    Write !!,"Either source or destination encoding must start with 'y'",!
    Set (hlpf,hlpt)="Enter encoding name starting with 'y'"
    Write !,"From: "
    Read ans If ans=""||(ans="^") goto gettype
    If ans="?" Write !,hlpf Goto getfrom 
    If ans'?1.AN Write " <Only alphanumerical characters>" Goto getfrom
    Set fr=ans,yt=$E(fr)'="y"
 } ElseIf ty="Mode" { Set yt=1 Goto getto }
 Else {
	Do GetCharsets(.Charsets)
    Set ichs=""
    Set st=##Class(%Library.Prompt).GetMenu("Character set?",.ichs,.Charsets,,128+4)
    If (st=2)||(ichs="") goto gettype
    Set fr=Charsets(ichs),yt=1 Write "  ",Charsets(ichs)
    Set hlpt="Enter table name starting with 'y'"
 }
getto Write !,$S(ty="XLT":"To: ",1:"Table name: ")
 If yt Write "y"
 Read ans If ans=""||(ans="^" ) Goto getfrom
 If ans="?" Write !,hlpt Goto getto
 If ans'?1.AN Write " <Only alphanumerical characters>" Goto getto
 Set to=ans Set:yt to="y"_to Set:ty="Mode" fr=to
 If ty="XLT",fr=to Write " <Source and destination encodings must be different>" Goto getto
 If ty'="XLT",ty'["Case",ty'["Accent" Set maxchar=0 Goto create
 Do GetOptions(.Sizes,"TableSizes")
getsize	;
 Set itype=""
 Write !!,"Initialization will map each character to itself"
 Set st=##Class(%Library.Prompt).GetMenu(Sizes,.itype,.Sizes,,128+4)
 If (st=2)||(itype="") Goto getfrom
 Set maxchar=Sizes(itype,1)
create Set sNew="Table("_ty_","_fr_","_to_")"
 If ##class(Config.NLS.Tables).Exists(ty,fr,to) { Write " <",sNew," already exists>" Goto getfrom }
 Set st=##class(Config.NLS.Tables).CreateSkeleton(ty,fr,to,maxchar)
 If st'=1 { Write !,"Error creating ",sNew Do $System.OBJ.DisplayError(st) Quit }
 If $$OpenTable(ty,fr,to) Write !!,"New ",sNew," created and selected with success"
 Else  Write !!,"Error selecting ",sNew
 Quit "NEXT"
}
DeleteTable() [sTab,oTab,sSub,oSub] {
 If $E(oTab.Description,1,8)="Built-in" { Write !!,"This is a built-in table." Quit }
 If '$SYSTEM.Security.Check("%Admin_Manage","USE") {
	Write !,"Sorry, you have no permission to delete tables."
	Quit
 }
 If $E($P(sTab,",",2))'="y",$E($P(sTab,",",3))'="y" {
	 Write !!,"You are about to delete a system table."
	 If $$YN("Are you sure you want to continue?")'="y" Quit
 }
 Set ty=$P(sTab,",",1),fr=$P(sTab,",",2),to=$P(sTab,",",3)
 If $E(fr)'="y",$E(to)'="y" { Write !!,"Cannot delete System Table(",sTab,")" Quit }
 Set ans=$$YN("Delete Table("_sTab_") ?")
 If ans'="y" Write " <NOT deleted>" Quit
 Kill sTab,oTab,oSub,sSub
 Set st=##class(Config.NLS.Tables).Delete(ty,fr,to,1)
 Write $S(st=1:" Deleted",1:" Error!")
 Do SelectTable()
}
SelectTable() {
 Write !!,"Select a table"
 Do GetOptions(.Types,"TableTypes")
gettype	;
 Set itype=""
 Set st=##Class(%Library.Prompt).GetMenu(Types,.itype,.Types,,128+4)
 If (st=2)||(itype="") Quit "PREV"
 Set ty=Types(itype,1) Write "  ",Types(itype)
 Do GetTables(.From,ty) Set From=$G(From)
 If 'From Write !,"No ",ty," table available" Goto gettype
 Set From=$Case(ty,"XLT":"From:","Patcode":"Table name:","Mode":"Table name:",:"Character set:")
getfrom	;
 Set ifrom=""
 Set st=##Class(%Library.Prompt).GetMenu(From,.ifrom,.From,,128+4)
 If (st=2)||(ifrom="") Goto gettype
 Set fr=From(ifrom) Write "  ",From(ifrom)
 Do GetTables(.To,ty,fr) Set to=$G(to)
 If 'To Write !,"No table available" Goto getfrom
 If To=1 { Set ito=1 Goto selend }
 Set To=$S(ty="XLT":"To:",1:"Table name:")
getto	;
 Set ito=""
 Set st=##Class(%Library.Prompt).GetMenu(To,.ito,.To,,128+4)
 If (st=2)||(ito="") Goto getfrom
 Write "  ",To(ito)
selend	;
 Set to=To(ito)
 If '$$OpenTable(ty,fr,to) Goto gettype
 Quit "NEXT"
}
OpenTable(ty,fr,to) [sTab,oTab,sSub,oSub,sMod,oMod,TabProps] PUBLIC {
	If '##class(Config.NLS.Tables).Exists(ty,fr,to,.obj,.st) Write " <Not available>",! Return 0
	If st'=1 Write !,"Error opening table" Do $System.OBJ.Dump(st) Return 0 
	Set st=obj.GetProperties(.props)
	If st'=1 Write " <Error accessing table>" Do $System.OBJ.DisplayError(st) Return 0
	If obj.SubTableName'="" {
		Set stn=obj.SubTableName
		If ty="Pattern" { Set avl=##class(Config.NLS.Tables).Exists("Patcode",stn,stn,.sub,.st) }
		Else { Set avl=##class(Config.NLS.SubTables).Exists(stn,.sub,.st) }
		If 'avl Write " <Sub-table ",stn," not available>",! Return 0
		If st'=1 Write !,"Error opening sub-table" Do $System.OBJ.Dump(st) Return 0
	}
	If obj.XLTModeTableName'="" {
		Set mtn=obj.XLTModeTableName
		If '##class(Config.NLS.Tables).Exists("Mode",mtn,mtn,.mod,.st) Write " <Mode table ",mtn," not available>" Return 0
		If st'=1 Write !,"Error opening table" Do $System.OBJ.Dump(st) Return 0
	}
	Kill TabProps Set TabProps=0 Merge TabProps=props
	Set sTab=ty_","_fr_","_to,oTab=obj
	If $D(sub) { Set sSub=stn,oSub=sub }
	Else { Kill sSub,oSub }
	If $D(mod) { Set sMod=mtn,oMod=mod }
	Else { Kill sMod,oMod }
	Return 1
}
DisplayFromToTab(col) [nLines,oSub] {
 Write !!,$$Justify(" Table data ",78-10,2,"-")
 Set tab=10,st=1
 Set w1=20,h1=$$Justify($S($D(col):" Char ",1:" From code "),w1,2,"-")
 Set w2=20,h2=$$Justify($S($D(col):" Collate value ",1:" To code "),w2,2,"-")
 Write !!?tab,h1,"  ",h2
 Set array=oSub.FromTo
 Set from="",to=array.GetNext(.from)
 While (from'="") {
	If nLines,$Y+3>nLines {
		Set st=##class(%Library.Prompt).GetMore()
		If st=3 ZTrap "QUIT"
		If st=2 Quit
		Write #?tab,h1,"  ",h2
	}
	Write !?tab,$J(from,w1),"  ",$J(to,w2)
 	Set to=array.GetNext(.from)
 }
 Quit st
}
DisplayRangeTab() [nLines,oTab] {
 Set tab=3,ty=oTab.Type,st=1
 If ty="XY" {
	Set w1=20,h1=$$Justify(" $X/$Y Action ",w1,1,"-")
	Set array=oTab.XYActions
 } Else {
	Set w1=16,h1=$$Justify(" Pattern code ",w1,2,"-")
	Set array=oTab.PatternRanges
 }
 Set w2=20,h2=$$Justify(" From character ",w2,2,"-")
 Set w3=20,h3=$$Justify(" To character ",w3,2,"-")
 Write !!?tab,h1,"  ",h2,"  ",h3
 Set idx="",ranges=array.GetNext(.idx)
 While (idx'="") {
	If ty="XY" { 
		Set f1=" "_$P("Normal,Full width,Non-printing,Backspace,Line feed,Form feed,Carriage return,Escape sequence",",",idx+1)
		Set f1=$$Justify(f1,w1,1)
	} Else { Set f1=$$Justify(idx,w1,2) }
	For i=1:1:$LL(ranges) {
		Set range=$List(ranges,i)
		Set f2=$P(range,":",1),f3=f2+$P(range,":",2)-1
		If nLines,$Y+3>nLines {
			Set st=##class(%Library.Prompt).GetMore()
			If st=3 ZTrap "QUIT"
			If st=2 Quit
			Write #?tab,h1,"  ",h2,"  ",h3
		}
		Write !?tab,f1,"  ",$$Justify($J(f2,5),w2,2),"  ",$$Justify($J(f3,5),w3,2)
	}
	If st'=1 Quit
 	Set ranges=array.GetNext(.idx)
 }
}
DisplayIdentTab() [nLines,oTab] {
 Set tab=3
 Set w1=20,h1=$$Justify(" From character ",w1,2,"-")
 Set w2=20,h2=$$Justify(" To character ",w2,2,"-")
 Write !!?tab,h1,"  ",h2
 Set ranges=oTab.Identifiers
 For i=1:1:$LL(ranges) {
	Set range=$List(ranges,i)
	Set f1=$P(range,":",1),f2=f1+$P(range,":",2)-1
	If nLines,$Y+3>nLines {
		Set st=##class(%Library.Prompt).GetMore()
		If st=3 ZTrap "QUIT"
		If st=2 Quit
		Write #?tab,h1,"  ",h2
	}
	Write !?tab,$J(f1,w2),"  ",$J(f2,w2)
 }
}
DisplayModeTab() [nLines,TabProps] {
 If '$D(nLines) Do GetLines()
 Set tab=2
 Set w1=10,h1=$$Justify(" Mode # ",w1,2,"-")
 Set w2=19,h2=$$Justify(" Mode name ",w2,2,"-")
 Set w3=14,h3=$$Justify(" Bytes/char ",w3,2,"-")
 Set w4=21,h4=$$Justify(" Escape sequence ",w4,2,"-")
 Write !!?tab,h1,"  ",h2,"  ",h3,"  ",h4
 For m=0:1:$O(TabProps("Modes",""),-1) {
	Set mod=TabProps("Modes",m)
	Set f1=m,f2=$P(mod,":",1),f3=$P(mod,":",2),f4=$P(mod,":",3)
	If nLines,$Y+3>nLines {
		Set st=##class(%Library.Prompt).GetMore()
		If st=3 ZTrap "QUIT"
		If st=2 Quit
		Write #?tab,h1,"  ",h2,"  ",h3,"  ",h4
	}
	Write !?tab,$$Justify(f1,w1,2),"  ",$$Justify(f2,w2,1)
	Write "  ",$$Justify(f3,w3,2),"  ",$$Justify(f4,w4,3)
 }
}
DisplayModeSubTab() [sMod,oMod,oSub] {
 Set modes=oMod.Modes,tab=3
 For m=0:1:modes.Count()-1 {
	Set prp=modes.GetAt(m),mod=$P(prp,":",1)
	Set h1=$$Justify(" Mode "_m_" ",78,2,"-")
	If ##class(Config.NLS.SubTables).Exists(mod,.oSub) {
		Write !!,h1
		Write !?tab,"      Mode name: ",mod
		Write !?tab,"     Bytes/char: ",$P(prp,":",2)
		Write !?tab,"Escape sequence: ",$P(prp,":",3)
		If $$DisplayFromToTab()'=1 Quit
	}
 }
 Kill sSub,oSub
}
DisplayPatcodeTab() [nLines,TabProps] {
 If '$D(nLines) Do GetLines()
 Set tab=3,st=1
 Set w1=20,h1=$$Justify(" Pattern code ",w1,2,"-")
 Set w2=20,h2=$$Justify(" Value ",w2,2,"-")
 Write !!?tab,h1,"  ",h2
 Set list=TabProps("PatCodes")
 For i=1:1:$LL(list) {
	Set x=$LI(list,i),f1=$P(x,":",1),f2=$P(x,":",2)
	If nLines,$Y+3>nLines {
		Set st=##class(%Library.Prompt).GetMore()
		If st=3 ZTrap "QUIT"
		If st=2 Quit
		Write #?tab,h1,"  ",h2
	}
	Write !?tab,$$Justify(f1,w1,2),"  ",$$Justify($J(f2,10),w2,2)
 }
 If st'=1 Quit
 Set list=TabProps("PatAliases") If list="" Quit
 Set w2=20,h2=$$Justify(" Alias ",w2,2,"-")
 If nLines,$Y+4>nLines {
	Set st=##class(%Library.Prompt).GetMore()
	If st=3 ZTrap "QUIT"
	If st=2 Quit
 }
 Write !!?tab,h1,"  ",h2
 For i=1:1:$LL(list) {
	Set x=$LI(list,i),f1=$P(x,":",1),f2=$TR($P(x,":",2),";",",")
	If nLines,$Y+3>nLines {
		Set st=##class(%Library.Prompt).GetMore()
		If st=3 ZTrap "QUIT"
		If st=2 Quit
		Write #?tab,h1,"  ",h2
	}
	Write !?tab,$$Justify(f1,w1,2),"  ",$$Justify($J(f2,10),w2,2)
 }
}
EditTableProps() [sMod,oMod,sSub,oSub,sTab,oTab,TabProps] {
 Set ty=$P(sTab,",",1),fr=$P(sTab,",",2),to=$P(sTab,",",3),TabProps=0
desc Set ans=TabProps("Description") Write !
 Set st=##Class(%Library.Prompt).GetString("Description: ",.ans,,,,128+4)
 If st=3 ZTrap "QUIT"
 If st=2 Quit
 If ans'=TabProps("Description") { Set TabProps("Description")=ans,TabProps=TabProps+1 }
 If ty="XLT" {
	Set action(1)="Generate error",action(2)="Replace with replacement string/value"
	Set action(3)="Ignore (replace with original value)"
	Set ans=TabProps("XLTDefaultAction")+1
	Set st=##Class(%Library.Prompt).GetMenu("Default action: ",.ans,.action,,128+4)
	If st=3 ZTrap "QUIT"
	If st=2 Goto desc
    Set ans=ans-1
    If ans'=TabProps("XLTDefaultAction") { Set TabProps("XLTDefaultAction")=ans,TabProps=TabProps+1 }
	If ans=1 {
		Set x=TabProps("XLTReplacementValue"),rep=""
		If TabProps("XLTType") Set mode=$P(x,",",1),x=$P(x,",",2,999)
		For i=1:1:$L(x,",") Set rep=rep_$C($P(x,",",i))
		Write !!,"Replacement value: ",rep," => " Read ans If ans="" Set ans=rep
		If ans'=rep {
			If TabProps("XLTType") { Set rep=mode_"," }
			Else { Set rep="" }
			For i=1:1:$L(ans) Set rep=rep_$A(ans,i)_","
			Set TabProps("XLTReplacementValue")=$E(rep,1,$L(rep)-1),TabProps=TabProps+1
		}
	}
	If $D(sMod) {
		Do GetTables(.tables,"Mode")
		Set ans="" For i=1:1:$O(tables(""),-1) If tables(i)=sMod { Set ans=i Quit }
		Set st=##Class(%Library.Prompt).GetMenu("Mode table: ",.ans,.tables,,128+4)
		If st=3 ZTrap "QUIT"
		If st=2 Goto desc
		Set ans=tables(ans)
		If ans'=sMod { Set TabProps("XLTModeTableName")=ans,TabProps=TabProps+1 }
	}
 } ElseIf ty="Pattern" {
	Do GetTables(.tables,"Patcode")
	Set ans="" For i=1:1:$O(tables(""),-1) If tables(i)=sSub { Set ans=i Quit }
	Set st=##Class(%Library.Prompt).GetMenu("Pattern Code table: ",.ans,.tables,,128+4)
	If st=3 ZTrap "QUIT"
	If st=2 Goto desc
	Set ans=tables(ans)
	If ans'=sSub { Set TabProps("SubTableName")=ans,TabProps=TabProps+1 }
 } ElseIf ty="COL" {
	Set col=TabProps("COLRules"),num=$LI(col,1)
	Set st=##class(%Library.Prompt).GetNumber("Internal number: ",.num,10,255)
	If st=3 ZTrap "QUIT"
	If st=2 Goto desc
	If $LI(col,1)'=num { Set $LI(col,1)=num,TabProps("COLRules")=col,TabProps=TabProps+1 }
	Do EditCOLRules()
 }
 If TabProps {
	Do SaveTabChanges()
	If $D(sSub),oTab.SubTableName'=sSub {
		Set stn=oTab.SubTableName
		If ty="Pattern" { Set avl=##class(Config.NLS.Tables).Exists("Patcode",stn,stn,.sub,.st) }
		Else { Set avl=##class(Config.NLS.SubTables).Exists(stn,.sub,.st) }
		If 'avl { Write " <Sub-table ",stn," not available>",! ZTrap "TAB1" }
 		If st'=1 { Write !,"Error opening sub-table" Do $System.OBJ.Dump(st) Ztrap "TAB2" }
 		Set sSub=stn,oSub=sub
 	}
	If $D(sMod),oTab.XLTModeTableName'=sMod {
		Set mtn=oTab.XLTModeTableName
		If '##class(Config.NLS.Tables).Exists("Mode",mtn,mtn,.mod,.st) Write " <Mode table ",mtn," not available>" ZTrap "TAB3"
		If st'=1 { Write !,"Error opening table" Do $System.OBJ.Dump(st) ZTrap "TAB4" }	
		Set sMod=mtn,oMod=mod
	}
 } Else { Write !!,"No changes!" }
}
EditTableData() [sTab,sMod] {
 Set ty=$P(sTab,",",1)
 If ty="XLT",$D(sMod) {
	Write !!,"This I/O table uses Mode table ",sMod
	If $E(sMod)'="y" { Write !,"Try Edit Properties to change it",! }
	Else { Write !,"You can either 1) Edit Properties to change its Mode table or"
	Write !,"               2) Select Mode table ",sMod," and Edit its Data",!  }
 }
 ElseIf ty="XLT"||(ty="COL")||(ty["Case")||(ty["Accent") { Do EditSubTable() }
 ElseIf ty="Pattern"||(ty="XY")||(ty="Ident") { Do EditRangeTable(ty) }
 ElseIf ty="Mode" { Do EditModeTable() }
 ElseIf ty="Patcode" { Do EditPatcodeTable() }
}
EditCOLRules() [TabProps] {
	Set rul=TabProps("COLRules")
	Do GetOptions(.numeric,"NumericRules"),GetOptions(.string,"StringRules")
	For i=2,3 {
		Set enc=$LI(rul,i),num=enc\32,str=enc#32
		Write !!,$$Justify($P(", Local, Global",",",i)_" Encoding Rules ",78,2,"-")
		Set ans=num+1,st=##Class(%Library.Prompt).GetMenu(numeric,.ans,.numeric,,128+4+2)
		If st=3 ZTrap "QUIT"
		Set ans=ans-1 If ans'=num { Set num=ans,TabProps=TabProps+1 }
		Set ans=str+1,st=##Class(%Library.Prompt).GetMenu(string,.ans,.string,,128+4+2)
		If st=3 ZTrap "QUIT"
		Set ans=ans-1 If ans'=str { Set str=ans,TabProps=TabProps+1 }
		Set $LI(rul,i)=num*32+str
	}
	If TabProps("COLRules")'=rul { Set TabProps("COLRules")=rul }
}
EditSubTable() [sSub,oSub,SubProps] {
 If $$HowManyUseSubTable(sSub)>1 Do CopySubTable()
 Write !!,"Loading data for SubTable(",sSub,")" Kill SubProps
 Set st=oSub.GetProperties(.SubProps),SubProps=0
 If st'=1 { Write !,"Error accessing SubTable(",sSub,")" Do $System.OBJ.DisplayError(st) Quit }
 If $P(sSub,"-",1)="XLT" {
	Do GetOptions(.subtypes,"SubTypes") Set isub=SubProps("Type")+1
	Set st=##Class(%Library.Prompt).GetMenu(subtypes,.isub,.subtypes,,128+4)
	If st=2 Quit
	If st=3 ZTrap "QUIT"
	Set isub=isub-1
	If isub'=SubProps("Type") { Set SubProps("Type")=isub,SubProps=SubProps+1 }
 }
 Write !
 For {
	Read !,"From code(s): ",fr Quit:fr=""
	If '$$IsValidCode(fr) Continue
	If '$D(SubProps("FromTo",fr),df) Set df=""
	Write ?32,"To code(s): " Write:df'="" df," ==> " Read to Set:to="" to=df
	If to="D"||(to="d") {
		If df="" Write " no data to delete" Continue
		Write "elete?"
		If $$YN(" ")="y" { Kill SubProps("FromTo",fr) Write " Deleted" Set SubProps=SubProps+1 }
		Else { Write " <NOT deleted>" }
		Continue
	}
	If '$$IsValidCode(to,1) Continue
	If to=df Continue
	Set SubProps("FromTo",fr)=to,SubProps=SubProps+1
 }
 If SubProps { Do SaveSubChanges() }
 Else { Write !!,"No changes!" }
}
FindSubType() [SubProps] PUBLIC {
	Set fromMulti=0,toMulti=0,f=$O(SubProps("FromTo",""),1,t)
	While f'="" {
	   If f[",",'fromMulti Set fromMulti=2
	   If t[",",'toMulti Set toMulti=1
	   If fromMulti,toMulti Quit
	   Set f=$O(SubProps("FromTo",f),1,t)
	}
	Return fromMulti+toMulti
}
SaveSubChanges() [sSub,oSub,SubProps] {
 Write ! Set ans=$$YN(SubProps_" changed point"_$S(SubProps=1:"",1:"s")_". Save?",1)
 If ans="y" {
	Set SubProps("Type")=$$FindSubType()
	Set st1=oSub.SetProperties(.SubProps)
	Set st2=oSub.%Save()
	If st1'=1||(st2'=1) { Write " <Error saving SubTable(",sSub,")>",!! Do $System.OBJ.DisplayError() }
	Else { Write " <Saved>" Do:$P(sSub,"-",1)'="Mode" ValidateAndReloadTable() }
 } Else { Write " <Discarded>" }
 Kill SubProps
}
EditRangeTable(ty) [sTab,oTab,Ranges] {
 If ty="Pattern" { Set array=oTab.PatternRanges Do GetPatcodes(.options) }
 ElseIf ty="XY" { Set array=oTab.XYActions Do GetOptions(.options,"XYActions") }
 Else { Set ranges=oTab.Identifiers,idx=ty,tag=" Identifiers " Goto getrange }
getclass ;
 Set ans=""
 Set st=##Class(%Library.Prompt).GetMenu(options,.ans,.options,,128+4)
 If st=3 ZTrap "QUIT"
 If st=2||(ans="") Quit
 If ty="Pattern" {
	Set idx=options(ans),ranges=oTab.PatternRanges.GetAt(idx)
	Set tag=" Pattern code '"_idx_"' "
 } Else {
	Set idx=ans-1,ranges=oTab.XYActions.GetAt(idx)
	Set tag=" "_options(ans)_" "
 }
getrange ;
 Kill Ranges
 For i=1:1:$LL(ranges) {
	Set range=$List(ranges,i),fr=$P(range,":",1),to=fr+$P(range,":",2)-1
	Set Ranges(fr)=to
 }
 Do EditRange(tag)
 If Ranges { Do SaveRanges(ty,idx) }
 Else { Write !!,"No changes!" }
 If ty'="Ident" Goto getclass
}
EditRange(tag) [Ranges] {
 Write !!,$$Justify(tag,40,2,"-") Set Ranges=0
getrange Write !,"Range: " Read ans If ans="" Quit
 If ans="?" {
	Set fr=$O(Ranges(""),1,to) Write !!,"-- Current ranges --"
	While (fr'="") { Write !?4,$J(fr,5),":",to Set fr=$O(Ranges(fr),1,to) }
	Write !!,"Enter a new range as <initial char>:<end char>"
	Write !?5,"or"
	Write !,"An existing range in order to delete it.",!
	Goto getrange
 }
 If ans'?1N.N1":"1N.N { Write " Format:  <initial char>:<end char>" Goto getrange }
 Set fr=$P(ans,":",1),to=$P(ans,":",2)
 If $L(fr)>7||(fr>1114111) { Write " <Initial character is too big>" Goto getrange }
 If $L(to)>7||(to>1114111) { Write " <End character is too big>" Goto getrange }
 If $D(Ranges(fr),to2),to=to2 {
	If $$YN("  Delete?")="y" { Kill Ranges(fr) Set Ranges=Ranges+1 Write " <Deleted>" }
	Else { Write " <NOT deleted>" }
	Goto getrange
 }
 Set nxt=$O(Ranges(fr),1,to2)
 If nxt'="",to'<nxt { Write " <Overlaps with range ",nxt,":",to2,">" Goto getrange }
 Write $S($D(Ranges(fr)):" <Modified>",1:" <Added>") Set Ranges(fr)=to,Ranges=Ranges+1
 Goto getrange
}
SaveRanges(ty,idx) [oTab,Ranges] {
 Write ! Set ans=$$YN(Ranges_" changed range"_$S(Ranges=1:"",1:"s")_". Save?",1)
 If ans="y" {
	Set ranges="",fr=$O(Ranges(""),1,to)
	For i=1:1 { Quit:fr=""  Set $LI(ranges,i)=fr_":"_(to-fr+1),fr=$O(Ranges(fr),1,to) }
	If ty="Pattern" {
		If ranges'="" { Set st=oTab.PatternRanges.SetAt(ranges,idx) }
		Else { Do oTab.PatternRanges.RemoveAt(idx) Set st=1 }
	} ElseIf ty="XY" {
		If ranges'="" { Set st=oTab.XYActions.SetAt(ranges,idx) }
		Else { Do oTab.XYActions.RemoveAt(idx) Set st=1 }
	} Else { Set oTab.Identifiers=ranges,st=1 }
	If st'=1 { Write " <Error updating table>",!! Do $System.OBJ.DisplayError(st) }
	Set st=oTab.%Save()
	If st'=1 { Write " <Error saving table>",!! Do $System.OBJ.DisplayError(st) }
	Else { Write " <Saved>" }
 } Else { Write " <Discarded>" }
 Kill Ranges
}
EditModeTable() [sSub,oSub,TabProps] {
begin	;
 Set maxm=$O(TabProps("Modes",""),-1),TabProps=0
getmode Kill oSub,sSub,SubProps
 Read !!,"Mode #",ans If ans=""||(ans="^") Quit
 If ans'?1N.N||(ans<0)||(ans>(maxm+1)) {
	 Do DisplayModeTab()
	 Write !!?2,"Enter a mode # between 0 and ",maxm," to edit it."
	 Write !?2,"Or ",maxm+1," to create a new mode."
	 Goto getmode
 }
 Set num=+ans
 If num-1=maxm {
	Write " <New mode>"
	Set mod="Mode-New:1:27",maxm=num,new=1
 } Else { Set mod=TabProps("Modes",num),new=0 }
getname Set def=$P(mod,":",1),oldname=def
 Write !,"Mode name: ",def," => " Read ans If ans="" Set ans=def
 If ans="^" Goto getmode
 If ans=def Goto getsub
 If ans'?1"Mode-"1E.E {
	 Write !?5,"Enter a new mode name as 'Mode-xxxxx'"
	 Write !?5,"Or 'D' to delete this mode."
	 Goto getname
 }
 If ans="D"||(ans="d") {
	Write "elete?"
	If num'=maxm { Write " <Only last mode can be deleted>" Goto getmode }
	If num=0 { Write " <Table must have at least one mode>" Goto getname }
	If $$YN(" ")="y" {
		Kill TabProps("Modes",num) Set maxm=maxm-1,num=maxm,TabProps=TabProps+1
		Write " <Deleted>"
	} Else { Write " <NOT deleted>" }
	goto getmode
 }
 Set $P(mod,":",1)=ans
getsub Kill oSub,sSub,SubProps
 If ##class(Config.NLS.SubTables).Exists(ans,.obj) {
	Set sSub=ans,oSub=obj Kill obj
 } Else {
	If new=0 {
	   Write !
	   If $$YN("Copy SubTable data from "_oldname_"?",1)="y" {
	      Write !!,"Copying SubTable data",!
	      If ##class(Config.NLS.SubTables).Exists(oldname,.obj) {
	         Do obj.GetProperties(.SubProps) Kill obj
	      } Else { Write " <Error>" Goto getmode }
	   } Else {
	      Write !!,"An empty SubTable will be created",!
	      Set SubProps("Type")=2
	   }
	} Else {
	   Set SubProps("Type")=2
	}
	Set SubProps("Description")=$P(ans,"-",2,99)_" mode subtable"
	Set st=##class(Config.NLS.SubTables).Create(ans,.SubProps) Kill SubProps
	If st=1,##class(Config.NLS.SubTables).Exists(ans,.obj) {
		Set sSub=ans,oSub=obj Kill obj
	} Else {
		Write !,"Error creating new SubTable ",ans,!
		Goto getmode
	}
 }
getbytes Set def=$P(mod,":",2)
 Write !,"Bytes/character: ",def," => " Read ans If ans="" Set ans=def
 If ans="^" Goto getname
 If ans=def Goto getseq
 If ans'?1N||(ans=0) { Write " <Enter a number between 1 and 9>" Goto getbytes } 
 Set $P(mod,":",2)=ans
getseq Set def=$P(mod,":",3)
 Write !,"Escape sequence: ",def," => " Read ans If ans="" Set ans=def
 If ans="^" Goto getbytes
 Set val=1 For i=1:1:$L(ans,",") { Set by=$P(ans,",",i) If by'?1N.N||(by>255) Set val=0 Quit }
 If 'val { Write !?5,"Enter a sequence of byte codes separated by commas" Goto getseq }
 If ans'=def Set $P(mod,":",3)=ans
 If new||(TabProps("Modes",num)'=mod) { Set TabProps("Modes",num)=mod,TabProps=TabProps+1 }
 If TabProps {
	 Do SaveTabChanges()
	 If new,'$D(TabProps("Modes",num)) Goto begin
 } Else { Write !!,"No changes!" }
 Write !
 If $D(oSub),$D(sSub),$$YN("Edit SubTable data for this mode?")="y" {
	Write !!,$$Justify(" Mode "_num_" ("_$P($P(mod,":",1),"-",2,99)_") ",75,2,"-"),!
	Do EditSubTable()
 } 
 Goto getmode
}
EditPatcodeTable() [TabProps] {
 Set x=TabProps("PatCodes")   For i=1:1:$LL(x) Set y=$LI(x,i),Values($P(y,":",1))=$P(y,":",2)
 Set x=TabProps("PatAliases") For i=1:1:$LL(x) Set y=$LI(x,i),Aliases($P(y,":",1))=$P(y,":",2)
 Set TabProps=0
getpatcode ;
 Read !!,"Pattern code: ",ans If ans=""||(ans="^") Goto save
 If ans="?" {
	Do DisplayPatcodeTab()
	Write !!?3,"Enter an existing pattern code to edit it."
	Write !?3,"Or a new code to be added to the table."
	Goto getpatcode
 }
 If ans'?1A.A,ans'?1N.N { Write " <Alphabetical or numerical characters only>" Goto getpatcode }
 Set code=ans,isalias=0,isvalue=0,def="",new=0
 If $D(Values(code),def) { Set isvalue=1,prompt="Value: " }
 ElseIf $D(Aliases(code),def) { Set isalias=1,prompt="Alias: " }
 ElseIf code?1N.N { Set isalias=1,prompt="Alias: " }
 Else { Set prompt="Value/alias: " }
 If def="" Write " <New>"
getvalue ;
 Write !,prompt Write:def'="" def," => " Read ans If ans="" Set ans=def
 If 'new,ans="D"||(ans="d") {
	Write "elete?"
	If $$YN(" ")="y" {
		If isvalue { Kill Values(code) Set TabProps=TabProps+1 }
		ElseIf isalias { Kill Aliases(code) Set TabProps=TabProps+1 }
		Write " <Deleted>"
	} Else { Write " <NOT deleted>" }
	Goto makelists
 }
 If ans="?" {
	Write !?3,"Enter a new value/alias"
	Write !?3,"Or D to delete the current pattern code."
	Goto getvalue
 }
 If isvalue {
	If ans'?1N.N { Write " <Numerical values>" Goto getvalue }
	Set Values(code)=ans
 } ElseIf isalias {
	Set ok=1 For i=1:1:$L(ans,",") { Set x=$P(ans,",",i) If x'?1A.A Set ok=0 Quit }
	If 'ok { Write " <Comma-separated list of pattern codes>" Goto getvalue }
	Set Aliases(code)=ans
 } ElseIf ans?1N.N { Set Values(code)= ans }
 Else { Set Aliases(code)=ans }
 Set TabProps=TabProps+1
makelists ;
 Set lst="",cod=$O(Values(""),1,val)
 For i=1:1 { Quit:cod=""  Set $LI(lst,i)=cod_":"_val,cod=$O(Values(cod),1,val) }
 Set TabProps("PatCodes")=lst
 Set lst="",cod=$O(Aliases(""),1,val)
 For i=1:1 { Quit:cod=""  Set $LI(lst,i)=cod_":"_val,cod=$O(Aliases(cod),1,val) }
 Set TabProps("PatAliases")=lst
 Goto getpatcode
save ;
 If TabProps { Do SaveTabChanges() }
 Else { Write !!,"No changes!" }
}
SaveTabChanges() [oTab,TabProps] {
 Write ! Set ans=$$YN(TabProps_" changed propert"_$S(TabProps=1:"y",1:"ies")_". Save?",1)
 If ans="y" {
	Set st1=oTab.SetProperties(.TabProps)
	Set st2=oTab.%Save()
	If st1'=1||(st2'=1) { Write " <Error saving table>",!! Do $System.OBJ.DisplayError(st) }
	Else { Write " <Saved>" }
 } Else {
	Write " <Discarded>" Kill TabProps
	Set st=oTab.GetProperties(.TabProps)
	If st'=1 { Write " <Error accessing table>" Do $System.OBJ.DisplayError(st) }
 }
 Set TabProps=0
}
CopySubTable() [sSub,oSub,oTab,TabProps] {
 Write !,"Copying SubTable data"
 Set sNew=sSub,bas=$P(sNew,".",1)
 Do {
	Set num=$P(sNew,".",2)+1,sNew=bas_$E(".0000",1,5-$L(num))_num
 } While (##class(Config.NLS.SubTables).Exists(sNew,.sub))
 Set st=oSub.GetProperties(.SubProps)
 If st'=1 { Write !,"Error accessing SubTable(",sSub,")" Do $System.OBJ.DisplayError(st) ZTrap "SUB1" }
 Set SubProps("Description")="Copy of "_SubProps("Description")
 Set st=##class(Config.NLS.SubTables).Create(sNew,.SubProps) Kill SubProps
 If st'=1 { Write !,"Error creating ",sNew Do $System.OBJ.DisplayError(st) ZTrap "SUB2" }
 If $P(sNew,"-",1)="Mode" {
	 Set modes=oTab.Modes
	 For i=0:1:modes.Count()-1 {
		 Set m=modes.GetAt(i)
		 If $P(m,":",1)=sSub Set $P(m,":",1)=sNew Do modes.SetAt(m,i) Set TabProps("Modes",i)=m Quit
	 }
 } Else { Set oTab.SubTableName=sNew,TabProps("SubTableName")=sNew }
 Do oTab.%Save()
 Set sub=##class(Config.NLS.SubTables).%OpenId(sNew,,.st)
 If st'=1 { Write !,"Error accessing SubTable(",sNew,")" Do $System.OBJ.DisplayError(st) ZTrap "SUB3" }
 Set sSub=sNew,oSub=sub
}
IsValidCode(str,del) {
 Set val=1,dis=$P(str,";",2),cod=$P(str,";",1)
 For i=1:1:$L(cod,",") { If $P(cod,",",i)'?1N.N Set val=0 Quit }
 If 'val {
	Write !!,"Enter one or more character codes separated by commas."
	Write:$G(del) !,"Or 'D' to delete the current node"
	Write !,"Examples:",?12,"168",!?12,"27,94,65",!
 } ElseIf dis'="" {
	If $L(str,";")>2 {
		Write !!,"For collations, use ';' to separate the codes from the disambiguator."
		Write !,"Example:",?12,"158,159;4",!
		Set val=0
	} ElseIf dis>255 {
		Write !!,"Disambiguator must be 0 <= dis <= 255",!
		Set val=0
	}
 }
 Quit val
}
HowManyUseSubTable(sub) {
 Set rset=##class(%Library.ResultSet).%New("Config.NLS.Tables:List")
 If '$IsObject(rset) Quit 0
 Set rset.RuntimeMode=1,n=0
 Do rset.Execute("XLT,COL,Mode,LowerCase,UpperCase,TitleCase,Accent","*","*")
 While rset.Next() {
	If $$UsesSubTable(rset.Data("Type"),rset.Data("NameFrom"),rset.Data("NameTo"),sub) Set n=n+1
 }
 Quit n
}
UsesSubTable(ty,fr,to,sub) {
 If '##class(Config.NLS.Tables).Exists(ty,fr,to,.tab) Quit 0
 If ty="XLT"||(ty="COL")||(ty["Case")||(ty["Accent") Quit tab.SubTableName=sub
 Set uses=0
 If ty="Mode" {
	Set Modes=tab.Modes
	For i=0:1:Modes.Count()-1 {
		If $P(Modes.GetAt(i),":",1)=sub { Set uses=1 Quit }
	}
 }
 Quit uses
}
GetPatcodes(array) [oSub] {
 Kill array Set list=oSub.PatCodes
 For i=1:1:$LL(list) Set array(i)=$P($LI(list,i),":",1)
 Set array="Pattern code?"
}
GetTables(Tables,Type,From) PUBLIC {
	Kill Tables Set Tables=0,From=$G(From,"*")
	Set rset=##class(%Library.ResultSet).%New("Config.NLS.Tables:List")
	If '$IsObject(rset) Quit
	Set rset.RuntimeMode=1
	Do rset.Execute(Type,From,"*")
	If From="*" {
		While rset.Next() {
			Set nam=rset.Data("NameFrom")
			If Type'="COL" { Set tab(nam)="" }
			Elseif (nam="Unicode")||(nam?1"Latin"1E)||(nam?1"CP"4N) { Set tab(nam)="" }
		}
		Set t=$O(tab(""))
		While t'="" {
			Set Tables=Tables+1,Tables(Tables)=t
			Set t=$O(tab(t))
		}
	} Else {
		While rset.Next() { Set Tables=Tables+1,Tables(Tables)=rset.Data("NameTo") }
	}
}
GetCharsets(Chs) PUBLIC {
	Kill Chs Set Chs=1,Chs(1)="Unicode"
	Set ref=$Name(^%SYS("NLS","Chs","Int-Int"))
	Set i=$O(@ref@(""),1,chs)
	While i'="" {
		If chs?1"CP"1.4N||(chs?1"Latin".1E) Set Chs=Chs+1,Chs(Chs)=chs
		Set i=$O(@ref@(i),1,chs)
	}
}
Justify(Str,Wid,Whr=1,Chr=" ") {
 Set len=$L(Str)
 If len=Wid Quit Str
 If len>Wid Quit $E(Str,1,Wid)
 Set $P(blnks,Chr,Wid+1)=""
 If Whr=1 {
	Set Str=Str_$E(blnks,len+1,Wid)
 } ElseIf Whr=2 {
	Set n=Wid-len\2,Str=$E(blnks,1,n)_Str_$E(blnks,1,n)
	If $L(Str)<Wid Set Str=Chr_Str
 } Else {
	Set Str=$E(blnks,len+1,Wid)_Str
 }
 Quit Str
}
Confirm() {
 Quit $$YN("Confirm?")
}
YN(prompt,def) {
 Set ans=$G(def,0)	
 Set st=##Class(%Library.Prompt).GetYesNo(prompt,.ans,,128)
 If (st=2) Quit "n"
 If ans=1 Quit "y"
 Quit "n"
}
GetLines() [nLines] {
 Set nLines=24
 Set st=##class(%Library.Prompt).GetNumber("Number of lines for paging (0=don't page): ",.nLines,0,200)
 Write #
}
GetOptions(options,class) {
 Kill options
 Set opt=1,end=class_"End",t=$T(@class),prompt=$P(t,";;",2,99)
 For i=1:1 {
	Set t=$T(@(class_"+"_i)) Quit:t=""
	Set t1=$P(t," ",1) Quit:t1=end
	If t1'="" Set options(opt)=$P(t,";;",2,99),options(opt,1)=t1,opt=opt+1
 }
 Set options=prompt
}
GetNewTableTypes(options) {
 Kill options
 Set opt=1,end="TableTypesEnd",prompt="New table type?"
 For i=1:1 {
	Set t=$T(@("TableTypes+"_i)) Quit:t=""
	Set t1=$P(t," ",1) Quit:t1=end
	If t1="COL"||(t1="Patcode") Continue
	If t1'="" Set options(opt)=$P(t,";;",2,99),options(opt,1)=t1,opt=opt+1
 }
 Set options=prompt
}
TableSizes	;;Table size?
0	;;Empty
255	;;8-bit (0-255)
65535	;;Unicode (0-65535)
TableSizesEnd	;;
TableTypes	;;Table type?
XLT	;;I/O
LowerCase	;;Lower case
UpperCase	;;Upper case
TitleCase	;;Title case
Accent	;;Accent
Pattern	;;Pattern match
Ident	;;Identifier
COL	;;Collation
XY	;;$X/$Y action
Mode	;;Mode
Patcode	;;Pattern code
TableTypesEnd	;;
StringRules	;;String encoding rule?
sr0	;;No conversion, quote initial < 32
sr1	;;Quote 0-3 and initial < 32
sr2	;;Disallow 0 or initial < 32
sr3	;;Quote 0-31
sr4	;;DTM-Native
sr5	;;Unicode
sr6	;;DSM-Native
sr7	;;Table+Unicode
StringRulesEnd	;;
NumericRules	;;Numeric encoding rule?
nr0	;;New ANSI
nr1	;;Old ANSI
nr2	;;String
nr3	;;Cobra
nr4	;;DTM-Native
nr5	;;DTM-Compatible
nr6	;;Cobra2
nr7	;;DSM-Native
NumericRulesEnd	;;
XYActions	;;Character class?
xy0	;;Normal printing character
xy1	;;Full width character
xy2	;;Non-printing character
xy3	;;Backspace character
xy4	;;Line feed character
xy5	;;Form feed character
xy6	;;Carriage return character
xy7	;;Escape sequence character
XYActionsEnd	;;
SubTypes	;;Mapping?
sb0	;;Single to single
sb1	;;Single to multi
sb2	;;Multi to single
sb3	;;Multi to multi
SubTypesEnd	;;

NLS2^INT^1^67214,47331
NLS2	; Manage NLS properties (System settings)
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ;%ShmObj.INC ; JLC1084 11/07/07
 Quit
Current() [nLines] PUBLIC {
 If '$D(nLines) Do GetLines()
 Set options(1)="Display loaded I/O tables"
 Set options(2)="Display loaded collations"
 Set options(3)="Display system defaults for I/O tables"
 Set options(4)="Display system defaults for internal tables"
 Set options(5)="Display process defaults for I/O tables"
 Set options(6)="Display process defaults for internal tables"
 While (1) {
	Set op="",st=##Class(%Library.Prompt).GetMenu("Option?",.op,.options,,128+4)
	If (st=2)||(st=3) Quit
	If op=1 { Do DispIOTabs() }
	ElseIf op=2 { Do DispCOLTabs() }
	ElseIf op=3 { Do DispIOSysDef() }
	ElseIf op=4 { Do DispIntSysDef() }
	ElseIf op=5 { Do DispIOProcDef() }
	ElseIf op=6 { Do DispIntProcDef() }
	Else { Quit }
 } 
}
DispIOTabs() [nLines] {
 Write #,$$Justify(" Loaded I/O tables ",75,2,"-"),!
 Set hdr1="I/O Table pair   ",hdr2="Type                "
 Do DispHeader(hdr1,hdr2)
 Set tab=$V((0)*$ZU(40,0,25)+($ZU(40,2,103)),-2,$ZU(40,0,25)),nam=""
 For {
	Set nam=$ZU(127,2,tab,nam) Quit:nam=""
	If nLines,$Y+5>nLines {
		Set st=##class(%Library.Prompt).GetMore()
		If st=3 ZTrap "QUIT"
		If st=2 Quit
		Write # Do DispHeader(hdr1,hdr2)
	}
	Do DispNamEle(tab,nam,2)
 }
}
DispCOLTabs() {
 Write #,$$Justify(" Loaded collations ",75,2,"-"),!
 Do DispHeader("Number","Name                     ")
 For col=0,1,5:1:255 {
	Set nam=$$GetCOL(col)
	If nam'="" Write !,$J(col,4),?9,nam
 }
}
GetCOL(col) {
 Set rul=$ZU(23,2,col),nam=""
 If $P(rul,"^",1,2)'="255^255" {
	Set num=$P(rul,"^",3)
	If num {
		Set offs=$ZU(83,num),dec=+$P(offs,",",2),enc=+offs
		If enc||dec {
			Set nam=$$GetOffName(enc,"COL")
			If col>128 Set nam=nam_" string"
		}
	} Else {
		If col<6 { Set nam=$P("Old ANSI^New ANSI^^^^IRIS standard","^",col+1) }
 		ElseIf col#128<6 { Set nam=$P("Old string^New string^^^^IRIS standard string","^",col-127) }
		Else { Set nam="???" }
 	}
 }
 Quit nam
}
DispIOSysDef() {
 Write #,$$Justify(" System defaults for I/O tables ",60,2,"-"),!
 Do DispIOTab($ZU(40,2,105),-2)
}
DispIOProcDef() {
 Write #,$$Justify(" Process defaults for I/O tables ",60,2,"-"),!
 Do DispIOTab($ZU(40,1,27),-1)
}
DispIntSysDef()
{
 Write #,$$Justify(" System defaults for internal tables ",60,2,"-"),!
 Do DispDef($ZU(40,2,104),-2)
 Do DispCOL(0)
 Do DispTab("",$ZU(40,2,106),"$X/$Y action",0,-2)
}
DispIntProcDef()
{
 Write #,$$Justify(" Process defaults for internal tables ",60,2,"-"),!
 Do DispDef($ZU(40,1,26),-1)
 Do DispCOL(1)
 Do DispTab("",$ZU(40,1,28),"$X/$Y action",0,-1)
}
DispNamEle(tab, nam, ele) {
 Set ele(0)=0,t1=20
 For i=1:1:ele Set ele(i)=$ZU(127,1,tab,nam,i) Set:ele(i) ele(0)=1
 Write !,nam If 'ele(0) Write ?t1,"Empty" Quit
 For i=1:1:ele {
	If ele(i) {
		Write:i>1 ! Write:ele-1 ?t1-6,$P("In,Out",",",i)
		Write ?t1,$$GetOffName(ele(i))
	}
 }
}
DispTab(hdr,base,names,max,typ) {
 If hdr'="" Do DispHeader(hdr,"Name           ")
 For i=0:1:max {
	Set off=$V((i)*$ZU(40,0,25)+(base),typ,$ZU(40,0,25)) Write !,$P(names,",",i+1)
	If off { Write ?20,$ZU(126,5,off) }
 }
 Write !
}
DispIOTab(base,typ) {
 Do DispHeader("Table            ","Name           ")
 For i=0:1:5,8:1:9 {
	Set off=$V((i)*$ZU(40,0,25)+(base),typ,$ZU(40,0,25)) Write !,$P("Process,IRIS Terminal,Other terminal,File,Magtape,TCP/IP,DSM-DDP,DTM-DCP,System call,Printer",",",i+1)
	If off { Write ?20,$ZU(126,5,off) }
 }
 Write !
}
DispCOL(proc) {
 Set col=$ZU(23,proc),nam=$$GetCOL(col)
 Write !,"Collation",?20,nam
}
DispDef(base,typ) {
 Do DispHeader("Table            ","Name                ")
 For i=0:1:7 {
	If i=5,'$ZBITGET($ZVERSION(0),30) Continue
	Set off=$V((i)*$ZU(40,0,25)+(base),typ,$ZU(40,0,25)) Write !,$P("Pattern match,Identifier,Uppercase,Lowercase,Titlecase,U2 pattern match,Alphaup,Accent",",",i+1)
	If off { Write ?20,$$GetOffName(off,$P("Pattern,Ident,UpperCase,LowerCase,TitleCase,Pattern,Alphaup,Accent",",",i+1)) }
 }
}
DispHeader(h1,h2,h3,h4) {
 Write ! Set sep="   "
 Write:$D(h1) h1 Write:$D(h2) sep,h2 Write:$D(h3) sep,h3 Write:$D(h4) sep,h4
 Write !
 Write:$D(h1) $TR($J("",$L(h1))," ","-")
 Write:$D(h2) sep,$TR($J("",$L(h2))," ","-")
 Write:$D(h3) sep,$TR($J("",$L(h3))," ","-")
 Write:$D(h4) sep,$TR($J("",$L(h4))," ","-")
}
GetOffName(off,typ) {
 Set oid=+$O(^|"%SYS"|SYS("shm","Off",1,off,"")),typ=$G(typ,"XLT")
 If 'oid Quit $S(typ="XLT"||(typ="COL")||(typ["Case")||(typ["Accent"):"Built-in",1:"Latin1")
 Set nam=$Q(^|"%SYS"|SYS("shm","Src",0,oid)) Quit:$QS(nam,3)'=0 "" Quit:$QS(nam,4)'=oid ""
 Quit $S(typ="XLT":$QS(nam,7)_"->"_$QS(nam,8),1:$QS(nam,8))
}
GetLines() [nLines] {
 Set nLines=24
 Set st=##class(%Library.Prompt).GetNumber("Number of lines for paging (0=don't page): ",.nLines,0,200)
}
Justify(Str,Wid,Whr=1,Chr=" ") {
 Set len=$L(Str)
 If len=Wid Quit Str
 If len>Wid Quit $E(Str,1,Wid)
 Set $P(blnks,Chr,Wid+1)=""
 If Whr=1 {
	Set Str=Str_$E(blnks,len+1,Wid)
 } ElseIf Whr=2 {
	Set n=Wid-len\2,Str=$E(blnks,1,n)_Str_$E(blnks,1,n)
	If $L(Str)<Wid Set Str=Chr_Str
 } Else {
	Set Str=$E(blnks,len+1,Wid)_Str
 }
 Quit Str
}

NLSCOMP^INT^1^67214,47331
NLSCOMP   ; FULLNLS compiler
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ;%ShmObj.INC ; JLC1084 11/07/07
 Quit
Table(ttyp,fromenc,name,sref) New oid,ref,t1 Set $zt="%CompERROR" Set t1=$zh
 Set:'$d(sref) sref="^%nls"
 Kill ^IRIS.TempJ($j) Set ref=$name(@sref@("Src",ttyp,fromenc,name))
 If $e($g(@ref),1,8)="Built-in" Write:$d(^%nlsmisc("DEBUG")) "Built-in   ",ref,! Quit -1
 If $d(@ref)<10 Write:$d(^%nlsmisc("DEBUG")) "Not loaded ",ref,! Quit -2
 Do %XLT:ttyp="XLT"!(ttyp["Case")!(ttyp["Accent"),%Ident:ttyp="Ident",%Pattern:ttyp="Pattern",%XY:ttyp="XY",%COL:ttyp="COL"
 If '$g(oid) Write:$d(^%nlsmisc("DEBUG")) !,"Unable to create "_$s($g(ttyp)="XLT":"Translation",$g(ttyp)="XY":"$X/$Y Behaviour",$g(ttyp)="Ident":"Identifier",$g(ttyp)="Pattern":"Pattern Match",$g(ttyp)="UpperCase":"Upper case",$g(ttyp)="LowerCase":"Lower case",$g(ttyp)="TitleCase":"Title case",1:"Collation")_" table "_$g(fromenc)_" to "_$g(name)_"." Quit 0
 If oid=-2 Write:$d(^%nlsmisc("DEBUG")) "Not loaded ",ref,! Quit -2 ; JLC078
 Set ^SYS("shm","Src",0,oid,"%nls",ttyp,fromenc,name)=""
 Set ^SYS("shm","Src",1,"%nls",ttyp,fromenc,name,oid)=""
 New x
 For  Set x=$O(^SYS("shm","Src",1,"%nls",ttyp,fromenc,name,oid)) Quit:x=""  Kill ^(x),^SYS("shm","Src",0,x,"%nls",ttyp,fromenc,name)
 Write:$d(^%nlsmisc("DEBUG")) "Compiled   ",ref," in ",$ZH-t1," seconds",!
 Quit oid
Locale(loc,sref) New nam,num,typ,rtyp,from,to,ref,oid,charset
 Set:'$d(sref) sref="^%nls"
 Set charset=$g(@sref@("Loc",loc,0))
 If charset="" Quit 0
 Set num=0,ref=$name(@sref@("Loc",loc,1)),typ=""
 For  Set typ=$o(@ref@(typ)) Quit:typ=""  Set nam="" Do
 . For  Set nam=$o(@ref@(typ,nam)) Quit:nam=""  Do
 . . If typ="Ident"!(typ="XY")!(typ="Pattern")!(typ["Case")!(typ["Accent") Do
 . . . Set oid=$$Table(typ,charset,nam,sref) Set:oid num=num+1
 . . Else  If typ="XLT"!(typ="COL") Do
 . . . If $d(@ref@(typ,nam))<10 Set from=charset,to=nam Do
 . . . . Set oid=$$Table(typ,from,to,sref) Set:oid num=num+1
 . . . . Set oid=$$Table(typ,to,from,sref) Set:oid num=num+1
 . . . Else  Do
 . . . . Set from=$g(@ref@(typ,nam,0,0)),to=$g(@ref@(typ,nam,0,1))
 . . . . If from'="",to'="" Set oid=$$Table(typ,from,to,sref) Set:oid num=num+1
 . . . . Set from=$g(@ref@(typ,nam,1,0)),to=$g(@ref@(typ,nam,1,1))
 . . . . If from'="",to'="" Set oid=$$Table(typ,from,to,sref) Set:oid num=num+1
 Quit num
All(sref) New ttyp,fromenc,name,oid Set fromenc="",name=""
 Set:'$D(sref) sref="^%nls"
 For ttyp="Ident","XY","Pattern","XLT","COL","LowerCase","UpperCase","TitleCase","Accent" Do
 . For  Set fromenc=$o(@sref@("Src",ttyp,fromenc)) Quit:fromenc=""  Do
 . . For  Set name=$o(@sref@("Src",ttyp,fromenc,name)) Quit:name=""  Do
 . . . Set oid=$$Table(ttyp,fromenc,name,sref)
 Quit
%Ident Set oid=$$%CompBITS($name(@ref@(0))) Quit
%Pattern If '$d(@ref@(1)) Set oid=-2 Quit
 New from,rng,i,lo,patcode,pattbl,val,pref
 Set from="",patcode="",pattbl=@ref@(0),$ZT="%XLTERROR"
 Set pref=$Name(@sref@("Src","Patcode",pattbl))
 If '$d(@pref@(0)) Set oid=-2 Quit
 For {
   Set patcode=$o(@ref@(1,patcode)) Quit:patcode=""
   Set val=+$g(@pref@(0,patcode))
   For {
	 Set from=$o(@ref@(1,patcode,from)) Quit:from=""  Set rng=^(from)
	 If from<65536 {
       For i=from:1:from+rng-1 Set lo=i#256 Set ^(lo)=$zboolean(+val,+$g(^IRIS.TempJ($j,"bmp",i\256,lo)),7)
	 } Else {
       For i=from-65536:1:from-65536+rng-1 Set lo=i#1024 Set ^(lo)=$zboolean(+val,+$g(^IRIS.TempJ($j,"sur",i\1024,lo)),7)
	 }
   }
 }
 Set oid=$$%CompVAL($name(^IRIS.TempJ($j)),1) Quit
%XY New from,rng,i,dxy Set dxy="",from="",$ZT="%XLTERROR"
 For  Set dxy=$o(@ref@(0,dxy)) Quit:dxy=""  Do
 . For  Set from=$o(@ref@(0,dxy,from)) Quit:from=""  Set rng=^(from) Do
 . . For i=from:1:from+rng-1 Set ^IRIS.TempJ($j,"bmp",i\256,i#256)=dxy
 Set oid=$$%CompVAL($name(^IRIS.TempJ($j)),1) Quit
%XLT New obj,typ,act,com,val,err,tmp,byt,top,i,pag,sur
 Set err=0,$ZT="%XLTERROR",typ=@ref@(0)
 Goto %XLTNormal:typ=0,%XLTToModal:typ=1,%XLTFromModal:typ=2
%XLTERROR SET $ZT="" Do ErrMsg^NLSLOAD("Error while trying to create "_$s($g(ttyp)="XLT":"Translation",$g(ttyp)="XY":"$X/$Y Behaviour",$g(ttyp)="Ident":"Identifier",$g(ttyp)="Pattern":"Pattern Match",$g(ttyp)="UpperCase":"Upper case",$g(ttyp)="LowerCase":"Lower case",$g(ttyp)="TitleCase":"Title case",1:"Collation")_" table "_$g(fromenc)_" to "_$g(name)_".")
 Quit
%XLTNormal Set sur=0,oid=$$%CompSUB(@ref@(4),.byt,.top,.pag,.sur) Quit:oid<1
 If sur Set sur=$$%CompSUB(@ref@(4),.byt,.top,.pag,.sur) Quit:sur<1
 Set typ=+$g(^SYS("shm","Obj",oid)),obj(3)=oid,oid=0 Goto:$d(byt) %XLTPack
 Set act=+$g(@ref@(2))
 Set obj=9,com=($d(pag)=0)*2+(ttyp["Case"!(ttyp["Accent"))+1
 If act=2 Set obj(2)=+$g(@ref@(3)),val=3
 Else  Set val(0)=$$%CompStr($g(@ref@(3)),.val),obj(2)=$$Save^ShmObj(.val) Quit:'obj(2)  Set val=^SYS("shm","Obj",obj(2))
 Set obj(0)=$C(1,val,typ)
 If fromenc="UnicodeLit" Set obj(1)=$C(5,act)
 Else  If fromenc="UnicodeBig" Set obj(1)=$C(7,act)
 Else  If name="UnicodeLit" Set obj(1)=$C(4,act)
 Else  If name="UnicodeBig" Set obj(1)=$C(6,act)
 Else  If name="GB18030" Set obj(1)=$C(26,act)
 Else  If fromenc="Latin1",name="UTF8" Set obj(1)=$C(2,act)
 Else  If fromenc="UTF8",name="Latin1" Set obj(1)=$C(3,act)
 Else  Set obj(1)=$E($C(13,11,12,10),com)_$C(act)
 If sur Set obj(4)=sur,obj(0)=obj(0)_$C(^SYS("shm","Obj",obj(4)))
 Set oid=$$Save^ShmObj(.obj)
 Quit
%XLTPack Quit:'$d(top)  Quit:'top  Goto %XLTGB18030:fromenc="GB18030"
 Set obj(5)=top
 Set obj(1)=$C(14,+$g(@ref@(2)))
 Set val(0)=$$%CompStr($g(@ref@(3)),.val)
 Set obj(2)=$$Save^ShmObj(.val) Quit:'obj(2)
 Set byt(0)=byt,byt=10,obj(4)=$$Save^ShmObj(.byt) Quit:'obj(4)
 Set obj(0)=$C(1,^SYS("shm","Obj",obj(2)),typ,^SYS("shm","Obj",obj(4)),^SYS("shm","Obj",top))
 Set obj=9 Set oid=$$Save^ShmObj(.obj)
 Quit
%XLTGB18030	Set obj(4)=top
 Set obj(1)=$C(27,+$g(@ref@(2)))
 Set val(0)=$$%CompStr($g(@ref@(3)),.val)
 Set obj(2)=$$Save^ShmObj(.val) Quit:'obj(2)
 Set obj(0)=$C(1,^SYS("shm","Obj",obj(2)),typ,^SYS("shm","Obj",top))
 Set obj=9 Set oid=$$Save^ShmObj(.obj)
 Quit
%XLTToModal Set sur=0,oid=$$%CompSUB(@ref@(4),.byt,.top,.pag,.sur) Quit:oid<1
 If sur Set sur=$$%CompSUB(@ref@(4),.byt,.top,.pag,.sur) Quit:sur<1
 Set typ=+$g(^SYS("shm","Obj",oid)),act=+$g(@ref@(2))
 Set obj=9,obj(3)=oid,oid=0
 Set val(0)=$$%CompStr($g(@ref@(3)),.val)
 Set obj(2)=$$Save^ShmObj(.val) Quit:'obj(2)
 Set obj(1)=$C($S($d(pag)=0:16,1:17),act)
 Set act=$name(@sref@("Src","Mode",@ref@(5)))
 Set val(0)="",typ(0)=""
 For com=0:1:$o(@act@(1,""),-1) Do  Quit:err
 . Set val(0)=val(0)_$c(@act@(1,com))
 . Set tmp(0)=$$%CompStr(@act@(2,com),.tmp),typ(0)=typ(0)_$c(tmp)
 . Set typ(com+1)=$$Save^ShmObj(.tmp) If 'typ(com+1) Set err=1 Quit
 Quit:err
 Set val=5,obj(4)=$$Save^ShmObj(.val) Quit:'obj(4)
 Set typ=9,obj(5)=$$Save^ShmObj(.typ) Quit:'obj(5)
 Set obj(0)=$C(1,^SYS("shm","Obj",obj(2)),typ,^SYS("shm","Obj",obj(4)),^SYS("shm","Obj",obj(5)))
 If sur Set obj(6)=sur,obj(0)=obj(0)_$C(^SYS("shm","Obj",obj(6)))
 Set oid=$$Save^ShmObj(.obj)
 Quit
%XLTFromModal Set obj=9
 If '$d(@sref@("Src","Mode",@ref@(5),1)) Set oid=-2 Quit  ; JLC078
 Set val(0)=$$%CompStr($g(@ref@(3)),.val)
 Set obj(2)=$$Save^ShmObj(.val) Quit:'obj(2)
 Set obj(0)=$C(1,^SYS("shm","Obj",obj(2)),9,5,9)
 Set obj(1)=$C(15,+$g(@ref@(2)))
 Set act=$name(@sref@("Src","Mode",@ref@(5)))
 Set val(0)="",typ(0)="",com(0)=""
 For com=0:1:$o(@act@(1,""),-1) Do  Quit:err
 . Set val=+@act@(1,com),val(0)=val(0)_$c(val)
 . Set tmp(0)=$$%CompStr(@act@(2,com),.tmp),typ(0)=typ(0)_$c(tmp)
 . Set typ(com+1)=$$Save^ShmObj(.tmp) If 'typ(com+1) Set err=1 Quit
 . Kill byt,top Set tmp=$$%CompSUB(@act@(0,com),.byt,.top)
 . If 'tmp Set err=2 Quit
 . Set com(0)=com(0)_$c(^SYS("shm","Obj",tmp)),com(com+1)=tmp
 . If $d(byt) For i=1:1:256 If $A(byt,i),$A(byt,i)'=val Set err=3 Quit
 . If val=1,'$d(top),$d(byt) Set err=4 Quit
 . If val'=1,$d(top) Set err=5 Quit
 Quit:err
 Set com=9,obj(3)=$$Save^ShmObj(.com) Quit:'obj(3)
 Set val=5,obj(4)=$$Save^ShmObj(.val) Quit:'obj(4)
 Set typ=9,obj(5)=$$Save^ShmObj(.typ) Quit:'obj(5)
 Set oid=$$Save^ShmObj(.obj)
 Quit
%CompERROR Set $ZT="" Do ErrMsg^NLSLOAD("Error while trying to create "_$s($g(ttyp)="XLT":"Translation",$g(ttyp)="XY":"$X/$Y Behaviour",$g(ttyp)="Ident":"Identifier",$g(ttyp)="Pattern":"Pattern Match",$g(ttyp)="UpperCase":"Upper case",$g(ttyp)="LowerCase":"Lower case",$g(ttyp)="TitleCase":"Title case",1:"Collation")_" table "_$g(fromenc)_" to "_$g(name)_".")
 Quit 0
%CompSUB(name,byt,top,pag,sur) New (name,byt,top,pag,sur,sref)
 Set typ=@sref@("Src","SUB",name,0),sur=+$G(sur)
 If sur { Set bas=65536,siz=1024,ini=65535,end=$ZH("10FFFF") }
 Else { Set bas=0,siz=256,ini="",end=65535 }
 If '$d(@sref@("Src","SUB",name,1)) Quit -2         ; JLC078
 Goto %SUBSingle:typ=0,%SUBToCol:typ=5,%SUBFromCol:typ=6,%SUBMulti:typ=3
 Goto:$zboolean(+typ,+2,1) %SUBFromMulti
 Goto:$zboolean(+typ,+1,1) %SUBToMulti
 Write:$d(^%nlsmisc("DEBUG")) !,"Error - Table type: ",$P("Single,ToMulti,FromMulti,Multi",",",$zboolean(+typ,+3,1)+1)," not yet supported"
 Quit 0
%SUBSingle Set src=$name(@sref@("Src","SUB",name,1)),$ZT="%CompERROR"
 If 'sur {
	 Set i=$o(@src@(""),-1)
	 If i<256 Set pag=1 Quit $$%CompPAG(src)
	 If i>65535 Set sur=1
 }
 Set i=ini,dst=$name(^IRIS.TempJ($j,"SUB")) Kill @dst
 For  Set i=$o(@src@(i)) Quit:i=""||(i>end)  Set j=i-bas,@dst@(j\siz,j#siz)=@src@(i)
 Set obj=$S(sur:29,1:19),$p(obj(0),$c(0),siz+1)="",i=""
 For  Set i=$o(@dst@(i)) Quit:i=""  Set oid=$$%CompPAG($name(@dst@(i)),siz) Do:oid
 . Set obj(i+1)=oid,$e(obj(0),i+1)=$c(^SYS("shm","Obj",oid))
 If $o(obj(1))="" Set pag=1 Quit +$g(obj(1))
 Quit $$Save^ShmObj(.obj)
%SUBToMulti Set src=$name(@sref@("Src","SUB",name,1)),$ZT="%CompERROR"
 If 'sur {
	 Set i=$o(@src@(""),-1)
	 If i<256 Set pag=1 Quit $$%CompPAGMulti(src,1)
	 If i>65535 Set sur=1
 }
 Set i=ini,dst=$name(^IRIS.TempJ($j,"SUB")) Kill @dst
 For  Set i=$o(@src@(i)) Quit:i=""||(i>end)  Set j=i-bas,@dst@(j\siz,j#siz)=@src@(i)
 Set obj=$S(sur:29,1:19),$p(obj(0),$c(0),siz+1)="",i=""
 For  Set i=$o(@dst@(i)) Quit:i=""  Set oid=$$%CompPAGMulti($name(@dst@(i)),'i,siz) Do:oid
 . Set obj(i+1)=oid,$e(obj(0),i+1)=$c(^SYS("shm","Obj",oid))
 If $o(obj(1))="" Set pag=1 Quit +$g(obj(1))
 Quit $$Save^ShmObj(.obj)
%SUBFromMulti Set $ZT="%CompERROR"
 Goto %SUBFromGB18030:name="XLT-GB18030-Unicode"
 Set src=$name(@sref@("Src","SUB",name,1)),lst=$o(@src@(""),-1) zt:lst>255 "COMP"
 Set ns=$ql(sref)
 Set $p(byt,$c(0),257)="",nod=src
 For  Set nod=$q(@nod) Quit:$qs(nod,ns+2)'="SUB"  Quit:$qs(nod,ns+3)'=name  Quit:$qs(nod,ns+4)>lst  Do
 . Set i=+$qs(nod,ns+5),len=$ql(nod)-ns-4
 . If '$a(byt,i+1) Set $e(byt,i+1)=$c(len)
 . Else  zt:$a(byt,i+1)'=len "COMP"
 For i=0:1:255 Set:$a(byt,i+1)=1 myval(i)=@src@(i)
 If $d(myval) Set top=$$%CompPAGMulti("myval")
 Set $p(obj(0),$c(0),257)=""
 For i=1:1:256 Set:$a(byt,i)>1 obj(i)=$$%CompLEV($a(byt,i),$name(@src@(i-1)))
 For i=1:1:256 Set:$d(obj(i)) $e(obj(0),i)=$c(^SYS("shm","Obj",obj(i)))
 Set obj=19 Quit $$Save^ShmObj(.obj)
%SUBFromGB18030	Set ns=$ql(sref),byt=1
 Set src=$name(@sref@("Src","SUB",name,1)),lst=$o(@src@(""),-1) zt:lst>255 "COMP"
 Set nod=src,$p(obj(0),$c(0),257)=""
 For  Set nod=$q(@nod) Quit:$qs(nod,ns+2)'="SUB"  Quit:$qs(nod,ns+3)'=name  Quit:$qs(nod,ns+5)>lst  Do
 . If $ql(nod)=6 Set gb($qs(nod,5),$qs(nod,6))=@nod
 For i=1:1:256 Set:$d(gb(i-1)) obj(i)=$$%CompLEV(2,$name(gb(i-1)))
 For i=1:1:256 Set:$d(obj(i)) $e(obj(0),i)=$c(^SYS("shm","Obj",obj(i)))
 Set obj=19,oid=$$Save^ShmObj(.obj)
 Kill obj,gb
 Set nod=src,$p(obj(0),$c(0),257)=""
 For  Set nod=$q(@nod) Quit:$qs(nod,ns+2)'="SUB"  Quit:$qs(nod,ns+3)'=name  Quit:$qs(nod,ns+5)>lst  Do
 . If $ql(nod)=8 Set gb($qs(nod,5),$qs(nod,6),$qs(nod,7),$qs(nod,8))=@nod
 For i=1:1:256 Set:$d(gb(i-1)) obj(i)=$$%CompLEV(4,$name(gb(i-1)))
 For i=1:1:256 Set:$d(obj(i)) $e(obj(0),i)=$c(^SYS("shm","Obj",obj(i)))
 Set obj=19,top=$$Save^ShmObj(.obj)
 Quit oid
%CompLEV(lev,ref) Quit:lev=2 $$%CompPAK(ref) New obj,i
 For i=0:1:255 Set:$d(@ref@(i)) obj(i+1)=$$%CompLEV(lev-1,$name(@ref@(i)))
 Set $p(obj(0),$c(0),257)=""
 For i=1:1:256 Set:$d(obj(i)) $e(obj(0),i)=$c(^SYS("shm","Obj",obj(i)))
 Set obj=19 Quit $$Save^ShmObj(.obj)
%COL New obj,typ,byt,top,pag
 Set $ZT="%CompERROR",oid=$$%CompSUB(@ref@(4),.byt,.top,.pag) Quit:oid<1
 Set obj(1)=$s($d(pag):$C(13),1:$C(12))
 Set typ=+$g(^SYS("shm","Obj",oid)),obj(3)=oid Goto:$d(byt) %XLTPack
 Set obj=9
 Set obj(0)=$C(1,3,typ)
 Set obj(1)=obj(1)_$C(+$g(@ref@(2)))
 Set obj(2)=$C(0)
 Set oid=$$Save^ShmObj(.obj)
 Quit
%SUBToCol Set sbt=0 Goto %SUBCol
%SUBFromCol Set sbt=1 Goto %SUBCol
%SUBMulti Set sbt=2 Goto %SUBCol
%SUBCol New obj,oid,i,dst,out
 Set src=$name(@sref@("Src","SUB",name,1)),$ZT="%CompERROR"
 Set i="",dst=$name(^IRIS.TempJ($j,"SUB")) Kill @dst
 For  Set i=$o(@src@(i)) Quit:i=""  Merge @dst@(i\256,i#256)=@src@(i)
 Set obj=19,$p(obj(0),$c(0),257)=""
 For  Set i=$o(@dst@(i)) Quit:i=""  Set oid=$$%CompPAGCol($name(@dst@(i)),sbt) Do:oid
 . Set obj(i+1)=oid,$e(obj(0),i+1)=$c(^SYS("shm","Obj",oid))
 If $o(obj(1))=""  Set pag=1 Quit +$g(obj(1)) 
 Quit $$Save^ShmObj(.obj)
%CompPAGCol(ref,sbt) New hi,obj,oid Set hi="",obj=19,$ZT="%CompERROR"
 Set $p(obj(0),$c(0),257)=""
 For  Set hi=$o(@ref@(hi)) Quit:hi=""  Set oid=$$%CompMultiStruct($name(@ref@(hi)),sbt) Do:oid
 . Set obj(hi+1)=oid,$e(obj(0),hi+1)=$c(^SYS("shm","Obj",oid))
 Quit $$Save^ShmObj(.obj)
%CompMultiStruct(ref,sbt) New obj,nod,bas,from,to,val,i,ns,p,yes,no,opt Set $ZT="%CompERROR"
 Set ns=$ql(ref),bas=$qs(ref,ns),obj(0)=$c(2),i=2
 Set nod=ref,yes=0,no=0,opt=1 Set:$d(@nod)#10=0 nod=$q(@nod)
 For  Quit:nod=""  Quit:$qs(nod,ns)'=bas  Set to=@nod Do  Set nod=$q(@nod)
 . If to[";" Set yes=yes+1
 . Else  Set no=no+1
 . If sbt=1,ns+1<$ql(nod) Set opt=0
 . Set dis=+$p(to,";",2),to=" "_$p(to,";",1)
 . If dis ZT:+$g(out(to),1)=0 "COMP"
 . Else  ZT:$d(out(to))&(sbt'=2) "COMP"
 . Set out(to)=dis
 If 'yes,'no ZT "COMP"
 If sbt=2,yes ZT "COMP"
 If sbt=0 Set:'yes sbt=2
 If sbt=1 Do
 . If no,'yes Set sbt=2
 . If 'no,yes Set:opt sbt=3
 If sbt'=3 Do
 . Set nod=ref Set:$d(@nod)#10=0 nod=$q(@nod)
 . For  Quit:nod=""  Quit:$qs(nod,ns)'=bas  Do  Set nod=$q(@nod)
 . . Set from=$e(nod,1,$l(nod)-1),from=$p(from,",",ns+1,999)
 . . If sbt=1,@nod'[";",from[",",$p(from,",",$l(from,","))'=0 Set from=from_",0"
 . . Set val(0)=$$%CompStr(from,.val),obj(i)=$$Save^ShmObj(.val)
 . . Set obj(0)=obj(0)_$c(^SYS("shm","Obj",obj(i))),i=i+1
 Set nod=ref Set:$d(@nod)#10=0 nod=$q(@nod)
 For  Quit:nod=""  Quit:$qs(nod,ns)'=bas  Do  Set nod=$q(@nod)
 . Set to=@nod,p=$f(to,";")
 . If p Set:sbt=0 $e(to,p-1)="," Set:sbt=1!(sbt=3) to=$p(to,";",1)
 . Else  If sbt=0,to[",",$p(to,",",$l(to,","))'=0 Set to=to_",0"
 . Set val(0)=$$%CompStr(to,.val),obj(i)=$$Save^ShmObj(.val)
 . Set obj(0)=obj(0)_$c(^SYS("shm","Obj",obj(i))),i=i+1
 Set obj=9,obj(1)=$C(sbt)
 Quit $$Save^ShmObj(.obj)         
%CompPAK(ref) New myval,i Set $ZT="%CompERROR"
 For i=0:1:255 Set:$d(@ref@(i))#2 myval(i)=@ref@(i)
 Quit $$%CompPAGMulti("myval")
%CompBITS(ref) New max,from,to,bits,obj,i,val Set $ZT="%CompERROR"
 Set max=-1,from=$o(@ref@(""))
 For  Quit:from=""  Set to=^(from)+from-1 zt:to<from "COMP" Set:to>max max=to Set from=$o(^(from))
 zt:(max<0)!(max>65535) "COMP" Goto:max<256 %CBYT2BIT
 Set max=(max+2047)\2048,bits=$ZBITSTR(max*2048),from=""
 For  Set from=$o(^(from)) Quit:from=""  Set bits=$ZBITSET(bits,from+1,1,^(from))
 Set $p(max,$c(0),257)=""
 Set val=10 For i=0:1:max-1 Set val(0)=$e(bits,i*256+2,i*256+257) Do
 . Set:val(0)'=max obj(i+3)=$$Save^ShmObj(.val)
 Set obj=9,obj(0)=$C(1,3)_$C(19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19)
 Set obj(1)=$C(8,1),obj(2)=$ZLC(0)
 Quit $$Save^ShmObj(.obj)
%CBYT2BIT Set bits=$ZBITSTR(256),from=""
 For  Set from=$o(^(from)) Quit:from=""  Set bits=$ZBITSET(bits,from+1,1,^(from))
 Set obj=7,obj(0)=$C(1,3,1)
 Set obj(1)=$C(9,1),obj(2)=$ZLC(0),obj(3)=$e(bits,2,33)
 Quit $$Save^ShmObj(.obj)
%CompVAL(ref,cvt) [ttyp,fromenc,name] PUBLIC {
 Set $ZT="ERROR"
 Set pref=$name(@ref@("bmp")),hi=""
 Set $p(obj(0),$c(0),257)="",obj=19
 For {
   Set hi=$o(@pref@(hi)) Quit:hi=""
   Set oid=$$%CompPAG($name(@pref@(hi)))
   If oid { Set obj(hi+1)=oid,$e(obj(0),hi+1)=$c(^SYS("shm","Obj",oid)) }
 }
 If $o(obj(1))="" {
   Set obj(0)=$C(1,3)_$E(obj(0)),obj(3)=obj(1)
   Set obj(1)=$C(11,cvt)
 } Else {
   Set oid=$$Save^ShmObj(.obj) Kill obj
   Set obj(0)=$C(1,3,19),obj(3)=oid
   Set obj(1)=$C(10,cvt)
   If $d(@ref@("sur")) {
     Set pref=$name(@ref@("sur")),hi=""
     Set $p(sur(0),$c(0),257)="",sur=29
     For {
	   Set hi=$o(@pref@(hi)) Quit:hi=""
	   Set oid=$$%CompPAG($name(@pref@(hi)),1024)
	   If oid { Set sur(hi+1)=oid,$e(sur(0),hi+1)=$c(^SYS("shm","Obj",oid)) }
     }
     Set oid=$$Save^ShmObj(.sur),obj(0)=obj(0)_$C(29),obj(4)=oid
   }
 }
 Set obj=9,obj(2)=$ZLC(0)
 Quit $$Save^ShmObj(.obj)
ERROR Set $ZT=""
 Do ErrMsg^NLSLOAD("Error while trying to create "_$s($g(ttyp)="XLT":"Translation",$g(ttyp)="XY":"$X/$Y Behaviour",$g(ttyp)="Ident":"Identifier",$g(ttyp)="Pattern":"Pattern Match",$g(ttyp)="UpperCase":"Upper case",$g(ttyp)="LowerCase":"Lower case",$g(ttyp)="TitleCase":"Title case",1:"Collation")_" table "_$g(fromenc)_" to "_$g(name)_".")
 Quit 0
}
%CompPAG(ref,siz) New max,obj,i,lo,val
 Set max=-1,lo=$o(@ref@("")),$ZT="%CompERROR",siz=$G(siz,256)-1
 For  Quit:lo=""  Set val=^(lo),lo=$o(^(lo)) Set:val>max max=val
 zt:(max<0)!(max>$ZH("ffffffff")) "COMP" Goto %CompPAG1:max<256,%CompPAG2:max<65536
 Set val="" For i=0:1:siz Set val=val_$ZLC($g(^(i)))
 Set obj=$S(siz=255:12,1:22),obj(0)=val Quit $$Save^ShmObj(.obj)
%CompPAG2 Set val="" For i=0:1:siz Set val=val_$ZWC($g(^(i)))
 Set obj=$S(siz=255:11,1:21),obj(0)=val Quit $$Save^ShmObj(.obj)
%CompPAG1 Quit:'max 0 Set val="" For i=0:1:siz Set val=val_$C($g(^(i)))
 Set obj=$S(siz=255:10,1:20),obj(0)=val Quit $$Save^ShmObj(.obj)
%CompPAGMulti(ref,flg,siz) New min,max,minlen,maxlen,obj,tmp,i,lo,val,typ,trz
 Set flg=+$g(flg),siz=$g(siz,256),$p(tmp(0),$c(0),257)="",trz=0
 Set minlen=65536,maxlen=-1,min=$ZH("100000000"),max=-1
 Set lo=$o(@ref@(""))
 For  Quit:lo=""  zt:lo'=+lo "COMP" Set lo=+lo Do  Set lo=$o(@ref@(lo))
 . Set val=@ref@(lo)
 . Set tmp(lo+1)=$$%CompStr(val,.typ,.min,.max,.minlen,.maxlen,.trz)
 . If 'lo,val=0,flg Set trz=0 ; Don't count 0->0 translation
 . Set $e(tmp(0),lo+1)=$C(typ)
 If max>255 Goto:minlen>0 %GenPAG2:maxlen=1,%GenPAKWRD4:maxlen=2
 Else  Goto:minlen>0 %GenPAG1:maxlen=1,%GenOFF:trz,%GenPAKBYT2:maxlen=2,%GenPAKBYT4:maxlen'>4
%GenOFF For i=1:1:siz Set obj=$A(tmp(0),i) Set:$d(tmp(i)) obj(0)=tmp(i),tmp(i)=$$Save^ShmObj(.obj)
 Set tmp=$S(siz=256:19,1:29) Quit $$Save^ShmObj(.tmp)
%GenPAG1 Set val="" For i=1:1:siz Set val=val_$E($g(tmp(i))_$c(0))
 Set obj=$S(siz=256:10,1:20) Set obj(0)=val Quit $$Save^ShmObj(.obj)
%GenPAG2 Set val="" For i=1:1:siz Set val=val_$E($g(tmp(i))_$zwc(0),1,2)
 Set obj=$S(siz=256:11,1:21) Set obj(0)=val Quit $$Save^ShmObj(.obj)
%GenPAKBYT2 Set val="" For i=1:1:siz Set val=val_$E($g(tmp(i))_$zwc(0),1,2)
 Set obj=$S(siz=256:14,1:24) Set obj(0)=val Quit $$Save^ShmObj(.obj)
%GenPAKBYT4 Set val="" For i=1:1:siz Set val=val_$E($g(tmp(i))_$zlc(0),1,4)
 Set obj=$S(siz=256:15,1:25) Set obj(0)=val Quit $$Save^ShmObj(.obj)
%GenPAKWRD4 Set val="" For i=1:1:siz Do
 . If $a(tmp(0),i)=5 Set tmp(i)=$zwc($a(tmp(i),1))_$zwc($a(tmp(i),2))
 . Set val=val_$E($g(tmp(i))_$zlc(0),1,4)
 Set obj=$S(siz=256:17,1:27) Set obj(0)=val Quit $$Save^ShmObj(.obj)
%CompStr(val,typ,pmin,pmax,minlen,maxlen,trz) New i,len,chr,str,min,max
 Set len=$s($l(val):$l(val,","),1:0),str="",min=65536,max=-1
 Set pmin=+$g(pmin),pmax=+$g(pmax),minlen=+$g(minlen),maxlen=+$g(maxlen),trz=+$g(trz)
 Set:len<minlen minlen=len Set:len>maxlen maxlen=len Set typ=5 Quit:'len ""
 For i=1:1:len Set chr=$p(val,",",i) zt:chr'=+chr "COMP" Set:chr<min min=+chr Set:chr>max max=+chr
 If max>255 Set typ=6 For i=1:1:len Set str=str_$zwc($p(val,",",i))
 Else  Set typ=5 For i=1:1:len Set str=str_$c($p(val,",",i))
 Set:+$p(val,",",len)=0 trz=1
 Set:min<pmin pmin=min Set:max>pmax pmax=max Quit str

NLSLOAD^INT^1^67214,47331
NLSLOAD   ; Load FULLNLS tables, locales, defaults
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ;%ShmObj.INC ; JLC1084 11/07/07
 Quit
Locale(locale) [cfgr,load] PUBLIC {
 New cfgr,load
 Set $zt="error" Kill ^|"^^"_$zu(12)|SYS("NLS","Errors")
 Set ref=$name(^|"^^"_$zu(12)|SYS("NLS","LocalesD")),ref=$name(@ref@(locale))
 If '$D(@ref) Do LogNLSError("Missing NLS object for locale "_locale) Quit
 Set lrec=@ref
 Set msg="Loading Locale "_locale_" ("_$LG(lrec,6)_") from objects"
 Set charset=$LG(lrec,2)
 Do $zu(9,"",msg,(0>0),0)
 Set tabs=$LG(lrec,4),typ="COL"
 For i=1:1:$LL(tabs) {
		Set nam=$LI(tabs,i)
		Set load(typ,nam,0)=$$LoadTable(typ,nam,charset)
		Set load(typ,nam,1)=$$LoadTable(typ,charset,nam)
 }
 Set tabs=$LG(lrec,8),typ="Ident"
 For i=1:1:$LL(tabs) {
	Set nam=$LI(tabs,i),load(typ,nam,1)=$$LoadTable(typ,charset,nam)
 }
 Set tabs=$LG(lrec,11),typ="LowerCase"
 For i=1:1:$LL(tabs) {
	Set nam=$LI(tabs,i),load(typ,nam,1)=$$LoadTable(typ,charset,nam)
 }
 Set tabs=$LG(lrec,29),typ="UpperCase"
 For i=1:1:$LL(tabs) {
	Set nam=$LI(tabs,i),load(typ,nam,1)=$$LoadTable(typ,charset,nam)
 }
 Set tabs=$LG(lrec,17),typ="TitleCase"
 For i=1:1:$LL(tabs) {
	Set nam=$LI(tabs,i),load(typ,nam,1)=$$LoadTable(typ,charset,nam)
 }
 Set tabs=$LG(lrec,58),typ="Accent"
 For i=1:1:$LL(tabs) {
	Set nam=$LI(tabs,i),load(typ,nam,1)=$$LoadTable(typ,charset,nam)
 }
 Set tabs=$LG(lrec,13),typ="Pattern"
 For i=1:1:$LL(tabs) {
	Set nam=$LI(tabs,i),load(typ,nam,1)=$$LoadTable(typ,charset,nam)
 }
 Set tabs=$LG(lrec,31),typ="XY"
 For i=1:1:$LL(tabs) {
	Set nam=$LI(tabs,i),load(typ,nam,1)=$$LoadTable(typ,charset,nam)
 }
 Set nam=$O(@ref@("XLTTables",""),1,lst),typ="XLT",namtab=$V((0)*$ZU(40,0,25)+($ZU(40,2,103)),-2,$ZU(40,0,25))
 While (nam'="") {
	Set fr=$LI(lst,1),to=$LI(lst,2),inp=$$LoadTable(typ,fr,to)
	If 'inp,nam'=fr {
		If $ZU(127,1,namtab,fr,0) Set inp=$ZU(127,1,namtab,fr,1)
		Else  Do LogNLSError("Failed to load input side of table "_nam)
	}
	Set load(typ,nam,0)=inp
	Set fr=$LI(lst,3),to=$LI(lst,4),out=$$LoadTable(typ,fr,to)
	If 'out,nam'=to {
		If $ZU(127,1,namtab,to,0) Set out=$ZU(127,1,namtab,to,2)
		Else  Do LogNLSError("Failed to load output side of table "_nam)
	}
	Set load(typ,nam,1)=out
 	Set nam=$O(@ref@("XLTTables",nam),1,lst)
 }
 Set typ="XLT",namtab=$V((0)*$ZU(40,0,25)+($ZU(40,2,103)),-2,$ZU(40,0,25)),nam=$O(load(typ,""))
 While (nam'="") {
	Set val=+$g(load(typ,nam,0))
	Set:val val=$ZU(127,1,namtab,nam,1+0,val)
	Set val=+$g(load(typ,nam,1))
	Set:val val=$ZU(127,1,namtab,nam,1+1,val)
	Set nam=$O(load(typ,nam))
 }
 If '$zbitget($zversion(0),1) {
	If charset="Latin1" { Do $zu(191,2,0,0) }
 	Else { Do $zu(191,2,+$g(load("XLT","UnicodeLittle",0)),+$g(load("XLT","UnicodeLittle",1))) }
 }
 Set val=-1 If $E(charset,1,2)="CP" Set val=128
 Set val=$Case(charset,"Unicode":8364,"CP1251":136,"Latin9":164,:val)
 Do $zu(191,3,val)
 Do $zu(191,5,locale)
 Set typ="XY",namtab=$V((1)*$ZU(40,0,25)+($ZU(40,2,103)),-2,$ZU(40,0,25)),nam=$O(load(typ,""))
 While (nam'="") {
	Set val=+$G(load(typ,nam,1))
	Set:val val=$ZU(127,1,namtab,nam,1,val)
	Set nam=$O(load(typ,nam))
 }
 Set val=$zu(191,1,charset)
 Set typ="COL",i=0
 For tab=1:1:$zu(83) If $zu(83,tab)="0,0" Set i=tab Quit
 Set nam=$O(load(typ,""))
 While (nam'="") {
	Set enc=+$G(load(typ,nam,1)) If 'enc Set nam=$O(load(typ,nam)) Continue
	Set dec=+$G(load(typ,nam,0)) If 'dec Set nam=$O(load(typ,nam)) Continue
	Set tab=$Name(^|"^^"_$zu(12)|SYS("NLS","TablesD")),tab=$Name(@tab@("COL",charset,nam)),trec=$G(@tab)
	Set col=$LG(trec,14),lrule=$LI(col,2),grule=$LI(col,3),col=$LI(col)
	If col#128>9,col<256 {
		Set col=col#128,lrule=lrule#32,grule=grule#32
		Set tabnum=$p($zu(23,2,col),"^",3) If 'tabnum Set tabnum=i Set:i i=i+1
		If tabnum Do $zu(83,tabnum,enc,dec),$zu(23,2,col,lrule,grule,tabnum),$zu(23,2,col+128,lrule+64,grule+64,tabnum)
		Else  Do LogNLSError("No space to load collation "_nam_"; try increasing "_"iris"_".cpf:nlstab")
	}
	Set nam=$O(load(typ,nam))
 }
 Set cfgr=$Name(^|"^^"_$zu(12)|SYS("NLS","Config"))
 Set nam=$G(@cfgr@("Collation"),$LG(lrec,3))
 If nam'="" {
	 Set val=$$GetNum^COLLATE(nam)
	 If val'<0 {
	 	If val#128<10 { Set val=$zu(23,0,val) }
		ElseIf +$G(load("COL",nam,0)),+$G(load("COL",nam,1)) {
			Set tab=$Name(^|"^^"_$zu(12)|SYS("NLS","TablesD")),tab=$Name(@tab@("COL",charset,nam)),trec=$G(@tab)
			Set col=$LG(trec,14),val=+$LI(col)
 			If val#128>9,val<256 Set val=$zu(23,0,val)
		}
	}
 }
 Set base=$ZU(40,2,104)
 Do SetSysTableDef(base,0,$LG(lrec,12))
 Do SetSysTableDef(base,1,$LG(lrec,7))
 Do SetSysTableDef(base,2,$LG(lrec,28))
 Do SetSysTableDef(base,3,$LG(lrec,10))
 Do SetSysTableDef(base,4,$LG(lrec,16))
 Do SetSysTableDef(base,7,$LG(lrec,57))
 If $ZBITGET($ZVERSION(0),30) {
 	Set nam=$O(load("Pattern","U2"))
 	If nam?1"U2".E Do SetSysTableDef(base,5,nam),$ZU(191,4)
 }
 Set base=$ZU(40,2,105),namtab=$V((0)*$ZU(40,0,25)+($ZU(40,2,103)),-2,$ZU(40,0,25))
 Do SetSysIoDef(base,0,$LG(lrec,27),namtab)
 Do SetSysIoDef(base,1,$LG(lrec,23),namtab)
 Do SetSysIoDef(base,2,$LG(lrec,26),namtab)
 Do SetSysIoDef(base,3,$LG(lrec,24),namtab)
 Do SetSysIoDef(base,4,$LG(lrec,20),namtab)
 Do SetSysIoDef(base,5,$LG(lrec,22),namtab)
 Do SetSysIoDef(base,6,$LG(lrec,18),namtab)
 Do SetSysIoDef(base,7,$LG(lrec,19),namtab)
 Do SetSysIoDef(base,9,$LG(lrec,21),namtab)
 Set syscall=$LG(lrec,25)
 If ($zversion(1)=3) {
	Set unix=$P($System.Util.GetEnviron("LANG"),".",2)
 	If unix'="" Set unix=$$MapCharset^%SYS.NLS(unix)
 	If unix'="",unix'="UTF8",'$D(load("XLT",unix)) Set unix=""
 	If syscall="RAW",unix'="" Set syscall=unix
 }
 Do SetSysIoDef(base,8,syscall,namtab)
 Set base=$ZU(40,2,106),namtab=$V((1)*$ZU(40,0,25)+($ZU(40,2,103)),-2,$ZU(40,0,25))
 Do SetSysXyDef(base,0,$LG(lrec,30),namtab)
 Set usfmt='$G(@cfgr@("LocaleFormat"))
 Do $ZU(174,1,$S(usfmt:1,1:$LG(lrec,33)))
 Do $ZU(174,2,$S(usfmt:0,1:$LG(lrec,52)))
 Do $ZU(174,3,$S(usfmt:1,1:$LG(lrec,47)))
 Do $ZU(174,4,$S(usfmt:0,1:$LG(lrec,48)))
 Do $ZU(174,5,$S(usfmt:3,1:$LG(lrec,44)))
 Do $ZU(174,6,$S(usfmt:".",1:$LG(lrec,37)))
 Do $ZU(174,7,$S(usfmt:",",1:$LG(lrec,43)))
 Do $ZU(174,8,$S(usfmt:"/",1:$LG(lrec,36)))
 Do $ZU(174,9,$S(usfmt:":",1:$LG(lrec,49)))
 Do $ZU(174,10,$S(usfmt:"+",1:$LG(lrec,46)))
 Do $ZU(174,11,$S(usfmt:"-",1:$LG(lrec,39)))
 Do $ZU(174,12,$S(usfmt:"AM",1:$LG(lrec,32)))
 Do $ZU(174,13,$S(usfmt:"PM",1:$LG(lrec,45)))
 Do $ZU(174,14,$S(usfmt:"NOON",1:$LG(lrec,42)))
 Do $ZU(174,15,$S(usfmt:"MIDNIGHT",1:$LG(lrec,38)))
 Do $ZU(174,16,$S(usfmt:" Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec",1:$LG(lrec,40)))
 Do $ZU(174,17,$S(usfmt:" January February March April May June July August September October November December",1:$LG(lrec,41)))
 Do $ZU(174,18,$S(usfmt:" Sun Mon Tue Wed Thu Fri Sat",1:$LG(lrec,50)))
 Do $ZU(174,19,$S(usfmt:" Sunday Monday Tuesday Wednesday Thursday Friday Saturday",1:$LG(lrec,51)))
 Do $ZU(174,20,$S(usfmt:0,1:$LG(lrec,35)))
 Do $ZU(174,21,$S(usfmt:2980013,1:$LG(lrec,34)))
 Do $ZU(174,22,$S(usfmt:"$",1:$LG(lrec,53)))
 If $zbitget($zversion(0),1) Do $zu(69,37,+$LG(lrec,54))
 d $ZU(125,8)
 d stopWorkers^%SYS.WorkQueueMgr()
 Quit
error Do LogNLSError("Error while trying to set locale to "_locale_": "_$ZE,3  /* Fatal */)
 Quit
}
SetSysTableDef(base,idx,nam) [cfgr,load] {
 Set cfg=$G(@cfgr@($P("PatternMatch,Identifier,Uppercase,Lowercase,Titlecase,PatternMatch,Alphaup,Accent",",",idx+1))) If cfg'="" Set nam=cfg
 If $G(nam)="" Quit
 Set typ=$P("Pattern,Ident,UpperCase,LowerCase,TitleCase,Pattern,Alphaup,Accent",",",idx+1),val=+$G(load(typ,nam,1))
 If 'val,nam="Latin1" Set val=$V((idx)*$ZU(40,0,25)+($ZU(40,2,166)),-2,$ZU(40,0,25))
 If val V (idx)*$ZU(40,0,25)+(base):-2:$ZU(40,0,25):val
}
SetSysIoDef(base,idx,nam,namtab) [cfgr] {
 Set cfg=$G(@cfgr@($P("Process,IRISTerminal,OtherTerminal,File,Magtape,TCPIP,DSMDDP,DTMDCP,SystemCall,Printer",",",idx+1))) If cfg'="" Set nam=cfg
 If $G(nam)="" Quit
 Set val=$ZU(127,1,namtab,nam,0)
 If 'val,nam="RAW" Set val=$V($ZU(40,2,168),-2,$ZU(40,0,25))
 If val V (idx)*$ZU(40,0,25)+(base):-2:$ZU(40,0,25):val
}
SetSysXyDef(base,idx,nam,namtab) [cfgr] {
 Set cfg=$G(@cfgr@("XYAction")) If cfg'="" Set nam=cfg
 If $G(nam)="" Quit
 Set val=$ZU(127,1,namtab,nam,0)
 If 'val,nam="Latin1" Set val=$V($ZU(40,2,167),-2,$ZU(40,0,25))
 If val V (idx)*$ZU(40,0,25)+(base):-2:$ZU(40,0,25):val
}
LogNLSError(msg,level=2  /* Severe error */) {
	Set ref=$Name(^|"^^"_$zu(12)|SYS("NLS","Errors")),@ref@($I(@ref))=msg
	Do $zu(9,"",msg,(level>0),level)
} 
LoadTable(typ,fromenc,name) PUBLIC {
 Set ref=$Name(^SYS("shm")),off=0 Set:'$D(@ref) ref=$Name(^%shm)
 Set oid=$o(@ref@("Src",1,"%nls",typ,fromenc,name,""),-1) 
 Try {
   If oid Set off=$$Load^ShmObj(oid,ref)
 } Catch (e) {
   Do LogNLSError("Error trying to load Table("_typ_","_fromenc_","_name_")",3  /* Fatal */)
 }
 Quit off
}
Table(loc,typ,nam) PUBLIC {
 Set lref=$Name(^|"^^"_$zu(12)|SYS("NLS","LocalesD")),lref=$Name(@lref@(loc))
 If '$D(@lref,lrec) Quit "1,Missing NLS object for table "_nam
 Set charset=$LG(lrec,2),inp=0,out=0,err=0
 If typ="XLT" {
	If $D(@lref@("XLTTables",nam),lst) {
		Set namtab=$V((0)*$ZU(40,0,25)+($ZU(40,2,103)),-2,$ZU(40,0,25))
		Set inp=$$LoadTable(typ,$LI(lst,1),$LI(lst,2))
		If 'inp,nam'=$LI(lst,1) Set inp=$ZU(127,1,namtab,$LI(lst,1),1)
		If 'inp Quit "1,Could not load input table"
		Set out=$$LoadTable(typ,$LI(lst,3),$LI(lst,4))
		If 'out,nam'=$LI(lst,4) Set out=$ZU(127,1,namtab,$LI(lst,4),2)
	} Else { Quit "1,Table not defined in locale" }
 } Else {
	Set off=$Case(typ,"COL":4,"Ident":8,"LowerCase":11,"UpperCase":29,"TitleCase":17,"Pattern":13,"XY":31,"Accent":57)
	Set tabs=$LG(lrec,off),fnd=0
	For i=1:1:$LL(tabs) If $LI(tabs,i)=nam Set fnd=1 Quit
	If fnd {
		If typ="COL" Set inp=$$LoadTable(typ,nam,charset) If 'inp Quit "1,Could not load input table"
		Set out=$$LoadTable(typ,charset,nam)
	} Else { Quit "1,Table not defined in locale" }
 }
 If 'out Quit "1,Could not load output table"
 If typ="XLT" {
	Set namtab=$V((0)*$ZU(40,0,25)+($ZU(40,2,103)),-2,$ZU(40,0,25))
	Set val=$ZU(127,1,namtab,nam,1+0,inp)
 	Set val=$ZU(127,1,namtab,nam,1+1,out)
 	Set base=$ZU(40,2,105),basep=$ZU(40,1,27),val=$ZU(127,1,namtab,nam,0)
 	Set off=27_","_23_","_26_","_24_","_20_","_22_","_18_","_19_","_25_","_21
 	For i=0:1:9 {
	 	If $LG(lrec,$P(off,",",i+1))=nam { V (i)*$ZU(40,0,25)+(base):-2:$ZU(40,0,25):val V (i)*$ZU(40,0,25)+(basep):-1:$ZU(40,0,25):val }
 	}
 }
 Elseif typ="XY" {
	Set base=$ZU(40,2,106),basep=$ZU(40,1,28),namtab=$V((1)*$ZU(40,0,25)+($ZU(40,2,103)),-2,$ZU(40,0,25))
	Set val=$ZU(127,1,namtab,nam,1,out)
	Set val=$ZU(127,1,namtab,nam,0)
	If $LG(lrec,30)=nam { V (0)*$ZU(40,0,25)+(base):-2:$ZU(40,0,25):val V (0)*$ZU(40,0,25)+(basep):-1:$ZU(40,0,25):val }
 }
 Elseif typ="COL" {
	Set tabnum=0
	Set tab=$Name(^|"^^"_$zu(12)|SYS("NLS","TablesD")),tab=$Name(@tab@("COL",charset,nam)),trec=$G(@tab)
	Set col=$LG(trec,14),lrule=$LI(col,2),grule=$LI(col,3),col=+$LI(col,1)
	If col#128'>9!(col'<256) { Set err="1,Invalid collation number: "_col }
	Else {
		Set tabnum=$p($zu(23,2,col),"^",3)
		If 'tabnum For i=1:1:$zu(83) If $zu(83,i)="0,0" Set tabnum=i Quit
		If 'tabnum { Set err="1,No index available for collation table" }
		Else {
			Set val=$zu(83,tabnum,out,inp)
			Set val=$zu(23,2,col,lrule,grule,tabnum)
		}
	}
 }
 Else {
	Set base=$ZU(40,2,104),basep=$ZU(40,1,26)
	Set off=$Case(typ,"Ident":7,"LowerCase":10,"UpperCase":28,"TitleCase":16,"Pattern":12,"Accent":57,:0)
	Set idx=$Case(typ,"Ident":1,"LowerCase":3,"UpperCase":2,"TitleCase":4,"Pattern":0,"Accent":7,:0)
	If $LG(lrec,off)=nam {
		V (idx)*$ZU(40,0,25)+(base):-2:$ZU(40,0,25):out V (idx)*$ZU(40,0,25)+(basep):-1:$ZU(40,0,25):out
	}
 }
 Quit err
}
INSTALL() [Locale,Language,LocaleDir,nlsMsg,SrcDir,Update,%Log] PUBLIC {
 Set $ZT="InstallError",Unicode=$ZBitget($ZVersion(0),1)
 If '$D(Locale) Set Locale=$S(Unicode:"enuw",1:"enu8")
 If '$D(LocaleDir) Set LocaleDir=SrcDir
 If '$D(%Log) Set %Log=0
 If '$D(Update) Set Update=0
 If Update Set OldCollations=$$GetCurrentCollations()
 If 'Update Kill ^%nls,^mnls
 Kill ^%shm,^mshm,^SYS("shm")
 Set dir=##class(%Library.File).SubDirectoryName($system.Util.InstallDirectory(),"mgr",1)
 Set lib=dir_"iris"_"lib"_$E(dir,$L(dir))
 Write !,$S(Update:"Updating",1:"Installing")," locales from ",lib
 Do CopyLocales($Name(^["^^"_lib]NLS),Unicode)
 Write !,"Compiling Locale (",Locale,")",!
 Set st=##class(Config.NLS.Locales).Compile(Locale)
 If st'=1 {
	Do $System.OBJ.DisplayError(st)
 	Write !!,nlsMsg(4),Locale,nlsMsg(5)
 	If '($zversion(1)=2) Use 0 Write !!,nlsMsg(4),Locale,nlsMsg(5) Use %Log
 	Set Locale="enu"_$S(Unicode:"w",1:"8")
 	Write !,"Compiling Locale (",Locale,")",!
 	Set st=##class(Config.NLS.Locales).Compile(Locale)
 	If st'=1 Do $System.OBJ.DisplayError(st)
 }
 If $D(^%nls("Ident")) Write !,"Cannot upgrade custom locales/tables from this version"
 Set typ=$O(^%nls("Src",""))
 If Update,typ'="" Write !,"Importing custom Tables"
 While (typ'="") {
	 If typ="SUB" Set typ=$O(^%nls("Src",typ)) Continue
	 Set from=$O(^%nls("Src",typ,""))
	 While (from'="") {
		 Set to=$O(^%nls("Src",typ,from,""))
		 While (to'="") {
			 If $E(from)="y"||($E(to)="y") {
				 Write !,"   Converting Table (",typ,",",from,",",to,")"
				 Set st=##class(Config.NLS.Tables).ImportFromNls(typ,from,to,1)
				 If st'=1 Do $System.OBJ.DisplayError(st)
			 }
			 Set to=$O(^%nls("Src",typ,from,to))
		 }
		 Set from=$O(^%nls("Src",typ,from))
	 }
	 Set typ=$O(^%nls("Src",typ))
 }
 Set loc=$O(^%nls("Loc","y"))
 If Update,loc'="" Write !,"Importing custom Locales"
 While (loc'="") {
 	If $E(loc)="y" {
	 	Write !,"   Converting Locale (",loc,")"
		For tab="HTML","XML","JS","URL" Kill ^%nls("Loc",loc,1,"XLT",tab)
		Set st=##class(Config.NLS.Locales).ImportFromNls(loc)
		If st'=1 { Do $System.OBJ.DisplayError(st) }
		Else {
	 		Write !,"   Compiling Locale (",loc,")",!
			Set st=##class(Config.NLS.Locales).Compile(loc)
			If st'=1 Do $System.OBJ.DisplayError(st)
		}
 	}
 	Set loc=$O(^%nls("Loc",loc))
 }
 Kill ^%nls,^mnls
 Set loc=$G(^|"^^"_$zu(12)|%SYS("LOCALE","CURRENT"))
 If $E(loc)="y" {
	If ##class(Config.NLS.Locales).IsLoadable(loc) { Set Locale=loc }
	Else {
		Write !,"Compiling Locale (",loc,")",!
		Set st=##class(Config.NLS.Locales).Compile(loc)
		If st'=1 Do $System.OBJ.DisplayError(st)
		If ##class(Config.NLS.Locales).IsLoadable(loc) Set Locale=loc
	}
 }
 Set oLoc=##class(Config.NLS.Locales).%OpenId(Locale,,.st)
 If st'=1 Do $System.OBJ.DisplayError(st)
 Write !,"Setting current locale to ",Locale
 Set ^|"^^"_$zu(12)|%SYS("LOCALE","CURRENT")=Locale
 Set Language=$ZCVT(oLoc.LanguageAbbr,"L") Set:$E(Language,1,3)="en-" Language="en"
 If Update {
	 Set OldLanguage=$$GetDefaultLanguage^%occMessages()
	 If Unicode||("de,en,es,fi,fr,it,nl,pt-br"[OldLanguage) Set Language=OldLanguage
 }
 Write !,"Setting current language to ",Language
 Do SetDefaultLanguage^%occMessages(Language)
 If Update {
	Set NewCollations=$$GetCurrentCollations(),old=$LG(OldCollations)
	If old'="",old'=$LI(NewCollations) {
		If $LF(NewCollations,old,1) {
			Set cfgr=$Name(^|"^^"_$zu(12)|SYS("NLS","Config"))
			If '$D(@cfgr@("Collation")) Set @cfgr@("Collation")=old
			Write !,"Preserving default collation ",@cfgr@("Collation")
		} Else { Write !,"Old default collation ",old," is not available in new locale ",Locale }
	}
 }
 If 'Update {
	 Do Locale(Locale)
	 Set col=$$GetNum^COLLATE(oLoc.CollationTable)
	 Do GetCacheDirs^STU(.IRISTemp)
	 Set rc=$$ModifyDatabase^%SYS.DATABASE(IRISTemp,,,,,,,,,,,,col)
	 If rc Write !!,"Setting ","IRIS","TEMP default collation to ",oLoc.CollationTable," (",col,")"
	 Else  Write !,"Error setting default collation of ","IRIS","TEMP"
 }
 If 'Unicode,##class(Config.NLS.Locales).Exists(Locale,.oLoc) {
 	Job LoadMsgs(oLoc.CharacterSet,+$J) Do ##class(%SYSTEM.Event).Wait()
 }
 Quit
InstallError Set $ZT=""
 Write !,"Error installing NLS support: ",$ZE,!,$ZU(56,2)
}
CopyLocales(fromRef,uni) [Product] PUBLIC {
 Set all=$G(Product)="EMS"
 Set gbl=$Name(^|"^^"_$zu(12)|SYS("NLS","LocalesD")),loc=$O(@fromRef@("LocalesD",""),1,lrec)
 While (loc'="") {
	Set chs=$LG(lrec,2),copy=0
	If uni,chs="Unicode" { Set copy=1 }
	ElseIf 'uni,chs'="Unicode" { Set copy=1 }
	If copy||all {
		Set toRef=$Name(@gbl@(loc))
		Kill @toRef Merge @toRef=@fromRef@("LocalesD",loc)
		Do GetTables(toRef,.Tables)
	}
	Set loc=$O(@fromRef@("LocalesD",loc),1,lrec)
 }
 Do CopyTables(fromRef,.Tables,.SubTables)
 Do CopySubTables(fromRef,.SubTables)
}
CopyTables(fromRef,Tables,SubTables) PUBLIC {
 Set type=$O(Tables("")),gbl=$Name(^|"^^"_$zu(12)|SYS("NLS","TablesD"))
 While (type'="") {
	Set from=$O(Tables(type,""))
	While (from '="") {
		Set to=$O(Tables(type,from,""))
		While (to'="") {
			Set trec=$G(@fromRef@("TablesD",type,from,to))
			Set toRef=$Name(@gbl@(type,from,to))
			Kill @toRef Merge @toRef=@fromRef@("TablesD",type,from,to)
			If type="COL"||(type="XLT")||(type["Case")||(type["Accent") {
				Set sub=$LG(trec,4)
				Set mod=$LG(trec,7)
				If sub'="" Set SubTables(sub)=""
				If type="XLT",mod'="" {
					If '$D(Tables("Mode",mod,mod)) {
						Set Tables("Mode",mod,mod)=""
						Set toRef=$Name(@gbl@("Mode",mod,mod))
						Set libRef=$Name(@fromRef@("TablesD","Mode",mod,mod))
						Kill @toRef Merge @toRef=@libRef
						Set num=$O(@libRef@("Modes",""),1,mod)
						While (num'="") {
							Set SubTables($P(mod,":",1))=""
							Set num=$O(@libRef@("Modes",num),1,mod)
						}
					}
				}
			} ElseIf type="Pattern" {
				Set pat=$LG(trec,4)
				Set toRef=$Name(@gbl@("Patcode",pat,pat))
				Kill @toRef Merge @toRef=@fromRef@("TablesD","Patcode",pat,pat) 			
 			}
    		Set to=$O(Tables(type,from,to))
		}
		Set from=$O(Tables(type,from))
	}
	Set type=$O(Tables(type))
 }
}
CopySubTables(fromRef,SubTables) PUBLIC {
 Set sub=$O(SubTables("")),gbl=$Name(^|"^^"_$zu(12)|SYS("NLS","SubTablesD"))
 While (sub'="") {
	Set toRef=$Name(@gbl@(sub))
	Kill @toRef Merge @toRef=@fromRef@("SubTablesD",sub)
	Set sub=$O(SubTables(sub))
 }
}
GetTables(ref,Tables) PUBLIC {
 Set lrec=$G(@ref)
 Set chs=$LG(lrec,2)
 Set tabs=$LG(lrec,4),typ="COL"
 For i=1:1:$LL(tabs) Set t=$LI(tabs,i) Set Tables(typ,chs,t)="",Tables(typ,t,chs)=""
 Set tabs=$LG(lrec,8),typ="Ident"
 For i=1:1:$LL(tabs) Set t=$LI(tabs,i),Tables(typ,chs,t)=""
 Set tabs=$LG(lrec,13),typ="Pattern"
 For i=1:1:$LL(tabs) Set t=$LI(tabs,i),Tables(typ,chs,t)=""
 Set tabs=$LG(lrec,11),typ="LowerCase"
 For i=1:1:$LL(tabs) Set t=$LI(tabs,i),Tables(typ,chs,t)=""
 Set tabs=$LG(lrec,17),typ="TitleCase"
 For i=1:1:$LL(tabs) Set t=$LI(tabs,i),Tables(typ,chs,t)=""
 Set tabs=$LG(lrec,29),typ="UpperCase"
 For i=1:1:$LL(tabs) Set t=$LI(tabs,i),Tables(typ,chs,t)=""
 Set tabs=$LG(lrec,58),typ="Accent"
 For i=1:1:$LL(tabs) Set t=$LI(tabs,i),Tables(typ,chs,t)=""
 Set tabs=$LG(lrec,31),typ="XY"
 For i=1:1:$LL(tabs) Set t=$LI(tabs,i),Tables(typ,chs,t)=""
 Set typ="XLT",nam=$O(@ref@("XLTTables",""),1,tab)
 while (nam'="") {
 	Set Tables(typ,$LI(tab,1),$LI(tab,2))="",Tables(typ,$LI(tab,3),$LI(tab,4))=""
 	Set nam=$O(@ref@("XLTTables",nam),1,tab)
 }
}
LoadMsgs(chs,ppid)	PUBLIC {
 Set clib=##class(%Library.File).SubDirectoryName($system.Util.InstallDirectory(),"mgr",1)
 Set clib=##class(%Library.File).SubDirectoryName(clib,"irislib",1)
 Set stat=$zu(49,clib),rdonly=$zb(+$p(stat,",",17),4,1),$zt="lderr"
 If rdonly {
    Set rnam=$p(stat,",",25)
    If @("$zu(1,"""_clib_""","_$p(stat,",",2,12)_",2,0,0,0,0,"""_rnam_""")")
 }
 Set lgs=$LB("de","en","es","fi","fr","it","nl","pt-br"),lan=""
 Kill ^IRIS.TempCSPLang
 Set domain=$order(^%qMsg(""))
 While domain'="" {
	Set language=$order(^%qMsg(domain,""))
	While language '="" {
		If '$LF(lgs,language) Kill ^%qMsg(domain,language)
		Set language=$order(^%qMsg(domain,language))
	}
	Set domain=$order(^%qMsg(domain))
 }
 Set lgs=$Case(chs,"LatinC":"ru","CP1251":"ru",:"") Goto:lgs="" done
 Set dir=##class(%Library.File).SubDirectoryName($system.Util.InstallDirectory(),"mgr",1)
 Set dir=##class(%Library.File).SubDirectoryName(dir,"Locale",1)
 For i=1:1:$L(lgs,",") {
	 Set lan=$P(lgs,",",i)
	 Set domain=$order(^%qMsg(""))
	 While domain'="" {
		 Kill ^%qMsg(domain,lan)
		 Set domain=$order(^%qMsg(domain))
	 }
	 Do Import^%occMessages(dir_"allmessages_"_lan_".xml")
 }
done If rdonly,@("$zu(1,"""_clib_""","_$p(stat,",",2,12)_",1,0,0,0,0,"""_rnam_""")")
 If $D(ppid) Do ##class(%SYSTEM.Event).Signal(+ppid)
 Quit
lderr Set $zt="" Goto done
}
LoadALPHAUP(charset,name) PUBLIC {
	Set off=$$LoadTable("UpperCase",charset,name)
	If off V (6)*$ZU(40,0,25)+($ZU(40,2,104)):-2:$ZU(40,0,25):off
	Quit off
}
UnloadALPHAUP() PUBLIC {
	V (6)*$ZU(40,0,25)+($ZU(40,2,104)):-2:$ZU(40,0,25):0
	Quit 1
}
GetALPHAUP() PUBLIC {
	Set off=$V((6)*$ZU(40,0,25)+($ZU(40,2,104)),-2,$ZU(40,0,25))
	If 'off Quit ""
	Set oid=+$O(^|"%SYS"|SYS("shm","Off",1,off,"")) Quit:'oid ""
	Set nam=$q(^|"%SYS"|SYS("shm","Src",0,oid)) Quit:$QS(nam,3)'=0 "" Quit:$QS(nam,4)'=oid ""
	Set len=$QL(nam)
	Quit $QS(nam,len-1)_"-"_$QS(nam,len)
}
GetCurrentCollations() PUBLIC {
	Set loc=$G(^|"^^"_$zu(12)|%SYS("LOCALE","CURRENT")) If loc="" Return ""
	Set ref=$name(^|"^^"_$zu(12)|SYS("NLS","LocalesD")),ref=$name(@ref@(loc))
	Set lrec=$G(@ref) If lrec="" Return ""
	Return $LB($LG(lrec,3))_$LG(lrec,4)
}

NSPACTIVATE^INT^1^67214,47331
NSPACTIVATE ; Activate a namespace map
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ; GXLATE.INC
Activate() Public {
 s $zt="Error"
 i $v(0,-1,4)\4#2 s setbreak=1 b 0
 l +^%SYS.NAMESPACE
 k ^||NspError,^||rtab,^SYS("NSMAPSUB")
 d $zu(9,"","Activating new namespace map",0,0  /* Informational message */)
 s Status=1
 s confname=$p($zu(86),"*",2)
 d SaveImpNsp(.SaveImpNsp)
 s OldDisconnect=$zu(137,0)
 i ##class(%SYS.Namespace).Exists("%SYS")
 s OldSwitch10=$$TurnOnSwitch10(.Status)
 i '(''Status) g Exit
 d $zu(5,"^^"_$zu(12))
 d $zu(90,-1)
 d REMINI("",1)
 i +$g(^||NspError)=0 {
	d $zu(5,"%SYS")
	s ^SYS("GREDIR","NSACT")=confname
	d RestoreImpNsp(.SaveImpNsp)
	d $zu(9,"","Namespace changes have been activated",0,0  /* Informational message */)
	i '$d(^SYS("FirstRestartSinceInstall")) {
		i $d(^SYS("RebuildExtentIndex")) {
			i ^SYS("RebuildExtentIndex")'<100 {
				d RebuildExtentIndex^STU()
			} else {
				m RebuildExtentIndex=^SYS("RebuildExtentIndex")
				zk RebuildExtentIndex
				d RebuildExtentIndexNS^STU(.RebuildExtentIndex)
			}
			k ^SYS("RebuildExtentIndex")
		}
	}
 	;s f="nsperror.log"
 	;o f:"WNS" u f d ALL^%SS c f
	;s Status=$$$OK
 } else {
	d $zu(5,"^^"_$zu(12))
	d $zu(90,-1)
	zn "%SYS"
	d $zu(9,"","Error activating namespaces",1 /* broadcast and log message*/,3  /* Fatal */)
 	f i=1:1:^||NspError {
	 	s Status=$select(+Status:$$Error^%apiOBJ(5001,^||NspError(i)),1:$$AppendStatus^%occSystem(Status,$$Error^%apiOBJ(5001,^||NspError(i))))
 		d $zu(9,"",^||NspError(i),1 /* broadcast and log message*/,2  /* Severe error */)
 	}
 	k ^||NspError
 	d $zu(9,"","Activating default %SYS namespace",0,0  /* Informational message */)
 	s ErrorLogged=1
 }
Exit
 d $SYSTEM.Util.SetSwitch(10,OldSwitch10)
 i $d(OldDisconnect) d $zu(137,1) ; Unsuspend async tcpdisconnect polling
 l -^%SYS.NAMESPACE
 i $d(setbreak) b 1
 set i=$$CheckServerInitAndDisconnectNamespaces^%apiSQL()
 if '(''Status),'$G(ErrorLogged) d $zu(9,"","Activate^NSPACTIVATE: Failed with error: "_$SYSTEM.Status.GetErrorText(Status),1 /* broadcast and log message*/,2  /* Severe error */)
 q Status
Error s $zt=""
 zn "%SYS"
 s Status=$$Error^%apiOBJ(5002,$ze)
 g Exit
}
SaveImpNsp(SaveImpNsp) Private {
 s $zt="Error"
 k SaveImpNsp
 For Ns=1:1:$zu(90,0) s Nsp=$zu(90,2,0,Ns) i Nsp]"",$e(Nsp)="@" s SaveImpNsp(Nsp)=""
 q
Error q
}
RestoreImpNsp(SaveImpNsp) Private {
 s $zt="Error"
 s Nsp=$o(SaveImpNsp(""))
 while (Nsp'="") {
	s x=$$MAP^%SYS.NAMESPACE(Nsp,$p(Nsp,"@",3),,,$p(Nsp,"@",2))
	s Nsp=$o(SaveImpNsp(Nsp))
 }
 q 
Error q
}
TurnOnSwitch10(Status) Private {
 s Status=1
 s OldValue=$SYSTEM.Util.SetSwitch(10,1) ;Set switch 10 to freeze everything while we activate namespaces
 i OldValue q OldValue
 f  q:$zu(51,8)  h .01 s WaitTime=$i(WaitTime) i WaitTime=12000 s Status=$$Error^%apiOBJ(453) q
 q OldValue
}
ActivateOne(nspace) Public {
 s $zt="Error"
 i $v(0,-1,4)\4#2 s setbreak=1 b 0
 l +^%SYS.NAMESPACE
 k ^||NspError,^||rtab
 s DeleteNS='$D(^SYS("NSMAP",nspace))
 d $zu(9,"",$s(DeleteNS:"Deleting ",1:"Activating ")_nspace_" namespace map",0,0  /* Informational message */)
 s OldDisconnect=$zu(137,0)
 s OldSwitch10=$$TurnOnSwitch10(.Status)
 i '(''Status) g Exit
 s ExistingNamespace=$zu(90,10,nspace)
 D REMINI(nspace,1)
 k ^||SingleNS
 i +$g(^||NspError)=0 {
	i ExistingNamespace d $zu(90,20)
	d $zu(9,"","Namespace "_nspace_$s('$D(^SYS("NSMAP",nspace)):" has been deleted",1:" changes have been activated"),0,0  /* Informational message */)
	i 'DeleteNS,'$$skipRebuildExtentIndex^%SYS.SHARDSRV() {
		i $d(^SYS("FirstRestartSinceInstall")) {
			s ^SYS("RebuildExtentIndex",nspace)=""
			d $i(^SYS("RebuildExtentIndex"))
		} else {
			i $d(^SYS("RebuildExtentIndex")) {
				i ^SYS("RebuildExtentIndex")'<100 {
					d RebuildExtentIndex^STU()
				} else {
					m RebuildExtentIndex=^SYS("RebuildExtentIndex")
					zk RebuildExtentIndex
					d RebuildExtentIndexNS^STU(.RebuildExtentIndex)
				}
				k ^SYS("RebuildExtentIndex")
			}
		}
	}
	s Status=1
 } else {
	d $zu(9,"","Error activating namespaces "_nspace,1 /* broadcast and log message*/,3  /* Fatal */)
 	f i=1:1:^||NspError d $zu(9,"",^||NspError(i),0,0  /* Informational message */) s Status=$select(+Status:$$Error^%apiOBJ(5001,^||NspError(i)),1:$$AppendStatus^%occSystem(Status,$$Error^%apiOBJ(5001,^||NspError(i))))
 	k ^||NspError
 	d $zu(9,"","Removing failed "_nspace_" namespace",0,0  /* Informational message */)
 	d $zu(90,25,nspace)
 	s ErrorLogged=1
 }
Exit
 d $SYSTEM.Util.SetSwitch(10,OldSwitch10) ;Let processes back into the global module
 i $d(OldDisconnect) d $zu(137,1) ; Unsuspend async tcpdisconnect polling
 l -^%SYS.NAMESPACE
 i $d(setbreak) b 1
 set i=$$CheckServerInitAndDisconnectNamespaces^%apiSQL()
 if '(''Status),'$G(ErrorLogged) d $zu(9,"","ActivateOne^NSPACTIVATE: Failed with error: "_$SYSTEM.Status.GetErrorText(Status),1 /* broadcast and log message*/,2  /* Severe error */)
 q Status
Error s $zt=""
 zn "%SYS"
 s Status=$$Error^%apiOBJ(5002,$ze)
 g Exit
}
 u 0 w !,"Illegal entry point: do not call ^",$ZN," directly."
 q:$zu(41)'>2  ZTRAP "EP"
REMINI(nspace="",qflag=1)
 n errenv,QUIETLY,xx,oldnum,newnum
 s QUIETLY=$G(qflag)
 s $zt="remerr"  ;Don't want to abort startup
 i '$d(@$NAME(^SYS("NSMAP"))) q  ;Silently do nothing if none defined
 s ^NET(0,"GREDST")=2   ; we're doing the 2nd step
 s $ze=""				; Important to set this to ""
 if nspace="" {
	 d all($NAME(^SYS("NSMAP")))
	 if $g(errenv)="" d slm($NAME(^SYS("NSMAP")))
 } elseif '$D(^SYS("NSMAP",nspace)) {
	 if $zu(90,25,nspace) d errlog("Error deleting namespace "_nspace)
 } else {
	 s ^||SingleNS=1
	 s oldnum=$s($zu(90,10,nspace):$zu(90,0,nspace),1:0)
	 d:oldnum $zu(90,26,nspace,0)
	 s newnum=$$OneNSGlobal($NAME(^SYS("NSMAP")),nspace)
	 i $g(errenv)'="" {
		 d errlog(errenv)
	 } else {
		 d OneNSSubscript($NAME(^SYS("NSMAP")),nspace)
	 }
 }
 k ^||rtab
remerr s $zt="" i $ze'="" d
 . i $g(^||SingleNS) s ^||SingleNS=2  ; For single NS, we need to restart with all NS.
 . d errlog($ZE_" occurred -- aborting redirection setup.")
 . r:'$g(QUIETLY) "Press RETURN ... ",r:30,!
 k ^NET(0,"GREDST")
 q
errlog(erm) ;
 i '$D(^||NspError) s ^||NspError=0
 i $G(qflag) s ^||NspError=^||NspError+1,^||NspError(^||NspError)=$E(erm,1,70)
 e  d $zu(9,"",erm,(1>0),1) s ^||NspError=1
 q
all(tran) 
 s nspace="" f  s nspace=$o(@tran@(nspace)) q:nspace=""  s xx=$$OneNSGlobal(tran,nspace) q:$g(errenv)'=""
 i $g(errenv)'="" d errlog(errenv),errlog("Redirection setup is aborted")        
 q
OneNSGlobal(tran,nspace) ;
 n db,bardef,barsys,gindgbl,gindsrtn,pat,x,totnum
 s db=$g(@tran@(nspace,"defglbloc"))
 s bardef=db,barsys=$g(@tran@(nspace,"defsysrtn"))
 s gindgbl=$$addenv(bardef) i gindgbl<0 s errenv=$p(gindgbl,-1,2) q +errenv
 s gindsrtn=$$addenv(barsys) i gindsrtn<0 s errenv=$p(gindsrtn,-1,2) q +errenv
 i $ZU(90,3,0,nspace,gindgbl,gindsrtn)<0 s errenv="Error adding namespace "_nspace q -1
 s totnum=0
 s pat="" f  s pat=$o(@tran@(nspace,"globmap",pat)) q:pat=""  d  q:x<0
 . s x=$$install(db,nspace,pat,tran)
 . i x<0 d  q
 . . s errenv="Error adding mapping for namespace "_nspace
 . . d errlog("ERROR processing namespace "_nspace_", pattern "_pat_": ")
 . . d errlog("    "_$p(x," ",2,$L(x," ")))
 . . d errlog("Redirection setup is aborted ")
 . . i $g(^||SingleNS) s ^||SingleNS=2  ; For signle NS, we need to restart with all NS.
 . . i +$G(^NET(0,"GREDST")) d
 . . . r:'$g(QUIETLY) !,"Press RETURN to continue ...",r:30
 . s totnum=totnum+1
 q totnum
install(db,nsp,pat,tran) 
 n before,ii1,li1,ri1,ii2,li2,ri2,result,fakeloc
 ;s fakeloc="|""^^""|"
 n tmp
 s $zt="tranerr"
 s (ri1,ri2)=0
 i $g(@tran@(nsp,"globmap",pat,1,"I"))="|""^^""|" s (ii1,ri1,li1)=0 g cont1  ; sorry for 'goto', it's just a few lines ahead
 s ii1=$s($g(@tran@(nsp,"globmap",pat,1,"I"))=""||((db["^^")&&(db=$g(@tran@(nsp,"globmap",pat,1,"I")))):0,1:$$addenv($g(@tran@(nsp,"globmap",pat,1,"I"))))
 i ii1<0 q ii1
 s li1=$s($g(@tran@(nsp,"globmap",pat,1,"L"))=""||((db["^^")&&(db=$g(@tran@(nsp,"globmap",pat,1,"L")))):0,1:$$addenv($g(@tran@(nsp,"globmap",pat,1,"L"))))
 i li1<0 q li1
cont1 i $g(@tran@(nsp,"globmap",pat,2,"I"))="|""^^""|" s (ii2,ri2,li2)=0 g cont2
 s ii2=$s($g(@tran@(nsp,"globmap",pat,2,"I"))=""||((db["^^")&&(db=$g(@tran@(nsp,"globmap",pat,2,"I")))):0,1:$$addenv($g(@tran@(nsp,"globmap",pat,2,"I"))))
 i ii2<0 q ii2
 s li2=$s($g(@tran@(nsp,"globmap",pat,2,"L"))=""||((db["^^")&&(db=$g(@tran@(nsp,"globmap",pat,2,"L")))):0,1:$$addenv($g(@tran@(nsp,"globmap",pat,2,"L"))))
 i li2<0 q li2
cont2 ;
 n c s c=","
 i $d(@tran@(nsp,"submap",pat)) d
 . new sub
 . f sub="ri1","ii1","li1","ri2","ii2","li2" s ^||rtab(nsp,pat,sub)=@sub
 q $ZU(90,0,nsp,pat,ri1,ii1,li1,ri2,ii2,li2)
tranerr q "-1 "_$ze
envindex(db,env) 
 s $zt="errindex"
 i env="" q 0
 i db["^^",db=env q 0
 q $$addenv(env)
errindex q "-1 "_$ze
addenv(env) ;Add environment E if not there, return index, -1 if error
 n found,dset,ret s $zt="NoZu9024"
 s ret=$zu(90,24,env),dset=$p(ret,"^",3),found=+ret
 i dset'="" s ^SYS("GREDIR","GINDTARG",dset,$p(ret,"^",4))=$p(ret,"^",1,2)
 S ^SYS("GREDIR","GINDTAB",found)=$p(ret,"^",2,4)
 i found>$g(^SYS("GREDIR","GINDTAB")) s ^SYS("GREDIR","GINDTAB")=found  
 q found
NoZu9024
 n remsysnum
 s $ze=""
 s dset=$$ENVDSET^%SYS.GXLINFO(env)
 s dir=$$ENVDIR^%SYS.GXLINFO(env)
 s remsysnum=$S(dset="":0,1:$ZU(63,0,dset))
 i 'remsysnum s dir=$ZU(12,dir)   ; canonize local directory names
 s found=$ZU(90,8,remsysnum,dir)
 i found'>0 s found=$ZU(90,9,remsysnum,dir)
 i +found<0 q found  ; ADDPATH returned an error
 s $ZT=""
 i dset'="" d   
 . s ^SYS("GREDIR","GINDTARG",dset,dir)=+found_"^"_remsysnum
 S ^SYS("GREDIR","GINDTAB",+found)=remsysnum_"^"_dset_"^"_dir
 i (+found)>$g(^SYS("GREDIR","GINDTAB")) s ^SYS("GREDIR","GINDTAB")=+found  
 q found
slm(tran) ; install subscript level mapping
 new nspace,defloc,coltn
 s nspace="" f  s nspace=$o(@tran@(nspace)) q:nspace=""  d OneNSSubscript(tran,nspace)
 q
OneNSSubscript(tran,nspace)
 n coltn,defloc,pat,x
 s pat="" f  s pat=$o(@tran@(nspace,"submap",pat)) q:pat=""  d  q:x<0
 . s defloc=$g(@tran@(nspace,"globmap",pat,1,"I"))
 . i defloc="" s defloc=$g(@tran@(nspace,"defglbloc"))
 . s coltn=$p(@tran@(nspace,"submap",pat),$c(1))
 . s x=$$instslm(nspace,pat,tran,defloc,coltn)
 . i x<0 d  q
 . . d errlog("ERROR processing namespace "_nspace_",subscript mapping for pattern "_pat_": ")
 . . d errlog("    "_$p(x," ",2,$L(x," ")))
 . . d errlog("Redirection setup is aborted ")
 . . i $g(^||SingleNS) s ^||SingleNS=2  ; For signle NS, we need to restart with all NS.
 . . i +$G(^NET(0,"GREDST")) d
 . . . r:'$g(QUIETLY) !,"Press RETURN to continue ...",r:30
 q
instslm(nsp,pat,tran,defloc,coltn) ;
 new keyoff,destoff,reploff,keystr,deststr,keyval
 new tmp,num,mes,string,ex,fakerep,slmkey,kk,tkey,restkey,ckey
 s $zt="tranerr"
 s num="",keystr="",deststr="",mes=""
 s fakerep=1 ; all fake replications flag
 f num=1:1 {
	 q:'$d(@tran@(nsp,"submap",pat,num),kk)
	 if ($l(kk)>480) {
		 s tkk=$e(kk,1,480),restkk=$e(kk,481,*)
		 i '$d(^SYS("NSMAPSUB",coltn,tkk)) {
pnew		 s ex="s keyval=$zu(90,11,coltn,"_$P(kk,$C(1)_"*next")_")" x ex
			 i keyval=0 s mes="-1 Not enough room to store subscript for SLM" q
			 i kk[($c(1)_"*next") s keyval=$zu(90,19,keyval) i keyval=0 s mes="-1 Not enough room to store subscript(next) for SLM" q
			 s ^SYS("NSMAPSUB",coltn,tkk,keyval)=restkk
		 } else {
			 s keyval="" f  s keyval=$o(^SYS("NSMAPSUB",coltn,tkk,keyval),1,ckk) q:keyval=""  q:restkk=ckk
			 if keyval="" g pnew
		 }
	 } elseif $d(^SYS("NSMAPSUB",coltn,kk),keyval)'=1 {
		 s ex="s keyval=$zu(90,11,coltn,"_$P(kk,$C(1)_"*next")_")" x ex
		 i keyval=0 s mes="-1 Not enough room to store subscript for SLM" q
		 i kk[($c(1)_"*next") s keyval=$zu(90,19,keyval) i keyval=0 s mes="-1 Not enough room to store subscript(next) for SLM" q
		 s ^SYS("NSMAPSUB",coltn,kk)=keyval
	 }
	 s keystr=keystr_$s(num>1:",",1:"")_keyval
	 i @tran@(nsp,"submap",pat,num,"I")="|""^^""|" {
		 s mes=0
	 } else {
		 s mes=$g(@tran@(nsp,"submap",pat,num,"I")),mes=$s(mes=""||((defloc["^^")&&(defloc=mes)):0,1:$$addenv(mes)) q:mes<0
	 }
	 s deststr=deststr_$s(num>1:",",1:"")_mes
 }
 q:mes<0 mes
 s num=num-1
 if ($l(keystr)>400) {
	 s tkey=$e(keystr,1,400),restkey=$e(keystr,401,*)
	 i '$d(^SYS("NSMAPSUB","key",tkey)) {
cnew	 s keyoff=$zu(90,12,keystr)
		 i keyoff=0 q "-1 Not enough room to store subscript pattern for SLM"
		 s ^SYS("NSMAPSUB","key",tkey,keyoff)=restkey
	 } else {
		 s keyoff="" f  s keyoff=$o(^SYS("NSMAPSUB","key",tkey,keyoff),1,ckey) q:keyoff=""  q:restkey=ckey
		 if keyoff="" g cnew
	 }
 } elseif $d(^SYS("NSMAPSUB","key",keystr),keyoff)'=1 {
	 s keyoff=$zu(90,12,keystr)
	 i keyoff=0 q "-1 Not enough room to store subscript pattern for SLM"
	 s ^SYS("NSMAPSUB","key",keystr)=keyoff
 }
 if ($l(deststr)>400) {
	 s tkey=$e(deststr,1,400),restkey=$e(deststr,401,*)
	 i '$d(^SYS("NSMAPSUB","dest",tkey)) {
dnew	 s destoff=$zu(90,13,deststr)
		 i destoff=0 q "-1 Not enough room to store destination pattern for SLM"
		 s ^SYS("NSMAPSUB","dest",tkey,destoff)=restkey
	 } else {
		 s destoff="" f  s destoff=$o(^SYS("NSMAPSUB","dest",tkey,destoff),1,ckey) q:destoff=""  q:restkey=ckey
		 if destoff="" g dnew
	 }
 } elseif $d(^SYS("NSMAPSUB","dest",deststr),destoff)'=1 {
	 s destoff=$zu(90,13,deststr)
	 i destoff=0 q "-1 Not enough room to store destination pattern for SLM"
	 s ^SYS("NSMAPSUB","dest",deststr)=destoff
 }
 s reploff=0  ; all default replications
 i '$d(^SYS("NSMAPSUB","slmkey",coltn,keyoff,destoff),slmkey) {
	 s slmkey=$zu(90,15,coltn,num,keyoff,destoff,reploff)
	 i slmkey=0 q "-1 Not enough room to store SLM entry"
	 s ^SYS("NSMAPSUB","slmkey",coltn,keyoff,destoff)=slmkey
 }
 q $zu(90,0,nsp,pat,slmkey,^||rtab(nsp,pat,"ri1"),^||rtab(nsp,pat,"ii1"),^||rtab(nsp,pat,"li1"),^||rtab(nsp,pat,"ri2"),^||rtab(nsp,pat,"ii2"),^||rtab(nsp,pat,"li2"))

NSPMAP^INT^1^67214,47331
NSPMAP ; create a namespace ;$Change: 7440104 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	; Revision: $Id: //iris/2024.1.3/databases/sys/rtn/sysconfig/nspmap.mac#1 $
 ; GXLATE.INC
assign(nsname,array,loclist) Public {
 s numl=""
 f  {
	s numl=$o(array(numl)) q:numl=""
	s numr=$o(array(numl))
	i numr="" d doone(nsname,.loclist,array(numl,"name"),array(numl,"loc"),array(numl,"loc"))
	i numr]"",array(numr,"name")'=array(numl,"name") d doone(nsname,.loclist,array(numl,"name"),array(numl,"loc"),array(numl,"loc"))
	i numr]"",array(numr,"name")=array(numl,"name") {
		d doone(nsname,.loclist,array(numl,"name"),array(numl,"loc"),array(numr,"loc"))
		k array(numl) s numl=numr
	}
	k array(numl)
 }
 q
}
doone(nsname,loclist,name,ind1,ind2) Private {
 k ^SYS("NSMAP",nsname,"globmap",name)
 s loc1=$g(loclist(ind1)),loc2=$g(loclist(ind2))
 s:$p(loc1,$c(1))'="" ^SYS("NSMAP",nsname,"globmap",name,1,"I")=$p(loc1,$c(1))
 s:$p(loc1,$c(1),2)'="" ^SYS("NSMAP",nsname,"globmap",name,1,"L")=$p(loc1,$c(1),2)
 s:$p(loc2,$c(1))'="" ^SYS("NSMAP",nsname,"globmap",name,2,"I")=$p(loc2,$c(1))
 s:$p(loc2,$c(1),2)'="" ^SYS("NSMAP",nsname,"globmap",name,2,"L")=$p(loc2,$c(1),2)
 q
}
oneglob(globname,Location,LockLocation,slmdef,pairs,loclist) Public { ;
 s impl=Location_$c(1)_LockLocation
 i '$d(loclist(impl),curloc) {
 	s curloc=$i(loclist)
 	s loclist(impl)=loclist
 	s loclist(loclist)=impl
 }
 i slmdef'="" s gn=globname,globname=slmdef
 e  s gn=0
 i $d(pairs(gn,"key",globname),i) {
	 s pairs(gn,i,1,"loc")=curloc
	 q
 }
 i $e(globname)'="(" {
	s range=$s($l(globname,":")=2:1,1:0),glob2=""
	s glob1=$p(globname,":"),wild1=$s(glob1["*":1,1:0)
	s glob1=$p(glob1,"*")
	i range {
		s glob2=$p(globname,":",2),wild2=$s(glob2["*":1,1:0)
		s glob2=$p(glob2,"*")
	}
	s:range wild1=1
	i glob1="" s glob1="%",glob2="",wild1=0,wild2=0,range=1
 }  else {
	s range=0,wild1=0,wild2=0,glob2="",glob2end=0
	i globname'["):" {
		s glob1=$e(globname,2,$l(globname)-1)
	} else {
 		f jj=1:1:$l(globname,"):")-1 s glob1=$p(globname,"):",1,jj) s:'($l(glob1)-$l($tr(glob1,""""))#2) range=1 q:range=1
		 i range {
			s glob2=$p(globname,"):",jj+1,$l(globname,"):"))
			i ($zcvt(glob2,"u")="END") {
				s glob2=""
			} else {
				i ($E($zcvt(glob2,"u"),*-4,*)=",END)") {
					s glob2end=1
		 			s glob2=$e(glob2,2,*-5)  ; strip of leading "("
				} else {
					s glob2=$e(glob2,2,$l(glob2)-1)
				}
			}
		 	s glob1=$e(glob1,2,$l(glob1))
		 }
	}
	s glob1=$$actref(glob1),glob2=$$actref(glob2)
	if glob2end s glob2=glob2_$c(1)_"*next"
 }
 s pairs=$i(pairs(gn))
 s pairs(gn,"key",globname)=pairs
 s pairs(gn,pairs,2,"loc")=1
 i 'range&wild1 {
	s pairs(gn,pairs,1,"name")=glob1,pairs(gn,pairs,1,"loc")=curloc,pairs(gn,pairs,2,"name")=$$globnext(glob1)
 } else {
	i 'range&('wild1) {
		s pairs(gn,pairs,1,"name")=glob1,pairs(gn,pairs,1,"loc")=curloc,pairs(gn,pairs,2,"name")=glob1
	} else {
		i range&('wild2) {
			s pairs(gn,pairs,1,"name")=glob1,pairs(gn,pairs,1,"loc")=curloc,pairs(gn,pairs,2,"name")=glob2
		} else {
			s pairs(gn,pairs,1,"name")=glob1,pairs(gn,pairs,1,"loc")=curloc,pairs(gn,pairs,2,"name")=$$globnext(glob2)
 		}
	}
 }
 i (slmdef'=""),(globname'["(") {  
	f jj=1,2 i pairs(gn,pairs,jj,"name")]"" s pairs(gn,pairs,jj,"name")=""""_pairs(gn,pairs,jj,"name")_""""
 }
 q
}
globnext(name) Public {
 f i=255:-1:1 i $zname($c(i),3) s LastValidChar=$c(i) q
 f jj=$l(name):-1:1 i $e(name,jj)'=LastValidChar q
 s find="zZ9&."
 s find1="aA./"
 s LastValidChar="{"
 f i=128:1:255 {
	 i ($zname($c(i+1),3)=0),($zname($c(i),3)=1) {
		s find=$c(i)_find
	 }
 }
 f i=128:1:255 {
 	i ($zname($c(i),3)=0) {
	 	continue
 	} else {
 		s LastValidChar=$c(i)
 	}
	i ($zname($c(i-1),3)=0) s find1=$c(i)_find1
 }
 s next=$f(find,$e(name,jj))
 i next s next=$e(name,1,jj-1)_$e(" "_LastValidChar_find1,next)
 e  s next=$e(name,1,jj-1)_$c($a(name,jj)+1)
 i next=" " s next=name ; handle $c(255) return itself
 q next
}
updmarg(nsname,globname,col,rmap,pairs,array) [pairs] Public {
 K array
 s subm=($l(col)>0),novlp=(subm&&('rmap))
 s $zt="Err",endon=""
 s gn=$s(subm:globname,1:0),pairs=pairs(gn)
 i pairs(gn,1,2,"name")'=""&&($zu(90,23,pairs(gn,1,1,"name"),pairs(gn,1,2,"name"),$s(col="":-1,1:col))) {
	 d maperr(nsname,globname,1,"endpoint does not follow starting point",.pairs,gn)
 } elseif pairs(gn,1,1,"name")=pairs(gn,1,2,"name") {
	 i subm s pairs(gn,1,2,"name")=pairs(gn,1,2,"name")_$c(1)_"*next"
	 s array(8)="pairs("""_gn_""","_1_","_1/*"pairs(1,1)"*/_")",array(8,"map")=1,array(8,"name")=pairs(gn,1,1/*"pairs(1,1)"*/,"name"),array(8,"loc")=pairs(gn,1,1/*"pairs(1,1)"*/,"loc")
	 s array(2*8)="pairs("""_gn_""","_1_","_2/*"pairs(1,2)"*/_")",array(2*8,"map")=0,array(2*8,"name")=pairs(gn,1,2/*"pairs(1,2)"*/,"name"),array(2*8,"loc")=pairs(gn,1,2/*"pairs(1,2)"*/,"loc")
 } else {
	 s array(8)="pairs("""_gn_""","_1_","_1/*"pairs(1,1)"*/_")",array(8,"map")=1,array(8,"name")=pairs(gn,1,1/*"pairs(1,1)"*/,"name"),array(8,"loc")=pairs(gn,1,1/*"pairs(1,1)"*/,"loc") i pairs(gn,1,2,"name")'="" s array(2*8)="pairs("""_gn_""","_1_","_2/*"pairs(1,2)"*/_")",array(2*8,"map")=0,array(2*8,"name")=pairs(gn,1,2/*"pairs(1,2)"*/,"name"),array(2*8,"loc")=pairs(gn,1,2/*"pairs(1,2)"*/,"loc")
	 if pairs(gn,1,2,"name")="" s endon=1
 }
 q:pairs=1
 s INT="",jj=1
errrepeat
 s $zt="ReIndex"
 For  {
	 Quit:$i(jj)>pairs
	 k maprecov
	 S (FIRSTL,FIRSTR)=""
	 i pairs(gn,jj,2,"name")'=""&&($zu(90,23,pairs(gn,jj,1,"name"),pairs(gn,jj,2,"name"),$s(col="":-1,1:col))) {
		 d maperr(nsname,globname,jj,"endpoint does not follow starting point",.pairs,gn)  ;JAO922
		 Continue
	 }
	 i subm&&(pairs(gn,jj,1,"name")=pairs(gn,jj,2,"name")) s pairs(gn,jj,2,"name")=pairs(gn,jj,2,"name")_$c(1)_"*next"
	 For  {
		 s INT=$O(array(INT)) Q:INT=""
		 S POINT=@(array(INT))@("name")
		 I FIRSTL=""&&($zu(90,23,POINT,pairs(gn,jj,1,"name"),$s(col="":-1,1:col))) S FIRSTL=INT
		 I pairs(gn,jj,2,"name")]""&&(FIRSTR="")&&($zu(90,23,POINT,pairs(gn,jj,2,"name"),$s(col="":-1,1:col))) S FIRSTR=INT
		 if FIRSTL]""&&(pairs(gn,jj,2,"name")=""!(FIRSTR]"")) s INT="" Q
	 }
	 S FIRSTL=$O(array(FIRSTL),-1),FIRSTR=$O(array(FIRSTR),-1)
	 S SET="",samestart=0,begedge="",oldpair=""
	 I FIRSTL="" {
		 S NUM=$O(array(""))-(2*8)
		 s array(NUM)="pairs("""_gn_""","_jj_","_1/*"pairs("_jj_",1)"*/_")",array(NUM,"map")=1,array(NUM,"name")=pairs(gn,jj,1/*"pairs("_jj_",1)"*/,"name"),array(NUM,"loc")=pairs(gn,jj,1/*"pairs("_jj_",1)"*/,"loc")
		 I FIRSTR="" {
			 s array(NUM+8)="pairs("""_gn_""","_jj_","_2/*"pairs("_jj_",2)"*/_")",array(NUM+8,"map")=0,array(NUM+8,"name")=pairs(gn,jj,2/*"pairs("_jj_",2)"*/,"name"),array(NUM+8,"loc")=pairs(gn,jj,2/*"pairs("_jj_",2)"*/,"loc")
			 Continue
		 }
		 s LSET=NUM
	 } else {
		 I (@array(FIRSTL)@("name")=pairs(gn,jj,1,"name"))&&($p($p(array(FIRSTL),",",3),")")=1)&&novlp {
			 if @array(FIRSTR)@("name")=pairs(gn,jj,2,"name")&&($p(array(FIRSTL),",",2)=$p(array(FIRSTR),",",2)) {
				 S (@array(FIRSTL)@("loc"),array(FIRSTL,"loc"))=pairs(gn,jj,1,"loc")
				 Continue
			 }
			 d maperr(nsname,globname,jj,"leading subscript same as a prior mapping",.pairs,gn)
			 Continue
		 }
		 i (FIRSTR<FIRSTL) {
			 d maperr(nsname,globname,jj,"endpoint precedes start of range (internal error)",.pairs,gn)
			 Continue
		 }
		 s oldloc=array(FIRSTL,"loc"),oldmap=array(FIRSTL,"map")
		 I @array(FIRSTL)@("name")=pairs(gn,jj,1,"name") {
			 s oldpair=array(FIRSTL)
			 if ($p($p(array(FIRSTL),",",3),")")=1) {
				 s begedge=$p(array(FIRSTL),",",2)
				 S (@array(FIRSTL)@("loc"),array(FIRSTL,"loc"))=pairs(gn,jj,1,"loc")
			 } else {
				 S @array(FIRSTL)@("delete")="pairs("""_gn_""","_jj_","_1_")"
				 s array(FIRSTL)="pairs("""_gn_""","_jj_","_1_")"
				 s array(FIRSTL,"loc")=pairs(gn,jj,1,"loc")
			 }
			 S array(FIRSTL,"map")=1
			 s maprecov=FIRSTL ;this is the only array element to recover in reindex
			 ;SML1136
			 s LSET=FIRSTL,samestart=1
			 if pairs(gn,jj,1,"name")=pairs(gn,jj,2,"name") {
				 s nf=$o(array(FIRSTL),-1,nd)
				 if nf]""&&(@nd@("name")=pairs(gn,jj,1,"name")) {
					 S (@array(nf)@("loc"),array(nf,"loc"))=pairs(gn,jj,1,"loc")
					 S (@array(FIRSTL)@("loc"),array(FIRSTL,"loc"))=oldloc
					 S array(FIRSTL,"map")=oldmap
					 Continue
				 }
			 }
		 } else {
			 S NEXT=$O(array(FIRSTL))
			 s NUM=$$GetMapIdx(.array,NEXT,FIRSTL,1)
			 ztrap:NUM="" "INDX"
			 s array(NUM)="pairs("""_gn_""","_jj_","_1/*"pairs("_jj_",1)"*/_")",array(NUM,"map")=1,array(NUM,"name")=pairs(gn,jj,1/*"pairs("_jj_",1)"*/,"name"),array(NUM,"loc")=pairs(gn,jj,1/*"pairs("_jj_",1)"*/,"loc")
			 S (LSET,SET)=NUM
		 }
	 }
	 I FIRSTR=FIRSTL {
		 i pairs(gn,jj,2,"name")="" {
			 if endon'="" g overlap
			 s endon=jj
			 s pairs(gn,jj,2,"delete")=""
			 Continue
		 }
		 S LSET=$S(SET]"":SET,1:FIRSTL)
		 S NEXT=$O(array(LSET))
		 s NUM=$$GetMapIdx(.array,NEXT,LSET,2)
		 ztrap:NUM="" "INDX"
		 s array(NUM)="pairs("""_gn_""","_jj_","_2/*"pairs("_jj_",2)"*/_")",array(NUM,"map")=0,array(NUM,"name")=pairs(gn,jj,2/*"pairs("_jj_",2)"*/,"name"),array(NUM,"loc")=pairs(gn,jj,2/*"pairs("_jj_",2)"*/,"loc")
		 s array(NUM,"loc")=oldloc,array(NUM,"map")=oldmap
		 if begedge'="" {
			 s array(NUM,"begedge")=begedge
			 s:$G(array(FIRSTL,"edgend"))'="END" x=$i(array(FIRSTL,"edgend"))
		 }
		 Continue
	 }
	 s nf=$O(array(LSET),1,nd),ned=array(FIRSTR),sameend=(@ned@("name")=pairs(gn,jj,2,"name"))
	 s edgeok=('novlp)&&((sameend&&(nf=FIRSTR))||samestart)
	 if ($p($p(nd,",",3),")")'=1&&('edgeok))||('$s($p($p(ned,",",3),")")=1:sameend,1:('sameend||'novlp))) {
overlap	 I FIRSTL=""||(@array(FIRSTL)@("name")'=pairs(gn,jj,1,"name")) {
			 k:LSET'="" array(LSET)
		 } else {
			 s:LSET'="" array(LSET,"loc")=oldloc,array(LSET,"map")=oldmap
		 }
		 d maperr(nsname,globname,jj,"mapping overlaps with a prior mapping",.pairs,gn)
		 Continue
	 }
	 I pairs(gn,jj,2,"name")=""||(pairs(gn,jj,2,"name")'=@array(FIRSTR)@("name")) {
		 i pairs(gn,jj,2,"name")="" {
			 if endon'="" g overlap
			 s endon=jj
			 s pairs(gn,jj,2,"delete")=""
			 S (@array(FIRSTR)@("loc"),array(FIRSTR,"loc"))=pairs(gn,jj,1,"loc")
			 s array(FIRSTR,"map")=1
			 if begedge'="" {
				 S (@array(FIRSTL)@("loc"),array(FIRSTL,"loc"))=oldloc
				 s array(FIRSTL,"edgend")="END"
			 }
		 } else {
			 S NEXT=$O(array(FIRSTR))
			 s NUM=$$GetMapIdx(.array,NEXT,FIRSTR,1) 
			 ztrap:NUM="" "INDX"
			 s array(NUM)="pairs("""_gn_""","_jj_","_2/*"pairs("_jj_",2)"*/_")",array(NUM,"map")=0,array(NUM,"name")=pairs(gn,jj,2/*"pairs("_jj_",2)"*/,"name"),array(NUM,"loc")=pairs(gn,jj,2/*"pairs("_jj_",2)"*/,"loc")
			 s oldmapx=array(FIRSTR,"map"),oldlocx=array(FIRSTR,"loc")
			 S (@array(FIRSTR)@("loc"),array(FIRSTR,"loc"))=pairs(gn,jj,1,"loc")
			 i oldmapx {
				 s (@array(NUM)@("loc"),array(NUM,"loc"))=oldlocx
				 s array(NUM,"map")=1
			 } else {
				 s array(FIRSTR,"map")=1
				 if FIRSTL'="" s array(NUM,"loc")=oldloc,array(NUM,"map")=oldmap
			 }
			 if begedge'="" {
				 s array(NUM,"begedge")=begedge
				 s:$G(array(FIRSTL,"edgend"))'="END" x=$i(array(FIRSTL,"edgend"))
			 }
			 S FIRSTR=NUM
		 }
	 } else {
		 s pairs(gn,jj,2,"delete")=array(FIRSTR)
	 }
	 if begedge'=""&&(pairs(gn,jj,2,"name")'="") {
	 	S NUM=FIRSTL
	 	For  {
		 	S NUM=$O(array(NUM),1,nd) Q:NUM=""||(NUM=FIRSTR)
		 	s edge=$g(array(NUM,"begedge"),"")
			if ($p($p(nd,",",3),")")=2&&(begedge=edge||(begedge=$p(nd,",",2)))) {
				S (@array(FIRSTL)@("loc"),array(FIRSTL,"loc"))=oldloc
				quit
			}
	 	}
	 }
	 S NUM=LSET
	 For  {
		 S NUM=$O(array(NUM),1,nd) Q:NUM=FIRSTR
nextpoint s beg=$p($p(nd,",",3),")"),index=$p(nd,",",2)
		 if beg=1 {
			 if $D(array(NUM,"edgend"),edgecnt) {
				 Q:edgecnt="END"
				 s edgecnt=edgecnt+1
				 s NUM=$O(array(NUM),1,nd) Q:NUM=FIRSTR
				 for  {
					 if '$d(array(NUM,"begedge"),cindex) s cindex=$p(nd,",",2)
					 s:index=cindex edgecnt=edgecnt-1
					 Q:edgecnt=0
					 s NUM=$O(array(NUM),1,nd)
					 Q:NUM=FIRSTR
				 }
				 if edgecnt d $zu(9,"","updmarg: could not find a matching end point for begin edge overlap "_pairs(gn,index,1,"name"),0,0) Q
				 s (@array(NUM)@("loc"),array(NUM,"loc"))=pairs(gn,jj,1,"loc"),array(NUM,"map")=1
				 continue
			 }
			 if $d(pairs(gn,index,2,"delete"),end) {
				 Quit:end=""
				 s NUM=$O(array(NUM),1,nd) Q:NUM=FIRSTR
				 for  Q:nd=end||(NUM=FIRSTR)  s NUM=$O(array(NUM),1,nd)
				 Q:NUM=FIRSTR
				 if $p($p(nd,",",3),")")=2 {
					 s (@array(NUM)@("loc"),array(NUM,"loc"))=pairs(gn,jj,1,"loc"),array(NUM,"map")=1
					 continue
				 } else {
					 goto nextpoint
				 }
			 }
			 s NUM=$O(array(NUM),1,nd) Q:NUM=FIRSTR
			 for  Q:index=$p(nd,",",2)||(NUM=FIRSTR)  s NUM=$O(array(NUM),1,nd)
			 if NUM=FIRSTR d $zu(9,"","updmarg: could not find a matching end point for "_pairs(gn,index,1,"name"),0,0) Q
			 s (@array(NUM)@("loc"),array(NUM,"loc"))=pairs(gn,jj,1,"loc"),array(NUM,"map")=1
			 continue
		 }
		 if '$d(array(NUM,"begedge"))&&(index'=begedge) d $zu(9,"","updmarg: found non-begin-overlap end point for "_pairs(gn,index,1,"name"),0,0) Q
	 }
 }
 q
Err s ^||SYS.ActivateError($i(^||SYS.ActivateError))=$ze q
ReIndex ;reindex the array
 i $ze'["<ZINDX>" s ^||SYS.ActivateError($i(^||SYS.ActivateError))="ERROR: "_$ze_" in reindexing." q
 s $zt="etReIndex"
 s pairtodo="pairs("""_gn_""","_jj_",1"
 k tmp
 i $g(maprecov)]"" {
	 s array(maprecov,"map")=$g(oldmap,0) ;this was set to 1 before error
	 s array(maprecov)=oldpair
	 s (@array(maprecov)@("loc"),array(maprecov,"loc"))=oldloc
 }
 s i="" f n=0:8 s i=$o(array(i)) q:i=""  m:array(i)'[pairtodo tmp(n)=array(i)
 k array m array=tmp
 s jj=jj-1 ;retry pairs(jj) that triggered reindexing
 g errrepeat  ; Go back to FOR loop with jj=jj-1
etReIndex ;
 s $zt=""
 s m=" mappings"
 s m=$s($g(col)="":"global mappings",+$g(rmap):"routine mappings",1:"subscript mappings of global "_globname)
 s ^||SYS.ActivateError($i(^||SYS.ActivateError))="ERROR: "_$ze_" in reindexing "_m_" in "_$g(nsname)
 q
} ; end updmarg
GetMapIdx(array,next,first,incr) Private {
 i next="" q first+(incr*8)
 s num=$s(incr=1:(first*.5)+(next*.5),1:(first*.25)+(next*.75))
 i $d(array(num)) q "" ;prevent pairs(jj,1) and (jj,2) from sharing one index
 i first<num,num<next q num
 i next<num,num<first q num
 q "" ;first and next are too close to insert a point between them
}
 ;
maperr(nsname,globname,index,reason,pairs,gn) Private { 
 s pair1=pairs(gn,index,1,"name")
 i pair1="" s pair1="BEGIN"
 e  s pair1="("_pair1_")"
 s pair2=$P(pairs(gn,index,2,"name"),$C(1)_"*next")
 i pair2="" s pair2="END"
 e  s pair2="("_pair2_")"
 s err="Discarding subscript mapping "_pair1
 i pair1'=pair2 s err=err_":"_pair2
 s err=err_" "_reason_" global ^"_globname_" namespace "_nsname
 d $zu(9,"",err,(1>0),2)
 q
}
FOLLOWS(ga,gb,col) Public {
 q $zu(90,23,ga,gb,$s(col="":-1,1:col))
}
actref(ga) [BEGIN,END] Private {
 i ga="" q ga
 i $zcvt(ga,"U")="BEGIN" q """"""
 i $zcvt(ga,"U")="END" q ""
 New BEGIN,END
 s (BEGIN,END)=""
 k ^||temp
 s xx=$name(@("^||temp("_ga_")"))
 s sav=$zu(68,1,1)
 s @xx=""
 s res=$q(^||temp)
 s sav=$zu(68,1,sav)
 s res=$p(res,"(",2,$l(res,"("))
 k ^||temp
 q $e(res,1,$l(res)-1)
}
assigslm(nsname,globname,col,loclist,array) Public {
 q:'$d(array)
 s $zt="Err"
 s mapnum=0
 k ^SYS("NSMAP",nsname,"submap",globname)
 s ^SYS("NSMAP",nsname,"submap",globname)=col
 s numl=$o(array(""))
 s subrefl=array(numl,"name") ; subscripts string
 i subrefl'="""""" d oneslm(nsname,globname,"""""",1,.loclist,.mapnum)
 s qll=$ql("xx("_subrefl_")") ; get number of subscripts
 i qll>1 d slmrange(nsname,globname,.loclist,.mapnum,subrefl,1,qll-1,1)
 d oneslm(nsname,globname,subrefl,array(numl,"loc"),.loclist,.mapnum)
 f  s numr=$o(array(numl)) q:numr=""  d  s numl=numr,subrefl=subrefr,qll=qlr
 . s subrefr=array(numr,"name") ; subscript string
 . if subrefr[($c(1)_"*next") d oneslm(nsname,globname,subrefr,array(numr,"loc"),.loclist,.mapnum) d  q
 . . s subrefr=$p(subrefr,$c(1)_"*next")
 . . s qlr=$ql("xx("_subrefr_")")
 . s qlr=$ql("xx("_subrefr_")") ; number of subscripts at the end of interval
 . i qlr=1 d oneslm(nsname,globname,subrefr,array(numr,"loc"),.loclist,.mapnum) q
 . f kk=1:1:qlr q:qll<kk  i $qs("xx("_subrefl_")",kk)'=$qs("xx("_subrefr_")",kk) q
 . i kk<qlr d slmrange(nsname,globname,.loclist,.mapnum,subrefr,kk,qlr-1,array(numl,"loc"))
 . d oneslm(nsname,globname,subrefr,array(numr,"loc"),.loclist,.mapnum)
 q
Err s ^||SYS.ActivateError($i(^||SYS.ActivateError))=$ze q
}
slmrange(nsname,globname,loclist,mapnum,subref,beg,end,ind) Private {
 f jj=beg:1:end s sub=$$extrsub(subref,jj) d oneslm(nsname,globname,sub,ind,.loclist,.mapnum)
 q
}
extrsub(subref,num) Private {
 s ref=$na(@("xx("_subref_")"),num)
 s ref=$p(ref,"(",2,$l(ref,"("))
 q $e(ref,1,$l(ref)-1)
}
oneslm(nsname,globname,sub,ind,loclist,mapnum)  Private {
 s mapnum=mapnum+1
 s ^SYS("NSMAP",nsname,"submap",globname,mapnum)=sub
 s loc=$p($G(loclist(ind)),$c(1))
 i loc="" s $p(loclist(ind),$c(1))="|""^^""|",loc="|""^^""|"
 s ^SYS("NSMAP",nsname,"submap",globname,mapnum,"I")=loc
 q
}
OneNSP(ConfigName,Namespace,rmtab,extratab) Public {
 s $zt="Error"
 k ^||SYS.ActivateError
 s SysCacheTemp=$p(^SYS("GREDIR","DSLOC","master",ConfigName,"IRISTEMP"),$c(1),3)
 s SysCacheAudit=$p(^SYS("GREDIR","DSLOC","master",ConfigName,"IRISAUDIT"),$c(1),3)
 s SysCacheSys=$p(^SYS("GREDIR","DSLOC","master",ConfigName,"IRISSYS"),$c(1),3)
 s SysCacheLib=$p(^SYS("GREDIR","DSLOC","master",ConfigName,"IRISLIB"),$c(1),3)
 s SysCache=$p(^SYS("GREDIR","DSLOC","master",ConfigName,"IRISLOCALDATA"),$c(1),3)
 s JournalcspSession=^CONFIG("Journal","JournalcspSession")
 Q:'$D(^CONFIG("Namespaces",Namespace)) 1
 s Data=^CONFIG("Namespaces",Namespace)
 s DefDir=$p(Data,",",1)
 s DefDirN=DefDir
 s DefDir=$p(^SYS("GREDIR","DSLOC","master",ConfigName,DefDir),$c(1),3)
 s DefRoDir=$p(Data,",",2)
 s DefRoDir=$s(DefRoDir="":DefDir,1:$p(^SYS("GREDIR","DSLOC","master",ConfigName,DefRoDir),$c(1),3))
 s CacheTemp=$p(Data,",",3)
 s CacheTemp=$s(CacheTemp="":SysCacheTemp,1:$p(^SYS("GREDIR","DSLOC","master",ConfigName,CacheTemp),$c(1),3))
 s DefSysGl=$p(Data,",",4)
 s DefSysGl=$s(DefSysGl="":SysCacheSys,1:$p(^SYS("GREDIR","DSLOC","master",ConfigName,DefSysGl),$c(1),3))
 s DefMgr=$p(Data,",",5)
 s DefMgr=$s(DefMgr="":SysCacheSys,1:$p(^SYS("GREDIR","DSLOC","master",ConfigName,DefMgr),$c(1),3))
 s CacheLib=$p(Data,",",6)
 s CacheLib=$s(CacheLib="":SysCacheLib,1:$p(^SYS("GREDIR","DSLOC","master",ConfigName,CacheLib),$c(1),3))
 s ^SYS("NSMAP",Namespace,"defglbloc")=DefDir
 i $p(DefMgr,"^",2)'="" s ^||SYS.ActivateError($i(^||SYS.ActivateError))="Namespace "_Namespace_": dataset "_DefMgr_" for system routines location is not local"
 s ^SYS("NSMAP",Namespace,"defsysrtn")=DefMgr
 s StreamLocation=$g(^SYS("DBStreamLocation",DefDirN))
 i StreamLocation'="" s ^%SYS("StreamLocation",Namespace)=StreamLocation
 k extratab("rsql")
 k extratab("pkg")
 k SubMapCol,pairs,loclist
 k GlobalMapped,PackageMapped,RoutineMapped
 s loclist=1,loclist("|""^^""|"_$c(1))=1,loclist(1)="|""^^""|"_$c(1)
 s Index=""
 f  {
	s Index=$o(rmtab("ext",Index),1,Data) q:Index=""
	s SubMapCol(Data)=$s(Data="rOBJ":133,1:5)
	d oneglob(Data,DefRoDir,DefRoDir,"",.pairs,.loclist)
 }
 s Index="" 
 f  {
	s Index=$o(extratab("ext",Index),1,Data) q:Index=""
	s SubMapCol(Data)=5
	d oneglob(Data,DefRoDir,DefRoDir,"",.pairs,.loclist)
 }
 d oneglob("odd*",DefRoDir,DefRoDir,"",.pairs,.loclist)
 d oneglob("mtemp*",CacheTemp,CacheTemp,"",.pairs,.loclist)
 d oneglob("CacheTemp*",CacheTemp,CacheTemp,"",.pairs,.loclist)
 d oneglob("cspRule",DefRoDir,DefRoDir,"",.pairs,.loclist)
 d oneglob("IRIS.oddMETA",SysCache,SysCache,"",.pairs,.loclist)
 d oneglob("IRIS.WorkQueue",SysCache,SysCache,"",.pairs,.loclist)
 d oneglob("IRIS.Temp*",CacheTemp,CacheTemp,"",.pairs,.loclist)
 d oneglob("IRIS.Msg*",DefRoDir,DefRoDir,"",.pairs,.loclist)
 i Namespace="%SYS" d oneglob("IRIS.Audit*",SysCacheAudit,SysCacheAudit,"",.pairs,.loclist)
 d oneglob("%utility",CacheTemp,CacheTemp,"",.pairs,.loclist)
 d oneglob("%q*",CacheLib,CacheLib,"",.pairs,.loclist)
 if Namespace="%SYS" {
 	d oneglob("%sqlcq",SysCache,SysCache,"",.pairs,.loclist)
 } else {
	d oneglob("%sqlcq",DefSysGl,DefSysGl,"",.pairs,.loclist)
 }
 i 'JournalcspSession d oneglob("%cspSession",SysCache,SysCache,"",.pairs,.loclist)
 d oneglob("%*",DefSysGl,DefSysGl,"",.pairs,.loclist)
 s Status=$$MapUserGlobals(Namespace,0)
 i '(''Status) q Status
 i (",DOCBOOK,"'[(","_Namespace_",")) {
	s Status=$$MapUserGlobals(Namespace,1)
	i '(''Status) q Status
 }
 i $g(pairs(0)) d updmarg(Namespace,"","",0,.pairs,.array)
 d assign(Namespace,.array,.loclist)
 k pairs
 s Status=$$MapPkg(Namespace,"INFORMATION.SCHEMA",CacheLib,1)
 i '(''Status) q Status
 s Status=$$MapSub(Namespace,"%z*","ALL",DefMgr,.rmtab)
 i '(''Status) q Status
 k extratab("slm")
 s extratab("slm","oddCOM")="(""%z""):(""%{"")"
 s extratab("slm","oddDEF")="(""%z""):(""%{"")"
 s extratab("slm","oddEXT")="(""%z""):(""%{"")"
 s extratab("slm","oddEXTR")="(""%z""):(""%{"")"
 s extratab("slm","oddMAP")="(""%z""):(""%{"")"
 s extratab("pkg","oddPKG","%z")=DefMgr_$c(1)_"(""%z""):(""%{"")"
 s extratab("pkg","oddPROC","%z")=DefMgr_$c(1)_"(""%z""):(""%{"")"
 s extratab("slm","oddPYTHON")="(""%z""):(""%{"")"
 s extratab("slm","oddSQL")="(""%z""):(""%{"")"
 s extratab("slm","oddStudioDocument")="(""%z""):(""%{"")"
 s extratab("slm","oddStudioMenu")="(""%z""):(""%{"")"
 s extratab("pkg","rINDEXCLASS","%z")=DefMgr_$c(1)_"(""%z""):(""%{"")"
 s Status=$$MapSub(Namespace,"","ALL",DefMgr,.extratab)
 i '(''Status) q Status
 k extratab("slm")
 s MapNamespace=$s(Namespace="%SYS":"",1:$tr(Namespace,"%_-$@:/\[]^ .","pudssssssssss"))
 s Status=$$MapPkg(Namespace,"%sqlcq"_$s(MapNamespace="":"",1:"."_MapNamespace),SysCache,1)
 i '(''Status) q Status
 s Status=$$MapSub(Namespace,"%sqlcq"_$s(MapNamespace="":"",1:"."_MapNamespace)_".*","ALL",SysCache,.rmtab)
 i '(''Status) q Status
 s Status=$$MapPkg(Namespace,"%ZEN",CacheLib,1)
 i '(''Status) q Status
 s Status=$$MapSub(Namespace,"%ZEN.*","ALL",CacheLib,.rmtab)
 i '(''Status) q Status
 k extratab("slm")
 s extratab("slm","oddCOM")="(""%Z""):(""%["")"
 s extratab("slm","oddDEF")="(""%Z""):(""%["")"
 s extratab("slm","oddEXT")="(""%Z""):(""%["")"
 s extratab("slm","oddEXTR")="(""%Z""):(""%["")"
 s extratab("slm","oddMAP")="(""%Z""):(""%["")"
 s extratab("pkg","oddPKG","%Z")=DefMgr_$c(1)_"(""%Z""):(""%["")"
 s extratab("pkg","oddPROC","%Z")=DefMgr_$c(1)_"(""%Z""):(""%["")"
 s extratab("slm","oddPYTHON")="(""%Z""):(""%["")"
 s extratab("slm","oddSQL")="(""%Z""):(""%["")"
 s extratab("slm","oddStudioDocument")="(""%Z""):(""%["")"
 s extratab("slm","oddStudioMenu")="(""%Z""):(""%["")"
 s extratab("pkg","rINDEXCLASS","%Z")=DefMgr_$c(1)_"(""%Z""):(""%["")"
 s Status=$$MapSub(Namespace,"","ALL",DefMgr,.extratab)
 i '(''Status) q Status
 s Status=$$MapSub(Namespace,"%Z*","ALL",DefMgr,.rmtab)
 i '(''Status) q Status
 s Status=$$MapPkg(Namespace,"%SYS",DefMgr,1)
 i '(''Status) q Status
 s Status=$$MapSub(Namespace,"%SYS.*","ALL",DefMgr,.rmtab)
 i '(''Status) q Status
 k extratab("slm")
 s extratab("slm","oddCOM")="(""%""):(""&"")"
 s extratab("slm","oddDEF")="(""%""):(""&"")"
 s extratab("slm","oddEXT")="(""%""):(""&"")"
 s extratab("slm","oddEXTR")="(""%""):(""&"")"
 s extratab("slm","oddMAP")="(""%""):(""&"")"
 s extratab("pkg","oddPKG","%")=CacheLib_$c(1)_"(""%""):(""&"")"
 s extratab("pkg","oddPROC","%")=CacheLib_$c(1)_"(""%""):(""&"")"
 s extratab("slm","oddPYTHON")="(""%""):(""&"")"
 s extratab("slm","oddSQL")="(""%""):(""&"")"
 s extratab("slm","oddStudioDocument")="(""%""):(""&"")"
 s extratab("slm","oddStudioMenu")="(""%""):(""&"")"
 s extratab("pkg","rINDEXCLASS","%")=CacheLib_$c(1)_"(""%""):(""&"")"
 s Status=$$MapSub(Namespace,"","ALL",CacheLib,.extratab)
 i '(''Status) q Status
 s Status=$$MapSub(Namespace,"%*","ALL",CacheLib,.rmtab)
 i '(''Status) q Status
 k extratab("slm")
 s Status=$$MapUserPackages(Namespace,0)
 i '(''Status) q Status
 i (",DOCBOOK,"'[(","_Namespace_",")) {
	s Status=$$MapUserPackages(Namespace,1)
	i '(''Status) q Status
 }
 f ii="oddPKG","oddPROC","rINDEXCLASS" {
	s Data=""
	k extratab("slm")
	f {
		s Data=$o(extratab("pkg",ii,Data),-1,val) q:Data=""
		s extratab("slm",ii)=$p(val,$c(1),2,999),col=$p(val,$c(1))
		s Status=$$MapSub(Namespace,"","ALL",col,.extratab)
		i '(''Status) q
	}
 }
 i '(''Status) q Status
 k extratab("slm")
 f ii="schema","rv","VIEW","TABLE","SERVER" {
	s Data=""
	f {
		s Data=$o(extratab("rsql",ii,Data),-1,extratab("slm","rINDEXSQL")) q:Data=""
		s Status=$$MapSub(Namespace,"","ALL",extratab("rsql",0,Data),.extratab)
		i '(''Status) q
	}
	i '(''Status) q
	s extratab("slm","rINDEXSQL")="("""_ii_""",""INFORMATION_SCHEMA_""):("""_ii_""",""INFORMATION_SCHEMA`"")~("""_ii_""",""INFORMATION_SCHEMA""):("""_ii_""",""INFORMATION_SCHEMA"_$C(0)_""")"
	s Status=$$MapSub(Namespace,"","ALL",CacheLib,.extratab)
	i '(''Status) q
	s extratab("slm","rINDEXSQL")="("""_ii_""",""%z""):("""_ii_""",""%{"")"
	s Status=$$MapSub(Namespace,"","ALL",DefMgr,.extratab)
	i '(''Status) q
	s extratab("slm","rINDEXSQL")="("""_ii_""",""%ZEN_""):("""_ii_""",""%ZEN`"")~("""_ii_""",""%ZEN""):("""_ii_""",""%ZEN"_$C(0)_""")"
	s Status=$$MapSub(Namespace,"","ALL",CacheLib,.extratab)
	i '(''Status) q
	s extratab("slm","rINDEXSQL")="("""_ii_""",""%Z""):("""_ii_""",""%["")~("""_ii_""",""%SYS_""):("""_ii_""",""%SYS`"")~("""_ii_""",""%SYS""):("""_ii_""",""%SYS"_$C(0)_""")"
	s Status=$$MapSub(Namespace,"","ALL",DefMgr,.extratab)
	i '(''Status) q
	i ((ii="VIEW")||(ii="TABLE")||(ii="SERVER")) {
		if MapNamespace="" {
			s extratab("slm","rINDEXSQL")="("""_ii_""",""%sqlcq_""):("""_ii_""",""%sqlcq`"")~("""_ii_""",""%sqlcq_""):("""_ii_""",""%sqlcq_"_$C(0)_""")"
		} else {
			s extratab("slm","rINDEXSQL")="("""_ii_""",""%sqlcq_"_MapNamespace_"_""):("""_ii_""",""%sqlcq_"_MapNamespace_"`"")~("""_ii_""",""%sqlcq_"_MapNamespace_"""):("""_ii_""",""%sqlcq_"_MapNamespace_""_$C(0)_""")"
		}
		s Status=$$MapSub(Namespace,"","ALL",SysCache,.extratab)
		i '(''Status) q
	} else {
		if MapNamespace="" {
			s extratab("slm","rINDEXSQL")="("""_ii_""",""%SQLCQ_""):("""_ii_""",""%SQLCQ`"")~("""_ii_""",""%SQLCQ_""):("""_ii_""",""%SQLCQ_"_$C(0)_""")"
		} else {
			s extratab("slm","rINDEXSQL")="("""_ii_""",""%SQLCQ_"_$zcvt(MapNamespace,"U")_"_""):("""_ii_""",""%SQLCQ_"_$zcvt(MapNamespace,"U")_"`"")~("""_ii_""",""%SQLCQ_"_$zcvt(MapNamespace,"U")_"""):("""_ii_""",""%SQLCQ_"_$zcvt(MapNamespace,"U")_""_$C(0)_""")"
		}
		s Status=$$MapSub(Namespace,"","ALL",SysCache,.extratab)
		i '(''Status) q
	}
	s extratab("slm","rINDEXSQL")="("""_ii_""",""%""):("""_ii_""",""&"")"
	s Status=$$MapSub(Namespace,"","ALL",CacheLib,.extratab)
	i '(''Status) q
 }
  i '(''Status) q Status
 s SubMapCol("%sqlcq")="5,1"
 d oneglob("%sqlcq",SysCache,SysCache,$s(MapNamespace="":"",1:"("""_Namespace_""")"),.pairs,.loclist)
 s Status=$$MapUserGlobals(Namespace,2)
 i '(''Status) q Status
 i (",DOCBOOK,"'[(","_Namespace_",")) {
	 s Status=$$MapUserGlobals(Namespace,3)
	 i '(''Status) q Status
 }
 s Status=$$MapUserRoutines(Namespace,0)
 i '(''Status) q Status
 i (",DOCBOOK,"'[(","_Namespace_",")) {
 s Status=$$MapUserRoutines(Namespace,1)
	i '(''Status) q Status
 }
 s Global=""
 f  {
	 s Global=$o(SubMapCol(Global),1,col) q:Global=""
	 i $g(pairs(Global)) d updmarg(Namespace,Global,+col,'$p(col,",",2),.pairs,.array),assigslm(Namespace,Global,col,.loclist,.array)
 }
 i $d(^||SYS.ActivateError) f i=1:1:^||SYS.ActivateError s Status=$select(+Status:$$Error^%apiOBJ(5001,$g(^||SYS.ActivateError(i))),1:$$AppendStatus^%occSystem(Status,$$Error^%apiOBJ(5001,$g(^||SYS.ActivateError(i)))))
 q Status
Error s $zt=""
 q $$Error^%apiOBJ(5002,$ze)
MapSub(Namespace, Subscript, Ext, ImplLoc, maptab)
 s Status=1
 if Ext'="ALL" s Ext=$s(Ext'="INT":"r"_Ext,1:"ROUTINE")
 s II="" 
 f  {
	s II=$o(maptab("ext",II),1,Global) q:II=""
	i (Ext'="ALL"),(Global'[Ext) continue
	i Subscript="" {
		s Subscripts = $g(maptab("slm",Global))
		f i=1:1 {
			s Subscript=$p(Subscripts,"~",i) q:Subscript=""
			d oneglob(Global,ImplLoc,ImplLoc,Subscript,.pairs,.loclist)
		}
	} else {
		d oneglob(Global,ImplLoc,ImplLoc,Subscript,.pairs,.loclist)
		Continue:(Ext="ALL")!(Subscript="rMACSAVE")!(Subscript="rINCSAVE")
		d oneglob("rINDEX",ImplLoc,ImplLoc,"("_""""_Subscript_""""_","_""""_Ext_""""_")",.pairs,.loclist)
	}
 }
 q Status
GetSchemaName(Namespace,pkg,ImplLoc)
 s $zt="GetSchemaNameErr"
 s sysn=$p(ImplLoc,"^",2)
 if (sysn'="") {
	 s sysn=$system.ECP.GetClientIndex(sysn)
	 i sysn=-1 g GetSchemaNameErr
	 s ECPstat=+$system.ECP.GetClientState(sysn)
	 i $system.Util.GetSwitch(10),ECPstat'=5 g GetSchemaNameErr
	 if ECPstat=1 d $SYSTEM.ECP.SetClientState(sysn,3,0)
	 for iii=1:1:20 {
		 q:ECPstat=5
		 h 0.1
		 s ECPstat=+$system.ECP.GetClientState(sysn)
	 }
	 if ECPstat'=5 g GetSchemaNameErr
 }
 q $g(@("^"_ImplLoc_"oddPKG("""_pkg_""",""sqlname"")"))
GetSchemaNameErr s $zt=""
 d $zu(9,"","Failed to find ^oddPKG() for schema name in package "_pkg_", default schema name is used.",1,1)
 if +$g(sysn)'=-1 {
	 s ^SYS("NSRELOADRESTART",Namespace)=""
	 s pkg=$i(^SYS("NSRELOADRESTART"))
 }
 q ""
MapPkg(Namespace, Package, ImplLoc, nosql = 0)
 s PACKAGE=$zcvt(Package,"u")
 k Schema2
 s Schema=$$GetSchemaName(Namespace,PACKAGE,ImplLoc)
 i Schema="" {
	 i PACKAGE="USER" {
		 s Schema="SQLUser",Schema2=Package,SCHEMA2=$zcvt(Schema2,"u")
	 } else {
		s Schema=$tr(Package,".","_")
	 }
 }
 s SCHEMA=$zcvt(Schema,"u")
 s Map = "("""_Package_".""):("""_Package_"/"")"   
 s Status=$$MapSub(Namespace,Map,"ALL",ImplLoc,.rmtab)
 i '(''Status) q Status
 k extratab("slm")
 s extratab("slm","oddCOM")=Map
 s extratab("slm","oddDEF")=Map
 s extratab("slm","oddEXT")=Map
 s extratab("slm","oddEXTR")=Map
 s extratab("slm","oddMAP")=Map
 s extratab("pkg","oddPKG",PACKAGE)=ImplLoc_$c(1)_"("""_PACKAGE_".""):("""_PACKAGE_"/"")~("""_PACKAGE_"""):("""_PACKAGE_$c(0)_""")"
 s extratab("pkg","oddPROC",SCHEMA)=ImplLoc_$c(1)_"("""_SCHEMA_"_""):("""_SCHEMA_"`"")~("""_SCHEMA_"""):("""_SCHEMA_$c(0)_""")"
 s extratab("slm","oddPYTHON")=Map
 s extratab("slm","oddSQL")="("""_Schema_"_""):("""_Schema_"`"")~("""_Schema_"""):("""_Schema_$c(0)_""")"_$s($d(Schema2):"~("""_Schema2_"_""):("""_Schema2_"`"")",1:"")
 if $d(Schema2) {
 	s extratab("pkg","oddPROC",SCHEMA2)=ImplLoc_$c(1)_"("""_SCHEMA2_"_""):("""_SCHEMA2_"`"")"
 }
 s extratab("slm","oddStudioDocument")=Map
 s extratab("slm","oddStudioMenu")=Map
 s extratab("pkg","rINDEXCLASS",PACKAGE)=ImplLoc_$c(1)_"("""_PACKAGE_".""):("""_PACKAGE_"/"")"
 i 'nosql {
	 s extratab("rsql",0,Package)=ImplLoc
	 s extratab("rsql",0,PACKAGE)=ImplLoc
	 s extratab("rsql","TABLE",Package)="(""TABLE"","""_Schema_"_""):(""TABLE"","""_Schema_"`"")~(""TABLE"","""_Schema_"""):(""TABLE"","""_Schema_$c(0)_""")"_$s($d(Schema2):"~(""TABLE"","""_Schema2_"_""):(""TABLE"","""_Schema2_"`"")",1:"")
	 s extratab("rsql","VIEW",Package)="(""VIEW"","""_Schema_"_""):(""VIEW"","""_Schema_"`"")~(""VIEW"","""_Schema_"""):(""VIEW"","""_Schema_$c(0)_""")"_$s($d(Schema2):"~(""VIEW"","""_Schema2_"_""):(""VIEW"","""_Schema2_"`"")",1:"")
	 s extratab("rsql","SERVER",Package)="(""SERVER"","""_Schema_"_""):(""SERVER"","""_Schema_"`"")~(""SERVER"","""_Schema_"""):(""SERVER"","""_Schema_$c(0)_""")"_$s($d(Schema2):"~(""SERVER"","""_Schema2_"_""):(""SERVER"","""_Schema2_"`"")",1:"")
	 s extratab("rsql","rv",PACKAGE)="(""rv"","""_SCHEMA_"_""):(""rv"","""_SCHEMA_"`"")~(""rv"","""_SCHEMA_"""):(""rv"","""_SCHEMA_$c(0)_""")"_$s($d(Schema2):"~(""rv"","""_SCHEMA2_"_""):(""rv"","""_SCHEMA2_"`"")",1:"")
	 s extratab("rsql","schema",PACKAGE)="(""schema"","""_SCHEMA_"_""):(""schema"","""_SCHEMA_"`"")~(""schema"","""_SCHEMA_"""):(""schema"","""_SCHEMA_$c(0)_""")"_$s($d(Schema2):"~(""schema"","""_SCHEMA2_"_""):(""schema"","""_SCHEMA2_"`"")",1:"")
 }
 s Status=$$MapSub(Namespace,"","ALL",ImplLoc,.extratab)
 k extratab("slm")
 q Status
MapUserGlobals(Namespace, All)
 s Status=1
 s PrevGlobal="",all=All#2,subonly=All\2
 q:all&&'$d(^CONFIG("Namespaces","%ALL")) Status
 s mapnam="Map."_$s(all=0:Namespace,1:"%ALL")
 s start=$o(^CONFIG(mapnam,"Global_999999"),-1)
 s prevg=""
 i start=""||($p(start,"_",1)'="Global") {
	 i (''Status),'$V($ZU(40,2,93),-2,1) s Status=$$incrementMapVersion^%SYS.SHARDSRV(Namespace)
	 q Status
 }
 s start=+$p(start,"_",2)
 f Index=start:-1:1 {
	 s Index1="0000"_Index
	 s Name=$o(^CONFIG(mapnam,"Global_"_$e(Index1,$l(Index1)-4,*)),1,Data) q:Name=""
	 i $p(Name,"_",1)'="Global" q
	 s Global=$p(Name,"_",3,9999)
	 s Subscript="("_$p(Global,"(",2,9999)
	 s Global=$p(Global,"(",1)
	 s:subonly diffg=(Global'=prevg),prevg=Global
	 i Subscript="(" {
		 i subonly continue
		 s Database=$p(Data,",",1)
		 if all,Database="%DEFAULTDB" s Database=$p(^CONFIG("Namespaces",Namespace),",",1)
		 s Database=$p(^SYS("GREDIR","DSLOC","master",ConfigName,Database),$c(1),3)
		 s SlmCol=$p(Data,",",2)
		 i SlmCol="" s SlmCol=5
		 s LockDatabase=$p(Data,",",3)
		 if all,LockDatabase="%DEFAULTDB" s LockDatabase=$p(^CONFIG("Namespaces",Namespace),",",3)
		 s LockDatabase=$s(LockDatabase="":Database,1:$p(^SYS("GREDIR","DSLOC","master",ConfigName,LockDatabase),$c(1),3))
		 s IndexNext="0000"_(Index+1)
		 s NextName=$o(^CONFIG(mapnam,"Global_"_$e(IndexNext,$l(IndexNext)-4,*)))
		 i (NextName]"")&&($e($p(NextName,"_",3,999),1,$l(Global)+1)=(Global_"(")) {
			 s SubMapCol(Global)=SlmCol_","_1
		 } else {
			 if 'all {
				 s GlobalMapped(0,Global)=$LB(Database,LockDatabase)
			 } elseif $d(GlobalMapped(0,Global),dd)&&(dd'=$LB(Database,LockDatabase))&&(Global'="{") {
				 d $zu(9,"","Mapping of global '"_Global_"' in namespace '"_Namespace_"' is overridden by same mapping in %ALL",1 /* broadcast and log message*/,2  /* Severe error */)
			 }
		 }
		 d oneglob(Global,Database,LockDatabase,"",.pairs,.loclist)
	 } else {
		 i 'subonly||('$d(SubMapCol(Global))) continue
		 if diffg {
			 if $d(pairs(Global)) k pairs(Global)
			 if 'all {
				 s GlobalMapped(Global)=""
			 } elseif $d(GlobalMapped(Global)) {
			 	d $zu(9,"","SLM mapping of global '"_Global_"' in namespace '"_Namespace_"' is overridden by same mapping in %ALL",1 /* broadcast and log message*/,2  /* Severe error */)
			 }
		 }
		 s Data=$p(^SYS("GREDIR","DSLOC","master",ConfigName,Data),$c(1),3)
		 d oneglob(Global,Data,Data,Subscript,.pairs,.loclist)
	 }	 	
 }
 i (''Status),'$V($ZU(40,2,93),-2,1) s Status=$$incrementMapVersion^%SYS.SHARDSRV(Namespace)
 q Status
MapUserPackages(Namespace, All = 0)
 s Status=1
 q:All&&'$d(^CONFIG("Namespaces","%ALL")) Status
 s mapnam="Map."_$s(All=0:Namespace,1:"%ALL")
 s start=$o(^CONFIG(mapnam,"Package_999999"),-1)
 i start=""||($p(start,"_",1)'="Package") {
	 i (''Status),'$V($ZU(40,2,93),-2,1) s Status=$$incrementMapVersion^%SYS.SHARDSRV(Namespace)
	 q Status
 }
 s start=+$p(start,"_",2)
 f Index=start:-1:1 {
 	s Index1="0000"_Index
 	s Name=$o(^CONFIG(mapnam,"Package_"_$e(Index1,$l(Index1)-4,*)),1,Data) q:Name=""
	i $p(Name,"_",1)'="Package" q
	s Data=$p(^SYS("GREDIR","DSLOC","master",ConfigName,Data),$c(1),3)
	s pkgname=$p(Name,"_",3,999)
	if 'All {
		s PackageMapped(pkgname)=Data
	} elseif $d(PackageMapped(pkgname),dd)&&(dd'=Data) {
		d $zu(9,"","Mapping of package '"_pkgname_"' in namespace '"_Namespace_"' is overridden by same mapping in %ALL",1 /* broadcast and log message*/,2  /* Severe error */)
	}
	s Status=$$MapPkg(Namespace,pkgname,Data)
	i '(''Status) q
 }
 i '(''Status) q Status
 k extratab("slm")
 i (''Status),'$V($ZU(40,2,93),-2,1) s Status=$$incrementMapVersion^%SYS.SHARDSRV(Namespace)
 q Status
MapUserRoutines(Namespace, All = 0)
 s Status=1
 q:All&&'$d(^CONFIG("Namespaces","%ALL")) Status
 s mapnam="Map."_$s(All=0:Namespace,1:"%ALL")
 s start=$o(^CONFIG(mapnam,"Routine_99999"),-1)
 q:start=""||($p(start,"_",1)'="Routine") Status
  i start=""||($p(start,"_",1)'="Routine") {
	 i (''Status),'$V($ZU(40,2,93),-2,1) s Status=$$incrementMapVersion^%SYS.SHARDSRV(Namespace)
	 q Status
 }
 s start=+$p(start,"_",2)
 f Index=start:-1:1 {
 	s Index1="0000"_Index
 	s Name=$o(^CONFIG(mapnam,"Routine_"_$e(Index1,$l(Index1)-4,*)),1,Data) q:Name=""
 	i $p(Name,"_",1)'="Routine" q
	s Type=$p(Name,"_",4) i Type="" s Type="ALL"
	s Data=$p(^SYS("GREDIR","DSLOC","master",ConfigName,Data),$c(1),3)
	s rtnname=$p(Name,"_",3)
	if 'All {
		s RoutineMapped(rtnname)=Data
	} elseif $d(RoutineMapped(rtnname),dd)&&(dd'=Data) {
		d $zu(9,"","Mapping of routine '"_rtnname_"' in namespace '"_Namespace_"' is overridden by same mapping in %ALL",1 /* broadcast and log message*/,2  /* Severe error */)
	}
	s Status=$$MapSub(Namespace,rtnname,Type,Data,.rmtab)
	i '(''Status) q
 }
 i (''Status),'$V($ZU(40,2,93),-2,1) s Status=$$incrementMapVersion^%SYS.SHARDSRV(Namespace)
 q Status
 }
MapDataMove(Namespace, All)
 s Status=1
 s PrevGlobal="",all=All#2,subonly=All\2
 q:all&&'$d(^CONFIG("Namespaces","%ALL")) Status
 s mapnam="Map."_$s(all=0:Namespace,1:"%ALL")
 s start=$o(^CONFIG(mapnam,"Global_999999"),-1)
 s prevg=""
 q:start=""||($p(start,"_",1)'="Global") Status
 s start=+$p(start,"_",2)
 f Index=start:-1:1 {
	 s Index1="0000"_Index
	 s Name=$o(^CONFIG(mapnam,"Global_"_$e(Index1,$l(Index1)-4,*)),1,Data) q:Name=""
	 i $p(Name,"_",1)'="Global" q
	 s Global=$p(Name,"_",3,9999)
	 s Subscript="("_$p(Global,"(",2,9999)
	 s Global=$p(Global,"(",1)
	 s:subonly diffg=(Global'=prevg),prevg=Global
	 i Subscript="(" {
		 i subonly continue
		 s Database=$p(Data,",",1)
		 s Database=$p(^SYS("GREDIR","DSLOC","master",ConfigName,Database),$c(1),3)
		 s SlmCol=$p(Data,",",2)
		 i SlmCol="" s SlmCol=5
		 s LockDatabase=$p(Data,",",3)
		 s LockDatabase=$s(LockDatabase="":Database,1:$p(^SYS("GREDIR","DSLOC","master",ConfigName,LockDatabase),$c(1),3))
		 s IndexNext="0000"_(Index+1)
		 s NextName=$o(^CONFIG(mapnam,"Global_"_$e(IndexNext,$l(IndexNext)-4,*)))
		 i (NextName]"")&&($e($p(NextName,"_",3,999),1,$l(Global)+1)=(Global_"(")) {
			 s SubMapCol(Global)=SlmCol_","_1
		 } else {
			 if 'all {
				 s GlobalMapped(0,Global)=$LB(Database,LockDatabase)
			 } elseif $d(GlobalMapped(0,Global),dd)&&(dd'=$LB(Database,LockDatabase)) {
				 d $zu(9,"","Mapping of global '"_Global_"' in namespace '"_Namespace_"' is overridden by same mapping in %ALL",1 /* broadcast and log message*/,2  /* Severe error */)
			 }
		 }
		 d oneglob(Global,Database,LockDatabase,"",.pairs,.loclist)
	 } else {
		 i 'subonly||('$d(SubMapCol(Global))) continue
		 if diffg {
			 if $d(pairs(Global)) k pairs(Global)
			 if 'all {
				 s GlobalMapped(Global)=""
			 } elseif $d(GlobalMapped(Global)) {
			 	d $zu(9,"","SLM mapping of global '"_Global_"' in namespace '"_Namespace_"' is overridden by same mapping in %ALL",1 /* broadcast and log message*/,2  /* Severe error */)
			 }
		 }
		 s Data=$p(^SYS("GREDIR","DSLOC","master",ConfigName,Data),$c(1),3)
		 d oneglob(Global,Data,Data,Subscript,.pairs,.loclist)
	 }	 	
 }
 q Status
CheckSLMOverlap(Namespace,Entry,CPFFile,Flags) PUBLIC {
 s Global=$p(Entry,"(",1),Entry=$e(Entry,$l(Global)+1,*)
 k ^||SYS.ActivateError
 s Status=##Class(Config.CPF).FileToName(CPFFile,.CPFName)
 i '(''Status) q Status
 s pairs=0
 if (Entry'="") d oneglobx(Global,Entry,.pairs)
 i $zb(Flags,1024,1) s CPFName=CPFName_("_"_(+$j))
 i $d(^|"^^"_$zu(12)|SYS("CONFIG",CPFName,"MapGlobals",Namespace,Global),Record)=0 q 1
 s col=$li(Record,2)
 s GlobalName=$o(^|"^^"_$zu(12)|SYS("CONFIG",CPFName,"MapGlobals",Namespace,Global))
 While ($p(GlobalName,"(")=Global) {
	d oneglobx(Global,$E(GlobalName,$L(Global)+1,*),.pairs)
	s GlobalName=$o(^|"^^"_$zu(12)|SYS("CONFIG",CPFName,"MapGlobals",Namespace,GlobalName))
 }
 i $g(pairs,0) d updmargx(col,0,.pairs)
 i $d(^||SYS.ActivateError) f i=1:1:^||SYS.ActivateError s Status=$select(+Status:$$Error^%apiOBJ(5001,$g(^||SYS.ActivateError(i))),1:$$AppendStatus^%occSystem(Status,$$Error^%apiOBJ(5001,$g(^||SYS.ActivateError(i)))))
 q Status
 }
EMSCheckSLMOverlap(index,col) PUBLIC {
 k ^||SYS.ActivateError
 s pairs=0,row="",Status=1
 f  {
	s row=$o(^||%ISCQueryTemp(index,row),1,entry) q:row=""
	s global=$p(entry,"(")
	d oneglobx(global,$e(entry,$L(global)+1,*),.pairs)
 }
 i $g(pairs,0) d updmargx(col,0,.pairs)
 i $d(^||SYS.ActivateError) f i=1:1:^||SYS.ActivateError s Status=$select(+Status:$$Error^%apiOBJ(5001,$g(^||SYS.ActivateError(i))),1:$$AppendStatus^%occSystem(Status,$$Error^%apiOBJ(5001,$g(^||SYS.ActivateError(i)))))
 q Status
 }
CheckGlobalMapOverlap(Namespace,Entry,CPFFile,Flags) PUBLIC {
 s Status=1
 k ^||SYS.ActivateError 
 s Status=##Class(Config.CPF).FileToName(CPFFile,.CPFName)
 i '(''Status) q Status
 s pairs=0
 if ($g(Entry)'="") d oneglobx($p(Entry,"("),"",.pairs)
 i $zb(Flags,1024,1) s CPFName=CPFName_("_"_(+$j))
 s Global=$o(^|"^^"_$zu(12)|SYS("CONFIG",CPFName,"MapGlobals",Namespace,""))
 While (Global'="") {
	i Global'["(" d oneglobx(Global,"",.pairs)
 	s Global=$o(^|"^^"_$zu(12)|SYS("CONFIG",CPFName,"MapGlobals",Namespace,Global))
 }
 i $g(pairs,0) d updmargx("",0,.pairs)
 i $d(^||SYS.ActivateError) f i=1:1:^||SYS.ActivateError s Status=$select(+Status:$$Error^%apiOBJ(5001,$g(^||SYS.ActivateError(i))),1:$$AppendStatus^%occSystem(Status,$$Error^%apiOBJ(5001,$g(^||SYS.ActivateError(i)))))
 q Status
}
EMSCheckGlobalMapOverlap(index) PUBLIC {
 k ^||SYS.ActivateError
 s pairs=0,row="",Status=1
 f  {
	s row=$o(^||%ISCQueryTemp(index,row),1,global) q:row=""
	d oneglobx(global,"",.pairs)
 }
 i $g(pairs,0) d updmargx("",0,.pairs)
 i $d(^||SYS.ActivateError) f i=1:1:^||SYS.ActivateError s Status=$select(+Status:$$Error^%apiOBJ(5001,$g(^||SYS.ActivateError(i))),1:$$AppendStatus^%occSystem(Status,$$Error^%apiOBJ(5001,$g(^||SYS.ActivateError(i)))))
 q Status
 }
CheckRoutineMapOverlap(Namespace,Entry,CPFFile,Flags) PUBLIC {
 s Status=1
 k ^||SYS.ActivateError
 s Status=##Class(Config.CPF).FileToName(CPFFile,.CPFName)
 i '(''Status) q Status
 s pairs=0
 s Name=$p(Entry,"_",1)
 s Type=$p(Entry,"_",2)
 i Type="ALL" s Type=""
 d oneglobx("ROUTINE",Name,.pairs)
 i $zb(Flags,1024,1) s CPFName=CPFName_("_"_(+$j))
 s Routine=$o(^|"^^"_$zu(12)|SYS("CONFIG",CPFName,"MapRoutines",Namespace,""))
 While (Routine'="") {
	s RoutineName=$p(Routine,"_",1)
	s RoutineType=$p(Routine,"_",2)
	i (Type="")||(RoutineType="")||(RoutineType=Type)&&('$d(Map(RoutineName))) {
		s Map(RoutineName)=""
		d oneglobx("ROUTINE",RoutineName,.pairs)
	}
 	s Routine=$o(^|"^^"_$zu(12)|SYS("CONFIG",CPFName,"MapRoutines",Namespace,Routine))
 }
 i $g(pairs,0) d updmargx("",1,.pairs)
 i $d(^||SYS.ActivateError) f i=1:1:^||SYS.ActivateError s Status=$select(+Status:$$Error^%apiOBJ(5001,$g(^||SYS.ActivateError(i))),1:$$AppendStatus^%occSystem(Status,$$Error^%apiOBJ(5001,$g(^||SYS.ActivateError(i)))))
 q Status
}
EMSCheckRoutineMapOverlap(index) PUBLIC {
 k ^||SYS.ActivateError
 s pairs=0,row="",Status=1
 f  {
	s row=$o(^||%ISCQueryTemp(index,row),1,routine) q:row=""
	d oneglobx("ROUTINE",routine,.pairs)
 }
 i $g(pairs,0) d updmargx("",1,.pairs)
 i $d(^||SYS.ActivateError) f i=1:1:^||SYS.ActivateError s Status=$select(+Status:$$Error^%apiOBJ(5001,$g(^||SYS.ActivateError(i))),1:$$AppendStatus^%occSystem(Status,$$Error^%apiOBJ(5001,$g(^||SYS.ActivateError(i)))))
 q Status
 }
oneglobx(globname,slmdef,pairs) Private {
 i slmdef'="" s globname=slmdef
 i $e(globname)'="(" {
	s range=$s($l(globname,":")=2:1,1:0),glob2=""
	s glob1=$p(globname,":"),wild1=$s(glob1["*":1,1:0)
	s glob1=$p(glob1,"*")
	i range {
		s glob2=$p(globname,":",2),wild2=$s(glob2["*":1,1:0)
		s glob2=$p(glob2,"*")
	}
	s:range wild1=1
	i glob1="" s glob1="%",glob2="",wild1=0,wild2=0,range=1
 }  else {
	s range=0,wild1=0,wild2=0,glob2="",glob2end=0
	i globname'["):" {
		s glob1=$e(globname,2,$l(globname)-1)
	} else {
 		f jj=1:1:$l(globname,"):")-1 s glob1=$p(globname,"):",1,jj) s:'($l(glob1)-$l($tr(glob1,""""))#2) range=1 q:range=1
		 i range {
			s glob2=$p(globname,"):",jj+1,$l(globname,"):"))
			i ($zcvt(glob2,"u")="END") {
				s glob2=""
			} else {
				i ($E($zcvt(glob2,"u"),*-4,*)=",END)") {
					s glob2end=1
		 			s glob2=$e(glob2,2,*-5)  ; strip of leading "("
				} else {
					s glob2=$e(glob2,2,$l(glob2)-1)
				}
			}
		 	s glob1=$e(glob1,2,$l(glob1))
		 }
	}
	s glob1=$$actref(glob1),glob2=$$actref(glob2)
	if glob2end s glob2=glob2_$c(1)_"*next"
 }
 s pairs=$i(pairs,-1)
 i 'range&wild1 {
	s pairs(pairs,1,"name")=glob1,pairs(pairs,2,"name")=$$globnext(glob1)
 } else {
	i 'range&('wild1) {
		s pairs(pairs,1,"name")=glob1,pairs(pairs,2,"name")=glob1
	} else {
		i range&('wild2) {
			s pairs(pairs,1,"name")=glob1,pairs(pairs,2,"name")=glob2
		} else {
			s pairs(pairs,1,"name")=glob1,pairs(pairs,2,"name")=$$globnext(glob2)
 		}
	}
 }
 i (slmdef'=""),(globname'["(") {  
	f jj=1,2 i pairs(pairs,jj,"name")]"" s pairs(pairs,jj,"name")=""""_pairs(pairs,jj,"name")_""""
 }
 q
}
updmargx(col,rmap,pairs) [pairs] Private {
 K array
 s subm=($l(col)>0),novlp=(subm&&('rmap))
 s $zt="Err",jj=$o(pairs("")),endon=""
 i pairs(jj,2,"name")'=""&&($zu(90,23,pairs(jj,1,"name"),pairs(jj,2,"name"),$s(col="":-1,1:col))) {
	 d maperrx(jj,"endpoint does not follow starting point","",.pairs)
 } elseif pairs(jj,1,"name")=pairs(jj,2,"name") {
  	 i '$G(%CPFOLDMAPOVERLAP) i subm s pairs(jj,2,"name")=pairs(jj,2,"name")_$c(1)_"*next"
	 s array(8)="pairs("_jj_","_1/*"pairs(1,1)"*/_")",array(8,"map")=1,array(8,"name")=pairs(jj,1/*"pairs(1,1)"*/,"name")
	 s array(2*8)="pairs("_jj_","_2/*"pairs(1,2)"*/_")",array(2*8,"map")=0,array(2*8,"name")=pairs(jj,2/*"pairs(1,2)"*/,"name")
	 i $G(%CPFOLDMAPOVERLAP) i subm s array(8,"map")=0
 } else {
	 s array(8)="pairs("_jj_","_1/*"pairs(1,1)"*/_")",array(8,"map")=1,array(8,"name")=pairs(jj,1/*"pairs(1,1)"*/,"name") 
	 i pairs(jj,2,"name")'="" s array(2*8)="pairs("_jj_","_2/*"pairs(1,2)"*/_")",array(2*8,"map")=0,array(2*8,"name")=pairs(jj,2/*"pairs(1,2)"*/,"name")
	 if pairs(jj,2,"name")="" s endon=jj
 }
 q:pairs=-1
 s INT=""
errrepeat
 s $zt="ReIndex"
 For  {
	 s jj=$o(pairs(jj)) q:jj=""
	 k maprecov
	 ;i $G(%CPFOLDMAPOVERLAP)&&($o(pairs(jj))="") s checkoldmapoverlap=1
	 S (FIRSTL,FIRSTR)=""
	 i pairs(jj,2,"name")'=""&&($zu(90,23,pairs(jj,1,"name"),pairs(jj,2,"name"),$s(col="":-1,1:col))) {
		 d maperrx(jj,"endpoint does not follow starting point","",.pairs)  ;JAO922
		 Continue
	 }
	 i '$G(%CPFOLDMAPOVERLAP) i subm&&(pairs(jj,1,"name")=pairs(jj,2,"name")) s pairs(jj,2,"name")=pairs(jj,2,"name")_$c(1)_"*next"
	 For  {
		 s INT=$O(array(INT)) Q:INT=""
		 S POINT=@(array(INT))@("name")
		 I FIRSTL=""&&($zu(90,23,POINT,pairs(jj,1,"name"),$s(col="":-1,1:col))) S FIRSTL=INT
		 I pairs(jj,2,"name")]""&&(FIRSTR="")&&($zu(90,23,POINT,pairs(jj,2,"name"),$s(col="":-1,1:col))) S FIRSTR=INT
		 if FIRSTL]""&&(pairs(jj,2,"name")=""!(FIRSTR]"")) s INT="" Q
	 }
	 S FIRSTL=$O(array(FIRSTL),-1),FIRSTR=$O(array(FIRSTR),-1)
	s x=FIRSTL,overlap=0
	i x="" s x=$o(array(FIRSTL))
	i $G(%CPFOLDMAPOVERLAP) {
	f  {
		q:(x="")!(x>FIRSTR)!(FIRSTR="")
		i array(x,"map")=1 {
			; A:B,B:C end point overlap ok
			i (@array(x)@("name")'=pairs(jj,2,"name"))||
			  (@array(x)@("name")=pairs(jj,1,"name")) {
				s overlap=1
				s jx=$p($p(array(x),","),"(",2)
				q
			}
		} 
		elseif @array(x)@("name")=pairs(jj,1,"name") {
			s y=$o(array(FIRSTL),-1)
			i @array(y)@("name")=@array(x)@("name") {
				s overlap=1
				s jx=$p($p(array(y),","),"(",2)
				q
			}
		}
		s x=$o(array(x))
	}
	} ;End overlap test
	i overlap {
		d maperrx(jj,"mapping overlaps with a prior mapping",jx,.pairs)
		continue
	}
	 S SET="",samestart=0
	 I FIRSTL="" {
		 S NUM=$O(array(""))-(2*8)
		 s array(NUM)="pairs("_jj_","_1/*"pairs("_jj_",1)"*/_")",array(NUM,"map")=1,array(NUM,"name")=pairs(jj,1/*"pairs("_jj_",1)"*/,"name")
		 I FIRSTR="" {
			 s array(NUM+8)="pairs("_jj_","_2/*"pairs("_jj_",2)"*/_")",array(NUM+8,"map")=0,array(NUM+8,"name")=pairs(jj,2/*"pairs("_jj_",2)"*/,"name")
			 Continue
		 }
		 s LSET=NUM
	 } else {
		 I (@array(FIRSTL)@("name")=pairs(jj,1,"name"))&&($p($p(array(FIRSTL),",",2),")")=1)&&novlp {
			 if @array(FIRSTR)@("name")=pairs(jj,2,"name")&&($p($p(array(FIRSTL),","),"(",2)=$p($p(array(FIRSTR),","),"(",2)) {
				 Continue
			 }
			 d maperrx(jj,"leading subscript same as mapping",$p($p(array(FIRSTL),","),"(",2),.pairs)
			 Continue
		 }
		 i (FIRSTR<FIRSTL) {
			 d maperrx(jj,"endpoint precedes start of range (internal error)","",.pairs)
			 Continue
		 }
		 s oldmap=array(FIRSTL,"map")
		 I @array(FIRSTL)@("name")=pairs(jj,1,"name") {
			 if ($p($p(array(FIRSTL),",",2),")")=1) {
			 	S pairs(jj,1,"delete")=1
			 } else {
				 S @array(FIRSTL)@("delete")="pairs("_jj_","_1_")"
				 s array(FIRSTL)="pairs("_jj_","_1_")"
			 }
			 S array(FIRSTL,"map")=1
			 s maprecov=FIRSTL ;this is the only array element to recover in reindex
			 ;SML1136
			 s LSET=FIRSTL,samestart=1
			 if pairs(jj,1,"name")=pairs(jj,2,"name") {
				 s nf=$o(array(FIRSTL),-1,nd)
				 if nf]""&&(@nd@("name")=pairs(jj,1,"name")) {
					 S array(FIRSTL,"map")=oldmap
					 Continue
				 }
			 }
		 } else {
			 S NEXT=$O(array(FIRSTL))
			 s NUM=$$GetMapIdx(.array,NEXT,FIRSTL,1)
			 ztrap:NUM="" "INDX"
			 s array(NUM)="pairs("_jj_","_1/*"pairs("_jj_",1)"*/_")",array(NUM,"map")=1,array(NUM,"name")=pairs(jj,1/*"pairs("_jj_",1)"*/,"name")
			 S (LSET,SET)=NUM
		 }
	 }
	 I FIRSTR=FIRSTL {
		 i pairs(jj,2,"name")="" {
			 if endon'="" s jx=endon g overlap
			 s endon=jj
			 s pairs(jj,2,"delete")=1
			 Continue
		 }
		 S NEXT=$O(array($S(SET]"":SET,1:FIRSTL)))
		 s NUM=$$GetMapIdx(.array,NEXT,FIRSTL,2) 
		 ztrap:NUM="" "INDX"
		 s array(NUM)="pairs("_jj_","_2/*"pairs("_jj_",2)"*/_")",array(NUM,"map")=0,array(NUM,"name")=pairs(jj,2/*"pairs("_jj_",2)"*/,"name")
		 s array(NUM,"map")=oldmap
		 Continue
	 }
	 s nf=$O(array(LSET),1,nd),ned=array(FIRSTR),sameend=(@ned@("name")=pairs(jj,2,"name"))
	 s edgeok=('novlp)&&((sameend&&(nf=FIRSTR))||samestart)
	 if ($p($p(nd,",",2),")")'=1&&('edgeok))||('$s($p($p(ned,",",2),")")=1:sameend,1:('sameend||'novlp))) {
ovx		 s jx=$s($p($p(nd,",",2),")")'=1:$p($p(nd,","),"(",2),1:$p($p(ned,","),"(",2))
overlap  I FIRSTL=""||(@array(FIRSTL)@("name")'=pairs(jj,1,"name")) {
			 k:LSET'="" array(LSET)
		 } else {
			 s:LSET'="" array(LSET,"map")=oldmap
		 }
		 i +$g(%CPFPRE20091)=0 d maperrx(jj,"mapping overlaps with a prior mapping",jx,.pairs)
		 Continue
	 }
	 I pairs(jj,2,"name")=""||(pairs(jj,2,"name")'=@array(FIRSTR)@("name")) {
		 i pairs(jj,2,"name")="" {
			 if endon'="" s jx=endon g overlap
			 s endon=jj
			 s pairs(jj,2,"delete")=1
			 s array(FIRSTR,"map")=1
		 } else {
			 S NEXT=$O(array(FIRSTR))
			 s NUM=$$GetMapIdx(.array,NEXT,FIRSTR,1) 
			 ztrap:NUM="" "INDX"
			 s array(NUM)="pairs("_jj_","_2/*"pairs("_jj_",2)"*/_")",array(NUM,"map")=0,array(NUM,"name")=pairs(jj,2/*"pairs("_jj_",2)"*/,"name")
			 i array(FIRSTR,"map") {
				 s array(NUM,"map")=1
			 } else {
				 s array(FIRSTR,"map")=1
			 }
		 }
	 }
	 S NUM=FIRSTL
	 For  {
		 S NUM=$O(array(NUM)) Q:NUM=FIRSTR
		 I array(NUM,"map")=0 {
			 S array(NUM,"map")=1
		 }
	 }
 }
 q
Err s ^||SYS.ActivateError($i(^||SYS.ActivateError))=$ze q
ReIndex ;reindex the array
 i $ze'["<ZINDX>" s ^||SYS.ActivateError($i(^||SYS.ActivateError))="ERROR: "_$ze_" in reindexing." q
 s $zt="etReIndex"
 s pairtodo="pairs("_jj_","
 k tmp
 i $g(maprecov)]"" s array(maprecov,"map")=$g(oldmap,0) ;this was set to 1 before error
 s i="" f n=0:8 s i=$o(array(i)) q:i=""  m:array(i)'[pairtodo tmp(n)=array(i)
 k array m array=tmp
 s jj=$o(pairs(jj),-1) ;retry pairs(jj) that triggered reindexing
 g errrepeat  ; Quit back to FOR loop
etReIndex ;
 s $zt=""
 s m=" mappings"
 s m=$s($g(col)="":"global mappings",+$g(rmap):"routine mappings",1:"subscript mappings of global "_globname)
 s ^||SYS.ActivateError($i(^||SYS.ActivateError))="ERROR: "_$ze_" in reindexing "_m
 q
} ; end updmarg
maperrx(index,reason,tidx,pairs) Private { 
 s pair1=pairs(index,1,"name")
 i pair1="""""" s pair1="(BEGIN)"
 e  s pair1="("_pair1_")"
 s pair2=$P(pairs(index,2,"name"),$C(1)_"*next")
 i pair2="" s pair2="END"
 e  s pair2="("_pair2_")"
 s err="Overlapped mapping "_$c(0)_pair1
 i pair1'=pair2 s err=err_":"_pair2
 s err=err_$c(0)_" "_reason
 i tidx'="" {
 	s pair1=pairs(tidx,1,"name")
 	i pair1="""""" s pair1="(BEGIN)"
 	e  s pair1="("_pair1_")"
 	s pair2=$P(pairs(tidx,2,"name"),$C(1)_"*next")
 	i pair2="" s pair2="END"
 	e  s pair2="("_pair2_")"
 	s err=err_" "_$c(0)_pair1
 	i pair1'=pair2 s err=err_":"_pair2
 	s err=err_$c(0)
 }
 s ^||SYS.ActivateError($i(^||SYS.ActivateError))=err
 q
}

NSPUTIL^INT^1^67214,47331
NSPUTIL ; Namespace helper subroutines ;$Change: 7440104 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	; Revision: $Id: //iris/2024.1.3/databases/sys/rtn/sysconfig/nsputil.mac#1 $
 u 0 w !,"Illegal entry point: do not call ^",$ZN," directly."
 q:$zu(41)'>2  ZTRAP "EP"
DataSetConfig(config) Public {
 s desc=config_" configuration"
 s ^SYS("GREDIR","DSCONF",config)=config_$c(1)_desc
 s ^SYS("GREDIR","DSLOC","master",config,"IRISSYS")=$ZU(12)_$c(1)_$c(1)_"|""^^"_$zu(12)_"""|"
 s ^SYS("GREDIR","DSLOC","master",config,"IRISSYS","rowid")=config_$c(1)_"IRISSYS"
 s ^SYS("GREDIR","DSLOC","index-name","IRISSYS",config)=config_$c(1)_"IRISSYS"
 QUIT
}  
DataSetName(Dataset) Public {
 s ^SYS("GREDIR","DSET",Dataset)=""
 QUIT
}  
DataSetLoc(Dataset,Config,Directory,System) Public {
 s ^SYS("GREDIR","DSLOC","master",Config,Dataset)=Directory_$c(1)_System_$c(1)_"|""^"_System_"^"_Directory_"""|"
 s ^SYS("GREDIR","DSLOC","master",Config,Dataset,"rowid")=Config_$c(1)_Dataset
 s ^SYS("GREDIR","DSLOC","index-name",Dataset,Config)=Config_$c(1)_Dataset
 QUIT
}  

ODT^INT^1^67214,47331
ODT ;
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
GO R !,"MODE: ",MODE Q:MODE=""  S BYTES=4
 W ?12,"Type B=2, etc to get 2 byte length, N to get next loc",!!
 W "Address",?20,"Old Value",?42,"New Value",!
A F  R !,ADD Q:ADD=""  D B
 Q
B I ADD="N"!(ADD="n") S ADD=OLD+BYTES_"."
 I ADD?1"B".E!(ADD?1"b".E) S BYTES=+$P(ADD,"=",2) Q
BBB I ADD["." S %D=ADD D INT^%DX S ADD=%X W ?10,ADD
 S %X=ADD D INT^%XD S OLD=%D
 W ?20 S %D=$V(OLD,MODE,BYTES) D INT^%DX W %X," (",%D,".)"
 W ?42 R "=> ",NEW Q:NEW=""  I NEW["." S %D=NEW D INT^%DX S NEW=%X W "  ",NEW
 S %X=NEW D INT^%XD S NEW=%D
 V OLD:MODE:BYTES:NEW W " **"
 Q

OPER^INT^1^67214,47331
OPER ; OPERATOR'S UTILITIES MENU
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ;
 n opt,act
getopt 
 w !!,"Operator's Utilities",!
 w !,"1.  Dismount databases (^DISMOUNT)"
 w !,"2.  Mount databases (^MOUNT)"
 w !,"3.  Lock Table Management (^LOCKTAB)"
 w !,"4.  Free Count (ALL^%FREECNT)"
 w !,"5.  Journal Utilities (^JOURNAL)"
 w !,"6.  Backup Utilities (^BACKUP)"
 w !,"7.  Examine Job (^JOBEXAM)"
 w !,"8.  Terminate Job (^RESJOB)"
 w !,"9.  Switch Set/Clear (^SWSET)"
 w !,"10. Free Up Terminal (^TTYFREE)"
 w !,"11. Broadcast a Message (^BROADCAS)"
 w !,"12. Display System Error Log (^SYSLOG)"
 w !,"13. Exit This Utility"
 r !!,"Option? ",opt
 i ((+opt=opt)&(opt>0)&(opt<13)) s act=$s((opt=1):"^DISMOUNT",(opt=2):"^MOUNT",(opt=3):"^LOCKTAB",(opt=4):"ALL^%FREECNT",(opt=5):"^JOURNAL",(opt=6):"^BACKUP",(opt=7):"^JOBEXAM",(opt=8):"^RESJOB",(opt=9):"^SWSET",(opt=10):"^TTYFREE",(opt=11):"^BROADCAS",(opt=12):"^SYSLOG") w ! d @act g getopt
 i opt=13 q  
 s opt=$zcvt(opt,"U")
 i ((opt="Q")!(opt="QUIT")) q  
 e  g getopt
 q

PERFSAMPLE^INT^1^67214,47331
PERFSAMPLE() { ; System & Process sampling tool ;$Change: $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	; Revision: $Id: $
	try {
		set zs=$zs,$zs=-1
		write !,"This utility performs high frequency sampling of processes on the system,"
		write !,"analyzing and counting data points in different ways to understand where"
		write !,"processes are spending most of their time.  On ECP Data Servers, this also"
		write !,"offers sampling of the current request being processed and the states of"
		write !,"the ECPSvrW daemons doing the processing."
		if '$system.ECP.NumServerConnections() {
			write !!,"Sample Local Process Activity"
			write !,"-----------------------------"
			do JOBS(.s)
		} 
		for {
			set ecps=$system.ECP.NumServerConnections()
			kill list
			set list(1)="Sample Local Process Activity"
			set list(2)="Sample ECP Server Requests"_$select(ecps:"",1:" [unavailable]")
			if $data(s) {
				set list(3)="Save Samples to File"
				set list(4)="Run Analyzer Again"
			}
			write !
			set v="",rc=##class(%Library.Prompt).GetMenu("Option?",.v,.list,,128+8+4)
			quit:(rc'=1)||('v)
			if v=1 { do JOBS(.s) }
			elseif v=2 && ecps { do ECPS(.s) }
			elseif v=3 { do SAVE(.s) }
			elseif v=4 { do CHUIAnalyzer(.s) }
		}
	} catch { write !,"Exiting due to error: ",$ze }
	kill s
	set $zs=zs
}
	/* GetDimensionHelp(s,d)
	   Returns with the output array d set as
	     d(dim) = description
	   where 'dim' is the short dimension specifier (e.g. "pid", "rou", etc).
	   A more verbose display name of 'dim' is returned by 
	   DisplayDimension(). 'description' is additional help text.
	   's' specifies the type of sample.  Different sample types have different
	   dimensions available.  Values for 'type' are the $$$SampleType* definitions.
	   It is also the first piece of the root of the sample array, which can be
	   passed in as the 's' argument alternatively. */    
GetDimensionHelp(s,d) {
	set stype=$piece(s,",",1)
	set d("state")="process state string, e.g. GSETW"
	set d("trace")="alternative to 'state' w/ kernel-level detail"
	set d("waits")="kernel-level condition that delayed the process"
	set d("wtrace")="revese kernel trace, stop at any wait state"
	set d("cpu")="process state indicates expected CPU use"
	if stype="Jobs" {
		set d("pid")="process ID"
		set d("rou")="name of current routine"
		set d("ns")="current namespace" 
	} elseif stype="ECPS" {
		set d("connid")="connection ID"
		set d("req")="client request type being processed"
		set d("glo")="database and global variable name"
		set d("lock")="database and LOCK name"
	} else {
		ztrap "STYP"
	}
}
	/* DisplayDimension(d)
	   Translates the short dimension specifier 'd' into a verbose 
	   name for display.
	 */
DisplayDimension(d) {
	quit $case(d,"pid":		"PID",
	             "rou":		"Routine",
	             "ns":		"Namespace",
	             "trace":	"Kernel Trace",
	             "wtrace":	"Reverse Kernel Trace",  
	             "state":	"Process State",
	             "waits":   "Kernel Wait State",
	             "req":		"ECP Request",
	             "sfn":		"SFN",
	             "glo":		"Global Reference",
	             "lock":	"Lock Reference",
	             "col":		"Collation",
	             "connid":	"Connection ID",
	             "cpu":		"Using CPU?")
}
	/* DisplayDimensionList(dims)
	   Returns a printable description of the comma-delimited dimension
	   specifier in 'dims'.
	 */ 
DisplayDimensionList(dims) PRIVATE {
	set line=$$DisplayDimension($piece(dims,",",1))
	for i=2:1:$length(dims,",") {
		set line=line_" -> "_$$DisplayDimension($piece(dims,",",i))
	}
	quit line
}
JOBS(s) PUBLIC {
	quit:'$$AskJobList(.jobs)
	if (jobs["*") || ($order(jobs($order(jobs(""))))'="") {
		; more than one job
		set yn=1,rc=##class(%Library.Prompt).GetYesNo("Ignore samples where the process appears idle (READ, HANG, etc)? ",.yn,,8)
		quit:(rc'=1)
		set:yn jobs=$get(jobs)_"i"
	}
	set rate=1000,rc=##class(%Library.Prompt).GetNumber("Sample rate per second:",.rate,1,10000,,8)
	quit:(rc'=1)
	set dur=30,rc=##class(%Library.Prompt).GetNumber("Number of seconds to sample:",.dur,,,,8)
	quit:(rc'=1)
	if $$SampleJobs(.jobs,.s,rate,dur) {
		do CHUIAnalyzer(.s)
	}
}
ECPS(s) PUBLIC {
	quit:'$$AskConnList(.conn)
	set rate=1000,rc=##class(%Library.Prompt).GetNumber("Sample rate per second:",.rate,1,10000,,8)
	quit:(rc'=1)
	set dur=30,rc=##class(%Library.Prompt).GetNumber("Number of seconds to sample:",.dur,,,,8)
	quit:(rc'=1)
	if $$SampleECPS(.conn,.s,rate,dur) {
		do CHUIAnalyzer(.s)
	}
}
SAVE(s) PUBLIC {
	set file="",rc=##class(%Library.Prompt).GetString("File: ",.file,,,,8)
	quit:(rc'=1)||(file="")
	if $piece(s,",")="ECPS" {
		set rc=##class(%Library.Prompt).GetYesNo("Strip global subscripts from ouptut:",.yn,,8)
		quit:(rc'=1)
	}
	do SaveSamples(.s,file,$get(yn))
}
	/* DO LOAD^PERFSAMPLE to interactively load samples from a saved file
	   and run the analyzer on it.  The file name can be optionally passed as 
	   the first argument; otherwise, the user is prompted for it */
LOAD(file="") PUBLIC {
	try {
		set zs=$zs,$zs=-1
		if file="" {
			set rc=##class(%Library.Prompt).GetString("File: ",.file,,,,8)
			quit:(rc'=1)
		}
		do:$$LoadSamples(.s,file) CHUIAnalyzer(.s)
	} catch { write !,"Exiting due to error: ",$ze }
	kill s
	set $zs=zs	
}
AddStateToLookup(procstate) {
	set $listbuild(op,flags,waitstate,trace,runcpu)=##class(%SYS.ProcessQuery).DecodeState($piece(procstate,"|",1),$piece(procstate,"|",2),$get(%resnames))
	set state=op_flags
	if trace="" {
		set (trace,wt)=1_","_"[null]"
	} else {
		set wt=""
		set tracelen=$length(trace,",")
		set trace=tracelen_","_trace
		; build the "waittrace" by reversing the stack trace and omitting "hiber"
		; if we're in a known waitstate. 
		for i=tracelen+1:-1:2 {
			set tmp=$piece(trace,",",i)
			continue:(waitstate'="")&&(tmp="hiber")
			set wt=wt_tmp_","
		}
		set wt=$extract(wt,1,*-1)
		if wt="" {
			set wt=1_","_"[null]"
		} else {
			set wt=$length(wt,",")_","_wt
		}
	}
	set:waitstate="" waitstate="[null]"
	set %lkps(procstate)=$listbuild(state,trace,waitstate,wt,runcpu)
}
	/* SampleJobs(jobs,s,rate,duration)
	   SampleECPS(conn,s,rate,duration)
	    ...
	   Collect a particular set of samples until the user presses ctrl-c or the
	   specified collection duration is reached.  Errors and warnings are
	   written to the current device.  Returns true on success, false otherwise.
	   The first parameter is an array passed by reference that describes what
	   to sample.  It differs by type of sampling.  It may be modified within
	   this function.
	      ---
	      SampleJobs uses the 'jobs' array of the form
		    jobs = string of one-character qualifiers
	                * - Collect info on all jobs. If * is not included then
	                    the subnodes describe what jobs to collect
	                i - ignore idle jobs (e.g. in READ, LOCKW, EVTW, etc)
	        jobs(jobnum) = PID,jobid
	                Describes each job to sample when 'jobs' doesn't contain *
	      SampleECPS uses the 'conn' array with a subscript of the form
	        conn(connid) = $system.ECP.GetServerState(connid)
	      ---
	   The other parameters are the same for each type:
	      s - output array of samples
	      rate - (default 1000) target number of samples per second
	      duration - (default 0) # seconds to collect or 0 to run until ctrl-c
	 */
SampleJobs(jobs,s,rate=1000,duration=0) PUBLIC {
	new %lkps,%resnames ; for $$$LookupState
	kill s
	if '$SYSTEM.Security.Check("%Admin_Manage","USE") {
		write !,"Operation requires %Admin_Manage:Use privilege"
		return 0
	}
	set s("const","zv")=$zv
	set s("const","resnames")=$zu(162,4)
	set i="",(cnt,pcnt,total)=0
	if jobs["i" {
		; don't record if the job's state indicates it's most likely idle
		set ignorestate="READ^READW^EVTW^HANG^SLCT^SLCTW^RUNW^"
	} else { set ignorestate="" }
	try { ; Main sampling loop can be stopped with ctrl-c
		set starttime=$h,zh=$zh
		break 0 set zhend=$zh+(duration)+1,unitspersec=$zu(136,27),delay=$select(unitspersec<=(rate):1,1:unitspersec\(rate)),remain=unitspersec*(duration) write !,"Collecting samples... " write:'duration "(ctrl-c to stop)" hang 0
		for {
			if 'i { 
				if remain { set remain=remain-delay if (remain<=0)||($zh>zhend) { write "Done" quit } } if $zboolean(+$zj,8,1) { write "Stopped" quit } do $zu(136,27,$random(delay*2)+1)
				set pcnt=pcnt+1
			}
			if jobs["*" {
				; the loop is over all job slots
				set i=i+1
				if i>$zu(181) { set i=0 continue }
				set jobid=$zu(61,30,i)
				continue:'jobid ; job slot not occupied now
				continue:i=$zu(61) ; ignore ourselves
				if $piece($get(jobs(i)),",",2)'=jobid {
					; job slot changed occupant (or first time)
					set pid=$zu(61,i)
					continue:'pid
					set jobs(i)=pid_","_jobid
				}
			} else {
				; the loop is over jobs identified at the start
				; and if they exit, drop them from the list
				set i=$order(jobs(i))
				continue:i=""
				set jobid=$zu(61,30,i)
				if $piece($get(jobs(i)),",",2)'=jobid {
					write !,"PID "_+jobs(i)_" exited."
					kill jobs(i)
					if $data(jobs)<10 {	write "  Stopping collection." quit }
					hang 0
					continue
				}
			}
			; take a sample
			set total=total+1
			set procstate=$zu(61,4,i)
			; is the state one to ignore?
			if ignorestate'="" {
				do:'$data(%lkps(procstate)) AddStateToLookup(procstate) set $listbuild(state,trace,waits,wtrace,runcpu)=%lkps(procstate)
				continue:ignorestate[(state_"^")
			}			
			; s(x) = $listbuild(pid,pstate/pstatebits/gstatebits,routine,namespace)
			set rou=$zu(61,5,i)
			if rou="" { ; like %SYS.ProcessQuery compute code for Routine
				set rou=$zu(61,32,i)
				if rou="" {
					set jt=$zu(61,10,i)
					set rou=$select(jt=1:"shell",jt=11:"DCP",jt=12:"DMNNET",jt=23:"JOBSRV",1:"")
				}
			}
			set s($increment(cnt))=$listbuild(+jobs(i),procstate,rou,$zu(61,6,i))
			if cnt>=1000000 {
				write !,"Reached maximum of ",1000000," samples"
				quit
			}
		}
		set s="Jobs"_","_starttime_","_($zh-zh)_","_cnt_","_total_","_pcnt_","_jobs
		break 1
		return 1
	} catch { 
		break 1
		write !,"Error: ",$ze
		return 0
	}
}
SampleECPS(conn,s,rate=1000,duration=0) PUBLIC {
	kill s
	if '$SYSTEM.Security.Check("%Admin_Manage","USE") {
		write !,"Operation requires %Admin_Manage:Use privilege"
		return 0
	}
	set getreq=1,req="",procstate=""
	; does the kernel support GetServerReq()?
	try { set req=$system.ECP.GetServerReq(1) } catch { set getreq=0 }
	; capture metadata for connection IDs, SFNs etc
	set s("const","TableLens")=$system.ECP.GetProperty("TableLens")
	set s("const","zv")=$zv
	set s("const","resnames")=$zu(162,4)
	merge s("conn")=conn
	set s("sfn",0)=$zu(49,0)
	set i=$zu(49,0,0,5)
	while i>0 {
		set s("sfn",+i)=i
		set i=$zu(49,i,0,5)
	}
	set i=$order(conn("")) 
	while i { 
		set s("statsbeg")=$system.ECP.GetProperty("ServerStats",i) 
		set i=$order(conn(i))
	}
	set i="",(cnt,pcnt,total)=0
	try { ; Main sampling loop can be stopped with ctrl-c
		set starttime=$h,zh=$zh
		break 0 set zhend=$zh+(duration)+1,unitspersec=$zu(136,27),delay=$select(unitspersec<=(rate):1,1:unitspersec\(rate)),remain=unitspersec*(duration) write !,"Collecting samples... " write:'duration "(ctrl-c to stop)" hang 0
		for  {
			if 'i { 
				if remain { set remain=remain-delay if (remain<=0)||($zh>zhend) { write "Done" quit } } if $zboolean(+$zj,8,1) { write "Stopped" quit } do $zu(136,27,$random(delay*2)+1)
				set pcnt=pcnt+1
			}
			set i=$order(conn(i))
			continue:i=""
			; take a sample
			set total=total+1
			if getreq {
				set req=$system.ECP.GetServerReq(i)
				set pstate=$list(req,2)
			} else {
				set procstate=$zu(61,4,$piece(conn(i),"^",11))
				set pstate=+procstate
			}
			continue:+pstate=5 ; server sets state to "READ" when waiting for work, so skip it
			; s(x) = $listbuild(connid,pstate/pstatebits/gstatebits,reqstate,reqcode,reqcode-specific-fields...
			set s($increment(cnt))=$listbuild(i,procstate)_req
			if cnt>=1000000 {
				write !,"Reached maximum of ",1000000," samples"
				quit
			}
		}
		set s="ECPS"_","_starttime_","_($zh-zh)_","_cnt_","_total_","_pcnt_","_getreq
		set i="" 
		for {
			set i=$order(conn(i),1,serverstate)
			quit:i=""
			if $system.ECP.GetServerState(i)'=serverstate {
				write !,"Warning: Connection #",i," changed state during collection."
				write !,"         Results may not be reliable."
			}
			set s("statsend",i)=$system.ECP.GetProperty("ServerStats",i)
		}
		break 1
		return 1
	} catch { 
		break 1
		write !,"Error: ",$ze
		return 0
	}
}
	/* SaveSamples(s,file,strip)
	   Saves sample array 's' to 'file'.
	   If 'strip' is true, then global subscripts are not output.
	*/ 
SaveSamples(s,file,strip) PUBLIC {
	try {
		open file:"WNVK\RAW\":1
		if $test { set opened=1 }
		else { 
			write !,"Could not open file"
			return 0
		}
		use file
		set a=s
		set cnt=$piece(a,",",5)
		; save header
		write s
		; save samples
		for i=1:1:cnt { 
			if ($piece(s,",")'="ECPS") || 'strip {
				; no global references to strip
				write s(i)
			} else {
				if $length($listget(s(i),12),$c(0))>1 {
					set tmp=s(i)
					set $list(tmp,12)=$piece($list(s(i),12),$c(0),1)
					write tmp
				} else {
					write s(i)
				}
			}
		}
		; save metadata
		for meta="const","conn","sfn","statsbeg","statsend" {
			set i=""
			for {
				set i=$o(s(meta,i),1)
				quit:i=""
				write $listbuild(meta,i,s(meta,i))
			}
		}
		write $listbuild("done")
		close file
		write !,"Done"
		return 1
	} catch {
		close:$get(opened) file
		write !,"Error: ",$ze
		return 0
	}
}
	/* LoadSamples(s,file,strip)
	   Load samples array 's' from 'file'.
	*/ 
LoadSamples(s,file,strip=1) PUBLIC {
	try {
		open file:"RVK\RAW\":1
		if $test {
			set opened=1
		} else {
			write !,"Could not open file"
			return
		}
		use file
		read s
		set a=s
		set cnt=$piece(a,",",5)
		for i=1:1:cnt { read s(i) }
		for {
			read tmp
			quit:$list(tmp,1)="done"
			set s($list(tmp,1),$list(tmp,2))=$list(tmp,3)
		}
		close file
		return 1
	} catch {
		close file
		kill s
		write !,"Error loading samples: ",$ze
		return 0
	}
}
	/* Analyze(s)
	   Given a set of samples in the input array 's', counts them in one or
	   more multidimensional arrays under the public variable 'a'.  
	   Before calling, 'a' must be set up with a description of one or more
	   analyses to perform by setting a(idx) = dims, where 'idx' is an
	   integer 1 or greater and 'dims' is a comma-delimited string specifying
	   a set of dimensions for this analysis to count in the multi-dimensional
	   array under a(idx).  
	   The available dimensions given by the DimensionHelp() function.
	   As an example calling Analyze() with 'a' as follows 
	    a(1) = "rou"
	    a(2) = "state,ns,rou"
	   performs two analyses.  Analysis #1 has only one dimension, to simply
	   counts the number of samples where each routine name was found to be
	   running.  Analysis #2 has three dimensions, the first with counts for
	   each different state the processes were found to be in, then for each
	   of those states, the namespace, and then for each state and namespace,
	   counts the different routines.  In this way you can see what the top
	   routines are that are generating a state of interest.
	   -- Output Array Format --
	   Each dimension of the array under the id represents the ordered
	   dimension given by the description, with the value in that dimension
	   being the subscript in the a array and the value being the count.
	   Note that if the value of the data point in that dimension is null
	   we store $$$NullDimension, which is a string "[null]"
	   An example provides clarity
	    a(1) = "state,rou"
	    a(1,"GGET")=100        // 100 samples were doing global gets,
	    a(1,"GGET","ABC")=80   //   80 of which were from routine ABC,
	    a(1,"GGET","XYZ")=20   //   and 20 from XYZ
	    a(1,"GSET")=5          // 5 samples were doing global sets
	    a(1,"GSET","ABC")=5    //   all from ABC
	    a(2) = "rou"
	    a(2,"ABC")=85          // 85 samples found routine ABC running
	    a(2,"XYZ")=20		   // 20 samples found routine XYZ running	     
	   -- Heirarchical Dimensions --
	   Some dimensions, namely "trace" and "glo", have an inherent heirarchy
	   that can be of interest for analysis.  For example, "glo" can have 
	   values like ^X(1), ^X(1,2), but also ^X itself, ^Y(...), ^Z(...), etc.
	   Depending on the data collected, it can be useful to have descendants
	   summarized under a particular level of ancestor, like ^X or ^X(1).
	   The values of the data point in heirarchical dimensions are strings
	   that have a certain delimiter between each level of the heirarchy.
	   For example, globals are stored in encoded form where $c(0) is the
	   subscript delimiter.
	   Heirarchical dimensions are still stored in just a single "flat" 
	   subscript, but start with their ancestry count followed by the
	   delimiter.  A count is recorded not just for the data point itself
	   but at each ancestor level as a second comma-delimited piece.
	   As an example, consider the heirarchical dimension "trace"
	    a(1)="trace","rou"
	    a(1,"1,[null]"=100  // 100 had no trace of interest
		a(1,"1,blkrd")=2,48       // 50 had blkrd as the highest parent function,
		                          //    48 with a call below that
	    a(1,"1,blkrd","MyRouC")=2 // The remaining 2 were both from MyRouC
	                              // Of the remaining 48...
	    a(1,"2,blkrd,diskio")=8            // 8 were in diskio, no calls below that
	    a(1,"2,blkrd,diskio","MyRouA")=8   //    All from from MyRouA" 
	    a(1,"3,blkrd,inusebufwt)=0,40      // 40 are under inusebufwt... 
	    a(1,"3,blkrd,inusebufwt,hiber")=40 // All inusebufwt,hiber 
	    a(1,"3,blkrd,inusebufwt,hiber","MyRouA")=25  // 25 from MyRouA
	    a(1,"3,blkrd,inusebufwt,hiber","MyRouB")=15  // 15 from MyRouB
	   Note that the ancestor nodes only count samples with their descendants
	   and not samples that had their value directly.
	   The ancestor nodes also have no further dimension, however, it can be
	   generated by calling AnalyzeHeirarchy	   
	 */	       
Analyze(s) [a] PUBLIC {
	new %gcol,%resnames
	; First figure out what the dimensions we'll be building into the 'a' array
	; We may be building multiple subarrays at the same time
	set (i,worklist)=""
	for {
		set i=$order(a(i),1,dims)
		quit:i=""
		continue:$data(a(i))>1 ; already populated
		; mark this subarray as needing work
		set worklist=worklist_i_","
		; note what dimensions we're using to avoid parsing unnecessary data
		for j=1:1:$length(dims,",") { 
			set d($piece(dims,",",j))="[null]"
		}
	}
	quit:worklist=""
	; Iterate over all samples, counting and aggregating into subarrays of 'a'
	set a=s
	set %resnames=s("const","resnames")
	try {
		set cnt=$piece(a,",",5)
		for i=1:1:cnt {
			; extract the data from the sample in to the 'd' array 
			if $piece(s,",")="ECPS" { 
				do GetDataECPS(s(i),.d)
			} else { 
				do GetDataJobs(s(i),.d)
			}
			; Now for each element of the 'a' array we're building, count in the specified way
			for j=1:1 {
				; idx is the index of the subarray of 'a'
				set idx=$piece(worklist,",",j)
				quit:idx=""
				; 'dims' has the order of the subscripts we'll build.
				; For example "req,trace,glo" means first count by request type, then
				; (request type, trace) then by {request type, trace, glo). 
				set dims=a(idx)
				set root=$name(a(idx))
				for k=1:1:$length(dims,",") {
					; d is the dimension we're counting, d(d) is its value in this sample
					set d=$piece(dims,",",k)
					set delim=$case(d,"glo":$c(0),"lock":$c(0),"trace":",","wtrace":",",:"")
					if delim'="" {
						; Heirarchical data
						; Store a count at each ancestor level as described above
						set level=$piece(d(d),delim)
						for h=1:1:level-1 {
							set tmp=$piece(d(d),delim,1,h+1)
							set $piece(tmp,delim,1)=h
							set new=$get(@root@(tmp),"0,0")
							set $piece(new,",",2)=$piece(new,",",2)+1
							set @root@(tmp)=new
						}
						set root=$name(@root@(d(d)))
						set $piece(@root,",",1)=$piece($get(@root),",",1)+1
					} else {
						; simple data point
						set root=$name(@root@(d(d)))
						do $increment(@root)
					}
				}
			}
		}
		merge s("gcol")=%gcol
	} catch {
		; kill any partial analysis
		break 0
		try { 
			for j=1:1 { 
				set idx=$piece(worklist,",",j)
				quit:idx=""
				kill a(idx)
			}
		} catch {}
		break 1
		throw
	}
}
	/* AddAnalysis(dims,new)
	   Put the anslysis specified by 'dims' into the public 'a' array.
	   finding it there if it already exists.  Returns its index into
	   the 'a' array and if it's new, 'new' is set to 1.  If 'dims' 
	   simply adds a dimension to an existing analysis then the
	   existing one is cleared and updated, and 'new' is set to 2.
	   Upon return with 'new' set to true, Analyze() must be called
	   to perform the analysis.  If multiple analyses are to be added
	   it's fastest to add all of them and call Analyze() once when
	   finished.
	 */
AddAnalysis(dims,new) [a] PUBLIC {
	set i=$order(a(0))
	while i {
		set lasti=i
		if a(i)=dims {
			; found existing
			set new=0
			return i
		}
		if a(i)=$piece(dims,",",1,$length(a(i),",")) {
			; matches through the length of a(i) but adds a dimension.
			; replace it
			kill a(i)
			set a(i)=dims
			set new=2
			return i
		}
		set i=$order(a(i))
	}
	; not found - add a new one
	set i=$get(lasti)+1
	set a(i)=dims
	set new=1
	return i
}
	/* GetDataXYZ(sample,d)
	   Set of functions for extracting data from a sample of type $$$SampleTypeXYZ
	   'sample' is the $list stored for a specific sample and 'd' is an array
	   with subscripts for each of the different dimensions being analyzed.
	   These functions set each subscript of 'd' to the value for that
	   dimension extracted from the sample.  
	   For any dimension that exists in 'd' that this function may extract, it 
	   must store $$$NullDimension if the value is null, unused or irrelevant
	   within the context of the given sample.  If there's a dimension defined
	   in 'd' that this function NEVER extracts, nothing needs to be one for it.
	   That's because all elements of the 'd' array are initialized to
	   $$$NullDimension when the analysis begins, but they are not reset between
	   calls for each sample. 
	 */
GetDataJobs(sample,d) PRIVATE {
	set $listbuild(d("pid"),procstate,d("rou"),d("ns"))=sample
	set:d("rou")="" d("rou")="[null]"
	set:d("ns")="" d("ns")="[null]"
	do:'$data(%lkps(procstate)) AddStateToLookup(procstate) set $listbuild(d("state"),d("trace"),d("waits"),d("wtrace"),d("cpu"))=%lkps(procstate)
}
GetDataECPS(sample,d) PRIVATE {
	; Pull apart the sample, assuming we have a global reference type request.
	; If we don't then sfn,col,glo are invalid and we'll adjust for that later.
	set (reqstate,reqcode,resenqcls,numlocks)=""
	set $listbuild(d("connid"),procstate,reqstate,pstate,pstatebits,gstatebits,resenqcls,reqcode,d("clijob"),sfn,col,gloenc)=sample
	if $data(d("req")) {
		if reqcode="" {
			set d("req")="[null]"
		} else {
			; translate code to readable type
			set d("req")=$piece("set,kill,$i,get,$d,$o,$bit,bitgetset,bitset,lock,lockcancel,delock,purgeblk,tcommit,tcommitsync,trollback,trollbackasync,filedata,job,viewblk,ijcwrite,noop,disconnect,shutdown,heartbeat,setlongstr,longstrdata,sync,semsync,semsemisync,semcntrl,settransstate",",",reqcode)
			set:d("req")="" d("req")="CODE"_reqcode
		}
	}
	; The process state is returned from ServerReq() as long as the server supports it.
	; Convert it to $zu(61,4,j) format for decoding and append the special statebits and its jobtype
	set:$data(pstate) procstate=pstate_"^"_pstatebits_"^"_gstatebits_"^"_resenqcls_"|"_reqstate_"^"_35
	do:'$data(%lkps(procstate)) AddStateToLookup(procstate) set $listbuild(d("state"),d("trace"),d("waits"),d("wtrace"),d("cpu"))=%lkps(procstate)
	if $data(d("glo")) {
		if reqcode="" || '(((reqcode)<=9) || ((reqcode)=26)) || (gloenc="") {
			set d("glo")=1_$c(0)_"[null]"
		} else {
			set d("glo")=($length(gloenc,$c(0))+1)_$c(0)_sfn_$c(0)_gloenc
			set %gcol(sfn,$piece(gloenc,$c(0)))=col
		}
	}
	if $data(d("lock")) {
		; GetServerReq() has the numlocks for lock requests in the same
		; $list element as sfn is for global refs.
		set numlocks=$g(sfn)
		if 'numlocks || (reqcode="") || '(((reqcode)>=10) && ((reqcode)<=12)) {
			set d("lock")=1_$c(0)_"[null]"
		} elseif numlocks>1 {
			; These are probably unusual and it's complicated to fit multi
			; lock into "lock" dimension of analysis without some compromise
			; so for now, we'll just report the number of locks
			set d("lock")=2_$c(0)_"multi-lock-command"_$c(0)_numlocks
		} else {
			; sfn of first lock reference is where collation is for gref
			set sfn=col
			set d("lock")=($length(gloenc,$c(0))+1)_$c(0)_sfn_$c(0)_gloenc
		}
	}
	quit
}
	/* DisplayValue(v,d,s)
	   Returns printable string for a value 'v' in the dimension given
	   by short dimension specifier 'd'.  's' is the sample array passed
	   by reference, whose metadata is needed for some translations.
	 */
DisplayValue(v,d,s) PRIVATE {
	if (d="glo") || (d="lock") {
		; translate globals to a printable form
		set sfn=$piece(v,$c(0),2)
		quit:sfn="[null]" "[null]"
		if sfn="multi-lock-command" {
			set numlocks=$piece(v,$c(0),3)
			quit:'numlocks "multi-lock-command"
			quit "multi-lock-command"_"(count="_numlocks_")"
		}
		set dir=$piece($get(s("sfn",sfn)),"^",3)
		if dir="" {
			set ret="|sfn"_sfn_"|"
		} else {
			set ret="|"_dir_"|" ; it's not quite extended reference but saves a few characters for display purposes
		}
		if $length(v,$c(0))>2 {
			set gvn("internal")=$piece(v,$c(0),3,*)
			if (d="lock") {
				set col=5
			} else {
				set col=s("gcol",$piece(v,$c(0),2),$piece(v,$c(0),3))
			}
			do GetPrintableRef^DMREPAIR(.gvn,$zu(70,1,col))
			set ret=ret_$$Quote^%qcr(gvn("printable"),1)
		}
		set:$piece(v,$c(0),1)="a" ret=ret_"..."
		quit ret
	} elseif d="cpu" {
		quit $select(v:"yes",1:"no")
	} elseif d="connid" {
		set ret=$piece($get(s("conn",v)),"^",3)
		quit:ret="" v
		quit ret
	}
	set delim=$case(d,"glo":$c(0),"lock":$c(0),"trace":",","wtrace":",",:"")
	quit:delim="" v
	quit $piece(v,delim,2,*)_$select($piece(v,delim,1)="a":"...",1:"")
}
	/* GetDimensionInfo(root,dims,num,delim)
	   For the dimension in the 'a' public array beneath 'root'
	   return the type of that dimension, e.g. "glo", "trace", etc.
	   Returns by reference:
	     dims - the list of dimensions in a(idx)
	     num - the number of the dimension beneath root
	     delim - the delimiter if heirarchical, else null
	   For example, if root=$na(a(1,"GSET")) and a(1)="state,trace,rou",
	   returns "trace" with dims="state,trace,rou", num=2, delim=$c(0).
	 */
GetDimensionInfo(root,dims,num,delim) [a] PUBLIC {
	set num=$qlength(root)
	set dims=@$name(@root,1)
	set d=$piece(dims,",",num)
	set delim=$case(d,"glo":$c(0),"lock":$c(0),"trace":",","wtrace":",",:"")
	quit d
}
	/* AnalyzeHeirarchy(root,ancestorspec) 
	   Aggregate the counts for all later dimensions so that all of the
	   heirarchical data points that are descendants of 'ancestorspec' are
	   summed in dimensions under the ancestor node.  The initial call
	   to Analyze() only adds further dimensions under the direct data
	   points and not at each ancestor of those points.  This subroutine
	   can be called to add that analysis for a specific ancestor.
	   The analysis is added under @root@(new), where 'new' is the
	   ancestorspec with its initial heirarchy count replaced with "a".
	   This function returns $name(@root@(new)).
	   For example, as in the prior example, if we have the analysis:
	    a(1)="trace","rou"
	    a(1,"1,[null]"=100        // 100 had no trace of interest
		a(1,"1,blkrd")=2,48       // 50 had blkrd as the highest parent function,
		                          //    48 with a call below that
	    a(1,"1,blkrd","MyRouC")=2 // The remaining 2 were both from MyRouC
	                              // Of the remaining 48...
	    a(1,"2,blkrd,diskio")=8            // 8 were in diskio, no calls below that
	    a(1,"2,blkrd,diskio","MyRouA")=8   //    All from from MyRouA" 
	    a(1,"3,blkrd,inusebufwt)=0,40      // 40 are under inusebufwt... 
	    a(1,"3,blkrd,inusebufwt,hiber")=40 // All inusebufwt,hiber 
	    a(1,"3,blkrd,inusebufwt,hiber","MyRouA")=25  // 25 from MyRouA
	    a(1,"3,blkrd,inusebufwt,hiber","MyRouB")=15  // 15 from MyRouB
	    used in a prior example
	   Then calling this function with 
	       root=$name(a(1))  and  ancestorspec="1,blkrd" 
	   adds the nodes
	    a(1,"1a,blkrd","MyRouA")=33  // 8 from diskio + 25 from inusebufwt
	    a(1,"1a,blkrd","MyRouB")=15  // 15 all from blkrd,inusebufwt,hiber
	    a(1,"1a,blkrd","MyRouC")=2   // and 2 with blkrd alone
	 */
AnalyzeHeirarchy(root,ancestorspec) [a] PUBLIC {
	do GetDimensionInfo(root,.dims,.dnum,.delim)
	; Since the heirarchical dimensions can be a little tricky, we want to throw
	; errors immediately if the caller's arguments don't makle sense.
	; best to throw errors rather 
	ztrap:delim="" "HDIM" ; next dimension under root is not heirarchical
	ztrap:$length(dims,",")'>dnum "NDIM" ; no dimension beyond the next under root
	ztrap:('ancestorspec || (ancestorspec+1'=$length(ancestorspec,delim))) "ANC" ; bad ancestorspec
	set ancestor=$piece(ancestorspec,delim,2,*)
	; like Analyze(), we're done if it's already built
	set ancroot=$name(@root@("a"_delim_ancestor))
	quit:$data(@ancroot) ancroot
	try {
		merge @ancroot=@root@(ancestorspec)
		; Now go through each further level of the ancestry adding in
		; the counts at subsequent subscripts
		for level=ancestorspec+1:1 {
			set cnt=""
			set node=$query(@root@(level_delim_ancestor),1,cnt)
			set found=0
		    for {
			    quit:node=""
				; dnum+1 is the subscript level of the dimension we're analyzing
				; (the one immediately below root).  The +1 is because the first
				; subscript of a is the index of the analysis we're working with.
				set ql=$qlength(node)
				quit:ql<=dnum
				set v=$qsubscript(node,dnum+1)
				quit:+v'=level
				quit:ancestor'=$piece(v,delim,2,ancestorspec+1)
				; build the reference and increment in it
				set found=1
				set tmp=ancroot
				for i=dnum+2:1:ql { set tmp=$name(@tmp@($qsubscript(node,i))) }
				set newcnt=$get(@tmp)
				set $piece(newcnt,",",1)=$piece(newcnt,",",1)+cnt
				set:$piece(cnt,",",2) $piece(newcnt,",",2)=$piece(newcnt,",",2)+$piece(cnt,",",2)
				set @tmp=newcnt
				set node=$query(@node,1,cnt)
			}
			; if we didn't find any descendant then there aren't any more at
			; a greater 'level' count
			quit:'found 
		}
		return ancroot
	} catch {
		kill @ancroot
		throw
	}
}
	/* SortDim(root,sorted,ancestorspec)
	   For the dimension in the 'a' public array beneath 'root'
	   return an array, 'sorted', by reference of the form
	      sorted(-count,value)=""
	   where 'count' is the number data points that have the
	   that value given by 'value'.
	   If the dimension in heirarchical, the default behavior is
	   to ignore the hierarchy and return only counts of the
	   data points that exactly match 'value'. To get this
	   behavior 'ancestorspec' parameter is null or omitted.
	   When the ancestorspec parameter is not null, the 'sorted'
	   array takes this form for a heirarchical dimension
	      sorted(-count,value)=descendantcount
	   where 'count' includes all data points for 'value' plus
	   the count from any descendants, and 'descendantcount' is 
	   just the descendants.  The set of values included are all
	   those that are one level further than 'ancestorspec'
	   Calling with ancestorspec=0 causes the sorting above to
	   occur at the first level of the heirarchy.
	   For example if the dimension is type "glo" and ancestorspec
	   is 1_$C(0)_"X" ($C(0) is the heirarchy delimiter for globals)
	   then data points for ^X(1), ^X(1,2), ^X(1,3) will be counted
	   and sorted under ^X(1) while ^X(2), ^X(2,"abc") etc will
	   sort as ^X(2).
	 */	   
SortDim(root,sorted,ancestorspec="") [a] PUBLIC {
	kill sorted
	do GetDimensionInfo(root,,,.delim)
	set v=""
	if ancestorspec'="" {
		ztrap:delim="" "HDIM" ; next dimension under root is not heirarchical
		ztrap:((ancestorspec'=0) && (ancestorspec+1'=$length(ancestorspec,delim))) "ANC" ; bad ancestorspec
		set ancestor=$piece(ancestorspec,delim,2,*)
		set v=(ancestorspec+1)_delim_ancestor
	}
	set sorted=0
	for {
		set v=$order(@root@(v),1,cnt)
		quit:v=""
		if delim="" {
			; not a heirarchical dimension
			set sorted(-cnt,v)=""
			set sorted=sorted+1
		} elseif (ancestorspec="") {
			; We're ignoring ancestory, so if this is an ancestral
			; data point without any direct count, skip it.
			continue:'cnt
			set sorted(-cnt,v)=""
			set sorted=sorted+1
		} else {
			; We only want to sort at a given level of the hierarchy.
			; We're done if the ancestory doesn't match.  (Level 1
			; has no ancestor)
			quit:+v'=(ancestorspec+1)
			quit:ancestorspec&&($piece(v,delim,2,ancestorspec+1)'=ancestor)
			set desccnt=$piece(cnt,",",2)
			set sorted(-cnt-desccnt,v)=+desccnt
			set sorted=sorted+1
		}
	}
}
	/* AskConnList(conn)
	   Returns 0 if the user cancelled or entered null, otherwise
	   returns 1 and the 'conn' byref array contains the connections
	   selected with value set to $system.ECP.GetServerState(i).
	 */
AskConnList(conn) PRIVATE {
	try {
reload	
		kill conn
		for i=1:1:$system.ECP.MaxServerConnections() {
			set state=$system.ECP.GetServerState(i)
			if state>0 {
				set client=$piece(state,"^",3)
				set:client'="" conn(i)=state,client(client)=i
			}
		}
		if '$data(conn) {
			write !,"No clients connections to sample."
			return 0
		}
		set i=$order(conn(""))
		return:'$order(conn(i)) 1 ; there's only one
		write !!,"The following clients are connected: "
		write !, "    Conn#  Client"
		set client=""
		for {
			set client=$order(client(client),1,connid)
			quit:client=""
			write !,$j(connid,9),": ",client
		}
retry
		write !!,"Enter *, list of connection numbers (comma separated) or clients."
		write !!,"Selection: "
		read x
		return:x="" 0
		return:x["*" 1
		goto:x["?" reload
		set x=$translate(x," ",",")	
		for i=1:1:$length(x,",") {
			set tmp=$piece(x,",",i)
			continue:tmp=""
			if $data(conn(tmp)) { ; numeric entry is the connection id
				set connid=tmp
			} elseif $data(client(tmp)) { ; fully qualified client
				set connid=client(tmp)
			} else { ; look for match in one or more of the ":"-delimted segments
				set connid="n",client="",test=":"_$zcvt(tmp,"u")_":"
				for {
					set client=$order(client(client))
					quit:client=""
					if (":"_client_":")[test {
						if connid="n" { 
							set connid=client(client)
						} else { 
							write !!,"'",tmp,"' ambiguous"
							goto retry
						}
					}
				}
				if connid="n" { write !!,"'",tmp,"' not found" goto retry }
			}
			set keep(connid)=1
		}
		; kill any connections that isn't marked keep
		set i="",cnt=0
		for  { 
			set i=$order(conn(i))
			quit:i=""
			if $get(keep(i)) { set cnt=cnt+1 }
			else { kill conn(i) }
	 	}
	 	if 'cnt {
		 	write !,"No connections selected"
		 	return 0
	 	}
		return 1
	} catch {
		return:$ze["INTERRUPT" 0
		throw
	} 
}
	/* AskJobList(jobs)
	   Returns 0 if the user cancelled or entered null, otherwise
	   Returns 1 and the 'jobs' array has the selected job numbers or
	   or jobs="*" if the user selected all.
	 */
AskJobList(jobs) PRIVATE {
	try {
retry
		kill jobs
		write !!,"Enter a list of PIDs (comma separated), * for all, or ? for ^%SS display."
		write !!,"Selection: "
		read x
		return:x="" 0
		if x["*" {
			set jobs="*"
			return 1
		}
		set x=$translate(x," ",",")
		if x="?" {
			do 1^%SS
			goto retry
		}
		for i=1:1:$length(x,",") {
			set pid=+$piece(x,",",i)
			continue:'pid
			set jobnum=$zu(67,pid)
			set jobid=$zu(61,30,jobnum)
			if 'jobnum||'jobid||(pid'=$zu(61,jobnum)) {
				write !,"PID ",pid," not found."
			} else {
				set jobs(jobnum)=pid_","_jobid
			}
		}
		if $data(jobs)<10 {
			write !,"No PIDs selected"
			return 0
		}
		set jobs=""
		return 1
	} catch {
		return:$ze["INTERRUPT" 0
		throw
	} 
}
	/* AskAnalysis(s,fdims)
	   Ask the user for an analysis dimension list.  If 'fdims' is
	   non-null then the list must begin with 'fdims' and include
	   at least one additional dimension.  Returns null if the user
	   cancelled input or the complete dimension list (including
	   the fdims, if specified)
	 */
AskAnalysis(s,fdims="") PRIVATE {
	do GetDimensionHelp(s,.d)
	try {
		write !,"Specify a comma-delimited list of dimensions upon which to analyze samples."
		write !,"For example, ""state,ns,rou"" means first count each unique state the sampled"
		write !,"processes were in; then for each state, count the namespace from the samples"
		write !,"in that state; and finally for each state->namespace pair, count each unique"
		write !,"routine name.  In other words, report on routines by namespace by state."
        write !
        write !,"The following dimensions are available:"
        set d=$order(d(""))
        while d'="" { 
      		continue:$get(d(d,"hidden"))
        	write !,"  ",d," - ",$$DisplayDimension(d)," (",d(d),")"
        	set d=$order(d(d))
        }
        write !
        for {
	        set dims=""
	        if fdims="" {
				set prompt="Enter dimension list:"
	        } else {
		        write !,"This analysis starts with ",fdims_"."
			    set prompt="Enter additional dimensions: "_fdims_","
	        }
			set rc=##class(%Library.Prompt).GetString(prompt,.dims,,,,8)
			quit:rc'=1||(dims="")
			set dims=$zcvt($translate(dims," ",""),"l")
			set:fdims'="" dims=fdims_","_dims
			kill used
			set ok=1
			for i=1:1:$length(dims,",") { 
				set d=$piece(dims,",",i)
				if (d="") || '$data(d(d)) {
					write !!,"  Invalid string!",!
					set ok=0
					quit
				}
				if $get(used(d)) {
					write !!,"  Dimension ",d," included more than once!",!
					set ok=0
					quit
				}
				set used(d)=1
			}
			return:ok dims
        }
        return ""
	} catch {
		return:$ze["INTERRUPT" ""
		throw
	} 
}
	/* CHUIAnalyzer(s)
	   Run the visual analyzer tool on an array of samples 's'.
	   Stacks a new public array 'a' to be used for the analysis,
	   populates it with an initial default set, and provides
	   options for the user to add others.
	 */
CHUIAnalyzer(s) [a] PUBLIC {
	set $zt="err"
	new a,%lkps,%screen,%mode
	set a=$get(s)
	if a="" || '$piece(a,",",5) {
		write !!,"No samples to analyze",!
		quit
	}
	; set up some default analyses
	set %mode=0
	; set up some default analyses
	if $piece(a,",",1)="Jobs" {
		if ($piece(a,",",6)=$piece(a,",",7)) {
			; just a single job was sampled
			set a(1)="cpu,state"
			set a(2)="cpu,rou,ns,state"
			set a(3)="state,rou"
			set a(4)="waits,rou"
		} else {
			; multiple jobs.
			set a(1)="cpu,pid,state"
			set a(2)="cpu,rou,ns,state"
			set a(3)="state,rou,pid"
			set a(4)="waits,rou,pid"
		}
	} elseif $piece(a,",",1)="ECPS" {
		; does the kernel support GetServerReq()?
		set getreq=$piece(s,",",6)
		if getreq {
			if ($piece(a,",",6)=$piece(a,",",7)) {
				; a single connection
				set a(1)="cpu,state"
				set a(2)="req"
				set a(3)="state,glo"
				set a(4)="waits,glo"
			} else {
				; multiple connections
				set a(1)="cpu,connid,state"
				set a(2)="req,connid"
				set a(3)="state,glo"
				set a(4)="waits,connid,glo"
			}
		} else {
			set a(1)="cpu,connid"
			set a(2)="state,connid"
			set a(3)="waits,connid"
		}
	}
	write !,"Analyzing..."
	do Analyze(.s)
run
	set $zt="runerr"
	set rc=$$CHUISelector(.s)
	; currently no return values of interest
	quit
runerr
	set $zt="err"
	write !,"Error running analyzer: ",$ze
	set yn=1,rc=##class(%Library.Prompt).GetYesNo("Retry? ",.yn,,8)
	quit:rc'=1||'yn
	goto run
err
	write !,"Error: ",$ze
}
	/* CHUISelector(root,ancestorspec)
	   Recursive subroutine of CHUIAnalyzer() to sort and display
	   the count for each unique value within a given dimension of
	   analysis.  The user can select a value, making a recursive
	   call to drill into the next dimension of data points with
	   the selected value.
	   'root' and 'ancestorspec' have similar meaning as in
	   SortDim().  The dimension of analysis to display is the one 
	   in the 'a' public array beneath 'root'.  If the dimension is
	   heirarchical, and ancestorspec="", the heirarchy may be
	   ignored if the number of unique values is small.  If
	   ancestorspec is not null then the set of values displayted are
	   all those that are one level below 'ancestorspec' in the
	   heirarchy, plus 'ancestorspec' itself if there are data points
	   with that value directly.  'ancestorspec' must include the
	   leading ancestry count followed by the heirarchy delimiter.
	   Calling with ancestorspec=0 causes the first level of the
	   heirarchy to be displayed.
	 */
CHUISelector(s,root="",ancestorspec="") [a] {
	set $ztrap="err"
	set origancestorspec=ancestorspec
	do:$get(%screen) %screen.Exit(1)
	new %screen,%portion
	set %screen=##class(%Library.CHUIScreen).%New()
	do %screen.AddLine("PERFSAMPLE for "_$case($piece(a,",",1),"Jobs":"Local Process Activity","ECPS":"ECP Server Requests")_".  "_$j($piece(a,",",4),0,2)_"s at "_$zdatetime($piece(a,",",2,3)))
	do %screen.AddLine($select($piece(a,",",6)=$piece(a,",",5):$piece(a,",",6)_" samples",
	                                      1:$piece(a,",",5)_" events in "_$piece(a,",",6)_" samples "_$$DisplayCount($piece(a,",",5),0,0))_
	                   $select($select($piece($get(a(1)),",",1)="cpu":$get(a(1,1)),1:"")'="":"  |  CPULoad* "_$justify($select($piece($get(a(1)),",",1)="cpu":$get(a(1,1)),1:"")/$piece(a,",",7),0,2),1:""))
	do:'($piece(a,",",6)=$piece(a,",",7)) %screen.AddLine("Multiple jobs included: "_$piece(a,",",7)_" samples per job")
	do %screen.AddLine("","separator")
	do %screen.AddLine("","locator")
	set $piece(separator,"-",%screen.HorizontalSize)=""
	set $extract(separator,30,42)="'?' for help"
restart
	if root="" {
		; A list of analyses to select
		set locator="Select an analysis to view:"
		do %screen.AddSelectorItem("New Analysis (press '+' any time)","new")
		set i=$order(a(0))
		while i {
			; Include all positive-numbered analyses.  Others are hidden/internal.
			set tmp=%screen.AddSelectorItem($$DisplayDimensionList(a(i)),i)
			set:'%screen.Selected %screen.Selected=tmp
			set i=$order(a(i))
		}
		goto page
	}
	; we're at some dimension of analysis, possibly at an ancestor level
	; of a heirarchy within one of the dimensions
	set d=$$GetDimensionInfo(root,.dims,.dnum,.delim)
	; if we're starting a heirarchical dimension (ancestorspec="")
	; and the # unique values is small, treat it non-heirarchically.
	if ancestorspec="" { 
		do SortDim(root,.sorted)
		if (delim'="") && (sorted>8) {
			set ancestorspec=0
			do SortDim(root,.sorted,ancestorspec)
		}
	} else {
		do SortDim(root,.sorted,ancestorspec)
	}
buildlist
	set cnt=$order(sorted(""))
	if ancestorspec && @root@(ancestorspec) {
		; We're working on a heirarchy and the ancestor has data points
		; itself, so display the ancestor as the first option to select.
		; idx="" denotes that.
		set idx=""
	} else {
		set idx=$order(sorted(cnt,""))
		if (ancestorspec'="") && (sorted=1) && (sorted(cnt,idx)) {
			; We're in a heirarchy level with only one result to show
			; and there are descendants.  Descend a level.
			set ancestorspec=idx
			do SortDim(root,.sorted,ancestorspec)
			goto buildlist
		}
	}
	; Set up %portion and %mode for displaying counts
	; %portion is # samples that for this root & ancestor
	; We may need to interchange mode 3 and 4.  3 expresses the counts
	; as an avg number of jobs in the given state at any one time during
	; the samples and 4 expresses the same thing as a percentage of a
	; single job's time.  If we're only looking at one job, then use
	; 4, since it's easier to understand as a percentage of one job's
	; time than as a fractional number of jobs.
	if (%mode=3)||(%mode=4) {
		set i=1
		do { 
			quit:$piece(dims,",",i)=$case($piece(a,",",1),"Jobs":"pid","ECPS":"connid")
		} while $increment(i)<=dnum
		set %mode=$select(i<=dnum:4,1:3)
	}	
	set dispmode=%mode ; the %mode with which we've built the display list	
	set %portion=$select(ancestorspec:@root@(ancestorspec)+$piece(@root@(ancestorspec),",",2),
	                           dnum>1:@root,
	                                1:$piece(a,",",5))
	set locator=$$DisplayLocator(.s,root,ancestorspec,
	                             $select(%mode<2:%mode, ; %-total or raw counts: use the same in the locator
	                                     %mode=2:0,	; %-subset needs %-total in the locator for scale    
	                                     %mode=3:0, ; #jobs is meaningful on its own so locator gets %-total samples
	                                     ancestorspec||(i<dnum):4, ; %-time uses %-time if the locator is isolated to 1 job
	                                     1:3)) ; otherwise this is the primary dimensnsion so show earlier dimension as # jobs
	; now let's build the list of items to select
	do {
		if idx="" {
			; ancestor that has data points itself goes first in the list.
			set v=ancestorspec,c=+@root@(ancestorspec)
			set desccnt=0 ; we are displaying its descendants so they don't count for this line 
		} else {
			set v=idx,c=-cnt
			set desccnt=+sorted(cnt,idx)
		}
		set line=$$DisplayValue(v,d,.s)_$select(desccnt:"...  ",1:"  ")
		if $length(line)+30<%screen.HorizontalSize {
			; add a visual tab before the DisplayCount
			set $extract(line,$length(line)+20-($length(line)#20))=$$DisplayCount(c,desccnt)
		} else { 
			set line=line_$$DisplayCount(c,desccnt)
		}
		do %screen.AddSelectorItem(line,idx)
		; get next item
		set idx=$order(sorted(cnt,idx))
		if idx="" {
			set cnt=$order(sorted(cnt))
			set:cnt'="" idx=$order(sorted(cnt,idx))
		}
	} while	(cnt'="") && (idx'="")
page
	do %screen.UpdateField("separator",separator)
	do %screen.UpdateField("locator",locator)
	do %screen.Draw(1)
	zt:%screen.TruncLine "SCRN"
	for  {
		write *-10
		set act=%screen.SelectorInput()
		set val=%screen.SelectedName
		set new=0
		if act="help" {
			do %screen.Exit(1)
			write "PERFSAMPLE Analyzer Help"
			write !,"------------------------"
			write !,"Use up and down arrow keys, or 'u' and 'd', to highlight an item."
			write !,"Right arrow or Enter selects the item to show the next level of detail."
			write !,"Left arrow or Backspace goes back a level.  'q' quits."
			write !,"'n'/'p' and ctrl-d/ctrl-u go to next/previos page (page down/up)"
			write !
			write !,"'c' cycles through modes for displaying counts of samples:"
			write !,"  %-total  ->  #samples  ->  %-subset  (And if multiple jobs were sampled...)"
			write !,"  [ ->  jobs: #samples/(#samples/job) = avg concurrent jobs in this state"
			write !,"    OR  %-time: % of this job's samples (% of its time spent in this state)  ]"
			write !
			write !,"'+' adds a dimension to the analysis under the highlighted item."
			write !,"'*' begins a new analysis with the highlighted item as the first dimension." 
			write !
			write !,"Some dimensions of analysis have a heirarchical organization."
			write !,"Selecting an ancestor, denoted with ..., moves down a heirarchy level."
			write !,"Selecting a non-ancestral item goes to the next dimension of analysis."
			write !,"  'h' toggles between this heirarchical view and a ""flattened"" view."
			write !,"  'a' on an ancestor aggregates subsequent dimensions for all its descendants."
			write !
			write !,"*CPU is estimated from sampled states, not a measure of true on-cpu time."
			read *tmp
			goto page
		}
		if (act="quit") || (act="back") { 
			return act
		}
		if (act="c") && (root'="") {
			; cycle through display modes
			set %mode=$select(($piece(a,",",6)=$piece(a,",",7)):%mode+1#3,
			                  %mode>2:0,
			                  1:%mode+1)
			do %screen.ClearSelector(1)
			goto buildlist
		}
		if (act="h") && (root'="") {
			if (delim="") {	write /bel continue } ; not a heirarchical dimension
			; If we're in non-heirarchical view, toggle to ancestorspec=0
			if (ancestorspec="") {
				do %screen.ClearSelector(0)
				set ancestorspec=0
				do SortDim(root,.sorted,ancestorspec)
				goto buildlist
			}
htoggleoff	; We're at some heirarchy level.  Toggle it off.
			; Return if this is a recursive call from a higher level 
			; of the heirarchy since we don't want intermediate levels
			; on the stack when the user goes "back" from here.
			return:origancestorspec act
			do %screen.ClearSelector(0)
			set ancestorspec=""
			do SortDim(root,.sorted)
			goto buildlist
		}
		if (act="+") || ((act="*") && (root'="")) ||
		   ((root="") && (act="select") && (val="new")) {
			; A new analysis specified by the user
			; + means add dimensions to the current location
			; * means new analysis starting with selected item as dimension #1
			do %screen.Exit(0)
			if root="" {
				write !!,"New Analysis:",!
				set tmp=$$AskAnalysis(.s)
			} else {
				if act="+" {
					write !!,"Add Dimensions Following Selected Item:",!
					set tmp=$$AskAnalysis(.s,$piece(dims,",",1,dnum))
				} else { ; act="*"
					write !!,"New Analysis With Selected Item as First Dimension:",!
					set tmp=$$AskAnalysis(.s,d)
				}
			}
			goto:tmp="" page
			set aidx=$$AddAnalysis(tmp,.new)
			if new {
				write !,"Analyzing..."
				do Analyze(.s)
				set:root'="" dims=@$name(@root,1)
			}
			; recurse into it
			if root="" { 
				set nextroot=$name(a(aidx))
			} else {
				if act="+" {
					; build the new root with (presumably) different idx
					set tmp=$piece(root,",",2,*) ; all subscripts after the first
					set nextroot=$select(tmp="":$name(a(aidx)),1:"a("_aidx_","_tmp)
				} else { ; act="*"
					set nextroot=$name(a(aidx))
				}
				if (val'="") && (ancestorspec'="") && $piece(@root@(val),",",2) {
					; An ancestor is selected in heirarchical mode
					; so this is like the 'a' action
					set nextroot=$$AnalyzeHeirarchy(nextroot,val)
				} else {
					; normal value
					set nextroot=$name(@nextroot@(val))
				}
			}
			set nextanc=""
			goto recurse
		}
		if (act="select") {
			if root="" {
				return:'val val
				set nextroot=$name(a(val))
				set nextanc=""
			} else {
				if val="" {
					; 'ancestorspec' itself has data points and was selected
					; Move to the next dimension in the analysis
					if dnum'<$length(dims,",") { write /bel continue }
					set nextroot=$name(@root@(ancestorspec))
					set nextanc=""
				} elseif ancestorspec'="" && $piece(@root@(val),",",2) {
					; This is a heirarchical display and there are descendants
					; so display a page for the descendants rather than the next
					; dimension in the analysis
					set nextroot=root
					set nextanc=val
				} else {
					; Move to the next dimension in the analysis
					if dnum'<$length(dims,",") { write /bel continue }
					set nextroot=$name(@root@(val))
					set nextanc=""
				}
			}
recurse		set rc=$$CHUISelector(.s,nextroot,nextanc)
			return:(rc="quit")&&(root'="") rc
			goto:rc="h" htoggleoff
			; On return from recursion, we at least have to call Draw()
			if (root="") {
				; The list of analyses could have been expanded by the caller 
				do %screen.ClearSelector(1)
				goto restart
			}
			; The user could have added dimensions under this one
			set dims=@$name(@root,1)
			if (%mode=dispmode) || ((%mode>=3) && (dispmode>=3)) {
				; %mode hasn't been changed (interchange of 3 and 4 not
				; withstanding), so we can just Draw() what we have.
				goto page
			}
			; build the list with the new %mode
			do %screen.ClearSelector(1)
			goto buildlist
		}
		if (act="a") && (root'="") {
			; We're asked to aggregate further dimensions for all nodes under a
			; selected ancestor
			if (dnum'<$length(dims,",")) || 
			   (val="") || (ancestorspec="") || '$piece(@root@(val),",",2) {
				write /bel
				continue
			}
			set nextroot=$$AnalyzeHeirarchy(root,val)
			set nextanc=""
			goto recurse
		}
	}
	return "back" ; shouldn't get here
err
	return:$ze["<INTERRUPT>"
	set $ztrap=""
	ztrap $zerror
}
DisplayCount(cnt,desccnt=0,mode) [a] {
	set mode=$get(mode,%mode)
	if mode=0 {
		; % of total
		set num=$fnumber(cnt*100/$piece(a,",",6),"g",2)
		set unit=" %-total"
	} elseif mode=1 {
		; display the raw count
		set num=+cnt
		set unit=""
	} elseif mode=2 {
		; % of the portion belonging to the selected subset
		set num=$fnumber(cnt*100/%portion,"g",2)
		set unit=" %-subset"
	} elseif mode=3 {
		; avg number of jobs in this state at any one time
		set num=$fnumber(cnt/$piece(a,",",7),"g",2)
		set unit=" jobs"  ; $$$aPerJobCnt is samples/job, so this is samples/(samples/job)=jobs
	} elseif mode=4 {
		; % of one job's time spent in this state
		; used when we've selected a single PID or connection
		set num=$fnumber(cnt*100/$piece(a,",",7),"g",2)
		set unit=" %-time"
	}
	quit "["_num_unit_"]"
}
DisplayLocator(s,root,ancestorspec,mode) [a] PRIVATE {
	set mode=$get(mode,%mode)
	set dims=@$name(@root,1)
	set line="",ql=$qlength(root),i=2
	while i<=ql {
		set d=$piece(dims,",",i-1)
		set line=line_$$DisplayDimension(d)_" ["_$$DisplayValue($qsubscript(root,i),d,.s)_"] -> "
		set i=i+1
	}
	set d=$piece(dims,",",i-1)
	set line=line_$$DisplayDimension(d)
	set line=line_$select(ancestorspec="":	"",
	                      'ancestorspec:	" {...top of heirarchy...}",
		                  1:				" {"_$$DisplayValue(ancestorspec,d,.s)_"...}")
	set line=line_" "_$$DisplayCount(%portion,0,mode)
	quit line
}

PKI^INT^1^67214,47331
PKI ; Public Key Infrastructure
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 Do MENU()
 Quit
MENU() PUBLIC { 
 Set $zt="ERROR"
 Set List(1)=$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2769985424"),"Certificate Authority client")
 Set List(2)=$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"942886451"),"Certificate Authority server")
 For {
 	Set Value=""
	Set Status=##class(%Library.Prompt).GetMenu($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3110499854"),"Select option:"),.Value,.List,,8+128+4)
 	If (+Status=0)||(Status=2)||(Value="") Quit
 	If Value=1 Do CAClient() Continue
 	If Value=2 Do CAServer() Continue
 }
 Quit
ERROR s $zt=""
 If $ze["<INTERRUPT>" Quit 0
 ztrap $ze
}
CAClient() {
 Set $zt="ERROR"
 Set List(1)=$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2228826969"),"Submit Certificate Signing Request to Certificate Authority server")
 Set List(2)=$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"4240755377"),"Get Certificate(s) from Certificate Authority server")
 Set List(3)=$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2372771294"),"Configure local Certificate Authority client")
 For {
 	Set Value=""
	Set Status=##class(%Library.Prompt).GetMenu($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3110499854"),"Select option:"),.Value,.List,,8+128+4)
 	If (+Status=0)||(Status=2)||(Value="") Quit
 	If Value=1 Do SubmitCSR() Continue
 	If Value=2 Do GetCertificate() Continue
 	If Value=3 Do ConfigureClient() Continue
 }
 Quit
ERROR Set $zt=""
 If $ze["<INTERRUPT>" Quit 0
 ztrap $ze
}
SubmitCSR() {
 Set $zt="ERROR"
 If '$SYSTEM.Security.Check("%Admin_Secure","USE") Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2529476099"),"Operation requires %Admin_Secure:Use privilege") Quit
 Set client=##class(PKI.CAClient).%OpenId("IRIS CA")
 If '$ISOBJECT(client) Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2978617499"),"Certificate Authority client not configured.") Quit
prompt
 Set Value=""
 Set Status=##class(%Library.Prompt).GetString($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1126793698"),"File name root for local Certificate and Private Key files (without extension):"),.Value,1,100,,8)
 If (+Status=0)||(Status=2)||(Value="") Quit
 If '(Value?.(1AN,1"_",1"-")) {
	 Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"4173578851"),"Illegal characters in name.")
	 goto prompt
 }
 If ($ZCONVERT(Value,"L")="iris") {
	 Write !,Value,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1750949141")," is a reserved name.")
	 goto prompt
 }
 Set name=Value
 Set password1=""
 Set password2=""
nextpass
 Set Value=""
 Use:$ZU(96,14)=1 0:(:"+S")
 Set Status=##class(%Library.Prompt).GetString($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2762632196"),"Private Key password (optional):"),.Value,0,100,,8)
 Use:$ZU(96,14)=1 0:(:"-S")
 If (+Status=0)||(Status=2) Quit
 Set password=Value
 If password'="" {
	Set Value=""
	Use:$ZU(96,14)=1 0:(:"+S")
	Set Status=##class(%Library.Prompt).GetString($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"978021831"),"Confirm password:"),.Value,0,100,,8)
	Use:$ZU(96,14)=1 0:(:"-S")
	If (+Status=0)||(Status=2) Quit
	If password'=Value Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1721163963"),"Values do not match.") Quit
 }
 For i=1:1:$L(client.AttributePrompt,",") Set List(i)=$p(client.AttributePrompt,",",i)
 Set attrList=""
 Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"112545658"),"Subject Distinguished Name:")
 For {
 	Set Type=""
	Set Status=##class(%Library.Prompt).GetMenu($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"548923624"),"Select attribute type:"),.Type,.List,,8+128+4)
 	If (+Status=0)||(Status=2)||(Type="") Quit
 	Set Value=""
 	Set Status=##class(%Library.Prompt).GetString($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"442056759"),"Attribute value:"),.Value,1,100,,8)
 	If (+Status=0)||(Status=2)||(Value="") Quit
 	If (Type=1)&& ($L(Value)'=2) {
	 	Write !!,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2703112699"),"Country value must be exactly two characters long.")
	 	Continue
	}
	Set $LIST(attrList,Type)=Value
	Write !!,"Current value:",!,client.BuildSubject(attrList)
 }
 If attrList="" {
	 Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1973969079"),"Subject Distinguished Name cannot be empty.")
	 Quit
 }
 Set Value=1
 Set Status=##class(%Library.Prompt).GetYesNo($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2946266450"),"Confirm Certificate Signing Request submission?"),.Value,,8)
 If (+Status=0)||(Status=2)||(Value="") Quit
 If Value=1 {
	Set Status=client.SubmitCSR(name,attrList,password,.st)
	If (''st) { Write !,Status }
	ElseIf ($ZE["<ZSOAP>") && $ISOBJECT(st) { Write !,st.faultstring }
	Else { Write !,##class(%SYSTEM.Status).GetErrorText(st) }
 }
 Quit
ERROR Set $zt=""
 If $ze["<INTERRUPT>" Quit 0
 ztrap $ze
}
GetCertificate() {
 Set $zt="ERROR"
 If '$SYSTEM.Security.Check("%Admin_Secure","USE") Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2529476099"),"Operation requires %Admin_Secure:Use privilege") Quit
 Set client=##class(PKI.CAClient).%OpenId("IRIS CA")
 If '$ISOBJECT(client) Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2978617499"),"Certificate Authority client not configured.") Quit
 Set List(1)=$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"352136140"),"List certificates issued for this instance")
 Set List(2)=$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3246575010"),"List all issued certificates")
 Set List(3)=$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2484500178"),"Get Certificate Authority Certificate")
 Set Value=""
 Set Status=##class(%Library.Prompt).GetMenu($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3110499854"),"Select option:"),.Value,.List,,8+128+4)
 If (+Status=0)||(Status=2)||(Value="") Quit
 If Value=1 {
	 Set hostname=##class(%SYS.System).GetNodeName()
	 Set instance=##class(%SYS.System).GetInstanceName()
	 Set Rset = client.ListCertificates(hostname, instance)
	 If '(''Rset) Do $SYSTEM.Status.DisplayError(%objlasterror) Quit
	 If 'Rset.Next() {
		 Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3073976168"),"No Certificates issued for this instance.")
		 Quit
	 }
	 Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3079124671"),"Certificates issued for instance ")_instance_$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2557207611")," on node ")_hostname_":",!
	 Write !,Rset.GetColumnName(1)
	 Write ?10,Rset.GetColumnName(2)
	 Write !,$$UL(Rset.GetColumnName(1))
	 Write ?10,$$UL(Rset.GetColumnName(2))
	 Do {
		 Write !,Rset.Data(Rset.GetColumnName(1))
		 Write ?10,Rset.Data(Rset.GetColumnName(2))
	 } While Rset.Next()
	 Write !
 	 Set Value=""
	 Set Status=##class(%Library.Prompt).GetNumber($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2127131962"),"Certificate number:"),.Value,,,,8+512)
	 If (+Status=0)||(Status=2)||(Value="") Quit
	 Set Number=Value
 } ElseIf Value=2 {
	 Set Rset = client.ListCertificates()
	 If '(''Rset) Do $SYSTEM.Status.DisplayError(%objlasterror) Quit
	 If 'Rset.Next() {
		 Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"603413621"),"No issued Certificates.")
		 Quit
	 }
	 Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3214852922"),"Issued Certificates:"),!
	 Write !,Rset.GetColumnName(1)
	 Write ?10,Rset.GetColumnName(2)
	 Write ?45,Rset.GetColumnName(3)
	 Write ?60,Rset.GetColumnName(4)
	 Write !,$$UL(Rset.GetColumnName(1))
	 Write ?10,$$UL(Rset.GetColumnName(2))
	 Write ?45,$$UL(Rset.GetColumnName(3))
	 Write ?60,$$UL(Rset.GetColumnName(4))
	 Do {
		 Write !,Rset.Data(Rset.GetColumnName(1))
		 Write ?10,Rset.Data(Rset.GetColumnName(2))
		 Write:$x>45 ! Write ?45,Rset.Data(Rset.GetColumnName(3))
		 Write:$x>60 ! Write ?60,Rset.Data(Rset.GetColumnName(4))
	 } While Rset.Next()
	 Write !
 	 Set Value=""
	 Set Status=##class(%Library.Prompt).GetNumber($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2127131962"),"Certificate number:"),.Value,,,,8+512)
	 If (+Status=0)||(Status=2)||(Value="") Quit
	 Set Number=Value
 } ElseIf Value=3 {
	 Set Number=0
 }
 Set Status=client.GetCertificate(Number,.st)
 If (''st) { Write !,Status }
 ElseIf ($ZE["<ZSOAP>") && $ISOBJECT(st) { Write !,st.faultstring }
 Else { Write !,##class(%SYSTEM.Status).GetErrorText(st) }
 Quit
ERROR Set $zt=""
 If $ze["<INTERRUPT>" Quit 0
 ztrap $ze
}
ConfigureClient() {
 Set $zt="ERROR"
 If '$SYSTEM.Security.Check("%Admin_Secure","USE") Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2529476099"),"Operation requires %Admin_Secure:Use privilege") Quit
 Set client=##class(PKI.CAClient).%OpenId("IRIS CA")
 If '$ISOBJECT(client) Set client=##class(PKI.CAClient).%New()
 Set Value=client.Server
 Set Status=##class(%Library.Prompt).GetString($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"836724224"),"Certificate Authority server hostname:"),.Value,1,100,,8)
 If (+Status=0)||(Status=2)||(Value="") Quit
 Set client.Server=Value
 Set Value=client.Port
 Set Status=##class(%Library.Prompt).GetNumber($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2975247674"),"Certificate Authority server port number:"),.Value,1,65535,,8)
 If (+Status=0)||(Status=2)||(Value="") Quit
 Set client.Port=Value
 Set Value=client.Path
 Set Status=##class(%Library.Prompt).GetString($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1497193697"),"Certificate Authority server path:"),.Value,1,100,,8)
 If (+Status=0)||(Status=2)||(Value="") Quit
 Set client.Path=Value
 Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3667849460"),"Local technical contact:")
 Set Value=client.ContactName
 Set Status=##class(%Library.Prompt).GetString($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1022533488"),"Name:"),.Value,1,100,,8)
 If (+Status=0)||(Status=2)||(Value="") Quit
 Set client.ContactName=Value
 If $L(client.ContactName) {
	 Set Value=client.ContactPhone
	 Set Status=##class(%Library.Prompt).GetString($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"785545014"),"Phone number:"),.Value,0,100,,8)
	 If (+Status=0)||(Status=2) Quit
	 Set client.ContactPhone=Value
	 Set Value=client.ContactEmail
	 Set Status=##class(%Library.Prompt).GetString($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1738842227"),"Email address:"),.Value,0,100,,8)
	 If (+Status=0)||(Status=2) Quit
	 Set client.ContactEmail=Value
 }
 Set Value=1
 Set Status=##class(%Library.Prompt).GetYesNo($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2556997463"),"Confirm Certificate Authority client configuration?"),.Value,,8)
 If (+Status=0)||(Status=2)||(Value="") Quit
 If Value=1 {
	 Set Status=##class(PKI.CAClient).Configure(client,.st)
	 If (''st) { Write !,Status }
	 Else { Write !,##class(%SYSTEM.Status).GetErrorText(st) }
 }
 Quit
ERROR Set $zt=""
 If $ze["<INTERRUPT>" Quit 0
 ztrap $ze
}
CAServer() {
 Set $zt="ERROR"
 Set List(1)=$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1364511770"),"Process pending Certificate Signing Request(s)")
 Set List(2)=$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"272911485"),"Configure local Certificate Authority server")
 For {
 	Set Value=""
	Set Status=##Class(%Library.Prompt).GetMenu($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3110499854"),"Select option:"),.Value,.List,,8+128+4)
 	If (+Status=0)||(Status=2)||(Value="") Quit
 	If Value=1 Do Sign() Continue
 	If Value=2 Do ConfigureServer() Continue
 }
 Quit
ERROR Set $zt=""
 If $ze["<INTERRUPT>" Quit 0
 ztrap $ze
}
Sign() {
 Set $zt="ERROR"
 If '$SYSTEM.Security.Check("%Admin_Secure","USE") Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2529476099"),"Operation requires %Admin_Secure:Use privilege") Quit
 Set server=##class(PKI.CAServer).%OpenId("IRIS CA")
 If '$ISOBJECT(server) Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2585170346"),"Certificate Authority server not configured.") Quit
 Set Rset = ##class(%Library.ResultSet).%New("PKI.CSR:List")
 If '(''Rset) Do $SYSTEM.Status.DisplayError(%objlasterror) Quit
 Do Rset.Execute()
 If 'Rset.Next() {
	 Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3691445333"),"No pending Certificate Signing Requests.")
	 Quit
 }
 Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"295460316"),"Pending Certificate Signing Request(s):")
 Write !,?5,Rset.GetColumnName(2)
 Write ?40,Rset.GetColumnName(3)
 Write ?55,Rset.GetColumnName(4)
 Write !,?5,$$UL(Rset.GetColumnName(2))
 Write ?40,$$UL(Rset.GetColumnName(3))
 Write ?55,$$UL(Rset.GetColumnName(4))
 Set i=0
 Do {
	Set i=i+1
	Set List(i)=Rset.Data(Rset.GetColumnName(1))
	Write !,i,")"
	Write ?5,Rset.Data(Rset.GetColumnName(2))
	Write:$x>40 ! Write ?40,Rset.Data(Rset.GetColumnName(3))
	Write:$x>55 ! Write ?55,Rset.Data(Rset.GetColumnName(4))
 } While Rset.Next()
 Write !
 Set Value=""
 Set Status=##class(%Library.Prompt).GetNumber($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1371711935"),"Select Certificate Signing Request:"),.Value,1,i,,8+512)
 If (+Status=0)||(Status=2)||(Value="") Quit
 Set Name=List(Value)
 Set csr=##class(PKI.CSR).%OpenId(Name)
 If '$ISOBJECT(csr) Quit
 Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"181162803"),"Request source:")
 Write !,?5,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3640585071"),"Hostname: "),csr.Hostname
 Write !,?5,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3013527077"),"Instance: "),csr.Instance
 Write !,?5,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3508475563"),"Filename: "),csr.Filename
 Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1678915791"),"Request content: ")
 Write !,?5,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1505419816"),"Subject Distinguished Name: "),csr.GetSubject()
 Write !,?5,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2506155066"),"SHA-256 Fingerprint: "),csr.GetSHA256Fingerprint()
 Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"4061566924"),"Technical contact:")
 Write !,?5,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3109375206"),"Name: "),csr.ContactName
 Write !,?5,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"653822123"),"Phone number: "),csr.ContactPhone
 Kill List
 Set List(1)=$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2249041824"),"Issue Certificate for TLS/SSL and XML security")
 Set List(2)=$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"187896277"),"Issue Certificate for Intermediate Certificate Authority")
 Set List(3)=$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"4206862092"),"Issue Certificate for code signing verification")
 Set List(4)=$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3925580311"),"Delete Certificate Signing Request")
 Set Value=1
 Set Status=##Class(%Library.Prompt).GetMenu($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3110499854"),"Select option:"),.Value,.List,,8+128+4)
 If (+Status=0)||(Status=2)||(Value="") Quit
 If Value=4 {
	Set Value=0
	Set Status=##class(%Library.Prompt).GetYesNo($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2632049671"),"Confirm Certificate Signing Request deletion?"),.Value,,8)
	If (+Status=0)||(Status=2)||(Value="") Quit
	If Value=1 {
		Do ##class(PKI.CSR).%DeleteId(Name)
		Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1462235849"),"Certificate Signing Request deleted.")
	}
	Quit
 }
 Write !!,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"292645454"),"WARNING!")
 Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3386538165"),"Before issuing a Certificate you must speak with the Technical Contact listed")
 Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2722515424"),"above, and verify:")
 Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"67079745"),"1. Their identity.")
 Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"900643801"),"2. Their authority to hold a certificate containing the Subject Distinguished")
 Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3421236426"),"   name shown above, signed by this Certificate Authority.")
 Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"390144011"),"3. That the SHA-256 Fingerprint shown above matches the one reported to them when")
 Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"633448467"),"   they submitted the Certificate Signing Request.")
 Write !
 Set certType=Value
 Set Value=""
 Use:$ZU(96,14)=1 0:(:"+S")
 Set Status=##class(%Library.Prompt).GetString($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2319294689"),"Password for Certificate Authority's Private Key file:"),.Value,1,100,,8)
 Use:$ZU(96,14)=1 0:(:"-S")
 If (+Status=0)||(Status=2) Quit
 Set password=Value
 Set Status=server.Sign(Name,password,certType,.st)
 If (''st) { Write !,Status }
 Else { Write !,##class(%SYSTEM.Status).GetErrorText(st) }
 Quit
ERROR Set $zt=""
 If $ze["<INTERRUPT>" Quit 0
 ztrap $ze
}
ConfigureServer() {
 Set $zt="ERROR"
 If '$SYSTEM.Security.Check("%Admin_Secure","USE") Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2529476099"),"Operation requires %Admin_Secure:Use privilege") Quit
 Set server=##class(PKI.CAServer).%OpenId("IRIS CA")
 If $ISOBJECT(server) {
	 Set Value=0
	 Set Status=##class(%Library.Prompt).GetYesNo($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2431945315"),"Reinitialize Certificate Authority server?"),.Value,,8)
	 If (+Status=0)||(Status=2)||(Value="") Quit
	 If Value=1 {
		 Write !!,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"292645454"),"WARNING!")
		 Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1391437632"),"This will delete the Certificate Authority server configuration and")
		 Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2474078361"),"all stored Certificates and pending Certificate Signing Requests.")
		 Set Value=0
		 Set Status=##class(%Library.Prompt).GetYesNo($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3254389078"),"Confirm Certificate Authority server reinitialization?"),.Value,,8)
		 If (+Status=0)||(Status=2)||(Value="") Quit
		 If Value=1 {
			 Set server=""
			 Do ##class(PKI.CAServer).%DeleteId("IRIS CA")
			 Do ##class(PKI.CSR).%DeleteExtent()
			 Do ##class(PKI.Certificate).%DeleteExtent()
		 }
	 }
 }
 Set attrList=""
 Set password=""
 Set days=""
 If '$ISOBJECT(server) {
	 Set server=##class(PKI.CAServer).%New()
prompt
	 Set Value=""
	 Set Status=##class(%Library.Prompt).GetString($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2705323614"),"File name root for Certificate Authority's Certificate and Private Key files (without extension):"),.Value,1,100,,8)
	 If (+Status=0)||(Status=2)||(Value="") Quit
	 If '(Value?.(1AN,1"_",1"-")) {
		 Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3124818803"),"Illegal characters in file name root.")
		 goto prompt
	 }
	 If ($ZCONVERT(Value,"L")="iris") {
		 Write !,Value,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2180602812")," is a reserved file name root.")
		 goto prompt
	 }
	 Set server.CAFilename=Value
	 Set Value=""
	 Set Status=##class(%Library.Prompt).GetString($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"254666254"),"Directory for Certificate Authority's Certificate and Private Key files:"),.Value,0,100,,8)
	 If (+Status=0)||(Status=2) Quit
	 Set server.CAPath=##class(%Library.File).NormalizeDirectory(Value)
	 If '(##class(%Library.File).Exists(server.CAPath_server.CAFilename_".cer") &&  ##class(%Library.File).Exists(server.CAPath_server.CAFilename_".key")) {
		 Set Value=""
		 Use:$ZU(96,14)=1 0:(:"+S")
		 Set Status=##class(%Library.Prompt).GetString($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2319294689"),"Password for Certificate Authority's Private Key file:"),.Value,1,100,,8)
		 Use:$ZU(96,14)=1 0:(:"-S")
		 If (+Status=0)||(Status=2) Quit
		 Set password=Value
		 Set Value=""
		 Use:$ZU(96,14)=1 0:(:"+S")
		 Set Status=##class(%Library.Prompt).GetString($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"978021831"),"Confirm password:"),.Value,1,100,,8)
		 Use:$ZU(96,14)=1 0:(:"-S")
		 If (+Status=0)||(Status=2) Quit
		 If password'=Value Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1721163963"),"Values do not match.") Quit
		 For i=1:1:$L(server.AttributePrompt,",") Set List(i)=$p(server.AttributePrompt,",",i)
		 Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1841767271"),"Certificate Authority's Subject Distinguished Name:")
		 For {
		 	Set Type=""
			Set Status=##class(%Library.Prompt).GetMenu($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"548923624"),"Select attribute type:"),.Type,.List,,8+128+4)
		 	If (+Status=0)||(Status=2)||(Type="") Quit
		 	Set Value=""
		 	Set Status=##class(%Library.Prompt).GetString($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"442056759"),"Attribute value:"),.Value,0,100,,8)
		 	If (+Status=0)||(Status=2) Quit
		 	If (Type=1)&& ($L(Value)'=2) {
			 	Write !!,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2703112699"),"Country value must be exactly two characters long.")
			 	Continue
		 	}
		 	Set $LIST(attrList,Type)=Value
		 	Write !!,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3844781990"),"Current value:"),!,server.BuildSubject(attrList)
		 }
		 If attrList="" {
			 Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"922665575"),"Subject Distinguished Name can not be empty.")
			 Quit
		 }
		 Set Value=server.Days*10
		 Set Status=##class(%Library.Prompt).GetNumber($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2768323098"),"Validity period for Certificate Authority Certificate (days):"),.Value,1,36500,,8)
		 If (+Status=0)||(Status=2)||(Value="") Quit
		 Set days=Value
	 }
 } Else {
	 Write !,"Certificate Authority server filename: ",server.CAFilename
	 Write !,"Certificate Authority server file path: ",server.CAPath
 }
 Set Value=server.Days
 Set Status=##class(%Library.Prompt).GetNumber($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2036836288"),"Validity period for Certificates issued by Certificate Authority (days):"),.Value,1,36500,,8)
 If (+Status=0)||(Status=2)||(Value="") Quit
 Set server.Days=Value
 Write !,"Configure email:"
 Set Value=server.SMTPServer
 Set Status=##class(%Library.Prompt).GetString($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3419524308"),"SMTP server:"),.Value,0,100,,8)
 If (+Status=0)||(Status=2) Quit
 Set server.SMTPServer=Value
 If $L(server.SMTPServer) {
	 Set Value=server.SMTPUsername
	 Set Status=##class(%Library.Prompt).GetString($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1148207579"),"SMTP username:"),.Value,0,100,,8)
	 If (+Status=0)||(Status=2) Quit
	 Set server.SMTPUsername=Value
	 If $L(server.SMTPUsername) {
		 Set Value=""
		 Use:$ZU(96,14)=1 0:(:"+S")
		 Set Status=##class(%Library.Prompt).GetString($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2087001951"),"SMTP password:"),.Value,1,100,,8)
		 Use:$ZU(96,14)=1 0:(:"-S")
		 If (+Status=0)||(Status=2) Quit
		 Set server.SMTPPassword=Value
		 Set Value=""
		 Use:$ZU(96,14)=1 0:(:"+S")
		 Set Status=##class(%Library.Prompt).GetString($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"978021831"),"Confirm password:"),.Value,1,100,,8)
		 Use:$ZU(96,14)=1 0:(:"-S")
		 If (+Status=0)||(Status=2) Quit
		 If server.SMTPPassword'=Value Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1721163963"),"Values do not match.") Quit
	 }
	 Set Value=server.AdminEmail
	 Set Status=##class(%Library.Prompt).GetString($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"887856928"),"Certificate Authority server administrator's email address:"),.Value,1,100,,8)
	 If (+Status=0)||(Status=2)||(Value="") Quit
	 Set server.AdminEmail=Value
 }
 Set Value=1
 Set Status=##class(%Library.Prompt).GetYesNo($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2965048557"),"Confirm Certificate Authority server configuration?"),.Value,,8)
 If (+Status=0)||(Status=2)||(Value="") Quit
 If Value=1 {
	 Set Status=##class(PKI.CAServer).Configure(server,attrList,password,days,.st)
	 If (''st) { Write !,Status }
	 Else { Write !,##class(%SYSTEM.Status).GetErrorText(st) }
 }
 Quit
ERROR Set $zt=""
 If $ze["<INTERRUPT>" Quit 0
 ztrap $ze
}
UL(String) PRIVATE {
	s $P(x,"-",$l(String)+1)=""
	q x
}

PRIO^INT^1^67214,47331
PRIO ;(KSO,PK) Change M/DG system-wide base priority and delta
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 W !,"Not implemented for this release." Q

PROFILE^INT^1^67214,47331
PROFILE ; Routine profiler for ObjectScript code
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	/* clean up stack to the Execute or Shell and start chained prog */
	/* clean up stack to the Execute or Shell and resume caller shell */
	/* like stop but invoke ON.ABORT */
	/* clean up stack and exit MV shell  */
	/* clean up stack and halt cache process */
 ;
 ; display definitions - Percentages or Totals
 ; 
 ; piece definitions for Routine display in ^||%Profile.Display(line)
 ; first 'n' pieces are stats
 ; routine name
 ; database system
 ; database directory
 ; routine selected flag
 ; routine source name
 ;
 ; fetch pieces for Detail list in ^||%Profile.Routine(RoutineIndex)
 ; RoutineName ^ System ^ Directory ^ SourceName ^ DatabaseName
 ;  
 ; default for number of routines to monitor
 ; 
 ;
 d Start q
Start() private {
 i '($e($roles,1,$l("%All"))="%All") w !,"Insufficient privilege for operation" q
 s status=$$Status()
 i status="MONLBL" {
	 w !,"The Line-by-line Monitor (%SYS.MONLBL) is already enabled."
	 w !,"This must be stopped before ^PROFILE can be used.",!
	 q
 }
 i status="PERFMON" {
	 w !,"A performance monitoring session (^PERFMON) is already running."
	 w !,"This must be stopped before ^PROFILE can be used.",!
	 q
 }
 i status="STOPPED" {
	 s status=$$STARTROU()
	 i status'=1 {
		 w !!,"Error starting profiler: ",$p(status,",",2),!
		 s status=$$pause()
		 q
	 }
	 s status=$$Status()
	 i status="ROUTINE" {
		 w !!,"Waiting for initial data collection " f i=1:1:3 h 1 w "."
	 }
 }
 i status="ROUTINE" {
	 d DISPLAY()
	 s status=$$STARTDET() ; start a detail collection?
	 i status'=1 {
		 w !!,"Error collecting profiler detail: ",$p(status,",",2),!
		 s status=$$pause()
	 }
	 s status=$$Status()
 }
 i status="DETAIL" {
	 d DISPLAYD()
 }
 i status'="STOPPED" {
 	 d STOP()
 }
 k ^||%Profile.Sort,^||%Profile.Display,^||%Profile.Detail,^||%Profile.Routine
 q
 }	 
 ; 
 ; Start a routine level run
 ; Returns '1' for success, or a negative number followed by a "," and message
 ;
STARTROU() {
 w !!,"WARNING: This routine will start a system-wide collection of"
 w !,"data on routine activity and then display the results. There"
 w !,"may be some overhead associated with the initial collection, "
 w !,"and it could significantly affect a busy system.",!
 w !,"The second phase of collecting line level detail activity"
 w !,"has high overhead and should ONLY BE RUN ON A TEST SYSTEM!",!
 s mask=8+4
 s prompt="Are you ready to start the collection? ",response=1
 s status=##class(%Library.Prompt).GetYesNo(prompt,.response,"",mask)
 i +response=0 {
	 w !!,"No collection started.",! q 1
 }
 ; If there's a user default, see if we can start it
 s num=+$g(^SYS("MONITOR","PROFILE","ROUTINES"))
 i num {
	 s required=$zu(84,0,4,0,0,num,0,0),avail=$zu(84,0,5)
	 i required<avail s status=$$StartRou(num) i +status'=-3 q status
 }
 ; Otherwise, see if our default uses too much memory
 s num=5000,required=$zu(84,0,4,0,0,num,0,0),avail=$zu(84,0,5)
 i required>(avail*.75) {
	 f n=num:-500:500 {
		 i $zu(84,0,4,0,0,n,0,0)<($zu(84,0,5)*.75) q
	 }
	 s num=n
 }
 s status=$$StartRou(num)
 i +status=1,num<5000 {
	 s required=$zu(84,0,4,0,0,5000,0,0),avail=$zu(84,0,5)
	 w !!,"The Profile collection has been started for a maximum of ",num
	 w !,"routines, which is less than the normal default. This is because"
	 w !,"there was a limited amount of shared memory available. You may"
	 w !,"need to increase the Generic Memory Heap (gmheap) parameter in the"
	 w !,"system configuration. To collect for the default of ",5000," routines"
	 w !,"requires ",required," pages (of 64kb each) and there are currently"
	 w !,"only ",avail," pages available.",!
	 s n=$$pause()
 }
 q status
}
 ; 
 ; Start a detail level run
 ; Returns '1' for success, or a negative number followed by a "," and message
 ;
STARTDET() {
 ;
 ; see if any routines were selected
 s i="",n=0 f  s i=$o(^||%Profile.Display(i)) q:i=""  i $p(^(i),",",6+4)=1 s n=n+1
 i n=0 q 1
 w #,!!,"There are ",n," routines selected for detailed profiling. You may now"
 w !,"end the routine level collection and start a detailed profiler collection."
 w !
 w !,"WARNING !!",!
 w !,"This will have each process on the system gather subroutine level and line"
 w !,"level activity on these routines. Note that this part of the collection may"
 w !,"have a significant effect on performance and should only be run in a test"
 w !,"or development instance.",!
 s mask=8+4
 s prompt="Are you ready to start the detailed collection? ",response=1
 s status=##class(%Library.Prompt).GetYesNo(prompt,.response,"",mask)
 i +response=0 q 1
 w !!,"Stopping the routine level Profile collection ..."
 s status=$$Stop()
 i status'=1 q status
 s status=$$StartDet()
 i status=1 w !!,"Detail level Profile collection started." h 1
 q status
 ;
}
 ; 
 ; Display routine results
 ;
DISPLAY() {
 s mask=8+4
 s PAGEWIDTH=$System.Device.GetRightMargin() s:PAGEWIDTH=0 PAGEWIDTH=80
 s PAGELEN=24 d ##class(%Library.Device).GetCurrent(,.PAGELEN)
 s PAGECNT=(PAGELEN-2)\2 ; calculate how many routines per page
 u 0:PAGEWIDTH
 i $zu(84,3,3)=0 {
	w !!,"No routines collected yet.",!
	s status=$$pause()
	q
 }
 d GetMetrics(.metrics) ; get list of routine metrics
 ; get a list of database names
 s rset=##class(%Library.ResultSet).%New("Config.Databases:LocalDatabaseList")
 d rset.Execute()
 while (rset.Next()) {
	 s dbase(rset.Data("Directory"))=rset.Data("Name")
 }
 ; create help text
 s opthelp(1)=""
 s opthelp(2)="You may page through the sorted profile display, or select "
 s opthelp(3)="routine(s) from this page that you would like to monitor at"
 s opthelp(4)="a detail level. Enter a comma separated list of numbers, or a"
 s opthelp(5)="number range, or a combination, e.g. '1,2-6,10'. Selected"
 s opthelp(6)="routines will be marked with an '*' next to the routine name"
 s opthelp(7)=""
 s opthelp(8)="Routines selected on one page are remembered and any routines"
 s opthelp(9)="selected on subsequent pages are added to the list."
 s opthelp(10)=""
 s opthelp(11)=""
 s opthelp(12)="Other options are:"
 s opthelp(13)=""
 s opthelp(14)="    'Q' to exit this list (and use selected routines for detail profile)."
 s opthelp(15)="    'N' to move to the next page."
 s opthelp(16)="    'B' to move back a page."
 s opthelp(17)="    'O' to change the display/sort options."
 s opthelp(18)="    'R' to refresh the display with the most recent metrics."
 s opthelp(19)="    'E' to export the current collection of metrics."
 s opthelp(20)="    'X' to clear the list of routines and start over."
 s opthelp(21)=""
 ;
 s display=1 ; default is percentages
 s sort=1 ; default is lines excuted
 s timeout=0 ; refresh rate
 ;
RouSort ; fetch a new sampling of metrics
 k ^||%Profile.Sort,^||%Profile.Display
 s ^||%Profile.Display=sort_","_display
 ; build header lines
 s hdr="      "_$p(metrics(sort),",",2),csvhdr=$p($p(metrics(sort),",",2)," ")
 f i=1:1:6 i sort'=i s hdr=hdr_$p(metrics(i),",",2),csvhdr=csvhdr_","_$p($p(metrics(i),",",2)," ")
 s csvhdr=csvhdr_",RoutineName,Database"
 ; keep totals for percentages
 f j=1:1:6 s totals(j)=0
 ; sort data
 k stats s stats=0 d GetStat(.stats) 
 f i=1:1:stats {
	s rstat="",nm=stats(i,"Name"),dir=$p(nm,","),sys=$p(nm,",",4),nm=$p(nm,",",3)
	s:dir="" dir=" " s:sys="" sys=" " s stat=stats(i,"Stat")
	f j=1:1:6 {
		s pc=$p(metrics(j),",",3)
		s val=$p(stat,",",$s(pc<4:pc+1,pc=4:pc,1:pc+2)) s:(pc=56)!(pc=57) val=$fnumber(val/1000000,"ON",5)
		s rstat=rstat_val_","
		s totals(j)=totals(j)+val
	}
	s ^||%Profile.Sort(+$p(rstat,",",sort),nm,sys,dir)=rstat
 }
 s response="",NextDispLine=1,status=1
 ; display the first page
 s sortnext="^||%Profile.Sort("""")",LastSortLine=0
 d ROUPAGE,ROUOUT
RouPrompt ; ask for options
 s mask=8+4
 s prompt="Select routine(s) or '?' for more options ",response="N" s:timeout>0 response="R"
 s status=##class(%Library.Prompt).GetString(prompt,.response,0,,.opthelp,mask,timeout)
 i (+status=0)||(status=3) q
 ;
 ; select routines
 i $e(response)?1.N {
	; validate routine selection
	s pc=$l(response,","),sel="",err=0
	f i=1:1:pc {
		s sel=$p(response,",",i)
		i sel?.N {
			if sel<NextDispLine,sel>=(NextDispLine-PAGECNT) {
				i $p(^||%Profile.Display(sel),",",6+1)="Other" s err=1 q
				s $p(^||%Profile.Display(sel),",",6+4)=1
			} else {
				s err=1 q
			}
		}
		i sel?.N1"-".N {
			s n1=$p(sel,"-"),n2=$p(sel,"-",2)
			if n1>=(NextDispLine-PAGECNT),(n2<NextDispLine),n1<n2 {
				f n=n1:1:n2 {
					i $p(^||%Profile.Display(n),",",6+1)="Other" s sel=n,err=1 q
					s $p(^||%Profile.Display(n),",",6+4)=1
				}
			} else {
				s err=1 q
			}
		}
	}
	i err {
		w !!,"Error in routine selection - ",sel,!
		s status=$$pause
	}
	s NextDispLine=NextDispLine-PAGECNT
	d ROUOUT g RouPrompt
 }
 ; change sort and/or display
 i "Oo"[response {
 	w #,!!,"Sort by: " k Menu
 	; build Menu
 	f i=1:1:6 s Menu(i)=$p(metrics(i),",",1)
 	s val=1,mask=128+8+4
 	s status=##class(%Library.Prompt).GetMenu("Option?",.val,.Menu,,mask)
 	i (+status=0)||(status=2)||(status=3)||(val="") g RouPrompt
 	s sort=val
 	; ask for percent vs totals
 	w !!,"Compare routines as: "
 	s list(1)="Percentages"
 	s list(2)="Counter Totals"
 	s val=list(1),mask=8+32+128+4
 	s status=##Class(%Library.Prompt).GetArray("Option?",.val,.list,,,,8+32+128)
 	i (+status=0)||(status=2)||(status=3)||(val="") g RouPrompt
 	s display=$s(val=list(1):1,1:2)
 	w ! s prompt="Refresh rate for fetching current data?",response=timeout
 	s tohelp(1)="Enter the number of seconds in which the screen should"
 	s tohelp(2)="automatically refresh. The latest metrics will be gathered,"
 	s tohelp(3)="any routines selected will be cleared, and the display will"
 	s tohelp(4)="return to the first page. A '0' will disable auto-refresh."
 	s status=##Class(%Library.Prompt).GetNumber(prompt,.response,0,,.tohelp,mask)
 	i (+status=0)||(status=2)||(status=3)||(response="") g RouPrompt
 	s timeout=response
 	g RouSort
 }
 ; collect current stats
 i "Rr"[response!(response="") {
	 g RouSort
 }
 ; next page
 i "Nn"[response {
	 i sortnext'="" d ROUPAGE 
	 i NextDispLine+PAGECNT>LastSortLine s NextDispLine=LastSortLine-PAGECNT+1
	 d ROUOUT g RouPrompt
 }
 ; back one page
 i "Bb"[response!(status=2) {
	 s:NextDispLine>1 NextDispLine=NextDispLine-(PAGECNT*2)
	 s:NextDispLine<1 NextDispLine=1
	 ; w "Backing up to ",NextDispLine s status=$$pause()
	 d ROUOUT g RouPrompt
 }
 i "xX"[response {
	 f i=1:1:LastSortLine s $p(^||%Profile.Display(i),",",6+4)=0
	 s NextDispLine=NextDispLine-PAGECNT
	 d ROUOUT g RouPrompt
 }
  ; export results to a file
 i "eE"[response {
	 w #,!!,"Save current data in ...",!!
	 s dev=0,mask=128+8+4,IOFlag=4,(IOSL,IOM,IOT)=""
	 s status=##Class(%Library.Device).Get("Device:",.dev,,mask,,IOFlag,.IOSL,.IOM,"","","",.IOT)
	 i (status=0)||(status=3)||(status=2) {
		  s NextDispLine=NextDispLine-PAGECNT
		  d ROUOUT g RouPrompt
	 }
	 u 0 w !!,"Output in: " k Menu
	 s Menu(1)="Display format"
	 s Menu(2)="CSV format"
	 s response=1,status=##class(%Library.Prompt).GetMenu("Option?",.response,.Menu,,mask)
	 i (+status=0)||(status=2)||(status=3)||(response="") c dev g RouPrompt
	 ; fetch all sorted results
	 while sortnext'="" {
		 d ROUPAGE
	 }
	 ; display format
	 if response=1 {
		 u dev w hdr
		 f line=1:1:LastSortLine d ROULINE(line)
		 c dev s format="display"
	 }
	 ; CSV format 
	 else {
		 u dev w csvhdr,!
		 f line=1:1:LastSortLine {
			 s stat=^||%Profile.Display(line)
			 s val=$p(stat,",",sort),nm=$p(stat,",",6+1),sys=$p(stat,",",6+2),dir=$p(stat,",",6+3)
			 i display=1 s out=$s(totals(sort):$fnumber(val/totals(sort)*100,"ON",2),1:0)
			 e  s out=val
			 f pc=1:1:6 {
				 i pc'=sort {
					 s count=$p(stat,",",pc),out=out_","
					 i display=1 s out=out_$s(totals(pc):$fnumber(count/totals(pc)*100,"ON",2),1:0)
					 e  s out=out_count
				 }
			 }
			 ; check for source
			 s src="",ns="^"_$s(sys=" ":"",1:sys)_"^"_dir
			 i nm'="Other" zn ns s src=##Class(%Library.RoutineMgr).GetOther(nm,"INT",-1) zn "%SYS"
			 i dir]"",$d(dbase(dir)) s dir=dbase(dir) ; get database name
			 s out=out_","_$s(src]"":src,nm="Other":nm,1:nm_".INT")_","_dir
			 w out,!
		 }
		 c dev s format="CSV"
	 }
	 u 0 w !!,"Data saved in ",format," format to ",dev,!
	 s response=$$pause()
	 s NextDispLine=NextDispLine-PAGECNT
	 d ROUOUT g RouPrompt
 }
 w !!,"Error in selection, type '?' at selection prompt for options.",! s status=$$pause()
 ; redisplay same page
 s NextDispLine=NextDispLine-PAGECNT
 d ROUOUT
 g RouPrompt
 ;
ROUPAGE ; Put the next page of entries into the display global
 ;
 s line=LastSortLine
 f  {
	s sortnext=$q(@sortnext,-1) q:sortnext=""
	s val=$qs(sortnext,1),nm=$qs(sortnext,2)
	s sys=$qs(sortnext,3) s:sys=" " sys=""
	s dir=$qs(sortnext,4) s:dir=" " dir=""
	s stats=@sortnext s line=line+1
	s ^||%Profile.Display(line)=stats_nm_","_sys_","_dir
	; check for source
	s src="",ns="^"_$s(sys=" ":"",1:sys)_"^"_dir
	if nm="Other" {
		s src="Other"
	} else {
		s type=$select(+$get(^[ns]ROUTINE(nm,"LANG"))<9:"INT",1:$case(+$get(^[ns]ROUTINE(nm,"LANG")),9:"BAS",10:"INT",11:"MVI",12:"PROC"))
		i type="INT" {
			zn ns s src=##Class(%Library.RoutineMgr).GetOther(nm,"INT",-1) zn "%SYS"
			i src="" s src=nm_".INT"
		}
		i type="MVI" s src=$p($g(^[ns]rMAP(nm,"MVI","MVB")),"~",2)_".MVB"
		i type="BAS" s src=nm_".BAS"
	}
	s $p(^||%Profile.Display(line),",",6+5)=src
	q:line-LastSortLine=PAGECNT
 }
 s LastSortLine=line
 q
ROUOUT ; display the current page from the display global
 w #,hdr
 i NextDispLine<1 s NextDispLine=1
 f line=NextDispLine:1:NextDispLine+PAGECNT-1 {
	 q:line>LastSortLine
	 d ROULINE(line)
 }
 s NextDispLine=NextDispLine+PAGECNT
 q
ROULINE(line) ; write display format for current line from sort global
 s stat=^||%Profile.Display(line)
 s val=$p(stat,",",sort),nm=$p(stat,",",6+1),dir=$p(stat,",",6+3)
 w !,line,". " s col=1
 i display=1 w ?6,$s(totals(sort):$fnumber(val/totals(sort)*100,"ON",2),1:0),"%"
 e  w ?6,val
 f pc=1:1:6 {
	i pc'=sort {
		w ?(6+(12*col)) s count=$p(stat,",",pc),col=col+1
		i display=1 w $s(totals(pc):$fnumber(count/totals(pc)*100,"ON",2),1:0),"%"
		e  w count
	}
 }
 w ! i $p(^||%Profile.Display(line),",",6+4)=1 w "    *" 
 i dir]"",$d(dbase(dir)) s dir=dbase(dir) ; get database name
 w ?6,$p(^||%Profile.Display(line),",",6+5) w:dir]"" " (",dir,")"
 q
 ;
ERROR s $zt=""
 i $ze["<INTERRUPT>" q
 ztrap $ze
}
 ; 
 ; Display detail results
 ;
DISPLAYD() {
 s mask=128+8+4
 s PAGEWIDTH=$System.Device.GetRightMargin() s:PAGEWIDTH=0 PAGEWIDTH=80
 s PAGELEN=24 d ##class(%Library.Device).GetCurrent(,.PAGELEN)
 s PAGECNT=PAGELEN-3 ; calculate how many lines per page
 u $IO:PAGEWIDTH
 k ^||%Profile.Routine,^||%Profile.Display
 ; get a list of database names
 s rset=##class(%Library.ResultSet).%New("Config.Databases:LocalDatabaseList")
 d rset.Execute()
 while (rset.Next()) {
	 s dbase(rset.Data("Directory"))=rset.Data("Name")
 }
 ; get routine list
 s RoutineCount=$zu(84,16)
 f rnum=1:1:RoutineCount {
	s nm=$zu(84,16,2,rnum),dir=$zu(84,16,6,rnum),sys=$p(dir,",",2),dir=$p(dir,",")
	s src="",dbase="",ns="^"_sys_"^"_dir
	s type=$select(+$get(^[ns]ROUTINE(nm,"LANG"))<9:"INT",1:$case(+$get(^[ns]ROUTINE(nm,"LANG")),9:"BAS",10:"INT",11:"MVI",12:"PROC"))
	i type="INT" {
		zn ns s src=##Class(%Library.RoutineMgr).GetOther(nm,"INT",-1) zn "%SYS"
		i src="" s src=nm_".INT"
	}
	i type="MVI" s src=$p($g(^[ns]rMAP(nm,"MVI","MVB")),"~",2)_".MVB"
	i type="BAS" s src=nm_".BAS"
	i dir]"",$d(dbase(dir)) s dbase=dbase(dir) ; get database name
	i src="" s src=nm_".INT"
	; ^||%Profile.Routine(rnum) = RoutineName ^ System ^ Directory ^ SourceName ^ DatabaseName
	s ^||%Profile.Routine(rnum)=nm_"^"_sys_"^"_dir_"^"_src_"^"_dbase
 }
 s metrics(1)="Lines of code executed,RtnLine     ,"_37
 s metrics(2)="Time of execution,Time        ,"_56
 s metrics(3)="Global references,GloRef      ,"_0
 ; create help text
 k opthelp
 s opthelp(1)=""
 s opthelp(2)="This lists the routines selected for the detail collection"
 s opthelp(3)="sorted by routine level activity."
 s opthelp(4)="" 
 s opthelp(5)="Select a routine, using the number list on the left to see"
 s opthelp(6)="detail activity for the routine. You will be able to view either"
 s opthelp(7)="Subroutine or Line level details. You will be returned to this"
 s opthelp(8)="list when you quit from the details display."
 s opthelp(9)=""
 s opthelp(10)=""
 s opthelp(11)="Other options are:"
 s opthelp(12)=""
 s opthelp(13)="    'Q' to exit the display screens."
 s opthelp(14)="    'N' to move to the next page."
 s opthelp(15)="    'B' to move back a page."
 s opthelp(16)="    'O' to change the display/sort options."
 s opthelp(17)="    'R' to refresh the display with the most recent metrics."
 s opthelp(18)=""
 s opthelp(19)=""
 s sort=1 ; init sort as RtnLine
 s display=1 ; display percent
 s CodeType="INT" ; start with INT code
GetSummary
 k ^||%Profile.Sort,^||%Profile.Display
 ; find sort metric
 f metric=0:1:($zu(84,13)-1) {
	 s n=$zu(84,13,11,metric)
	 i n=$p(metrics(sort),",",3) s SortMetric=metric q
 }
 ; get routine metrics for each routine and sort
 s SortTotal=0
 f rnum=1:1:RoutineCount {
	s val=0 i $zu(84,16,1,rnum) s val=$zu(84,16,5,SortMetric)
	s ^||%Profile.Sort(val,rnum)=rnum
	s SortTotal=SortTotal+val
 }
 ; build display list
 s sortnext="^||%Profile.Sort("""")",line=0
 f  {
	s sortnext=$q(@sortnext,-1) q:sortnext=""
	s val=$qs(sortnext,1),rnum=$qs(sortnext,2)
	s line=line+1 s ^||%Profile.Display(line)=val_","_rnum
 }
 s NextDispLine=1
DispRouList
 w #,?4,$p(metrics(sort),",",2),?14,"Routine Name  (Database)"
 i NextDispLine<1 s NextDispLine=1
 f line=NextDispLine:1:NextDispLine+PAGECNT-1 {
	 q:line>RoutineCount
	 s stat=^||%Profile.Display(line),val=$p(stat,","),rnum=$p(stat,",",2)
	 s src=$p(^||%Profile.Routine(rnum),"^",4),dbase=$p(^||%Profile.Routine(rnum),"^",5)
	 i dbase="" s dbase="^"_$p(^||%Profile.Routine(rnum),"^",2)_"^"_$p(^||%Profile.Routine(rnum),"^",3) ; remote
	 w !,line,". ",?4
	 i display=1 w $s(SortTotal:$fnumber(val/SortTotal*100,"ON",2),1:0),"%"
	 e  s:sort=2 val=$s(val=0:"0"_$j("",sp-4),1:$fnumber(val/10000,"ON",4)) w val
	 w ?16,src," (",dbase,")"
 }
 s NextDispLine=NextDispLine+PAGECNT
 s mask=8+4
 s prompt="Select routine to see details or '?' for more options "
 s response="N" s:NextDispLine>RoutineCount response="R"
 w ! s status=##class(%Library.Prompt).GetString(prompt,.response,0,,.opthelp,mask,0)
 i (+status=0)||(status=3) q
 ; routine selected, display detail
 i +response>(NextDispLine-PAGECNT-1),+response<NextDispLine {
	 s rtn=$p(^||%Profile.Display(+response),",",2)
	 d DETAIL(rtn)
	 s NextDispLine=1
	 g DispRouList
 }
 ; next page
 i "Nn"[response {
	 i NextDispLine+PAGECNT>RoutineCount s NextDispLine=RoutineCount-PAGECNT
	 g DispRouList
 }
 ; refresh page
 i "Rr"[response {
	 g GetSummary
 }
 ; back one page
 i "Bb"[response!(status=2) {
	 s:NextDispLine>1 NextDispLine=NextDispLine-(PAGECNT*2)
	 s:NextDispLine<1 NextDispLine=1
	 g DispRouList
 }
 ; change sort metric
 i "Oo"[response {
 	w #,!!,"Sort by: " k Menu
 	; build Menu
 	f i=1:1:3 s Menu(i)=$p(metrics(i),",",1)
 	s val=1,mask=128+8+4
 	s status=##class(%Library.Prompt).GetMenu("Option?",.val,.Menu,,mask)
 	i (+status=0)||(status=2)||(status=3)||(val="") g GetSummary
 	s sort=val
 	; ask for percent vs totals
 	w !!,"Compare routines as: "
 	s list(1)="Percentages"
 	s list(2)="Counter Totals"
 	s val=list(1),mask=8+32+128+4
 	s status=##Class(%Library.Prompt).GetArray("Option?",.val,.list,,,,8+32+128)
 	i (+status=0)||(status=2)||(status=3)||(val="") g GetSummary
 	s display=$s(val=list(1):1,1:2)
 	g GetSummary
 }
 w !!,"Error in selection, type '?' at selection prompt for options.",! s status=$$pause()
 ; redisplay same page
 s NextDispLine=NextDispLine-PAGECNT
 g DispRouList
 ;
 ; Display details list
 ;	'rtn' = routine number in internal list
 ; 
DETAIL(rtn,line)
 s type="S"
 s nm=$p(^||%Profile.Routine(rtn),"^",1),sys=$p(^||%Profile.Routine(rtn),"^",2),dir=$p(^||%Profile.Routine(rtn),"^",3)
 s source=$p(^||%Profile.Routine(rtn),"^",4),dbase=$p(^||%Profile.Routine(rtn),"^",5)
 s ns="^"_sys_"^"_dir,sp=11
 ; get routine code
 k routine s (routine,err)="",LineDetail=1
 s load=nm i $p(nm,".",$l(nm,"."))'="INT" s load=nm_".INT"
 i '$$ROUTINE^%R(load,.routine,.err,"LI",,,ns) {
	 s text=$$FMTERR^%R(err)
	 i text["<NOSOURCE>" w !!,"No source found for routine ",nm," in ",$s(dbase]"":dbase,1:ns)
	 e  w !!,"Error loading routine ",nm," in ",dir," - ",text
	 w !! s status=$$pause()
	 q
 }
 ;
 ; Subroutine level display
 ;
GetSubDetail
 k ^||%Profile.Detail
 s sel=$zu(84,16,1,rtn) ; select routine
 ; Get a tag-line list, first piece is number of tags, others are line numbers for each tag
 ; Routine must be ZLOADed so $zu() can access source code
 s tags=0,hdr="Tag#    RtnLine    GloRef     Time        Label"
 s com="(tags) zl "_nm_" s tags=$zu(84,16,4,0)"
 ; use $zu(39) so we can find any mapped %-routines
 zn ns d $zu(39,"^^") x (com,.tags) zn "%SYS" s ntags=+tags
 f tag=1:1:ntags {
	 s line=$p(tags,",",tag+1),data=""
	 s tagname=$s(tag=1:nm,line="":"*Unknown*",1:$p(routine(line)," "))
	 i $l(tagname)>38 s tagname=$e(tagname,1,35)_"..."
	 ; get first 3 metrics (Lines, GloRef, Time ... no TotalTime)
	 for metric=0:1:2 {
		 s out=$zu(84,16,4,tag,metric)
		 ; Convert clock to seconds
		 i (metric=2) s out=$s(out=0:"0"_$j("",sp-4),1:$fnumber(out/1000000,"ON",5))
		 s data=data_out_"^"
	 }
	 s ^||%Profile.Detail(tag)=tagname_"^"_data
 }
 s RoutinePrompt=$p(^||%Profile.Routine(rtn),"^",1)_" in "_$s(dbase]"":dbase,1:ns)
 s NextDispLine=1,LastLine=ntags
DispSubDetail
 w #,hdr
 i NextDispLine<1 s NextDispLine=1
 f line=NextDispLine:1:NextDispLine+PAGECNT-1 {
	 q:line>LastLine
	 w !,line,"." s stat=^||%Profile.Detail(line)
	 w ?8,$p(stat,"^",2),?19,$p(stat,"^",3),?30,$p(stat,"^",4),?42,$p(stat,"^",1)
 }
 s NextDispLine=NextDispLine+PAGECNT
 ; create help text
 k opthelp
 s opthelp(1)=""
 s opthelp(2)=""
 s opthelp(3)="This screen displays a list of subroutine labels and the metrics"
 s opthelp(4)="counted for each label. You may switch to a Line Level display"
 s opthelp(5)="of the same routine by entering 'L', or by selecting a label number"
 s opthelp(6)="to jump to that line of the routine."
 s opthelp(7)=""
 s opthelp(8)="Other options are:"
 s opthelp(9)="    'Q' to exit back to the list of routines."
 s opthelp(10)="    'N' to move to the next page."
 s opthelp(11)="    'B' to move back a page."
 s opthelp(12)="    'R' to refresh the display with the most recent metrics."
 s opthelp(13)=""
 s opthelp(14)=""
 s opthelp(15)="" 
 s mask=8+4
 s prompt="Routine "_RoutinePrompt_" - '?' for options ",response="N"
 w ! s status=##class(%Library.Prompt).GetString(prompt,.response,0,,.opthelp,mask,0)
 i (+status=0)||(status=3) q
 ; select label and switch to line level
 i response?1.N,response>0,response<(LastLine+1) {
	 s NextDispLine=$p(tags,",",response+1)
	 g DoLineDetail
 }
 ; next page
 i "Nn"[response {
	 i NextDispLine+PAGECNT>LastLine s NextDispLine=LastLine-PAGECNT
	 g DispSubDetail
 }
 ; refresh page
 i "Rr"[response {
	 g GetSubDetail
 }
 ; back one page
 i "Bb"[response!(status=2) {
	 s:NextDispLine>1 NextDispLine=NextDispLine-(PAGECNT*2)
	 s:NextDispLine<1 NextDispLine=1
	 g DispSubDetail
 }
 ; Line level display
 i "Ll"[response {
	 s NextDispLine=1
	 g DoLineDetail
 }
 w !!,"Error in selection, type '?' at selection prompt for options.",! s status=$$pause()
 ; redisplay same page
 s NextDispLine=NextDispLine-PAGECNT
 g DispSubDetail
 ;
 ; Line level display
 ;(NOTE: NextDispLine is set by selection in Subroutine Level)
 ;
DoLineDetail
 k ^||%Profile.Detail,INTroutine,SRCroutine
 s hdr1=$s(LineDetail=1:"RtnLine",LineDetail=2:"GloRef",LineDetail=3:"Time",1:"TotalTime")
 s nm=$p(^||%Profile.Routine(rtn),"^",1),dbase=$p(^||%Profile.Routine(rtn),"^",5)
 s sys=$p(^||%Profile.Routine(rtn),"^",2),dir=$p(^||%Profile.Routine(rtn),"^",3),ns="^"_sys_"^"_dir
 s load=nm i $p(nm,".",$l(nm,"."))'="INT" s load=nm_".INT"
 i '$$ROUTINE^%R(load,.INTroutine,.err,"LI",,,ns) q
 s sel=$zu(84,16,1,rtn) ; select routine
 f line=1:1:INTroutine(0) {
	 s data=""
	 ; get first metrics (Lines, GloRef, Time, TotalTime)
	 for metric=0:1:3 {
		 s out=$zu(84,16,3,line-1,metric)
		 ; Convert clock to seconds
		 i (metric=2)!(metric=3) s out=$s(out=0:"0"_$j("",sp-4),1:$fnumber(out/1000000,"ON",5))
		 s data=data_out_"^"
	 }
	 s ^||%Profile.Detail("INT",line)=data
 }
 s RoutinePrompt=$p(^||%Profile.Routine(rtn),"^",1)_" in "_$s(dbase]"":dbase,1:ns)
 s LastLine=INTroutine(0)
 i CodeType="SRC" {
	 s ok=$$GetSrcDetail(rtn,.SRCroutine,.INTroutine)
	 if ok {
		 s LastLine=SRCroutine(0)
		 s RoutinePrompt=$p(^||%Profile.Routine(rtn),"^",4)_" in "_$s(dbase]"":dbase,1:ns)
	 } 
	 else {
		 s CodeType="INT"
		 s RoutinePrompt=$p(^||%Profile.Routine(rtn),"^",1)_" in "_$s(dbase]"":dbase,1:ns)
	 }
 }
 ;	 
DispLineDetail
 w #,"Line  ",hdr1,?30,"Code"
 i NextDispLine<1 s NextDispLine=1
 f line=NextDispLine:1:NextDispLine+PAGECNT-1 {
	 q:line>LastLine
	 w !,line,"." s stat=^||%Profile.Detail(CodeType,line)
	 s rline=$s(CodeType="SRC":SRCroutine(line),1:INTroutine(line))
	 s rline=$replace(rline,$c(9),"    ")
	 w ?6,$p(stat,"^",LineDetail),?16,$e(rline,1,PAGEWIDTH-16)
 }
 s NextDispLine=NextDispLine+PAGECNT
 ; create help text
 k opthelp
 s opthelp(1)=""
 s opthelp(2)=""
 s opthelp(3)="This screen displays a list of all lines for this routine and a"
 s opthelp(4)="selected metric counted for each line. You may switch back to a"
 s opthelp(5)="Subroutine Level display of the same routine by entering 'S'."
 s opthelp(6)=""
 s opthelp(7)="You may enter a line number to jump to that line of the routine."
 s opthelp(8)=""
 s opthelp(9)=""
 s opthelp(10)="Other options are:"
 s opthelp(11)=""
 s opthelp(12)="    'Q' to exit back to the list of routines."
 s opthelp(13)="    'N' to move to the next page."
 s opthelp(14)="    'B' to move back a page."
 s opthelp(15)="    'O' to change the display/metric options"
 s opthelp(16)="    'C' to switch Code display (source vs. INT/MVI)"
 s opthelp(17)="    'M' to change the page margin and length"
 s opthelp(18)="    'R' to refresh the display with the most recent metrics."
 s opthelp(19)=""
 s opthelp(20)="" 
 s opthelp(21)="" 
 s mask=8+4
 s prompt="Routine "_RoutinePrompt_" - '?' for options ",response="N"
 w ! s status=##class(%Library.Prompt).GetString(prompt,.response,0,,.opthelp,mask,0)
 i (+status=0)||(status=3) q
 ; select line to display
 i response?1.N,response>0,response<(LastLine+1) {
	 s NextDispLine=response
	 g DoLineDetail
 }
 ; next page
 i "Nn"[response {
	 i NextDispLine+PAGECNT>LastLine s NextDispLine=LastLine-PAGECNT
	 g DispLineDetail
 }
 ; refresh page
 i "Rr"[response {
	 s NextDispLine=NextDispLine-PAGECNT s:NextDispLine<1 NextDispLine=1
	 g DoLineDetail
 }
 ; back one page
 i "Bb"[response!(status=2) {
	 s:NextDispLine>1 NextDispLine=NextDispLine-(PAGECNT*2)
	 s:NextDispLine<1 NextDispLine=1
	 g DispLineDetail
 }
 ; subroutine level display
 i "Ss"[response {
	 g GetSubDetail
 }
 ; change display metric
 i "Oo"[response {
 	w #,!!,"Select metric to display: " k Menu
 	; build Menu
 	s Menu(1)="Lines of code executed"
 	s Menu(2)="Global references"
 	s Menu(3)="Time of execution"
 	s Menu(4)="Total Time (including subroutine calls)"
 	s val=1,mask=128+8+4
 	s status=##class(%Library.Prompt).GetMenu("Option?",.val,.Menu,,mask)
	s NextDispLine=NextDispLine-PAGECNT
 	i (+status=0)||(status=2)||(status=3)||(val="") {
	 	 g DispLineDetail
 	}
 	s LineDetail=val
 	g DoLineDetail
 }
 ; change page length/width
 i "Mm"[response {
 	w ! s status=$$page(.PAGELEN,.PAGEWIDTH)
 	s NextDispLine=NextDispLine-PAGECNT
 	s PAGECNT=PAGELEN-3 u $IO:PAGEWIDTH
 	g DispLineDetail
 }
 ; change code selection INT/source
 i "Cc"[response {
	 s dbase=$p(^||%Profile.Routine(rtn),"^",5)
	 i dbase="" s dbase="^"_$p(^||%Profile.Routine(rtn),"^",2)_"^"_$p(^||%Profile.Routine(rtn),"^",3) ; remote
	 if CodeType="INT" {
		 i '$d(^||%Profile.Detail("SRC")) {
			 s ok=$$GetSrcDetail(rtn,.SRCroutine,.INTroutine)
			 i 'ok {
				 w !!,"No source code available.",! s status=$$pause()
			 	 s NextDispLine=NextDispLine-PAGECNT
			 	 g DispLineDetail
			 }
		 }
		 s CodeType="SRC",LastLine=SRCroutine(0),NextDispLine=1
		 s RoutinePrompt=$p(^||%Profile.Routine(rtn),"^",4)_" in "_dbase
	 }
	 else {
		 s CodeType="INT",LastLine=INTroutine(0),NextDispLine=1
		 s RoutinePrompt=$p(^||%Profile.Routine(rtn),"^",1)_" in "_dbase
	 }
	 g DispLineDetail
 }
 w !!,"Error in selection, type '?' at selection prompt for options.",! s status=$$pause()
 ; redisplay same page
 s NextDispLine=NextDispLine-PAGECNT
 g DispLineDetail
}
 ;
 ; Get Source lines and map metrics from INT
 ; 'rtn' = routine number in internal list
 ; return 1 if loaded or 0 if not
 ;
 ; Use this global for stats:
 ; ^||%Profile.Detail("INT",line)=Lines ^ GloRef ^ Time ^ TotalTime
 ;
 ; Fill in this global with accumulated stats:
 ; ^||%Profile.Detail("SRC",line)=Lines ^ GloRef ^ Time ^ TotalTime
 ;
 ; Source code lines are in SRCroutine()
 ;
GetSrcDetail(rtn,SRCroutine,INTroutine) {
 s nm=$p(^||%Profile.Routine(rtn),"^",1),sys=$p(^||%Profile.Routine(rtn),"^",2),dir=$p(^||%Profile.Routine(rtn),"^",3),ns="^"_sys_"^"_dir
 s dbase=$p(^||%Profile.Routine(rtn),"^",5),src=$p(^||%Profile.Routine(rtn),"^",4),type=$p(src,".",$l(src,".")),return=0
 ;
 i ",MAC,MVB,"[type {
	 ; get source code
	 s (SRCroutine,err)=""
	 i type="MAC",'$$ROUTINE^%R(src,.SRCroutine,.err,"LI",,,ns) q 0
	 i type="MVB" {
		 s mvbName=$g(^[ns]rMAP(nm,"MVI","MVB")) i mvbName="" q 0
		 i mvbName["~" s file=$p(mvbName,"~",1),mvbName=$p(mvbName,"~",2)
		 e  s file="BP"
		 ; Find "account" (i.e. namespace). Note this isn't exactly right, as
		 ; we just look for the first namespace that uses the MVI directory for
		 ; routines. We really need to add the account to the rMAP global.
		 s account="",nspace=""
		 s rset=##class(%Library.ResultSet).%New("Config.Namespaces:List") d rset.Execute()
		 while (rset.Next()) {
			  i rset.Data("Routines")=dbase s nspace=rset.Data("Namespace") q
		 }
		 if nspace'="" set account=$G(^%MV.SYS("N",nspace))
		 i account="" q 0
		 w "(",account,",",file,")"
		 Set fobj=$zu(24,0),rc=$zu(24,4,fobj,account,file,0) i rc q 0
		 Set code=$zu(24,5,fobj,mvbName,0,0),rc=$zu(24) i rc q 0
		 s SRCroutine(0)=$l(code,$c(254))
		 f line=1:1:SRCroutine(0) s SRCroutine(line)=$p(code,$c(254),line)
	 }
	 s return=1
	 f line=1:1:SRCroutine(0) s ^||%Profile.Detail("SRC",line)="0^0^0^0"
	 ; map INT code to source lines
	 f intline=1:1:INTroutine(0) {
		 k map s srcline=0 
		 s stat=##class(%Studio.Debugger).SourceLine(nm,intline,1,intline,1,ns,.map)
		 if $d(map) {
			 ; map("MAC",1) = $list( source, "", label_offset, line_offset )
			 s sc=$g(map(type,1)) i sc]"" s srcline=$list(sc,3)
		 }
		 ; add metrics to this source line
		 i srcline {
			 f m=1:1:4 {
				 s v1=$p(^||%Profile.Detail("SRC",srcline),"^",m)
				 s v2=$p(^||%Profile.Detail("INT",intline),"^",m)
				 s $p(^||%Profile.Detail("SRC",srcline),"^",m)=v1+v2
			 }
		 }
	 }
 }
 i type="CLS" {
	 ; find all methods in this INT routine
	 k methods
	 for intline=1:1:INTroutine(0) {
	 	 ; see if any source code for this line, temporarily store in methods() array
		 k map s method="",srcline=0
		 ;SourceLine(intName As %String, startLine As %Integer, startPos As %Integer, endLine As %Integer, endPos As %Integer, Namespace As %String, ByRef map As %String) As %Status
		 s stat=##class(%Studio.Debugger).SourceLine(nm,intline,1,intline,1,ns,.map)
		 if $d(map) {
			 ; map("CLS",1) = $list( source, method, label_offset, line_offset )
			 s sc=$g(map("CLS",1)),method=""
			 i sc]"" s class=$list(sc,1),method=$list(sc,2),srcline=$list(sc,3)
		 }
		 ; set up method source lines the first time we see it
		 i method]"",'$d(methods(method)) {
			 s ref=##class(%Dictionary.MethodDefinition).%OpenId(class_"||"_method)
			 i ref="" {
				 s method="",srcline=0
			 } else {
				 f l=1:1 {
					 s methods(method,l)=ref.Implementation.ReadLine()
					 s methods(method,l,"stat")=""
					 q:ref.Implementation.AtEnd
				 }
			 }
		 }
		 ; add metrics to this source line
		 i method]"",srcline {
			 f m=1:1:4 {
				 s v1=$p(methods(method,srcline,"stat"),"^",m)
				 s v2=$p(^||%Profile.Detail("INT",intline),"^",m)
				 s $p(methods(method,srcline,"stat"),"^",m)=v1+v2
			 }
		 }
	 }
	 ; did we find anything?
	 i $o(methods(""))="" q 0
	 ; create display from methods() array
	 s method="",srcline="",displine=1,return=1
	 f  {
	 	s method=$o(methods(method)) q:method=""
	 	s SRCroutine(displine)="",^||%Profile.Detail("SRC",displine)=""
	 	s SRCroutine(displine+1)="** Method "_method_" **",^||%Profile.Detail("SRC",displine+1)=""
	 	s SRCroutine(displine+2)="",^||%Profile.Detail("SRC",displine+2)=""
	 	s displine=displine+3
	 	f  {
		 	s srcline=$o(methods(method,srcline)) q:srcline=""
		 	s SRCroutine(displine)=methods(method,srcline)
		 	s ^||%Profile.Detail("SRC",displine)=methods(method,srcline,"stat")
		 	s displine=displine+1
	 	}
	 }
	 s SRCroutine(0)=displine-1
 }
 q return
}
 ; 
 ; Stop Profile
 ;
STOP() {
 s mask=8+128+4
STP1
 s prompt="Do you want to stop the Profile collection (collected data will be deleted)? ",response=0
 s help(1)="Enter 'Y' to stop the current Profile collection."
 s help(2)="Note that all data in memory will be deleted."
 s help(3)="It should be saved to file if you wish to keep it."
 w ! s status=##class(%Library.Prompt).GetYesNo(prompt,.response,.help) k help
 i response {
	s status=$$Stop()
	if status'=1 {
		w !!,"Error stopping Profile collection: ",status,!!
	} else {
		w !!,"Profile collection stopped.",!!
	}
 } 
 q
}
 ;
 ; Get status of profiler, returns one of the following strings:
 ;
 ; "MONLBL" = %SYS.MONLBL session is running
 ; "PERFMON" = PERFMON session is running
 ; "STOPPED" = Stopped - no profiling collection is active
 ; "ROUTINE" = Routine-level collection active
 ; "DETAIL" = Detail-level (subroutine/line) collection active
 ;
Status() PUBLIC {
 s status="STOPPED"
 ; check for PERFMON or MONLBL
 i $zu(84,8)=1,$zu(84,1,4)=0 s status=$s($zu(84,16)=-1:"PERFMON",1:"MONLBL") q status
 ; check for active and ROUTINE vs. DETAIL
 i $zu(84,8)=1 s status="DETAIL" i $zu(84,16)<1 s status="ROUTINE"
 q status
}
 ;
 ; Startup a routine-level run
 ;
 ; 'rou' = number of routines to allocate space for.
 ; The default is to allocate space for 1000 routines.
 ;
 ; Returns '1' for success, or a negative number followed by a "," and message
 ; 
StartRou(rou) PUBLIC {
 i '$g(rou,0) s rou=1000
 s (proc,glo,net,dbase)=0
 s status=1,err="",$ZT="funcerr",$ZE=""
 L +^SYS("MON-HOLD"):3
 e  s status="-1,Somebody else is using Monitor" g funcex
 i $zu(84,8)=1 s status="-2,Monitor is already running" g funcex
 d $zu(84,12,0) ; clear any leftover routine lists
 i $zu(84,0,1,proc,glo,rou,net,dbase)'=1 s status="-3,Memory allocation failed" g funcex
 i $zu(84,1,1)'=1 s status="-4,Couldn't enable profile collection" g funcex
 i $zu(84,1,4,1)=1  ; enable Time collection for routines"
 s ^SYS("MONITOR","START")=$h
 k ^SYS("MONITOR","PAUSE"),^SYS("MONITOR","PAUSE-TIME"),^SYS("MONITOR","SAMPLE")
 L -^SYS("MON-HOLD")
 q status
funcerr s status="0, Unexpected Profiler error, "_$ze
funcex L -^SYS("MON-HOLD")
 q status
}
 ;
 ; Startup a detail-level run
 ;
 ; Get list of routines from ^||%Profile.Display(line)
 ;
 ; Returns '1' for success, or a negative number followed by a "," and message
 ; 
StartDet() PUBLIC {
 L +^SYS("MON-HOLD"):3
 e  s status="-1,Somebody else is using Monitor" g runexit
 s $zt="runexit",err="",status=1
 d $zu(84,12,0) ; clear internal routine list
 i $zu(84,8)=1 s status="-2,Monitor is already running" g runexit
 ; Loop through selected routines
 s line="" w !
 f  {
	s line=$o(^||%Profile.Display(line)) q:line=""
	i $p(^(line),",",6+4)=1 {
		s rou=$p(^(line),",",6+1)
		s dir=$p(^(line),",",6+3)
		s sys=$p(^(line),",",6+2)
		s ns="^"_sys_"^"_dir
		s com="zl "_rou_" s ok=$zu(84,12,1)"
		w !,"Loading ^",rou," in ",ns
		; use $zu(39) so we can find any mapped %-routines
		zn ns d $zu(39,"^^") x com zn "%SYS"
	}
 }
 ; select metrics
 d $zu(84,13,0)
 d $zu(84,13,1,37) ; M commands
 d $zu(84,13,1,0) ; global refs
 d $zu(84,13,1,56) ; clock time
 d $zu(84,13,1,57) ; total time
 ;
 ; allocate memory and enable main monitor flag
 i $zu(84,0,1,0,0,0,0,0)'=1 {
	w !!,$zu(84,0,4,0,0,0,0,0)," page(s) of memory required."
	w !,$zu(84,0,5)," page(s) of memory available."
	w !!,"The Generic Memory Heap (gmheap) parameter probably needs to be increased."
	w !,"Pages are each 64kb of memory."
	s status=-3,err="Memory allocation failed"
	g runexit
 }
 ; enable collection for all PIDs
 i $zu(84,1,1)'=1 set status=-4,err="Couldn't enable stats collection" goto runexit
 ; enable LBL monitoring
 d $zu(84,15)
 ; flag PROFILE run
 d $zu(84,1,4,1) 
 s ^SYS("MONITOR","START")=$h
 k ^SYS("MONITOR","PAUSE"),^SYS("MONITOR","PAUSE-TIME")
runexit if $ze]"" set status=0,err="Error trap - "_$ze
 L -^SYS("MON-HOLD")
 i err]"" {
	set status=status_","_err
	quit status
 }
 q status
}
 ;
 ; Stop Profile collection
 ;
 ; Returns '1' for success, or a negative number followed by a "," and message
 ;
Stop() PUBLIC {
 set $ZE="",$ZT="funcerr",status=1
 L +^SYS("MON-HOLD"):3
 else  set status="-1,Somebody else is using Monitor." goto funcex
 if $zu(84,8)=0 set status="-2,Monitor is not running." goto funcex
 set zu84=$zu(84,1,0) ; disable stats...
 set zu84=$zu(84,0,0) ; end collection
 kill ^SYS("MONITOR","START")
 kill ^SYS("MONITOR","PAUSE"),^SYS("MONITOR","PAUSE-TIME")
 L -^SYS("MON-HOLD")
 quit status
funcerr s status="0, Unexpected Profiler error, "_$ze
funcex L -^SYS("MON-HOLD")
 q status
}
 ; 
 ;
GetStat(out)  ; Retrieve stats for report
 ;
 ; out  = is an array name (by reference)
 ; 
 n j,name
 s $zt="Gsterr"
 s out=$zu(84,3,3) ; number of routines collected
 f j=0:1:out {
	s name=$zu(84,4,3,j) s:name=0 name=",,Other"
	s out(j+1,"Name")=name,out(j+1,"Stat")=$tr($zu(84,5,3,j),"^ ",",,")
 }
 s out=out+1 ; add 1 for 0 ("other") category
 q
Gsterr ;
 ; Trap a FUNCTION error for the last entry + 1 
 i $ze["<FUNCTION>",j=out s $ze="",$zt="" q
 q
 ;
 ; Build a list of metrics for routine profile
 ; Pass array 'metrics' byref, return list
 ; Uses $$$PRFMETRICS defined at top
 ;
 ; Done to keep defintions in one place
 ;
GetMetrics(metrics)
 ; array of sort and data field options - pieces are: menu,hdr_name,$p_of_stat,LBL_stat_num
 s metrics=6
 s metrics(1)="Lines of code executed,RtnLine     ,"_37
 s metrics(2)="Time of execution,Time        ,"_56
 s metrics(3)="CPU Time,CPU         ,"_57
 s metrics(4)="Routine Loaded,RtnLoad     ,"_38
 s metrics(5)="Global references,GloRef      ,"_0
 s metrics(6)="Global sets,GloSet      ,"_1
 q
 ;
 ; get page length and width - (pass by ref)
 ;
page(length,width)
 s mask=8+4
 s status=##Class(%Library.Prompt).GetNumber("Right margin:",.width,0,511,,mask)
 i (+status=0)||(status=3) q status
 s status=##Class(%Library.Prompt).GetNumber("Page length:",.length,0,,,mask)
 q status
 ;
 ; function to say "press enter to continue"
 ;
pause() ;
 s mask=8+4
 s status=##class(%Library.Prompt).GetString("Press ENTER to continue",,0,1,"",mask)
 q status

REDEBUG^INT^1^67214,47331
REDEBUG ; Change Network Debug flags
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 d SETUP,ISHOW,IWRITE
 q
SETUP d ^ST s flagadd=$zu(40,2,31)
 q
GET s %D=$V(flagadd,-2,4) d INT^%DX s flags=%X
 q
SHOW d SETUP
ISHOW d GET w !!,"Old flag values = ",flags
 q
WRITE d SETUP
IWRITE r !!,"New flag values (in Hex): ",nflags
 i nflags="" w " No Change" q
 d SETDEC
 i nflags=-1 w " Invalid flags. No change" q
 w !!,"Done",!
 q
SETDEC i $tr(nflags,"0123456789abcdefABCDEF")]""!($l(nflags)>8) s nflags=-1 q
 s %X=nflags d INT^%XD s nflags=%D
SET v flagadd:-2:4:nflags
 d $zu(9,"","REDEBUG: new netdebugflags "_$ZH(+nflags),(0>0),0)
 q
INTGET() d SETUP,GET
 q flags
INTSET(nflags) q:nflags=""  d SETUP,SETDEC
 q

RELBL^INT^1^67214,47331
RELBL(DIR) ; Set into MUMPS.DAT label block
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ;SET ANYREPLICATION BITS IN LABEL BLOCK
 ;
 ;  Returns: OLDIMPL=value of ANYIMPL bit prior to changing [always 0],
 ;           NEWIMPL=value of ANYIMPL bit after changing [always 0],
 ;           OLDREPL=value of ANYREPL bit prior to changing,
 ;           NEWREPL=value of ANYREPL bit after changing.
 ;
 ;  Called By: 'GIMPLICI','REPL'
 ;
 ;=====================================================================
 ;
1 N GLO,J S NEWIMPL=0,NEWREPL=0,GLO=""
GO n NSP s NSP="^^"_DIR
 F J=0:0 S GLO=$O(^[NSP]SYSDIR("GLOBAL",GLO)) Q:GLO=""  D GLOBAL
 ;
 ;READ LABEL BLOCK INTO VIEW-BUFFER, CHANGE ANYREPL,NOMOUNT BITS, AND WRITE OUT LABEL BLOCK
 O 63:"^^"_DIR V 1 D GFS^ST N nomnt,repl,offset,size,oldmnt
 S nomnt=%ST("GFNOMOUNT"),repl=%ST("GFREPL")
 I $V(%ST("GFOFFSET")+%ST("gfformat"),0,%ST("szformat")) S offset=%ST("GFOFFSET")+%ST("gfattrib"),size=%ST("szattrib")
 E  S offset=%ST("GFOFFSET")+%ST("gfuse"),size=%ST("szuse")
 S V=$V(offset,0,size)
 S OLDIMPL=0,OLDREPL=V\repl#2,oldmnt=V\nomnt#2,NOMOUNT=NEWREPL
 S V=V-(OLDREPL*repl)-(oldmnt*nomnt)
 S V=V+(NEWREPL*repl)+(NOMOUNT*nomnt)
 V offset:0:size:V V -1 C 63
K q   ; MRP Could remove K
 ;
GLOBAL n NSP s NSP="^^"_DIR
 I 'NEWREPL,$D(^[NSP]SYSDIR("GLOBAL",GLO,"REPL")),$$DEFINE(GLO) S NEWREPL=1
 Q
 ;
 ; $$DEFINE(GLO) = 1 if the global is actually defined, otherwise = 0
 ; and kill ^SYSDIR("GLOBAL",GLO,"REPL").  Will = 0 if someone kills
 ; an entire replicated global.
 ;
DEFINE(GLO) S $ZT="DEFERR" 
 n NSP s NSP="^^"_DIR
 I @("'$D(^[NSP]"_GLO_")") K ^[NSP]SYSDIR("GLOBAL",GLO,"REPL") Q 0  ;GLOBAL UN
DEFINED 
 Q 1
DEFERR Q 1 ;IF IN DOUBT, LEAVE ALONE.
 ;
 ; ENTRY POINT.  $$ANYIMPL(DIR) = value of ANYIMPL, always returns 0
 ;
ANYIMPL(DIR) 
 Q 0
 ;
 ; ENTRY POINT.  $$ANYREPL(DIR) = value of ANYREPL, 1 iff at least
 ; one global in DIR is replicated.
 ;
ANYREPL(DIR) 
 Q $$ANYBIT(DIR,"GFREPL")
REPLQ S $ZT="" C 63 Q ANYREPL
 ;
ANYBIT(DIR,BIT) ;
 if BIT="GFIMPL" Q 0  ; never set (doesn't exist)
 N X S $ZT="ANYQ",X="" O 63:"^^"_DIR S $ZT="" V 1 D GFS^ST
 I $V(%ST("GFOFFSET")+%ST("gfformat"),0,%ST("szformat")) S X=$V(%ST("GFOFFSET")+%ST("gfattrib"),0,%ST("szattrib"))
 E  S X=$V(%ST("GFOFFSET")+%ST("gfuse"),0,%ST("szuse"))
 S X=X\%ST(BIT)#2
ANYQ S $ZT="" C 63 Q X

REPAIR^INT^1^67214,47331
REPAIR ;REPAIR/EXAMINE PROGRAM FOR DATABASE DEGRADATION ;$Change: 7440104 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	; Revision: $Id: //iris/2024.1.3/databases/sys/rtn/diagnostic/repair.mac#1 $
 ; GXLATE.INC
 New remote
 Set remote=0
INIT
 n DIRNAM,%BLKSIZ,%UIC,%FILSIZ,%EXP,%MAX,%GD,%GP,%GG,%RD,%RG,%TOTVOL,%BIG,%MAPBLOCKS
 n %CURBLKS,%MAPSZ,%CURMAPS,%FREEZE,rc,addoff,REPVAL,REPAIR,REPPRINT,REPCCC
 n REPLEN,REPPAD,REPSUB,REPBIG,REPINFO,OFF,TYPE,LINK,BLK,A,N,X,NUMNODES
 n delerr,mtemp1,D,Z,F,L,S,Y,I,C,B,return,cod,i,DFIRST,DLAST,DEND,GD
 n msglist,%A,G,VAL,colrule,encG,curkeep,typeval,ans,pi
 New BIGCOUNT,BLINCVER,COLLATE,FREECOUNT,GARTREE,LEFT,LNEXTPNTREF,RIGHT,PNTLEN,NEXTPNTLEN,NEXTPNTREF,NEXTPNTVAL,NEXTPNTOFF,allocblk,blocktab,curlev,gloname,levels,link,mapblk,method,modblk,modtab,mtemp1,newblock,oldBLK,top,upblock,LA,PNTREF,POP,UA,already,dodump,domore,mapblknum,op,restoreBLK,tab,updatearray,%UTILITY
 New blk,blocks,dirblk,found,lev,levels,thisblk,treestr
 New bytes,domodify,numn,modok ;JO2166
 New oldREPVAL
 new SYS,DIR,SYSNUM,sfn,%DATABIG,%PTRBIG,%DATA
 s %DATA=1
 Goto:remote ASK
 Goto A
ECP ;Entry point to work with Client Side ECP cache
 Write !,"***ECP Client Cache Block Repair/Examine***",!!
 New remote
 Set remote=1
 Set $Ztrap="badError"
 Goto INIT
A W !,"***Block Repair/Examine Program***",!!
 Set $Ztrap="badError"
ASK ;
 s remote=+$G(remote)
 i remote {
	 s sfn=##class(SYS.ECP).AskUserForRemoteDir()
 	 i 'sfn s DIRNAM="" q  ;sfn #0 means they didn't make a choice
 	 s DIRNAM=##class(SYS.ECP).StorageDBName()
	 s rc=$$SetDatabaseVariables^%SYS.DATABASE(DIRNAM,.%BLKSIZ,.%UIC,.%FILSIZ,.%EXP,.%MAX,.%GD,.%GP,.%GG,.%RD,.%RG,.%TOTVOL,.%BIG,.%CURBLKS,.%MAPSZ,.%CURMAPS,.%FREEZE)
	 s %PTRBIG=%BIG 	 
	 s rc=$$SetDatabaseVariables^%SYS.DATABASE(+sfn,.%BLKSIZ,.%UIC,.%FILSIZ,.%EXP,.%MAX,.%GD,.%GP,.%GG,.%RD,.%RG,.%TOTVOL,.%BIG,.%CURBLKS,.%MAPSZ,.%CURMAPS,.%FREEZE)
	 s %DATABIG=%BIG
	 s %BIG=%PTRBIG
	 w !!,"To read data blocks, append 'D' to the block number.  Otherwise, pointer blocks"
	 w !,"from ",DIRNAM," are assumed",!
 } else {
	 d ASK^%SYS.FILE
	 q:DIRNAM=""
	 s rc=$$SetDatabaseVariables^%SYS.DATABASE(DIRNAM,.%BLKSIZ,.%UIC,.%FILSIZ,.%EXP,.%MAX,.%GD,.%GP,.%GG,.%RD,.%RG,.%TOTVOL,.%BIG,.%CURBLKS,.%MAPSZ,.%CURMAPS,.%FREEZE)
	 If %TOTVOL>1 {
		Try { Open 63:"^^"_DIRNAM } 
		Catch {
			Quit:$ze'["<NOTOPEN>"
			Set X=$zu(49,DIRNAM)
			Quit:(+X'=-1)&&(+X'=$zu(40,0,41))
			If ($$YN("Failed to open multi-volume database.  Display volume information","Y")="Y") {
				Do MultiVolumeDisplay(DIRNAM,%BLKSIZ,$piece(X,",",30))
				Goto ASK
			}
		}
	 }
 }
 quit:DIRNAM=""
 i ('rc) d ShowMessage(rc,0) g ASK
 s mirrorDB=('remote)&&$zb(+$p($zu(49,DIRNAM),",",17),+$ZU(40,8,28),1)
A1 W !,"Global Directory Block: ",%GD
 W !
 if ('remote) {  ;JO1564+
    Set rc=$$GetMapBlocks^DMREPAIR(DIRNAM,.%MAPBLOCKS)
    If ('rc) d ShowMessage(rc,0) Quit  
    Write !,"Map Blocks: "
    Set mapblk="" For  Set mapblk=$Order(%MAPBLOCKS(mapblk)) Quit:mapblk=""  Write mapblk," "
 }               ;JO1564-
A2 ;JO1564
 S LINK=0,BLK=0 W ! D menuREAD I 'BLK C 63 Q
B Write !,"Block Repair Function "_$Case(BLK,0:"",:"(Current Block "_BLK_"): ") 
 Read F
 If 'remote {
    If F>%CURBLKS {
	    s rc=$$SetDatabaseVariables^%SYS.DATABASE(DIRNAM,.%BLKSIZ,.%UIC,.%FILSIZ,.%EXP,.%MAX,.%GD,.%GP,.%GG,.%RD,.%RG,.%TOTVOL,.%BIG,.%CURBLKS,.%MAPSZ,.%CURMAPS,.%FREEZE)
	    If F>%CURBLKS Write !,"Block number too high",! Goto B
    }
    If F<0!(F[".") Write !,"Not a block number",! Goto B
 }
 If F="" Goto B
 If F>12 Set BLK=F Do R3 Goto B
 Set ans=$zcvt(F,"U")
 If ans="LEFT" || (ans="PREV" || (ans="PREVIOUS")) {
    If $$doLeft(BLK) { Do R3 } Goto B
 }
 If ans="LINK" || (ans="RIGHT" || (ans="NEXT")) {
    If $$doRight() { Do R3 } Goto B
 }
 If ans="UP" {
    If $$doUp(BLK) { Do R3 } Goto B
 }
 I F>0,F<13 S A=$T(FUN+F) W " ",$P(A,";;",2),! D @$P(A,";;",3) G B 
 I F="?" W ! DO  W ! G B
 . F I=1:1:12 S A=$T(FUN+I) W $J(I,6),")  ",$P(A,";;",2),!
 S F=$zconvert(F,"U")
 F I=1:1:12 S LA=$T(FUN+I) S UA=$zconvert(LA,"U") I $E($P(UA,";;",2),1,$L(F))=F W $E($P(LA,";;",2),$L(F)+1,99),! D @$P(LA,";;",3) G B
 W " ???" G B
doLeft(block) [BLK,DIRNAM] PRIVATE
{
 If '$Get(block) Write !,"No Current Block",! Quit 0
 Write !,"Searching for block to the left of ",block," ...",!
 Set rc=$$FindLeftBlock^DMREPAIR(DIRNAM,block,.LEFT)
 If ('rc) { Do ShowMessage(rc,0) Quit 0 }
 ElseIf LEFT { Write !,"Left Block is ",LEFT Set BLK=LEFT Quit 1 }
 Else { Write !,"No left block",! Quit 0 }
}
doRight() [BLK,LINK] PRIVATE
{
 If LINK { Set BLK=LINK Quit 1 }
 Else { Write !,"No link block",! Quit 0 }
 Quit  
}
doUp(block) [DIRNAM,BLK] PRIVATE
{
 If '$Get(block) Write !,"No Current Block",! Quit 0
 Set rc=$$FindPointerBlock^DMREPAIR(DIRNAM,block,.upblock)
 If ('rc) { d ShowMessage(rc,0) Quit 0 }
 ElseIf upblock { Write !,"Pointer block is ",upblock Set BLK=upblock Quit 1 }
 Else { Write !,"No upper block",! Quit 0 }
}
FUN ; ;
 ;;Read Block;;READ
 ;;Display Current Block;;DISPLAY
 ;;Alternate Display of Current Block using --more--;;moreDISPLAY
 ;;Edit Current Block;;EDIT
 ;;Write Current Block to Disk;;WRITE
 ;;Internal Detail of Current Block;;dumpDISPLAY
 ;;Saved Block Restore;;RESTORE
 ;;Block Dump;;dumpBLOCK
 ;;Pointer Tree;;TREE
 ;;Node Dump;;dumpNODE
 ;;Help;;HELP
 ;;Quit REPAIR;;quitREPAIR
TREE
 If TYPE=$Case(%BIG,0:170,:16) w !,"Not applicable to bitmap blocks" Quit
 If TYPE=9 {
    Open 63:"^^"_DIRNAM Set dirblk=%GD
    Write !,"This is a directory block: "_%GD
    For  View dirblk Do  Set dirblk=$v($Zutil(40,32,4),0,4) Quit:'dirblk  Write " => "_dirblk
    . For i=1:1 Set blk=$View(i*2,-5) Quit:blk=""  If blk=BLK Set found=dirblk Quit  
 Quit  
 }
 Set rc=$$FindGlobalLevels^DMREPAIR(DIRNAM,BLK,,,.curlev)
 If ('rc) Do ShowMessage(rc,0) Quit
 Write !,curlev," level"_$Case(curlev,1:"",:"s")
 Set (treestr,thisblk)=BLK
 For lev=1:1:curlev-1 {
    Set rc=$$FindPointerBlock^DMREPAIR(DIRNAM,thisblk,.upblock)
    If ('rc) d ShowMessage(rc,0) Quit
    If 'upblock Quit
    Else  Set treestr=upblock_" => "_treestr
    Set thisblk=upblock
 }
 ;Now find out which global directory block points here.
 Set found=0
 Open 63:"^^"_DIRNAM Set dirblk=%GD
 For  View dirblk Do  Quit:found  Set dirblk=$v($Zutil(40,32,4),0,4) Quit:'dirblk
 . For i=1:1 Set blk=$View(i*2,-5) Quit:blk=""  If blk=thisblk Set found=1 Quit  
 If 'found Write !,"Cannot find global directory block"
 Else  Set treestr="Directory block: "_dirblk_" => "_treestr
 Write !,treestr,!
 Quit
HELP 
 Write !,"Navigation Options:"
 Write !,"-If you enter a number greater than 12 REPAIR will read that block."
 Write !,"-If you enter ""left"" or ""previous"" REPAIR will read the block that precedes"
 Write !," the current block." ;if there is one."
 Write !,"-If you enter ""link"" or ""right"" or ""next"" REPAIR will read the link block."
 Write !,"-If you enter ""up"" REPAIR will read the pointer block that points"
 Write !," to the current block."
 Write !,"-At the Read Block prompt you can enter any block number or"
 Write !," any of the above options.",!
 Quit  
quitREPAIR ZQuit  
 Quit   
dumpBLOCK
 Write !,"Calling ^BLKDUMP"
 Do INT^BLKDUMP(DIRNAM,BLK) Quit   
displayBLOCK
 Write !,"Calling ^BITMAPSCAN"
 Do INT^BITMAPSCAN(DIRNAM,BLK) Quit   
RESTORE 
 Set restoreBLK=$Order(^REPAIR("restore",$Zutil(12,DIRNAM),""))
 Open 63:"^^"_DIRNAM
 While restoreBLK'="" {
    Write !,"Restore block ",restoreBLK," ? " Read ans
    If $TR(ans,"yn","YN")'?1"Y".E { W " Not restored",! }
    Else {
       View restoreBLK 
       View 0:0:-%BLKSIZ:^REPAIR("restore",$Zutil(12,DIRNAM),restoreBLK)
       d WriteBlock^DMREPAIR(restoreBLK)
       Write "Block ",restoreBLK," written",!
    }
    Set restoreBLK=$Order(^REPAIR("restore",$Zutil(12,DIRNAM),restoreBLK))
 }
 Close 63 Quit  
moreDISPLAY set domore=1 Goto DISPLAY
dumpDISPLAY Set dodump=1 Goto DISPLAY
menuREAD Write "Entering Block Repair Menu",!
	s oldBLK=BLK
READ Kill modtab R "Block #: ",A 
 s BLK=oldBLK
 If $zcvt(A,"U")="Q" Quit
 If 'remote {
    If A>%CURBLKS {
	    s rc=$$SetDatabaseVariables^%SYS.DATABASE(DIRNAM,.%BLKSIZ,.%UIC,.%FILSIZ,.%EXP,.%MAX,.%GD,.%GP,.%GG,.%RD,.%RG,.%TOTVOL,.%BIG,.%CURBLKS,.%MAPSZ,.%CURMAPS,.%FREEZE)
	    If A>%CURBLKS Write !,"Block number too high",! Goto READ
    }
    If A<0 || (A["." && ($e(A)'="^")) Write !,"Not a block number",! Goto READ
 }
 If A="" {
    Write ! Goto READ
 } else {
    Set BLK=A
    Set oldBLK=BLK
 }
 Set ans=$zcvt(A,"U")
 If ans="LEFT" || (ans="PREV" || (ans="PREVIOUS")) {
    If $$doLeft(BLK) { Goto R3 } Else { Goto READ }
 }
 If ans="LINK" || (ans="RIGHT" || (ans="NEXT")) {
    If $$doRight() { Goto R3 } Else { Goto READ }
 }
 If ans="UP" {
    If $$doUp(BLK) { Goto R3 } Else { Goto READ }
 }
 I A?1"L".E,LINK W "  Link Block ",LINK,! S BLK=LINK
 n NSPNAM s NSPNAM="^^"_DIRNAM
 G R3:A'?1"^".E
 If A?1"^[".E || (A?1"^|".E) Write !,"This requires a simple global name with no extended namespace syntax",! Goto READ
 Set gloname=A,A="^["""_NSPNAM_"""]"_$E(A,2,*)
 S $ZT="READERR"
 I '$D(@A) W " ??? does not exist",! G READ
R2 Set rc=$$GetGlobalPointers^%SYS.DATABASE(DIRNAM,gloname,.top,.BLK)
 If ('rc) Do ShowMessage(rc,0) Goto READ
  W !,"DATA BLOCK = ",BLK,"  TOP POINTER BLOCK = ",top,!
R3 I 'BLK W " ???",! G READ
 Kill modtab
 if (remote) {
    s %BIG=%PTRBIG,%DATA=0
    if ("Dd"[$E(BLK,$L(BLK))) {
       Set %DATA=1
    } Else {
       try {
          Open 63:"^^"_DIRNAM 
          View BLK
       } catch {
          Write !,"  Block could not be read from "_DIRNAM
          Write !,"  Attempting to read as ECP data block.  To read as an ECP"
          Write !,"  data block explicitly, append 'D' to the block number."
          Write !
          Set %DATA=1
       }
    }
    If %DATA {
	   Open 63:"#"_sfn 
	   View BLK 
	   s %BIG=%DATABIG
    }
 } else {
    Open 63:"^^"_DIRNAM View BLK
 }
 Set TYPE=$$GetBlockTypeFromViewBuffer^DMREPAIR(%BIG)
 i 'TYPE&remote {
   Open 63:"#"_sfn View BLK s %BIG=%DATABIG,%DATA=1
   Set TYPE=$$GetBlockTypeFromViewBuffer^DMREPAIR(%BIG)
 }
 If TYPE=24 { 
    Write !,"Big string block",!
    Do INT^BLKDUMP(DIRNAM,BLK)
    Write !
    Goto READ
 }
 If 'remote,TYPE=16 {
    Set rc=$$ParseMapBlock^DMREPAIR(DIRNAM,BLK,.FREECOUNT,.MAPNUM,.BITMAPTYPE,.BITMAPBAD,.INCRFILE,.INCRVER)
    i ('rc) d ShowMessage(rc,0) Set BLK=0 Goto READ
    Goto DISPLAY
 }
 If 'remote,TYPE=18 {
	Goto DISPLAY
 }
 k OFF,REPVAL,REPAIR,REPPRINT,REPCC,REPLEN,REPPAD,REPSUB,REPBIG,REPINFO
 k N,TYPE,LINK,BIGCOUNT,PNTLEN,NEXTPNTLEN,NEXTPNTVAL,NEXTPNTOFF,PNTREF,NEXTPNTREF,BLINCVER,COLLATE,GARTREE
 Set $Ztrap=""
 i ('remote)!('%DATA) {
    s rc=$$ParseRepairViewBuf^DMREPAIR(DIRNAM,.OFF,.REPAIR,.REPPRINT,.REPVAL,.REPCCC,.REPLEN,.REPPAD,.REPSUB,.REPBIG,.REPINFO,.N,.TYPE,.LINK,.BIGCOUNT,.PNTLEN,.NEXTPNTLEN,.NEXTPNTVAL,.NEXTPNTOFF,.PNTREF,.NEXTPNTREF,.BLINCVER,.COLLATE,.GARTREE)
 } else {
    s rc=$$ParseRepairViewBuf^DMREPAIR(sfn,.OFF,.REPAIR,.REPPRINT,.REPVAL,.REPCCC,.REPLEN,.REPPAD,.REPSUB,.REPBIG,.REPINFO,.N,.TYPE,.LINK,.BIGCOUNT,.PNTLEN,.NEXTPNTLEN,.NEXTPNTVAL,.NEXTPNTOFF,.PNTREF,.NEXTPNTREF,.BLINCVER,.COLLATE,.GARTREE)
 }
 i ('rc) {
    Write !,*7
    Do ShowMessage(rc,0)
    If ($listget($listget($extract(rc,3,*)),1,0)=195) 
         || ($Get(N)<1) {
       Goto READ
    }
    If ($listget($listget($extract(rc,3,*)),1,0)=218) {
       Write !,"Block contents that are parsable will be displayed.  If you write this block"
       Write !,"to disk, a new offset will be calculated to include only parsable nodes."
       Write !
    }
 }
DISPLAY If 'BLK Write !,"No block number, please pick a block" Quit  
 W !,"Block # ",BLK,?25,"Type: ",TYPE
 w $case(TYPE,2:" POINTER",6:" BOTTOM POINTER",8:" DATA",9:" GLOBAL DIR",24:" BIGDATA",66:" TOP POINTER",70:" TOP/BOTTOM POINTER",16:" BITMAP BLOCK",13:" SECURITY BLK",18:" VOLUME INFORMATION")
 If $Get(GARTREE) {
    k X
    Set rc=$$IsBlockAllocated^DMREPAIR(DIRNAM,BLK,.ans,.X)
    If ('rc) { Do ShowMessage(rc,0) }
    Else {
       Write !,?25,"(In garbage tree ",$Case(ans,1:"but is",:"and not")," allocated in map block ",X,")"
    }
 }
 If TYPE=16 {
    Write !,"Bitmap Block Type: "
    Write $case(BITMAPTYPE,"m":"Map Block",
                           "s":"Secondary Map Block (SATMAP)",
                           "i":"Incremental Bitmap Block",
                           "I":"Secondary Incremental Block",
                              :"Unknown ("_BITMAPTYPE_")")
    If $Data(%MAPBLOCKS(BLK)) {
       Write:BITMAPTYPE'="m" "  ***Unexpected bitmap type!"
       Write !,"Free Count: ",FREECOUNT
       Write !,"First block: ",%MAPBLOCKS(BLK,1)
       Write !,"Last block: ",%MAPBLOCKS(BLK,2)
    } Else {
       Write:BITMAPTYPE="m" "  ***Unexpected bitmap type!"
       Write !,"Summary Count: ",FREECOUNT
       Write !,"Map Number (recorded in block): ",MAPNUM
       if (BITMAPTYPE="i") || (BITMAPTYPE="I") {
          Write !,"Incremental File: ",INCRFILE
          Write !,"Incremental Version: ",INCRVER
       }
    }
    Write:BITMAPBAD !,"  *** Bitmap Block Marked BAD!"
    If $Case($$YN("Do ^BITMAPSCAN","N"),"Y":1,:0) Do INT^BITMAPSCAN(DIRNAM,BLK)
    ; return to the block menu (for edit, etc) for map blocks
    Quit:$Data(%MAPBLOCKS(BLK))
    Write !,"  No further action allowed for this bitmap type",!
    Goto READ
 }
 If (TYPE=18) {
	Do DisplayVolumeInfoBlock()
	If $$YN("Dump block contents","N")="Y" {
		Do INT^BLKDUMP(DIRNAM,BLK)
	}
	Write !!
	Goto READ
 }
 Else { W !,"Link Block: ",LINK,?25,"Offset: ",OFF,!,"Count of Nodes: ",N w:TYPE'=9 ?25,"Collate: ",$G(COLLATE) }
 If (TYPE=8)!(TYPE=9) {  ;JO2150
    If '$Data(BIGCOUNT) {
       Write !,"Cannot display this block because you have changed the type."
       Write !,"Please restart REPAIR to display this block"
       Quit  
    }
    If TYPE=8 Write ?48
    Else  Write ?25
    Write ?25,"Big String Nodes: ",BIGCOUNT
    Write !,"Pointer Length:",PNTLEN,?25,"Next Pointer Length:",NEXTPNTLEN
    Write ?48," Diff Byte:Hex ",$zh(NEXTPNTVAL)
    If $D(PNTREF) {
       Write !,"Pointer Reference:      ",$$clean(PNTREF("printable")) If $Get(dodump) zzdump PNTREF("internal")
    } Else {
       Write !,"Pointer Reference:      Unknown due to error"
    }
    If $D(NEXTPNTREF) {
       Write !,"Next Pointer Reference: ",$$clean(NEXTPNTREF("printable")) If $Get(dodump) zzdump NEXTPNTREF("internal")
       If +NEXTPNTOFF = -1 {
          Write !,"Next Pointer Reference stored at end does not match!"
          If $Get(dodump) Write !,"Stored reference:" zzdump $Piece(NEXTPNTOFF,",",2)
       } Else {
          Write !,"Next pointer stored? ",$Select(NEXTPNTOFF#2:"Yes",1:"No"),!
       }
    } Else {
       Write !,"Next Pointer Reference: Unknown due to error"
    }
 } Else {
    If N>1 {
       If $Data(REPPRINT(1)) Write !,"First Node: ",$$clean(REPPRINT(1))
       If $Data(REPPRINT(N)) Write !,"Last Node:  ",$$clean(REPPRINT(N))
    }
 }
 Read !!,"--more--",ans w ! If $zcvt(ans,"U")="Q" Quit
 W !,"#",?5,"Node",?29
 w $case(TYPE,8:"Data",24:"BIGDATA",9:"PTR,NEW GROWTH,COLL,TYPE,PROT",:"POINTER")
 W ! F D=1:1:N W D D PRINT If ($Get(domore)||$Get(dodump)) && '(D#20) Read !,"--more--",ans w ! If $zcvt(ans,"U")="Q" Quit
 Set (domore,dodump)=0 W ! Q
PRINT 
 Quit:'$Data(REPVAL(D))  
 S X=$G(REPVAL(D)) 
 W ?5,$$clean($G(REPPRINT(D))),?28," "
 If $Get(dodump) zzdump $Get(REPAIR(D)) Write !,?28," "
 If TYPE=9 {For pi=1:1:5 {Write $Piece(X,",",pi)_$Case(pi,2:"        ",:"    ")} Write ! Quit }
 I TYPE-8,TYPE-12,TYPE-24 D  W ! Q 
 . w $p(X,",",2),$case($p(X,",",1),1:" *big",:"")
 i $a(X)=8 w ! q  ;dummy first node, no data ; 6 for 2k blocks
 I $A(X)=0 W $$clean($E(X,2,$Length(X))),! Q 
 If $Ascii(X)=6!($Ascii(X)=4) {
    Open 63:"^^"_DIRNAM 
    View BLK
    W $$clean($View(D*2,-5)),! ;unicode strings need $v(,-5)
    Close 63
	Quit  
 }
 I $A(X)=1 {
   If $ZU(40,0,0) {
	   S Z=$A(X,2)*256+$A(X,3)*256+$A(X,4)*256+$A(X,5)
   } else {
 	   S Z=$A(X,5)*256+$A(X,4)*256+$A(X,3)*256+$A(X,2)
   }
   s:Z>2147483647 Z=Z-4294967296 
   W Z," *",! 
   Q
 }
 I ($case($A(X),3:1,5:1,7:1,13:1,:0)) G PRINTBIG
 I $A(X)=10 G PRINTDBL
 i $A(X)=12 G PRINTVECTOR
 G PRINT2:$A(X,$S($ZU(40,0,0):3,1:10))>127
 S Z=0 
 If $ZU(40,0,0) {
	 F J=3:1:10 S Z=Z*256+$A(X,J)
 } else {
 	F J=10:-1:3 S Z=Z*256+$A(X,J)
 }
 ;
PRINT1 S Y=$A(X,2) 
 I Y<128,Y S Z=Z_"E+"_Y
 I Y>127 S Y=256-Y S Z=Z_"E-"_Y
 W Z," **",! Q
PRINT2 If $ZU(40,0,0) F J=3:1:10 S A(J)=255-$A(X,13-J)
 Else  F J=3:1:10 S A(J)=255-$A(X,J)
 S A(3)=A(3)+1#256 F J=3:1:10 Q:A(J)  S A(J+1)=A(J+1)+1#256
 S Z=0 F J=10:-1:3 S Z=Z*256+A(J)
 S Z="-"_Z G PRINT1
PRINTBIG S NUM=$p(X,",",2) ; X has $C(<datatype code>),numblks,bytes in last block, block,block,... where $A(X) is a bigdb block datatype (see %syDatabase.inc)
 S REM=$p(X,",",3)
 S LEN=(NUM-1)*(%BLKSIZ-$zu(40,32,10))+REM
 if $A(X)=13 {
	 W "BIGVector: "
 } else {
	 w "BIG: "
 }
 W "LEN ",LEN," BLKS: " 
 i NUM+3'=$l(X,",") W "** BLOCK TOTAL MISMATCH **" Q
 f Z=1:1:NUM w:Z>1 "," w $p(X,",",3+Z)
 w ! Q
PRINTDBL S Z=$E(X,2,*),Z=$ZDASCII($S($ZU(40,0,0):$RE(Z),1:Z)) W Z," ***",! Q
PRINTVECTOR s Z=$E(X,2,*),Z=$ZU(220,Z,4) w Z,! Q
clean(data)     ; Convert all control characters to $c(3)
 s L=$l(data) q:'L ""
 s return=data
 f i=1:1:L s cod=$a(data,i) i cod<32!(cod>126&(cod<160)) s $e(return,i)=$c(3)
 q return
READERR S $ZT="" W !,$P($ZE,">")_">",! G READ
badError 
 If $ZE["<ZNBLK>" {
    Write !,"Cannot continue editing.",!
    Goto A2
 }
 Set $Ztrap=""
 Write !,$ZE
 Quit
mapEDIT ;
 New func,option
mapLoop Read !,"Map Edit Option: ",func Quit:func=""
 If 'BLK Write !,"No block" Quit  
 If func>0,func<7 Set option=$Text(FUNMAPEDIT+func) Write " ",$Piece(option,";;",2) Do @$Piece(option,";;",3) Goto mapLoop
 If func="?" {
    Write ! 
    For func=1:1:6 {
       Set option=$Text(FUNMAPEDIT+func)
       Write ?5,func,")  ",$Piece(option,";;",2),!
    }
    Goto mapLoop
 }
 Set func=$zconvert(func,"U")
 F I=1:1:6 S LA=$T(FUNMAPEDIT+I),UA=$zconvert(LA,"U") I $E($P(UA,";;",2),1,$L(func))=func W $E($P(LA,";;",2),$L(func)+1,99),! D @$P(LA,";;",3) Goto mapLoop
 Write " ???" Goto mapLoop
FUNMAPEDIT ; ;
 ;;Change Free Count ;;changeFREECOUNT
 ;;Allocate one Block ;;allocateBLOCK
 ;;Free (Deallocate) one Block ;;deallocateBLOCK
 ;;Dump Map Block ;;dumpBLOCK
 ;;Display Map Block ;;displayBLOCK
 ;;Allocate Entire Map ;;mapOUT
changeFREECOUNT 
 Write !,"Current free count in map block ",BLK," is ",FREECOUNT
 Read !,"New free count? ",ans
 If ans=FREECOUNT || ((ans\1)'=ans) Write !,"No change" Quit  
 Set rc=$$ChangeFreeCount^DMREPAIR(DIRNAM,BLK,ans,0,.newblock)
 i ('rc) d ShowMessage(rc,0)
 Set FREECOUNT=ans
 Write !,"Map block # "_BLK_" modified"
 Write !,"Change will be written to disk if you choose"
 Write !,"""5)  Write Current Block to Disk"" from the Block Repair menu."
 Write !,"To retain this change you must write this block to disk before"
 Write !," making additional edits to this block."
 Set modtab(BLK)=newblock
 Quit  
allocateBLOCK
deallocateBLOCK
 ;Use number of Map Edit Option for Allocate
 Set op=$S(func=2:1,$e(func)="A":1,1:0) 
 Write !,"Block to "_$Case(op,1:"Allocate",:"Deallocate")_"? :"
 Read allocblk
 Write !,$Case(op,1:"Allocate",:"Deallocate")_" block "_allocblk_" in map? " Read ans
 If $TR(ans,"yn","YN")?1"Y".E {
    Set rc=$$IsBlockAllocated^DMREPAIR(DIRNAM,allocblk,.ans,BLK)
    If ('rc) { Do ShowMessage(rc,0) Quit }
    If ans,op=1 Write !,"Block ",allocblk," is already allocated" Quit  
    If 'ans,'op Write !,"Block ",allocblk," is already deallocated" Quit  
    Set already=0
    Set rc=$$AllocateBlockInMap^DMREPAIR(DIRNAM,allocblk,op,,,.newblock)
    If ('rc) { Do ShowMessage(rc,0) Quit }
    Write !,"Map block # "_BLK_" modified"
    Write !,"Change will be written to disk if you choose"
    Write !,"""5)  Write Current Block to Disk"" from the Block Repair menu."
    Write !,"To retain this change you must write this block to disk before"
    Write !," making additional edits to this block."
    Set modtab(BLK)=newblock
 }
 Quit  
mapOUT
 Set rc=$$MapOut^DMREPAIR(DIRNAM,BLK,,.newblock)
 If ('rc) { Do ShowMessage(rc,0) Quit }
 Write !,"Map block # "_BLK_" modified"
 Write !,"Change will be written to disk if you choose"
 Write !,"""5)  Write Current Block to Disk"" from the Block Repair menu."
 Write !,"To retain this change you must write this block to disk before"
 Write !," making additional edits to this block."
 Set modtab(BLK)=newblock
 Quit  
EDIT ;
 i remote w !,"Cannot EDIT blocks from the ECP client cache." q
 If TYPE=$Case(%BIG,0:170,:16) Goto mapEDIT
BB R !,"Edit Option: ",F Q:F=""
 If 'BLK Write !,"No block" Quit
 ; Options 10,11,12 and 14 are only for Data & Global Directory blocks
 If (TYPE'=9 && (F=7 || ($zcvt(F,"U")="K"))) || 
    ((TYPE'=8) && (TYPE'=9) && ((F=10)!(F=11)!(F=12)!(F=14))) {  ;JO2150
    Write " Not applicable for this block type" Goto BB
 } Else {
    I F>0,F<15 S A=$T(FUNEDIT+F) W " ",$P(A,";;",2),! D @$P(A,";;",3) G BB
 }
 I F="?" {
    W ! F I=1:1:14 S A=$T(FUNEDIT+I) W $J(I,6),")  ",$P(A,";;",2),!
    Goto BB
 }
 S F=$zconvert(F,"U")
 F I=1:1:14 S LA=$T(FUNEDIT+I) S UA=$zconvert(LA,"U") I $E($P(UA,";;",2),1,$L(F))=F W $E($P(LA,";;",2),$L(F)+1,99),! D @$P(LA,";;",3) G BB
 W " ???" G BB
FUNEDIT ; ;
 ;;Delete Node ;;DENODE
 ;;Insert Node ;;INNODE
 ;;Value (Data or Down pointer) - Change ;;VALUE
 ;;Link - Change ;;LINK
 ;;Type - Change ;;TYPE
 ;;Blincversion4 - Change ;;BLINCVERSION4
 ;;Keep Flag - Change ;;KEEP
 ;;Node Dump ;;dumpNODE
 ;;Big string count - Change ;;BIGCOUNT
 ;;Blpntlen4 - Change;;BLPNTLEN4
 ;;Blnextpntlen4 - Change ;;BLNEXTPNTLEN4
 ;;Blnextpntvalue4 - Change ;;BLNEXTPNTVALUE4
 ;;Blnextpntoff - Change ;;BLNEXTPNTOFF
 ;;Collation - Change ;;COLLATION
dumpNODE
 If TYPE=$Case(%BIG,0:170,:16) w !,"Not applicable to bitmap blocks" Quit
 Read "Dump Node #: ",i Q:'i
 If i>N Write " ???",! Goto dumpNODE
 Set numn=1
 Do ASKSET("How many nodes to show? ",.numn)
 If numn="" Set numn=N
 Else  If i+numn>N Set numn=N-i
 Set dodump=$Case($$YN("Detailed display","N"),"Y":1,:0)
 For D=i:1:i+numn {
    Write !,D,?5,REPPRINT(D)
    If dodump {
       Write !,"Node Reference:" zzdump REPAIR(D)
       Write !,"Node Value:"
    }
    Set bytes=0
    If 'dodump {
       If ($x+$l(REPPRINT(D))>80) { Write ! } ;Else { Write "     " }
       Write "     "
       Write REPVAL(D)
    }
    Else {
       Do {
          Do zzdumpmore^BLKDUMP($Extract(REPVAL(D),bytes+1,bytes+256),bytes+256)
	  Set bytes=bytes+256
	  If bytes<$Length(REPVAL(D)) {
             Read !,"--more--",ans
	     If $zcvt(ans,"U")="Q" Quit  
	  }
       } While bytes<$Length(REPVAL(D))
    }
 }
 Quit  
COLLATION Write "Change block header collation byte from ",COLLATE," to: " Read X
 If X="" Write " ***No Change*** "
 If X<0 Write " ???",! Goto COLLATION
 Set COLLATE=X Quit  
BLPNTLEN4 
 Write "Change block header pointer length field from ",PNTLEN," to: " Read X
 If X="" Write " ***No Change*** " Quit
 If X<0 Write " ???",! Goto BLPNTLEN4
 If X>$L(REPAIR(1)) Write " exceeds length of first node!",! Goto BLPNTLEN4
 Set PNTLEN=X
 Set PNTREF("internal")=$Extract(REPAIR(1),1,X)
 Set rc=$$GetPrintableRef^DMREPAIR(.PNTREF,$zu(70,1,COLLATE))
 Do:('rc) ShowMessage(rc,0)
 Quit
BLNEXTPNTLEN4
 Write "Change block header next pointer length field from ",NEXTPNTLEN," to: " Read X
 If X="" Write " ***No Change*** " Quit
 If X<0 Write " ???",! Goto BLNEXTPNTLEN4
 Set NEXTPNTLEN=X
 Goto rebuildnextpntref
BLNEXTPNTVALUE4
 Write "Change block header Discriminator byte from Decimal(",NEXTPNTVAL,") Hex(",$ZH(NEXTPNTVAL),") to Decimal: " Read X Write !,"Hex: ",$zh(+X)
 If X="" || (X=NEXTPNTVAL) Write " ***No Change*** " Quit
 If X<0 Write " ???",! Goto BLNEXTPNTVALUE4
 Set NEXTPNTVAL=+X
rebuildnextpntref
 Set rc=$$WriteRepairBlock^DMREPAIR(.newblock,DIRNAM,BLK,TYPE,LINK,N,.REPAIR,.REPVAL,.REPCCC,.REPLEN,.REPPAD,.REPSUB,.REPBIG,.REPINFO,.PNTLEN,.NEXTPNTLEN,.NEXTPNTVAL,.NEXTPNTOFF,.BLINCVER,.COLLATE,$Get(NEXTPNTREF("internal")),.GARTREE)
 If ('rc) { Write !!,"Fatal error occurred building modified block #",$Get(BLK),"." Do ShowMessage(rc,0) Ztrap "NBLK" }
 Set rc=$$ParseRepairBlock^DMREPAIR(DIRNAM,,newblock,.OFF,.REPAIR,.REPPRINT,.REPVAL,.REPCCC,.REPLEN,.REPPAD,.REPSUB,.REPBIG,.REPINFO,.N,.TYPE,.LINK,.BIGCOUNT,.PNTLEN,.NEXTPNTLEN,.NEXTPNTVAL,.NEXTPNTOFF,.PNTREF,.NEXTPNTREF,.BLINCVER,.COLLATE,.GARTREE)
 If ('rc) { Write !!,"Error occurred parsing modified block #",$Get(BLK),"." Do ShowMessage(rc,0) Ztrap:($Get(N)<1) "NBLK" Write "You can continue editing the block, but might have degradation." }
 Quit
BLNEXTPNTOFF
 Write "Change block header indicator of stored next pointer from ",NEXTPNTOFF," to: " Read X
 If X="" Write " ***No Change*** " Quit
 If X<0 || (X>1) Write " ???",! Goto BLNEXTPNTOFF
 Set NEXTPNTOFF=X Quit  
BLINCVERSION4
 Write "Change block header incremental backup version from ",BLINCVER," to: " Read X
 If X="" || (X=BLINCVER) Write " ***No Change*** " Quit
 If X<0 Write " ???",! Goto BLINCVERSION4
 Set BLINCVER=X Quit  
BIGCOUNT
 Write "REPAIR will correct the value for the big string count in this block if you"
 Write !," choose ""Write Current Block to Disk"" from the Block Repair Function menu."
 Quit  
KEEP n D,X 
 w ! r "Change keep type for Node: ",D  ; D because PRINT expects it
 If D="" Write " ***No Change" Quit  
 W ! D PRINT^REPAIR R "Is this the node? ",X
 I $TR(X,"yn","YN")'?1"Y".E W " ***No Change" Q
 s typeval=$p(REPVAL(D),",",4)
 s curkeep=typeval#2 ;keep flag is bit 1 of type
 w !,"Current keep type is ",$case(curkeep,1:"TRUE",:"FALSE")
 w !,"Do you want to change it to ",$case(curkeep,0:"TRUE? ",:"FALSE? ") r X
 I $TR(X,"yn","YN")'?1"Y".E W " ***No Change" Q
 s $p(REPVAL(D),",",4)=typeval+$case(curkeep,1:-1,:1)
 q  
INNODE 
 Write !,"To insert a node that you will enter manually, type ""E""."
 Write !,"To insert a node specified in a global string, type ""G""."
 Read !,"How will you specify the global reference? => E ",method
 If method="" Set method="E"
 Write !
 If (method="?") || ($zcvt(method,"U")="HELP") {
    Write !,"For example you can use the ""G"" method to enter control characters like this:",!
    Write "Set ^foo(1)=""^THISGLOBAL(""_1_$c(4)_""sub""_"")"""
    Write !,"Then enter ^foo(1) at this prompt",!
    Goto INNODE
 } ElseIf ($zcvt(method,"U")="E") {
    Read "Insert Global Node: ^",G I G?1"^".E S G=$E(G,2,99)
 } ElseIf $zcvt(method,"U")="G" {
    Read "Global that contains the reference for the inserted node? ",glo
    If $e(glo,1)'="^" Set glo="^"_glo
    If '$Data(glo) Write !,glo," does not exist" Goto INNODE
    Set G=@glo I G?1"^".E S G=$E(G,2,99)
 } Else {
   Write "???" Goto INNODE
 }
 Q:G=""  G IN10:TYPE=9 S X=$P(G,"(",1),B=$L(X)
 I $D(REPPRINT(2)),$P($E(REPPRINT(2),2,99),"(")'=X DO  G INNODE
 . W "** Must be same global **",!
 I TYPE=8!(TYPE=12) R !,"Data Value (String only): ",VAL,!
 E  Do  
 . R !,"Down Pointer: ",VAL,!
 . If '(TYPE=6 || (TYPE=70)) Set VAL="0,"_VAL Quit 
 . R !,"Does that block contain any big string nodes? ",ans 
 . If $TR(ans,"yn","YN")'?1"Y".E W " No big string nodes",! Set VAL="0,"_VAL
 . Else  Set VAL="1,"_VAL
 s colrule=$$GetCollationRuleInViewBuffer^DMREPAIR(DIRNAM,BLK)
 If ('colrule) d ShowMessage(colrule,0) g INNODE 
 Set colrule=$List($List($e(colrule,3,$Length(colrule))))
 s encG=$$EncodeGlobalReference^DMREPAIR(G,colrule)
 s rc=$$InsertNodeInRepairBlock^DMREPAIR(DIRNAM,BLK,G,encG,VAL,.N,.REPAIR,.REPPRINT,.REPVAL,.REPCCC,.REPLEN,.REPPAD,.REPSUB,.REPBIG,.REPINFO,.OFF,.D)
 If +rc'=rc,rc d ShowMessage(rc,0)
 If ('rc) d ShowMessage(rc,0) Goto INNODE
 If D=1 && ($$YN("Modify associated blocks","N")="Y"){
    Set updatearray("internal")=REPAIR(1),updatearray("printable")=REPPRINT(1)
    Do gupdateFirst(DIRNAM,BLK,TYPE,.updatearray)
 }
 If D=N && (((TYPE=8 || (TYPE=9) || (TYPE=12) || (TYPE=24))) && LINK) && ($$YN("Modify associated blocks","N")="Y") Do gupdateLast(DIRNAM,BLK,LINK,REPAIR(N))
 If (TYPE=8 || (TYPE=9) || (TYPE=12) || (TYPE=24)) && ((D=1) || (D=N)) {
    Set rc=$$WriteRepairBlock^DMREPAIR(.newblock,DIRNAM,BLK,TYPE,LINK,N,.REPAIR,.REPVAL,.REPCCC,.REPLEN,.REPPAD,.REPSUB,.REPBIG,.REPINFO,.PNTLEN,.NEXTPNTLEN,.NEXTPNTVAL,.NEXTPNTOFF,.BLINCVER,.COLLATE,$Get(NEXTPNTREF("internal")),.GARTREE)
    If ('rc) { Write !!,"Fatal error occurred building modified block #",$Get(BLK),"." Do ShowMessage(rc,0) Ztrap "NBLK" }
    Set rc=$$ParseRepairBlock^DMREPAIR(DIRNAM,,newblock,.OFF,.REPAIR,.REPPRINT,.REPVAL,.REPCCC,.REPLEN,.REPPAD,.REPSUB,.REPBIG,.REPINFO,.N,.TYPE,.LINK,.BIGCOUNT,.PNTLEN,.NEXTPNTLEN,.NEXTPNTVAL,.NEXTPNTOFF,.PNTREF,.NEXTPNTREF,.BLINCVER,.COLLATE,.GARTREE)
    If ('rc) { Write !!,"Error occurred parsing modified block #",$Get(BLK),"." Do ShowMessage(rc,0) Ztrap:($Get(N)<1) "NBLK" Write "You can continue editing the block, but might have degradation." }
 }
 Use 0 Write ! g INNODE 
IN10 I G'?1A.AN&(G'?1"%".AN)!($L(G)>32) DO  Q
 . W " Incorrect syntax - No insertion",!
INGET 
 R !,"Pointer: ",VAL S VAL=+VAL
 R !,"New growth area: ",A S VAL=VAL_","_+A
 R !,"Collation type: ",A S VAL=VAL_","_+A
 R !,"Global type (Decimal #): 0 => ",A S VAL=VAL_","_+A
 R !,"Protection code (Decimal #): ",A S VAL=VAL_","_+A
 Set rc=$$InsertNodeInRepairBlock^DMREPAIR(DIRNAM,BLK,G,G,VAL,.N,.REPAIR,.REPPRINT,.REPVAL,.REPCCC,.REPLEN,.REPPAD,.REPSUB,.REPBIG,.REPINFO,.OFF,.D)
 If +rc'=rc,rc d ShowMessage(rc,0)
 If ('rc) d ShowMessage(rc,0) Goto INNODE
 Q
DENODE R "Delete Node #: ",D Q:'D
 If $Data(modtab("DELETE",D)) {
    Write !,"To delete node ",D," you must write this block to disk before"
    Write !," making additional edits to this block.",!
    Goto DENODE
 } Else { Set modtab("DELETE",D)="" }
 S (DFIRST,DLAST)=D I D[":" {
    If (TYPE=8 || (TYPE=9) || (TYPE=12) || (TYPE=24)) { S DFIRST=$P(D,":"),DLAST=$P(D,":",2) }
    Else { Write !,"Cannot delete a range of pointer nodes",! Goto DENODE }
 }
 ;
 I DFIRST<0!(DFIRST>N)!(DFIRST'?1N.N) W " ???",! G DENODE
 I DLAST<0!(DLAST>N)!(DLAST'?1N.N)!(DLAST<DFIRST) W " ???",! G DENODE
 Set rc=$$FindGlobalLevels^DMREPAIR(DIRNAM,BLK,.levels,.blocktab,.curlev)
 s modok=1  ;tracks whether REPAIR can automatically update related blocks
 If ('rc) {
	 w !,"Error locating this block in the tree: " do ShowMessage(rc,0)
	 w !,"  Repair will be unable to automatically update associated blocks"
	 w !,"  which may be affected by this change. You may continue and modify"
	 w !,"  any related blocks yourself."
	 r !,"Do you want to continue? <Yes> ",resp
	 w !
	 if "Nn"[$E(resp_"X") Goto DENODE
	 s modok=0
 }
 If modok,DFIRST=1 {
	 For i=1:1:levels {
	    if blocktab(i)=BLK {
	       Write !,"  Repair cannot update related blocks when deleting the node at the"
	       Write !,"  left edge of global tree. You may continue and modify any related"
	       Write !,"  blocks yourself."
	       r !,"Do you want to continue? <Yes> ",resp
	  	   w !
	       if "Nn"[$E(resp_"X") Goto DENODE
	       s modok=0
	       quit
        }
     }
 }
 W ! F D=DFIRST:1:DLAST D PRINT^REPAIR
 ;
 W $S(DFIRST=DLAST:"Is this the node",1:"Are these the nodes")
 R " to be deleted? ",X
 I $TR(X,"yn","YN")'?1"Y".E W " ***No Change",! G DENODE
 For D=DLAST:-1:DFIRST {  
    New prefix Set prefix=$Ascii(REPVAL(D))
    If $Get(BIGCOUNT)=1 && ($case(prefix,3:1,5:1,7:1,13:1,:0)) {
       u 0 w !,REPPRINT(D)_" is the only long string in this block.",!,"If you delete this node you must change the pointer block."
       Read !,"Do you want to continue? ",rc
       If $TR(rc,"yn","YN")'?1"Y".E { Write " ***No Change",! g DENODE }
       Read !,"Do you want REPAIR to change the pointer block? ",rc
       If $TR(rc,"yn","YN")'?1"Y".E { Write " ***Not changing pointer block" }
       Else {
          Set rc=$$FindPointerBlock^DMREPAIR(DIRNAM,BLK,.upblock)
          If ('rc) d ShowMessage(rc,0) Goto DENODE
          Do gupdateBigStringPtr(DIRNAM,BLK,upblock)
       }
    }
 }
 If '(TYPE=8 || (TYPE=9) || (TYPE=12) || (TYPE=24)) Set oldREPVAL=REPVAL(D)
 F D=DLAST:-1:DFIRST d  
 . s rc=$$DeleteNodeInRepairBlock^DMREPAIR(DIRNAM,BLK,D,.N,.REPAIR,.REPPRINT,.REPVAL,.REPCCC,.REPLEN,.REPPAD,.REPSUB,.REPBIG,.REPINFO,.OFF,.BIGCOUNT)
 . If +rc'=rc,rc Do ShowMessage(rc,0) 
 . i ('rc) Do ShowMessage(rc,0) Goto DENODE
 . If (D=1) && (TYPE=8 || (TYPE=9) || (TYPE=12) || (TYPE=24)) && (PNTLEN>$L(REPAIR(1))) Set PNTLEN=$L(REPAIR(1))
 . Set rc=$$WriteRepairBlock^DMREPAIR(.newblock,DIRNAM,BLK,TYPE,LINK,N,.REPAIR,.REPVAL,.REPCCC,.REPLEN,.REPPAD,.REPSUB,.REPBIG,.REPINFO,.PNTLEN,.NEXTPNTLEN,.NEXTPNTVAL,.NEXTPNTOFF,.BLINCVER,.COLLATE,$Get(NEXTPNTREF("internal")),.GARTREE)
 . If ('rc) { Write !!,"Fatal error occurred building modified block #",$Get(BLK),"." Do ShowMessage(rc,0) Ztrap "NBLK" }
 . Set rc=$$ParseRepairBlock^DMREPAIR(DIRNAM,,newblock,.OFF,.REPAIR,.REPPRINT,.REPVAL,.REPCCC,.REPLEN,.REPPAD,.REPSUB,.REPBIG,.REPINFO,.N,.TYPE,.LINK,.BIGCOUNT,.PNTLEN,.NEXTPNTLEN,.NEXTPNTVAL,.NEXTPNTOFF,.PNTREF,.NEXTPNTREF,.BLINCVER,.COLLATE,.GARTREE)
 . If ('rc) { Write !!,"Error occurred parsing modified block #",$Get(BLK),"." Do ShowMessage(rc,0) Ztrap:($Get(N)<1) "NBLK" Write "You can continue editing the block, but might have degradation." }
 Set modtab(BLK)=newblock Kill newblock
 if 'modok {
	 set domodify=0
 } else {
    If '(TYPE=8 || (TYPE=9) || (TYPE=12) || (TYPE=24)) {
       Set domodify=$Case($$YN("Modify associated blocks","N"),"Y":1,:0)
    } ElseIf (((D=1) && '((TYPE=9) && (BLK=3))) || (D=(N+1))) {  ;JO2438
		Set domodify=$Case($$YN("Modify associated blocks","N"),"Y":1,:0)
		If domodify {
			If D=1 {
				Set updatearray("internal")=REPAIR(1),updatearray("printable")=REPPRINT(1)
				Do gupdateFirst(DIRNAM,BLK,TYPE,.updatearray)
			} ElseIf LINK {
				Do gupdateLast(DIRNAM,BLK,LINK,REPAIR(N))
			}
		}
    } ;end if D=1 or N+1
 }  ;JO2166
 If '(TYPE=8 || (TYPE=9) || (TYPE=12) || (TYPE=24)) && domodify {
    If D=1 {
       Write !,"Searching for block to the left of ",BLK," ...",!
       Set rc=$$FindLeftBlock^DMREPAIR(DIRNAM,BLK,.LEFT)
       If ('rc) { Do ShowMessage(rc,0) Goto DENODE }
       Open 63:"^^"_DIRNAM View LEFT
       For i=2:2 If $View(i,-5)="" Quit  ;Find last node in left block
       Set LEFT=$View(i-2,-5) Close 63
    } Else { Set LEFT=$Piece(REPVAL(D-1),",",2) }
    If D'>N { Set RIGHT=$Piece(REPVAL(D),",",2) }
    Else {
       If LINK {
          Open 63:"^^"_DIRNAM View LINK
          Set RIGHT=$View(2,-5) Close 63
       } Else { Set RIGHT=0 }
    }
    Do gupdateDeletePointer(DIRNAM,BLK,TYPE,D,N,LEFT,RIGHT,$Piece(oldREPVAL,",",2))
    Write !,"We have updated the blocks to support deleting this pointer."
    If $Data(modtab(BLK)) {
       Write !,"Parsing updated block ",BLK
       s rc=$$ParseRepairBlock^DMREPAIR(DIRNAM,,modtab(BLK),.OFF,.REPAIR,.REPPRINT,.REPVAL,.REPCCC,.REPLEN,.REPPAD,.REPSUB,.REPBIG,.REPINFO,.N,.TYPE,.LINK,.BIGCOUNT,.PNTLEN,.NEXTPNTLEN,.NEXTPNTVAL,.NEXTPNTOFF,.PNTREF,.NEXTPNTREF,.BLINCVER,.COLLATE,.GARTREE)
       If ('rc) { Write !!,"Error occurred parsing modified block #",$Get(BLK),"." Do ShowMessage(rc,0) Ztrap:($Get(N)<1) "NBLK" Write "You can continue editing the block, but might have degradation." }
       Kill modtab(BLK)
    }
 } ;End if data block and do modify
 u 0 w ! g DENODE
VALUE W "Change ",$S(TYPE=8!(TYPE=24):"Data value",TYPE=9:"Value",1:"Pointer")
 W " of node #: " R D Q:D=""  I D<1!(D>N)!(D'?1.N) W " ???",! G VALUE
 W ! D PRINT^REPAIR R "Is this the node? ",X
 I $TR(X,"yn","YN")'?1"Y".E W " ***No Change" Q
 I TYPE=1 D INGET S REPVAL(D)=VAL Q  ; CHECK this out
 I TYPE=9 D  Q
 . W !,"Pointer ("_$p(REPVAL(D),",",1)_"): " R VAL S:VAL'="" $p(REPVAL(D),",",1)=+VAL
 . W !,"New growth area ("_$p(REPVAL(D),",",2)_"): " R VAL S:VAL'="" $p(REPVAL(D),",",2)=+VAL
 . W !,"Collation type ("_$p(REPVAL(D),",",3)_"): " R VAL S:VAL'="" $p(REPVAL(D),",",3)=+VAL
 . W !,"Global type (Decimal #)("_$p(REPVAL(D),",",4)_"): " R VAL S:VAL'="" $p(REPVAL(D),",",4)=+VAL
 . W !,"Protection code (Decimal #)("_$p(REPVAL(D),",",5)_"): " R VAL S:VAL'="" $p(REPVAL(D),",",5)=+VAL
 W !,"NEW ",$S(TYPE=8!(TYPE=24):"Data value (string only)",1:"Pointer"),": " R X
 New prefix Set prefix=$Ascii(REPVAL(D))
 If ($case(prefix,3:1,5:1,7:1,13:1,:0)) {
    u 0 w !,REPPRINT(D)_" is a long string.",!,"If you change this value you must change the pointer block."
    Read !,"Do you want to continue? ",rc
    If $TR(rc,"yn","YN")'?1"Y".E Write " ***No Change" Quit
 }
 If (TYPE=6 || (TYPE=70)) {
    R !,"Does that block contain any big string nodes? ",ans
    If $TR(ans,"yn","YN")'?1"Y".E W " No big string nodes",! Set X="0,"_X
    Else  Set X="1,"_X
 } ElseIf '(TYPE=8 || (TYPE=9) || (TYPE=12) || (TYPE=24)) {
    Set X="0,"_X
 }
 s rc=$$ChangeValueInRepairBlock^DMREPAIR(DIRNAM,BLK,D,X,.REPAIR,.REPVAL,.REPCCC,.REPLEN,.REPPAD,.REPSUB,.REPBIG,.REPINFO,.OFF)
 i ('rc) d ShowMessage(rc,0)
 q  
LINK W "Change link from ",LINK," to: " R X
 I X="" W " ***No Change (Specify 0 to delete link)",! Q
 I X<0 W " ???",! G LINK
 Set LINK=X
 If LINK && ($$YN("Modify associated blocks","N")="Y") Do gupdateLast(DIRNAM,BLK,LINK,REPAIR(N))
 Quit  
TYPE 
 W "Change type from ",$$GetTypeName^DMREPAIR(TYPE)," to one of the following: ",!
 F I=2,6,8,9,24,66,70 w ?10,I,?15,$$GetTypeName^DMREPAIR(I),!
TYP1 R !,"New type: ",Z I Z="" W " ***No Change",! Q
 s Y=$$GetTypeName^DMREPAIR(Z) i Y="" W " ??? Choose a # or press <RETURN>",! G TYP1
 W " ",Y,!
 If $Get(GARTREE) {
    Write !,"The block type field indicates this block is in the garbage tree.",!
    If $$YN("Do you want to retain this setting?","Y")="N" Set GARTREE=0
 } Else {
    Write !,"The block type field indicates this block is not in the garbage tree.",!
    If $$YN("Do you want to retain this setting?","Y")="N" Set GARTREE=1
 }
 S X=TYPE,TYPE=Z W " ",Y,!
 Write !,"If you make this change REPAIR will change the block immediately,"
 Write !," as opposed to waiting until you choose the Write option. "
 Write !,"If you have other edits in this block you should save those first"
 Write !,"before making this change"
 If $$YN("Do you want to make the change?","N")="Y" {
    Open 63:"^^"_DIRNAM View BLK
    If DIRNAM'=$Zutil(12) {
       Write !,"Saving old block in ^REPAIR(""restore""",",","""",DIRNAM,"""",",",BLK,")"
       Set ^REPAIR("restore",DIRNAM,BLK)=$View(0,0,-%BLKSIZ)
    }
    Write !,"Writing new block ",BLK,!
    View $Zutil(40,32,1):0:1:TYPE
    d WriteBlock^DMREPAIR(BLK)
    Quit
 }
 Close 63
 Q  ; For now allow any type to be switched to any other type
WRITE ;
 i remote w !,"Cannot WRITE blocks from the ECP client cache." q
 W !,"Writing modified block ",BLK
 if $G(mirrorDB) w " (will not be reflected on other mirror members)"
 w !
okayWRITE R "Okay? Please answer yes or no: ",X,!
 If ($zcvt(X,"U")'="YES"),($zcvt(X,"U")'="NO") Goto okayWRITE
 If ($zcvt(X,"U")'="YES") W "***Not Written",! kill modtab Q 
 Open 63:"^^"_DIRNAM View BLK
 If DIRNAM'=$Zutil(12) {
    Write "Saving old block in ^REPAIR(""restore""",",","""",DIRNAM,"""",",",BLK,")"
    Set ^REPAIR("restore",DIRNAM,BLK)=$View(0,0,-%BLKSIZ)
 }
 Write !,"Writing new block ",BLK,!
 If TYPE=$Case(%BIG,0:170,:16) {
    If $Data(modtab(BLK)) View 0:0:-%BLKSIZ:modtab(BLK) d WriteBlock^DMREPAIR(BLK)
    Kill modtab(BLK)
    Quit
 }
 Kill modtab(BLK)
 Close 63
 s rc=$$WriteRepairBlock^DMREPAIR("disk",DIRNAM,BLK,TYPE,LINK,N,.REPAIR,.REPVAL,.REPCCC,.REPLEN,.REPPAD,.REPSUB,.REPBIG,.REPINFO,.PNTLEN,.NEXTPNTLEN,.NEXTPNTVAL,.NEXTPNTOFF,.BLINCVER,.COLLATE,$Get(NEXTPNTREF("internal")),.GARTREE)
 i ('rc) d ShowMessage(rc,0) Quit 
 If $Data(modtab) {
    Open 63:"^^"_DIRNAM
    Set modblk=$Order(modtab(""))
    While (modblk'="" && (modblk'="DELETE")) {
       View modblk
       If DIRNAM'=$Zutil(12) Set ^REPAIR("restore",DIRNAM,modblk)=$View(0,0,-%BLKSIZ)
       Write !,"Now REPAIR will write updated block ",modblk,!
okayMOD	  
       R "Okay? Please answer yes or no: ",X,!
       If ($zcvt(X,"U")'="YES"),($zcvt(X,"U")'="NO") Goto okayMOD
       If ($zcvt(X,"U")'="YES") {
          W "***Not Written",!
       } Else {
          If DIRNAM'=$Zutil(12) {
             Write "Saving old block in ^REPAIR(""restore""",",","""",DIRNAM,"""",",",modblk,")",!,"Writing new block ",modblk,!
          } Else {
             Write !,"Writing new block ",modblk,!
          }
          View 0:0:-%BLKSIZ:modtab(modblk)
          d WriteBlock^DMREPAIR(modblk)
       }
       Set modblk=$Order(modtab(modblk))
    }
    Kill modtab
 }
 Close 63 Quit  
gupdateFirst(dir,blk,type,newfirst) [modtab,PNTLEN,PNTREF,LNEXTPNTREF] PUBLIC
{
 Set $Zerror="",$Ztrap="errgupdateFirst"
 If (type=8 || (type=9) || (type=12) || (type=24)) {
    Write !,"Searching for block to the left of ",blk," ...",!
    Set rc=$$FindLeftBlock^DMREPAIR(dir,blk,.left)
    If ('rc) {d ShowMessage(rc,0) Do gupdateErrorMsg Quit  }    
    If left {
       If $Data(modtab(left)) {
          Set rc=$$ParseRepairBlock^DMREPAIR(dir,,modtab(left),.LOFF,.LREPAIR,.LREPPRINT,.LREPVAL,.LREPCCC,.LREPLEN,.LREPPAD,.LREPSUB,.LREPBIG,.LREPINFO,.LN,.LTYPE,.LLINK,.LBIGCOUNT,.LPNTLEN,.LNEXTPNTLEN,.LNEXTPNTVAL,.LNEXTPNTOFF,.LPNTREF,.LNEXTPNTREF,.LBLINCVER,.LCOLLATE,.LGARTREE)
          Kill modtab(left)
       } Else {
          Set rc=$$ParseRepairBlock^DMREPAIR(dir,left,,.LOFF,.LREPAIR,.LREPPRINT,.LREPVAL,.LREPCCC,.LREPLEN,.LREPPAD,.LREPSUB,.LREPBIG,.LREPINFO,.LN,.LTYPE,.LLINK,.LBIGCOUNT,.LPNTLEN,.LNEXTPNTLEN,.LNEXTPNTVAL,.LNEXTPNTOFF,.LPNTREF,.LNEXTPNTREF,.LBLINCVER,.LCOLLATE,.LGARTREE)
       }
       If ('rc) {d ShowMessage(rc,0) Do gupdateErrorMsg Quit  }
       For i=1:1:($L(LREPAIR(LN))+1) {
          Quit:$Extract(LREPAIR(LN),i)'=$Extract(newfirst("internal"),i)
       }
       Set (LNEXTPNTLEN,PNTLEN)=i,LNEXTPNTVAL=$Ascii(newfirst("internal"),i)
       Set LNEXTPNTREF("internal")=$Extract(newfirst("internal"),1,i)
       Write !,"Updating left data block, ",left,", with new Next Pointer Reference: " zzdump LNEXTPNTREF("internal")
       Set rc=$$WriteRepairBlock^DMREPAIR(.newleftblock,dir,left,LTYPE,LLINK,LN,.LREPAIR,.LREPVAL,.LREPCCC,.LREPLEN,.LREPPAD,.LREPSUB,.LREPBIG,.LREPINFO,LPNTLEN,LNEXTPNTLEN,LNEXTPNTVAL,LNEXTPNTOFF,LBLINCVER,LCOLLATE,LNEXTPNTREF("internal"),LGARTREE)
       If ('rc) {d ShowMessage(rc,0) Do gupdateErrorMsg Quit  }
       Set rc=$$ParseRepairBlock^DMREPAIR(dir,,newleftblock,.LOFF,.LREPAIR,.LREPPRINT,.LREPVAL,.LREPCCC,.LREPLEN,.LREPPAD,.LREPSUB,.LREPBIG,.LREPINFO,.LN,.LTYPE,.LLINK,.LBIGCOUNT,.LPNTLEN,.LNEXTPNTLEN,.LNEXTPNTVAL,.LNEXTPNTOFF,.LPNTREF,.LNEXTPNTREF,.LBLINCVER,.LCOLLATE,.LGARTREE)
       If ('rc) {d ShowMessage(rc,0) Do gupdateErrorMsg Quit  }
       Set modtab(left)=newleftblock
       Merge PNTREF=LNEXTPNTREF
    }
    Do:type'=9 modifyHigherLevels(dir,blk,.PNTREF)
 } Else { ;not a data block
    Do modifyHigherLevels(dir,blk,.newfirst)
 }
 Quit  
errgupdateFirst Do gupdateErrorMsg
 Quit  
}
modifyHigherLevels(dir,blk,newref) [modtab,LNEXTPNTREF] PUBLIC
{
 Write !,"Modifying higher levels with new reference ",newref("printable")
 Write !,"Internal version is:" zzdump newref("internal")
 Set rc=$$FindGlobalLevels^DMREPAIR(dir,blk,.levels,.blocktab,.curlev)
 If ('rc) {d ShowMessage(rc,0) Do gupdateErrorMsg Quit  }    
 Write !,"The current level, which contains block ",blk," is ",curlev
 Set modblk=blocktab(curlev-1),found=0
 If curlev=1 Quit  
 If modblk>%CURBLKS || ('modblk) Do gupdateErrorMsg Quit  
 Open 63:"^^"_dir ;This gets closed by gupdatePtrBlk
 Do {
    View modblk Set modtype=$v($Zutil(40,32,1),0,1)
    ; Use the most current version of the block if it is being edited
    If $Data(modtab(modblk)) View 0:0:-%BLKSIZ:modtab(modblk)
    Set node=1
    Do {
       Set curblk=$View(node*2,-5)
       If curblk=blk {
          Set insertval=$View(node*2,-6) ;add big string flag piece
          u 0 w !!,"update node ",node," in block ",modblk
          Do gupdatePtrBlk(dir,node,modblk,insertval,.newref)
          Open 63:"^^"_dir ;This gets closed by gupdatePtrBlk
       }
       Set node=node+1
    } While (curblk'="" && (curblk'=blk))
    If curblk'=blk {
       View modblk
       If $Data(modtab(modblk)) View 0:0:-%BLKSIZ:modtab(modblk)
       Set modblk=$v($Zutil(40,32,4),0,4) 
    } Else {
       Set found=1
    }
 } While ('found && modblk && (modblk'>%CURBLKS))
 If curblk'=blk {
    Write !,"Block ",blk," cannot be found on level ",curlev-1
    Do gupdateErrorMsg
    Quit  
 }
 Close 63
 If (node=2) Do gupdateFirst(dir,modblk,modtype,.newref)
 Quit  
}
gupdatePtrBlk(dir,node,modblk,block,ref) [modtab] PUBLIC
{
 If $Data(modtab(modblk)) Set rc=$$ParseRepairBlock^DMREPAIR(dir,,modtab(modblk),.MOFF,.MREPAIR,.MREPPRINT,.MREPVAL,.MREPCCC,.MREPLEN,.MREPPAD,.MREPSUB,.MREPBIG,.MREPINFO,.MN,.MTYPE,.MLINK,.MBIGCOUNT,.MPNTLEN,.MNEXTPNTLEN,.MNEXTPNTVAL,.MNEXTPNTOFF,.MPNTREF,.MNEXTPNTREF,.MBLINCVER,.MCOLLATE,.MGARTREE)
 Else  Set rc=$$ParseRepairBlock^DMREPAIR(dir,modblk,,.MOFF,.MREPAIR,.MREPPRINT,.MREPVAL,.MREPCCC,.MREPLEN,.MREPPAD,.MREPSUB,.MREPBIG,.MREPINFO,.MN,.MTYPE,.MLINK,.MBIGCOUNT,.MPNTLEN,.MNEXTPNTLEN,.MNEXTPNTVAL,.MNEXTPNTOFF,.MPNTREF,.MNEXTPNTREF,.MBLINCVER,.MCOLLATE,.MGARTREE)
 If ('rc) {d ShowMessage(rc,0) Do gupdateErrorMsg Quit  }
 Write !,"Updating pointer block ",modblk,", by deleting node ",node," and inserting in its place: " zzdump ref("internal")
 s rc=$$DeleteNodeInRepairBlock^DMREPAIR(dir,modblk,node,.MN,.MREPAIR,.MREPPRINT,.MREPVAL,.MREPCCC,.MREPLEN,.MREPPAD,.MREPSUB,.MREPBIG,.MREPINFO,.MOFF,.MBIGCOUNT)
 If ('rc) {d ShowMessage(rc,0) Do gupdateErrorMsg Quit  }    
 ;Write and parse the block after deleting
 Set rc=$$WriteRepairBlock^DMREPAIR(.newmodblk,dir,modblk,MTYPE,MLINK,MN,.MREPAIR,.MREPVAL,.MREPCCC,.MREPLEN,.MREPPAD,.MREPSUB,.MREPBIG,.MREPINFO,,,,,,,.MGARTREE)
 If ('rc) {d ShowMessage(rc,0) Do gupdateErrorMsg Quit  }    
  Set rc=$$ParseRepairBlock^DMREPAIR(dir,,newmodblk,.MOFF,.MREPAIR,.MREPPRINT,.MREPVAL,.MREPCCC,.MREPLEN,.MREPPAD,.MREPSUB,.MREPBIG,.MREPINFO,.MN,.MTYPE,.MLINK,.MBIGCOUNT,.MPNTLEN,.MNEXTPNTLEN,.MNEXTPNTVAL,.MNEXTPNTOFF,.MPNTREF,.MNEXTPNTREF,.MBLINCVER,.MCOLLATE,.MGARTREE)
 If ('rc) {d ShowMessage(rc,0) Do gupdateErrorMsg Quit  }    
 s rc=$$InsertNodeInRepairBlock^DMREPAIR(dir,modblk,ref("printable"),ref("internal"),block,.MN,.MREPAIR,.MREPPRINT,.MREPVAL,.MREPCCC,.MREPLEN,.MREPPAD,.MREPSUB,.MREPBIG,.MREPINFO,.MOFF)
 If ('rc) {d ShowMessage(rc,0) Do gupdateErrorMsg Quit  }
 if rc,rc'=+rc d ShowMessage(rc,0)
 Set rc=$$WriteRepairBlock^DMREPAIR(.newmodblk,dir,modblk,MTYPE,MLINK,MN,.MREPAIR,.MREPVAL,.MREPCCC,.MREPLEN,.MREPPAD,.MREPSUB,.MREPBIG,.MREPINFO,,,,,,,.MGARTREE)
 If ('rc) {d ShowMessage(rc,0) Do gupdateErrorMsg Quit  }    
  Set rc=$$ParseRepairBlock^DMREPAIR(dir,,newmodblk,.MOFF,.MREPAIR,.MREPPRINT,.MREPVAL,.MREPCCC,.MREPLEN,.MREPPAD,.MREPSUB,.MREPBIG,.MREPINFO,.MN,.MTYPE,.MLINK,.MBIGCOUNT,.MPNTLEN,.MNEXTPNTLEN,.MNEXTPNTVAL,.MNEXTPNTOFF,.MPNTREF,.MNEXTPNTREF,.MBLINCVER,.MCOLLATE,.MGARTREE)
 If ('rc) {d ShowMessage(rc,0) Do gupdateErrorMsg Quit  }    
 Set modtab(modblk)=newmodblk Kill newmodblk
}
 ;
gupdateLast(dir,blk,link,newlast) [modtab,NEXTPNTLEN,NEXTPNTREF,NEXTPNTVAL] PUBLIC
{
 Set $Zerror="",$Ztrap="errgupdateLast"
 If $Data(modtab(link)) Set rc=$$ParseRepairBlock^DMREPAIR(dir,,modtab(link),.LOFF,.LREPAIR,.LREPPRINT,.LREPVAL,.LREPCCC,.LREPLEN,.LREPPAD,.LREPSUB,.LREPBIG,.LREPINFO,.LN,.LTYPE,.LLINK,.LBIGCOUNT,.LPNTLEN,.LNEXTPNTLEN,.LNEXTPNTVAL,.LNEXTPNTOFF,.LPNTREF,.LNEXTPNTREF,.LBLINCVER,.LCOLLATE,.LGARTREE)
 Else  Set rc=$$ParseRepairBlock^DMREPAIR(dir,link,,.LOFF,.LREPAIR,.LREPPRINT,.LREPVAL,.LREPCCC,.LREPLEN,.LREPPAD,.LREPSUB,.LREPBIG,.LREPINFO,.LN,.LTYPE,.LLINK,.LBIGCOUNT,.LPNTLEN,.LNEXTPNTLEN,.LNEXTPNTVAL,.LNEXTPNTOFF,.LPNTREF,.LNEXTPNTREF,.LBLINCVER,.LCOLLATE,.LGARTREE)
 If ('rc) {d ShowMessage(rc,0) Do gupdateErrorMsg Quit  }
 For i=1:1:$L(newlast)+1 {
    Quit:$Extract(newlast,i)'=$Extract(LREPAIR(1),i)
 }
 Set (NEXTPNTLEN,newlinkpntlen)=i,NEXTPNTVAL=$Ascii(LREPAIR(1),i)
 Set NEXTPNTREF("internal")=$Extract(LREPAIR(1),1,i)
 Write !,"Updating data block, ",blk,", with new Next Pointer Reference: "
 zzdump NEXTPNTREF("internal")
 Write !,"Updating right data block, ",link,", with new pntlen ",newlinkpntlen
 Open 63:"^^"_dir View link 
 If $Data(modtab(link)) View 0:0:-%BLKSIZ:modtab(link)
 View $Zutil(40,32,3):0:2:newlinkpntlen
 Set rc=$$GetNodeReferences^DMREPAIR(0,.internal,.printable)
 If ('rc) {d ShowMessage(rc,0) Do gupdateErrorMsg Quit  }
 Set newlinkpntref("internal")=internal,newlinkpntref("printable")=printable
 Kill NEXTPNTREF Merge NEXTPNTREF=newlinkpntref
 Set modtab(link)=$View(0,0,-%BLKSIZ)
 Close 63
 If ($$YN("Modify associated blocks on higher levels","N")="Y") {
	Do modifyHigherLevels(dir,link,.newlinkpntref)
 }
 Quit  
errgupdateLast Do gupdateErrorMsg
}
gupdateDeletePointer(dir,blk,type,node,numnodes,left,right,nodeval) [modtab] PUBLIC
{
 Open 63:"^^"_dir
 If (type=6 || (type=70)) {
    Set leftdata=left,rightdata=right
    If rightdata {
       View rightdata 
       If $Data(modtab(rightdata)) View 0:0:-%BLKSIZ:modtab(rightdata)
       Set rightfirstnode=$View(1,-6)
    } Else { 
       Set rightfirstnode=0
    }
 } Else {
    Write !,"Updating lower blocks while deleting node ",node
    Write !,"Updating left block on this level, ",left,", with new link, ",right
    View left
    If $Data(modtab(left)) View 0:0:-%BLKSIZ:modtab(left)
    View $Zutil(40,32,4):0:4:right
    Set modtab(left)=$View(0,0,-%BLKSIZ)
    View nodeval
    If $Data(modtab(nodeval)) View 0:0:-%BLKSIZ:modtab(nodeval)
    While ('($v($Zutil(40,32,1),0,1)=6 || ($v($Zutil(40,32,1),0,1)=70))) {
       Set firstptr=$View(2,-5)
       Write !,"Searching for block to the left of ",firstptr," ...",!
       Set rc=$$FindLeftBlock^DMREPAIR(dir,firstptr,.leftptr)
       If ('rc) {d ShowMessage(rc,0) Do gupdateErrorMsg Quit  }
       Open 63:"^^"_dir
       If right {
          View right 
          If $Data(modtab(right)) View 0:0:-%BLKSIZ:modtab(right)
          Set rightptr=$View(2,-5)
       } Else {
          Set rightptr=0
       }
       View leftptr 
       If $Data(modtab(leftptr)) View 0:0:-%BLKSIZ:modtab(leftptr)
       View $Zutil(40,32,4):0:4:rightptr
       Set modtab(leftptr)=$View(0,0,-%BLKSIZ)
       Set right=rightptr
       View firstptr
       If $Data(modtab(firstptr)) View 0:0:-%BLKSIZ:modtab(firstptr)
    }
    Write !,"Searching for block to the left of ",$View(2,-5)," ...",!
    Set rc=$$FindLeftBlock^DMREPAIR(dir,$View(2,-5),.leftdata)
    If ('rc) {d ShowMessage(rc,0) Do gupdateErrorMsg Quit  }
    Open 63:"^^"_dir
    If right {
       View right 
       If $Data(modtab(right)) View 0:0:-%BLKSIZ:modtab(right)
       Set rightdata=$View(2,-5) View rightdata
       If $Data(modtab(rightdata)) View 0:0:-%BLKSIZ:modtab(rightdata)
       Set rightfirstnode=$View(1,-6)
    } Else {
       Set rightdata=0
    }
 }
 ;
 If $Data(modtab(leftdata)) Set rc=$$ParseRepairBlock^DMREPAIR(dir,,modtab(leftdata),.LOFF,.LREPAIR,.LREPPRINT,.LREPVAL,.LREPCCC,.LREPLEN,.LREPPAD,.LREPSUB,.LREPBIG,.LREPINFO,.LN,.LTYPE,.LLINK,.LBIGCOUNT,.LPNTLEN,.LNEXTPNTLEN,.LNEXTPNTVAL,.LNEXTPNTOFF,.LPNTREF,.LNEXTPNTREF,.LBLINCVER,.LCOLLATE,.LGARTREE)
 Else  Set rc=$$ParseRepairBlock^DMREPAIR(dir,leftdata,,.LOFF,.LREPAIR,.LREPPRINT,.LREPVAL,.LREPCCC,.LREPLEN,.LREPPAD,.LREPSUB,.LREPBIG,.LREPINFO,.LN,.LTYPE,.LLINK,.LBIGCOUNT,.LPNTLEN,.LNEXTPNTLEN,.LNEXTPNTVAL,.LNEXTPNTOFF,.LPNTREF,.LNEXTPNTREF,.LBLINCVER,.LCOLLATE,.LGARTREE)
 If ('rc) {d ShowMessage(rc,0) Do gupdateErrorMsg Quit  }
 If (right) {
    Set llastnoderef=LREPAIR(LN),llastnodereflen=$Length(llastnoderef)
    For i=1:1:llastnodereflen+1 {
       Quit:$Extract(llastnoderef,i)'=$Extract(rightfirstnode,i)
    }
    Set (LNEXTPNTLEN,RPNTLEN)=i,LNEXTPNTVAL=$Ascii(rightfirstnode,i)
    Set LNEXTPNTREF("internal")=$Extract(rightfirstnode,1,i)
 } Else {
    Set (LLINK,LNEXTPNTLEN,LNEXTPNTVAL,LNEXTPNTOFF)=0
 }
 Write !,"Updating left data block, ",leftdata,", with new Next Pointer Reference: "
 If LNEXTPNTLEN zzdump LNEXTPNTREF("internal") 
 Set LLINK=rightdata
 Set rc=$$WriteRepairBlock^DMREPAIR(.newleftdatablock,dir,leftdata,LTYPE,LLINK,LN,.LREPAIR,.LREPVAL,.LREPCCC,.LREPLEN,.LREPPAD,.LREPSUB,.LREPBIG,.LREPINFO,LPNTLEN,LNEXTPNTLEN,LNEXTPNTVAL,LNEXTPNTOFF,LBLINCVER,LCOLLATE,LNEXTPNTREF("internal"),LGARTREE)
 If ('rc) {d ShowMessage(rc,0) Do gupdateErrorMsg Quit  }
 Set rc=$$ParseRepairBlock^DMREPAIR(dir,,newleftdatablock,.LOFF,.LREPAIR,.LREPPRINT,.LREPVAL,.LREPCCC,.LREPLEN,.LREPPAD,.LREPSUB,.LREPBIG,.LREPINFO,.LN,.LTYPE,.LLINK,.LBIGCOUNT,.LPNTLEN,.LNEXTPNTLEN,.LNEXTPNTVAL,.LNEXTPNTOFF,.LPNTREF,.LNEXTPNTREF,.LBLINCVER,.LCOLLATE,.LGARTREE)
 If ('rc) {d ShowMessage(rc,0) Do gupdateErrorMsg Quit  }
 Set modtab(leftdata)=newleftdatablock Kill newleftdatablock
 If right {
    Write !,"Updating right data block, ",rightdata,", with new pntlen ",LNEXTPNTLEN
    Open 63:"^^"_dir
    View rightdata
    If $Data(modtab(rightdata)) View 0:0:-%BLKSIZ:modtab(rightdata) 
    View $Zutil(40,32,3):0:2:LNEXTPNTLEN
    Set modtab(rightdata)=$View(0,0,-%BLKSIZ)
    Set rc=$$GetPrintableRef^DMREPAIR(.LNEXTPNTREF,$Zutil(70,1,$View($Zutil(40,32,2),0,1))) ;colrule for right data block
    Do:('rc) ShowMessage(rc,0)
    Do modifyHigherLevels(dir,rightdata,.LNEXTPNTREF)
 }
}
gupdateBigStringPtr(dir,blk,upblock) [modtab] PUBLIC
{
 Set $Zerror="" Set $Ztrap="errgupdateBigStringPtr"
 If $Data(modtab(upblock)) Set rc=$$ParseRepairBlock^DMREPAIR(dir,,modtab(upblock),.UOFF,.UREPAIR,.UREPPRINT,.UREPVAL,.UREPCCC,.UREPLEN,.UREPPAD,.UREPSUB,.UREPBIG,.UREPINFO,.UN,.UTYPE,.ULINK,.UBIGCOUNT,.UPNTLEN,.UNEXTPNTLEN,.UNEXTPNTVAL,.UNEXTPNTOFF,.UPNTREF,.UNEXTPNTREF,.UBLINCVER,.UCOLLATE,.UGARTREE)
 Else   Set rc=$$ParseRepairBlock^DMREPAIR(dir,upblock,,.UOFF,.UREPAIR,.UREPPRINT,.UREPVAL,.UREPCCC,.UREPLEN,.UREPPAD,.UREPSUB,.UREPBIG,.UREPINFO,.UN,.UTYPE,.ULINK,.UBIGCOUNT,.UPNTLEN,.UNEXTPNTLEN,.UNEXTPNTVAL,.UNEXTPNTOFF,.UPNTREF,.UNEXTPNTREF,.UBLINCVER,.UCOLLATE,.UGARTREE)
 If ('rc) {d ShowMessage(rc,0) Do gupdateErrorMsg Quit  }
 Open 63:"^^"_dir View upblock
 If $Data(modtab(upblock)) View 0:0:-%BLKSIZ:modtab(upblock)
 For node=1:1:UN If $View(node*2,-5)=blk Set found=1 Quit
 If 'found || (UREPVAL(node)'=("1,"_blk)) {
    Write !,"Cannot find node in pointer block"
    Do gupdateErrorMsg Quit
 }
 Write !,"Changing node ",node," in pointer block ",upblock," to indicate no long strings in block ",blk
 Set rc=$$ChangeValueInRepairBlock^DMREPAIR(dir,upblock,node,"0,"_blk,.UREPAIR,.UREPVAL,.UREPCC,.UREPLEN,.UREPPAD,.UREPSUB,.UREPBIG,.UREPINFO,.UOFF)
 If ('rc) {d ShowMessage(rc,0) Do gupdateErrorMsg Quit  }
  Set rc=$$WriteRepairBlock^DMREPAIR(.newmodblk,dir,upblock,UTYPE,ULINK,UN,.UREPAIR,.UREPVAL,.UREPCCC,.UREPLEN,.UREPPAD,.UREPSUB,.UREPBIG,.UREPINFO,,,,,,,.UGARTREE)
 If ('rc) {d ShowMessage(rc,0) Do gupdateErrorMsg Quit  }
 Set rc=$$ParseRepairBlock^DMREPAIR(dir,,newmodblk,.UOFF,.UREPAIR,.UREPPRINT,.UREPVAL,.UREPCCC,.UREPLEN,.UREPPAD,.UREPSUB,.UREPBIG,.UREPINFO,.UN,.UTYPE,.ULINK,.UBIGCOUNT,.UPNTLEN,.UNEXTPNTLEN,.UNEXTPNTVAL,.UNEXTPNTOFF,.UPNTREF,.UNEXTPNTREF,.UBLINCVER,.UCOLLATE,.UGARTREE)
 If ('rc) {d ShowMessage(rc,0) Do gupdateErrorMsg Quit  }
 Set modtab(upblock)=newmodblk Kill newmodblk
 Quit   
errgupdateBigStringPtr Do gupdateErrorMsg
}
gupdateErrorMsg
 If $Zerror'="" Write !,$Zerror
 Write !,"This REPAIR operation requires further updating of the database"
 Write !,"in order to maintain its integrity, but this error makes that"
 Write !,"impossible to do automatically.  If you save this block to disk"
 Write !,"you probably will have degradation."
 Quit
MultiVolumeDisplay(dir,blksize,volblk) {
 Try {
	Set dump=($$YN("Include block dumps for volume information blocks","N")="Y")
	Set rs=##class(%Library.ResultSet).%New("SYS.Database:VolumeFiles")
	Set sc=rs.%Execute(dir,0)
	If ('sc) { 
		Write !,"Error getting list of volumes: "
		Do $system.Status.DisplayError(sc)
		Quit
	}
	Open 63
	While rs.%Next() {
		If $i(count)>1 && dump {
			Read !!,"--more--",ans w ! If $zcvt(ans,"U")="Q" Quit
		}
		If $Extract(rs.File)="*" {
			Set file=rs.VolumeDirectory_$Piece(rs.File,"*",3,*)
			Set flag=$Piece(rs.File,"*",1,2)
		} Else {
			Set file=rs.VolumeDirectory_rs.File
			Set flag=""
		}
		Write !!,"Volume #",rs.VolumeNumber,": ",flag," ",file," [",rs.Size," MB]"
		Write !,"------"
		Set block=""
		Open file:"UR":0
		Else  Write !,"  *** failed to open" Continue
		Try {
			Use file:$Select(rs.VolumeNumber:0,1:volblk-1*blksize)
			Read block#blksize:1
		} Catch {}
		Close file
		If block="" { Write !,"  *** failed to open" Continue }
		View 0:0:-1024:block
		Continue:$v($Zutil(40,32,1),0,1)'=18
		Do DisplayVolumeInfoBlock()
		If dump {
			Write !
			zzdump block
		}
	}
	Close 63
 } Catch {
	Close 63
	Write !,$ze
 }
 Write !!,"--end--",!
}
DisplayVolumeInfoBlock() {
	Write !,"Info Block for Volume:   ",$view(36,0,4)
	Write !,"First Block of Volume:   ",$view(56,0,8)
	Write !,"Next Volume First Block: ",$view(64,0,8)
	Write !,"Database Creation ID:    ",$view(48,0,4)," ",$view(52,0,4)
	Write !,"Checkpoint (Nonce):      ",$view(40,0,4)
	Write !,"Prev Checkpoint (Nonce): ",$view(44,0,4)
}
DC(c,n) Q $TR($J("",n)," ",$E(c_" "))
YN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YN"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"yn","YN") I "^YN"'[R W "  enter Yes or No, please"
 S POP=(R="^") W $E($S(R="N":"No",R="Y":"Yes",1:""),$L(X)+1,3) Q R
ShowMessage(sc,device) [] PRIVATE {
    Do DecomposeStatus^%SYS.DATABASE(sc,.msglist,0,"")
    Do wrtmsg($C(13,10),device)
    For i=1:1:msglist {	Do wrtmsg(msglist(i)_$C(13,10),device) }
}
wrtmsg(msg,device) [] PRIVATE {
    Quit:'$L(msg)  ; Avoid argumentless writes...
    If device=-1 { Do $zu(9,"",msg,0,0) Quit }
    If $g(%UI,"CHUI")="CHUI" { Use device Write msg Quit }
    Do:$$IjcMsg^%Wprima("DI"_msg)="CANCEL"  ; Return value could be cancel message 
    . i $$IjcMsg^%Wprima("DI"_$C(13,10)_"Abort received!"_$C(13,10))
    . zt "Abort"
}
ASKSET(prompt,val,backup,help,pattern) ;procedure
 N x,done,def,enahelp,helpavail,backupavail
 s done=0
 s def=$G(val)
 s backup=$G(backup,0) 
 s enabackup=$S(backup=-1:0,1:1)
 s backupavail=$S(backup=1:1,1:0)
 s help=$G(help)
 s enahelp=$S(help="*":0,1:1) ;there might not be any help though
 s helpavail=$s(enahelp&($L(help)!($D(help)>1)):1,1:0)
 if 'enabackup n POP
 s POP=0
 f  d  q:done!POP
 . W !,$G(prompt)
 . w:($X+$L(def))>65 !,?5
 . w:$L(def) " <",def,">"
 . if helpavail!backupavail do
 . . w " [" w:helpavail "?" w:backupavail "^" w "]"
 . w:(($X+$L(def))>75) !,?5
 . W " => " 
 . R x,!
 . if x="^" d  q
 . . if 'enabackup s done=1 q
 . . if backupavail s POP=1 q
 . . w "...backup not available here"
 . if enabackup,x="""^""" s x="^",done=1 q
 . ;
 . if x="?" d  q
 . . if 'enahelp s done=1 q
 . . if 'helpavail w "...help not available here" q
 . . if $D(help)=1 w !?5,help q
 . . s x="" f  s x=$O(help(x)) q:x=""  w !,?5,help(x)
 . . w !
 . if enahelp,x="""?""" s x="?",done=1 q
 . i x]"",$g(pattern)]"",x'?@pattern w !?5,$s(helpavail:help,1:"[bad format]") q
 . s:'$L(x) x=val 
 . s done=1
 s:'POP val=x
 q

RESJOB^INT^1^67214,47331
RESJOB ;(KSO,PK) Kill a job by VMS PID
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
BEGIN ;
 New  
 i '$SYSTEM.Security.Check("%Admin_Manage","USE") w !,"Operation requires %Admin_Manage:Use privilege" q
 W !,"Force a process to quit "_"InterSystems IRIS"
ASK R !!,"Process ID (? for status report): ",JOB i JOB="" w ! q
 I JOB="?" w ! D ALL^%SS g ASK
 Set obj=##CLASS(SYS.Process).%OpenId(JOB)
 If 'obj W *7," [no such "_"InterSystems IRIS"_" process]" G ASK
 If obj.Pid=$J W *7,!,"This is your current process, not proceeding with kill." G ASK
 If 'obj.CanBeTerminated W *7,!,"Can NOT kill the "_obj.Location_" process. "
 Set Result=obj.Terminate()
 If Result=1 Goto ASK
 Else  w "Job NOT Terminated" Goto ASK
 ;EXTRINSIC FUNCTION. GIVEN JOB=PROCESS ID#. QUITS 1 IF TERMINATES, ELSE QUITS 0.
INT(JOB,SndErr) [] PUBLIC {
 Set obj=##CLASS(SYS.Process).%OpenId(JOB)
 If 'obj Quit 0 ;QUIT 0 IF CANNOT FIND THAT PROCESS
 Set Result=obj.Terminate($g(SndErr,0))
 If Result=1 Quit 1
 Else  Quit 0   
}

SETQUOTA^INT^1^67214,47331
SETQUOTA ; Set quotas for jobbed processes
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ;
 ; Modifies the GJOBQUOTA and PJOBQUOTA table for process quotas.
 ; Modifications to the GJOBQUOTA table are done based on the values
 ; in ^SYS("QUOTAS","SYSTEM",quota). Modifications to the PJOBQUOTA
 ; table are done only to the process executing STU depending on
 ; which set of processes we are interested in. These values are
 ; obtained either from ^SYS("QUOTAS","NETDAEMON",quota) for the
 ; network daemons and ^SYS("QUOTAS","STUJOB",quota) for job servers
 ; and jobbed processes started during execution of STU.
 ; 
 ; Note to maintenance programmers: Whenever we change the default
 ; value (hard-coded) of any of the quotas for a jobbed process, the
 ; same change has to be made in this routine. Also note that any
 ; additions/changes in quotas should be made here too. The list of
 ; quotas and their default values are set at tags NAMLIST and DEFLIST
 ; respectively.
 ;
 u 0 w !,"Illegal entry point: do not call ^",$ZN," directly."
 q:$zu(41)'>2  ZTRAP "EP"
 ;
APPLY(QTYPE) Public {
}
RESTORE() Public {
}
DEFAULT(QTYPE) Public {
}
DISPLAY(QTYPE) Public {
}
SETUP(QUOTAVAL,QUOTANAM,QUOTADEF) Private {
}
INIT() Public {
}

SNMPENS^INT^1^67214,47331
SNMPENS    ; SNMP AgentX code for Ensemble
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ;  
 ;
 /* MONEXT.INC */
init	; initialize local variables and arrays for Ensemble
 s $zt="initerr^SNMPENS"
 s EnsembleInstalled=$o(^%SYS("Ensemble","InstalledNamespace",""))]""
 q:'EnsembleInstalled
 ;
 s ensembleOID="1.3.6.1.4.1"_".16563.2.1"
 ; Create a reference array of all the tables in the Ensemble MIB
 ; The "COL" nodes indicate how many columns in the table (and the first 
 ; accessible column). NOTE: Some tables have numeric indexes which must be 
 ; marked 'not-accessible' (RFC 2578) and should not be returned for Get or 
 ; GetNext. For now, all these are just the first column in the table, so all
 ; we need to know is which ones to skip.
 ; The "INDEX" nodes indicate a table with secondary index
 s ENSMIB(1,"COL")="4,2"
 s ENSMIB(1,"INDEX")=0
 s ENSMIB(2,"COL")="6,2"
 s ENSMIB(2,"INDEX")=1
 s ENSMIB(3,"COL")="11,3"
 s ENSMIB(3,"INDEX")=1
 ;
 ; create integer indexes for Productions and Namespaces
 s nspace="",INDEX("EnsProd")=0,nsi=0
 f {
	 s nspace=$o(^%SYS("Ensemble","InstalledNamespace",nspace))
	 q:nspace=""
	 try {
		 zn nspace
	 } 
	 catch {
		 d $zu(9,"","Unable to intialize Interoperability SNMP tables for namespace "_nspace,(1>0),1)
		 continue
	 }
	 s nsi=nsi+1,INDEX("EnsNspace", nsi)=nspace
	 s rs=##class(%Library.ResultSet).%New("Ens.Config.Production:Extent")
	 d rs.Execute() s cont=1
	 while (rs.Next()) {
		 s pi=INDEX("EnsProd")+1
		 s INDEX("EnsProd",pi)=rs.Data("ID")_";"_nspace,INDEX("EnsProd")=pi
	 }
	 zn "%SYS"
 }
 s INDEX("EnsNspace")=nsi
 ;
 q
initerr	; trap any errors in Ensemble initialization so it doesn't
 		; interfere with ^SNMP startup.
 s $zt=""
 zn "%SYS"
 d $zu(9,"","Unexpected error initalizing Interoperability SNMP table - "_$ze,(1>0),1)
 q
 ; 
register()	; register Ensemble for SNMP (non-Windows)
 ;
 ; Check if Ensemble installed
 i $o(^%SYS("Ensemble","InstalledNamespace",""))="" q 1
 ;
 ; register Ensemble MIB
 s ok=1
 i $o(^%SYS("Ensemble","InstalledNamespace",""))]"" {
     f tbl=1:1:3 {
	     s oid=ensembleOID_"."_tbl_".1."_$p(ENSMIB(tbl,"COL"),",",2)_"."_irisCfg
	     s ok=$$register^SNMP(oid,12,+ENSMIB(tbl,"COL"),'ENSMIB(tbl,"INDEX"))
	     q:'ok
     }
 }
 q ok
 ;
next(oid) ; get next OID in Ensemble MIB tree
 ;
 ; oid = Object ID for start of search
 ; return = next Ensemble OID (or "" if end of MIB)
 ;
 i 'EnsembleInstalled q "" 
 s tab=$p(oid,".",10),row=$p(oid,".",11),col=$p(oid,".",12)
 i dbg>1 d log^SNMP("Search Ensemble next - tab="_tab_", row="_row_", col="_col)
 s index=1 s:tab=0 tab=1 ; RFD170
 s:tab=3 index=$$nxtevt(0,0)
 ; Handle secondary indexes. If OID is specified up to (and possibly including)
 ; the 2nd index, then next node is same item with next index.
 i tab]"",ENSMIB(tab,"INDEX"),$l(oid,".")'<(12+$l(irisCfg,".")) { ; RFD093
	 s index=$p(oid,".",MIBindex2,$l(oid,".")) s:index="" index=0
	 i dbg>1 d log^SNMP("Search next for Ensemble - index = "_index_".")
	 i tab=2 s index=$s(index<INDEX("EnsProd"):index+1,1:0)
	 ; Event Log has 2 secondary indexes (namespace and eventID)
	 i tab=3 s index=$$nxtevt(+$p(index,"."),+$p(index,".",2))
	 ; check for a 'not-accessible' item, signal a move to next item
	 i col<$p(ENSMIB(1,"COL"),",",2) s index=0
	 if index = 0 {
		 ; index of '0' here means we've reached the end of
		 ; the 2nd index, fall through and try to get next item
		 s index=1 s:tab=3 index=$$nxtevt(0,0)
	 } else {
		 ; otherwise, return this item with next 2nd index
		 s next=$p(oid,".",1,12) g nextex
	 }
 }
 ; Check system instance index. If none specified, then the next
 ; node is just this one with an index added
 i $l(oid,".")=12 {
	 i ENSMIB(tab,"INDEX") s index=1 s:tab=3 index=$$nxtevt(0,0)
	 s next=oid
	 g nextex
 }
 ; set slen to indicate presence of tab/row/col
 s slen=$s(col]"":3,row]"":2,tab]"":1,1:0) 
 i dbg>1 d log^SNMP("Find next entry in Ensemble MIB, slen = "_slen)
 ; Top of MIB
 if slen=0 {
	 s next="1.1."_$p(ENSMIB(1,"COL"),",",2)
 ; table level
 } elseif slen=1 {
	 if tab'>3 {
		 s next=tab_".1."_$p(ENSMIB(tab,"COL"),",",2)
	 } else {
		 s next=""
	 }
 ; row level
 } elseif slen=2 {
	 ; validate tab and row
	 if (tab>3)!(row>1) {
		 s next=""
	 ; step to first column
	 } else {
		 s next=tab_".1."_$p(ENSMIB(tab,"COL"),",",2)
	 }
 ; column level
 } elseif slen=3 {
	 ; validate tab and row
	 if (tab>3)!(row>1) {
		 s next=""
	 ; step to next column
	 } elseif (col < +ENSMIB(tab,"COL")) {
		 s next=tab_".1."_(col+1)
	 ; step into next table
	 } else {
		 ;last table
		 if tab=3 {
			 s next=""
		 ; next table
		 } else {
			 s next=(tab+1)_".1."_$p(ENSMIB(tab+1,"COL"),",",2)
		 }
	 }
 }
 i next]"" s next=ensembleOID_"."_next ; add Cache prefix
nextex ; Add system instance index (and maybe index for DB or ResSz) at end
 i next]"" {
	 s next=next_"."_irisCfg
	 i ENSMIB($p(next,".",10),"INDEX") s next=next_"."_index
 }
 ;	 
 q next
 ;
 ;
fetch(oid) ; get the data and type for an OID
 ;
 ; oid = Object ID to fetch data for 
 ; return = $LIST of (data_type, data)
 ;
 i 'EnsembleInstalled q $lb(128, 0) 
 s tab=$p(oid,".",10),row=$p(oid,".",11),col=$p(oid,".",12)
 i dbg>1 d log^SNMP("Fetch Ensemble table="_tab_", row="_row_", column="_col)
 ; Fully qualified OID, including system instance index, is required here
 i $l(oid,".")<(12+$l(irisCfg,".")) q $lb(128, 0) ; RFD093
 ; 
 i tab=1 {
	 ; 1. ensSysIndex - Index for this Ensemble Cache instance | STRING |
	 ; 2. ensSysName - Name of this Ensemble Cache instance | STRING |
	 ; 3. ensSysDir - Installation directory for this Ensemble Cache instance | STRING
	 ; 4. ensSysVersion - Version string for this Ensemble Cache instance | STRING |
	 ; 
     i col=1 q $lb(128, 0)
	 i col=2 q $lb(4, $p($zu(86),"*",2))
     i col=3 q $lb(4, $zu(12))
     i col=4 q $lb(4, $zv)
	 q $lb(128, 0)
 }
 i tab=2 {
	 ; 1. ensProdIndex - An index to the table of Productions for this system | INTEGER
	 ; 2. ensProdName - The name of the Ensemble Production | STRING
	 ; 3. ensProdNamespace - The Cache Namespace for this Production | STRING
	 ; 4. ensProdStatus - The current status of the Production | STRING
	 ; 5. ensProdStart - The date-time this Production was last started | STRING
	 ; 6. ensProdStop - The date-time this Production was last stopped | STRING
	 n pindex,prod,nspace,data,state,currProd
     i col=1 q $lb(128, 0)
     ; if no Productions, fill in a dummy
     if INDEX("EnsProd")=0 {
	     i col=2 q $lb(4,"NONE")
	     i col<7 q $lb(4, "")
	     q $lb(128, 0)
     }
     s pindex=+$p(oid,".",MIBindex2)
     i pindex="" q $lb(128, 0)
     i '$d(INDEX("EnsProd",pindex)) q $lb(128, 0)
     s prod=$p(INDEX("EnsProd",pindex),";",1),nspace=$p(INDEX("EnsProd",pindex),";",2)
     i col=2 q $lb(4,prod)
     i col=3 q $lb(4,nspace)
     i '$lf($lb(4,5,6),col) q $lb(128, 0)
     zn nspace
     i col = 4 {
	     s data = "Unknown"
         Try {
             i ''##class(Ens.Director).GetProductionStatus(.currProd,.state) {
                 s state = $s(prod = currProd: state, 1: $s(state < 0: -2, 1: 2))
             }
             else { s state = 0 }
             s data = ##class(Ens.Config.Production).ProductionStateToText(state)
         }
         Catch { s data = "Unknown" }
     }
     i col = 5 s data = ##class(Ens.DataType.UTC).LogicalToOdbc($get(^Ens.Configuration("csp","Activity",prod,"started")))
     i col = 6 s data = ##class(Ens.DataType.UTC).LogicalToOdbc($get(^Ens.Configuration("csp","Activity",prod,"stopped")))
	 zn "%SYS"
	 i $lf($lb(4,5,6),col) q $lb(4, data)
	 q $lb(128, 0)
 }
 i tab=3 {
	 ; 1. ensEvtLogNSIndex - An integer index to the Namespace | INTEGER
	 ; 2. ensEvtLogIndex - An integer index to the entry in this Event Log | INTEGER
	 ; 3. ensEvtLogNamespace - The Cache Namespace for this Event Log | STRING
	 ; 4. ensEvtLogID - The unique identifier for this event log entry | INTEGER
	 ; 5. ensEvtLogTime - The date and time when this entry was logged | STRING
	 ; 6. ensEvtLogType - Type of entry: Alert, Assert, Error, Info, Status, Trace, or Warning | STRING
	 ; 7. ensEvtLogJob - The system job that hosted the event | STRING
	 ; 8. ensEvtLogSession - The unique identifier for the session associated with this message | STRING
	 ; 9. ensEvtLogSource - The configuration item (service, process, or operation) that sent the message | STRING
	 ; 10. ensEvtLogMethod - The host class method that was in progress when the event was logged | STRING
	 ; 11. ensEvtLogText - The text string associated with the event log entry | STRING
	 n nsid,evtid,nspace,data,le,fnd
     i col=1 q $lb(128, 0)
	 i col=2 q $lb(128, 0)
	 s nsid=$p(oid,".",MIBindex2),evtid=$p(oid,".",MIBindex2+1)
	 i nsid=""!(evtid="") q $lb(128, 0)
	 s nspace=INDEX("EnsNspace", nsid)
     i col=3 q $lb(4, nspace)
     i col=4 q $lb(2, evtid)
     zn nspace s fnd=1
     s le=##class(Ens.Util.Log).%OpenId(evtid)
     i le]"" s data=$s(col=5:le.TimeLogged,col=6:le.Type,col=7:le.Job,col=8:le.SessionId,col=9:le.ConfigName,col=10:le.SourceClass_"."_le.SourceMethod,col=11:le.Text,1:"")
     e  s data=""
     k le zn "%SYS"
     i col=5 q $lb(4, $p(data,".",1))
     i col=6 {
	     i data="" q $lb(4,"None")
	     e  q $lb(4, $p("Assert,Error,Warning,Info,Trace,Alert",",",data))
     }
     i col=7 q $lb(4, data)
     i col=8 q $lb(4, data)
     i col=9 q $lb(4, data)
     i col=10 q $lb(4, data)
     i col=11 q $lb(4, $s(data="":"No Event Log entry.",1:data))
	 q $lb(128, 0)
 }
 q $lb(128, 0)
 ;
nxtevt(nsid, evtid) ; get next Event Log entry for system
 ; 
 ; Params: 	nsid - Namespace index to begin search (0=start)
 ;			evtid  - Event Log ID to begin search (0=start)
 ; Return:  string as OID index 'nspace.evtid' or 0 if last one
 ;
 n index,nxtevt,rs,cont,first
 s first=0 s:(nsid=0)&(evtid=0) first=1
 i dbg>1 d log^SNMP("Find next Event Log ID, NSID="_nsid_", EVID="_evtid)
 ; maybe first namespace?
 if nsid=0 s nsid=$o(INDEX("EnsNspace","")),evtid=0
 ; validate namespace index and quit if there's a problem
 if (nsid="")||(nsid>INDEX("EnsNspace")) q 0
 s cont=1,index=0
 ; find next event ID for this namespace, or move to next namespace if none
 while (cont) {
	 s nspace=INDEX("EnsNspace",nsid)
	 zn nspace
	 s rs=##class(%Library.ResultSet).%New("Ens.Util.Log:Extent")
	 do rs.Execute() s nxtevt=0
	 while (rs.Next()) {
		 i rs.Data("ID")>evtid s nxtevt=rs.Data("ID") q
	 }
	 s evtid=nxtevt
	 k rs
	 zn "%SYS"
	 ; check for end and go to next namespace
	 if evtid=0 {
		 s nsid=+$o(INDEX("EnsNspace",nsid))
		 s:nsid=0 cont=0
	 }
	 else {
		 s index=nsid_"."_evtid
		 s cont=0
	 }
 }
 ; return a dummy entry if there aren't any at all
 i first,index=0 s index="1.1"
 i dbg>1 d log^SNMP("Next Event Log index = "_index)
 q index
 ;
systrap(trap, nspace, aux, oid) [dbg,INDEX] PUBLIC {
 ; 
 ; Build OIDs necessary for Ensemble traps
 ; This routine contains most of the "knowledge" about
 ; the traps defined in ISC-ENSEMBLE.MIB
 ; 
 ; trap = the ID number of the trap (last digit of OID)
 ; nspace = the namespace of the Ensemble production which generated the trap
 ; aux = optional comma-delimited list of auxiliary info for traps
 ; oid = (by reference) array of auxiliary OIDs returned (as a list)
 ; 
 ; return = main trap OID (success) or 0 (failure)
 ; 
 i (trap<1)!(trap>1) q 0
 ;
 ; create OID
 s toid="1.3.6.1.4.1"_".16563.2.2."_trap
 ;
 ; set up top oid and cfg name index
 s ensOID="1.3.6.1.4.1"_".16563.2.1."
 s cfg=$p($zu(86),"*",2),len=$l(cfg)
 s cindex=len f i=1:1:len s cindex=cindex_"."_$a(cfg,i)
 ;
 ; all traps send cache system instance name
 s oid=ensOID_"1.1.2."_cindex
 s oid(1)=$lb(oid, 4, $p($zu(86),"*",2))
 ;
 ; build Event trap
 i trap=1 {
	 i $g(aux)="" q 0
	 s evid=+$p(aux,",",1),nsid=""
	 f  s nsid=$o(INDEX("EnsNspace",nsid)) q:nsid=""  q:INDEX("EnsNspace",nsid)=nspace
	 ; switch to namespace to get event info
	 i dbg d log^SNMP("Namspace ID = "_nsid)
     zn nspace
     s le=##class(Ens.Util.Log).%OpenId(evid)
     i le="" zn "%SYS" q 0
	 ; build auxiliary OIDs
	 ; ensEvtLogNamespace, ensEvtLogID, ensEvtLogTime, ensEvtLogType, ensEvtLogText, ensEvtLogSource
 	 s oid=ensOID_"3.1.3."_cindex_"."_nsid_"."_evid
 	 s oid(2)=$lb(oid, 4, nspace)
 	 s oid=ensOID_"3.1.4."_cindex_"."_nsid_"."_evid
 	 s oid(3)=$lb(oid, 4, evid)
 	 s oid=ensOID_"3.1.5."_cindex_"."_nsid_"."_evid
 	 s oid(4)=$lb(oid, 4, le.TimeLogged)
 	 s oid=ensOID_"3.1.6."_cindex_"."_nsid_"."_evid
 	 s oid(5)=$lb(oid, 4, le.Type)
 	 s oid=ensOID_"3.1.11."_cindex_"."_nsid_"."_evid
 	 s oid(6)=$lb(oid, 4, le.Text)
 	 s oid=ensOID_"3.1.9."_cindex_"."_nsid_"."_evid
 	 s oid(6)=$lb(oid, 4, le.ConfigName)
     k le zn "%SYS"
 }
 q toid
}
index	; test indexes
 ; create integer indexes for Productions and Namespaces
 s nspace="",INDEX("EnsProd")=0
 f nsi=0:1 {
	 s nspace=$o(^%SYS("Ensemble","InstalledNamespace",nspace))
	 q:nspace=""
	 s INDEX("EnsNspace", nsi+1)=nspace
	 zn nspace
	 s rs=##class(%Library.ResultSet).%New("Ens.Config.Production:ProductionStatus")
	 d rs.Execute() s cont=1
	 while (rs.Next()) {
		 s pi=INDEX("EnsProd")+1
		 s INDEX("EnsProd",pi)=rs.Data("Production")_";"_nspace,INDEX("EnsProd")=pi
	 }
	 zn "%SYS"
 }
 s INDEX("EnsNspace")=nsi

SNMPTC^INT^1^67214,47331
SNMPTC    ; SNMP AgentX code for TrakCare
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ;  
 ;
 /* MONEXT.INC */
init()	
	//See if TrakCare is installed and set up the TCMIB and TCNS array for local use
	//MIB contents is managed by TrakCare development
 	Try {
		//Find a TrakCare installation
		set tcnspace=""
		set tcnspace=$order(^%SYS("TrakCare","InstalledNamespace",tcnspace))
		if tcnspace'="" {
			//If the configured TrakCare namespace exists
			if ##class(%SYS.Namespace).Exists(tcnspace) {
				//Switch to the first registered TrakCare namespace for initialisation
				set namespace=$zu(5,tcnspace)
				//If websys.Indicators class exists in configured TrakCare namespace
				if ##class(%Dictionary.CompiledClass).%Exists($listbuild("websys.Indicators")) {
					//Call the initialisation method
					set status=##class(websys.Indicators).SNMPInit(tcnspace,.TCMIB,.TCNS)
					//Switch back to %SYS
					set namespace=$zu(5,"%SYS")
				}
				else {
					//Switch back to %SYS
					set namespace=$zu(5,"%SYS")
					//Log error
					do $zu(9,"","SNMP - Invalid TrakCare configuration - websys.Indicators class not in namespace "_tcnspace,(1>0),1)
					set TrakCareInstalled=0
					quit
				}
			}
			else {
				//Log error
				do $zu(9,"","SNMP - Invalid TrakCare configuration - TrakCare installed namespace "_tcnspace_" configured in ^%SYS does not exist",(1>0),1)
				set TrakCareInstalled=0
				quit
			}
		}
		else {
			set TrakCareInstalled=0
			quit
		}
		//If TrakCare is installed return successful initialization else return 0
		if ($data(TCNS(1))=11)&(status) {
			set TrakCareInstalled=1
		}
		else {
			set TrakCareInstalled=0
		}
 	}
	Catch {
		//Switch back to %SYS
		set namespace=$zu(5,"%SYS")					
		//Log any errors
		do $zu(9,"","SNMP - Unexpected error initalizing TrakCare SNMP - "_$ze,(1>0),1)
		set TrakCareInstalled=0
	}
	//Return
	quit TrakCareInstalled
register()	
	//Register TrakCare for SNMP (non-Windows)
	/* This calls back to $$register^SNMP(oid, sub, upper, instance) for each table of the TrakCare MIB
	oid = the exact OID to register
	sub = specify a sub-id position for the range (always $$$MIBcol)
	upper = upper range the specified sub-id (the number of columns in the table)
	instance = a flag (1) if the oid is a fully qualified instance (no secondary indexes)
	Note that Cache uses sub/upper to register a specific instance, or more exactly
	the rows in each table that correspond to a specific instance */
 	//Register Trakcare MIB
	set ok=1
 	Try {
		//See if TrakCare is installed
		if $order(^%SYS("TrakCare","InstalledNamespace",""))="" {
			do $zu(9,"","TrakCare is not installed - ^%SYS(TrakCare,InstalledNamespace) is empty",(1>0),1)
			quit
		}
		//Find a TrakCare installation
		set tcnspace=""
		set tcnspace=$order(^%SYS("TrakCare","InstalledNamespace",tcnspace))
		if tcnspace'="" {
			//Switch to the first registered TrakCare namespace for initialisation
			set namespace=$zu(5,tcnspace)
			//Call the registration method
			set ok=##class(websys.Indicators).SNMPRegister(irisCfg,.TCMIB)
			//Switch back to %SYS
			set namespace=$zu(5,"%SYS")
		}
 	}
 	Catch {
		//Switch back to %SYS
		set namespace=$zu(5,"%SYS")					
		//Log any errors
		do $zu(9,"","Unexpected error registering TrakCare SNMP - "_$ze,(1>0),1) 
	}
	quit ok
next(oid) 
	//Get 'next' OID in TrakCare MIB tree
	//oid = Object ID for start of search
	//return = next TrakCare OID (or "" if end of MIB)
	//Initialize return
	set return=$listbuild(128,0)
	Try {
		//Find a TrakCare installation
		set tcnspace=""
		set tcnspace=$order(^%SYS("TrakCare","InstalledNamespace",tcnspace))
		if tcnspace'="" {
			//Switch to the first registered TrakCare namespace for initialisation
			set namespace=$zu(5,tcnspace)
			//Call the next method
			set return=##class(websys.Indicators).SNMPNext(oid,irisCfg,dbg,.TCMIB,.TCNS)
			//Switch back to %SYS
			set namespace=$zu(5,"%SYS")
		}
	}
 	Catch {
		//Switch back to %SYS
		set namespace=$zu(5,"%SYS")					
		//Log any errors
		do $zu(9,"","Unexpected error relating to next in TrakCare SNMP - "_$ze,(1>0),1) 
	}
	quit return
fetch(oid) 
	//Get the data and type for an OID
	//oid = Object ID to fetch data for 
	//return = $LIST of (data_type, data)
	//Initialize return
	set return=$listbuild(128,0)
	Try {
		//Find a TrakCare installation
		set tcnspace=""
		set tcnspace=$order(^%SYS("TrakCare","InstalledNamespace",tcnspace))
		if tcnspace'="" {
			//Switch to the first registered TrakCare namespace for initialisation
			set namespace=$zu(5,tcnspace)
			//Call the fetch method
			set return=##class(websys.Indicators).SNMPFetch(oid,irisCfg,dbg,.TCNS)
			//Switch back to %SYS
			set namespace=$zu(5,"%SYS")
		}
	}
	Catch {
		//Switch back to %SYS
		set namespace=$zu(5,"%SYS")					
		//Log any errors
		do $zu(9,"","Unexpected error relating to fetch in TrakCare SNMP - "_$ze,(1>0),1) 
	}
	quit return

SS^INT^1^67214,47331
SS ; System Utilities ; System Status Report
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 n
 Do SYS(1,"") Quit  
1 n  Do ALL Quit  
ALL() [] PUBLIC
{
 Do SYS(0,"") 
}
SYS(Page,Dir="",Filter="") [] PUBLIC
{
 s swval=$SYSTEM.Util.GetSwitch(10)
 s SW10=+swval,SWJOB=$S('SW10:"",1:$P(swval,",",2))
 s $zt="errtrap"
 s:$I=$P IOMS=$System.Device.GetRightMargin()
 D:'SW10 CURRENT(.RM)
 S:SW10 RM=80     
 w #
 W !,$$CC("InterSystems IRIS System Status: "_$$ZT($P($H,",",2))_" "_$ZDATE($H,2,,4),RM)
 I SW10 d
 . W !,$$CC("*** Switch 10 Set by Process: "_SWJOB_" ***",RM)
 ;
 s query="SS",parm=1
 i Filter]"" s query=$p(Filter,":"),parm=$p(Filter,":",2)
 ;
 Set Rset=##class(%Library.ResultSet).%New("SYS.Process:"_query)
 Do Rset.Execute(parm)
 Do HEADER(Rset)
 s POP=0
 While Rset.Next() {
	s NameSpace=Rset.Get("Namespace")
	i NameSpace="" s NameSpace="%SYS" 
	i (Dir'=""),(NameSpace'=Dir) continue
	Set Pid=Rset.Get("Process")
	i (Page=1)&(($Y+(Pid=SWJOB))>20) If $$Prompt(Rset) s POP=1 Quit
	Set JobType=Rset.Get("JobType")
	w !,$J(Pid,8)_$Case(JobType,1:"*",:"")
	s pdev=Rset.Get("Device")
	i pdev["TCP" s pdev=$p(pdev,"|",1,3)_$s(pdev["*":"*",1:"")
	w ?10,pdev
	w:$x>22 ! w ?22,Rset.Get("Namespace")
	s Routine=Rset.Get("Routine")
	i ($e(Routine,$l(Routine)-1,$l(Routine))?1"."1N)&('(($e(Routine,1,2)="MV")&($l(Routine,".")=2))) s Routine=$e(Routine,1,$l(Routine)-2)
	w:$x>37 ! w ?37,Routine
	s CPU=Rset.Get("CPU")
	w:$x>(56-$l(CPU)) ! w ?(56-$l(CPU)),CPU_","_Rset.Get("Glob")
	w:$x>63 ! w ?63,Rset.Get("Pr")
	s Username=Rset.Get("User")
	s Location=Rset.Get("Location")
	i Location=Routine s Location=""
	w ?66
	i Username]"" {
		w $S($L(Username)>14:$E(Username,1,14-1)_"*",1:Username)
	} else {
		w $S($L(Location)>14:$E(Location,1,14-1)_"*",1:Location)
	}
	i SW10,Pid=SWJOB W !,"   *** Has Switch 10 Set ***"
	i (JobType=2)||(JobType=27)||(JobType=28)||(JobType=26)||(JobType=23)||(JobType=25)||(JobType=48)||(JobType=47)||(JobType=42)||(JobType=59)||(JobType=60)||(JobType=22)!(JobType=1)||(JobType=3) {
		s NUSR=$Get(NUSR)+1
	} else {
		s NSYS=$Get(NSYS)+1
	}
 }
 U:$D(IOMS)&&(IOMS'=$System.Device.GetRightMargin()) $I:/MAR=IOMS 
 w ! ;
 i POP q 1
 s NGLO=##Class(%SYS.System).GetGlobalCache()
 s NGLO=$FN(NGLO,"",0)
 S NROU=##class(%SYS.System).GetRoutineCache()
 s NROU=$FN(NROU,"",0)
 ;
 W !,+$g(NUSR)_" user, "_+$g(NSYS)_" system, "
 W NGLO_" mb global/"_NROU_" mb routine cache"
 W ! Q 1
errtrap ;
 I $D(IOMS)&&(IOMS'=$System.Device.GetRightMargin()) U $I:/MAR=IOMS
 Q 1
}
HEADER(Rset) {
 W !," "_Rset.GetColumnName(1)
 w ?10,Rset.GetColumnName(3)
 W ?22,Rset.GetColumnName(4)
 w ?37,Rset.GetColumnName(5)
 w ?53,Rset.GetColumnName(6),",",Rset.GetColumnName(7)
 w ?63,Rset.GetColumnName(8)
 w ?66,Rset.GetColumnName(9),"/",Rset.GetColumnName(10)
 Q
}
ZT(t) [] PRIVATE ; return formatted time string given 't' seconds
{
 S h=t\3600,m=$TR($J(t\60#60,2)," ",0),a=" am"
 S:h>11 a=" pm",h=h-12 S:'h h=12 Q ($J(h,2)_":"_m_a) ;hh:mm am
}
CC(str,rm) [] PUBLIC; Center a string within 'rm' margin
{
 Q $J(str,$L(str)+rm\2)
}
 ; Copied from ^%IS
CURRENT(RM) [] PRIVATE ; INTERNAL ENTRY TO SET PARAMETERS FOR CURRENT DEVICE
{
 S MSYS=$Case($zversion(1),1:"M/AV",2:"M/WNT",3:"M/UX",:"UNKNOWN") ;get platform type
 ;
 S E=$G(^%IS($I,1)) D VTRMCK(.E):E=""
 S FF="#",SL=24,BS="*8",RM=80,SUB="",XY="",ZFF=$C(12),ZBS=$C(8,32,8)
 S A=$P(E,"^",3) I A]"",$G(^%IS(0,"SUB",A))]"" DO  
 . S SUB=A,A=^%IS(0,"SUB",SUB),FF=$P(A,"^",2),RM=+A,SL=$P(A,"^",3)
 . S BS=$P(A,"^",4),XY=$P(A,"^",5),ZFF=$P(A,"^",8),ZBS=$P(A,"^",9)
 . I ZFF]"" S ZFF=$$VALUE(ZFF)
 . I ZBS]"" S ZBS=$$VALUE(ZBS)
 I $ZU(22,0,ZFF,ZBS) ;set the new value
 O $I:RM Q 1
}
VALUE(x) N X S $ZT="VALERR^"_$ZN X ("S X="_x) Q X
VALERR Q $G(X)
VTRMCK(E) [] PRIVATE ;Check for virtual terminal, if $I is not in %IS table.
{
 I $Case($zversion(1),1:"M/AV",2:"M/WNT",3:"M/UX",:"UNKNOWN")="M/UX" DO  Q 1 ;unix default terminal type
 . ;no longer limited to /dev/tty or /dev/pt
 . S X="TERM",E=$G(^%IS(X,1)) ;default terminal type
 ; If the tty is not in the %IS table, it's probably a network device.
 ; It should probably just be put in the table, but for now we will
 ; just do what M/VX does, in case anything out there depends on this.
 ;
 S X="TERM" I $zconvert($I,"U")?1"VT".E,$D(^%IS("VT0:")) S X="VT0:"
 E  I $zconvert($I,"U")?1"RTA".E,$D(^%IS("RT0:")) S X="RT0:"
 E  I $zconvert($I,"U")?1"LTA".E,$D(^%IS("LT0:")) S X="LT0:"
 E  I $zconvert($I,"U")?1"|TNT|".E,$D(^%IS("|TNT|")) s X="|TNT|"
 E  I $zconvert($I,"U")?1"|TRM|".E,$D(^%IS("|TRM|")) s X="|TRM|"
 S E=$G(^%IS(X,1)) Q 1  ;default terminal types
}
Prompt(Rset,WID,WIDDirsave,TAB) [] PRIVATE ; ask for prompt when pagination in effect
{
 r !,!,"Press Q or q to quit, any other character to continue. ",ans#1:20
 I "Qq"'[$E(ans_"X") W # d HEADER(Rset) q 0
 q 1
}
 ;
SHUTDOWN() [] PUBLIC
{
 S (NSYS,NJOB,NBKG,NINT,NCSP,NODB,NOTH)=0
 Set Rset=##class(%Library.ResultSet).%New("SYS.Process:SS")
 Do Rset.Execute(1)
 While Rset.Next() {
 Set JobType=Rset.Get("JobType")
 I (JobType=1)||(JobType=3) S NINT=NINT+1
 E  I JobType=2 S NBKG=NBKG+1
 E  I JobType=27 S NCSP=NCSP+1
 E  I JobType=28 S NODB=NODB+1
 E  S NSYS=$Get(NSYS)+1 
 }
 W !,$$CC("InterSystems IRIS Shutdown Status: "_$$ZT($P($H,",",2))_" "_$ZDATE($H,2,,4),80)
 W ! ;
 ;
 s:NINT'=0 NINT=NINT-1
 W !,$j(NINT,8)," interactive job" W:NINT'=1 "s" W " (Telnet/Lat)"
 W !,$j(NBKG,8)," background job" W:NBKG'=1 "s" W " (from job command)"
 W !,$j(NCSP,8)," CSP server job" W:NCSP'=1 "s"
 W !,$j(NODB,8)," ODBC server job" W:NODB'=1 "s"
 W !,$j(NSYS,8)," system job" W:NSYS'=1 "s"
 W ! Q
}
INT() Quit $$INTold()
OLD ;new entry point for old utility
 N PAGES,Dir,ans S PAGES=1,Dir="" 
 D SYSP Q
1old G ALLold ; ALternative to ALL^%SS 
ALLold D SYSold("") Q  ;system status, all directories
THIS D SYSold($namespace) Q  ;system status, THIS directory only
MGR D SYSold("^^"_$ZU(12)) Q  ;system status, manager's namespace only
INTold() N NSYS,NJOB,NUSR,NLIC,NGLO,NROU,IO  ; NGA031+
 i ($zversion(1)=2) S IO="//./nul" O IO U IO
 i ($zversion(1)=3) S IO="/dev/null" O IO U IO
 D SYSold(1) C IO Q NJOB_"^"_NSYS_"^"_NUSR_"^"_NGLO_"^"_NROU_"^"_NLIC
 ; NGA031- 
SYSold(Dir) ;system status for a specific directory (or all if none)
 ;VGG195 parameter accepted now is a namespace
  N PAGES S PAGES=0
SYSP ;entry for pagination
 I Dir=1 S Dir="" N MSYS,BS,FF,RM,SL,SUB,XY,JOB,SORT
 E  N MSYS,BS,FF,RM,SL,SUB,XY,NSYS,NJOB,NUSR,NLIC,NGLO,NROU,JOB,SORT
 N TAB,WID,J,MGR,SW10,SWJOB,pid1,pid2,POP,swval
 s POP=0
 n i,WIDDirsave
 S MGR=$$Dir("^^"_$ZU(12)),Dir=$G(Dir) I Dir]"" S Dir=$$Dir(Dir)
 s swval=$SYSTEM.Util.GetSwitch(10)
 s SW10=+swval,SWJOB=$S('SW10:"",1:$P(swval,",",2))
 D:'SW10 CURRENTold
 S:SW10 RM=80     
 D Init
 ;
 w #
 W !,$$CCold("InterSystems IRIS System Status: "_$$ZTold($P($H,",",2))_" "_$ZDATE($H,2,,4),RM)
 I SW10 d
 . W !,$$CCold("*** Switch 10 Set by Process: "_SWJOB_" ***",RM)
 W ! I Dir]"" W $$CCold("For Namespace: "_Dir,RM),!
 ;
 S (NSYS,NJOB)=0 ;# of SYSTEM jobs and # of jobs                  
 n maxpid
 d BUILDold,HEADold ; build JOB(i,j)=pid
 s pid1="",pid2=""
 f  s pid1=$o(JOB(pid1)) q:pid1=""  d  q:POP=1
 . f  s pid2=$o(JOB(pid1,pid2)) q:pid2=""  d Printold(JOB(pid1,pid2)) q:POP=1
 W ! ;
 s NGLO=0
 f i=0:1:5 s NGLO=NGLO+($v($ZU(40,2,135)+(i*$ZU(40,0,1)),-2,$ZU(40,0,1))*(2**(11+i))/(1024*1024))
 s NGLO=$FN(NGLO,"",0)
 S NROU=$V($ZU(40,2,26),-2,$ZU(40,0,1))*32767/(1024*1024)
 s NROU=$FN(NROU,"",0)
 S NUSR=NJOB-NSYS ;number of user processes
 S NLIC=$$JOBS
 ;
 W !,NUSR_" user, "_NSYS_" system, "
 W NGLO_" mb global/"_NROU_" mb routine cache"
 W ! Q
Init ;initialize some values
 S:'RM!(RM>100) RM=80 K WID
 S WID(1)=7,WID(2)=2,WID(3)=12
 S WID(4)=4,WID(5)=15,WID(6)=10
 S WID(7)=12,WID(8)=3,WID(9)=7
 s WIDDirsave=WID(5)
 Q
Dir(dir) I dir=" " Q "" ;no such directory
 i dir'?1"^^".e q dir  ; it's a defined namespace so leave it unchanged
 n realdir s realdir=$e(dir,3,$l(dir))
 s realdir=$zu(12,realdir)
 q "^^"_realdir
BUILDold ;build JOB()=job information
 n base,i,pid
 s base=$v($zu(40,2,47),-2,"S")
 s maxpid=$v($zu(40,2,118),-2,4)
 f i=1:1:maxpid-1 s pid=$View($View($ZU(40,2,47)+((i\$zu(40,0,102))*$zu(40,0,25)),-2,$zu(40,0,25))+((i#$zu(40,0,102))*$s($ZBITGET($ZVERSION(0),40):$zu(40,28,79)*2,1:4)),-2,4) s:pid JOB(i\1000,i#1000)=pid
 Q
BldJob(J,JOB) ;build the JOB(J) entry for one job
 N Info,X,SYS
 S JOB(J)="" ;always set to SOMETHING
 D JobInfo(J,.Info) ;get job information
 I $G(Info)="" Q  ;no information on job
 ;
 S Info(5)=$$Dir(Info(5)) ;'normalize' directory
 I $G(Dir)]"",Info(5)'=Dir Q  ;not an interesting job
 ;
 I ($ZU(67,10,J)>3),($ZU(67,10,J)'=15) S SYS=1 Set:(Info(5)=("^^"_$Zutil(12))) Info(5)="%SYS"   ;system job
 E  S SYS=0
 ;
 ;
 S Info(11)=SYS
 I SYS,$D(NSYS) S NSYS=NSYS+1 ;count of system jobs
 ;
 I '$G(SW10),Info(10)="",Info("P")]"" DO  ;possible substitute?
 . S Info(10)=$G(^%IS(Info("P"),0)) ;location information
 i $ZU(67,10,J)=21 S Info(10)="RCVDMN"
 ;Use client name for ECP dmns in the info field
 n jtype s jtype=$ZU(67,10,J) i (jtype>=32)&(jtype<=35) s Info(10)=$zu(67,12,J)
 ;
 ;
 I $D(NJOB) S NJOB=NJOB+1 ;count of total jobs
 S JOB(J)=Info F X=1:1:11,"P","D" S JOB(J,X)=Info(X)
 ;
 I $D(WID(5)) DO
 . N X S X=$L(Info(5)) I X>WID(5) S WID(5)=X ;width
 Q
JobInfo(job,Info) ;place job information into Info()
 N L,X,ii,pdev,odev,pm,dev,par,dir,rou,glo,pri,uic,loc K Info
 S L=$$JobVw(job) I L="" Q  ;try twice for each job
 S (pdev,odev)="",dev=$LFS($P(L,"^",3),",",2) F ii=1:1:$LL(dev) DO
 . S X=$LG(dev,ii) 
 . i X["TCP" d
 . . i X["*" s X=$p($e(X,1,$l(X)-1),"|",1,4)_"*"
 . . i X'["*" s X=$p(X,"|",1,4)
 . I pdev="",X?.E1"*" S pdev=$E(X,1,$L(X)-1) Q
 . ;otherwise build a list of 'other' devices, not including null device
 . i "/dev/null,_NLA0:,//./nul"'[X S odev=odev_","_X 
 ;
 S Info=L,Info("P")=pdev,Info("D")=$E(odev,2,$L(odev))
 F ii=1:1:10 S Info(ii)=$P(L,"^",ii)
 s Info(13)=$tr($p(L,"^",14),$c(0),"^")
 s Info(5)=Info(13)
 Q
NOJOB S $ZT="",Info=" " F ii=1:1:10 S Info(ii)=" " ;ghost!
 S Info("D")="",Info("P")="******"
 Q
JobVw(J) S $ZT="JobE1" 
 i SW10,($ZU(67,0,J)'=2) D NOJOB Q "" 
 Q $V(-1,J)
JobE1 S $ZT="JobE2" Q $V(-1,J)
JobE2 S $ZT="" D NOJOB Q ""
HEADold ;print header, first compute tab columns
 N ii
 s WID(5)=WIDDirsave
 K TAB F ii=1:1:10 S TAB(ii)=$G(TAB(ii-1))+$G(WID(ii-1))
 W !,"Process",?TAB(3),"Devices",?TAB(4)," KB"
 W ?TAB(5),"Namespace",?TAB(6),"Routine"
 W ?TAB(7),"  CPU,Glob",?TAB(8),"Pri"
 W ?TAB(10),"Location"
 Q
Printold(job,hasjob) ;print one job's information
 N pm,dev,pdev,odev,par,dir,pro,glo,pri,uic,loc,ii,X,info
 i '$g(hasjob) n JOB D BldJob(job,.JOB) ;build the JOB(J) entry 
 Q:'$D(JOB(job,2))
 S pm=JOB(job,2),pdev=JOB(job,"P"),odev=JOB(job,"D")
 S par=JOB(job,4),dir=JOB(job,5),pro=JOB(job,6)
 S glo=JOB(job,7),pri=JOB(job,8),uic=JOB(job,9)
 S loc=JOB(job,10)
 i pdev["TCP" s pdev=$p(pdev,"|",1,3)_$s(pdev["*":"*",1:"")
 ;
 I $L(pdev)'<WID(3) S odev=pdev_$E(",",odev]"")_odev,pdev="-"
 ;
 i (PAGES=1)&(($Y+$L(odev,",")+(job=SWJOB))>20) d promptold q:POP=1
 W !,$J(job,6)_pm,?TAB(3),pdev_" "
 W ?TAB(4),$J(par,3)
 W ?TAB(5),dir_" "
 I pro]"" W:$X>TAB(6) ! W ?TAB(6),pro_" "
 W ?TAB(7)+5-$L($P(glo,",")),glo_" "
 W ?TAB(8),$J(pri,2)_" "
 W ?TAB(10) S ii=RM-$X W $S($L(loc)>ii:$E(loc,1,ii-1)_"*",1:loc)
 ;
 I odev]"" F ii=1:1:$L(odev,",") S dev=$P(odev,",",ii) I dev]"" DO
 . W !?TAB(3),dev
 I SW10,job=SWJOB W !?TAB(3),"*** Has Switch 10 Set ***"
 Q
ZTold(t) ; return formatted time string given 't' seconds
 N h,m,a S h=t\3600,m=$TR($J(t\60#60,2)," ",0),a=" am"
 S:h>11 a=" pm",h=h-12 S:'h h=12 Q ($J(h,2)_":"_m_a) ;hh:mm am
CCold(str,rm) ; Center a string within 'rm' margin
 Q $J(str,$L(str)+rm\2)
 ; Copied from ^%IS
CURRENTold ; INTERNAL ENTRY TO SET PARAMETERS FOR CURRENT DEVICE
 N (MSYS,FF,SL,BS,RM,SUB,XY)
 S MSYS=$$MSYS() ;get platform type
 ;
SFF N ZFF,ZBS,%A,%E S %E=$G(^%IS($I,1)) D VTRMCKold:%E=""
 S FF="#",SL=24,BS="*8",RM=80,SUB="",XY="",ZFF=$C(12),ZBS=$C(8,32,8)
 S %A=$P(%E,"^",3) I %A]"",$G(^%IS(0,"SUB",%A))]"" DO  ;
 . S SUB=%A,%A=^%IS(0,"SUB",SUB),FF=$P(%A,"^",2),RM=+%A,SL=$P(%A,"^",3)
 . S BS=$P(%A,"^",4),XY=$P(%A,"^",5),ZFF=$P(%A,"^",8),ZBS=$P(%A,"^",9)
 . I ZFF]"" S ZFF=$$VALUEold(ZFF)
 . I ZBS]"" S ZBS=$$VALUEold(ZBS)
 I $ZU(22,0,ZFF,ZBS) ;set the new value
 O $I:RM Q
VALUEold(x) N X S $ZT="VALERRold^"_$ZN X ("S X="_x) Q X
VALERRold Q $G(X)
VTRMCKold ;Check for virtual terminal, if $I is not in %IS table.
 I $$MSYS()="M/UX" DO  Q  ;unix default terminal type
 . ;no longer limited to /dev/tty or /dev/pt
 . S %X="TERM",%E=$G(^%IS(%X,1)) ;default terminal type
 ; If the tty is not in the %IS table, it's probably a network device.
 ; It should probably just be put in the table, but for now we will
 ; just do what M/VX does, in case anything out there depends on this.
 ;
 S %X="TERM" I $zconvert($I,"U")?1"VT".E,$D(^%IS("VT0:")) S %X="VT0:"
 E  I $zconvert($I,"U")?1"RTA".E,$D(^%IS("RT0:")) S %X="RT0:"
 E  I $zconvert($I,"U")?1"LTA".E,$D(^%IS("LT0:")) S %X="LT0:"
 E  I $zconvert($I,"U")?1"|TNT|".E,$D(^%IS("|TNT|")) s %X="|TNT|"
 E  I $zconvert($I,"U")?1"|TRM|".E,$D(^%IS("|TRM|")) s %X="|TRM|"
 S %E=$G(^%IS(%X,1)) Q  ;default terminal types
MSYS() Q $Case($zversion(1),1:"M/AV",2:"M/WNT",3:"M/UX",:"UNKNOWN") ;what platform is this?
JOBS() ;
 q $$nlicenses^%SYS.LICENSE
promptold ; ask for prompt when pagination in effect
 r !,!,"Press Q or q to quit, any other character to continue. ",ans#1:20
 I "Qq"'[$E(ans_"X") W # d HEADold q
 s POP=1
 q
GFLS ; Display Free License Slot info
 N gflsflg S gflsflg=0 g gflscom
gfls() ; Return Free License Slot info
 N gflsflg S gflsflg=1
gflscom w !,"Please use Control Panel for license display"
 q
 ;
SHUTDOWNold N MSYS,NSYS,NBKG,NINT,NCSP,NODB,NJOB,NOTH,pid1,pid2,maxpid,JOB,J
 S (NSYS,NJOB,NBKG,NINT,NCSP,NODB,NOTH)=0
 d BUILDold ; build JOB(i,j)=pid
 s pid1="",pid2=""
 f  s pid1=$o(JOB(pid1)) q:pid1=""  d
 . f  s pid2=$o(JOB(pid1,pid2)) q:pid2=""  d Count(JOB(pid1,pid2))
 w #
 W !,$$CCold("InterSystems IRIS Shutdown Status: "_$$ZTold($P($H,",",2))_" "_$ZDATE($H,2,,4),80)
 W ! ;
 ;
 W !,$j(NINT,8)," interactive job" W:NINT'=1 "s" W " (Telnet/Lat)"
 W !,$j(NBKG,8)," background job" W:NBKG'=1 "s" W " (from job command)"
 W !,$j(NCSP,8)," CSP server job" W:NCSP'=1 "s"
 W !,$j(NODB,8)," ODBC server job" W:NODB'=1 "s"
 W !,$j(NSYS,8)," system job" W:NSYS'=1 "s"
 W ! Q
 ;
Count(pid) N jtype S jtype=$ZU(67,10,pid)
 I (jtype=1)!(jtype=3) Q:pid=$j  S NINT=NINT+1
 E  I jtype=2 S NBKG=NBKG+1
 E  I jtype=27 S NCSP=NCSP+1
 E  I jtype=28 S NODB=NODB+1
 E  I jtype'=15 S NSYS=NSYS+1
 E  S NOTH=NOTH+1
 Q

ST^INT^1^67214,47331
ST ;return pointers to various important locations
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 s %ST=$Case($zversion(1),1:"M/AV",2:"M/WNT",3:"M/UX",:"UNKNOWN")
 s %ST("PV")=$ZU(67,2,$J) ;                $V($zu(40,2,0),-2,"P")
 s %ST("MGDIR")=$ZU(12) ;  $V($zu(40,2,10),-2,-$V($zu(40,2,9),-2,2))
 s %ST("MGRNSP")="%SYS"
 s %ST("UNAME")=$ZU(40,1,19) ;          $zu(40,1,19)
 s %ST("DIR")=($ZU(67,2,$J)+$ZU(40,1,13)) ;              %ST("PV")+$zu(40,1,13)
 s %ST("ALLOC")=($ZU(67,2,$J)+$ZU(40,1,0)) ;          %ST("PV")+$ZU(40,1,0)
 ; BEGIN entries retained for PC 5.1; remove when PC has flat-file jour
 s %ST("JRN")=$ZU(40,2,2) ;              $zu(40,2,2)
 s %ST("JRNNEW")=$ZU(40,2,3) ;        $zu(40,2,3)
 s %ST("JRNPNT")=$ZU(40,2,4) ;        $zu(40,2,4)
 s %ST("JRNLAST")=$ZU(40,2,5) ;      $zu(40,2,5)
 s %ST("JRNUIC")=$ZU(40,2,6) ;        $zu(40,2,6)
 s %ST("JRNIND")=$ZU(40,2,8) ;        $zu(40,2,8)
 ; END entries retained for PC 5.1
 s %ST("JRNTYP")=$ZU(40,2,7) ;        $zu(40,2,7)
 s %ST("REPTYP")=$ZU(40,2,72) ;        $zu(40,2,72) (except on PC 5.1)
 s %ST("LOCKTAB")=$ZU(40,2,16) ;      $zu(40,2,16)
 s %ST("DEV")=$ZU(40,1,17) ;              $zu(40,1,17)
 s %ST("VBUF")=$ZU(40,1,5) ;            $zu(40,1,5)
 s %ST("PRIN")=$ZU(40,1,18) ;            $zu(40,1,18)
 s %ST("ROU")=$ZU(40,1,1) ;              $zu(40,1,1)
 s %ST("SYPNTR")=$ZU(40,2,11) ;        $zu(40,2,11)
 s %ST("BDB0")=$V($ZU(40,2,21),-2,"S") ;            $V($zu(40,2,21),-2,"P")
 s %ST("GID")=$V($ZU(40,2,11)+($ZU(40,0,4)*3),-2,"S") ;              $V(%ST("SYPNTR")+12,-2,"P")
 ;s %ST("UIC")=$$$STUIC ;              $zu(40,1,3)   ;STC347
 s %ST("UICTAB")=$V($ZU(40,2,20),-2,"P") ;        $V($zu(40,2,20),-2,"P")
 s %ST("GPRIBAS")=$ZU(40,2,14) ;      $zu(40,2,14)
 s %ST("GPRILOW")=$ZU(40,2,12) ;      $zu(40,2,12)
 s %ST("GPRICH")=$ZU(40,2,15) ;        $zu(40,2,15)
 s %ST("GPRIHIGH")=$ZU(40,2,13) ;    $zu(40,2,13)
 s %ST("GPROTDEF")=$ZU(40,2,18) ;    $zu(40,2,18)
 s %ST("PRIBAS")=$ZU(40,1,8) ;        $zu(40,1,8)
 ;s %ST("PRICUR")=$$$STPRICUR ;        $zu(40,1,10)  ;STC347
 s %ST("PRIUSR")=$ZU(40,1,9) ;        $zu(40,1,9)
 s %ST("BUFCNT")=$ZU(40,2,17) ;        $zu(40,2,17)
 s %ST("RBUFCNT")=$ZU(40,2,26) ;      $zu(40,2,26)
 s %ST("NUMRBUF")=$ZU(40,2,26) ;      $zu(40,2,26)
 s %ST("OP")=$ZU(40,1,16) ;                $zu(40,1,16)
 s %ST("PAP")=$ZU(40,1,15) ;              $zu(40,1,15)
 s %ST("SSP")=$ZU(40,1,14) ;              $zu(40,1,14)
 s %ST("PLINES")=$ZU(40,1,6) ;        $zu(40,1,6)
 s %ST("POBJECT")=$ZU(40,1,7) ;      $zu(40,1,7)
 s %ST("NHASH")=$V($ZU(40,2,22),-2,"P") ;          $V($zu(40,2,22),-2,"P")
 s %ST("GIND")=$V($ZU(40,2,11)+($ZU(40,0,4)*4),-2,"S") ;            $V(%ST("SYPNTR")+16,-2,"P")
 s %ST("GT")=$V($V($ZU(40,2,11)+($ZU(40,0,4)*4),-2,"S")+2,-3,2)+1*4+$V($ZU(40,2,11)+($ZU(40,0,4)*4),-2,"S")
 s %ST("NETREPA")=$V($ZU(40,2,11)+($ZU(40,0,4)*5),-2,"S") ;      $V(%ST("SYPNTR")+20,-2,"P")
 s %ST("FLAGSA")=($ZU(40,2,33)+$V($ZU(40,2,11)+($ZU(40,0,4)*6),-2,"S")) ; $zu(40,2,33)+$V(%ST("SYPNTR")+24,-2,"P")
 s %ST("PID")=$ZU(40,1,4) ;              $zu(40,1,4)
 s %ST("ROUREF")=$ZU(40,2,1) ;        $zu(40,2,1)
 s %ST("PJOURN")=$ZU(40,1,2) ;        $zu(40,1,2)
 s %ST("ILEN")=$ZU(40,0,1) ;            $zu(40,0,1)
 s %ST("PPLEN")=$ZU(40,0,4) ;           $zu(40,0,2)
 s %ST("CPLEN")=$ZU(40,0,4) ;           $zu(40,0,3)
 s %ST("PLEN")=$ZU(40,0,4) ;            $zu(40,0,4) now DPB101 3/24/93
 s %ST("VERSION")=$ZU(40,2,23) ;      $zu(40,2,23)
 s %ST("GARCUR")=$ZU(40,2,25) ;        $zu(40,2,25)
 s %ST("GARNEXT")=$ZU(40,2,24) ;      $zu(40,2,24)
 s %ST("MTBUFF")=$ZU(40,1,20) ;        $zu(40,1,20)
 s %ST("MTDEV")=$ZU(40,2,28) ;          $zu(40,2,28)
 s %ST("SFLAGS")=$ZU(40,2,38) ;        $zu(40,2,38)
 s %ST("LOGTAB")=$V($ZU(40,2,39),-2,"S") ;        $V($zu(40,2,39),-2,"P")
 s %ST("LOGENTRY")=$ZU(40,0,16) ;    $zu(40,0,16)
 s %ST("TRANSTAB")=$V($ZU(40,2,40),-2,"S") ;    $V($zu(40,2,40),-2,"P")
 s %ST("MTTYPE")=$s(($zversion(1)=3):$ZU(40,17,0),1:0) ;        $zu(40,17,0)
 s %ST("MTINFO")=$s(($zversion(1)=3):$ZU(40,17,1),1:0) ;        $zu(40,17,1)
 s %ST("LINKDIR")=$ZU(40,2,84) ;      $zu(40,17,2)
 s %ST("ALTPID")=$ZU(40,2,47) ;        $zu(40,17,3)
 s %ST("TTYHASH")=$ZU(40,2,48) ;      $zu(40,17,4)
 s %ST("indian")=$ZU(40,0,0) ;        $zu(40,0,0)
 s %ST("ds","sys")=$ZU(40,22,1) ;       $zu(40,22,1)
 s %ST("ds","len")=$ZU(40,22,3) ;       $zu(40,22,3)
 s %ST("ds","nam")=$ZU(40,22,4) ;       $zu(40,22,4)
 Q
GFS ;
 D GFSCON n zu49 s zu49=$zu(49,"") i $p(zu49,",",16) g GFSNEW1
 E  G GFSOLD1
GFSCON ;
 s %ST("GFOFFSET")=$ZU(40,0,5) ;    $zu(40,0,5)
 s %ST("BLTYPE")=$ZU(40,0,6) ;        $zu(40,0,6)
 s %ST("BLOFF")=$ZU(40,0,7) ;          $zu(40,0,7)
 s %ST("MAPLABEL")=$ZU(40,0,8) ;    $zu(40,0,8)
 s %ST("BLLNK")=$ZU(40,0,9) ;          $zu(40,0,9)
 s %ST("BLENGTH")=$ZU(40,0,10) ;      $zu(40,0,10)
 s %ST("GFPRIMVOL")=$ZU(40,8,0) ;  $zu(40,8,0)
 s %ST("GFNEXTVOL")=$ZU(40,8,1) ;  $zu(40,8,1)
 s %ST("GFREAD")=$ZU(40,8,2) ;        $zu(40,8,2)
 s %ST("GFNOMOUNT")=$ZU(40,8,3) ;  $zu(40,8,3)
 s %ST("GFDISMOUNT")=$ZU(40,8,4) ;$zu(40,8,4)
 s %ST("GFREMOUNT")=$ZU(40,8,5) ;  $zu(40,8,5)
 s %ST("GFREPL")=$ZU(40,8,7) ;        $zu(40,8,7)
 s %ST("GFVOL")=$ZU(40,8,8) ;          $zu(40,8,8)
 s %ST("GFSKELETON")=$ZU(40,8,9) ;$zu(40,8,9)
 s %ST("gfformat")=$ZU(40,5,10) ;    $zu(40,5,10)
 s %ST("szformat")=$ZU(40,4,10) ;    $zu(40,4,10)
 Q
GFSOLD D GFSCON
GFSOLD1 ;
 s %ST("gfuic")=$zu(40,7,0)
 s %ST("gfmaps")=$zu(40,7,1)
 s %ST("gfexp")=$zu(40,7,2)
 s %ST("gfmax")=$zu(40,7,3)
 s %ST("gfsat")=$zu(40,7,4)
 s %ST("gfdir")=$zu(40,7,5)
 s %ST("gfgptr")=$zu(40,7,6)
 s %ST("gfrdir")=$zu(40,7,7)
 s %ST("gfrgrw")=$zu(40,7,8)
 s %ST("gfggrw")=$zu(40,7,9)
 s %ST("gfuse")=$zu(40,7,10)
 s %ST("gfmsz")=$zu(40,7,11)
 s %ST("szuic")=$zu(40,6,0)
 s %ST("szmaps")=$zu(40,6,1)
 s %ST("szexp")=$zu(40,6,2)
 s %ST("szmax")=$zu(40,6,3)
 s %ST("szsat")=$zu(40,6,4)
 s %ST("szdir")=$zu(40,6,5)
 s %ST("szgptr")=$zu(40,6,6)
 s %ST("szrdir")=$zu(40,6,7)
 s %ST("szrgrw")=$zu(40,6,8)
 s %ST("szggrw")=$zu(40,6,9)
 s %ST("szuse")=$zu(40,6,10)
 s %ST("szmsz")=$zu(40,6,11)
 Q
GFSNEW D GFSCON
GFSNEW1 ;
 s %ST("gfuic")=$zu(40,5,0)
 s %ST("gfmaps")=$zu(40,5,1)
 s %ST("gfexp")=$zu(40,5,2)
 s %ST("gfmax")=$zu(40,5,3)
 s %ST("gfsat")=$zu(40,5,4)
 s %ST("gfdir")=$zu(40,5,5)
 s %ST("gfgptr")=$zu(40,5,6)
 s %ST("gfrdir")=$zu(40,5,7)
 s %ST("gfrgrw")=$zu(40,5,8)
 s %ST("gfggrw")=$zu(40,5,9)
 s %ST("gfuse")=$zu(40,5,10)
 s %ST("gfmsz")=$zu(40,5,11)
 s %ST("szuic")=$zu(40,4,0)
 s %ST("szmaps")=$zu(40,4,1)
 s %ST("szexp")=$zu(40,4,2)
 s %ST("szmax")=$zu(40,4,3)
 s %ST("szsat")=$zu(40,4,4)
 s %ST("szdir")=$zu(40,4,5)
 s %ST("szgptr")=$zu(40,4,6)
 s %ST("szrdir")=$zu(40,4,7)
 s %ST("szrgrw")=$zu(40,4,8)
 s %ST("szggrw")=$zu(40,4,9)
 s %ST("szuse")=$zu(40,4,10)
 s %ST("szmsz")=$zu(40,4,11)
 s %ST("gfvolseq")=$zu(40,10,0)
 s %ST("gfmaxvol")=$zu(40,10,1)
 s %ST("gfstatus")=$zu(40,10,2)
 s %ST("gfattrib")=$zu(40,10,3)
 s %ST("gfvolmaps")=$zu(40,10,4)
 s %ST("gfnextvol")=$zu(40,10,5)
 s %ST("gfcollation")=$zu(40,10,6)
 s %ST("szvolseq")=$zu(40,9,0)
 s %ST("szmaxvol")=$zu(40,9,1)
 s %ST("szstatus")=$zu(40,9,2)
 s %ST("szattrib")=$zu(40,9,3)
 s %ST("szvolmaps")=$zu(40,9,4)
 s %ST("sznextvol")=$zu(40,9,5)
 s %ST("szcollation")=$zu(40,9,6)
 i $zbitget($zversion(0),21) d  
 . s %ST("gfblksinvol")=$zu(40,10,7)
 . s %ST("szblksinvol")=$zu(40,9,7)
 Q

STRTENQ^INT^1^67214,47331
STRTENQ() ; Start up the enq deamon and the recovery deamon.
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ;
 n gbuf,status,failp  ; KMK122
 n clunet             ; JAO748+
 s clunet=$G(^SYS("CLUSTER","NETTYPE"))
 s clunet=$E(clunet_"D",1)  ; Defaults to ECP
 s clunet=$ZCONVERT(clunet,"U")  ; make sure it's upper case
 s failp=1
 n rootlocks ; ROOTLOCKS must be a power of 2
 s rootlocks=$G(^SYS("CLUSTER","ROOTLOCKS"),0)
 Do $system.ECP.SetProperty("MountsClusterDB",1) 
 Set ^%SYS("SERVICE","ECPCluster")=1 
 if ($G(STU)'="S") {
    Set pijdir=$p($zu(59),",",13)
    if (pijdir="") {
       d $zu(9,"","ENQ daemon not started.. PIJ dir is not specified",(1>0),1) ; GK339
       s status=-101
       Goto failed 
    }
    if ($System.ECP.Debug()\$zh("2000")#2=1) d $ZU(9,"","ecpstrtenq: "_"+++ Chk clu comm DB state="_$g(STU)) ; GK339
    If (($$AnyECPOpenSession^ECPRecovery(pijdir))) {
       d $zu(9,"","ENQ daemon not started.. There are open ECP sessions",(1>0),1) ; GK339
       s status=-100
       Goto failed 
    }
 }
 If ((clunet="D")!(clunet="d")) {
    n prop
    Set prop("Enabled")=1
    Do ##class(Security.Services).Modify("%Service_ECP",.prop)
 }
 i rootlocks="DEFAULT" s rootlocks=0 ; 0 is use system default
 f  s status=$zu(59,1,clunet,rootlocks) q:status'=-11  d  
 . i failp,'+$G(QUIETFLAG) w !,"Failover in progress..." s failp=0
 . h 10                  ; KMK122-
 ;If the enqdeamon started, give the write deamon 20 seconds to
 ;'join' the cluster, otherwise return an error. If the write
 ;deamon joins, go ahead and job off the recovery deamon.
 ;
failed ; GK300
 i status=1 d  q:'status 0
 . i "Mm"[$E($G(^SYS("CLUSTER","STARTRDMN"))_"A") d
 . . w !,"Recovery deamon set to manual startup - Start by hand when ready"
 . e  d
 . . ; zu(66) returns pid of new job or -1 if job command failed
 . . s status=$ZU(66,"REC","RCVRYDMN",30,0,0,$I)
 . . i status=-1 d $zu(9,"","Recovery deamon failed to start.",(1>0),1)
 . s status=0
 . f i=1:1:60 s:$P($zu(59),",",3)'=4294967295 status=1 q:status  h 1
 . d MountCluCommonDB()
 . i 'status,'+$G(QUIETFLAG) d
 . . d $zu(9,"","Write daemon failed to join the cluster.",(1>0),1)
 . . w !,"This may be due to an invalid "_$S(clunet="D":"ECP",1:"DCP")_" configuration"
 . . w !,"Check your "_$S(clunet="D":"ECP",1:"DCP")_" configuration for all nodes in this cluster"
 i +$G(QUIETFLAG) q status  ; KMK074
 i status=1 q 1
 s errmsg="ENQ daemon failed to start because "
 i status=0 s errmsg=errmsg_"of an unknown reason (see SYSLOG)."
 i status=-1 s errmsg=errmsg_"of an unknown reason (see SYSLOG)."
 i status=-2 s errmsg=errmsg_"cluster member limit reached."
 i status=-3 s errmsg=errmsg_"database recovery was not successfully completed."
 i status=-4 s errmsg=errmsg_"the format of the cluster journal file is unrecognizable."
 i status=-5 s errmsg=errmsg_"a read or write operation to the cluster journal file failed."
 i status=-6 s errmsg=errmsg_"the cluster journal file could not be opened or created."
 i status=-7 s errmsg=errmsg_"recovery of this machine's databases may not have been completed successfully."  ; (very unlikely)
 i status=-8 s errmsg=errmsg_"the path to the PIJ file is not defined or defined incorrectly."
 i status=-9 s errmsg=errmsg_"it is already running."
 i status=-10 s errmsg=errmsg_"cluster is crashed."  ; KMK122
 i status=-11 s errmsg=errmsg_"cluster is failing over."
 i status=-12 d
 . n nettype
 . i clunet="E"!(clunet="e") s nettype="ethernet"
 . e  i clunet="U"!(clunet="u") s nettype="udp/ip"
 . e  i clunet="W"!(clunet="w") s nettype="wollengong"
 . e  i clunet="D"!(clunet="d") s nettype="ecp"
 . e  s nettype="unknown network"  ; Should never happen
 . s errmsg=errmsg_"could not locate our "_nettype_" address in the network tables"
 i status=-13 s errmsg=errmsg_"system is in journal recovery mode"
 i status=-14 s errmsg=errmsg_"incorrect # of cluster members in PIJ"
 i status=-15 s errmsg=errmsg_"unsupported network type for cluster network line: "_$G(^SYS("CLUSTER","NETTYPE"))
 i status=-16 s errmsg=errmsg_"network type for cluster network line: "_$G(^SYS("CLUSTER","NETTYPE"))_" differs from what is currently inuse"
 i status=-17 s errmsg=errmsg_"can't locate master's network address in our network tables"
 i status=-18 s errmsg=errmsg_"failed to write the current journal file header"
 i status=-19 s errmsg=errmsg_"failed to get a lock on the CIN resource"
 i status=-20 s errmsg=errmsg_"failed to create a new CIN"
 i status=-21 s errmsg=errmsg_"CIN not found in CCD_LOCK for existing cluster"
 i status=-22 s errmsg=errmsg_"CIN in CCD lock does not match CIN in PIJ"
 i status=-22 s errmsg=errmsg_"CIN in CCD lock does not match CIN in PIJ"
 i status=-22 s errmsg=errmsg_"system does not support clustering, DLM is not loaded"
 i status=-24 s errmsg=errmsg_"logins are disabled because switch 12 is set"
 i status=-25 s errmsg=errmsg_"we failed to resolve an IP address for "_$C(10,13)_"     the local machine"
 i status=-100 s errmsg=errmsg_"cluster has unresolved ECP sessions"
 i status=-101 s errmsg=errmsg_"No PIJ dir specified"
 d $zu(9,"",errmsg,(1>0),1)
 i status=-12 w !,"Please configure network connections."  ; DAS284
 q status
 ;
 ; Create clu manager dir
 ;
MountCluCommonDB() [QUIETLY] public {
    if ('$d(QUIETLY)) { n QUIETLY s QUIETLY=0 }
    Set $zt="mounterr"
    Set retry=5
getdbpath
    Set Directory=$p($zu(59),",",13)
    Set Directory=$zu(12,Directory)
    Set sc=$zu(49,Directory) 
    If (sc<=-2) {
    	if ($System.ECP.Debug()\$zh("2000")#2=1) d $ZU(9,"","ecpstrtenq: "_"Creating cluster common DB in:"_Directory) ; GK339
        Set sc=##class(SYS.Database).CreateDatabase(Directory,,,,$Piece($zu(49,$zu(12)),",",25))
	If ('sc) {
	   Set retry=retry-1
	   if (retry>0) {
		hang 1
		Goto getdbpath
	   }
	   Set sc=$System.Status.GetErrorText(sc)
	   d $zu(9,"","Cluster common DB create failed : "_sc,(1>0),1) ; GK339
	   Goto nodb
	}
	d ##class(SYS.Database).DismountDatabase(Directory)
    }
    if ($p($zu(49,Directory,1),",",3)="X") {
       d $zu(9,"","Warning: Dismounting privately mounted cluster common database: "_Directory,(1>0),1)
       d ##class(SYS.Database).DismountDatabase(Directory)
    }
    if ($System.ECP.Debug()\$zh("2000")#2=1) d $ZU(9,"","ecpstrtenq: "_"+++Mounting cluster common database: "_Directory) ; GK339
    set sc=##class(SYS.Database).MountDatabase(Directory,0,1) ;; dir,<readonly flag>,<cluster flag>
    if ('sc) {
       Set sc=$System.Status.GetErrorText(sc)
       d $zu(9,"","Mounting cluster common database("_Directory_") failed!! err:"_$zu(56,2)_" "_sc,(1>0),1) ; GK339
nodb
       d $zu(9,"","Warning: ECP server connections may fail!!",(1>0),1) ; GK339
    } else {
       if ($System.ECP.Debug()\$zh("2000")#2=1) d $ZU(9,"","ecpstrtenq: "_"ENQ dmn is up: ECP server is enabled!!"_sc) ; GK339
       d $system.ECP.SetProperty("MountsClusterDB",2)
       s clustat=$zu(59)
       if (+$p(clustat,",",3)=1) {
	  Set ^["^^"_Directory]%SYS("CLUInstanceGUID")=$system.Util.CreateGUID()
       s sc=##Class(SYS.Database).ModifyDatabase(Directory,,$Piece($zu(49,$zu(12)),",",25))
       }
    }
    q 1
mounterr ;
    s $ZT="mounterr2"
    d $zu(9,"","mount cluster common DB ("_Directory_") failed from: "_$zu(56,2),(1>0),1) ; GK339
    d $zu(9,"","   Warning: unable to mount "_Directory,(1>0),1) ; GK339
mounterr2 ;
    q 0
 }

SWSET^INT^1^67214,47331
SWSET ;Software switch set.  (FLH, MS)
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 N %SW,%VAL,success
GO R !,"Set/Clear switch #: ",%SW Q:%SW=""
 I %SW?1.2N,%SW<32
 E  W *7,"  [0-31]" G GO
 ;
RVAL R " to value (0 or 1): ",%VAL Q:%VAL=""
 I "10"[%VAL=$L(%VAL) D INT W:success "...done" Q
 W *7,"  [0 OR 1]" G RVAL
INT N %T,JOB10 S %T=0 IF %SW=10 ZA %SWITCH(10) D CHECK10
 D SET:%SW'=10!%T
 S success=%SW'=10!%T ZD %SWITCH(10) Q
CHECK10 
 S %T=$SYSTEM.Util.GetSwitch(10)
 I %VAL {
    ;%VAL=1 returns %T=1 if Sw10 is clear or we own it
    If ('+%T)!(+$P(%T,",",2)=+$J) {Set %T=1} else {Set %T=0}
 } else {
    ;%VAL=0 means %T=1 only if we own Switch 10
    If (+%T)&(+$P(%T,",",2)=+$J) {Set %T=1} else {Set %T=0}
 }
 Q
SET Do $SYSTEM.Util.SetSwitch(%SW,%VAL)
 quit
 Q
 ;Purpose: set/clear switch locally and cluster wide with timeout
 ;Parameters:
 ; sw: switch # (10 or 13 only)
 ; val: 1 to set or 0 to clear
 ; noloc: (optional) 1 if switch is already set locally (default=0)
 ; qma: (optional) 1 if only master to be quiesced
 ;Return: 1 on success or 0 if unable to quiesce or followed by ",$ze"
 ;        always release switch (if it was set here) before returning 0
CLU(sw,val,noloc,qma) ;set/clear switch locally and cluster wide with timeout
 n rc s $zt="CLUet0"
 i $g(sw)-10,$g(sw)-13 ztrap "SWITCH" ;for switch 10 or 12 only
 i '$s($S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0):''$zu(59,0),1:0) ztrap "CLUSTER" ;for cluster systems only
 ;to clear the switch
 i 'val d $zu(95,sw,0) s %SW=sw,%VAL=0 D:'$g(noloc) INT^SWSET q 1
 ;to set the switch
 i +$g(qma) s %SW=sw,%VAL=1 D:'$g(noloc) INT^SWSET d $zu(95,sw,1) s rc=$$CluQuiet(sw,2) d:'rc CLU(sw,0,$g(noloc)) q rc
 ;to suspend a ECP/DCP-based cluster, first suspend slaves only 
 d $zu(95,sw,1,1) s $zt="CLUet1"
 ;setting switch cluster wide doesn't result in setting switch locally, 
 ;thus we have to set local switch if we are not the master.
 i '($p($zu(59,0),",",3)=$zu(40,0,73)),'$g(noloc) s %SW=sw,%VAL=1 d INT^SWSET s $zt="CLUet2"
 ;if fail to quiesce slaves, clear switch and exit with error
 i '$$CluQuiet(sw,1) d $zu(95,sw,0,1) s %SW=sw,%VAL=0 D:'$g(noloc) INT^SWSET q 0
 ;now suspend the master
 i '($p($zu(59,0),",",3)=$zu(40,0,73)) d $zu(95,sw,1)
 e  i '$g(noloc) s %SW=sw,%VAL=1 d INT^SWSET
quietall ;
 s $zt="CLUet3"
 ;quiesce the master (and the cluster, as slaves must be quiet by now)
 i '$$CluQuiet(sw) d CLU(sw,0,$g(noloc)) q 0
 q 1
CLUet3 s $zt=""
 i $$CLU(sw,0,$g(noloc))
 g CLUet0
CLUet2 s $zt=""
 s %SW=sw,%VAL=0 d INT^SWSET
 ; CLUet2 falls through to CLUet1
CLUet1 s $zt=""
 i $zu(95,sw,0,1)
 ; CLUet1 falls through to CLUet0
CLUet0 s $zt=""
 d $zu(9,"","ERROR: "_$ze,(0>0),0)
 q 0_","_$ze
TQUIWRITE(verbose) q $$QUIESCE(1,"buffer activity",10,verbose)
TQUIGC(verbose) q $$QUIESCE(2,"garbage collection",10,verbose)
TQUIDB(verbose) q $$QUIESCE(4,"database expansion",10,verbose)
TQUIGLO(verbose) q $$QUIESCE(8,"global activity",10,verbose)
TQUIGLOUPD(verbose) q $$QUIESCE(16,"global updates",10,verbose)
TQUINET(verbose) q $$QUIESCE(32,"network activity",10,verbose)
TQUIDISK(verbose) q $$QUIESCE(1+2,"disk activity",10,verbose)
TQUIUPD(verbose) q $$QUIESCE(1+2+4+16,"update activity",10,verbose)
TQUISYS(verbose) q $$QUIESCE(1+2+4+8,"system activity",10,verbose)
QUIESCE(bits,text,retries,verbose,intv) ;
 s verbose=+$g(verbose),retries=+$g(retries,-1),intv=+$g(intv,1)
 q ($$Quiesce(bits,text,retries,verbose,intv)>0)
Quiesce(bits,text,retries,verbose,intv) ;
 n noWDbits
 s $zt="QUIESCEE"
 q:$zu(51,bits) 1 ;double checking $ZU(51) is no longer necessary
 s verbose=+$g(verbose),retries=+$g(retries,-1),intv=+$g(intv,1)
 i verbose w $c(13,10)_"WARNING: Switch is set and may affect production for up to "_(retries*intv)_" seconds."_$c(13,10)_"Waiting for "_text_" to finish..."
 f  q:'retries  h intv q:$zu(51,bits)  s retries=retries-1 i retries#5=0 i verbose w "."
 s noWDbits=1
 s:$s($S($ZBITGET($ZVERSION(0),2):$V($ZU(40,2,136),-2,4),1:0):''$zu(59,0),1:0) noWDbits=noWDbits+2
 s noWDbits=$zboolean(bits,noWDbits,2)  ;2 = x & ~ y
 if '$ZU(51,bits),bits'=1,$zboolean(bits,1,1),$zu(51,noWDbits) {
	 i verbose w $c(13,10)_"System is idle except WD is still running."_$c(13,10)_"     Waiting up to 2 minutes for WD to finish"
	 f i=1:1:120 q:$ZU(51,bits)  h 1 if i#5=0 i verbose w "."
	 if $ZU(51,bits) s retries=1 ;signal success
 }
 i verbose w $s(retries:" ready.",1:" abort. "_$$quiescefailmsg(bits))_$c(13,10)
 q retries
quiescefailmsg(bits)
 N ret,clu,clumsg s ret="",clu=$zb(bits,512+256+128,1),clumsg=""
 if $zb(clu,128,1)||($zb(clu,(256+512),1)=(256+512)) s clu=128,clumsg=" (cluster wide)"
 if $zb(clu,512,1) s clumsg=" (cluster master only)"
 if $zb(clu,256,1) s clumsg=" (cluster slaves only)"
 if $zb(bits,1,1)&&('$ZU(51,clu+1)) S ret=ret_"write daemon"_clumsg_","
 if $zb(bits,2,1)&&('$ZU(51,clu+2)) S ret=ret_"garbage collector"_clumsg_"," 
 if $zb(bits,4,1)&&('$ZU(51,clu+4)) S ret=ret_"file expander"_clumsg_","
 if $zb(bits,8,1)&&('$ZU(51,clu+8)) S ret=ret_"global reference"_clumsg_","
 if $zb(bits,16,1)&&('$ZU(51,clu+16)) S ret=ret_"global update"_clumsg_","
 if $zb(bits,32,1)&&('$ZU(51,clu+32)) S ret=ret_"client-side network connections"_clumsg_","
 if $zb(bits,64,1)&&('$ZU(51,clu+64)) S ret=ret_"network server activity"_clumsg_","
 if ret'="" s ret="Quiesce failed reason: "_$e(ret,1,*-1) d $zu(9,"",ret,1,2) i $d(^rOBJ("ZQuiesceFail")) d ^ZQuiesceFail
 Q ret
QUIESCEE s $zt="" d $zu(9,"","QUIESCE: "_$ze,(1>0),1) q -1 ;0
CluQuiet(switch,target,timeout)
 n flags,rc
 i $g(switch)-10,$g(switch)-13 ztrap "SWITCH"
 n targetmsg s target=$g(target)
 i target=1 s target=256,targetmsg=" on cluster slave members"
 e  i target=2 s target=512,targetmsg=" on cluster master"
 e  s target=512+256,targetmsg=" cluster wide"
 s flags=1+2+4+$s(switch=10:8,1:16)
 s rc=$$Quiesce(flags+target,$s(switch=10:"system activity",1:"update activity")_targetmsg,$g(timeout,10),'$g(QUIET,$g(QUIETLY)))
 i rc<0 ztrap "Abort"
 q rc
%swstat(sw,detail) ; Return the status of Switch (sw)...
 s sw=+$g(sw),detail=+$g(detail)
 i sw<0 q $s(detail:-1_$c(1)_"Illegal Switch",1:-1)
 n bit,i,info,job10
 s info=""
 s $zt="%swerr^"_$zn,$ze=""
 Set i=$System.Util.GetSwitch(sw)
 i +i=0 q $s(detail:0_$c(1)_"Switch "_sw_" is NOT set.",1:0)
 i sw=10 s job10=$p(i,",",2),info=" Set by JOB #: "_job10_"  ("_$v(-1,job10)_")"
 q $s(detail:1_$c(1)_"Switch "_sw_" IS set."_info,1:1)
%swerr   ; Some error occured when doing a Switch 10 Status...
 s $zt=""
 q $s(detail:-1_$c(1)_$ze,1:-1)
%swset(sw,val,detail) ; Set Switch (sw) to (val - {0,1})...
 s sw=+$g(sw),val=+$g(val),detail=+$g(detail)
 i sw<0 q $s(detail:-1_$c(1)_"Illegal Switch",1:-1)
 i val'=0,val'=1 q $s(detail:-1_$c(1)_"Illegal Switch Value",1:-1)
 s $zt="%swseter^"_$zn,$ze=""
 If +$System.Util.GetSwitch(sw)=val q 1
 Do $System.Util.SetSwitch(sw,val)  ;Also maintains job # for job 10
 If +$System.Util.GetSwitch(sw)=val q 1
 q 0
%swseter ; Some error occured when Setting Switch (sw) to (val)...
 s $zt=""
 q $s(detail:-1_$c(1)_$ze,1:-1)

SYSLOG^INT^1^67214,47331
SYSLOG ; System Error Log Report
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
ERRLOG ;
 New (IOP)
 New POP,%ST
ERRLOGN ; search/filter entry, allow variables passed in
 d ^ST i '$d(screen) s screen=0
 N IOMS s IOMS=$System.Device.GetRightMargin()
dev ;
 n SELF d OUT^%IS q:POP  s SELF=IO=$I
detail ;
 n detail s detail=($$YN("Show detail","N")="Y")
 i POP g dev
 i screen k errlist d errcnt i POP g detail
 d INT^%D d INT^%T U IO
 W !,"InterSystems IRIS"_" System Error Log printed on ",%DAT," at ",%TIM 
 w !,"--------------------------------------------------------"
 D INT
Done I 'SELF C IO Q
 U IO:/MAR=IOMS
 Q
INT ;
 n e
 n bignum,dispval,%DN,%TN,%TS
 n dispcnt
 i '$d(%ST) D ^ST
 i '$d(screen) n screen s screen=0
 s dispcnt=0 i 'screen d sinit
 i '$d(detail) s detail=0
 s bignum=2147483648 ; Largest positive #
 d ^ST i $D(%ST("LOGENTRY")) g ERRNEW
 ; Use old SYSLOG format
 w !,"Number",?12,"process",?24,"addr",?36,"time"
 f e=%ST("LOGTAB"):16 q:$V(e,-3,4)=0  w ! f o=0:4:12 d
 . s dispval=$V(e+o,-3,4)
 . ; if this is the errno, if its negative, make it so
 . i 'o,dispval'<bignum s dispval=dispval-(bignum*2)
 . i o=12 d
 .. s %DN=47117+dispval\86400,%TN=dispval#86400
 .. d 200^%TO s dispval=$ZDATE(%DN,2,,4)_" "_%TS
 . w ?o*3," ",dispval
 q
SCREEN ; entrypoint for displaying a subset of the SYSLOG
SEARCH ; either one will work
FILTER ; or even this
 new
 s screen=1 
 d sinit
 k IO
 f  d ERRLOGN q:POP  i $$YN("Run again","Y")="N" q
 q
sinit ;
 s (disptotal,screener,screenpid)="all",screendup="no"
 q       
errcnt ;
 n esize,tab,nerr,tabsize,e,lin,mod,errlist,val
 s esize=%ST("LOGENTRY")
 s tab=%ST("LOGTAB"),tabsize=$V(tab,-3,4),nerr=$V(tab+4,-3,4),tab=tab+8
 i nerr<tabsize s cnt=nerr 
 e  s cnt=tabsize
disptotal ; get the total number of errors to display
 s val=$$getval("Maximum log entries to display",disptotal)
 i POP quit
 i val="?" d  g disptotal
  . d dh("Enter the maximum number of error entries to display.")
  . d dh("This will restrict the report to the most recent entries")
  . d dh("and may be further restricted by other parameters.")
  . d dh("Enter ""all"" or ""*"" to not")
  . d dh("restrict the number of entries displayed.")
 s disptotal=val
screener ; get which error to search for
 s val=$$getval("Screen for which error code",screener)
 i POP g disptotal
 i val="?"!(val'="all"&(val'=+val)) d  g screener
  . d dh("Enter the numeric value of the error code to display.")
  . d dh("This will restrict the report to only this error")
  . d dh("and may be further restricted by other parameters.")
  . d dh("Enter ""all"" or ""*"" to not")
  . d dh("screen for a particular error.")
 s screener=val
screenpid ; get which PID to search for
 s val=$$getval("Screen for which pid",screenpid)
 i POP g screener
 i val="?" d  g screenpid
  . d dh("This will restrict the report to only this PID")
  . d dh("and may be further restricted by other parameters.")
  . d dh("Enter ""all"" or ""*"" to not")
  . d dh("screen for a particular PID.")
 i val="all" s pid=""
 s screenpid=val
screendup ; should we suppress duplicate errors of the same error code
 ; this will display only the most recent incidence of the error
 s screendup=$s($$YN("Suppress duplicates",screendup)="Y":"yes",1:"no")
 i POP g screenpid
 q
getval(prompt,default) ;
 n x,y
 w !,prompt,": " w:$d(default) default," => "
 r x
 i x="" s x=default
 f  q:$e(x)'=" "  s x=$e(x,2,999)
 s POP=$e(x)="^" q:POP x
 i $e(x)="?" d  q "?"
  . d dh("Enter ""^"" to go back to the previous question.")
 i x="*" s x="a" w "  a" 
 s x=$zcvt(x,"U"),y=$e(x)="A"
 i x=$e($s(y:"ALL",1:"DISPLAY ALL"),1,$l(x)) d
  . w $e($s(y:"all",1:"display all"),$l(x)+1,99)
  . s x="all"
 q x
dh(d) ; display a line of help text
 w !?5,d
 q
ERRNEW ;
 n esize,tab,nerr,tabsize,e,lin,mod,cnt,i
 s esize=%ST("LOGENTRY")
 s tab=%ST("LOGTAB"),tabsize=$V(tab,-3,4),nerr=$V(tab+4,-3,4),tab=tab+8
 i nerr<tabsize s cnt=nerr 
 e  s cnt=tabsize
 i 'screen w !,"Printing the last ",cnt," entries out of ",nerr," total occurrences."
 i screen d
  . i disptotal="all" w !,"Printing the last ",cnt," entries out of ",nerr," total occurrences."
  . i disptotal'="all" w !,"Displaying a maximum of ",disptotal," errors out of ",nerr," total occurrences."
  . i screener'="all" W !,"Displaying only error code ",screener
  . i screenpid'="all" W !,"Displaying only PID ",screenpid
  . i screendup'="no" w !,"Suppressing duplicates"
 w !,"Err",?6,"Process",?17,"Date/Time"
 i esize>16 w ?37,"Mod",?41,"Line"
 w ?47,"Routine"
 w ?66,"Namespace"
 s done=0 f i=1:1:cnt D ERRLIN q:done
 w ! q
ERRLIN ;
 n errtoolong,charsize
 s nerr=nerr-1,e=tab+((nerr#tabsize)*esize)
 s dispval=$V(e+$zu(40,31,1),-3,4)
 i dispval'<bignum s dispval=dispval-(bignum*2)
 i $l(dispval)>5 s errtoolong=1
 e  s errtoolong=0
 i screener'="all",dispval'=screener q  ; not the error we are looking for
 s pid=$s(($zversion(1)=1):$ZH(+$v(e+$zu(40,31,2),-3,4)),1:$v(e+$zu(40,31,2),-3,4))
 i screenpid'="all",pid'=screenpid q  ; not the pid we are looking for
 i screendup'="no",$d(errlist(dispval)) q  ; already displayed this error
 i disptotal'="all",dispcnt'<disptotal s done=1 q
 s errlist(dispval)="",dispcnt=$i(dispcnt)
 w !,dispval,?6
 i errtoolong w " "
 w $v(e+$zu(40,31,2),-3,4)
 s dispval=$V(e+$zu(40,31,3),-3,$ZU(40,0,55))
 s dispval=$zdth(dispval,-2)
 s %DN=$P(dispval,",",1),%TN=$P(dispval,",",2)
 d 200^%TO s dispval=$zd(%DN)_" "_%TS
 n len,toolong,rouval,nsval,nslen,cast
 s charsize=$$charsize^%Wprim()
 i charsize=2 s cast="w"
 e  s cast=""
 s len=$v(e+$zu(40,31,5),-3,charsize),toolong=18
 i len s rouval=$v(e+$zu(40,31,5)+charsize,-3,$s('detail && (len>toolong):-toolong,1:-len)_cast)
 e  s rouval=""
 i $x>16 w $s('detail:" ",1:$c(13,10))
 w ?17,dispval
 i esize>16 d  
 . s mod=$V(e+$zu(40,31,4),-3,4),lin=mod#65536,mod=mod\65536
 . i $x>36 w $s('detail:" ",1:$c(13,10))
 . w ?37,mod
 . i $x>40 w $s('detail:" ",1:$c(13,10))
 . w ?41,lin
 i $x>46 w $s('detail:" ",1:$c(13,10))
 w ?47,rouval
 s len=$v(e+$zu(40,31,10),-3,charsize),toolong=13
 i len d  
 . s nsval=$v(e+$zu(40,31,10)+charsize,-3,$s('detail && (len>toolong):-toolong,1:-len)_cast)
 . i $e(nsval,1,2)="@@" s nsval="^^"_$e(nsval,3,*)
 e  s nsval=""
 s nslen=$l(nsval)
 i 'detail d  
 . i $x>65 w " "
 . w ?66,nsval
 e  d  
 . i $x>(79-nslen) w !,?(79-nslen),nsval
 . e  d  
 . . i $x>65 w " " 
 . . w ?66,nsval
 i 'detail q  
 w !,?6
 d showitem($zu(40,31,8))
 d showitem($zu(40,31,6))
 d showitem($zu(40,31,7))
 d showitem($zu(40,31,9))
 q
showitem(off) 
 s len=$v(e+off,-3,charsize)
 i len d  
 . s val=$v(e+off+charsize,-3,-len_cast)
 . i off=$zu(40,31,8) w val
 . e  w "/",val
 q
YN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YN"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"yn","YN") I "^YN"'[R W "  enter Yes or No, please"
 S POP=(R="^") W $E($S(R="N":"No",R="Y":"Yes",1:""),$L(X)+1,3) Q R

TASKMGR^INT^1^67214,47331
TASKMGR ; Task manager
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 n
MENU s $zt="MENUE"
 w !
 w !,"1) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"4085034206"),"Create a Task")
 w !,"2) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3532810686"),"Edit a Task")
 w !,"3) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"4246954580"),"List Tasks")
 w !,"4) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2217291786"),"Delete a Task")
 w !,"5) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1777206210"),"Suspend a Task")
 w !,"6) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2315783362"),"Resume a Task")
 w !,"7) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1071803248"),"Run a Task")
 w !,"8) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1275260151"),"Task Reports")
 w !,"9) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1375033480"),"Task Manager Options")
 w !,"10) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"876292912"),"Exit")
 w !
 s Option=$$OPTION($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1071287907"),"Option? "),10,10)
 i Option=1 d TASKINFO(0) g MENU
 i Option=2 d TASKINFO(1) g MENU
 i Option=3 d TASKLIST() g MENU
 i Option=4 d TASKDELETE() g MENU
 i Option=5 d TASKSUSPEND() g MENU
 i Option=6 d TASKRESUME() g MENU
 i Option=7 d TASKRUN() g MENU
 i Option=8 d TASKREPORTS g MENU
 i Option=9 d TASKOPTIONS g MENU
 q
MENUE s $zt=""
 i $ze'["<INTERRUPT>" w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1936651305"),"ERROR: %1"),$ZE)
 q
TASKINFO(Flag) {
TASKINFO1 s $zt="TASKINFOE"
	Set HaveMailServer=##class(%SYS.Task.Config).GetData("MailServer")]""
	If Flag=0 { 
		s Name=$$GETTASK($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1738489176"),"Task name to create? "),0,0) q:Name=$C(0)
		Set Task=##class(%SYS.Task).%New()
		Set Task.Name=Name
		}
	Else {
		s Name=$$GETTASK($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1075487612"),"Task number to edit? "),1,3,.Number) q:Name=$C(0)
		s Task=##class(%SYS.Task).%OpenId(Number,4)
	}
	i 'Task Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1720091924"),"Task not available for edit") Q
UPDATEINFO	D GetTaskInfo(Task) q:POP
	i $$YN($$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3177712267"),"Confirm changes to task %1"),Task.Name),"Y")="N" g TASKINFO1
	s Task.SkipAuditOnReschedule=0
	Set Status=Task.%Save()
	If 'Status { Do $system.OBJ.DisplayError(Status) Goto UPDATEINFO}
	d TASKDETAIL(Task.%Id())
	g TASKINFO1
TASKINFOE s $zt=""
 i $ze'["<INTERRUPT>" w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1936651305"),"ERROR: %1"),$ZE)
 q
GetTaskInfo(Task) s $ZT="GetTaskInfoE"
 s POP=1
Name
 s Name=$$STRINGOPTION($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"4262580536"),"Name"),Task.Name,1) q:Name=$C(0)
 S Task.Name=Name
Description
 s Description=$$STRINGOPTION($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3950563313"),"Description"),Task.Description,1) q:Description=$C(0)
 S Task.Description=Description
NameSpace
 i Task.Type'=0 {
	s NameSpace=$$STRINGOPTION($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2970675701"),"Namespace"),Task.NameSpace,0) q:NameSpace=$C(0)
	s NameSpace=$zcvt(NameSpace,"U")
	d List^%SYS.NAMESPACE(.nslist)
	i $d(nslist(NameSpace)) s POP=0 
	i POP=1 w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3426613596"),"Namespace %1 does not exist, please re-enter"),NameSpace) g NameSpace
 } else {
	 s NameSpace="%SYS"
 }
 S Task.NameSpace=NameSpace
 s POP=1
TaskClass
 s TaskClass=$$STRINGOPTION($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1577554303"),"Task Class"),Task.TaskClass,0) q:TaskClass=$C(0)
	If 'Task.CheckClass(TaskClass,NameSpace) W !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"4121557686"),"Task Class must exist in the namespace") g TaskClass
	Set Task.TaskClass=TaskClass
Settings	
	Set where=$zu(5,Task.NameSpace)
	Set objTaskClass=$classmethod(Task.TaskClass,"%New")
	Do objTaskClass.SetSettings(Task.Settings)
	Set Settings=objTaskClass.GetSettings()
	If $ll(Settings) Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2098513667"),"Settings:")
	For i=1:2:($ll(Settings)) {
		Set name=$li(Settings,i)
		If objTaskClass.GetCollectionType(name)]"" Continue  // exclude collections
		Set displayName=objTaskClass.GetPropertyName(name)
		Set value=$li(Settings,i+1)
		f  {
			Set value=$$STRINGOPTION(displayName,value,1) q:value=$C(0)
			Set status=$method(objTaskClass,name_"IsValid",value)
			Continue:'status
			Set $li(Settings,i,i+1)=$lb(name,value)
			Quit
		}
	}
	Do objTaskClass.SetSettings(Settings)
	Set objTaskClass=""
	Set where=$zu(5,"%SYS")
	Set Task.Settings=Settings
Priority
	Set Priority=$$Priority^TASKMGR1(Task.Priority)
	q:Priority=$C(0)
	s Task.Priority=Priority-1
Mode
 w !
 w !,"1) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"640249298"),"Normal")
 w !,"2) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"969571792"),"Batch")
 w !
 s IsBatch=$$NUMOPTION($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"939059349"),"Mode"),(Task.IsBatch)+1,1,2) 
 q:IsBatch=$C(0)
 s Task.IsBatch=IsBatch-1
MirrorStatus
 i $SYSTEM.Mirror.IsMember() {
	s MirrorStatus=$$MirrorStatus^TASKMGR1(Task.MirrorStatus)
	q:MirrorStatus=$C(0)
	s Task.MirrorStatus=MirrorStatus
 }
TimePeriod
 w !
 w !,"1) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1331463278"),"Daily")
 w !,"2) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1500557074"),"Weekly")
 w !,"3) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"622395140"),"Monthly")
 w !,"4) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3180018154"),"Monthly special")
 w !,"5) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1021483240"),"After another task completes")
 w !,"6) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"421367435"),"On Demand")
 w !
 s TimePeriod=$$NUMOPTION($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2623778972"),"Run task how often"),(Task.TimePeriod)+1,1,6) q:TimePeriod=$C(0)
 s (Task.TimePeriod,TimePeriod)=TimePeriod-1
 if TimePeriod=0 {
 	s TimePeriodEvery=$$NUMOPTION($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2647698820"),"How many days between runs"),Task.TimePeriodEvery,1,7) q:TimePeriodEvery=$C(0)
	S Task.TimePeriodEvery=TimePeriodEvery
	s TimePeriodDay="" 
 } Elseif TimePeriod=1 {
 	s TimePeriodEvery=$$NUMOPTION($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2140213787"),"How many weeks between runs"),Task.TimePeriodEvery,1,5) q:TimePeriodEvery=$C(0)
	S Task.TimePeriodEvery=TimePeriodEvery
 	S TimePeriodDay=Task.TimePeriodDay
 	i TimePeriodDay="" s TimePeriodDay=1
	s TimePeriodDay=$$MULTIDAYOPTION($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2089789809"),"Days to run on"),TimePeriodDay,1,7) q:TimePeriodDay=$C(0)
	s Task.TimePeriodDay=TimePeriodDay
 } ElseIf TimePeriod=2 {
 	s TimePeriodEvery=$$NUMOPTION($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1493390500"),"How many months between runs"),Task.TimePeriodEvery,1,12) q:TimePeriodEvery=$C(0)
 	s TimePeriodDay=Task.TimePeriodDay
 	i TimePeriodDay="" s TimePeriodDay=1
	s TimePeriodDay=$$NUMOPTION($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3232854760"),"Day to run on (1-31, 31=last day of month)"),TimePeriodDay,1,31) q:TimePeriodDay=$C(0)
	s Task.TimePeriodDay=TimePeriodDay
	s Task.TimePeriodEvery=TimePeriodEvery
 } elseIf TimePeriod=3 {
 	s TimePeriodDay=Task.TimePeriodDay
 	s Week=$p(TimePeriodDay,"^")
 	s Day=$p(TimePeriodDay,"^",2)
 	s TimePeriodEvery=$$NUMOPTION($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1493390500"),"How many months between runs"),Task.TimePeriodEvery,1,12) q:TimePeriodEvery=$C(0)
 	s Week=$$NUMOPTION($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"777440763"),"Run which week"),Week,1,5) q:Week=$C(0)
 	w !
 	w !,"1) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3421684983"),"Sunday")
 	w !,"2) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3632146495"),"Monday")
 	w !,"3) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"597723493"),"Tuesday")
 	w !,"4) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"395286495"),"Wednesday")
 	w !,"5) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3078746362"),"Thursday")
 	w !,"6) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3072242550"),"Friday")
 	w !,"7) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3910980832"),"Saturday")
 	w !
	s Day=$$NUMOPTION($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3166688702"),"Day to run on"),Day,1,31) q:Day=$C(0)
	s TimePeriodDay=Week_"^"_Day
	s Task.TimePeriodDay=TimePeriodDay
	s Task.TimePeriodEvery=TimePeriodEvery
 } Elseif TimePeriod=4 {
	Set RunAfter=Task.RunAfterGUID
	Set RunAfterText=##class(%SYS.Task).DisplayGUID(RunAfter)
	S Number=##class(%SYS.Task).GetRunAfterID(RunAfter)
	For  {
		s RunAfter=$$GETTASK($$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"847345884"),"Task number to run after? %1 => "),RunAfterText),1,3,.Number) 
		If RunAfter=$C(0) && (Task.RunAfterGUID]"") Quit
		Set Task.RunAfterGUID=##class(%SYS.Task).GetRunAfterGUID(Number)
		If Task.RunAfterGUID]"" Quit
		Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1291213271"),"Please enter the Task number to run after")
	}
 } Elseif TimePeriod=5 {
	s Task.TimePeriodEvery=""
	s Task.TimePeriodDay=""
	s Task.DailyFrequency=0
	s Task.DailyStartTime=0
	s Task.DailyFrequencyTime=""
	s Task.DailyIncrement=""
	s Task.DailyEndTime=""
	s Task.StartDate=+$h
	s Task.EndDate=""
 }
Frequency
 i TimePeriod'=4,TimePeriod'=5 {
 w ! 
 w !,"1) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3671252920"),"Run once on the day scheduled")
 w !,"2) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"4187384170"),"Run several times on the day scheduled")
 w !
 s DailyFrequency=$$NUMOPTION($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2672717967"),"Frequency to run"),(Task.DailyFrequency)+1,1,2) q:DailyFrequency=$C(0)
 s (Task.DailyFrequency,DailyFrequency)=DailyFrequency-1
 if Task.DailyFrequency=0 {
	s DailyStartTime=$$GETTIME($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3365077156"),"Time to run task"),Task.DailyStartTime) q:DailyStartTime=$C(0)
	s Task.DailyStartTime=DailyStartTime
	s Task.DailyFrequencyTime=""
	s Task.DailyIncrement=""
	s Task.DailyEndTime=""
 }
 if DailyFrequency=1 {
	w !
	w !,"1) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1876325183"),"Minutes")
	w !,"2) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1272681097"),"Hours")
	w !
	S DailyFrequencyTime=Task.DailyFrequencyTime
	i DailyFrequencyTime="" s DailyFrequencyTime=0
	s DailyFrequencyTime=$$NUMOPTION($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3629222304"),"Time Interval"),DailyFrequencyTime+1,1,2) q:DailyFrequencyTime=$C(0)
	s (Task.DailyFrequencyTime,DailyFrequencyTime)=DailyFrequencyTime-1
	s DailyIncrement=Task.DailyIncrement
	i DailyIncrement="" s DailyIncrement=1
	s DailyIncrement=$$NUMOPTION($s(DailyFrequencyTime=0:$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1876325183"),"Minutes"),1:$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1272681097"),"Hours"))_" "_$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3868962252"),"between runs"),DailyIncrement,1,$s(DailyFrequencyTime=0:1440,1:24)) q:DailyIncrement=$C(0)
	s Task.DailyIncrement=DailyIncrement
	s DailyStartTime=$$GETTIME($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3363266933"),"First time to run task"),Task.DailyStartTime) q:DailyStartTime=$C(0)
	s Task.DailyStartTime=DailyStartTime
	s DailyEndTime=$$GETTIME($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3428919371"),"Last time to run task"),Task.DailyEndTime) q:DailyEndTime=$C(0)
	s Task.DailyEndTime=DailyEndTime
 }
Expires
 i $$YN($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"662774590"),"Task Expires"),$s(Task.Expires=0:"N",1:"Y"))="N" {
	 s Task.Expires=0
 } else {
 	s Task.Expires=1
	s ExpiresDays=$$NUMOPTION($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1500773037"),"Expires in how many days"),Task.ExpiresDays,0,999) Quit:ExpiresDays=$C(0)
	s ExpiresHours=$$NUMOPTION($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2250125747"),"Expires in how many hours"),Task.ExpiresHours,0,24) Quit:ExpiresHours=$C(0)
	s ExpiresMinutes=$$NUMOPTION($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"803954697"),"Expires in how many mins"),Task.ExpiresMinutes,0,60) Quit:ExpiresMinutes=$C(0)
	s Task.ExpiresDays=$S(ExpiresDays:ExpiresDays,1:"")
	s Task.ExpiresHours=$S(ExpiresHours:ExpiresHours,1:"")
	s Task.ExpiresMinutes=$S(ExpiresMinutes:ExpiresMinutes,1:"")
 }
 }
OutputFile
 i $$YN($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1048819027"),"Open output file"),$s(Task.OpenOutputFile=0:"N",1:"Y"))="N" {
	 s Task.OpenOutputFile=0
 } else {
 	s Task.OpenOutputFile=1
OutputDirectory
 s Directory=$$STRINGOPTION($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"771586649"),"Output directory"),Task.OutputDirectory,1) q:Directory=$C(0)
 s Task.OutputDirectory=Directory
OutputFilename
 s Filename=$$STRINGOPTION($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3352846325"),"Output file name"),Task.OutputFilename,1) q:Filename=$C(0)
 s Task.OutputFilename=Filename
EmailOutputFile
 	If HaveMailServer {
	 	i $$YN($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2509289500"),"Email output file"),$s(Task.EmailOutput=0:"N",1:"Y"))="N" {
		 	s Task.EmailOutput=0
		 } else {
		 	s Task.EmailOutput=1
			If $$STRINGOPTION($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2676188074"),"Email output as BINARY"),$S(Task.OutputFileIsBinary=0:"N",1:"Y"),1)="Y"
			{
				Set Task.OutputFileIsBinary=1
			} Else {
				Set Task.OutputFileIsBinary=0
			}
		 }
 	}
 }
EmailOnCompletion
	If HaveMailServer {
		Set EmailOnCompletion=""
		For i=1:1:Task.EmailOnCompletion.Count() {
			Set:EmailOnCompletion]"" EmailOnCompletion=EmailOnCompletion_"," 
			Set EmailOnCompletion=EmailOnCompletion_Task.EmailOnCompletion.GetAt(i)
		}
		s EmailOnCompletion=$$STRINGOPTION($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"427050551"),"Email notification on completion to (comma sep addresses)"),EmailOnCompletion,1) q:EmailOnCompletion=$C(0)
		Do Task.EmailOnCompletion.Clear()
		For i=1:1:$l(EmailOnCompletion,",") {
			Set email=$p(EmailOnCompletion,",",i)
			if email]"" Do Task.EmailOnCompletion.Insert(email)
		}
	}
EmailOnError
	If HaveMailServer {
		Set EmailOnError=""
		For i=1:1:Task.EmailOnError.Count() {
			Set:EmailOnError]"" EmailOnError=EmailOnError_"," 
			Set EmailOnError=EmailOnError_Task.EmailOnError.GetAt(i)
		}
		s EmailOnError=$$STRINGOPTION($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"345776757"),"Email notification on error to (comma sep addresses)"),EmailOnError,1) q:EmailOnError=$C(0)
		Do Task.EmailOnError.Clear()
		For i=1:1:$l(EmailOnError,",") {
			Set email=$p(EmailOnError,",",i)
			if email]"" Do Task.EmailOnError.Insert(email)
		}
	}
SuspendOnError
 i $$YN($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"283789264"),"Suspend Task on error"),$s(Task.SuspendOnError=1:"Y",1:"N"))="N" {
	 s Task.SuspendOnError=0
 } else {
 	s Task.SuspendOnError=1
 }  
 i TimePeriod=4!(TimePeriod=5) Set POP=0 Quit 
StartDate
 s StartDate=$$GETDATE($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1167221256"),"Date to first schedule task"),Task.StartDate) q:StartDate=$C(0)
 S Task.StartDate=StartDate
EndDate
 s EndDate=$$GETDATE($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"77761594"),"Date to last schedule task"),Task.EndDate) q:EndDate=$C(0)
 S Task.EndDate=EndDate
RescheduleOnStart
 i $$YN($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1273638526"),"Reschedule task on system restart"),$s(Task.RescheduleOnStart=0:"N",1:"Y"))="N" {
	 s Task.RescheduleOnStart=0
 } else {
 	s Task.RescheduleOnStart=1
 }
 s POP=0
 q
GetTaskInfoE s $zt=""
 i $ze'["<INTERRUPT>" w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1936651305"),"ERROR: %1"),$ZE)
 s POP=1 
 q
}
TASKDELETE() {
TASKDELETE1 s $ZT="TASKDELETEE"
 s Name=$$GETTASK($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"497836297"),"Task name to delete? "),1,0,.Number) q:Name=$C(0)
 i $$YN($$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3456180515"),"Do you want to delete Task %1"),Name),"N")="N" g TASKDELETE1
 Set Status=##class(%SYS.Task).%DeleteId(Number)
 If Status {w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"93934700"),"Task %1 deleted"),Name)}
 Else {Do $system.OBJ.DisplayError(Status)}
 g TASKDELETE1
TASKDELETEE s $zt=""
 i $ze'["<INTERRUPT>" w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1936651305"),"ERROR: %1"),$ZE)
 q
}
TASKSUSPEND() {
TASKSUSPEND1 s $ZT="TASKSUSPENDE"
 s Name=$$GETTASK($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3238546656"),"Task name to suspend? "),1,3,.Number) q:Name=$C(0)
 i $$YN($$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"590465255"),"Do you want to suspend Task %1"),Name),"Y")="N" g TASKSUSPEND1
 i $$YN($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2976988660"),"Reschedule task when task is supposed to run"),"Y")="Y" {
	 s Flag=2
 } else {
	 s Flag=1
 }
	Set ID=##class(%SYS.Task).FindId(Name)
	Set Status=##class(%SYS.Task).Suspend(ID,Flag)
	If Status {w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1255457836"),"Task %1 suspended"),Name)}
	Else { Do $system.OBJ.DisplayError(Status) }
 g TASKSUSPEND1
TASKSUSPENDE s $ZT=""
 i $ze'["<INTERRUPT>" w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1936651305"),"ERROR: %1"),$ZE)
 q
}
TASKRESUME() {
TASKRESUME1 s $ZT="TASKRESUMEE"
 s Name=$$GETTASK($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"403269244"),"Task name to resume? "),1,3,.Number) q:Number=$C(0)
 i $$YN($$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1538280093"),"Do you want to resume Task %1"),Name),"Y")="N" g TASKRESUME1
	Set Status=##class(%SYS.Task).Resume(Number)
	If Status {w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2697540267"),"Task %1 resumed"),Name)}
	Else { Do $system.OBJ.DisplayError(Status)}
 g TASKRESUME1
TASKRESUMEE s $zt=""
 i $ze'["<INTERRUPT>" w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1936651305"),"ERROR: %1"),$ZE)
 q
}
TASKRUN() {
TASKRUN1 s $ZT="TASKRUNE"
 s Name=$$GETTASK($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1802345530"),"Task number to run? "),1,3,.Number) q:Name=$C(0)
 s Date=$$GETDATE($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"702099857"),"Date to run task"),+$h) q:Date=$C(0)
 s Time=$$GETTIME($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3365077156"),"Time to run task"),$p($h,",",2)) q:Time=$C(0)
 i $$YN($$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2775439294"),"Confirm running task %1 at %2"),Name,$zdatetime(Date_","_Time,3,2)),"Y")="N" g TASKRUN1
 d ##class(%SYS.Task).RunOnce(Number,Date,Time)
 w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3891431577"),"Task %1 queued for %2"),Name,$zdatetime(Date_","_Time,3,2))
 g TASKRUN1
TASKRUNE s $zt=""
 i $ze'["<INTERRUPT>" w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1936651305"),"ERROR: %1"),$ZE)
 q
}
TASKOPTIONS s $ZT="TASKOPTIONSE"
 w !
 w !,"1) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"4205045027"),"Task Manager Information")
 w !,"2) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1269661455"),"Start Task Manager")
 w !,"3) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2196412421"),"Suspend Task Manager")
 w !,"4) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1477083081"),"Resume Task Manager")
 w !,"5) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2793067076"),"Task Manager History")
 w !,"6) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"768121462"),"Define Mail Settings")
 w !,"7) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"876292912"),"Exit")
 w !
 s Option=$$OPTION($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1071287907"),"Option? "),7,7)
 i Option=1 d INFO() g TASKOPTIONS
 i Option=2 d START() g TASKOPTIONS
 i Option=3 d SUSPEND() g TASKOPTIONS
 i Option=4 d RESUME() g TASKOPTIONS
 i Option=5 d PURGE() g TASKOPTIONS
 i Option=6 d MAIL() g TASKOPTIONS
 q
TASKOPTIONSE s $zt=""
 i $ze'["<INTERRUPT>" w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1936651305"),"ERROR: %1"),$ZE)
 q
INFO() {
 s $ZT="INFOE"
 w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3136722309"),"Task Manager Version: %1"),##class(%SYS.Task).VersionGet())
 w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1050947211"),"Task Manager is currently %1"),$case(##class(%SYS.Task).TASKMGRStatus(),0:$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2948462001"),"not running"),1:$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"790727023"),"running"),:$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2325058159"),"suspended")))
 w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2576973663"),"Task History purged after %1 days"),##class(%SYS.Task).HistoryPurgeGet())
 q
INFOE s $zt=""
 i $ze'["<INTERRUPT>" w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1936651305"),"ERROR: %1"),$ZE)
 q
}
START() {
	S $ZT="STARTE"
	i ##class(%SYS.Task).TASKMGRStatus() w !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1067701360"),"Task Manager is currently running") q
	w !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"4211934992"),"Task Manager is not running"),!
	w:$SYSTEM.Version.GetOS()'["Windows" !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"979048188"),"Ensure that you are using a privileged account to start the TASKMGR"),!
	i $$YN($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1960252605"),"Do you want to start Task Manager"),"Y")="N" q
	d ##class(%SYS.Task).StartTASKMGR()
	h 5
	If ##class(%SYS.Task).TASKMGRStatus() w !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"4209708361"),"Task Manager started") q
	w !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3975512539"),"Task Manager failed to start, check the messages.log file for errors")
	q
STARTE s $zt=""
	i $ze'["<INTERRUPT>" w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1936651305"),"ERROR: %1"),$ZE)
	q
}
SUSPEND() {
	s $ZT="SUSPENDE"
	i ##class(%SYS.Task).SuspendGet() {
		Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1142653944"),"Task Manager is suspended"),!
		Quit
	}
	i $$YN($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1869607359"),"Do you want to suspend the Task Manager"),"Y")="N" q
	i ##class(%SYS.Task).SuspendSet(1) {
		w !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1142653944"),"Task Manager is suspended")
	}
	q
SUSPENDE s $zt=""
	i $ze'["<INTERRUPT>" w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1936651305"),"ERROR: %1"),$ZE)
	q
}
RESUME() {
 s $ZT="RESUMEE"
 i ##class(%SYS.Task).SuspendGet()=0 {
	 Write !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2417618865"),"Task Manager not Suspended"),!
	 Quit
 }
 i $$YN($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3538703545"),"Do you want to resume the Task Manager"),"Y")="N" q
 i ##class(%SYS.Task).SuspendSet(0) {
	 w !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1487719"),"Task Manager resumed")
 }
 q
RESUMEE s $zt=""
 i $ze'["<INTERRUPT>" w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1936651305"),"ERROR: %1"),$ZE)
 q
}
PURGE() {
PURGE1 s $ZT="PURGEE"
 s Days=##class(%SYS.Task).HistoryPurgeGet()
 w !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2996608125"),"Number of days to keep Task History? ")_Days_" => "
 r Option s:Option="" Option=Days
 i '(Option?1.4N) w !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3709371068"),"Please enter a number") g PURGE1
 d ##class(%SYS.Task).HistoryPurgeSet(+Option)
 w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"953816723"),"Number of days set to %1"),Option)
 i $$YN($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"730840388"),"Do you want to purge the Task History"),"Y")="N" q
 d ##class(%SYS.Task.History).PurgeHistory()
 w !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"966508975"),"Task History purged")
 q
PURGEE s $zt=""
 i $ze'["<INTERRUPT>" w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1936651305"),"ERROR: %1"),$ZE)
 q
}
GETTASK(Prompt,Mode,Type,Number) {
 Set Rset = ##class(%Library.ResultSet).%New("%SYS.Task:TaskList")
 d Rset.Execute()
 Set tasklist(0)=$lb($$LocalizeQueryColumn^TASKMGR1(Rset.GetColumnName(1)),$$LocalizeQueryColumn^TASKMGR1(Rset.GetColumnName(2)),$$LocalizeQueryColumn^TASKMGR1(Rset.GetColumnName(6)))
 While Rset.Next() {
	s tasklist(Rset.Get("ID"))=Rset.GetData(1)_"^"_Rset.GetData(2)_"^"_Rset.Get("ID")_"^"_Rset.Get("Suspended")
 }
GETTASK1 s $zt="GETTASKE"
 w !!,Prompt
 R Task i (Task="")!(Task="^")!($zcvt(Task,"U")="STOP") Set Number=$C(0) q $C(0)
 i (Mode=2),(Task="*") Set Number="*" q "*"
 i Task="?" w ! d  w ! g GETTASK1
 . w !,"   ID",?8,$lg(tasklist(0),1),?36,$lg(tasklist(0),2),?47,$lg(tasklist(0),3)
 . Set i=0
 . For  Set i=$O(tasklist(i)) Quit:i=""  d
 . . w !,$j(i,5)_") ",?8,$p(tasklist(i),"^",1),?36,$p(tasklist(i),"^",2),?47,$p(tasklist(i),"^",4)
 Set Rset=""
 s Index=0
 i Task,$d(tasklist(Task)) Set Index=Task,Task=$p(tasklist(Task),"^",1) Write "  ",Task,!
 If 'Index {
	 Set i=0
	 For  Set i=$O(tasklist(i)) Quit:i=""  i $p(tasklist(i),"^")=Task s Index=i q
 }
 i (Mode=0),(Index'=0) w !,"Task "_Task_" already exists, please re-enter" g GETTASK1
 i (Mode),(Index=0) w !,"Task "_Task_" does not exist, please re-enter" g GETTASK1
 i (Mode),(Type=0),$p(tasklist(Index),"^",2)="System" w !,"Cannot select System Task "_Task_", please re-enter" g GETTASK1
 Set Number=Index
 q Task
GETTASKE S $ZT="GETTASKE1"
 i $ze["<INTERRUPT>" q $C(0)
 w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1936651305"),"ERROR: %1"),$ZE)
 q $C(0)
GETTASKE1 s $zt=""
 w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1936651305"),"ERROR: %1"),$ZE)
 q $C(0)
 }
OPTION(prompt,default,max) [] {
 s $zt="OPTIONE"
OPTION1 w !,prompt
 r Option i Option="" q default
 i '(Option?1.2N)!(Option<1)!(Option>max) w !!,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3288010699"),"Please enter a number between 1 and %1"),max),! g OPTION1
 q +Option
OPTIONE s $zt=""
 i $ze'["<INTERRUPT>" w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1936651305"),"ERROR: %1"),$ZE)
 q 0
}
MULTIDAYOPTION(prompt,default,min,max) [] {
	Quit $$MULTIDAYOPTION^TASKMGR1(prompt,default,min,max)
} 
NUMOPTION(prompt,default,min,max) [] {
	Quit $$NUMOPTION^TASKMGR1(prompt,default,min,max)
}
STRINGOPTIONEXT(prompt,default,allownull,same) Quit $$STRINGOPTION(prompt,default,allownull,.same)
STRINGOPTION(prompt,default,allownull,same) [] {
 s $zt="STRINGOPTIONE"
STRINGOPTION1 w !,prompt_"? " i default'="" w default_" => "
 s same=0
 r Option i Option="",(default'="") s same=1 q default
 i Option="",(allownull=0) w !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1380879397"),"Please enter a non-null value") g STRINGOPTION1 
 q Option
STRINGOPTIONE s $zt=""
 i $ze'["<INTERRUPT>" w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1936651305"),"ERROR: %1"),$ZE)
 q $C(0)
}
GETTIME(prompt,default) [] {
 s $zt="GETTIMEE"
GETTIME1
	s default=default\60*60
	w !,prompt_"? "_$ztime(default,2)_" => " 
	r Option i Option="" q default
	s Option=$ztimeh(Option,,$C(0))
	i Option=$C(0) w !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1413884408"),"Invalid time, please re-enter") g GETTIME1
	q Option\60*60
GETTIMEE s $zt=""
	i $ze'["<INTERRUPT>" w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1936651305"),"ERROR: %1"),$ZE)
	q $C(0)
}
GETDATE(prompt,default) [] {
 s $zt="GETDATEE"
GETDATE1
	w !,prompt_"? "
	i +default'=0 w $zdate(default,3)_" => " 
	r Option i Option="" q default
	s Option=$zdateh(Option,5,,6,,,,,$C(0))
	i Option=$C(0) w !,$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1333283697"),"Invalid date, please re-enter") g GETDATE1
	q Option
GETDATEE s $zt=""
	i $ze'["<INTERRUPT>" w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1936651305"),"ERROR: %1"),$ZE)
	q $C(0)
}
TASKREPORTS s $ZT="TASKREPORTSE"
	Do TASKREPORTS^TASKMGR1
	Set Option=$$OPTION($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1071287907"),"Option? "),6,6)
	i Option=1 d TASKSCHEDULE() g TASKREPORTS
	i Option=2 d TASKDETAIL("") g TASKREPORTS
	i Option=3 d TASKHISTORY() g TASKREPORTS
	i Option=4 d TASKHISTORYDETAIL() g TASKREPORTS
	i Option=5 d UpcomingTasks^TASKMGR1 g TASKREPORTS
	q
TASKREPORTSE s $zt=""
	i $ze'["<INTERRUPT>" w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1936651305"),"ERROR: %1"),$ZE)
	q
TASKSCHEDULE() PRIVATE {
	Do TASKSCHEDULE^TASKMGR1
}
TASKDETAIL(TaskNumber) PRIVATE { 
TASKDETAIL1	s $ZT="TASKDETAILE"
	i TaskNumber="" {
		s Name=$$GETTASK($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1299577689"),"Display detail of which task (*=ALL)? "),2,3,.Number) q:Number=$C(0)
	} Else { Set Number=TaskNumber}
	Set Rset = ##class(%Library.ResultSet).%New("%SYS.Task:TaskListDetail")
	d Rset.Execute()
	While Rset.Next() {
		Set ID=Rset.Get("ID")
		If ID=Number!(Number="*") {
			w !,"------------------"
			f i=1:1:Rset.GetColumnCount() w !,$$LocalizeQueryColumn^TASKMGR1(Rset.GetColumnName(i))_":",?22,Rset.GetData(i)
		}
	}
	If TaskNumber="" G TASKDETAIL1
	Quit
TASKDETAILE s $zt=""
	i $ze'["<INTERRUPT>" w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1936651305"),"ERROR: %1"),$ZE)
	Q
}
TASKHISTORY() PRIVATE {
	Do TASKHISTORY^TASKMGR1
}
TASKHISTORYDETAIL() PRIVATE {
	D TASKHISTORYDETAIL^TASKMGR1
}
MAIL() PRIVATE { Set $zt="MAILE"
MAIL1	//
	D MAIL^TASKMGR1
 	s Option=$$OPTION($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1071287907"),"Option? "),8,8)
 	i Option=1 d MAILSERVER^TASKMGR1 g MAIL1
 	i Option=2 d MAILPORT^TASKMGR1 g MAIL1
 	i Option=3 d MAILREPLY^TASKMGR1 g MAIL1
 	i Option=4 d MAILSENDER^TASKMGR1 g MAIL1
 	i Option=5 d TIMEZONE^TASKMGR1 g MAIL1
 	i Option=6 d MAILAUTHUSER^TASKMGR1 g MAIL1
 	i Option=7 d MAILSSL^TASKMGR1 g MAIL1
 	q
MAILE	s $zt=""
	i $ze'["<INTERRUPT>" w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1936651305"),"ERROR: %1"),$ZE)
}
MAILREPLY() PRIVATE {
	D MAILREPLY^TASKMGR1
}
MAILSENDER() PRIVATE {
	D MAILSENDER^TASKMGR1
}
TIMEZONE() PRIVATE {
	D TIMEZONE^TASKMGR1
}
MAILAUTHUSER() PRIVATE {
	D MAILAUTHUSER^TASKMGR1
}
TASKLIST() PRIVATE {
	Do TASKLIST1^TASKMGR1
}
GETTASK1(Prompt,Mode,Type,Number)
	Quit $$GETTASK(Prompt,Mode,Type,.Number)
YN(P,D,t) N R,X S P=$G(P),D=$E($G(D)_"?"),t=$G(t) ;ask Yes/No w/ Prompt,Default
 S D=$S("Yy"[D:"Yes => ","Nn"[D:"No => ",1:"") ;Yes, No or no default
 F  W !,P_"? "_D Read:t R:t Read:'t R DO  I "^YN"[R Q  ;timed or non-timed read
 . S X=R,R=$TR($E(R_D_"?"),"yn","YN") I "^YN"'[R W "  enter Yes or No, please"
 S POP=(R="^") W $E($S(R="N":"No",R="Y":"Yes",1:""),$L(X)+1,3) Q R

TASKMGR1^INT^1^67214,47331
TASKMGR ; Task manager
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	/// extension of TASKMGR routine
TASKSCHEDULE	s $ZT="TASKSCHEDULEE"
	w !
	Set Rset = ##class(%Library.ResultSet).%New("%SYS.Task:TaskSchedule")
	d Rset.Execute()
	w !,##class(%SYS.Task).FormatTaskSchedule($$LocalizeQueryColumn(Rset.GetColumnName(1)),$$LocalizeQueryColumn(Rset.GetColumnName(2)),$$LocalizeQueryColumn(Rset.GetColumnName(3)),$$LocalizeQueryColumn(Rset.GetColumnName(4)),$$LocalizeQueryColumn(Rset.GetColumnName(5)))
	w !,##class(%SYS.Task).FormatTaskSchedule($$UL(Rset.GetColumnName(1)),$$UL(Rset.GetColumnName(2)),$$UL(Rset.GetColumnName(3)),$$UL(Rset.GetColumnName(4)),$$UL(Rset.GetColumnName(5)))
	While Rset.Next() {
		w !,##class(%SYS.Task).FormatTaskSchedule(Rset.GetData(1),Rset.GetData(2),Rset.GetData(3),Rset.GetData(4),Rset.GetData(5))
	}
	q
TASKSCHEDULEE s $zt=""
	i $ze'["<INTERRUPT>" w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1936651305"),"ERROR: %1"),$ZE)
	q
TASKDETAIL(TaskNumber) 
TASKDETAIL1	s $ZT="TASKDETAILE"
	i TaskNumber="" {
		s Name=$$GETTASK1^TASKMGR($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"675976747"),"Display detail of which task (*=ALL)"),2,3,.Number) q:Number=$C(0)
	} Else { Set Number=TaskNumber}
	Set Rset = ##class(%Library.ResultSet).%New("%SYS.Task:TaskListDetail")
	d Rset.Execute()
	While Rset.Next() {
		Set ID=Rset.Get("ID")
		If ID=Number!(Number="*") {
			w !,"------------------"
			f i=1:1:Rset.GetColumnCount() {
				i Rset.GetColumnName(i)="MirrorStatus",'$SYSTEM.Mirror.IsMember() continue
				w !,$$LocalizeQueryColumn(Rset.GetColumnName(i))_":",?22,Rset.GetData(i)
			}
		}
	}
	If TaskNumber="" G TASKDETAIL1
	Quit
TASKDETAILE s $zt=""
	i $ze'["<INTERRUPT>" w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1936651305"),"ERROR: %1"),$ZE)
	Q
TASKHISTORY	s $ZT="TASKHISTORYE"
	s Name=$$GETTASK1^TASKMGR($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3545996286"),"Display history of which task (*=ALL)"),2,3) q:Name=$C(0)
	w !
	Set query="%SYS.Task.History:TaskHistory",ID=""
	If Name'="",Name'="*" {
		Set ID=##class(%SYS.Task).FindId(Name)
		IF ID Set query="%SYS.Task.History:TaskHistoryForTask"
	}
	Set Rset = ##class(%Library.ResultSet).%New(query)
	d Rset.Execute(ID)
	w !,##class(%SYS.Task.History).FormatTaskHistory($$LocalizeQueryColumn(Rset.GetColumnName(1)),Rset.GetColumnName(2),Rset.GetColumnName(3),Rset.GetColumnName(4),Rset.GetColumnName(5))
	w !,##class(%SYS.Task.History).FormatTaskHistory($$UL(Rset.GetColumnName(1)),$$UL(Rset.GetColumnName(2)),$$UL(Rset.GetColumnName(3)),$$UL(Rset.GetColumnName(4)),$$UL(Rset.GetColumnName(5)))
	While Rset.Next() {
		w !,##class(%SYS.Task.History).FormatTaskHistory(Rset.GetData(1),Rset.GetData(2),Rset.GetData(3),Rset.GetData(4),Rset.GetData(5))
	}
	Quit
TASKHISTORYE s $zt=""
	i $ze'["<INTERRUPT>" w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1936651305"),"ERROR: %1"),$ZE)
 	q
TASKHISTORYDETAIL	//
	s $ZT="TASKHISTORYDETAILE"
	s Name=$$GETTASK1^TASKMGR($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"46185186"),"Display detail history of which task (*=ALL)"),2,3,.Number) q:Name=$C(0)
	w !
	Set Query="%SYS.Task.History:TaskHistory"
	If Name'="*" Set Query="%SYS.Task.History:TaskHistoryForTask"
	Set Rset = ##class(%Library.ResultSet).%New(Query)
	Set Rset.RuntimeMode=2
	d Rset.Execute(Number)
	s len=0
	f i=1:1:Rset.GetColumnCount() s newlen=$l($$LocalizeQueryColumn(Rset.GetColumnName(i))) i newlen>len s len=newlen
	While Rset.Next() {
		i (Rset.Get("Task Name")=Name)!(Name="*") {
			w !,"------------------"
			f i=1:1:Rset.GetColumnCount() w !,$$LocalizeQueryColumn(Rset.GetColumnName(i))_":",?newlen+2,Rset.GetData(i)
		}
	}
	Quit
TASKHISTORYDETAILE s $zt=""
	i $ze'["<INTERRUPT>" w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1936651305"),"ERROR: %1"),$ZE)
	q
MAIL	//
 	w !
 	w !,"1) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"880933896"),"Define Mail Server")
 	w !,"2) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3187197805"),"Define Server Port")
 	w !,"3) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2274824725"),"Define Reply To")
 	w !,"4) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2103178825"),"Define Sender")
 	w !,"5) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1410831273"),"Time Zone")
 	w !,"6) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1615012644"),"Define Authenticated User")
 	w !,"7) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"68695254"),"Define SSL Configuration")
 	w !,"8) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"876292912"),"Exit")
 	w !
	q
MAILSERVER	//
	Set Value=##class(%SYS.Task.Config).GetData("MailServer")
	Set Value=$$STRINGOPTIONEXT^TASKMGR($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"474235070"),"Mail Server"),Value,1,.Same) q:Value=$C(0)  Quit:Same
	Set Status=##class(%SYS.Task).MailServerSet(Value)
	Q
MAILPORT	//
	Set Value=##class(%SYS.Task.Config).GetData("MailPort")
	Set Value=$$STRINGOPTIONEXT^TASKMGR($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1610834942"),"Mail Server Port"),Value,1,.Same) q:Value=$C(0)  Quit:Same
	Set Status=##class(%SYS.Task).MailPortSet(Value)
	Q
MAILREPLY	//
	Set Value=##class(%SYS.Task.Config).GetData("MailReplyTo")
	Set Value=$$STRINGOPTIONEXT^TASKMGR($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3522138738"),"Reply To"),Value,1,.Same) q:Value=$C(0)  Quit:Same
	Set Status=##class(%SYS.Task).MailReplyToSet(Value)
	Q
MAILSENDER	//
	Set Value=##class(%SYS.Task.Config).GetData("MailSender")
	Set Value=$$STRINGOPTIONEXT^TASKMGR($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1729764905"),"Send Message As"),Value,1,.Same) q:Value=$C(0)  Quit:Same
	Set Status=##class(%SYS.Task).MailSenderSet(Value)
	Q
TIMEZONE	//
	Set Value=##class(%SYS.Task.Config).GetData("MailTimeZone")
	Set Value=$$STRINGOPTIONEXT^TASKMGR($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1410831273"),"Time Zone"),Value,1,.Same) q:Value=$C(0)  Quit:Same
	Set Status=##class(%SYS.Task).MailTimeZoneSet(Value)
	Q
MAILAUTHUSER	//
	W !!,"This option is only required to do SMTP authentication "
	W !,"with the SMTP server (as defined by RFC 2554)"
	Set User=##class(%SYS.Task.Config).GetData("MailAuthUser")
	Set User=$$STRINGOPTIONEXT^TASKMGR($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"648618971"),"Authenticated Username"),User,1,.Same) q:User=$C(0)
	/// remove current user by entering one or more spaces
	If $TR(User," ")="" Set User=""
	If 'Same {
		Do ##class(%SYS.Task.Config).UpdateData("MailAuthUser",User)
	}
	If User="" Do ##class(%SYS.Task.Config).AuthPassSet("") Quit
	u:$zu(96,14)=1 $io:(:"S")
	Set Password=$$STRINGOPTIONEXT^TASKMGR($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3946144633"),"Authenticated Password"),"",1,.Same)
	u:$zu(96,14)=1 $io:(:"-S")
	q:Password=$C(0)
	If 'Same {
		Do ##class(%SYS.Task.Config).AuthPassSet(Password)
	}
	Quit
MAILSSL	//
	Set Value=##class(%SYS.Task.Config).GetData("MailSSLConfiguration")
	Set Value=$$STRINGOPTIONEXT^TASKMGR($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1785800903"),"SSL Configuration"),Value,1,.Same) q:Value=$C(0)
	/// remove current SSLConfig by entering one or more spaces
	If $TR(Value," ")="" Set Value=""
	If 'Same {
		If Value'="",'##Class(Security.SSLConfigs).Exists(Value,,.Status) Write !,$System.Status.GetErrorText(Status) Quit
		Set Status=##class(%SYS.Task.Config).UpdateData("MailSSLConfiguration",Value)
	}
	Set Value=+##class(%SYS.Task.Config).GetData("MailUseSTARTTLS")
	Set Value=$$STRINGOPTIONEXT^TASKMGR($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1651792071"),"UseSTARTTLS"),Value,1,.Same) q:Value=$C(0)
	If 'Same Set Status=##class(%SYS.Task.Config).UpdateData("MailUseSTARTTLS",+Value)
	Q
TASKLIST1	//
	s $zt="TASKLISTE"
	Set Rset = ##class(%Library.ResultSet).%New("%SYS.Task:TaskList")
	w !!,$$LocalizeQueryColumn(Rset.GetColumnName(1)),?28,$$LocalizeQueryColumn(Rset.GetColumnName(2)),?39,$$LocalizeQueryColumn(Rset.GetColumnName(3))
	w !,$$UL(Rset.GetColumnName(1)),?28,$$UL(Rset.GetColumnName(2)),?39,$$UL(Rset.GetColumnName(3))
	d Rset.Execute()
	While Rset.Next() {
		w !,Rset.GetData(1),?28,Rset.GetData(2),?39,Rset.GetData(3)
	}
	q
TASKLISTE s $zt=""
 i $ze'["<INTERRUPT>" w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1936651305"),"ERROR: %1"),$ZE)
 q
UL(String) {
	s $P(x,"-",$l(String)+1)=""
	q x
}
MULTIDAYOPTION(prompt,default,min,max)	//  
 	w !
 	w !,"1) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3421684983"),"Sunday")
 	w !,"2) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3632146495"),"Monday")
 	w !,"3) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"597723493"),"Tuesday")
 	w !,"4) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"395286495"),"Wednesday")
 	w !,"5) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3078746362"),"Thursday")
 	w !,"6) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3072242550"),"Friday")
 	w !,"7) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3910980832"),"Saturday")
 	w !
	s $zt="MULTIDAYOPTIONE"
MULTIDAYOPTION1 w !,prompt_"? "_default_" => "
	r Option i Option="" q default
	S Ok=1
	F I=1:1:$L(Option) S v=$e(Option,I) i "1234567"'[v w !!,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2705546656"),"Please enter numbers between %1 and %2"),min,max),! S Ok=0
	i 'Ok g MULTIDAYOPTION1
	q +Option
MULTIDAYOPTIONE s $zt=""
	i $ze'["<INTERRUPT>" w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1936651305"),"ERROR: %1"),$ZE)
	q $C(0)
NUMOPTION(prompt,default,min,max) 	// 
	s $zt="NUMOPTIONE"
NUMOPTION1 w !,prompt_"? "_default_" => "
	r Option i Option="" q default
	i '(Option?1.4N)!(Option<min)!(Option>max) w !!,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2705546656"),"Please enter numbers between %1 and %2"),min,max),! g NUMOPTION1
	q +Option
NUMOPTIONE s $zt=""
	i $ze'["<INTERRUPT>" w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1936651305"),"ERROR: %1"),$ZE)
	q $C(0)
Priority(CurrentPriority)	///
	w !
	w !,"1) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"640249298"),"Normal")
	w !,"2) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2865053249"),"Low")
	w !,"3) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1362578283"),"High")
	w !
	s Priority=$$NUMOPTION($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2614148721"),"Priority"),(CurrentPriority)+1,1,3) 
	Quit Priority
MirrorStatus(CurrentStatus)	///
	w !
	w !,"1) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"3640185626"),"Primary")
	w !,"2) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2081684781"),"Non-Primary")
	w !,"3) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1556001108"),"Any")
	w !
	s Status=$$NUMOPTION($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1832637606"),"MirrorStatus"),CurrentStatus,1,3) 
	Quit Status
TASKREPORTS	///
	w !
	w !,"1) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2146098704"),"Task Schedule")
	w !,"2) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2394935651"),"Task Detail")
	w !,"3) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"2594651129"),"Task History")
	w !,"4) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1159264198"),"Task History Detail")
	w !,"5) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1538899152"),"Upcoming Tasks")
	w !,"6) ",$get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"876292912"),"Exit")
	w !
	Quit
LocalizeQueryColumn(pName)	//
 	// get key, lookup in localization global
	Set tKey = $ZCVT(pName,"L")
	Set tLang = $select($isObject($get(%response)):%response.Language,1:$get(^%SYS("LANGUAGE","CURRENT"),"en"))
	Quit $get(^%qMsg("%UtilityColumns",tLang,tKey),pName_"*")
UpcomingTasks	///
	Try {
		Set Rset = ##class(%Library.ResultSet).%New("%SYS.Task:UpcomingTasks")
		Set Rset.RuntimeMode=2
		d Rset.Execute()
		Set uLine="----------------------",Columns="ID:5,Name:30,Date:10,Time:8,Suspended:10"
		For tIdx=1,2 {
			Write !
			For Cols=1:1:$l(Columns,",") {
				Set txt=$P($p(Columns,",",Cols),":"),size=$p($p(Columns,",",Cols),":",2)
				If tIdx=1 Write $j($$LocalizeQueryColumn(txt),size)_" "
				Else  Write $j($e(uLine,1,size),size)_" "
			}
		}
		While Rset.%Next() {
			Write !
			For Cols=1:1:$l(Columns,",") {
				Set txt=$P($p(Columns,",",Cols),":"),size=$p($p(Columns,",",Cols),":",2)
				Write $j(Rset.Get(txt),size)_" "
			}
		}
	} Catch {
		i $ze'["<INTERRUPT>" w !,$$FormatText^%occMessages($get(^%qMsg("%Utility",$s($mvv(58)="":"en",1:$mvv(58)),"1936651305"),"ERROR: %1"),$ZE)
	}
	Quit

TERCAP^INT^1^67214,47331
TERCAP ; Terminal DB for charwindows
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 k ops s ops=3
 s ops(1)="edit;Edit/create terminal description"
 s ops(2)="border;Edit/create border map"
 s ops(3)="del;Delete terminal description"
option r !!,"Option: ",op q:op=""
 i op="?" w ! d  g option
 . f i=1:1:ops w !,?5,i," - ",$p(ops(i),";",2)
 i '$d(ops(op)) w *7," <???>" g option
 s op=ops(op) w " - ",$p(op,";",2) g @$p(op,";",1)
 ;----------------------------------------------------------------
 ;
 ; Edit/create terminal description
 ;
edit r !!,"Terminal type: ",tt g option:tt=""  i tt="?" d types g edit
 i '$d(^%SYS("tercap",tt)) r " new ? [y] ",r i r'="",r'="y",r'="Y" g edit
 i '$d(^%SYS("tercap",tt)) d copy(tt)
 i '$d(^%SYS("tercap",tt,"names")) s ^("names")=tt
 i '$d(^("lins")) s ^("lins")=24
 i '$d(^("cols")) s ^("cols")=80
names s old=^%SYS("tercap",tt,"names") w !,"Names: ",old r " // ",new
 i new'="",new'=old s ^("names")=new
lins s old=^%SYS("tercap",tt,"lins") w !,"Lines: ",old r " // ",new
 i new'="",new'=old s ^("lins")=new
cols s old=^%SYS("tercap",tt,"cols") w !,"Colunms: ",old r " // ",new
 i new'="",new'=old s ^("cols")=new
flags s old=$g(^%SYS("tercap",tt,"flags")) w !,"Flags: ",old d bits(old)
 r !,"  New: ",new i new=""!(new=old) g mnemo
 i new="?" d bits(65535) g flags
 d bits(new) r " Ok ? [y] ",ok i ok'="",ok'="y",ok'="Y" g flags
 s ^("flags")=new
mnemo r !,"Mnemonic: ",mn g edit:mn=""
 i mn="?" s mn="" f  s mn=$o(^%SYS("tercap",tt,"src",mn)) g mnemo:mn="" w !,?10,mn
 i '$d(^%SYS("tercap",tt,"src",mn)) r " new ? [y] ",r i r'="",r'="y",r'="Y" g mnemo
src s old=$g(^%SYS("tercap",tt,"src",mn)) w !,?3,"Old: ",old r !,?3,"New: ",new
 i new="*D" d  w "deleted" g mnemo
 . r "ELETE ? [n] ",r i r'="y",r'="Y" w " NOT " q
 . k ^%SYS("tercap",tt,"src",mn),^%SYS("tercap",tt,"bin",mn) q 
 i new=""!(new=old) g mnemo
 s bin=$$tic(new)
 i er'="" w "  ",$p(er,";",2,999),!,?7+er,"^" g src
 s ^%SYS("tercap",tt,"src",mn)=new,^%SYS("tercap",tt,"bin",mn)=bin g mnemo
 ;------------------------------------------------------------------
 ;
 ; Edit/create border map
 ;
border s bs(1)="Single line",bs(2)="Double line",bs(3)="Bold line"
 s bs(4)="Blocks",bs(5)="Light dots",bs(6)="Dark dots"
 s bs(7)="Light bar",bs(8)="Medium bar",bs(9)="Heavy bar"
 s bc8="   UL   UR   LL   LR   TO   BO   LE   RI"
 s un8="  ---  ---  ---  ---  ---  ---  ---  ---"
 s bc4="   LE   RI   TO   BO"
 s un4="  ---  ---  ---  ---"
bordtt r !!,"Terminal type: ",tt g option:tt="" i tt="?" d types g border
 i '$d(^%SYS("tercap",tt)) w *7," <Unknown terminal>" g bordtt
 s old=$g(^%SYS("tercap",tt,"src","bormap"))
 i old="" s $p(old,"0,",62)="",old=old_0
 s new=old
bstyle r !!,"Border style: ",bs
 i bs="" s:new'=old ^%SYS("tercap",tt,"src","bormap")=new,@("^%SYS(""tercap"",tt,""bin"",""bormap"")=$c("_new_")") g bordtt
 i bs="?" d bstyles g bstyle
 i bs'?1n!(bs=0) w *7," <1 to 9>" g bstyle
 w "  ",bs(bs) d @("bstyle"_bs) g bstyle
 ;
bstyle1 s ocs=$p(new,",",1) d cset
 i ncs'="",ncs'=ocs f i=1:2:15 s $p(new,",",i*2-1)=ncs
 w !,!,?10,bc8,!,?10,un8,!,?10 f i=1:2:9,13,11,15 d fmt(i)
 w !,?10 f i=1:2:9,13,11,15 d charr(i)
 q
bstyle2 s ocs=$p(new,",",3) d cset
 i ncs'="",ncs'=ocs f i=2:2:16 s $p(new,",",i*2-1)=ncs
 w !,!,?10,bc8,!,?10,un8,!,?10 f i=2:2:10,14,12,16 d fmt(i)
 w !,?10 f i=2:2:10,14,12,16 d charr(i)
 q
bstyle3 w *7," Same as style 1 (Single line) with bold attribute" q
bstyle4 s ocs=$p(new,",",61) d cset
 i ncs'="",ncs'=ocs s $p(new,",",61)=ncs
 d char1(31) q
bstyle5 s ocs=$p(new,",",59) d cset
 i ncs'="",ncs'=ocs s $p(new,",",59)=ncs
 d char1(30) q
bstyle6 s ocs=$p(new,",",57) d cset
 i ncs'="",ncs'=ocs s $p(new,",",57)=ncs
 d char1(29) q
bstyle7 s ocs=$p(new,",",33) d cset
 i ncs'="",ncs'=ocs f i=17:1:24 s $p(new,",",i*2-1)=ncs
 w !,!,?10,bc8,!,?10,un8,!,?10 f i=17:1:24 d fmt(i)
 w !,?10 f i=17:1:24 d charr(i)
 q
bstyle8 w *7," Same as style 7 (Light bar)" q
bstyle9 s ocs=$p(new,",",49) d cset
 i ncs'="",ncs'=ocs f i=25:1:28 s $p(new,",",i*2-1)=ncs
 w !,!,?10,bc4,!,?10,un4,!,?10 f i=25:1:28 d fmt(i)
 w !,?10 f i=25:1:28 d charr(i)
 q
 ;
cset w !,!,"Charset: ",ocs r " // ",ncs
 i ncs'="",ncs'="0",ncs'="1",ncs'="2" w *7," <0, 1 or 2>" g cset
 q
 ;
char1(i) w !,!,?10,"All Chars",!,?10,"----------",!,?11
 d fmt(i) w !,?11 d charr(i) q
 ;
charr(i) n dx,j w ?$x+2 s dx=$x
chrrd r ch#4
 i ch="" w $j($p(new,",",i*2),3) q
 f j=1:1:$l(ch) w *8," ",*8
 s $x=dx
 i ch'?1.3n!(ch>255) w *7 g chrrd
 w $j(ch,3) s $p(new,",",i*2)=ch q
 ;
bstyles n i w !
 w !,?7,"Styles",?25,"Charset",?33,bc8
 w !,?7,"---------------",?25,"-------",?33,un8
 w !,?7,"1 - ",bs(1),?28,$p(new,",",1),?33 f i=1:2:9,13,11,15 d fmt(i)
 w !,?7,"2 - ",bs(2),?28,$p(new,",",3),?33 f i=2:2:10,14,12,16 d fmt(i)
 w !,?7,"3 - ",bs(3),?28,$p(new,",",1),?33 f i=1:2:15 d fmt(i)
 w !,?7,"4 - ",bs(4),?28,$p(new,",",61),?33 f i=1:1:8 d fmt(31)
 w !,?7,"5 - ",bs(5),?28,$p(new,",",59),?33 f i=1:1:8 d fmt(30)
 w !,?7,"6 - ",bs(6),?28,$p(new,",",57),?33 f i=1:1:8 d fmt(29)
 w !,?7,"7 - ",bs(7),?28,$p(new,",",33),?33 f i=17:1:24 d fmt(i)
 w !,?7,"8 - ",bs(8),?28,$p(new,",",33),?33 f i=17:1:24 d fmt(i)
 w !,?7,"9 - ",bs(9),?28,$p(new,",",49),?33 f i=25,26,25,26,27,28,25,26 d fmt(i)
 q
fmt(n) w $j($p(new,",",n*2),5) q
 ;
 ;------------------------------------------------------------------
 ;
 ; Delete a terminal description
 ;
del r !!,"Terminal type: ",tt g option:tt="" i tt="?" d types g del
 i '$d(^%SYS("tercap",tt)) w *7," <Unknown terminal>" g del
 w !,"Delete terminal description for ",tt r " OK? [n] ",r
 i r'="y",r'="Y" w " NOT"
 e  k ^%SYS("tercap",tt)
 w " deleted" g del
 ;
copy(to) r !,"Copy from another terminal? [y] ",r i r'="",r'="y",r'="Y" q
from r !,"Copy from: ",from q:from=""  i from="?" d types g from
 i '$d(^%SYS("tercap",from)) w " <???>" g from
 w " Copying..." m ^%SYS("tercap",to)=^%SYS("tercap",from) w " done" q
 ;
types n ty s ty="" w ! f  s ty=$o(^%SYS("tercap",ty)) q:ty=""  w !,?10,ty
 q
 ;    
bits(n) i n#2 w !,?10," 1 = hascolor "
 s n=n\2 i n#2 w !,?10," 2 = firmware"
 s n=n\2 i n#2 w !,?10," 4 = auto-margin"
 s n=n\2 i n#2 w !,?10," 8 = pc-attributes"
 s n=n\2 i n#2 w !,?10,"16 = erase resets attributes"
 s n=n\2 i n#2 w !,?10,"32 = disable border mapping"
 q
 ;-------------------------------------------------------------------
 ;
comp ; Compile all mnemonics of all terminals
 ;
 n ty,mn s ty="",ne=0
 f  s ty=$o(^%SYS("tercap",ty)) q:ty=""  k ^%SYS("tercap",ty,"bin") d
 . w ty," " s mn="" f  s mn=$o(^%SYS("tercap",ty,"src",mn)) q:mn=""  d
 . . i mn="bormap" s @("bin=$c("_^(mn)_")"),er=""
 . . e  s bin=$$tic(^(mn))
 . . i er'="" s ne=ne+1 w !,mn,"  ",^(mn) q
 . . s ^%SYS("tercap",ty,"bin",mn)=bin q
 i ne=0 q
 i ne=1 w "There was 1 error!" q
 w "There were ",ne,"errors" q
 ;------------------------------------------------------------------
 ;
export ; Export ^%tercap as ^mtercap without binary nodes
 ;
 n x,type s x=$ZU(68,28,0),type="" k ^mtercap s x=$ZU(68,28,x) m ^mtercap=^%SYS("tercap")
 f  s type=$o(^mtercap(type)) q:type=""  k ^mtercap(type,"bin")
 q
 ;
INSTALL ; Install ^%SYS("tercap") from ^mtercap
 ;
 ; Preserve user definitions from ^%tercap
 i $d(^%tercap) m ^%SYS("tercap")=^%tercap
 i $d(^mtercap) m ^%SYS("tercap")=^mtercap
 n x
 s x=$ZU(68,28,0) k ^mtercap,^%tercap s x=$ZU(68,28,x)
 d comp q
 ;
tic(src) n ind,bin,lit,c s ind=0,bin="",c="",er="",lit=src'["%1"
parse d next,item
 i er'="" q ""
 i c="," g parse
 i c="" d end q bin
 d syntax q ""
 ;
end i lit s bin=$c($l(bin))_bin
 e  s bin=$c(0)_bin_$c(255)
 q
item i c="" q
 i c="""" d lit q
 i c="$"  d fun q
 i c="%"  d exp q
 d syntax q
 ;
syntax s er=ind_";Unexpected character: "_c q
lit d next
 i c="""",$e(src,ind+1)="""" d emit(0,34),next g lit
 i c="""" d next q
 i c="" s er=ind_";Expected """ q
 d emit(0,$a(c)) g lit
fun n fun d next s fun=$s(c="a":"A",c="c":"C",1:c)
 d next i c'="(" d syntax q
 d next,@$s(fun="A":"ascii",fun="C":"char",1:"erfun")
 q:er'=""  i c'=")" s er=ind_";Expected )" q
 d next q
 ;
erfun s er=ind-2_";Unknown function: $"_fun q
 ;
ascii d exp q:er'=""
 n l s l=$l(bin)-1,$e(bin,l)=$c($a($e(bin,l))+128)
 q
 ;
char n ch
 f  s ch=$$dec q:er'=""  d  q:er'=""!(c'=",")  d next
 . i ch>255 s er=ind-$l(ch)_";Invalid char code: "_ch q
 . d emit(0,ch)
 q
exp n par,sig,off d next s par=$$dec,sig="+",off=0
 i par=0!(par>127) s er=ind-$l(par)_";Invalid parameter: %"_par q
 i c="+"!(c="-") s sig=c d next s off=$$dec
 i sig="+",off>127 s er=ind-$l(off)_";Offset too big: "_off q
 i sig="-",off>128 s er=ind-$l(off)_";Offset too small: "_off q
 i sig="-" s off=256-off
 d emit(par,off) q
dec() i c'?1n s er=ind_";Expected a digit: "_c q ""
 n dec s dec=""
 f  q:c'?1n  s dec=dec_c d next
 q dec
 ;
emit(f,d) i lit,f=0 s bin=bin_$c(d)
 e  s bin=bin_$c(f)_$c(d)
 q
 ;
next s ind=ind+1,c=$e(src,ind) q

TRACE^INT^1^67214,47331
TRACE() {    ; Process TRACE utility ;$Change: 7440104 $
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 ; Revision: $Id: //iris/2024.1.3/databases/sys/rtn/diagnostic/trace.mac#1 $
	i '$SYSTEM.Security.Check("%Admin_Manage","USE") {
		w !,"Operation requires %Admin_Manage:Use privilege"
		q
	}
	n %lastflags,%dir,%events,%maxsize
	try {
		w !,"This utility traces the execution of a process.  Traced processes write events"
		w !,"to a trace file with details about the routine line where the event occurred"
		w !,"and, if applicable, the global reference.  The events available for tracing"
		w !,"correspond to the metrics availabe in performance monitoring tools (PERFMON,"
		w !,"%SYS.MONLBL etc).  Raw data is written to ","iris","trace_<pid>.txt in the"
		w !,"configured directory, and is then parsed and displayed by this utility."
		w !
		s %dir=##class(%SYS.Trace).GetDirectory()
		s %events=##class(%SYS.Trace).GetEvents()
		s %maxsize=##class(%SYS.Trace).GetMaxSize()
		k list
		s list(1)="Configure Trace"
		s list(2)="Trace Process (Foreground)"
		s list(3)="Start Background Trace"
		s list(4)="Stop Background Trace"
		s list(5)="Display Trace Files"
		s list(6)="Delete All Trace Files"
		d:$ll(##class(%SYS.Trace).PIDList()) AskStopAll()
		f  {
			w !!,"Trace file directory:   ",$s(%dir="":"not set",1:%dir)
			w !, "Trace file size limit: ",$s(%maxsize=0:"unlimited",1:(%maxsize_" MB"))
			w !, "Trace events selected:  " f i=1:1:$ll(%events) { i $x+$l($li(%events,i))>77 { w !,"   " } elseif i>1 { w ", " } w $li(%events,i) }
			s v="",rc=##class(%Library.Prompt).GetMenu("Option?",.v,.list,,128+8+4)
			q:(rc'=1)||('v)
			if (v=1) {
				d SETUP()
				continue
			} elseif (%dir="") && (v<4) {
				w !!,"Trace directory must be configured first."
				d SETUP()
				continue:%dir=""
			}
			i v>4 {
				s dir=$$ChooseDirectory()
				i dir="" continue
			}
			i v=6 {
				w !!,"This option deletes all trace files in the selected directory except those that"
				w !,"are in use by processes currently being traced.  (You may also use operating"
				w !,"system commands to delete trace files.)"
				w !
				k yn s rc=##class(%Library.Prompt).GetYesNo("Do you want to delete them?",.yn,,8)
				d:$g(yn) Files("d",dir)
				continue
			}
			i v=4 && $$AskStopAll() { continue } 
			f  {
				s pid="",rc=##class(%Library.Prompt).GetNumber(list(v)_" - Enter PID:",.pid,,,,512+8+1)
				i rc=4 { 
					i (v=2)||(v=3) { 
						d ^%SS 
					} elseif (v=4) {
						s pids=##class(%SYS.Trace).PIDList()
						i '$ll(pids) { w !!,"No processes are being traced." q }
						w !!,"PIDs traced:  " f i=1:1:$ll(pids) { i $x+$l($li(pids,i))>77 { w !,"   " } elseif i>1 { w ", " } w $li(pids,i) }
					} elseif (v=5) {
						d Files(,dir)
					}
					w !,*-1
					continue
				}
				q:'pid||(rc'=1)
				i (v=2)||(v=5) {
					k help
					s help(1)="Enter a string of desired qualifiers"
					s help(2)="  d - Display database paths if possible.  If displaying a trace file"
					s help(3)="      created before the system started last, the paths may be inaccurate."
					s help(4)="  n - Display database system file numbers"
					s help(5)="  s - Dipslay source line if available"
					s flags=$g(%lastflags,"s"),rc=##class(%Library.Prompt).GetString("Option flags for display:",.flags,,,.help,8)
					q:(rc'=1)
					s %lastflags=flags
				}
				if v=2 { 
					d FORE(pid,flags)
				} elseif v=3 {
					s sc=##class(%SYS.Trace).StartPID(pid,%dir,%events,%maxsize)
					i (''sc) { w "  Started" } else { d $system.Status.DisplayError(sc) }
				} elseif v=4 { 
					s sc=##class(%SYS.Trace).StopPID(pid)
					i (''sc) { w "  Stopped" } else { d $system.Status.DisplayError(sc) }
				} elseif v=5 {
					s tf=dir_"iris"_"trace_"_pid_".txt"
					i '##class(%Library.File).Exists(tf) {
						w !!,"File ",tf," not found.",!
					} else {
						w !
						d ##class(%SYS.Trace).Display(tf,flags)
					}
				}
			}
		}
	} catch {
		w !!,"Exiting due to error: ",$ze
	}
}
FORE(pid,flags) PUBLIC {
	try {
		w !
		s dir=%dir
		i dir="" { w !,"Directory must be set first" q }
		s pids=##class(%SYS.Trace).PIDList()
		i $listfind(pids,pid) { w !,"PID ",pid," is already being traced." q }
		s tf=dir_"iris"_"trace_"_pid_".txt"
		i ##class(%Library.File).Exists(tf) && '##class(%Library.File).Delete(tf) { 
			w !,"Failed to delete old trace file ",tf
			q
		}
		s sc=##class(%SYS.Trace).StartPID(pid,dir,%events,%maxsize)
		i ('sc) { w !,"Error starting trace" d $system.Status.DisplayError(sc) q	}
		s started=1
		w !,"Trace started for PID ",pid,". Waiting for trace file... "
		w !," (ctrl-c to stop)"
		b 1
		h .5
		while '##class(%Library.File).Exists(tf) { h .5 }
		d ##class(%SYS.Trace).Display(tf,$g(flags)_"w")
	} catch { 
		w:$ze'["INTERRUPT" !,"Error: ",$ze
	}
	i $g(started) {
		s sc=##class(%SYS.Trace).StopPID(pid)
		i ('sc) { 
			w !,"Error stopping trace!"
			d $system.Status.DisplayError(sc)
		} else { w !,"Trace stopped" }
		i ##class(%Library.File).Exists(tf) {
			f i=1:1 {
				i ##class(%Library.File).Delete(tf) { w !,"Trace file deleted" q }
				i i>$s(($zversion(1)=2):5,1:1) { w !,"Failed to delete trace file ",tf,*7 q }
				h 1
			}
		}
	}
	w !
}
SETUP() PUBLIC {
	try {
		w !!,"Note: Trace files may contain sensitive information such as global references"
		w !,"(but not values) or parameters passed to subroutines.  The trace directory must"
		w !,"exist and must be writeable by the processes being traced."
		w !
		w !,"You can configure and use the system-wide defaults or use custom settings for"
		w !,"this trace session."
		w !!,"System-wide defaults:"
		s sysdir=##class(%SYS.Trace).GetDirectory()
		s sysevents=##class(%SYS.Trace).GetEvents()
		s sysmaxsize=##class(%SYS.Trace).GetMaxSize()
		w !!,"    Directory:   ",$s(sysdir="":"not set",1:sysdir)
		w !, "    Size Limit:  ",$s(sysmaxsize=0:"unlimited",1:(sysmaxsize_" MB"))
		w !, "    Events:  " f i=1:1:$ll(sysevents) { i $x+$l($li(sysevents,i))>77 { w !,"   " } elseif i>1 { w ", " } w $li(sysevents,i) }
		w !
		i (%dir'=sysdir)||(%events'=sysevents)||(%maxsize'=sysmaxsize) {
			w !,"Custom settings are currently in effect."
			w !
		}
		s custom=1,rc=##class(%Library.Prompt).GetYesNo("Use custom settings for this session?",.custom,,8)
		q:(rc'=1)
		i 'custom {
			s %dir=sysdir
			s %events=sysevents
			s %maxsize=sysmaxsize
		}
retrydir
		s dir=%dir
		s rc=##class(%Library.Prompt).GetString("Directory for trace files:",.dir,,,,8)
		q:(rc'=1)||(dir="")
		i 'custom {
			s sc=##class(%SYS.Trace).SetDirectory(dir)
		} else {
			s sc=##class(%SYS.Trace).ValidateDirectory(dir)
		}
		i ('sc) {
			d $system.Status.DisplayError(sc)
			g retrydir
		}
		s dir=##class(%Library.File).NormalizeDirectory(dir)
		s %dir=dir
retrymaxsize
		s maxsize=%maxsize
		w !!,"Choose a value between 0 and 2047. If 0, file size is unlimited."
		s rc=##class(%Library.Prompt).GetNumber("Maximum trace file size (MB):",.maxsize,,,,8)
		q:(rc'=1)
		i 'custom {
			s sc=##class(%SYS.Trace).SetMaxSize(maxsize)
		} else {
			s sc=##class(%SYS.Trace).ValidateMaxSize(maxsize)
		}
		i ('sc) {
			d $system.Status.DisplayError(sc)
			g retrymaxsize
		}
		s %maxsize=maxsize
		d GetEventNames(.evtlist,.namelist)
		s events=%events
		k tmp
		f i=1:1:$ll(events) {
			s evt=$li(events,i)
			s evtn=$get(namelist(evt))
			s:evtn tmp(evtn)=""
		}
		s (events,tmp)="" f  { s tmp=$o(tmp(tmp)) q:tmp=""  s events=events_$lb(tmp_") "_evtlist(tmp)) }
		w !!,"The following events are currently selected:  "
		w !,"   " f i=1:1:$ll(events) { i $x+$l($li(events,i))>77 { w !,"   " } elseif i>1 { w ", " } w $li(events,i) }
		w !!,"Enter a new set of events or return to leave unchanged."
		w !,"  (comma-separated numeric list and/or ranges; ? to display available events)"
retryevents
		k tmp s rc=##class(%Library.Prompt).GetArray("Events to trace:",.tmp,.evtlist,,,,
		                                     512+8+64+1024)
		q:(rc'=1)||'$ll(tmp)
		i 'custom {
			s sc=##class(%SYS.Trace).SetEvents(tmp)
		} else {
			s sc=##class(%SYS.Trace).ValidateEvents(tmp)
		}
		i ('sc) {
			d $system.Status.DisplayError(sc)
			g retryevents
		}
		s %events=tmp
	} catch {
		w !!,"Error: ",$ze
	}
	w !
}
AskStopAll() PRIVATE {
	s pids=##class(%SYS.Trace).PIDList()
	i '$ll(pids) { w !!,"No processes are being traced." q 1 }
	w !!,"PIDs traced:  " f i=1:1:$ll(pids) { i $x+$l($li(pids,i))>77 { w !,"   " } elseif i>1 { w ", " } w $li(pids,i) }
	k yn s rc=##class(%Library.Prompt).GetYesNo("Do you want to stop them all?",.yn,,8)
	q:(rc'=1)||('yn) 0
	s allok=1
	f i=1:1:$ll(pids) { 
		s sc=##class(%SYS.Trace).StopPID($li(pids,i))
		i ('sc) {
			w !,"Error stopping PID "_$li(pids,i)
			d $system.Status.DisplayError(sc)
			w allok=0
		}
	}
	w:allok !,"Done"
	q 1
}
Files(mode="",dir="") PRIVATE {
	try {
		i dir="" s dir=%dir
		i dir="" { w !!,"Trace directory not set" q }
		s rs=##class(%Library.ResultSet).%New("%File:FileSet")
		Set sc=rs.%Execute(dir,"iris"_"trace_*.txt") Throw:('sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc)
		if 'rs.%Next() {
			w !!,"No trace files found in ",dir
			q
		}
		s pids=##class(%SYS.Trace).PIDList()
		i mode="" {
			w !!,"Trace files in ",dir
			w !,?7,"PID [* if currently traced]",?55,"Date",?72,"Size"
		}
		do {
			s fname=$e(rs.Name,$l(dir)+1,*)
			s pid=+$p($p(fname,"_",2),".")
			s active=$listfind(pids,pid)
			i mode="d" {
				i 'active && '##class(%Library.File).Delete(rs.Name) {
					w !,"Failed to delete trace file ",rs.Name
				}
			} else {
				w !,$j(pid,10),$s(active:"*",1:" ")," (",fname,")",?40,$p(rs.DateCreated,"."),?60,$j(rs.Size,16)
			}
		} while rs.%Next()
	} catch err {
		w !,"Error listing trace files: ",err.DisplayString()
	}
}
GetEventNames(evtlist,namelist) PRIVATE {
	f i=1:1:56 {
		s t=$text(@("Flist+"_i_"^%SYS.MONLBL"))
		s evtlist(i)=$p(t,";",4)
		s desc=$case(i,0+1:"any global reference (including sets and kills)",
		               38+1:"routine loads *plus* tracing subroutine call & return",
		               37+1:"trace every routine line",
		               :$p(t,";",5))
		s evtlist(i,0)=": "_$s($l(evtlist(i))<12:$j("",12-$l(evtlist(i))),1:"")_desc
		s:$l(evtlist(i,0))<60 $e(evtlist(i,0),60)=" " 
		s namelist(evtlist(i))=i
	}
}
ChooseDirectory() PRIVATE {
	try {
retrydir
		s dir=%dir
		s rc=##class(%Library.Prompt).GetString("Directory: ",.dir,,,,8)
		if (rc'=1) return ""
		s sc=##class(%SYS.Trace).ValidateDirectory(dir)
		i ('sc) {
			d $system.Status.DisplayError(sc)
			g retrydir
		}
		s dir=##class(%Library.File).NormalizeDirectory(dir)
		return dir
	} catch(err) {
		d $system.Status.DisplayError(err.AsStatus())
		return ""
	}
}

TTYFREE^INT^1^67214,47331
TTYFREE ; TTY Hash Table Manipulation
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 Set tty=$ZU(40,2,48)
 f i=0:0 d q q:q=""  d @q
 q
q ;
 r !,"Terminal: ",t
 i t="" s q="" q
 i t="?" s q="list" q
 if ($zversion(1)=2) s q="remove" q
 else  s t=$zu(12,t),q="remove" q
 q
list ;
 New cs,i,chunkoff,endoff,entryoff,namlen,offword,pid,shmoff,ttyname
 Set cs=$$charsize^%Wprim(),shmoff=$zu(40,0,25)
zb
 For i=0:1:$ZU(40,0,66)-1 {
    Set chunkoff=$View(tty+(i*shmoff),-2,shmoff)
    If 'chunkoff Quit  
    Set offword=$View(chunkoff,-2,4)
    Set endoff=chunkoff+((offword#65536)*4)
    Set entryoff=chunkoff+$zu(40,0,25)
    While (entryoff < endoff) {
       Set pidptr=entryoff+$ZU(40,33,0)
       Set pid=$View(pidptr+$ZU(40,28,78),-2,4)
       if $ZBITGET($ZVERSION(0),40) {
	  s tid=$View(pidptr+$ZU(40,28,79),-2,4)
       } else {
          s tid=0
       }
       Set namlen=$View(entryoff+$ZU(40,33,1),-2,1)
       If cs=1 {
          Set ttyname=$View(entryoff+$ZU(40,33,3),-2,-(namlen-1))_$View(entryoff+$ZU(40,33,2),-2,-1)
       } else {
          Set ttyname=$View(entryoff+$ZU(40,33,3),-2,-namlen_"w")
       }
       Write:pid !,ttyname,?30," ",pid
       Write:tid " (thread id = ",tid,")"
       Set entrylen=0+$ZU(40,33,3)+(namlen*cs)-$Case(cs,1:1,:0)
       Set entryoff=entryoff+(((entrylen+shmoff-1)\shmoff)*shmoff)
    }
 }
 q
INT ;
 Set tty=$ZU(40,2,48)
 d rem q
remove ;
 d rem q:f
 w !,"Enter a terminal device name, or '?' to see a list of terminals."
 q
rem ;
 s f=$zu(109,0,t)
 q

VERSION^INT^1^67214,47331
VERSION ; Display system version
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 D INT W %V Q
INT s %V=$ZV q

WSMON^INT^1^67214,47331
WSMON	; Web Services monitoring utility
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	;
	; Menu based demo for calling Web Services for monitoring, see SYS.WSMon classes.
	; You start by entering the System name and IRIS Web Server port for a IRIS
	; instance. The utility will remember instances which have previously been accessed. 
	;
	; This should work from any type of OS (Windows, Unix, VMS) across the network to
	; any other type of OS. Note that firewalls may inhibit connections (recent versions
	; of Windows block this by default).
	;
	; This routine also incudes EVENTS^WSMON, which is used as a background job to monitor
	; and deliver Events if there are any "subscribers".
 	;  
	;
 /* MONEXT.INC */
	;
	;
	d MENU
 	q
 	;
MENU() PUBLIC {
 	s $zt="ERROR"
 	s Menu(1)="Monitor an instance"
 	s Menu(2)="Subscribe to Events"
 	s Menu(3)="Cancel Subscription"
 	s Menu(4)="Stop WS Events Monitor"
 	s Menu(5)="List Current Subscriptions"
 	f  {
 		s response=""
 		s mask=8+128+4
 		w #
		s status=##Class(%Library.Prompt).GetMenu("Option?",.response,.Menu,,mask)
 		i (+status=0)||(status=2)||(status=3)||(response="") q
 		i response=1 d monitor() Continue
 		i response=2 d subscribe() Continue
 		i response=3 d cancel() Continue
 		i response=4 d STOP Continue
 		i response=5 d sublist Continue
 	}
 	q status
ERROR	; handle errors
	s $zt=""
 	i $ze["<INTERRUPT>" q 0
 	ztrap $ze
 }
	;
	; Call Web Services to monitor a remote instance
	;
monitor()  {
	s server=$$select()
	q:server=""
	s system=$p(server,":",1),port=$p(server,":",2)
	s user=$p(server,":",3) i user]"" s pw=$list(user,2),user=$list(user,1)
 	;
 	; send request for system info
 	;
 	s client=##class(SYS.WSMon.Client).%New()
	s client.Location="http://"_server_"/csp/sys/SYS.WSMon.Service.cls"
	s client.Timeout=10
	i user]"" {
		s usertoken=##class(%SOAP.Security.UsernameToken).Create(user,pw)
		d client.SecurityOut.AddToken(usertoken)
	}
	s $zt="monerr"
	s sysref=client.GetSystem()
	s $zt=""
sys	;
	w #
	w !!,"Instance ",sysref.Name," on ",sysref.System
	w !,sysref.Version
	w !!,"Installed at ",sysref.Directory
	w !,"Config file: ",sysref.ConfigFile
	w !!,"Current Users: ",sysref.CurrentUsers,?29,"Routine Buffers: ",sysref.RoutineCache,?53,"Global Buffers: ",sysref.DatabaseCache
	w !,"Current Licenses Available: ",sysref.LicenseAvailable,?40,"Used: ",sysref.LicenseUsed,?55,"Highest Used: ",sysref.LicenseHigh
	;
	s Menu(1)="Get Global Stats"
 	s Menu(2)="Get Routine stats"
 	s Menu(3)="Get Database listing"
 	s Menu(4)="Get Buffer stats"
 	s Menu(5)="Get Write Daemon stats"
 	s Menu(6)="Get Resource Seize stats"
 	s Menu(7)="Get Process list by Commands"
 	s Menu(8)="Get Process list by GloRefs"
 	s Menu(9)="Get System Dashboard"
 	;
 	s response=""
 	s mask=8+128+4
	s status=##Class(%Library.Prompt).GetMenu("Option?",.response,.Menu,,mask)
 	i (+status=0)||(status=2)||(status=3)||(response="") q
 	i response=1 d getglo
 	i response=2 d getrou
 	i response=3 d getdb
 	i response=4 d getbuff
 	i response=5 d getwd
 	i response=6 d getressz
 	i response=7 d getproc("COMMANDS")
 	i response=8 d getproc("GLOREFS")
 	i response=9 d getdash
 	;
 	s status=##Class(%Library.Prompt).GetString("Press RETURN to continue.",,0,,,8+4)
 	g sys
 	;
monerr	;
	s $ze=""
	w !!,"Error in contacting ",system," at port ",port,"."
 	s status=##Class(%Library.Prompt).GetString("Press RETURN to continue.",,0,,,8+4)
	q
	;
getglo	; get global stats
	s ref=client.GetGlobal() s c1=20,c2=40,c3=60
	w #
	w !,"Instance ",sysref.Name," on ",system,!!
	w !,"                    Local               Remote              Total"
	w !,"                    -----               ------              -----"
	w !,"Global Refs",?c1,ref.RefLocal,?c2,ref.RefRemote,?c3,ref.RefLocal+ref.RefRemote
	w !,"Global Updates",?c1,ref.RefUpdateLocal,?c2,ref.RefUpdateRemote,?c3,ref.RefUpdateLocal+ref.RefUpdateRemote
	w !,"Journal Entries",?c1,ref.JrnEntries
	w !,"Journal Blocks",?c1,ref.JrnBlocks w !
	w !!,"Logical Reads: ",ref.LogicalBlocks,"    Physical Reads: ",ref.PhysBlockReads,"    Block Writes: ",ref.PhysBlockWrites
	w !!,"Global Updaters: ",ref.UpdateCnt,"   Update Lock: ",ref.UpdateLock,"   WD Wake: ",ref.WDWake,"   WD Queue: ",ref.WDQueueSize
	w !!
	q
getrou	; get routine stats
	s ref=client.GetRoutine()
	w #
	w !,"Instance ",sysref.Name," on ",system,!!
	w !,"Commands: ",ref.RtnLines
	w !!,"Routine Calls (Local): ",ref.RtnCallsLocal,?35,"  Routine Calls (Remote): ",ref.RtnCallsRemote
	w !!,"Routine Fetch (Local): ",ref.RtnFetchLocal,?35,"  Routine Fetch (Remote): ",ref.RtnFetchRemote
	w !!
	q
getdash	; get system Dashboard
	s ref=client.GetDashboard() s c=12
	w #
	w !,"Instance ",sysref.Name," on ",system,!!
	w ! i ref]"" d $System.OBJ.Dump(ref)
	q
getdb	; get database info
	w # s c1=34,c2=50,c3=64
	w "Instance ",sysref.Name," on ",system,!
	w !,"Name/Directory                    Size           Freespace       Status"
	w !,"--------------                    ----           ---------       ------"
	;
	set dataset=client.EnumDatabase()
	while (dataset.Next(.status)) {
		w !,dataset.Get("Name")
		w ?c1,dataset.Get("SizeAllocated"),?c2,dataset.Get("FreeSpace")
		if dataset.Get("Mounted")=1 {
			w ?c3,"Mounted/" w $s(dataset.Get("ReadOnly")=1:"RO",1:"RW")
		} else {
			w ?c3,"Dismounted"
		}
		w !,dataset.Get("Directory")
	}
	i 'status w !,$$DisplayError^%apiOBJ(status)
	q
getbuff	; get buffer info
	w # s c=11
	w !,"Instance ",sysref.Name," on ",system,!!
	w !,"Size       NumSize   LRUqueue  Interactive  Available  WrtQueSz   LastWrite"
	w !,"----       -------   --------  -----------  ---------  --------   ---------"
	set dataset=client.EnumBuffer()
	while (dataset.Next(.status)) {
		w !,dataset.Get("Size"),?c,dataset.Get("NumSize"),?c*2,dataset.Get("BatchQ")
		w ?c*3,dataset.Get("Interact"),?c*4,dataset.Get("Avail")
		w ?c*5,dataset.Get("WrtQSz"),?c*6,dataset.Get("WrtSz")
	}
	i 'status w !,$$DisplayError^%apiOBJ(status)
	w !
	q
getwd	; get write daemon info
	w # s c=10,index=0
	w !,"Instance ",sysref.Name," on ",system,!!
	w !,"WD#       Blocks    TotBlk    Cycles  Blks/Cycle  Wake      CycleTime"
	w !,"---       ------    ------    ------  ----------  ----      ---------"
	set dataset=client.EnumWriteDaemon()
	while (dataset.Next(.status)) {
		s index=index+1
		w !,index,". ",?c,dataset.Get("CurBlk"),?c*2,dataset.Get("TotBlk")
		w ?c*3,dataset.Get("Cycles"),?c*4,dataset.Get("CycleBlk")
		w ?c*5,dataset.Get("Wake"),?c*6,dataset.Get("CycleTime")
	}
	i 'status w !,$$DisplayError^%apiOBJ(status)
	w !
	q
getressz	; get resource seize stats
	w # s c=10,index=0
	w !,"Instance ",sysref.Name," on ",system,!!
	w !,"Res Name            Seize     Nseize    Aseize    Bseize    BusySets "
	w !,"--------            -----     ------    ------    ------    ---------"
	set dataset=client.EnumResource()
	while (dataset.Next(.status)) {
		s index=index+1
		w !,dataset.Get("Name"),?c*2,dataset.Get("Seize")
		w ?c*3,dataset.Get("Nseize"),?c*4,dataset.Get("Aseize")
		w ?c*5,dataset.Get("Bseize"),?c*6,dataset.Get("BusySets")
	}
	i 'status w !,$$DisplayError^%apiOBJ(status)
	w !
	q
getproc(sort)	; get top process list
	w # s c1=9,c2=22,c3=34,c4=44,c5=58,c6=67,c7=75
	w "Instance ",sysref.Name," on ",system,!
	w !,"Process  UserName     Device      Namespace   Routine     Commands GloRefs State"
	w !,"-------  --------     ------      ---------   -------     -------- ------- -----"
	;
	set dataset=client.EnumProcess(sort,10)
	while (dataset.Next(.status)) {
		w !,dataset.Get("Process")
		w ?c1,dataset.Get("UserName"),?c2,dataset.Get("CurrentDevice")
		w ?c3,dataset.Get("Namespace"),?c4,dataset.Get("Routine")
		w:dataset.Get("Process")'=0 !
		w ?c5,dataset.Get("CommandsExecuted"),?c6,dataset.Get("GlobalReferences")
		w ?c7,dataset.Get("State")
	}
	i 'status w !,$$DisplayError^%apiOBJ(status)
	q
}
	; subscribe to Events
subscribe() {
	s server=$$select()
	q:server=""
	s system=$p(server,":",1),port=$p(server,":",2)
	s user=$p(server,":",3) i user]"" s pw=$list(user,2),user=$list(user,1)
 	;
	w !!,"Subscribing to event ..."
	s client=##class(SYS.WSMon.Client).%New()
	s client.Location="http://"_server_"/csp/sys/SYS.WSMon.Service.cls"
	s Status=##Class(%Library.RoutineMgr).GetWebServerPort(.Port,.Server,.URLPrefix,.URL)
	s location=URL_"/csp/sys/SYS.WSMon.EventSink.cls"
	i user]"" {
		s usertoken=##class(%SOAP.Security.UsernameToken).Create(user,pw)
		d client.SecurityOut.AddToken(usertoken)
	}
	set resp=client.EventSubscribe(location)
	i resp]"" w !!,"Subscription granted as ",resp,!
	e  w !!,"Subscription failed.",!
	; remember the subscription ID
	s i=$i(^IRIS.Temp.WSMonSubscriptions)
	s ^IRIS.Temp.WSMonSubscriptions(system,port,i)=resp
	s status=##Class(%Library.Prompt).GetString("Press RETURN to continue.",,0,,,8+4)
	k
	q
}
	; Cancel subscription
cancel() {
	s server=$$select()
	q:server=""
	s system=$p(server,":",1),port=$p(server,":",2)
	s user=$p(server,":",3) i user]"" s pw=$list(user,2),user=$list(user,1)
 	;
	s client=##class(SYS.WSMon.Client).%New()
	s client.Location="http://"_server_"/csp/sys/SYS.WSMon.Service.cls"
	i user]"" {
		s usertoken=##class(%SOAP.Security.UsernameToken).Create(user,pw)
		d client.SecurityOut.AddToken(usertoken)
	}
	s id=$o(^IRIS.Temp.WSMonSubscriptions(system,port,""))
	if id="" {
		w !!,"No subscription to ",system,":",port," found.",!
	} else  {
		s sub=^IRIS.Temp.WSMonSubscriptions(system,port,id)
		w !!,"Canceling subscription ",sub
		set resp=client.EventCancel(sub)
		i resp w !!,"Subscription cancelled.",!
		e  w !!,"Subscription cancel failed.",!
		k ^IRIS.Temp.WSMonSubscriptions(system,port,id)
	}
	s status=##Class(%Library.Prompt).GetString("Press RETURN to continue.",,0,,,8+4)
	k
	q
}
	;
	; Select an instance - return system:port:$list(user,password)
	;
	; New selections are added to list at 
	;   ^SYS("MONITOR","WSMON","SERVERS",system,port)=instance_name;system_name
	;
	; NOTE: we get the system name from the system, VMS may have to use a gateway
	;
select() {
	s n=0
	; create a list of previous choices if there are some
	i $o(^SYS("MONITOR","WSMON","SERVERS",""))]"" {
		s (system,port)=""
		f  {
			s system=$o(^SYS("MONITOR","WSMON","SERVERS",system))
			q:system=""
			f  {
				s port=$o(^SYS("MONITOR","WSMON","SERVERS",system,port))
				q:port=""
				s n=n+1,instance=^SYS("MONITOR","WSMON","SERVERS",system,port)
				s list(n)=system_":"_port
				s nm=$p(instance,";",1)_" on "_$p(instance,";",2)
				s Menu(n)=nm_$e("                                       ",1,40-$l(nm))_"("_system_":"_port_")"
			}
		}
	}
	; handle  menu
	if n {
		s n=n+1,Menu(n)="Enter new system and port number"
		s response=n
		s mask=8+128+4
		s status=##Class(%Library.Prompt).GetMenu("Option?",.response,.Menu,,mask)
		i (+status=0)||(status=2)||(status=3)||(response="") q ""
		i response<n q list(response)_":"_$$user()
	}
	w !
 	s prompt="System:"
 	s response=$g(^%SYS("WebServer","Name"))
 	i response="" s response=$zu(110)
 	s help(1)="Enter the system name of the IRIS instance to connect to."
 	s status=##Class(%Library.Prompt).GetString(prompt,.response,0,,.help,8+4) k help
 	i (status=2)||(+status=0)||(status=3)||(response="") q ""
 	s system=$zcvt(response,"U")
	;
 	s prompt="Port:"
 	s response=$g(^%SYS("WebServer","Port"),57772),help(1)="Enter the IRIS Web Server Port number."
 	s status=##Class(%Library.Prompt).GetString(prompt,.response,0,,.help,8+4) k help
 	i (status=2)||(+status=0)||(status=3)||(response="") q ""
 	s port=+response
 	;
 	s user=$$user(),pw=""
 	i user]"" s pw=$list(user,2),user=$list(user,1)
 	s client=##class(SYS.WSMon.Client).%New()
	s client.Location="http://"_system_":"_port_"/csp/sys/SYS.WSMon.Service.cls"
	s client.Timeout=10
	i user]"" {
		s usertoken=##class(%SOAP.Security.UsernameToken).Create(user,pw)
		d client.SecurityOut.AddToken(usertoken)
	}
	s $zt="selerr"
	s sysref=client.GetSystem()
	s $zt=""
	s ^SYS("MONITOR","WSMON","SERVERS",system,port)=sysref.Name_";"_sysref.System
	q system_":"_port_":"_$s(user]"":$lb(user,pw),1:"")
	;
selerr ; handle connection error
	s $ze=""
	w !!,"Error in contacting ",system," at port ",port,"."
	d $System.OBJ.DisplayError(%objlasterror)
 	s status=##Class(%Library.Prompt).GetString("Press RETURN to continue.",,0,,,8+4)
	q ""
}
	;
	; Provide a username/password for a server - return $list(user,pass)
	;
user()
	w !
 	s prompt="User:",response="",help(1)="Enter a user name for remote access."
 	s status=##Class(%Library.Prompt).GetString(prompt,.response,0,,.help,8+4) k help
 	i (status=2)||(+status=0)||(status=3)||(response="") q ""
 	s user=response
 	i user="" q ""
	;
 	s prompt="Password:",response="",help(1)="Enter a user name for remote access."
 	;w prompt u 0:"S" r response
 	u $io:(:"S") s status=##Class(%Library.Prompt).GetString(prompt,.response,0,,.help,8+4) u $io:(:"-S") k help
 	i (status=2)||(+status=0)||(status=3)||(response="") q ""
 	s pw=response
 	;
    q $lb(user,pw)
    ;
event	; test sending an event
	s defsys=$g(^%SYS("WebServer","Name"))
	i defsys="" s defsys="localhost"
	w !,"System: <",defsys,"> " r system s:system="" system="localhost"
	s defport=$g(^%SYS("WebServer","Port"),57772)
	w !,"Port: <",defport,"> " r port s:port="" port=defport
	s client=##class(SYS.WSMon.Client).%New()
	s client.Location="http://"_system_":"_port_"/csp/sys/SYS.WSMon.EventSink.cls"
	s event=##class(SYS.WSMon.wsEvent).%New()
	s err=$r(16-1)+1,trap=$t(traplist+err^SNMP)
	s event.System=$zu(110),event.Instance=$p($zu(86),"*",2)
	s event.Name=$zstrip($p(trap,";",4),"*W"),event.Severity=+$p(trap,";",5)
	s event.SnmpId=err,event.AdditionalInfo=$tr($p(trap,";",6),"'","*")
	w !,"Sending ...",!! d $System.OBJ.Dump(event)
	set resp=client.CacheEventSink(event)
	w !!,"Response = ",resp,!
	k
	q
	;
EVENTS	; Entry point for JOB to signal events
	;
	s $zt="evterr^WSMON"
	l +^SYS("MONITOR","WSMON"):5 e  s ^SYS("MONITOR","WSMON","ERROR")="Unable  to LOCK - "_$H q
	s ^SYS("MONITOR","WSMON")="RUN"
	s to=+$g(^SYS("MONITOR","WSMON","EVENTLOOP"),10) ; loop time in seconds
	d $zu(9,"","Events monitor for Web Services (WSMON) started.",(0>0),0)
	s trap=$zu(190,1,1,4)	; enable queue
evtloop	; job loop to check for alerts
	i $g(^SYS("MONITOR","WSMON"))="STOP" d $zu(9,"","Web Services Monitor terminated.",(1>0),1) g evtexit
	s trap=$zu(190,1,2,4) ; get next entry on queue
	i trap=0 h to g evtloop
	s tn=$p(trap,",") i (tn<1)!(tn>16),tn'=100 h to g evtloop
	;
	s aux=$p(trap,",",2,$l(trap,","))
	; Get trap name and message
	if tn=100 {
		; emulate 'traplist' - insert trap name and severity
		s text=";;100;cacheAppAlert;"_$p(aux,",")
		s msg=$p(aux,",",2,$l(aux,","))
	} else {
		s text=$t(traplist+tn^SNMP),msg=$p(text,";",6)
	}
	; add database index for some DB traps
	i tn>2,tn<7,aux]"" {
		s sfn=+$p(aux,",",1),index=$$dbtab^SNMP("INDEX",sfn)
		s dbname=$p(index,",",2),index=$p(index,",")
		s msg=msg_", database "_dbname
		; add database read status for cacheDBStatusChange
		i tn=5 s msg=msg_", status is "_$p($$dbtab^SNMP("Status",index),"/",2)
		i tn=6 s msg=msg_", error is "_$zu(96,1,+$p(aux,",",2))
  	}
  	; add message for messages.log trap
  	i tn=14 s msg=msg_" - "_$p(aux,",",1)
  	;
  	; Build object to send
	s event=##class(SYS.WSMon.wsEvent).%New()
	s event.System=$zu(110),event.Instance=$p($zu(86),"*",2)
	s event.Name=$zstrip($p(text,";",4),"*W"),event.Severity=+$p(text,";",5)
	s event.SnmpId=+$p(text,";",3),event.AdditionalInfo=msg
	;
	; Now send it to all subscribers
	s id=""
evtsend ;
	d $System.OBJ.Dump(event)
	f  {
		s id=$o(^IRIS.Temp.WSMonSubscriber(id)) q:id=""
		s location=^IRIS.Temp.WSMonSubscriber(id)
		s client=##class(SYS.WSMon.Client).%New()
		s client.Location=location
		w !,"Send to ",location
		S $zt="senderr^WSMON"
		s resp=client.CacheEventSink(event)
		s $zt="evterr^WSMON"
		i 'resp d $zu(9,"","No response to Web Services Event from "_location,(1>0),1)
	}
	;
	g evtloop
senderr	; error in sending Event
	s $zt="evterr^WSMON"
	d $zu(9,"","Error sending Web Services Event to "_$g(location)_" - "_$ze,(1>0),1)
	i $g(%objlasterror)]"" s ^SYS("MONITOR","WSMON","objlasterror")=$g(%objlasterror)
	;i $g(location)]"" {
	;	d $$$LOGMSG("Removing subscriber at "_$g(location),0,1)
	;	i $g(id)]"" k ^IRIS.Temp.WSMonSubscriber(id)
	;}
	g evtsend ; continue with other subscribers 
evterr	; unexpected error trap 
	s $zt=""
	d $zu(9,"","Unexpected error in Web Services Event Monitor -"_$ze,(1>0),1)
evtexit
	s trap=$zu(190,1,0,4) ; disable queue for WSMon 
	l -^SYS("MONITOR","WSMON")
	q
	;
STOP	; stop background job
	s ^SYS("MONITOR","WSMON")="STOP"
	q
sublist	; list current subscribers
	n num,fnd,i,sys,port
	s num=+$g(^IRIS.Temp.WSMonSubscriber),fnd=0
	w !!,"Subscribers for Events on this system ...",!
	f i=1:1:num i $d(^IRIS.Temp.WSMonSubscriber(i)) w !,i,". ",^IRIS.Temp.WSMonSubscriber(i) s fnd=1
	i 'fnd w !,"No subscribers found.",!
	w !!,"Subscriptions to Events on other systems ...",!
	s (sys,port,i)="",fnd=0
	f  {
		s sys=$o(^IRIS.Temp.WSMonSubscriptions(sys))
		q:sys=""
		f  {
			s port=$o(^IRIS.Temp.WSMonSubscriptions(sys,port))
			q:port=""
			f  {
				s i=$o(^IRIS.Temp.WSMonSubscriptions(sys,port,i))
				q:i=""
				s fnd = 1 w !,sys,":",port, " = ",^IRIS.Temp.WSMonSubscriptions(sys,port,i)
			}
		}
	}
	i 'fnd w !,"No subscriptions found.",!
	w !
 	s status=##Class(%Library.Prompt).GetString("Press RETURN to continue.",,0,,,8+4)
	q
	;
	; Test WS-Management client
	; action = "get", "enum", "pull", "release", "enum+", "subscribe", "renew", "unsubscribe"
	; resource = "database", "system", "global", "disk", "routine", "wd"
	; selector = index for "get" with multiple instances (e.g. "database" or "wd")
	;            or may be used as EnumerationContext:MaxElements for "enum+", "pull" and "release"
	;			 or may be Subscriber index for Renew / Unsubscribe / Notify
	; 
	; Prints out resource data (or error)
	; Returns status or EnumerationContext
	;
wsman(action, resource, selector) PUBLIC {
	s system=$zu(110),port=8080,response=1
	;s system=$zu(110),port=$g(^%SYS("WebServer","Port"),57772)
 	s client=##class(SYS.WSMon.wsman.Client).%New()
	s client.Location="http://"_system_":"_port_"/csp/sys/SYS.WSMon.wsman.Service.cls"
	s client.Timeout=10
	s class=$case(resource,
			"system":"SYS.WSMon.wsSystem",
			"database":"SYS.WSMon.wsDatabase",
			"global":"SYS.Stats.Global",
			"buffer":"SYS.Stats.Buffer",
			"disk":"SYS.Stats.Disk",
			"ecpapp":"SYS.Stats.ECPAppSvr",
			"ecpsvr":"SYS.Stats.ECPDataSvr",
			"routine":"SYS.Stats.Routine",
			"wd":"SYS.Stats.WriteDaemon",
			"resource":"SYS.Stats.Resource",
			"event":"SYS.WSMon.wsEvent",
			:"")
	i class="" w "Unknown resource ",resource q 0
	;
	s client.Resource="http://intersystems.com/cache/wsman/1/resource/"_class
	;
	if action="get" {
		; this works for 'database' and 'wd', shouldn't be a selector otherwise
		if $g(selector)]"" d client.Selector.SetAt(selector,"ID")
		s ref=client.TransferGet()
		i ref]"" d $System.OBJ.Dump(ref)
		q 1
	}
	if action="enum" {
		s enum=##class(SYS.WSMon.wsen.Enumerate).%New()
		s enum.Expires=""
		s client.RequestTotalItemsCountEstimate=1
		s ref=client.Enumerate(enum)
		i ref]"" d $System.OBJ.Dump(ref)
		q ref.EnumerationContext
	}
	if action="pull" {
		s pull=##class(SYS.WSMon.wsen.Pull).%New()
		s pull.EnumerationContext=+selector
		s pull.MaxElements=$p(selector,":",2)
		s ref=client.Pull(pull)
		i ref]"" d $System.OBJ.Dump(ref)
		q ref.EnumerationContext
	}
	if action="release" {
		s rel=##class(SYS.WSMon.wsen.Release).%New()
		s rel.EnumerationContext=+selector
		s ref=client.Release(rel)
		i ref]"" d $System.OBJ.Dump(ref)
		q ref.EnumerationContext
	}
	if action="enum+" {
		s enum=##class(SYS.WSMon.wsen.Enumerate).%New()
		s enum.Expires=""
		s enum.OptimizeEnumeration=$c(0)
		s enum.MaxElements=$p(selector,":",2)
		s ref=client.Enumerate(enum)
		i ref]"" d $System.OBJ.Dump(ref)
		q ref.EnumerationContext
	}
	if action="subscribe" {
		s sub=##class(SYS.WSMon.wse.Subscribe).%New()
		s sub.Expires=$c(0)
		s notify=##class(SYS.WSMon.wse.EndpointReference).%New()
		; send to TcpTrace for now
		s notify.Address="http://"_$zu(110)_":8080/csp/sys/SYS.WSMon.wsman.Service.cls"
		; build an Identifier for the ReferenceProperties
		s xmlns=##class(%XML.Namespaces).%New()
		s sc=xmlns.AddNamespace("http://www.intersystems.com/cache/wsmon/1/xsd","wsmon")
		s id=##class(%SOAP.IdHeader).%New(),sc=id.GetId()
		s myrefprop=##class(SYS.WSMon.wse.MyRefProp).%New(),myrefprop.value=id.Id
		s sc=myrefprop.XMLExportToString(.refprop,"","",xmlns)
		s notify.ReferenceProperties=refprop
		s deliver=##class(SYS.WSMon.wse.Delivery).%New()
		s deliver.NotifyTo=notify
		s sub.Delivery=deliver
		s ref=client.Subscribe(sub)
		i ref]"" d $System.OBJ.Dump(ref)
		zw ^IRIS.Temp.WSMonSubscriber
		q 1
	}
	if action="unsubscribe" {
		; 'selector' is ID of subscription in ^IRIS.Temp.WSMonSubscriber(ID)
		s client.Identifier=$g(^IRIS.Temp.WSMonSubscriber(selector,"Identifier"))
		s sub=##class(SYS.WSMon.wse.Unsubscribe).%New()
		s ref=client.Unsubscribe(sub)
		i ref]"" d $System.OBJ.Dump(ref)
		zw ^IRIS.Temp.WSMonSubscriber
		q 1
	}
	if action="renew" {
		; 'selector' is ID of subscription in ^IRIS.Temp.WSMonSubscriber(ID)
		s client.Identifier=$g(^IRIS.Temp.WSMonSubscriber(selector,"Identifier"))
		s sub=##class(SYS.WSMon.wse.Renew).%New()
		s sub.Expires="2004-06-26T12:00:00.000-00:00"
		s ref=client.Renew(sub)
		i ref]"" d $System.OBJ.Dump(ref)
		zw ^IRIS.Temp.WSMonSubscriber
		q 1
	}
	if action="notify" {
		; Build object to send
		s event=##class(SYS.WSMon.wsEvent).%New()
		s event.System=$zu(110),event.Instance=$p($zu(86),"*",2)
		s event.Name="cacheTest",event.Severity=3
		s event.SnmpId=1,event.AdditionalInfo="This is a test"
		;
		s location=$g(^IRIS.Temp.WSMonSubscriber(selector))
		i location="" w !,"Subscription ",selector," not found." q 1
		w !,"Send to ",location
		s client.Location=location
		s client.ReferenceProperties=$g(^IRIS.Temp.WSMonSubscriber(selector,"RefProp"))
		d client.Notification(event)
		zw ^IRIS.Temp.WSMonEvent
		q 1
	}
	;
	w !,"Unknown action ",action
	q 0
}

Wcomm^INT^1^67214,47331
Wcomm ; Communication program
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
JOB(rtn,P0,P1) ; 
	Set $zt="^%ET",CDAlive=1
	Set cmd="JOB "_rtn
	Set return=$$IjcOpen^%Wprima("VServer")
	If +return=0 q
	Set return=$$IjcOpen^%Wprima("Utility")
	If +return=0 q
	;
	Xecute cmd
	;
Loop ;
	Set EmptyBuffers=0,msg=""
	Set return=$$IjcRead^%Wprima(.msg,"Utility")
	If return=2 {
		If CDAlive {
			Set return=$$IjcMsg^%Wprima(msg,"VServer")
			If return="CANCEL" {
				If $$IjcWrite^%Wprima("CA","Utility")
			}
		}
	} ElseIf return=1 { If $i(EmptyBuffers) } Else { Goto Exit }
	If $e(msg,1,2)="JS" Goto Exit
	If 'CDAlive Hang:EmptyBuffers=2 1 Goto Loop
	Set msg="",return=$$IjcRead^%Wprima(.msg,"VServer")
	If return=2 {
		If msg'="DS" Set x=$$IjcWrite^%Wprima(msg,"Utility")
		Else  Set CDAlive=0
	} ElseIf return=1 { If $i(EmptyBuffers)
	} Else { /* Read error from CD Server */
		Set CDAlive=0
	}
	Hang:EmptyBuffers=2 1 Goto Loop
	;
Exit ;
	If $$IjcClose^%Wprima("VServer"),$$IjcClose^%Wprima("Utility")
	Quit

Wpfiles^INT^1^67214,47331
Wpfiles ;File selector functions
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
maskincl(mask,item,ext) New e,i,include,m,m1,m2
 Set include=0,ext=$ZCVT($g(ext,""),"U")
 For i=1:1 Set m=$p(mask,";",i),e="" Quit:m=""  Do:m'["'"  Quit:include
 . Set:m["." m=$$ParseRoutineName^%R(m,.e),e=$s(e="*":"",e="SRC":".INC.MAC.INT.BAS",e="":"",1:"."_e)
 . If m["*" Do  Quit
 . . Set m=$p(m,"*")
 . . If m=$e(item,1,$l(m)),(e=""!(e[ext)) Set include=1 Quit
 . If m[":" Do  Quit
 . . Set m1=$p(m,":"),m2=$p(m,":",2)
 . . If m1=$e(item,1,$l(m1))!(item]m1) Do
 . . . If m2=$e(item,1,$l(m2))!(m2]item) Do
 . . . . Set:e=""!(e[ext) include=1
 . If m=item,(e=""!(e[ext)) Set include=1 Quit
 If include,mask["'" For i=1:1 Set m=$p(mask,";",i),e="" Quit:m=""  Do:m["'"  Quit:'include
 . Set m=$e(m,2,*)
 . Set:m["." m=$$ParseRoutineName^%R(m,.e),e=$s(e="*":"",e="SRC":".INC.MAC.INT.BAS",e="":"",1:"."_e)
 . If m["*" Do  Quit
 . . Set m=$p(m,"*")
 . . If m=$e(item,1,$l(m)),e=""!(e[ext) Set include=0
 . If m[":" Do  Quit
 . . Set m1=$p(m,":"),m2=$p(m,":",2)
 . . If m1=$e(item,1,$l(m1))!(item]m1) Do
 . . . If m2=$e(item,1,$l(m2))!(m2]item) Do
 . . . . Set:e=""!(e[ext) include=0 ; SJ bug fix
 . If m=item,(e=""!(e[ext)) Set include=0 Quit
 Quit include
 Quit
GUIdir(dir,mask,dirstr,files,curdir,drive) New (%UI,dir,mask,dirstr,files,curdir,drive)
 Set $zt="GUIdirErr",$ze=""
 Set guiDirSep=$s(($zversion(1)=2):"\",($zversion(1)=3):"/")
 If ($zversion(1)=3) Do
 . Set drive="",dirstr=0_$c(19,94,1)_guiDirSep,dirs=$p(dir,guiDirSep,2,9999)
 Else  Do  ; $$$guiWIN
 . Set drive=$p(dir,":"),dirstr=0_$c(19,94,1)_drive_":"_guiDirSep,dirs=$p(dir,":\",2)
 Set:dirs="" dirs=$c(22,35,1)_guiDirSep ; Special case for root
 For i=1:1 Set x=$p(dirs,guiDirSep,i) Quit:x=""  Do
 . Set:x=$c(22,35,1) x="" Set:x'="" dirstr=dirstr_$c(22,35,1)_i_$c(19,94,1)_x
 . If $p(dirs,guiDirSep,i+1)="" Do
 . . Set xx=$p(dir,guiDirSep,1,i+1)
 . . If ($zversion(1)=2)!(($zversion(1)=3)) Do
 . . . If x'="",xx'=guiDirSep Set xx=xx_guiDirSep
 . . Set y=$$dir(xx,"",$g(mask)),files=$p(y,$c(19,94,1),3),y=$p(y,$c(19,94,1),2) ; list of sub_directories
 . . If files'="" Set files=$$GUIfile("",$g(mask),files) ; List of files
 . . Set level=$s(x="":i,1:i+1)
 . . For j=1:1 Set z=$p(y,$c(22,35,1),j) Quit:z=""  Do
 . . . Set dirstr=dirstr_$c(22,35,1)_level_$c(19,94,1)_z ; Individual directory 
 Set curdir=dir
 If '($zversion(1)=3) Set drive=drive_":"
 Quit 1
GUIdirErr Quit 0_$c(22,35,1)_"Unable to fetch directory information for "_$g(dir)_". "_$s($ZE'="":$c(13,10,10)_"$ze="_$ZE,1:"")
GUIfile(dir,mask,files) New (%UI,dir,mask,files)
 Set return="" Set mask=$ZCVT(mask,"U") Quit:mask="" ""
 If mask="*"!(mask="*.*") Set msk=".E"
 Else  Do
 . Set mask1=$p(mask,"."),mask2=$p($p(mask,".",2),";")
 . Set mask1=$s(mask1="*":".E",mask1="":"",mask1["*":"1"""_($p(mask1,"*")_""".E"),1:"1"""_mask1_"""")
 . Set mask2=$s(mask2="*":".E",mask2="":".E",mask2["*":"1"""_($p(mask2,"*")_""".E"),1:"1"""_mask2_"""")
 . Set msk=mask1_"1""."""_mask2
 Set:$g(files)="" files=$p($$dir(dir,"",mask),$c(19,94,1),3)
 For i=1:1 Set x=$p(files,$c(22,35,1),i) Quit:x=""  Set:$ZCVT(x,"U")?@msk return=return_x_$c(22,35,1)
 Quit return
files(dir,masks,dirs,files,detail) New (%UI,dir,masks,dirs,files,detail)
 Set $zt="filesErr",$ze=""
 Set (dirs,files)="",detail=$g(detail,0)
 For imask=1:1 Set mask=$p(masks,";",imask) Quit:mask=""  Do
 . Set mask=$ZCVT(mask,"U") Quit:mask="" ""
 . If mask="*"!(mask="*.*") Set msk=".E"
 . Else  Do
 . . Set mask1=$p(mask,"."),mask2=$p($p(mask,".",2),";")
 . . Set mask1=$s(mask1="*":".E",mask1="":"",mask1["*":"1"""_($p(mask1,"*")_""".E"),1:"1"""_mask1_"""")
 . . Set mask2=$s(mask2="*":".E",mask2="":".E",mask2["*":"1"""_($p(mask2,"*")_""".E"),1:"1"""_mask2_"""")
 . . Set msk=mask1_"1""."""_mask2
 . Set list=$$dir(dir,"",mask),dlist=$p(list,$c(19,94,1),2),flist=$p(list,$c(19,94,1),3)
 . ;concatenate subdirecties info into 'dirs' string
 . If imask=1 Do
 . . For i=1:1 Set x=$p(dlist,$c(22,35,1),i) Quit:x=""  Do
 . . . If detail Do
 . . . . Set d=dir_x,modzh=$zu(140,2,d)
 . . . . Set mod=$zdate($p(modzh,",",1),3)_" "_$ztime($p(modzh,",",2),1)
 . . . . Set rec=x_$c(19,94,1)_$c(19,94,1)_mod_$c(19,94,1)_$zu(140,7,d)
 . . . . Set dirs=dirs_rec_$c(22,35,1)
 . . . Else  Set dirs=dirs_x_$c(22,35,1)
 . ;get files into array
 . For i=1:1 Set x=$p(flist,$c(22,35,1),i) Quit:x=""  Do:$ZCVT(x,"U")?@msk 
 . . If detail Do
 . . . Set f=dir_x,modzh=$zu(140,2,f)
 . . . Set mod=$zdate($p(modzh,",",1),3)_" "_$ztime($p(modzh,",",2),1)
 . . . Set rec=x_$c(19,94,1)_$zu(140,1,f)_$c(19,94,1)_mod_$c(19,94,1)_$zu(140,7,f)
 . . . Set f(rec)=""
 . . Else  Set f(x)=""
 ;concatenate files info into 'files' string
 Set x="" For  Set x=$o(f(x)) Quit:x=""  Set files=files_x_$c(22,35,1)
 Quit 1
filesErr Quit 0_$c(22,35,1)_"Unable to fetch directory information for "_$g(dir)_". "_$s($ZE'="":$c(13,10,10)_"$ze="_$ZE,1:"")
dir(dir,system,mask) New (%UI,dir,system,mask)
 Set subdir="",files="",mask=$g(mask)
 If ($zversion(1)=2) Do  Quit return
 . Set UpFlag=0,d=dir_"*.*",%="",dl=$l(dir)+1
 . For i=1:1 Set z=$zse(d) Quit:z=""  Do
 . . Set d="",z=$e(z,dl,*) Quit:z=""
 . . If z="." Set UpFlag=1,z=$zse("") Quit  ; Skip root ancestors
 . . Set x=$zu(12,dir_z,2) ; Canonize name to see if its a subdirectory
 . . If $e(x,$l(x))="\" Set subdir($ZCVT(z,"U"))=z ;subdirectory name
 . . Else  Set files($ZCVT(z,"U"))=z ;filename
 . For  Set %=$o(subdir(%)) Quit:%=""  Set subdir=$s(subdir="":"",1:subdir_$c(22,35,1))_subdir(%) Quit:$l(subdir)>32000
 . For  Set %=$o(files(%)) Quit:%=""  Set files=$s(files="":"",1:files_$c(22,35,1))_files(%) Quit:$l(files)>32000
 . Set return=UpFlag_$c(19,94,1)_subdir_$c(19,94,1)_files
 If ($zversion(1)=3) Do  Quit return
 . Set UpFlag=0,d=dir_"*",%=""
 . For i=1:1 Set z=$zse(d) Quit:z=""  Do
 . . Set d="",z=$p(z,dir,2) Quit:z=""
 . . Set x=$zu(12,dir_z,2) ; Canonize name to see if its a subdirectory
 . . If $e(x,$l(x))="/" Set subdir($ZCVT(z,"U"))=z ;subdirectory name
 . . Else  Set files($ZCVT(z,"U"))=z ;filename
 . For  Set %=$o(subdir(%)) Quit:%=""  Set subdir=$s(subdir="":"",1:subdir_$c(22,35,1))_subdir(%) Quit:$l(subdir)>32000
 . For  Set %=$o(files(%)) Quit:%=""  Set files=$s(files="":"",1:files_$c(22,35,1))_files(%) Quit:$l(files)>32000
 . Set return=UpFlag_$c(19,94,1)_subdir_$c(19,94,1)_files
 Quit 0
drives(d) New (d) Set $zt="driveErr",d=""
 Do
 . Set drv=$zu(108),j=1
 . For i=97:1:122 Set:i'=97 j=j*2 Quit:j>drv  Set:drv\j#2 d=d_$c(i)_":"_$c(22,35,1)
 Quit 1
driveErr Quit 0_$c(22,35,1)_"Unable to fetch drives."_$s($ZE'="":$c(13,10,10)_"$ze="_$ZE,1:"")
check(mode,dir,file) Set $zt="checkerr",return=0
 Set filename=$s((file["\")!(file["/"):file,1:dir_file)
 Set check='$zu(140,4,filename)
 Quit:mode $S(check:"2",1:"1")_$c(22,35,1)_filename ; write new=2, over=1
 Quit:check "1"_$c(22,35,1)_filename ; Read
 Quit "0"_$c(22,35,1)_filename_$c(13)_"File not found."_$c(13)_"Please verify the correct file name was given"
checkerr Set $zt=""
 Quit:$ze["<NOTOPEN>" "0"_$c(22,35,1)_filename_$c(13)_" Path not found."_$c(13)_"Please verify the correct path given"
 Close filename Quit "0"_$c(22,35,1)_$ze
CopyFile(src,dst) 
 n line,read
 o src:"R":10 e  q 0_$c(22,35,1)_"Can't open input file"
 o dst:"WNS":10 e  c src q 0_$c(22,35,1)_"Can't open output file"
 s $zt="CFErr"
 f  u src s read=1 r line q:$ZEOF  s read=0 u dst w line,!
CopyFileDone ; come here via the error trap or because $ZEOF is set
 c src,dst
 q 1
CFErr ;CopyFile error handler
 s $zt=""
 i $ZE["<ENDOFFILE>",read=1 g CopyFileDone
 c src,dst
 q 0_$c(22,35,1)_$ZE
system() New
 Quit $s(($zversion(1)=2):"WIN",($zversion(1)=3):"UNIX")

Wr^INT^1^67214,47331
Wr ;spj,Routine utilities
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
maskincl(mask,item,ext) New e,i,include,m,m1,m2
 Set include=0,ext=$ZCVT($g(ext,""),"U")
 For i=1:1 Set m=$p(mask,";",i),e="" Quit:m=""  Do:m'["'"  Quit:include
 . Set:m["." m=$$ParseRoutineName^%R(m,.e),e=$s(e="*":"",e="SRC":".INC.MAC.INT.BAS",e="":"",1:"."_e)
 . If m["*" Do  Quit
 . . Set m=$p(m,"*")
 . . If m=$e(item,1,$l(m)),(e=""!(e[ext)) Set include=1 Quit
 . If m[":" Do  Quit
 . . Set m1=$p(m,":"),m2=$p(m,":",2)
 . . If m1=$e(item,1,$l(m1))!(item]m1) Do
 . . . If m2=$e(item,1,$l(m2))!(m2]item) Do
 . . . . Set:e=""!(e[ext) include=1
 . If m=item,(e=""!(e[ext)) Set include=1 Quit
 If include,mask["'" For i=1:1 Set m=$p(mask,";",i),e="" Quit:m=""  Do:m["'"  Quit:'include
 . Set m=$e(m,2,*)
 . Set:m["." m=$$ParseRoutineName^%R(m,.e),e=$s(e="*":"",e="SRC":".INC.MAC.INT.BAS",e="":"",1:"."_e)
 . If m["*" Do  Quit
 . . Set m=$p(m,"*")
 . . If m=$e(item,1,$l(m)),e=""!(e[ext) Set include=0
 . If m[":" Do  Quit
 . . Set m1=$p(m,":"),m2=$p(m,":",2)
 . . If m1=$e(item,1,$l(m1))!(item]m1) Do
 . . . If m2=$e(item,1,$l(m2))!(m2]item) Do
 . . . . Set:e=""!(e[ext) include=0 ; SJ bug fix
 . If m=item,(e=""!(e[ext)) Set include=0 Quit
 Quit include
 Quit
fmtErr(e) ;
 New i,errmsg,e1
 For i=1:1:$LL(e) Do
 . Set e1=$LI(e,i)
 . Set errmsg=$g(errmsg)_$s(i>1:$c(13,10),1:"")_"line: +"_$LI(e1,1)_" offset: "_$LI(e1,2)_" error: "_$LI(e1,3)
 Quit $g(errmsg)
GenErr(msg) Quit 0_$c(22,35,1)_msg_"."_$s($ZE'="":$c(13,10,10)_"$ze="_$ZE,1:"")
GUIset(flag,str) Kill:flag ^IRIS.TempJ($j)
 For i=1:1:$l(str,$c(22,35,1)) Set x=$p(str,$c(22,35,1),i) Set:x'="" ^IRIS.TempJ($j)=$g(^IRIS.TempJ($j))+1,^IRIS.TempJ($j,x)=""
 Quit $g(^IRIS.TempJ($j))
rcomp(ns1,ns2,rtn1,rtn2) Quit $$rcomp^Wr1(ns1,ns2,rtn1,rtn2)
rcopy(routine,nspace1,nspace2,over,compile,syntax,backup,action,copied) 
 Quit $$rcopy^Wr1(routine,nspace1,nspace2,over,compile,syntax,backup,action,.copied) 
callback(xa,xb) Set:$g(ff)[1!($g(ff)[2) counter=$g(counter)+1 Set nbytes=1024
 Set string=$g(string),line=""
 Set:ff=0 $p(line,$c(19,94,1),1)=xa,$p(line,$c(19,94,1),4)=xb
 Set:ff[1 $p(line,$c(19,94,1),1)="+"_nline(1),$p(line,$c(19,94,1),2)=xa
 Set:ff[2 $p(line,$c(19,94,1),3)="+"_nline(2),$p(line,$c(19,94,1),4)=xb
 If $g(%UI)="GUI" Do
 . If xa=0,xb=0 Set _txtVisM.Text=string_$c(22,35,1),string="" Quit
 . Set:($l(string)+$l(line))>nbytes _txtVisM.Text=string_$c(22,35,1),string=""
 . Set:line'="" string=string_$c(22,35,1)_line
 Else  Do
 . If xa=0,xb=0 Quit
 . New io Set io=$io
 . Use 0 Write !,line Use io
 Quit ""
wrcomp(p) New %UI Set %UI="GUI",%UI("CANCEL")=0 
 Quit $$rcomp^Wr1($p(p,$c(22,35,1)),$p(p,$c(22,35,1),3),$p(p,$c(22,35,1),2),$p(p,$c(22,35,1),4)) 
onedel(rtn,allvers) Do onedel^Wr1(rtn,allvers) Quit
oneline(routine,line,text,type,rtnnew) New X,i,found,output
 Set X=$S('case:$ZCVT(text,"U"),1:text),found=0,i=""
 For  Set i=$o(string(i)) Quit:i=""  If X[string(i) Set found=1 Quit
 Quit:'found
 Set output=$s('rtnnew:$c(22,35,1)_routine_"."_type_$c(22,35,1),1:"")_$j("+"_line,6)_" "_text
 Set cancel=$$callVisM^%Wprim(0,output),rtnnew=1
 Quit
rsel(MASK,SILENT) New (MASK,SILENT,%UI) Set $ze="",$zt="rselErr^Wr"
 Set return=1,MASK=$g(MASK),SILENT=$g(SILENT,0),c="",n=0
 If $$ParseRoutineName^%R(MASK)="*",$namespace'="%SYS" Set MASK=MASK_";'%*.*" ;Skip %* routines
 Kill ^IRIS.TempJ($j)
 For  Do  Quit:'more
 . Set more=$$LIST^%R(MASK,1000,0,.d,.c)
 . If d'="" Set len=$ll(d) For i=1:1:len Set ^IRIS.TempJ($j,$li(d,i))="",n=n+1
 Set ^IRIS.TempJ($j)=n
 Quit 1
rselErr Quit 0
begrou(glo) Quit $S($namespace="%SYS":"",1:$o(@glo@("A"),-1))
wrsel(MASK) New %UI Set %UI="GUI",%UI("CANCEL")=0 Quit:'$$rsel(MASK) 0 Quit 1
init Kill ^IRIS.TempJ($j),nrp Set nrp(1)=0,nrp(0)=0 Do sel,unsel:nrp(1)
 Set ^IRIS.TempJ($j)=nrp(1)_";"_nrp(0) Quit nrp(1)
sel Kill err Read !,"Routines: ",rs," " Quit:rs=""  Set getf=1 Set:rs?1"-".e getf=0,rs=$e(rs,2,*) Do parse Write:$d(err) " ?? bad format" Do:'$d(err) store Goto sel
unsel Kill err Read !,"Exclusions: ",rs," " Quit:rs=""  Set getf=0 Do parse Write:$d(err) " ?? bad format" Do:'$d(err) store Goto unsel
parse Kill pat,err Set np=0 Goto range:rs[":",single:rs'["*"&(rs'["?")
 For i=1:1:$l(rs) Set c=$e(rs,i) Do chk Quit:$d(err)
 Quit:$d(err)  Set m="",n="" For i=0:0 Set n=$o(pat(n)) Quit:n=""  Set l=pat(n) Do lchk Set m=m_l
 Set rpattern="?"_m Quit
range Set brtn=$p(rs,":"),ertn=$p(rs,":",2,999)
 For x=brtn,ertn Goto:'$$rname(x) err1
 Goto:brtn]ertn err1 Set rpattern=":"_rs Quit
err1 Set err=1 Quit
single Goto:'$$rname(rs) err1 Set rpattern="="_rs Quit
chk Goto chk1:c="?",chk2:c="*",pct:c="%",err1:c'?1a&(c'?1n) Set:'$d(pat(np)) pat(np)=$c(0) Set pat(np)=pat(np)_c Quit
chk1 Set np=np+1,pat(np)="1e",np=np+1 Quit
chk2 Set np=np+1,pat(np)=".e",np=np+1 Quit
pct Goto err1:np Goto err1:$g(pat(0))'="" Set pat(0)=$c(0)_"%" Quit
lchk Set:'$a(l) l="1"_""""_$e(l,2,$l(l))_"""" Quit
store Set:'$d(^IRIS.TempJ($j,getf)) ^IRIS.TempJ($j,getf)=0 Set nrp(getf)=nrp(getf)+1,^IRIS.TempJ($j,getf,nrp(getf))=rpattern Quit
screen(rtn) New (rtn) Set screen=0,type=1 Do tests Set:pass screen=1
 Quit:'screen 0 Set type=0 Do tests Quit:pass 0 Quit screen
tests Set pass=0 For i=1:1 Quit:'$d(^IRIS.TempJ($j,type,i))  Set test=^(i) Do pass Quit:pass
 Quit
pass Set tt=$e(test),test=$e(test,2,*) Goto equals:tt="=",inmatch:tt="?",inrange:tt=":" Quit
equals Set:rtn=test pass=1 Quit
inmatch Xecute "i rtn?"_test_" s pass=1" Quit
inrange Set brtn=$p(test,":",1),ertn=$p(test,":",2) Quit:brtn]rtn  Quit:rtn]ertn  Set pass=1 Quit
rname(rtn) Quit:$l(rtn)>31 0 Set fc=$e(rtn) Quit:fc'="%"&(fc'?1a) 0 Set sp=1,ok=1
 For i=2:1:$l(rtn) Set c=$e(rtn,i) If c'?1n&(c'?1a) Set ok=0 Quit
 Quit ok
wrset(p) New (p) Kill ^IRIS.TempJ($j),nrp Set return=1,nrp(1)=0,nrp(0)=0,ln=$l(p,$c(13,10))
 For ij=1:1:ln Set rs=$p(p,$c(13,10),ij) If rs'="" Do  Quit:'return
 . Set rsfull=rs,getf=1 Set:$e(rs)="'"!($e(rs)="-") getf=0,rs=$e(rs,2,$l(rs))
 . Do parse If $d(err) Set return=rsfull_" - wrong format" Quit
 . Do store
 Set ^IRIS.TempJ($j)=nrp(1)_";"_nrp(0) Quit return
rsave(TYPE,file,description,format,printf,autoload,silent) 
 New (%UI,TYPE,file,description,format,printf,autoload,silent,j2)
 Set cancel=0,EXT=TYPE Set:format="Object" TYPE="OBJ",printf=0,autoload=0
 Set parms="~Format="_format_"."_$s($p($p(file,"(",2),")",1)["V":"V",1:"S")_"~"
 Set silent=$g(silent,0)
 If autoload Do  Set description=D
 . Set D="N IO,D,P,I,A,X,L S IO=$I R D U 0 W !,D,! S P=""^"" "
 . Set D=D_"F  U IO R A Q:A=""""  I $P(A,P,3) S L=$P(A,P,5) "
 . Set D=D_"S:L X=$ZUTIL(55,L) ZLOAD  ZSAVE @$P(A,P) S:L X=$ZUTIL(55,0) "
 . Set D=D_"U 0 W !,$P(A,P,1,2),?20,"" loaded"" ;(Self-loading)"
 Do INT^%T Set DATTIM=$ZD($H,6)_"  "_%TIM
 Set SYSNAM="M/SQL-UNIX",VOL=1,$zt="rsaveErr"
 If '$$OpenDev^%Wprim(.file) Quit 0_$c(22,35,1)_"Can't open file."
 Set stream=$$IsStream^%Wprim(file) Use file
 If format="DTM" Do
 . Write ";Routine Save - "_DATTIM_" (DT format - "_$zv_")"_parms Write:stream !
 . Write ";Saved from "_$tr($namespace,":","")_": "_description Write:stream !
 If format="DSM" Do
 . Write "Saved by %RO from "_$tr($namespace,":","")_" on "_$tr($zd($h,2)," ","-")_" "_%TIM Write:stream !
 . Write description Write:stream !
 If format="Cache"!(format="ISM")!(format="") Do
 . Write $S(autoload:description,1:"Cache for Windows NT^"_EXT_"^"_description_"^"_parms) Write:stream !
 . Write "%RO on "_DATTIM Write:stream !
 If format="MSM" Do
 . Write %TIM_"  "_$tr($zd($h,2)," ","-")_parms Write:stream !
 . Write description Write:stream !
 If format="ANSI" Do
 . Write %TIM_"  "_$tr($zd($h,2)," ","-")_parms Write:stream !
 . Write description Write:stream !
 If format="Object" Do  Goto:$G(err) rsaerr Goto close ; Based on %ROMF
 . Use file Use:$ZU(96,18,2,"RAW")!1 0
 . New ok Set rtn="",%R=+$g(^IRIS.TempJ($j)),description=$tr(description,"~","")
 . Set VOL=0,%DAT=$P(DATTIM,"  "),bytes=0
 . Do INT^%T,INT^%D S SYS=$S(($zversion(1)=2):"M/WNT",1:"M/UX")
 . If '$$VOLHDR^%ROMF(0,file,$$MAKEHDR^%ROMF(description,SYS),%DAT,%TIM,.VOL,.bytes) Set cancel=1 Quit
 . Set cancel=0,j=0,err=0,iot=$s($$IsFile^%Wprim(file):"RMS",1:"MT") 
 . For j2=1:1 Set rtn=$$ParseRoutineName^%R($g(^IRIS.TempJ($j,j2)),.EXT) Quit:rtn=""  If EXT="OBJ" Do  Quit:cancel!err
 . . Set j=j+1,ok=$$ONEROU^%ROMF(1,file,iot,rtn) 
 . . If 'ok Quit:$P(ok,"^",2)=""  Set $ZE=$P(ok,"^",2),err=1 Quit
 . . If 'silent Set cancel=$$callVisM^%Wprim($s(j#5=1:1,1:0),rtn) Quit:cancel
 . Use file Write $C(0)
 Set page=0,rtn=0
 For j=1:1 Set rtn=$g(^IRIS.TempJ($j,j)) Quit:rtn=""  Do rsave1(rtn) Quit:cancel  If 'silent Do DoEvents^%CDSrv
 If 'silent Set:'cancel cancel=$$callVisM^%Wprim(1,"")
 Write:stream !! Write:'stream "",""
close Close file Set $zt="" Quit $s(cancel:"Canceled",1:1)
rsaveErr Close file Quit 0_$c(22,35,1)_$ze
rsave1(x) Set RTN=$$ParseRoutineName^%R(x,.EXT)
 If 'silent Set cancel=$$callVisM^%Wprim($s(j#5=1:1,1:0),RTN)
 Set rc=$$ROUTINE^%R(x,.%rou,.err,"L")
 Set DT=$$DATE^%R(x),LANG=$$LANG^%R(x,,.GENERATED),NL=%rou(0)
 If 'printf Do  Write:stream !
 . If "DTM,DSM,MSM,ANSI"'[format Write RTN_"^"_EXT_"^"_$S(EXT="INT":1,EXT="BAS":1,1:"")_"^"_DT_"^"_LANG_"^"_GENERATED
 . Else  Write RTN
 Do:printf rsahead
 For II=1:1:NL Set X=%rou(II) D:printf LINE Do:'printf
 . If format="DSM" Set J=$P(X," "),X=J_$c(9)_$P(X," ",2,999)
 . Else  s:X="" X="."
 . Write:X'="" X Write:stream !
 Write:format="DTM" # Write:stream ! Write:'stream ""
 Quit
rsave2(rou,file,description) New (%UI,rou,file,description)
 Kill ^IRIS.TempJ($j) Set ^IRIS.TempJ($j,1)=rou
 s rtn=$$ParseRoutineName^%R(rou,.type)
 Quit $$rsave(type,file_":(""WNS"")",description,"Cache",0,0,1)
rsaerr Set $zt="" Set err=$ze Close file Close 63 Quit err
LINE Goto:EXT="INC" LOOP
 If X?." "1"#".E,X'?." "1"##".E
 Else  Set J=$P(X," "),X=$E(J_$J("",7),1,7)_$E(J,8,99)_" "_$P(X," ",2,999)
LOOP Write $E(X,1,79) Write:stream ! Set X=$E(X,80,*) Goto:X]"" LOOP
 If $Y+5>60,II+2<NL Do rsahead
 Quit
rsahead Set PAGE=$G(PAGE)+1 Write #,RTN_"."_EXT,?60\2,DATTIM,?70,"Page "_PAGE,!!!
 Quit
LJ(x,n) Quit ($E(x_$J("",n),1,n)_$E(x,n+1,$L(x)))
wrsave(s) New %UI,desc,format,printf,autoload Set %UI="GUI",%UI("CANCEL")=0
 Set format=$p(s,$c(22,35,1),4),autoload=$p(s,$c(22,35,1),5)
 Set printf=$s(format="Printer":1,1:0) Set:$e(printf)=" " printf=$e(printf,2)
 Set:$e(autoload)=" " autoload=$e(autoload,2)
 Set desc=$tr($p(s,$c(22,35,1),3),$c(13,10)," ")
 Quit $$rsave($p(s,$c(22,35,1)),$p(s,$c(22,35,1),2),desc,format,printf,autoload)
getdescr(filespec,format) Quit $$getdescr^Wr1(filespec,format)
getlist(param) Quit $$getlist^Wr1(param) 
GUIlist(file) Set %UI="GUI",%UI("CANCEL")=0 Quit $$getlist^Wr1(file) 
rload(file,format,selection,over,compile,syntax,backup,showstat,langmode,pasting) 
 New (%UI,file,format,selection,over,compile,syntax,backup,showstat,langmode,pasting)
 Set $ze="",$zt="rlderr",langmode=$g(langmode),pasting=$g(pasting,0)
 Set zs=$zs,$zs=16384 ;expand partitition to allow for large routine arrays
 Set cancel=0,limited=$s(selection=1:3,1:2),message=""
 If '$$OpenDev^%Wprim(.file) Quit $$notopen
 If '$$IsFile^%Wprim(file) Use file w *-5
 If format="Object" Quit $$rloado^Wr1(file,format,selection,over)  ; Object separatly
 Use file Read x,y ; Read Header
 If $ZEOF g rldeof
 If format="XML" Set header1=x,header2=y
 For iii=1:1 Set $zt="rldeof2" Use file Read x Goto:$ZEOF rldeof2 Set $zt="rlderr",x=$p(x,$c(13)) Quit:x=""!(format="XML"&(x'["<Routine"))  Do  Quit:cancel
 . Set roustart=x,rtn=$$ParseRoutineHeader^%R(x,.type,.ver,.date,.lang,format,.generated) Quit:rtn=""
 . Set okcomp=$s(type="MAC":1,type="INT":1,type="BAS":1,1:0)
 . Set:date="" date=$H
 . Set:langmode'="" lang=langmode
 . If showstat,$g(%UI)="GUI" Do DoEvents^%CDSrv
 . If pasting Do
 . . If iii#5=1 Set cancel=$$callVisM^%Wprim(1,rtn_"."_type)
 . Else  Set cancel=$$callbckl(limited,rtn_"."_type)
 . If '$$include(rtn,type,selection) Do  Quit  ; Do not restore this routine
 . . Do skip(file,format) ; Skip routine
 . . Set cancel=$$callbckl(limited_1,rtn,rtn_"."_type_$c(19,94,1)_0_$c(19,94,1)_0_$c(19,94,1)_"not in selection"_$c(22,35,1))
 . Set status=$$over(rtn,type,over) If 'status Do  Quit  ;Do not overvrite this routine
 . . Do skip(file,format)  ; Skip routine
 . . Set cancel=$$callbckl(limited_1,rtn,rtn_"."_type_$c(19,94,1)_0_$c(19,94,1)_0_$c(19,94,1)_"already exists"_$c(22,35,1))
 . Do:backup&("MAC,INC"[type) ^%RSHUF("PUSH","","",rtn,type) Kill %temp
 . If format'="XML" Do
 . . Use file Set n=0 For  Read x If $ZEOF,$ZUTIL(96,0,42) {} Set x=$P(x,$C(13)) Quit:$$stop(.x,format)  Do
 . . . Set:x="." x=" " Set n=n+1,%temp(n)=x
 . . Set %temp(0)=n,(message,errmsg)="",(loaded,compiled)=0
 . . Set rc=$$ROUTINE^%R(rtn_"."_type,.%temp,.e,$s((compile&okcomp):"CS",1:"S"),lang,date,,,generated)
 . . Set loaded=$s(rc[",SAVED":1,1:0),compiled=$s(rc[",COMPILED":1,1:0)
 . . If $ll(e) Kill:"MAC,INC"[type %temp Set errmsg=$c(13,10)_$$FMTERR^%R(e,.%temp)
 . Else  Do  Quit:$g(quit)
 . . Set (message,errmsg)="",(loaded,compiled,flg)=0
 . . Set temp=$p(file,".",1,$l(file,".")-1),ext=$p(file,".",$l(file,".")) Set:temp="" temp=file,ext="xml"
 . . For i=1:1:1000 Set tempfile=temp_i_"_tmp."_ext Quit:$zu(140,4,tempfile)
 . . If i<1000 Open tempfile:("WNS"):0 Set flg=$t
 . . If i=1000!'flg Set errmsg=0_$c(22,35,1)_"Could not open file "_tempfile,quit=1 Quit
 . . Use tempfile Write header1,!,header2,!,roustart,!
 . . For  Use file Read x If $ZEOF,$ZUTIL(96,0,42) {} Set x=$P(x,$C(13)) Use tempfile Write x,! Quit:$$stop(.x,format)
 . . Use tempfile Write "<Checksum value=""0""/>",!,"</Export>",! Close tempfile
 . . Set stype=type ;Circumvent $System.OBJ.Load bug
 . . Set rc=$System.OBJ.Load(tempfile,$s(compile:"c",1:"")_"k-d")
 . . Set type=stype
 . . Set loaded=1,compiled=compile
 . . Set rc=$zu(140,5,tempfile)
 . Set:status=2 message=message_"replaced old one"
 . Set message=rtn_"."_type_$c(19,94,1)_loaded_$c(19,94,1)_compiled_$c(19,94,1)_message_$c(19,94,1)_errmsg
 . Set cancel=$$callbckl(limited_1,rtn,message_$c(22,35,1))
rldeof2 ;
 If $d(tempfile) Close tempfile
 Set cancel=$$callbckl(limited,"") ;flush final routine name 
 Set cancel=$$callbckl(limited_2) Kill ^IRIS.TempJ($j),^IRIS.TempWr($j) Close file
 Set $zs=zs
 Quit 1
rldeof Set $ZE="<ENDOFFILE>"  ;come here on EOF error
rlderr Set $zt="",$zs=zs
 If $ZE["ENDOF",((format="DTM")!(format="DSM")) Close file Do  Quit 1
 . Set cancel=$$callbckl(limited_2) Kill ^IRIS.TempWr($j),^IRIS.TempJ($j)
 . If $d(tempfile) Close tempfile
 Close file Close 63 Close:$d(tempfile) tempfile Quit 0_$c(22,35,1)_$ZE
skip(file,format) Use file
 If format=""!(format="Cache")!(format="ISM")!(format="MSM")!(format="DSM")!(format="ANSI") For  Read y If $ZEOF,$ZUTIL(96,0,42) {} Quit:y=""
 If format="DTM" For  Read y If $ZEOF,$ZUTIL(96,0,42) {} If y="" Read y If $ZEOF,$ZUTIL(96,0,42) {} If y="",($a($zb)=12) Read y If $ZEOF,$ZUTIL(96,0,42) {} Quit
 Quit
stop(x,format) New y
 If format=""!(format="Cache")!(format="ISM")!(format="MSM")!(format="DSM")!(format="ANSI") Quit:x="" 1
 If format="XML" Quit $s(x["</Routine>":1,1:0)
 If format="DTM",x="" Read x Goto:$ZEOF rldeof If x="",($a($zb)=12) Read x Goto:$ZEOF rldeof Quit 1
 Quit ""
include(rtn,type,selection) New j Quit:'selection 1
 Quit:selection=1 $d(^IRIS.TempJ($j,rtn,type))
 Quit:selection=2 $$screen(rtn) ; ^Wrset
 Quit 1 ; Restore
over(rtn,type,over) Set status=$$EXIST^%R(rtn_"."_type) Set:status>1 status=1
 Quit:over=2 1+status Quit:'status 1 Quit:'over 0 Quit $$callbckl(4,rtn,type)*2
wrload(p) New %UI,d Set %UI="GUI",%UI("CANCEL")=0,d=$c(22,35,1)
 Quit $$rload($p(p,d),$p(p,d,2),$p(p,d,3),$p(p,d,4),-$p(p,d,5),-$p(p,d,6),-$p(p,d,7),$p(p,d,8),$p(p,d,9))
callbckl(who,rtn,p1,p2) Set nbytes=1024
 If $g(%UI)="GUI" Do  If who=4 Quit $g(return)
 . Set str=$g(str)
 . If who=1 Do  Quit  ; Create list
 . . Set _txtVisM.Text=rtn
 . . Set line=0_$c(19,94,1)_rtn_$c(19,94,1)_p1_$c(19,94,1)_p2
 . . Set:$l(str)+$l(line)>(nbytes-5) _txtVisM=str_$c(22,35,1),str=""
 . . Set str=str_$c(22,35,1)_line
 . If who=21!(who=31) Do  Quit  ; Create log
 . . Set str=$g(str)
 . . Set:$l(str)+$l(p1)>(nbytes-5) _txtVisM=str_$c(22,35,1),str=""
 . . Set str=str_$c(22,35,1)_p1
 . If who=2 Set:showstat _txtVisM.Text=rtn Quit  ;Update progress
 . If who=3 Set:showstat _txtVisM.Text=rtn Quit
 . If who=11!(who=22) Set _txtVisM=str_$c(22,35,1) Quit  ;Flush out
 . If who=32 Set _txtVisM=str_$c(22,35,1) Quit
 . If who=4 Do  Quit
 . . Set:showstat _txtVisM.Text=rtn ;update status when message box is shown
 . . If $g(yesAll) Set return=6
 . . Else  Do
 . . . Set return=$$confirm^%Wprim(9000_$c(19,94,1)_"%S1"_$c(19,94,1)_rtn_"."_p1,"_frmUtility!txtConfirm")
 . . . If return=-1 Set yesAll=1,return=6
 . . Set:return=2 %UI("CANCEL")=1,cancel=1,return=7 Set return=7-return
 If $g(%UI)'="GUI",showstat Set IO=$IO U 0 Do  Use IO ;show chui status
 . If who=21!(who=31) Do  Quit  ; Create log
 . . New rtn,load,comp,comm,err
 . . Set rtn=$p(p1,$c(19,94,1),1),load=$p(p1,$c(19,94,1),2),comp=$p(p1,$c(19,94,1),3),comm=$p($p(p1,$c(19,94,1),4),$c(22,35,1),1),err=$p($p(p1,$c(19,94,1),5),$c(22,35,1),1)
 . . Write !,rtn,$s(load:" Loaded",1:" Skipped"),$s(comp:"; Compiled",1:""),$s(comm="":"",1:"; "_comm)
 . . If err'="" W !,err,!
 Quit $G(%UI("CANCEL"))
HEAD() Set C="",DT="",VOL="" Do GUIHDR^%RIMF(file,.C,.DT,.VOL)
 Quit:'$$ID^%RIMF($$COMPART^%RIMF(C,2)) "[This is not %ROMF file.]"
 Set VOL=+VOL,EB=$$COMPART^%RIMF(C,5),OS=$P($$COMPART^%RIMF(C,3)," ")
 Set CAP=$$COMPART^%RIMF(C,4),C=$$COMPART^%RIMF(C,1)
 Set ENDIAN=$E(CAP,2) ;the big/little endian value
 Set NEW=($E(CAP,3)>1) ;CAP = Ascii/Ebcdic-endian-version (must be 0/1!)
 Quit:VOL'=1 "[***Error: this is volume "_VOL_". Please try again]"
 If " "'[EB,EB="A" Do  Quit ret ;if extra byte added, was 8th bit stripped?
 . Set ret="ERROR: this file has had all '8-bit' characters"
 . Set ret=ret_" truncated to 7-bits -- this file is UNREADABLE as is."
 . Set ret=ret_" Please make sure all file transfers (if any) were done"
 . Set ret=ret_" in BINARY MODE."
 If " "'[EB,EB'=$C(128+$A("A")) Do  Quit ret ;if not 'right' character
 . Set ret="* * * * ERROR: this file has been 'scrambled' in some form"
 . Set ret=ret_" which this routine cannot determine.  Specifically, an"
 . Set ret=ret_" '8-bit' character expected in the file is neither now"
 . Set ret=ret_" '7-bit' nor is it the proper value -- the characters in"
 . Set ret=ret_" the header have somehow been scrambled; this file"
 . Set ret=ret_"cannot be processed."
 If $E(CAP)'="A" Do  Quit ret
 . Set ret="Unfortunately, this file was written on a platform which"
 . Set ret=ret_" used a non-ASCII character set.  At this time, this"
 . Set ret=ret_" version of utility cannot read these files."
 Quit 1
notopen Set $zt="" Quit "Can't open file" 

Wr1^INT^1^67214,47331
Wr1  ;Routine utilities (continued)
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
maskincl(mask,item,ext) New e,i,include,m,m1,m2
 Set include=0,ext=$ZCVT($g(ext,""),"U")
 For i=1:1 Set m=$p(mask,";",i),e="" Quit:m=""  Do:m'["'"  Quit:include
 . Set:m["." m=$$ParseRoutineName^%R(m,.e),e=$s(e="*":"",e="SRC":".INC.MAC.INT.BAS",e="":"",1:"."_e)
 . If m["*" Do  Quit
 . . Set m=$p(m,"*")
 . . If m=$e(item,1,$l(m)),(e=""!(e[ext)) Set include=1 Quit
 . If m[":" Do  Quit
 . . Set m1=$p(m,":"),m2=$p(m,":",2)
 . . If m1=$e(item,1,$l(m1))!(item]m1) Do
 . . . If m2=$e(item,1,$l(m2))!(m2]item) Do
 . . . . Set:e=""!(e[ext) include=1
 . If m=item,(e=""!(e[ext)) Set include=1 Quit
 If include,mask["'" For i=1:1 Set m=$p(mask,";",i),e="" Quit:m=""  Do:m["'"  Quit:'include
 . Set m=$e(m,2,*)
 . Set:m["." m=$$ParseRoutineName^%R(m,.e),e=$s(e="*":"",e="SRC":".INC.MAC.INT.BAS",e="":"",1:"."_e)
 . If m["*" Do  Quit
 . . Set m=$p(m,"*")
 . . If m=$e(item,1,$l(m)),e=""!(e[ext) Set include=0
 . If m[":" Do  Quit
 . . Set m1=$p(m,":"),m2=$p(m,":",2)
 . . If m1=$e(item,1,$l(m1))!(item]m1) Do
 . . . If m2=$e(item,1,$l(m2))!(m2]item) Do
 . . . . Set:e=""!(e[ext) include=0 ; SJ bug fix
 . If m=item,(e=""!(e[ext)) Set include=0 Quit
 Quit include
 Quit
getdescr(filespec,format) Set $ze="",$zt="getderr" New temp,y Set file=filespec
 If '$$OpenDev^%Wprim(.file) Quit $$notopen^Wr
 Use file Read x#510 
 If filespec["k\UNI\" Set x=$e(x,2,*) ;strip off unicode sentinal character
 Set format=$g(format),temp="" For i=1:1:3 Set temp(i)=""
 If format="" Do  Set format=temp ; Try to find out file format
 . If $e(x,1,8)=";Routine" Set temp="DTM" Quit
 . Set y=$p($p(x,"on ",2),":")_":"_$p($p($p(x,"on ",2),":",2)," ")
 . If y?0.1" "1.2N1"-"3A1"-"2.4N1." "1.2N1":"2N Set temp="DSM" Quit
 . If $$ID^%RIMF($p(x,"~",2)) Set temp="Object" Quit
 . If $e(x,1,4)="Cach"!($e(x,1,6)="Open M")!($e(x,1,5)="M/SQL")!($zcvt($e(x,1,5),"U")="OPENM") Set temp="Cache" Quit
 . If $e(x,1,5)="<?xml" Set temp="XML" Quit
 . Set temp="ANSI"
 Read:format'="Object" y Read:format="ANSI"!(format="XML") z
 Set:format="Cache"!(format="ISM") temp(1)=$p(x,"^")_"  Extension "_$p(x,"^",2),temp(2)="Written by "_y,temp(3)=$p(x,"^",3)
 Set:format="DTM" temp(1)=$p($p(x,"(",2),")"),temp(2)=$p($p(y,";",2),":")_" "_$p($p(x,"("),"-",2),temp(3)=$p(y,":",2,999)
 Set:format="DSM" temp(1)=x,temp(3)=y
 If format="ANSI" Set:z["."&(x'["Self-loading") temp="MSM",format=temp Set temp(1)=x,temp(3)=y
 If format="Object" Set temp(1)=$p($p(x,"~",3)," ")_" wrote this file on "_$e(x,257,274),temp(2)="",temp(3)=$p(x,"~")
 If format="XML" Set temp(1)="XML "_$s(z["Routine":"routine ",1:"")_"file",temp(2)="",temp(3)="Written by "_$p($p(y,"=",2),"""",2)
getderr Close file Quit:$ze'="" "" Quit temp(1)_$c(22,35,1)_temp(2)_$c(22,35,1)_temp(3)_$c(22,35,1)_temp
getlist(param) New (%UI,param) Set $zt="errgetl",cancel=0 Kill ^IRIS.TempWr($j)
 Set file=$p(param,$c(22,35,1)),format=$p(param,$c(22,35,1),2)
 If '$$OpenDev^%Wprim(.file) Quit $$notopen^Wr
 If '$$IsFile^%Wprim(file) Use file w *-5
 If format="Object" Set x=$$getlisto(file) Quit:'x x
 Else  If format="XML" Do
 . Use file Read x,y
 . For  Read rtn If $ZEOF,$ZUTIL(96,0,42) {} Set rtn=$p(rtn,$c(13)) If rtn["<Routine" Set type=$p($p(rtn,"type=",2),"""",2),rtn=$p($p(rtn,"name=",2),"""",2) Quit:rtn=""  Do  Quit:cancel
 . . Read first
 . . If $ZEOF,$ZUTIL(96,0,42)
 . . Set:rtn'="" ^IRIS.TempWr($j,rtn)=type_$c(22,35,1)_first
 . . Set cancel=$$callbckl^Wr(1,rtn,type,first)
 . . For  Read x If $ZEOF,$ZUTIL(96,0,42) {} If x["</Routine>" Quit
 Else  Do
 . Use file Read x,y ; Read Header
 . If $ZEOF,$ZUTIL(96,0,42)
 . For  Read rtn If $ZEOF,$ZUTIL(96,0,42) {} Set rtn=$p(rtn,$c(13)) Quit:rtn=""  Do  Quit:cancel
 . . Set rtn=$$ParseRoutineHeader^%R(rtn,.type) Set:type="" type="INT"
 . . Read first 
 . . If $ZEOF,$ZUTIL(96,0,42)
 . . Set:rtn'="" ^IRIS.TempWr($j,rtn)=type_$c(22,35,1)_first
 . . Set cancel=$$callbckl^Wr(1,rtn,type,first)
 . . Do skip^Wr(file,format) ; skip routine
 Set cancel=$$callbckl^Wr(11) 
 Close file 
 Set $zt="" 
 Quit 1
erreof Set $ZE="<ENDOFFILE>"  ;come here on EOF error
errgetl Set $zt="",err=$ZE
 If $ZE["ENDOF" Close file Set x=$$callbckl^Wr(11) Quit 1
 Close file Quit "0"_$c(22,35,1)_err
getlisto(file) Use file
 Set head=$ZU(96,18,2,"RAW")
 Set head=$$HEAD^Wr() Quit:'head head Set LEN="",rtn="",first="",type="OBJ"  
 For  Quit:'$$GUIRDL^%RIMF(file,.rtn,.LEN)  Do  Quit:cancel
 . Set ^IRIS.TempWr($j,rtn)=type_$c(22,35,1)_first
 . Set cancel=$$callbckl^Wr(1,rtn,type,first)
 . Do GUISKP^%RIMF(file,LEN) ; Skip routine
 Quit 1    
NSpaceM(ns) Quit $s(ns="":"",1:$ZU(5,ns))
onedel(rtn,allvers) ;allvers parameter is now obsolete, as v4.0
 n x s x=$$DEL^%R(rtn)
 Quit
rcomp(ns1,ns2,rtn1,rtn2) New (%UI,TYPE,rtn1,rtn2,ns1,ns2)
 Set rtn(1)=rtn1,rtn(2)=rtn2,return=1,nline(1)=0,nline(2)=0
 If (rtn1=rtn2),(ns1=ns2) Quit 1 ; 0 differences "Can not compare to itself"
 Quit:rtn1=""!(rtn2="") "" Set ns(1)=ns1,ns(2)=ns2
 s (more(1),more(2))=0
rcmore For i=1,2 Do  Quit:return'=1
 . Set src(i)="",rtn=$$ParseRoutineName^%R(rtn(i),.TYPE),start=1
 . Set TYPE(i)=TYPE
 . If '$$EXIST^%R(rtn(i),ns(i)) Set return="Routine '"_rtn_"' does not exist" Quit
 . If TYPE="OBJ" Do
 . . New obj If $$ROUTINE^%R(rtn(i),.obj,.e,"L","","",ns(i)) Set src(i)=obj(1) Set:$d(obj(2)) src(i,0)=obj(2)
 . Else  Do
 . . If more(i) Set start=more(i)+1,more(i)=0
 . . Else  Set end(i)=$$LENGTH^%R(rtn(i),ns(i))
 . . For j=start:1:end(i) Do  Quit:more(i)
 . . . Set src(i)=src(i)_$$LINE^%R(rtn_"."_TYPE,j,ns(i))_$c(10)
 . . . If $l(src(i))>32000 Set more(i)=j
 . . Set:j=end(i) more(i)=0
 If return'=1  Quit return
 Quit:TYPE(1)'=TYPE(2) "Routines are of different types"
 If TYPE="OBJ" {
   If src(1)=src(2),$g(src(1,0))=$g(src(2,0)) Quit 2
   Quit 1
 }
 Set return=$$compare(.src)
 If more(1)!(more(2)) Goto rcmore
 Quit return
compare(src) Set return=$g(return)
 For i=1,2 Set nline(i)=+$g(nline(i))
 Set src(1)=src(1)_$s($e(src(1),$l(src(1)))'=$c(10):$c(10),1:"")_"--end--"
 Set src(2)=src(2)_$s($e(src(2),$l(src(2)))'=$c(10):$c(10),1:"")_"--end--"
compare1 Set a=$p(src(1),$c(10)),b=$p(src(2),$c(10)) Goto:a'=b compare2
 If a="--end--",a=src(1) Set x=$$callback^Wr(0,0) Quit return ;+$g(counter)
 Set ff=12 Do nextline Goto compare1
compare2 Set a=$c(10)_$p(src(1),$c(10),1,2),b=$c(10)_$p(src(2),$c(10),1,2)
 Set oa=$f(src(1),b)-$l(b),ob=$f(src(2),a)-$l(a)
 Set o=$s(oa<0:ob,ob<0:oa,oa>ob:ob,1:oa)
 If o<0 Do
 .  Set ff=12,showline=$$callback^Wr($p(src(1),$c(10)),$p(src(2),$c(10))),ff=12 Do nextline
 Else  Set ff=$s(o=oa:1,1:2) Do
 . Set p=0 For k=1:1 Set p=$f($s(ff=2:src(2),1:src(1)),$c(10),p) Quit:'p  Quit:p>o
 . For j=1:1:k  Set showline=$$callback^Wr($p(src(1),$c(10)),$p(src(2),$c(10))) Do nextline
 Goto compare1
nextline Set:ff[1 src(1)=$p(src(1),$c(10),2,9999),nline(1)=nline(1)+1
 Set:ff[2 src(2)=$p(src(2),$c(10),2,9999),nline(2)=nline(2)+1
 Quit
rcseq(file,ctx) New (%UI,file,ctx)
 Set $zt="rcsErr",$ze="",ctx=$g(ctx,0)
 If ctx=0 Do  If ctx=0 Quit 0_"^"_$$notopen^Wr
 . Set $zt="rcseq0"
 . If '$$OpenDev^%Wprim(.file) Quit
 . Set ctx=$I(^IRIS.Temp)
 . Use file
 . Read h1 If $ZEOF,$ZUTIL(96,0,42) {}
 . Read h2 If $ZEOF,$ZUTIL(96,0,42) {}
 . For  u file r a If $ZEOF,$ZUTIL(96,0,42) {} s rtn=$$ParseRoutineHeader^%R(a,.type)_"."_type d
 . . For i=1:1 Use file Read a If $ZEOF,$ZUTIL(96,0,42) {} Quit:a=""  Set ^IRIS.Temp(ctx,rtn,i)=a
rcseq0 . Close file 
 . If $ze'["<ENDOFFILE>" Set ctx=0 Quit
 Set nline(1)=0,nline(2)=0
 Set ctx1=+ctx,rtn=$o(^IRIS.Temp(ctx1,$p(ctx,"^",2)))
 Set end(1)=$o(^IRIS.Temp(ctx1,rtn,""),-1),end(2)=$$LENGTH^%R(rtn),ff=0 
 If 'end(2) Do callback^Wr($p(rtn,$c(10)),"[no routine]"),callback^Wr(0,0) Goto rcseq2
 Do callback^Wr(rtn,"")
 Set (more(1),more(2),nline(1),nline(2))=0
rcseq1 For i=1,2 Do
 . Set src(i)="",start=1
 . If more(i) Set start=more(i)+1,more(i)=0
 . For j=start:1:end(i) Do  Quit:more(i)
 . . If i=1 Set src(1)=src(1)_^IRIS.Temp(ctx1,rtn,j)_$c(10)
 . . Else  Set src(2)=src(2)_$$LINE^%R(rtn,j)_$c(10)
 . . If $l(src(i))>32000 Set more(i)=j
 . Set:j=end(i) more(i)=0
 Set return=$$compare(.src)
 If more(1)!(more(2)) Goto rcseq1
rcseq2 Set ctx=ctx1_"^"_rtn
 Set return=($o(^IRIS.Temp(ctx1,rtn))'="")
 Quit return
rcsErr Quit 0_"^"_$ze
rcopy(routine,nspace1,nspace2,compile,syntax,backup,action,copied) 
 ;Quit $$rcopyOld(routine,nspace1,nspace2,compile,syntax,backup,action,copied)
 New (%UI,routine,nspace1,nspace2,over,compile,syntax,backup,action,copied)
 Set $zt="copyerr",replaced=0,compiled=0,showstat=0
 Set NSPACE=$namespace,zs=$ZS,$ZS=16384
 Set status=1,cancel=0,message=""
 Set rtn=$$ParseRoutineName^%R(routine,.type)
 ;Load MAC,INC,INT,BAS routine in ^IRIS.TempWr($j,%msub)
 Do NSpaceM(nspace1)
 If type="INT"!(type="MAC")!(type="INC")!(type="BAS") Do
 . Do ROUTINE^%R(routine,.r,.err,"L")
 . Set lang=$$LANG^%R(routine)
 . If lang Set OLDLANG=$ZUTIL(55,lang) ; Save the old language
 ; Copy in to nspace2
 Do NSpaceM(nspace2)
 If backup,"MAC,INC"[type Do ^%RSHUF("PUSH","","",rtn,type)
 If compile Do
 . Set compiled=$$ROUTINE^%R(routine,.r,.e,"SC")
 Else  Do 
 . Do ROUTINE^%R(routine,.r,.e,"S")
 Set copied=copied+1
 If action=2 Do NSpaceM(nspace1) s x=$$DEL^%R(routine)
 Set message=routine
 Set:action=1 message=message_" copied          "
 Set:action=2 message=message_" moved           "
 Set:replaced message=message_" Replaced old one"
 Set:compiled message=message_" Recompiled      "
 Set cancel=$$callVisM^%Wprim(1,$c(22,35,1)_message) Quit:cancel 0
 Set NSPACE=$ZU(5,NSPACE)
 Set $ZS=zs
 Quit 1
copyerr Set $ZS=zs
 d debug^%Wprim("copyerr^Wr1: "_$ze)
 Quit $$GenErr^Wr("Copy error")
rloado(file,format,selection,over) Kill ^mtemp1("ROU") Do 1^%ROUN Use file
 Set head=$ZU(96,18,2,"RAW")
 Set head=$$HEAD^Wr() Quit:'head head Set LEN="",rtn=""
 For iii=1:1 Quit:'$$GUIRDL^%RIMF(file,.rtn,.LEN)  Do  Quit:cancel
 . Set cancel=$$callbckl^Wr($s(iii#5=1:limited,1:0),rtn),type="OBJ" ;output every 5th routine
 . If '$$include^Wr(rtn,type,selection) Do  Quit  ; Do not restore this routine
 . . Do GUISKP^%RIMF(file,LEN) ; Skip routine
 . . Set cancel=$$callbckl^Wr(limited_1,rtn,rtn_"."_type_$c(19,94,1)_0_$c(19,94,1)_0_$c(19,94,1)_"not in selection"_$c(22,35,1))
 . Set status=$$over^Wr(rtn,type,over) If 'status Do  Quit  ; Do not overvrite this routine
 . . Do GUISKP^%RIMF(file,LEN) ; Skip routine
 . . Set cancel=$$callbckl^Wr(limited_1,rtn,rtn_"."_type_$c(19,94,1)_0_$c(19,94,1)_0_$c(19,94,1)_"already exists"_$c(22,35,1))
 . Set status=status-1
 . Set rc=$$GUILDR^%RIMF(file,rtn,LEN)
 . If rc Do  
 . . s x=$$DEL^%R(rtn_".INT") Set status=status_"@" ;load!
 . . Set message=rtn_"."_type_$c(19,94,1)_1_$c(19,94,1)_(status["@")_$c(19,94,1)
 . . If status["1" Set message=message_"replaced old one"
 . . Set cancel=$$callbckl^Wr(limited_1,rtn,message_$c(22,35,1))
 . Else  Do  
 . . Set message=rtn_"."_type_$c(19,94,1)_0_$c(19,94,1)_0_$c(19,94,1)_$c(19,94,1)_"old object"
 . . Set cancel=$$callbckl^Wr(limited_1,rtn,message_$c(22,35,1))
 . . Set cancel=1,rc="00"
 . If cancel Quit  
 Set cancel=$$callbckl^Wr(limited,rtn) ;flush final routine name
 Set cancel=$$callbckl^Wr(limited_2) Kill ^IRIS.TempJ($j),^IRIS.TempWr($j) Close file
 Quit rc

Wsback^INT^1^67214,47331
Wsback ;System Management backup functions
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
maskincl(mask,item,ext) New e,i,include,m,m1,m2
 Set include=0,ext=$ZCVT($g(ext,""),"U")
 For i=1:1 Set m=$p(mask,";",i),e="" Quit:m=""  Do:m'["'"  Quit:include
 . Set:m["." m=$$ParseRoutineName^%R(m,.e),e=$s(e="*":"",e="SRC":".INC.MAC.INT.BAS",e="":"",1:"."_e)
 . If m["*" Do  Quit
 . . Set m=$p(m,"*")
 . . If m=$e(item,1,$l(m)),(e=""!(e[ext)) Set include=1 Quit
 . If m[":" Do  Quit
 . . Set m1=$p(m,":"),m2=$p(m,":",2)
 . . If m1=$e(item,1,$l(m1))!(item]m1) Do
 . . . If m2=$e(item,1,$l(m2))!(m2]item) Do
 . . . . Set:e=""!(e[ext) include=1
 . If m=item,(e=""!(e[ext)) Set include=1 Quit
 If include,mask["'" For i=1:1 Set m=$p(mask,";",i),e="" Quit:m=""  Do:m["'"  Quit:'include
 . Set m=$e(m,2,*)
 . Set:m["." m=$$ParseRoutineName^%R(m,.e),e=$s(e="*":"",e="SRC":".INC.MAC.INT.BAS",e="":"",1:"."_e)
 . If m["*" Do  Quit
 . . Set m=$p(m,"*")
 . . If m=$e(item,1,$l(m)),e=""!(e[ext) Set include=0
 . If m[":" Do  Quit
 . . Set m1=$p(m,":"),m2=$p(m,":",2)
 . . If m1=$e(item,1,$l(m1))!(item]m1) Do
 . . . If m2=$e(item,1,$l(m2))!(m2]item) Do
 . . . . Set:e=""!(e[ext) include=0 ; SJ bug fix
 . If m=item,(e=""!(e[ext)) Set include=0 Quit
 Quit include
 w !,"This is not an interactive routine, enter only at specified entry points."
 q
GetFirst() ; Get first line of backup history to display on client
 ; The first line is different from the rest.
 n
 s tmp=$G(^SYS("BACKUP","LASTFULL","DATE"))
 i tmp="" q "" ; No backup data
 s date=$p(tmp,",",1)
 i date'="" s date=$$dec2dat^%Wmdc(date)
 s time=$p(tmp,",",2)
 i time'="" s time=$$dec2tim^%Wmdc(time)
 s tmp=date_";"_time_";"_$G(^SYS("BACKUP","LASTFULL","TYPE"))
 s tmp=tmp_";"_$G(^SYS("BACKUP","LASTFULL","DEVICE"))
 s tmp=tmp_";"_$G(^SYS("BACKUP","LASTFULL","LOG"))
 s tmp=tmp_";"_$G(^SYS("BACKUP","LASTFULL","DESC"))
 q tmp
GetHist()   ;
 ; Get backup history to display on client.  Return null to terminate.
 I '$D(^TMP($J,"GetHist")) S ^TMP($J,"GetHist")=""
 d ConvHistDate^DBACK
 i $l(^TMP($J,"GetHist"),",")=2 s ^TMP($J,"GetHist")=(+^TMP($J,"GetHist")*1000000+$p(^TMP($J,"GetHist"),",",2))
 S ^TMP($J,"GetHist")=$O(^SYS("BACKUP","HISTORY",^TMP($J,"GetHist")))
 S tmp=^TMP($J,"GetHist")
 i tmp="" q "" ; No backup data
 s date=$$dec2dat^%Wmdc((tmp\1000000))
 s time=$$dec2tim^%Wmdc((tmp#1000000))
 s tmp=date_";"_time_";"_$G(^SYS("BACKUP","HISTORY",^TMP($J,"GetHist"),"TYPE"))
 s tmp=tmp_";"_$G(^SYS("BACKUP","HISTORY",^TMP($J,"GetHist"),"DEVICE"))
 s tmp=tmp_";"_$G(^SYS("BACKUP","HISTORY",^TMP($J,"GetHist"),"LOG"))
 s tmp=tmp_";"_$G(^SYS("BACKUP","HISTORY",^TMP($J,"GetHist"),"DESC"))
 q tmp
 ;
test ;
 s return=$$BACKUP^DBACK("","F","Description","C:\openm\backup.ful","N","C:\openm\backup.log","NOISY","N","N","")
 q
 ;
BACKUP(sub)      ; Started from Control Panel
 ;P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,P10
 ; called from progress3
 s $zt="^%ET"
 s return=$$IjcOpen^%Wprima("Job")
 i return=0 q
 i $$IjcMsg^%Wprima("PD"_$J) ; Send a PID message to Message2 
 ;                            procedure in Progress3 form
 ; The parameter list is too long to be shelled so
 ; we get the parameters from a Openm1.tmp file
 n (sub)
 I '$d(^IRIS.TempUtil("BACKUP",sub)) Q
 s string=^IRIS.TempUtil("BACKUP",sub)
 s del1=$$del1^%Wprim
 f i=1:1:11 s parm="P"_(i-1),@parm=$p(string,del1,i)
 k ^IRIS.TempUtil("BACKUP",sub)
 ;o file::1 u file
 ;r P0,P1,P2,P3,P4,P5,P6,P7,P8,P9
 ;c file
 ;i $zf(-1,"del "_file) ; delete the temp file
 ; use this code to prompt a user
 ;s prompt="Enter a tape device",default="default",title="Title"
 ;s ans=$$IjcIB^%Wprima(prompt,title,default)
 ;s ans=$e(ans,3,999)
 ;i $$IjcMsg^%Wprima("DI"_ans)
BACKUP1 ;
 s return=$$BACKUP^DBACK(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,,P10)
 i $$IjcMsg^%Wprima("DI"_$C(13,10)_"Return status = "_return)
 ; BACKUP^DBACK calls SetStatus because we passed the taskname (P10)
 i $$IjcMsg^%Wprima("JS"_$S(return:"1",1:"0"))
 s return=$$IjcClose^%Wprima("Job")
 q  ; Called with the JOB command, so no return value
SetStatus       ; Update Set status
 q:P10=""
 s $p(^SYS("BACKUPTASK",P10),"^",9)=$s(return=1:"Completed",return=0:"Failed",$e(return,1,2)="1,":"Warning",return="CANCEL":"Cancelled",1:return)
 q
setGlo(P0) ; Saves backup parameters in global for job command.
 n (P0)
 f cnt=1:1 I '$D(^IRIS.TempUtil("BACKUP",cnt)) Q
 s ^IRIS.TempUtil("BACKUP",cnt)=P0
 Q cnt
text(file) ;
 ; inputs: file to be opened
 ;  
 ; return value:
 ;  status flag (1=success; 0=failure)
 ; output record:
 ;  error, tag, time, process, line of code
 ;
 ;s return=1
 c file o file:"r":4
 i $t=0 q 0
 s $zt="eof"
 s %UI="GUI"
 k %UI("CANCEL")
 ; Only get the first 1000 records to browse
 ; if you get too many the text box will overfill
 f i=1:1:1000 d
 . u file 
 . r x
 . i $ZEOF,$ZUTIL(96,0,42)
 . I $$callback^%Wprim(0,"",x_$c(13,10))
 u 0
eof i $ze["ENDOFFILE" S $ze=""
 c file
 w $$callback^%Wprim(1,"","")
 q i
GetDir()        ; Get the directories
 n
 s (str,dir)=""
 i '$d(^SYS("BACKUP","DIRECTORIES")) q "" ; No backup information at all
 l +^SYS("BACKUP","DIRECTORIES"):2 i $t=0 q 0
 f  s dir=$o(^SYS("BACKUP","DIRECTORIES",dir)) q:dir=""  s str=str_";"_dir
 l -^SYS("BACKUP","DIRECTORIES")
 s str=$e(str,2,$l(str))
 q str
GetAllDir(DirStr)     ;
 ;inputs:
 ;  None
 ;  DirStr is a return parameter passed by value call like this
 ;  MVB1.Code = "$$GetAllDir(.P0)"
 ;return value:
 ;  success/failure flag (0_message=failure, 1 = success)
 ;
 n (DirStr)
 s $ze="",$zt="StdErr^"_$zname
 s message="Error in GetAllDir"
 s DirStr="",del1=$$del1^%Wprim
 s dir="" f  s dir=$$GetNextDatabaseByUCI^%SYS.CONFIG(dir) q:dir=""  d
 . s DirStr=DirStr_$c(22,35,1)_dir
 s DirStr=$p(DirStr,del1,2,999)
 q 1
 ;
GetBDir(DirStr)     ;
 ;inputs:
 ;  None
 ;  DirBStr is a return parameter passed by value call like this
 ;  MVB1.Code = "$$GetBDir(.P0)"
 ;  The return value of DirStr is
 ;  a pieced string where the first character of each piece is the
 ;  backup flag, the rest of the
 ;return value:
 ;  success/failure flag (0_message=failure, 1 = success)
 ;
 n (DirStr)
 s $ze="",$zt="StdErr^"_$zname
 s message="Error in GetAllDir"
 s DirStr="",del1=$$del1^%Wprim
 s dir="" f  s dir=$$GetNextDatabaseByUCI^%SYS.CONFIG(dir) q:dir=""  d
 . s DirStr=DirStr_$c(22,35,1)_$S($D(^SYS("BACKUP","DIRECTORIES",dir))>0:1,1:0)_dir
 s DirStr=$p(DirStr,del1,2,999)
 q 1
 ;
PutDir(str) ;
 n (str)
 q:str="" 1
 l +^SYS("BACKUP","DIRECTORIES"):2 i $t=0 q 0
 k ^SYS("BACKUP","DIRECTORIES")
 f i=1:1:$l(str,";") S X=$P(str,";",i) I X'="" S ^SYS("BACKUP","DIRECTORIES",X)=""
 l -^SYS("BACKUP","DIRECTORIES")
 q 1
 ;
StdErr ; Standard error trap
 s message=0_$$del1^%Wprim_message_$c(13,10)_$ze
 s $ze=""
 q message
SaveSet(str)    ; For Control Panel use: save backup Set definitions
 ; Called from New and Edit
 ; ^SYS("BACKUPTASK",SETNAME)=Set data delimited by gsD1
 ; P1 = setname
 ; P2 = Backup Type (ful,inc,cum)
 ; P3 = Device
 ; P4 = Selected Databases (delimited by gsD2)
 ; P5 = Switch Journal flag (1 = yes, 0 = no)
 ; P6 = Description (max 256 characters)
 ; P7 = Last modified date and time
 ; P8 = Last run date and time   ;this is updated when run
 ; P9 = Last run status          ;this is updated when run
 ; P10= System designed flag (1 = system designed, null = user defined)
 n (str)
 s $ze="",$zt="SaveSetErr^Wsback"
 s setname=$p(str,"^"),str=str_"^"_$$cvtdate($h)
 s $P(str,"^",4)=""  ;set database list to null, current list will be used
 s $p(^SYS("BACKUPTASK",setname),"^",1,7)=str
 q 1
SaveSetErr      ;
 q 0_$$del1^%Wprim_"Unable to save backup set definition for "_setname_$s($ZE'="":$c(13,10,10)_"$ze="_$ZE,1:"")
 ;
DbList(data)    ; get backup Database List for Control Panel
 ; Called from NodeSelect, frmMain
 ; ^SYS("BACKUP","DIRECTORIES",database name)=database directory
 ; If this list exists, get it.
 ; If not, build all from the existing database list except the CACHETEMP
 n (%UI,data)
 s $ze="",$zt="DbListErr"
 s data="",stop=0,return=1
 s db="",del1=$$del1^%Wprim,del2=$$del2^%Wprim
 if $D(^SYS("BACKUPCHUI")) s sc=$$UpgradeDBList() if '+sc q sc
 d GetCompactDBList(.cdblist)
 f  s db=$o(^SYS("BACKUPDB",db)) q:db=""  d  i ('sc) s return="0,"_del1_$SYSTEM.Status.GetErrorText(sc) q
 . s sc=##class(Config.Databases).Get(db,.p)
 . q:('sc)
 . s dir=p("Directory")
 . s dir=##class(%Library.File).ComputeFullDBDir(dir)
 . q:(dir="")!('##class(%Library.File).DirectoryExists(dir))
 . Set info=$g(cdblist(dir),"-1^0") ; defaut to -1 SFN and not readonly.
 . q:$p(info,"^")=$ZU(173)  ;don't backup cachetemp
 . s readonly=$p(info,"^",2)
 . s data=data_db_del2_dir_del2_readonly_del1
 q return
 ;
DbListErr       ;
 q 0_$$del1^%Wprim_"Unable to get backup database list."_$s($ZE'="":$c(13,10,10)_"$ze="_$ZE,1:"")
 ;
GetCompactDBList(list) {
	Set rs=##class(%Library.ResultSet).%New("SYS.Database:CompactLocalList")
	Do rs.Execute()
	while (rs.Next()) {
		s list(rs.Data("Directory"))=rs.Data("SFN")_"^"_rs.Data("ReadOnly")
	}
}
SvDbList(str)   ; Save database list
 ; ^SYS("BACKUPDB",dbname)=dbdirectories
 n (str)
 q:str="" 1
 s $ze="",$zt="SvDbListErr"
 s db="",del1=$$del1^%Wprim,del2=$$del2^%Wprim
 l +^SYS("BACKUPDB"):2 i $t=0 q 0
 k ^SYS("BACKUPDB")
 f i=1:1:$l(str,del1) S db=$P(str,del1,i) d
 . q:$p(db,del2)=""
 . s ^SYS("BACKUPDB",$p(db,del2))=""
 l -^SYS("BACKUPDB")
 q 1
SvDbListErr     ;
 q 0_$$del1^%Wprim_"Unable to save backup database list."_$s($ZE'="":$c(13,10,10)_"$ze="_$ZE,1:"")
 ;
UpgradeDBList() { ;
    q:'$D(^SYS("BACKUPCHUI"))
    s del1=$$del1^%Wprim,del2=$$del2^%Wprim
	s context=""
	do {
 	   s done=$$List^Wsdba(.datalist,.context)
 	   s cnt=$L(datalist,del1)
 	   f i=1:1:cnt {
 		  s db=$p(datalist,del1,i)
 		  s dbname=$p(db,del2)
		  s dbdir=$p(db,del2,2)
		  if $L(dbdir),+$p(db,del2,4)'=$ZU(173)  { ;skip cachetemp
 		     s index=$I(list(dbdir))
 		     s list(dbdir,index)=dbname
 		     s dbdir2=$ZU(12,dbdir,2)
 		     i $L(dbdir2),dbdir2'=dbdir {
	 		    s index=$I(list(dbdir2))
	 		    s list(dbdir2,index)=dbname
 	         }
 	      }
 	   }
	} while (done)
	;
	s status=1  ;return status
	s dir=$O(^SYS("BACKUPCHUI","DIRECTORIES",""))
	while dir'="" {
	   if $g(list(dir)) {
	      f i=1:1:list(dir) s ^SYS("BACKUPDB",list(dir,i))=""
		  s dir=$O(^SYS("BACKUPCHUI","DIRECTORIES",dir))
	   } else {
		  s msg=$C(13,10)_"Unable to translate directory "_dir
		  s msg=msg_$C(13,10)_"to a database name for backups"
		  s msg=msg_$C(13,10)_"Removing backup list and all databases will be included"
		  s msg=msg_$C(13,10)_"until a new database list is defined."
		  do $ZU(9,"",msg)
		  s status=0_$$del1^%Wprim_msg
		  s dir=$o(list(""))
		  while dir'="" {
			f i=1:1:list(dir) s ^SYS("BACKUPDB",list(dir,i))=""
			s dir=$o(list(dir))
		  }
		  k ^SYS("BACKUP")  ; Delete backup history
		  ;Don't include the CACHELIB and DOCBOOK in the backup list.
		  k ^SYS("BACKUPDB","IRISLIB"),^SYS("BACKUPDB","DOCBOOK")
		  ;dir will be null here and it will terminate the outer while loop.
	   }
	}
 	s ^SYS("BACKUPDB","IRISAUDIT")=""   ; include audit database 
 	merge ^SYS("BACKUP")=^SYS("BACKUPCHUI") ; transfer history
 	s fulldate=$g(^SYS("BACKUPCHUI","LASTFULL","DATE"),"")
 	if fulldate'="" {
	 	s hindex=(+fulldate*1000000+$p(fulldate,",",2))
	 	merge ^SYS("BUHISTORY",hindex)=^SYS("BACKUPCHUI","LASTFULL")
	 	;don't need date for history, the subscript is the date already.
	 	k ^SYS("BUHISTORY",fulldate,"DATE")
 	}
 	;set the non full backup history.
 	s hdate=""
 	f  {
	 	s hdate=$o(^SYS("BACKUPCHUI","HISTORY",hdate))
	 	q:hdate=""
	 	s hindex=(+hdate*1000000+$p(hdate,",",2))
	 	merge ^SYS("BUHISTORY",hindex)=^SYS("BACKUPCHUI","HISTORY",hdate)
 	}
 	k ^SYS("BACKUPCHUI")
	if +status do $ZU(9,"","Wsback: Upgraded CHUI backup information")
	q status
 }
SaveDir(str)    ; Save database directories for this run
 ; This sub is called to save the current run databases
 ; in ^SYS("BACKUP","DIRECTORIES"). The set from the last 
 ; backup run was saved by the backup in ^SYS("BACKUP","LASTDIRECTORIES")
 ; and when we run the backup it will decide whether there have been
 ; any changes
 n (str)
 q:str="" 1
 s $ze="",$zt="SaveDirErr"
 s db="",del1=$$del1^%Wprim
 l ^SYS("BACKUP","DIRECTORIES"):2 i $t=0 g SaveDirErr
 k ^SYS("BACKUP","DIRECTORIES")
 f i=1:1:$l(str,del1) s db=$p(str,del1,i) d
 . q:db=""
 . s ^SYS("BACKUP","DIRECTORIES",db)=""
 l
 q 1
SaveDirErr      ;
 q 0_$$del1^%Wprim_"Unable to save backup database directories."_$s($ZE'="":$c(13,10,10)_"$ze="_$ZE,1:"")
 ;
List(data,context)  ;get backup Set definitions for Control Panel
 ;inputs:
 ;       .data = data to be returned
 ;       .context = context variable to resume fetching
 ;return value:
 ;       success/failure flag (0_message=failure, #databases=success)
 ;       success/failure/more data flag
 ;               0_message=failure,
 ;               0 = success
 ;               1 = more data, pass the returned context back in
 ;output record:
 ;       name, backup type, device, databases, switch journal flag, description
 ;       logfile, last run date and time, last modified date and time
 ;Note:  You must take into consideration the four system sets which the user
 ;       cannot modify: case 1: the first time it's used; case 2: after it's run
 ;
 n (%UI,data,context)
 s $ze="",$zt="ListErr"
 s data="",stop=0,return=1,size=1000
 s bckset=context,del1=$$del1^%Wprim
 ;clean up old nodes prior to build 47.
 ;i $d(^%SYS("BACKUPLIST","EVERYTHING")),$d(^("Custom")) k ^("EVERYTHING"),^("Custom")
 s setdef("FullAllDatabases")="0^^^1^Full backup of ALL databases, whether or not they are in the backup database list.^^^^1"
 s setdef("FullDBList")="0^^^1^Full backup of all databases that are in the backup database list.^^^^1"
 s setdef("IncrementalDBList")="1^^^1^Incremental backup of all databases that are in the backup database list.^^^^1"
 s setdef("CumuIncrDBList")="2^^^1^Cumulative and Incremental backup of all databases that are in the backup database list.^^^^1"
 ;set the listview in this order
 s setdef(0)="FullAllDatabases"_"^"_"FullDBList"_"^"_"IncrementalDBList"_"^"_"CumuIncrDBList"
 ;k ^%SYS("BACKUPLIST","CumulativeIncrementalDBList")
 ;take care of the very first time
 i context="" d
 . s set=0 
 . f  s set=$o(setdef(set)) q:set=""  d:'$d(^SYS("BACKUPTASK",set))
 . . s ^SYS("BACKUPTASK",set)=set_"^"_setdef(set)
 . ;always set FullAllDatabases first and in this order
 . f i=1:1:4 s data=data_$$List1($p(setdef(0),"^",i))_del1
 f  s bckset=$O(^SYS("BACKUPTASK",bckset)) d  Quit:stop
 . i bckset="" s stop=1,return=0,context="" Quit
 . q:$d(setdef(bckset))  ;system designed tasks have already been set.
 . s data=data_$$List1(bckset)_del1
 . i $l(data)>size s context=bckset,stop=1 quit
  Quit return
ListErr ;error
 Q 0_$c(22,35,1)_"Unable to fetch backup set definitions!"_$s($ZE'="":$c(13,10,10)_"$ze="_$ZE,1:"")                
 ;
List1(set)      ; translate into displayable form
 s rec=$g(^SYS("BACKUPTASK",set))
 ;i rec="",set="Custom" q set
 s type=$p(rec,"^",2)
 s type=$s(type=0:"Full",type=1:"Incremental",type=2:"Cumulative",1:"")
 s $p(rec,"^",2)=type
 q rec
cvtdate(datetime)       ; convert $h style date into displayable date and time
 ; date style: mmm dd yyyy
 ; time style: hh:mmAM or PM
 q:datetime="" ""
 q $zdate(datetime,6)_" "_$zt($p(datetime,",",2),4)
SetLast(setname)        ; set the last run date and time, status
 ; also update the last file name
 ;return value:
 ;       success/failure flag
 q:setname="" 0
 s $p(^SYS("BACKUPTASK",setname),"^",8)=$$cvtdate($h)
 s $p(^SYS("BACKUPTASK",setname),"^",9)="Running"
 s ^SYS("BACKUPTASK",setname,"LASTFILE")=$$getname(setname)
 q 1
getname(setname)        ;get file name
 ;this is also called from GUI to display new file name
 ;on the backup window
 n last,file
 s last=$G(^SYS("BACKUPTASK",setname,"LASTFILE"))
 s file=$$NextName(last)
 q file
NextName(oldname)  ;
 n curdate,olddate,seqnum
 s curdate=$zd($h,8),olddate=$e(oldname,1,8),seqnum=$e(oldname,10,*)
 i olddate=curdate q curdate_"_"_$s(seqnum<99:$e(seqnum+1001,2,4),1:seqnum+1)
 e  q curdate_"_001" ;including the case oldname=""

Wsdba^INT^1^67214,47331
Wsdba ;System Management database functions part 2
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
maskincl(mask,item,ext) New e,i,include,m,m1,m2
 Set include=0,ext=$ZCVT($g(ext,""),"U")
 For i=1:1 Set m=$p(mask,";",i),e="" Quit:m=""  Do:m'["'"  Quit:include
 . Set:m["." m=$$ParseRoutineName^%R(m,.e),e=$s(e="*":"",e="SRC":".INC.MAC.INT.BAS",e="":"",1:"."_e)
 . If m["*" Do  Quit
 . . Set m=$p(m,"*")
 . . If m=$e(item,1,$l(m)),(e=""!(e[ext)) Set include=1 Quit
 . If m[":" Do  Quit
 . . Set m1=$p(m,":"),m2=$p(m,":",2)
 . . If m1=$e(item,1,$l(m1))!(item]m1) Do
 . . . If m2=$e(item,1,$l(m2))!(m2]item) Do
 . . . . Set:e=""!(e[ext) include=1
 . If m=item,(e=""!(e[ext)) Set include=1 Quit
 If include,mask["'" For i=1:1 Set m=$p(mask,";",i),e="" Quit:m=""  Do:m["'"  Quit:'include
 . Set m=$e(m,2,*)
 . Set:m["." m=$$ParseRoutineName^%R(m,.e),e=$s(e="*":"",e="SRC":".INC.MAC.INT.BAS",e="":"",1:"."_e)
 . If m["*" Do  Quit
 . . Set m=$p(m,"*")
 . . If m=$e(item,1,$l(m)),e=""!(e[ext) Set include=0
 . If m[":" Do  Quit
 . . Set m1=$p(m,":"),m2=$p(m,":",2)
 . . If m1=$e(item,1,$l(m1))!(item]m1) Do
 . . . If m2=$e(item,1,$l(m2))!(m2]item) Do
 . . . . Set:e=""!(e[ext) include=0 ; SJ bug fix
 . If m=item,(e=""!(e[ext)) Set include=0 Quit
 Quit include
BldInfo(db,status)  ;build info about databases
 ;inputs:
 ;  db = one of the following:
 ;    - database directory name: build for this database
 ;    - null: build for all databases, kill off ^%SYS("database")
 ;    - 1: build for all databases, do not kill off ^%SYS("database")
 ;  status = flag to post status (0/1)
 ;return value:
 ;  none
 ;
 ; ^%SYS("database") = last build run information
 ;       P1:  1 complete
 ;            0 error during build
 ;           -1 current database (running)
 ;       P2:  time and date the build is run
 ;           $ze if P1=0
 ; ^%SYS("database",0) = all database calculation 
 ;       P1:  $H of start
 ;       P2:  $H of finish
 ;       P3:  date and time of finish in display format
 ; ^%SYS("database",database_dir) = database size information 
 ;       P1:  current size
 ;       P2:  current percent
 ;       P3:  max size
 ;       P4:  max percent
 ;       P5:  $H of calculation finish for this database
 ;       P6:  date and time of finish in display format
 ; Note: It is intended to maintain backward compatibility for V2.x  
 n (db,status,%UI)
 Lock +^%SYS("database"):2 i '$t q  ;already running
 s $ze="",$zt="BldInfoErr"
 s return=1
 s db=$g(db)
 k:db="" ^%SYS("database")       ;start from scratch
 s:db=1 db=""                    ;update all databses, but don't kill entire global
 s dirsys=$g(^SYS("GREDIR","NSACT"))
 q:dirsys=""                    ;this should never happen
 i db'="",'$d(^%SYS("database",db)) s db=$zu(12,$p($g(^SYS("GREDIR","DSLOC","master",dirsys,db)),$c(1),1))
 s del=$$del2^%Wprim
 k %UI("CANCEL")
 s %UI=$g(%UI,"GUI")
 ;take care of one database
 i db'="" d  q
 . s dir=db 
 . d BldInfo2
 . Lock -^%SYS("database")
 ;the following code deals with all databases
 ;stamp starting date/time for calculating all databases
 s ^%SYS("database",0)=$H
 s dir=""
 f  s dir=$$GetNextDatabaseByUCI^%SYS.CONFIG(dir) q:dir=""  d  q:'return
 . i db'="",db'=dir q       ;skip if not selected db
 . d BldInfo2
 ;stamp finishing date/time for calculating all databases
 s ^%SYS("database",0)=^%SYS("database",0)_$c(22,35,1)_$H_$c(22,35,1)_%TIM_", "_$zdate($h,6)_"."
 Lock -^%SYS("database")
 q
BldInfo2        ; break out from the for loop so that
 ; it works when jobbed off from List
 Do
 . Set ^%SYS("database")=-1_$c(22,35,1)_dir
 . Set $ZTrap="BldI2^Wsdba"
 . Set rc=$$GetDatabaseInfo^%SYS.DATABASE(dir,.%zu)
 . If rc'=1 Quit
 . Set blksize=$Piece(%zu,",",2)
 . Set cursize=$Piece(%zu,",",4)
 . Set curpct=""
 . If $Piece(%zu,",",6)=0 Do   ;use max database size in blocks
 . . If blksize=2048 Set $Piece(%zu,",",6)=8388096
 . . Else  Do
 . . . ; From GMaxBlks[] in blsize.h
 . . . Set mapsize=$Case(blksize,4096:0,8192:31,16384:31*3,32768:31*7,65536:31*15)+30*1024
 . . . Set max=65536*65536-1/mapsize-1\1*mapsize
 . . . Set $Piece(%zu,",",6)=max
 . Set maxsize=$Piece(%zu,",",6)
 . Set maxpct=""
 . Set %FREE=0
 . If blksize=2048 Do
 . . Open 63:"^^"_dir
 . . Set %Max=cursize*1048576/2048/400\1
 . . For Map=0:1:%Max-1 View 400*Map+1 Do
 . . . If status,Map#100=0 Do  ;report status, keep MVB from timing out
 . . . . Do DoEvents^%CDSrv
 . . . If $v(2046,0,2)<400,$View(2040,0,2)=21845 Set %FREE=%FREE+$v(2046,0,2)
 . . Close 63
 . Else  Do
 . . ;here goes the $ZU call that Laura will write to count in-use blocks.
 . . Set x=$$GetFreeCount^%SYS.DATABASE(dir,.y,.%FREE)
 . Set %FREE=%FREE*blksize/1048576
 . Set curpct=$Justify((cursize-%FREE)/cursize,0,4)
 . Set maxpct=$Justify(cursize-%FREE/(maxsize*blksize/1048576),0,4)
 . Do INT^%T
 . Set ^%SYS("database",dir)=$Justify(cursize,0,0)_del_curpct_del_$Justify(maxsize,0,0)_del_maxpct_del_$Horolog_del_%TIM_", "_$ZDate($Horolog,6)_"."
 . Quit
BldI2 . Close 63
 . Set ^%SYS("database",dir)=$ZE
 . Lock
 . Quit
 Do INT^%T
 Set ^%SYS("database")=1_$c(22,35,1)_%TIM_", "_$ZDate($Horolog,6)_"."
 Quit
BldInfoErr      ;
 s ^%SYS("database")=0_$c(22,35,1)_$ze
 Lock
 q
 ;
DbIsMounted(glo)  ;get info about databases
 ;inputs:
 ;  glo = global to check (optional, use this consider mapping)
 ;return value:
 ;  success/failure flag (0_message=failure, 1=success)
 ;
 New (%UI,glo)
 Set $ze="",$zt="DbIMErr",status=0,glo=$g(glo)
 ;test local default database
 If glo="",$$defsys^%SYS.GLO($namespace)="" Do  Quit status
 . Set status=$p($zu(49,$$defdir^%SYS.GLO($namespace)),",",1)
 . Set status=$s(status>($zu(40,0,41)-1):0,status<0:0,1:1)
 ;test mapping
 Set netHard=$zu(68,27,0) ;turn off network hardening
 ;check db status by trying to access a global
 If glo="" Set glo="^k1z9foo"
 Set dummy=$d(@glo)
 If $ze="" Set status=1
DbIMErr If $g(netHard) Do $zu(68,27,1) ;restore to original state
 Quit status
 ;
GetInfo(asof)  ;get info about databases
 ;inputs:
 ;  asof = date of last $$BldInfo(), passed by reference
 ;return value:
 ;  success/failure flag (0_message=failure, #databases=success)
 ;output record:
 ;  name, mount status, current size, pct, max size, pct
 ;
 n (%UI,asof)
 s $ze="",$zt="GetInfoErr"
 s return=1
 s (dir,str)=""
 s del=$$del2^%Wprim
 k %UI("CANCEL")
 s %UI=$g(%UI,"GUI")
 f  s dir=$O(^%SYS("database",dir)) q:dir=""  d  q:'return
 . s stat=$P($zu(49,dir),",",1)
 . s mount=$s(stat<0:0,1:1)
 . i '$zu(40,2,95) s clust=5
 . i $zu(40,2,95) d
 . . s clust=$p($zu(49,dir,1),",",3) 
 . . i clust="S" s clust=3
 . . e  s clust=5
 . s out=dir_"iris"_".dat"_del_mount_del_clust_del_^%SYS("database",dir)
 . i $$callback^%Wprim(0,"",out) s return=0
 i return,$$callback^%Wprim(1,"","") s return=0
 s asof=$g(^%SYS("database"))
 q 1
GetInfoErr      ;
 Q 0_$c(22,35,1)_"Can not fetch database information for "_dir_$s($ZE'="":$c(13,10,10)_"$ze="_$ZE,1:"")
 ;
List(data,context)  ;get info about databases for Control Panel
 New (data,context)
 Set context=$g(context)
 Set $ze="",$zt="ListErr"
 Set data="",stop=0,return=1,size=30000
 Set prev=context
 Set rs=##class(%Library.ResultSet).%New("Config.Databases:CompactLocalDBList")
 Do rs.Execute()
 For  s rnext=rs.Next() Do  Q:stop
 . If rnext=0 Set stop=1,return=0,context="" Quit
 . Set dirnm=rs.Data("Name"),dir=rs.Data("Directory")
 . I prev'="" Q:dirnm'=prev  s prev="" Quit
 . Set data=data_dirnm_$c(19,94,1)_rs.Data("Directory")_$c(19,94,1)_rs.Data("ReadOnly")_$c(19,94,1)_rs.Data("SFN")_$c(22,35,1)
 . If $l(data)>size Set context=dirnm,stop=1 Quit
 Quit return
ListErr ;error
 Q 0_$c(22,35,1)_"Unable to fetch database information!"_$s($ZE'="":$c(13,10,10)_"$ze="_$ZE,1:"")                
 ;
ListStat(dir) ;return mounted status
 n sfn
 s sfn=+$zu(49,dir)
 q:sfn>-1&(sfn<$zu(40,0,41)) 1    ;"mounted"
 q:sfn=$zu(40,0,41) 0             ;"not mounted"
 q:sfn=-1 -1             ;"dismounted"
 q:sfn=-2 -2             ;"no such database"
 q 0                     ;"other result, database not mounted"
 ;
NmLoc(nm)       ;return database location for namespace
 Quit:nm="" 0
 N (nm)
 Set dirsys=$G(^SYS("GREDIR","NSACT"))
 Quit:dirsys="" 0
 Set loc=$G(^SYS("GREDIR","NSCONF",dirsys,"name-space",nm,"defloc"))
 Quit $P(loc,$C(1))
 ;
UpdInfo(chk)    ; Update database information from Control Panel.
 ; If chk is equal to 1, we are checking lock only
 ; If it is equal to "All", we are to update all databases
 ; Else, we are to update one or multiple databases
 ; 
 n return
 s return=1
 i chk=1 d  q return
 . Lock ^%SYS("database"):2 i '$t s return=0 q
 . Lock  ;unlock
 . s return=$p($g(^%SYS("database",0)),$c(22,35,1),3)
 i chk="All" d  q return
 . Job BldInfo^Wsdba(1,0)::2
 Quit return
UpdInfoI(chk)   ; Update selected databases (jobbed from Control Panel)
 n dir,i
 s dir=""
 f i=1:1 s dir=$p(chk,",",i) q:dir=""  d
 . d BldInfo^Wsdba(dir,0)
 q
 ;
UpdTime(dbs)    ; Return the earliest finishing time
 ; Called from Control Panel before commit to calculate 
 ; selected database sizes.
 ; Input:  one or a list of database names,
 ; Output: the earliest finishing time
 n (dbs)
 s del2=$c(19,94,1)
 s dirsys=$g(^SYS("GREDIR","NSACT"))
 q:dirsys="" ""         ;this should never happen
 f i=1:1 s dbname=$p(dbs,",",i) q:dbname=""  d
 . s dbdir=$zu(12,$p($g(^SYS("GREDIR","DSLOC","master",dirsys,dbname)),$c(1),1))
 . s time=$p($g(^%SYS("database",dbdir)),del2,5) ;$H
 . q:time=""
 . s ftime($tr(time,",",""))=$p(^(dbdir),del2,6) ;date/time in displayable format
 i '$d(ftime) q ""
 s time=$o(ftime(0))     ;get the earliest date/time
 q ftime(time)           ;return the displayable date/time
Dismount(dir) ;dismount a database
 ;inputs:
 ;  dir = directory containing M database
 ;
 ;return value:
 ;  status flag (1=success; 0=failure)
 ;
 n (dir)
 s $ZE="",$zt="DismErr^Wsdba"
 s del=$$del2^%Wprim
 s dir=$zu(12,dir)
 s dummy=0
 i $ZU(36,dir)=$ZU(12) g DismErr
 s dummy=$ZU(3,dir)
 i dummy<0 g DismErr
 Q 1
DismErr ;error
 ; If dummy=0 and $ze="" then they tried to dismount the manager's
 ; database and we're not going to allow that. Otherwise one or the
 ; other contains the error related to why the dismount failed.
 ;
 s msg=0_$c(22,35,1)_"Unable to dismount "_dir
 i $ZE="",dummy=0 q msg
 s msg=msg_$C(13,10)_" because "
 s msg=msg_$S($ZE'="":"$ze="_$ZE,1:$$MSG^%DKIOERR(dummy))
 q msg
 ;
Mount(dir,CLUSFLAG) ;mount a database
 ;inputs:
 ;  dir = directory containing M database
 ;
 ;return value:
 ;  status flag (1=success; 0=failure)
 ;
 n (dir,CLUSFLAG)
 Set blksize=$Piece($Zutil(49,dir),",",2)
 Set blkix=$case(blksize,2048:0,4096:1,8192:2,16384:3,32768:4,:5)
 If '$case($v(blkix*$ZU(40,0,1)+$zu(40,2,128),-2,$ZU(40,0,1)),4294967295:0,:1) Quit 0_$c(22,35,1)_"Unable to mount "_dir_" because"_$C(13,10)_"there are no "_(blksize\1024)_"KB buffers (or bigger) configured."
 Quit ##class(SYS.Database).MountDatabase(dir,,CLUSFLAG)
 ;
DBBuildInfo	New lastfinish
 If '$g(^%SYS("database"),0) Job BldInfo^Wsdba("",0)::2 Quit
 ;if this is the first click for the day, calculate all database sizes.
 If $g(^%SYS("database",0)) d
 . s lastfinish=$p(^%SYS("database",0),$c(22,35,1),2)
 . q:lastfinish=""       ;don't job it if last run did not finish
 . i +$h>lastfinish Job BldInfo^Wsdba(1,0)::2
 Else  Job BldInfo^Wsdba(1,0)::2
 Quit

XMM^INT^1^67214,47331
XMM ;
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
again
    w !,"Extended Memory Diagnostics",!
    w "1. Analyse an extended memory trace file.",!
    w "2. Display current extended memory values.",!
    w "3. Dump extended diagnostic information.",!
    w "4. Dump verbose extended diagnostic information.",!
    w "5. Purge trace files.",!
    w "Q. Quit",!
    r "Enter option : ",ans,!  r dummy:0
    s ans=$zstrip($zcvt(ans,"U"),"<>W")
    if (ans="1") {
    	; Analyse an extended memory trace file
	r "Enter name of trace file to be analysed : ",tracefile,!
	s tracefile=$zstrip(tracefile,"<>W")
	goto:tracefile="" again
	w "Enter a start and end boundaries delimited by ^ or , or - (optional) "
	r boundary,!
	s boundary=$zstrip(boundary,"<>W")
	w "Enter any regular expressions as filters (optional) "
	r filter,!
	s filter=$zstrip(filter,"<>W")
opt	w "Enter any options (optional) "
	r options,!
	s options=$zstrip(options,"<>W")
	if options="?" {
		w "  A - Summarise all memory allocations",!
		w "  H,B,M - Include Heap, Buddy blocks, Memory maps",!
		w "  C - Sort by Calls instead of size",!
		w "  I - Ignore errors",!
		w "  F - Display memory not freed at the end",!
		w "  V - Verbose output at end of analysis",!
		w "  S{nn} - Summary every nn lines (default 1000)",!
		w "  D - For 'S' show the delta",!
		w "  E - Expand usage displays to show a drill-down; should increase Tnn",!
		w "  Tnn - Set depth of Top reports (default 20)",!
		w "  P{nn} - Summarise usage at Peak or every time peak changes by nn",!
		w "  For complete details see the source code",!!
		goto opt
	}
	do al(tracefile,boundary,filter,options)
    } elseif (ans="2") {
    	; Display extended memory values
	do mem
    } elseif (ans="3") {
    	; Dump extended information
	d diag(0)
    } elseif (ans="4") {
    	; Dump verbose extended information
	d diag(1)
    } elseif (ans="5") {
    	; Purge trace files
	w "Process ID to purge (* means all)      : "  r pid,!
	s:$g(pid)="" pid=$J
	w "Depth of entries to remove (default 2) : "  r depth,!
	s:$g(depth)="" depth=2
	w "Verbosity level 0,1 or 2 (default 1)   : "  r verbose,!
	s:$g(verbose)="" verbose=1
	w !
	d purge(pid,depth,verbose)
    } elseif (ans="Q")||(ans="") {
    	q
    } else {
    	w "Unknown option.",!
    }
    goto again
al(filename="", boundary="" , filter="", options="",outputfile="",snapshots="") [] PUBLIC {
    set stats=$zu(187,4,1),trace=$p(stats,",",16)
    if (trace>0) {
    	w "Warning: Memory tracing is still turned on.",!
	w "This could affect the operation of this routine if",!
	w "  you are still udpating the same trace file.",!
	w "Do you wish to continue [N] ? "
	r ans,!
	s ans=$zstrip($zcvt(ans,"U"),"<>W")
	q:((ans'="Y")&&(ans'="YES"))
    }
    set options=$zcvt(options,"U")
    set optionP=$f(options,"P") , optionV=$f(options,"V") , optionA=$f(options,"A") , 
    	optionC=$f(options,"C") , optionF=$f(options,"F") , optionS=$f(options,"S"),
	optionI=$f(options,"I") , optionT=$f(options,"T") , optionD=$f(options,"D"),
	optionH=$f(options,"H") , optionB=$f(options,"B") , optionM=$f(options,"M"),
	optionE=$f(options,"E")
    ; Get numeric arguments for a couple of the options
    set (optionSBegin,optionSEnd)=0
    set optionSFrequency=$$getNumericArgument(options,optionS,1000,.optionSBegin,.optionSEnd)
    set optionTDepth=$$getNumericArgument(options,optionT,20)
    if ('$l(filename)) { w "Error. You must specify a file name as the first parameter",!  q }
    close filename
    open filename:"R":0
    if ('$T) { w "Unable to open input file "_filename,!  q }
    if (outputfile'="") {
    	open outputfile:"WN":0
	if ('$T) { w "Unable to open output file "_outputfile,!  q }
    }
    ;
    ; See if we have any boundaries.
    ;
    set optionBoundary=0, boundaryFlag = 1
    if (boundary'="") {
    	; Check boundaries delimited by "^" or "-" or ","
	set delim=$S($f(boundary,"^"):"^",$f(boundary,","):",",1:"-")
    	s boundaryStart=$p(boundary,delim,1) , boundaryEnd=$p(boundary,delim,2)
	if ((boundaryStart?1N.N)||(boundaryEnd?1N.N)) {
	    ; Numeric start end end -- line numbers.
	    s:(boundaryStart="") boundaryStart=1
	    s:(boundaryEnd="") boundaryEnd=999999999999
	    s optionBoundary=1
	    w " from line "_boundaryStart_" to line "_boundaryEnd
	} else {
	    ; Non-numeric, must be labels
	    s optionBoundary=2
	    w " from label "_boundaryStart_" to label "_boundaryEnd
	    s:'$l(boundaryStart) boundaryStart=$c(255,255),boundaryFlag=0
	    s:'$l(boundaryEnd) boundaryEnd=$c(255,255)			// Needs something for $locate()
	}
    }
    set (filterI,filterX,filterT)=0
    if (filter'="") {
    	set filterT=$l(filter,"^")			// Count number of filters to apply
	for filterNext=1:1:filterT {			// For each defined filter
	    set filter2=$p(filter,"^",filterNext)	// Extract next filter
	    if ($e(filter2)="-") {			// If true it is an exclusion filter
	    	set idx=$I(filterX), filterX(idx)=$e(filter2,2,*)
	    } else {					// Must be an inclusion filter.
	    	set idx=$I(filterI), filterI(idx)=filter2
	    }
	}
    }
    if (optionH||optionB||optionM) {
    	set analyseBuddy=optionB,analyseHeap=optionH,analyseMap=optionM
    } else { set analyseBuddy=1,analyseHeap=0,analyseMap=0}
    set snapshotsCount = 0
    if (snapshots '= "") {
	set snapshotsCountLines=$$CountLines(.filename,1)
	q:(snapshotsCountLines<=0)
    	set snapshotsCount = $l(snapshots,",")
	for snapshotsNext = 1:1:snapshotsCount {
	    set lineno = $p(snapshots,",",snapshotsNext)
	    if ($e(lineno,$l(lineno))="%") {		// Want a percentage
		set lineno=snapshotsCountLines*$e(lineno,1,$l(lineno)-1)\100
	    }
	    set snapshots(snapshotsNext)=lineno
	}
    }
    set peakBytesInUse = 0 , peakBytesAtLineNo = 0 
    set IOSAVE=$IO
    set IOOUT=$SELECT(outputfile="":$IO,1:outputfile)
    set IOIN=filename
    use IOIN   set dummp=$zseek(0)  use IOOUT
    set lineno = 0, errcount = 0, startTime = $zh , $ZE="", currentBytesInUse = 0, err=0
    set optionSDone = 0 , optionSHeader = 0
    set linesparsed = 0
    set allocations = 0 , frees = 0 
    set (prevAllocations,prevFrees,prevCurrentBytesInUse)=0
    kill lines,linesAllCache,linesAllRoutine,linesPeak
    try {
    	use IOOUT
	w "Analysis started on file "_filename_" at "_$zt($p($h,",",2))_" "_$zd($p($h,","),2),!
	use IOIN
	set dummp=$zseek(0) 
	for {
	    read line  
	    s lineno=lineno + 1
	    s line=$zstrip(line,"<>W")
	    ; Ignore blank lines and comment lines
	    continue:('$l(line))||($e(line)="#")
	    ;
	    ; See if boundaries are in effect
	    ;
	    if (optionBoundary) {
	    	if (optionBoundary=1) {
		    ; Numeric line numbers
		    continue:((lineno<boundaryStart)||(lineno>boundaryEnd))
		} else {
		    ; Alphanumeric labels.
		    if ($locate(line,boundaryStart)) {
		    	; Found the start tag, about to go inside the boundary
			set boundaryFlag=0
		    } elseif ($locate(line,boundaryEnd)) {
		    	; Found the end tag, about to go outside the boundary
			set boundaryFlag=1
			q
		    } else {
		    	; The value 'boundaryFlag' is set to 1 when outside the
			; boundary or '0' when inside the boundary.
			continue:boundaryFlag
		    }
		}
	    }
	    ;
	    ; See if the filter is going to prevent some lines being parsed.
	    ;
	    if (filterT) {
		if (filterI) {
		    ; Must contain one or more of the inclusion filters.
		    set continueline=0
		    for i=1:1:filterI { 
		    	if ($locate(line,filterI(i))) { set continueline=1  q }
		    }
		    continue:'continueline
		}
		if (filterX) {
		    ; Must NOT contain any of the exclusion filters.
		    set continueline=1
		    for i=1:1:filterX { 
		    	if ($locate(line,filterX(i))) { set continueline=0  q }
		    }
		    continue:'continueline
		}
	    }
	    ;
	    set linesparsed = linesparsed + 1
	    ;
	    ; Display summary of status every 'nnn' lines if necessary.
	    ;
	    if (optionS) {
	    	if ((optionSBegin<=0)||((lineno>=optionSBegin)&&(lineno<=optionSEnd))) {
		    set optionSDone = optionSDone+1
		    if (optionSDone >= optionSFrequency) {
			; Display the statistics at this point in the file.
			; Use of the "D" option means we show the delta between
			; the operations, not the current value.
			if (optionD) {
			    s showAllocations=allocations-prevAllocations,
				    showFrees=frees-prevFrees,
				    showCurrentBytesInUse=currentBytesInUse-prevCurrentBytesInUse,
				    prevAllocations=allocations,
				    prevFrees=frees,
				    prevCurrentBytesInUse=currentBytesInUse
			} else {
			    s showAllocations=allocations,showFrees=frees,showCurrentBytesInUse=currentBytesInUse
			}
			set msg=$fn(lineno,","), $e(msg,16)=$fn(showAllocations,","),
			    $e(msg,32)=$fn(showFrees,","),$e(msg,48)=$fn(showCurrentBytesInUse,","),
			    optionSDone=0
			use IOOUT    
			if ('optionSHeader) {
			    write !,"Line Number    Allocations     Frees           In Use",!
			    set optionSHeader = 1
			}
			write msg,!    
			if (optionV) {
			    do convertLines(.lines,.ctr,.totalBytes,.xrefCache,.xrefRoutine,1,0,optionE)
			    d sortLines(.xrefCache,0,optionC," allocations at line "_$fn(lineno,","), "Source",optionTDepth,optionE)
			    d sortLines(.xrefRoutine,0,optionC," allocations at line "_$fn(lineno,","), "Routine Name",optionTDepth,optionE)
			}
			use IOIN
		    }
		}
	    }
	    ;
	    ; See if we are performing snapshots
	    ;
	    for snapshotsNext=1:1:snapshotsCount {
	    	set nextlineno = snapshots(snapshotsNext)
		if (nextlineno <= lineno) {
		    use IOOUT    
		    set snapshots(snapshotsNext) = 9999999999999
		    set msg = " allocations at line "_$fn(lineno,",")_" ("_$fn(lineno/snapshotsCountLines*100,"",2)_" %)"
		    do convertLines(.lines,.ctr,.totalBytes,.xrefCache,.xrefRoutine,1,0,optionE)
		    d sortLines(.xrefCache,0,optionC,msg, "Source",optionTDepth,optionE)
		    d sortLines(.xrefRoutine,0,optionC,msg, "Routine Name",optionTDepth,optionE)
		    use IOIN
		}
	    }
	    ;
	    ; The format of the lines can be one of the following
	    ; If op is within ROUTINE, address is the offset, else the full op value
	    ; If no current routine, ROUTINE is empty
	    ;
	    ; BuddyAlloc 0000023FB1B51448 size 8 scope 0 op address ROUTINE : LINENO 1980, MODID 23
	    ; BuddyFree  0000023FB1B51448 size 8 scope 0 op address ROUTINE : LINENO 1875, MODID 23
	    ;
	    ; HeapAlloc 0000023FB1B51448 size 8 op address ROUTINE : LINENO 536, MODID 165
	    ; HeapFree  0000023FB1B51448 size 8 op address ROUTINE : LINENO 788, MODID 165
	    ;
	    ; Mmap 0000023FB1B00000 size 16777216 op address ROUTINE : LINENO 3035, MODID 172
	    ; Munmap 0000023FB1B00000 size 16777216 op address ROUTINE : LINENO 3103, MODID 172
	    ;
	    ; PushScope scope 2 mapcollection 0 op address ROUTINE
	    ; PopScope scope 2 op address ROUTINE
	    ;
	    ; CreateMapCollection mapcollection 0, max memory 2199023254528, map type 1, map size 16777216 op address
	    ;
	    s p1=$p(line," ",1)
	    ;
	    ; Remove redundant spaces
	    ;
	    for {
		s offset=$f(line,"  ",1)
		q:'offset  q:offset>16
		s $e(line,offset-2,offset-1)=" "
	    }
	    set addr = $p(line," ",2), size = $p(line," ",4), source = $p(line,":",*)
	    set scope = $s(p1["Buddy":$p(line," ",6),p1["Scope":$p(line," ",3),1:0)
	    set routine = $p(line," ",$case($e(line,1,4),"Heap":7,"Budd":9,:99))
	    ;
	    ; Find out what sort of entry we have.
	    ;
	    set %filename=filename
	    set opcode = $$parseopcode(.p1 , .size , .bytesize)
	    ;
	    ; Check what sort of memory operation was performed.
	    ;
	    if (((opcode = 2) && analyseBuddy) || 
	    	((opcode = 3) && analyseMap) ||
	    	((opcode = 1) && analyseHeap)) {
	    	; Allocated a space. See if it already exists.
	    	set data = $g(lines(addr),"")
		if ($l(data)) {
		    if ('optionI) {
			use IOSAVE
			w "Error at line number "_lineno_": Address "_addr_" is already allocated",!
			w "    Originally allocated at line number "_$lg(data,4),!
			s errcount=errcount+1
			use IOIN
		    }
		    continue
		}
		;
		; Add to the following local arrays...
		;   lines()             Contains all the current allocated memory space
		;   linesPeak()         Copy of lines() if this is our peak memory usage
		;   linesAllCache()     Contains all the spaces ever allocated, sorted by kernel source name
		;   linesAllRoutine()   Contains all the spaces ever allocated, sorted by application routine name
		;
		s lines(addr) = $lb(size,scope,source,lineno,routine,opcode)
		s currentBytesInUse = currentBytesInUse + bytesize
		set allocations = allocations + 1
		if (optionA) {
		    if (source '= "") {
			set linesAllCache(source,1) = $g(linesAllCache(source,1),0) + 1
			set linesAllCache(source,2) = $g(linesAllCache(source,2),0) + bytesize
		    }
		    if (routine '= "") {
			set linesAllRoutine(routine,1) = $g(linesAllRoutine(routine,1),0) + 1
			set linesAllRoutine(routine,2) = $g(linesAllRoutine(routine,2),0) + bytesize
		    }
		}
		if (currentBytesInUse>peakBytesInUse) {
		    set peakBytesInUse=currentBytesInUse,peakBytesAtLineNo=lineno
		    if (optionP) {			// Display peak usage at end of analysis
			kill linesPeak
			merge linesPeak = lines
		    }
		}
	    } elseif (((opcode = 5) && analyseBuddy) || 
	    	((opcode = 6) && analyseMap) ||
	    	((opcode = 4) && analyseHeap)) {
	    	;
		; Check the address actually exists to be freed.
		;
	    	set data = $g(lines(addr),"")
		if ('$l(data)) {
		    if ('optionI) {
			use IOSAVE
			w "Error at line number "_lineno_": Address "_addr_" cannot be found to be freed.",!
			s errcount=errcount+1
			use IOIN
		    }
		    continue
		}
		;
		; Check consistency of the freed address, i.e. scope and size the same.
		;
		s origScope = $lg(data,2) , origSize = $lg(data,1), origOpcode = $lg(data,6)
		set frees = frees + 1
		if ((opcode = 5) && (origScope '= scope)) {
		    if ('optionI) {
			use IOSAVE
			w "Error at line number "_lineno_" during FREE: Scopes differ from allocation to release.",!
			w "    Originally allocated at line number "_$lg(data,4),!
			use IOIN
			s errcount=errcount+1
		    }
		}
		if (origSize '= size ) {
		    if ((origSize>1)||(size>1)) {
		    	if ('optionI) {
			    use IOSAVE
			    w "Error at line number "_lineno_" during FREE: Sizes differ from allocation to release.",!
			    w "    Originally allocated at line number "_$lg(data,4),!
			    use IOIN
			    s errcount=errcount+1
			}
		    }
		}
		;
		; Remove this address from the lines() array which is memory currently in use.
		;
		kill lines(addr)
		s currentBytesInUse = currentBytesInUse - bytesize
	    } elseif (opcode = 8) {
		s scope=$p(line," ",3)
		;
		; Remove all buddy block entries for this scope level
		;
		s key=$O(lines(""),1,data)
		while (key'="") {
		    s thisscope = $lg(data,2)
		    if (thisscope=scope) {
		    	set origOpcode=$lg(data,6)	// Check if buddy block or heap space
			if (origOpcode=2) {
			    kill lines(key)
			    set bytesize = $lg(data,1)
			    s currentBytesInUse = currentBytesInUse - bytesize
			}
		    }
		    s key=$O(lines(key),1,data)
		}
	    } else {
		continue
	    }
	}
    } catch ex {
	use IOSAVE
	if ($e($ZE,1,11)'="<ENDOFFILE>") {
	    w "Error reading file "_filename_" , error "_$ZE,!
	    set err=1
	}
    }
    use IOSAVE
    close filename
    USE IOOUT
    w:optionS !
    if (err) {
    	use IOSAVE
	kill IOOUT,outputfile
	q
    }
    ;
    ; Make a count of the number of memory allocations still outstanding. This
    ; is basically all the entries in the local array lines(). We optionally
    ; create a couple more local arrays as follows.
    ;     xrefCache()        List of remaining allocations sorted by Cache kernel module id and line number
    ;     xrefRoutine()      List of remaining allocations sorted by application routine name.
    ;
    do convertLines(.lines,.ctr,.totalBytes,.xrefCache,.xrefRoutine,optionF,optionV,optionE)
    ;
    ; The remaining output depends upon what options were passed to us as a parameter.
    ;
    if (optionF ) {
    	;
	; optionF means display all the allocations that remain at the end of the file.
	; By default we display 2 tables with the most allocations sorted by Cache module id/line number
	;     and by application routine name. The use of option "V" (flag optionV) means instead
	;     we display each remaining allocation indvidually.
	;
	if (optionV) {
	    w !,"The following "_$fn(ctr,",")_" memory allocations were not freed",!
	    s lineno = $ORDER(xrefCache(""),1,data), done = 0
	    while (lineno '= "") {
	    	write:((done#20)=0) !,"Line #     Size         Scope  Cache Source                 Module",!
		set done = done + 1
		set line=$lg(data,4),line=line_$j("",11-$l(line))	// Source line number
		set line=line_$lg(data,1),line=line_$j("",24-$l(line))	// Size
		set line=line_$lg(data,2),line=line_$j("",30-$l(line))	// Scope
		set line=line_$lg(data,3),line=line_$j("",60-$l(line))	// Cache source
		set line=line_$lg(data,5)				// Routine
		w line,!
		s lineno = $ORDER(xrefCache(lineno),1,data)
	    }
	} else {
	    d sortLines(.xrefCache,optionV,optionC," remaining allocations at End Of File", "Source",optionTDepth,optionE)
	    d sortLines(.xrefRoutine,optionV,optionC," remaining allocations at End Of File", "Routine Name",optionTDepth,optionE)
	}
    }
    ;
    if (optionP) {
    	;
	; optionP means display memory allocation at peak usage.
	;
	do convertLines(.linesPeak,.ctr,.totalBytes,.xrefCache,.xrefRoutine,1,optionV,optionE)
	; By default we display 2 tables with the most allocations sorted by Cache module id/line number
	;     and by application routine name. The use of option "V" (flag optionV) means instead
	;     we display each remaining allocation indvidually.
	;
	if (optionV) {
	    w !,"The following "_$fn(ctr,",")_" memory allocations were not freed at Peak Usage",!
	    s lineno = $ORDER(xrefCache(""),1,data)
	    while (lineno '= "") {
		w data,!
		s lineno = $ORDER(xrefCache(lineno),1,data)
	    }
	} else {
	    d sortLines(.xrefCache,optionV,optionC," allocations at Peak Usage", "Source",optionTDepth,optionE)
	    d sortLines(.xrefRoutine,optionV,optionC," allocations at Peak Usage", "Routine Name",optionTDepth,optionE)
	}
    }
    ;
    if (optionA) {
    	;
	; optionA means display all memory allocations ever performed.
	; By default we display a summary of all allocations in 2 ways, first by Cache module id/line number
	;    and secondly by routine application name. By default this is limited to the top 20 entries,
	;    but the use of option "V" (flag optionV) means the list is displayed in its entirity.
	;
	d sortLines(.linesAllCache,optionV,optionC,"allocations by system", "Source",optionTDepth,optionE)
	d sortLines(.linesAllRoutine,optionV,optionC,"routine allocates","Routine Name",optionTDepth,optionE)
    }
    ;
    ; End of processing stuff
    ;
    w "Completed: "_$fnumber(linesparsed,",")_" lines"
    w:(linesparsed'=lineno) " (out of "_$fn(lineno,",")_")"
    w " in "_$fnumber(($zh-startTime),",",2)_" seconds. "
    w "  ",$CASE(errcount,0:"No errors.",1:"1 error.",:errcount_" errors."),!
    if (ctr>0) {
	w "  There were "_$fnumber(ctr,",")_" memory loss entries totalling "_$fnumber(totalBytes,",")_" bytes.",!
    }
    if (peakBytesAtLineNo>0) {
	w "  Peak memory utilization occurred at line "_$fn(peakBytesAtLineNo,",")_" with "_$fn(peakBytesInUse,",")_" bytes.",!
    }
    use IOSAVE
    close IOOUT
    kill IOOUT,outputfile
    ;
    ; Finished, go home.
    ;
    q
}
csv(inputfilename="", outputfilename="" , traces="", sample="1%", options="") [] PUBLIC {
    set filecount = $l(inputfilename,",")
    open outputfilename:"WN":0
    if ('$T) { w "Unable to open output file "_outputfilename,!  q }
    set traces2 = traces
    for filenext = 1:1:filecount {
	kill traces
	set traces = traces2
    	set nextfile=$p(inputfilename,",",filenext)
	set percent = 0
	do csv2(nextfile,outputfilename,.traces,sample,options,.percent)
	do csv3(nextfile,outputfilename,.traces,percent,filenext,filecount)
    }
    close outputfilename
}
csv2(inputfilename, outputfilename , traces, sample, options,percent) [] PRIVATE {
    set options=$zcvt(options,"U")
    set optionA=$f(options,"A") , optionD=$f(options,"D") , optionF=$f(options,"F"),
    	optionB=$f(options,"B") , optionH=$f(options,"H") , optionM=$f(options,"M")
    if ('$l(inputfilename)) { w "Error. No input file name specified",!  q }
    if ('$l(outputfilename)) { w "Error. No output file name specified",!  q }
    if ('$l(traces)) { w "Error. No traces specified",!  q }
    open inputfilename:"R":0
    if ('$T) { w "Unable to open input file "_inputfilename,!  q }
    ;
    ; Parse the data in the 'traces' parameter. It specifies what to look for.
    ; The trace specification can contain a number of definitions separater by ","
    ; for example "MODID 170,MODID 3"
    ; In this example we will include all traces that include the string (regular expression)
    ;    "MODID 170" OR "MODID 3". On the output csv, the labels for the lines will be the same.
    ; The second expression can contain a number of expressions for each trace definition that are
    ;    separated by |. For example "PTRIE|MODID 170|MODID 3,All Memory|.*". In this example we
    ;    will output a CSV with 2 rows, the first row will have a label "PTRIE" and will contain
    ;    all the data with "MODID 170" OR "MODID 3" in it. The second row will have a label "All Memory"
    ;    and will contain the data which matches the regular expression ".*" i.e. all lines.
    ;
    set tracesCount=$l(traces,","),err=0
    for tracesNext=1:1:tracesCount {
    	set expression = $p(traces,",",tracesNext)	// E.G. "MODID 170" , E.G. "PTRIE|MODID 170|MODID 3"
	set expressionCount=$l(expression,"|")		// Find if there is a | modifier
	// Check the regular expressions are valid and don't give an error later.
	try {
	    for i=1:1:expressionCount { s nxtexpr = $p(expression,"|",i) , dummy=$locate("xxx",nxtexpr) }
	} catch ex {
	    write ex.Name_" error with """_nxtexpr_"""",!
	    set err = 1
	}
	q:err
	if (expressionCount=1) {			// If true, there are no | modifiers and is a simple trace
	    set traces(tracesNext,1) = 1		// Number of expression to evaluate
	    set traces(tracesNext,2) = expression	// The label, default to same as the expression
	    set traces(tracesNext,3,1) = expression	// The only single regular expression to evaluate
	} else {
	    set traces(tracesNext,1) = expressionCount-1 // Number of expression to evaluate
	    set traces(tracesNext,2) = $p(expression,"|",1)	// The first expression is the row label
	    for i=2:1:expressionCount { set traces(tracesNext,3,i-1)=$p(expression,"|",i)}	// Set expressions
	}
    }
    q:err
    if (optionH||optionB||optionM) {
    	set analyseBuddy=optionB,analyseHeap=optionH,analyseMap=optionM
    } else { set analyseBuddy=1,analyseHeap=0,analyseMap=0}
    ;
    w "Analysis started on file "_inputfilename,!
    set IO=$IO
    use inputfilename   set dummp=$zseek(0)  use IO
    set lineno = 0, errcount = 0, startTime = $zh , $ZE="", err=0
    set percent = 0 
    if ($e(sample,$l(sample))="%") {
    	; We need to do a further pass to convert a percentage
	; of lines to a line count
	set sample=sample+0
	if (sample<=0) { w "Error, illegal sample value.",!  q}
	try {
	    use inputfilename
	    set dummp=$zseek(0) 
	    for {
		read line  
		s lineno=lineno + 1
	    }
	} catch ex {
	    use IO
	    if ($e($ZE,1,11)'="<ENDOFFILE>") {
		w "Error reading file "_inputfilename_" , error "_$ZE,!
		set err=1
	    }
	}
	use IO
	q:err
	set percent = sample
	set sample=lineno*sample\100
	w "First pass completed, sample set every "_$fn(sample,",")_" lines",!
    }
    set sampledelta=0, samplecount = 0, percentdone = 0
    set lineno = 0, errcount = 0, $ZE="", err=0
    kill addresses
    try {
	use inputfilename
	set dummp=$zseek(0) 
	for {
	    read line  
	    s lineno=lineno + 1
	    s line=$zstrip(line,"<>W")
	    ; Ignore blank lines and comment lines
	    continue:('$l(line))||($e(line)="#")
	    ;
	    s p1=$p(line," ",1)
	    ;
	    ; Remove redundant spaces
	    ;
	    for {
		s offset=$f(line,"  ",1)
		q:'offset  q:offset>16
		s $e(line,offset-2,offset-1)=" "
	    }
	    set addr = $p(line," ",2), size = $p(line," ",4), source = $p(line,":",*)
	    set scope = $s(p1["Buddy":$p(line," ",6),p1["Scope":$p(line," ",3),1:0)
	    set routine = $p(line," ",$case($e(line,1,4),"Heap":7,"Budd":9,:99))
	    ;
	    ; Find out what sort of entry we have.
	    ;
	    set opcode = $$parseopcode(.p1 , .size , .bytesize)
	    ;
	    ; Check what sort of memory operation was performed.
	    ;
	    if (((opcode = 2) && analyseBuddy) || 
	    	((opcode = 3) && analyseMap) ||
	    	((opcode = 1) && analyseHeap)) {
	    	; Allocated a space. 
		; For each possible trace value
		;
		for tracesNext=1:1:tracesCount {
		    ; Check all the regular expressions for this trace value
		    set usethisline = 0
		    for expression=1:1:traces(tracesNext,1) {
		    	if ($locate(line,traces(tracesNext,3,expression))) {
			    set usethisline = 1 
			    quit
			}
		    }
		    if (usethisline) {
		    	; Add this to the trace
			// (a) Total current allocations this scope
			set traces(tracesNext,4,scope,1) = $g(traces(tracesNext,4,scope,1),0) + 1
			// (b) Total current bytes this scope
			set traces(tracesNext,4,scope,2) = $g(traces(tracesNext,4,scope,2),0) + bytesize
			// (c) Total current allocations all scopes
			set traces(tracesNext,5) = $g(traces(tracesNext,5),0) + 1
			// (d) Total current bytes all scopes
			set traces(tracesNext,6) = $g(traces(tracesNext,6),0) + bytesize
			// (e) Accumulative allocations all scopes
			set traces(tracesNext,7) = $g(traces(tracesNext,7),0) + 1
			;
			; Option "F" means this will be freed automatically
			;
			if (optionF) { 
			    set addresses(scope,addr,tracesNext) = ""
			}
		    }
		}
	    } elseif (((opcode = 5) && analyseBuddy) || 
	    	((opcode = 6) && analyseMap) ||
	    	((opcode = 4) && analyseHeap)) {
	    	; Free a space
		; Option "F" means this will be freed automatically
		;
		if (optionF) {
		    for tracesNext=1:1:tracesCount {
			if ($d(addresses(scope,addr,tracesNext))) {		// See if the address exists
			    ; Remove this from the trace
			    // (a) Total current allocations this scope
			    set traces(tracesNext,4,scope,1) = $g(traces(tracesNext,4,scope,1),0) - 1
			    // (b) Total current bytes this scope
			    set traces(tracesNext,4,scope,2) = $g(traces(tracesNext,4,scope,2),0) - bytesize
			    // (c) Total current allocations all scopes
			    set traces(tracesNext,5) = $g(traces(tracesNext,5),0) - 1
			    // (d) Total current bytes all scopes
			    set traces(tracesNext,6) = $g(traces(tracesNext,6),0) - bytesize
			    // (e) Accumulative frees all scopes
			    set traces(tracesNext,8) = $g(traces(tracesNext,8),0) + 1
			}
			kill addresses(scope,addr,tracesNext)
		    }
		} else {
		    ;
		    ; For each possible trace value
		    ;
		    for tracesNext=1:1:tracesCount {
			; Check all the regular expressions for this trace value
			set usethisline = 0
			for expression=1:1:traces(tracesNext,1) {
			    if ($locate(line,traces(tracesNext,3,expression))) {
				set usethisline = 1 
				quit
			    }
			}
			if (usethisline) {
			    ; Remove this from the trace
			    // (a) Total current allocations this scope
			    set traces(tracesNext,4,scope,1) = $g(traces(tracesNext,4,scope,1),0) - 1
			    // (b) Total current bytes this scope
			    set traces(tracesNext,4,scope,2) = $g(traces(tracesNext,4,scope,2),0) - bytesize
			    // (c) Total current allocations all scopes
			    set traces(tracesNext,5) = $g(traces(tracesNext,5),0) - 1
			    // (d) Total current bytes all scopes
			    set traces(tracesNext,6) = $g(traces(tracesNext,6),0) - bytesize
			    // (e) Accumulative frees all scopes
			    set traces(tracesNext,8) = $g(traces(tracesNext,8),0) + 1
			}
		    }
		}
	    } elseif (opcode = 8) {
		s scope=$p(line," ",3)
		;
		; Remove all entries for this scope level
		;
		for tracesNext=1:1:tracesCount {
		    set totalAllocations = $g(traces(tracesNext,4,scope,1),0) ,
			totalBytes       = $g(traces(tracesNext,4,scope,2),0)
		    set traces(tracesNext,5) = $g(traces(tracesNext,5),0) - totalAllocations ,
			traces(tracesNext,6) = $g(traces(tracesNext,6),0) - totalBytes ,
			traces(tracesNext,8) = $g(traces(tracesNext,8),0) + totalAllocations
		    kill traces(tracesNext,4,scope)
		}
		kill addresses(scope)		// In case option "F" in place
	    }
	    ;
	    ; See if time to output another line
	    ;
	    set sampledelta = sampledelta + 1
	    if (sampledelta >= sample) {
		set sampledelta = 0 , samplecount = samplecount+1
		for tracesNext=1:1:tracesCount {
		    if (percent > 0) {
			set sub3 = percentdone
			set percentdone = percentdone + percent
		    } else {
			set sub3 = lineno
		    }
		    for i=5:1:8 { set traces(tracesNext,9,sub3,i) = $g(traces(tracesNext,i)) }
		}
	    }
	}
    } catch ex {
	use IO
	if ($e($ZE,1,11)'="<ENDOFFILE>") {
	    w "Error reading file "_inputfilename_" , error "_$ZE,!
	    set err=1
	}
    }
    use IO
    close inputfilename
    q:err err
    ;
    ; Display simple statistics
    ;
    w "Completed: "_$fnumber(lineno,",")_" lines with "_$fn(samplecount,",")_" samples"
    w " in "_$fnumber(($zh-startTime),",",2)_" seconds. ",!
    q 0
}
csv3(inputfilename,outputfilename,traces,percent,filenext,filecount) [] PRIVATE {
    w "Analysis complete, writing output to file "_outputfilename,!
    set IO=$IO
    set tracesCount=$l(traces,","),err=0
    try {
	use outputfilename
	; Write the headers
	if (filenext = 1 ) {
	    set key=$O(traces(1,9,""))
	    if (percent > 0) {
		while (key'="") {
		    write ","_key_"%"
		    set key=$O(traces(1,9,key))
		}
	    } else {
		while (key'="") {
		    write ",Line "_key
		    set key=$O(traces(1,9,key))
		}
	    }
	    write !
	}
	; For each sample defined
	for tracesNext=1:1:tracesCount {
	    if (filecount = 1 ) {
		write traces(tracesNext,2)
	    } else {
		set ll=$p(inputfilename,"/",$l(inputfilename,"/"))
		set ll=$p(ll,"\",$l(ll,"\"))
	    	write ll
	    }
	    set key=$O(traces(tracesNext,9,""))
	    while (key'="") {
	    	write ","_traces(tracesNext,9,key,6)	// Write total number of bytes in use at this sample
		set key=$O(traces(tracesNext,9,key))
	    }
	    write !
	}
	use IO
    } catch ex {
    	use IO
	w "Error writing to file "_outputfilename_" , error "_$ZE,!
	set err=1
    }
    use IO
    ;
    ; Finished, go home.
    ;
    q
}
replay(filename="",options="") [] PUBLIC {
    set stats=$zu(187,4,1),trace=$p(stats,",",16)
    if (trace>0) {
    	w "Warning: Memory tracing is still turned on.",!
	w "This could affect the operation of this routine if",!
	w "  you are still udpating the same trace file.",!
	w "Do you wish to continue [N] ? "
	r ans,!
	s ans=$zstrip($zcvt(ans,"U"),"<>W")
	q:((ans'="Y")&&(ans'="YES"))
    }
    set options=$zcvt(options,"U")
    set optionF=$f(options,"F") 
    if ('$l(filename)) { w "Error. You must specify a file name as the first parameter",!  q }
    open filename:"R":0
    if ('$T) { w "Unable to open input file "_filename,!  q }
    set IOSAVE=$IO
    set IOIN=filename
    use IOIN   set dummp=$zseek(0)  use IOSAVE
    set lineno = 0, errcount = 0, startTime = $zh , $ZE="", err=0
    set linesparsed = 0
    kill lines
    try {
    	set userscope = $zu(187,30,1)
    } catch ex {
    	w "Error "_$ZE_" attempting to set new scope level",!
	set userscope = -100
    }
    if (userscope < 0) {
	w "Error number "_userscope_" while trying to create new scope",!
	q
    }
    set scopemax = userscope
    kill fragmented
    try {
    	use IOSAVE
	w "Analysis started on file "_filename_" at "_$zt($p($h,",",2))_" "_$zd($p($h,","),2),!
	use IOIN
	set dummp=$zseek(0) 
	for {
	    read line  
	    s lineno=lineno + 1
	    s line=$zstrip(line,"<>W")
	    ; Ignore blank lines and comment lines
	    continue:('$l(line))||($e(line)="#")
	    set linesparsed = linesparsed + 1
	    set p1=$p(line," ",1)
	    ;
	    ; Remove redundant spaces
	    ;
	    for {
		s offset=$f(line,"  ",1)
		q:'offset  q:offset>16
		s $e(line,offset-2,offset-1)=" "
	    }
	    set addr = $p(line," ",2), size = $p(line," ",4), source = $p(line,":",*)
	    set scope = $s(p1["Buddy":$p(line," ",6),p1["Scope":$p(line," ",3),1:0)
	    set routine = $p(line," ",$case($e(line,1,4),"Heap":7,"Budd":9,:99))
	    ;
	    ; Find out what sort of entry we have.
	    ;
	    set %filename=filename
	    set opcode = $$parseopcode(.p1 , .size , .bytesize)
	    ;
	    ; Check what sort of memory operation was performed.
	    ;
	    if (opcode = 2) {
	    	; Allocated a space. See if it already exists.
	    	set data = $g(lines(addr),""), thisscope = scope + userscope
		if (thisscope <= scopemax) {
		    set ans = $zu(187,30,3,thisscope,size)
		    set lines(addr) = $lb(ans,thisscope,size)
		} else {
		    use IOSAVE   
		    w "Error: Trying to create operation at exceeded scope level "_scope_" at line "_lineno,!
		    use IOIN
		}
	    } elseif (opcode = 5) {
	    	set thisscope = scope + userscope 
		if (thisscope <= scopemax) {
		    if ($d(lines(addr))) {
		    	set data = lines(addr), ans = $lg(data,1) , size = $lg(data,3)
			d $zu(187,30,4,ans,thisscope,size)
		    	kill lines(addr)
		    } else {
			use IOSAVE   
			w "Error: Unable to find address "_addr_" at line "_lineno,!
			use IOIN
		    }
		    if (optionF) {
		    	set counter = $g(fragmented(thisscope,1),0)+1,fragmented(thisscope,1) = counter
			if (counter >= 10) {
			    set fragmented(thisscope,1) = 0 , currentmax = $g(fragmented(thisscope,2))
			    set memdata=$zu(187,6,thisscope)	// Get stats about this scope.
			    set currentfrag = $p(memdata,",",7)	// Current fragmented index
			    if (currentfrag > currentmax) {	// Time to update the maximum
				set fragmented(thisscope,2) = currentfrag	// Update maximum fragmentation seen
				set fragmented(thisscope,3) = memdata		// The memory stats at this point
				set fragmented(thisscope,4) = lineno		// The line number it occurred
			    }
			}
		    }
		} else {
		    use IOSAVE   
		    w "Error: Trying to create operation at exceeded scope level "_scope_" at line "_lineno,!
		    use IOIN
		}
	    } elseif (opcode = 7) {
		s scope=$p(line," ",3) , thisscope = scope + userscope
		if (scope > 0) {			// Ignore the first scope push
		    d $zu(187,30,5,thisscope)
		    set scopemax = thisscope
		}
	    } elseif (opcode = 8) {
		s scope=$p(line," ",3), thisscope = scope + userscope
		d $zu(187,30,6,thisscope)
		set scopemax = thisscope - 1
		// Remove all entries in the 'lines' array with the scope level.
		set key=$O(lines(""),1,data)
		while (key '= "") {
		    if ($lg(data,2) = thisscope) {
			kill lines(key)
		    }
		    set key=$O(lines(key))
		}
	    } else {
		continue
	    }
	}
    } catch ex {
	use IOSAVE
	if ($e($ZE,1,11)'="<ENDOFFILE>") {
	    w "Error reading file "_filename_" , error "_$ZE,!
	    set err=1
	}
    }
    use IOSAVE
    close filename
    ;
    ; If option "F" then we want to display the point at
    ; which we believe the most fragmentation occurred.
    ;
    if (optionF) {
	for nextscope=userscope:1 {				// For each scope we've seen
	    set memdata=$g(fragmented(nextscope,3),"")		// Get fragmentation data
	    q:memdata=""
	    set fragindex = fragmented(nextscope,2)		// Get fragmentation index
	    set fraglineno = fragmented(nextscope,4)		// Get fragmentation line number where it occurred
	    d reportscope("Maximum fragmentation for scope "_(nextscope-userscope)_" occurred at line "_fraglineno,memdata,(nextscope-userscope),"SV")
	}
    }
    ;
    ; Display the final report.
    ;
    for nextscope=userscope:1 {
	set memdata=$zu(187,6,nextscope)
	q:memdata=""
	set originalscope = nextscope - userscope 
	if (nextscope=userscope) {
	    d reportscope("Final report at end of analysis" , memdata , originalscope , "MSV")
	} else {
	    d reportscope("", memdata , originalscope , "SV")
	}
    }
    ;
    ; Display termination statistics.
    ;
    w "Completed: "_$fnumber(linesparsed,",")_" lines"
    w:(linesparsed'=lineno) " (out of "_$fn(lineno,",")_")"
    w " in "_$fnumber(($zh-startTime),",",2)_" seconds. "
    ;
    ; Close the map collection.
    ;
    try {
	d $zu(187,30,2,userscope)
    } catch ex {}
    ;
    ; Finished, go home.
    ;
    q
}
reportscope(message , memdata , origscope, options ) [] PUBLIC {
    set optionM = $f(options,"M") , optionS = $f(options,"S"), optionV = $f(options,"V")
    w:message'="" !,message,!
    if (optionM) {
    	set mapcollection = $p(memdata,",",2)
	w "Map collection ",mapcollection,", 2k block count "_$fn($p(memdata,",",5),","),!
	set bsize = 2048, total = 0
	for size=9:1:14 {
	    set blocks=$p(memdata,",",10+size)
	    w "   Allocation size ",$$left(size,2)," ("_$$left($fn(bsize,","),6),"), block count ",blocks,", total bytes "_$fn(blocks * bsize,","),!
	    set total = total + (blocks * bsize)
	    set bsize=bsize*2
	}
	w "   Total bytes in free space chains for map collection ",mapcollection,"        ",$fn(total,","),!
    }
    if (optionS) {
	set scope = $p(memdata,",",1)
	w "Original scope ",origscope," (current ",scope,"), map collection "_$p(memdata,",",2),", 2k block count "_$fn($p(memdata,",",3),","),!
	set bsize = 8, total = 0
	for size=1:1:8 {
	    set blocks=$p(memdata,",",10+size)
	    w "   Allocation size ",$$left(size,2)," ("_$$left($fn(bsize,","),6),"), block count ",blocks,", total bytes "_$fn(blocks * bsize,","),!
	    set total = total + (blocks * bsize)
	    set bsize=bsize*2
	}
	w "   Total bytes in free space chains for scope ",origscope,"        ",$fn(total,","),!
	w "   Fragmentation index "_$p(memdata,",",7),!
    }
}
left(in,len) [] PRIVATE {
    q in _ $j("",len - $l(in))
}
bytesize(size) [] PRIVATE {
    q $case(size,0:8,1:8,2:16,3:32,4:64,5:128,6:256,7:512,8:1024,9:2048,10:4096,11:8192,12:16384,13:32768,14:65536,:-1)
}
CountLines(filename,verbose) {
    open filename:"R":0
    if ('$T) { w "Unable to open input file "_filename,!  q 0 }
    set linecount = 0
    w:verbose "Counting lines in file "_filename_" ..."
    set IOSAVE=$IO
    try {
	use filename
	set dummp=$zseek(0) 
	for {
	    read line  
	    s linecount=linecount + 1
	}
	set dummp=$zseek(0) 
    } catch ex {
    	use IOSAVE
	if ($e($ZE,1,11)'="<ENDOFFILE>") {
	    w "Error reading file "_filename_" , error "_$ZE,!
	    set linecount=0
	}
    }
    use IOSAVE
    w:verbose $fn(linecount,",")_" lines.",!
    q linecount
}
parseopcode(opcode , size , bytesize) [] PRIVATE {
    s bytesize=size
    q $case(opcode,
    	"BuddyAlloc":2,
    	"BuddyFree":5,
    	"HeapAlloc":1,
    	"HeapFree":4,
    	"ReallocAlloc":1,
    	"ReallocFree":4,
    	"AlignAlloc":1,
    	"AlignFree":4,
    	"Mmap":3,
    	"Munmap":6,
	"PushScope":7,
	"PopScope":8,
	:9)
}
getNumericArgument(options,index,default,value2,value3) [] PRIVATE {
    ; Get a numeric argument following an alpha option
    s rtnvalue=""
    while ($e(options,index)?1N) {
	s rtnvalue=rtnvalue_$e(options,index),index=index+1
    }
    s:(rtnvalue="") rtnvalue=default
    ; If we have asked for an optional couple of values, delimited
    ; by "^", "," or "-", then try to extract them.
    if ($d(value2)) {
    	s delim=$e(options,index)
	if (delim=",")||(delim="^")||(delim="-") {
	    set value2=$p($e(options,index,*),delim,2)+0,value3=$p($e(options,index,*),delim,3)+0
	}
    }
    q (rtnvalue+0)
}
convertLines(lines,ctr,totalBytes,xrefCache,xrefRoutine,createXrefArrays,optionV,optionE) [] PRIVATE {
    ;
    ; Convert from one layout to another.
    ;
    s addr=$ORDER(lines(""),1,data), ctr = 0 , totalBytes = 0
    kill xrefCache,xrefRoutine
    while (addr'="") {
	s ctr=ctr+1 , size=$lg(data,1), bytes = size, totalBytes=totalBytes+bytes
	if (createXrefArrays) {
	    if (optionV) {
		s xrefCache($lg(data,4))=data
	    } else {
		s scope = $lg(data,2) , source = $lg(data,3) , lineno = $lg(data,4), routine = $lg(data,5)
	    	if (source'="") {
		    if (optionE) {
		    	set subscript1 = source _ " " _ routine
			set subscript2 = routine _ " " _ source
		    } else {
		    	set subscript1 = source
			set subscript2 = routine
		    }
		    set id = $i(xrefCache(subscript1)), xrefCache(subscript1,1)=$g(xrefCache(subscript1,1))+1,xrefCache(subscript1,2)=$g(xrefCache(subscript1,2))+bytes
		    if subscript2'="" set id = $i(xrefRoutine(subscript2)), xrefRoutine(subscript2,1)=$g(xrefRoutine(subscript2,1))+1,xrefRoutine(subscript2,2)=$g(xrefRoutine(subscript2,2))+bytes
		}
	    }
	}
	s addr=$ORDER(lines(addr),1,data)
    }
}
sortLines(in,optionV,optionC,msg1,msg2,depth,optionE) [] PRIVATE {
    kill sorted
    s source=$O(in("")),ctr=0
    while (source'="") {
    	set TotalCalls=in(source,1) , TotalBytes=in(source,2)
	if (optionC) {
	    set id=$I(sorted(TotalCalls))
	    set sorted(TotalCalls,id)=$lb(source,TotalBytes,TotalCalls)
	} else {
	    set id=$I(sorted(TotalBytes))
	    set sorted(TotalBytes,id)=$lb(source,TotalBytes,TotalCalls)
	}
    	set ctr=ctr+1,source=$O(in(source))
    }
    ;
    ; Display the heading including the depths of the report.
    ;
    if ('optionV) {
	w !,"Top "_$S(ctr<depth:ctr,1:depth)_" "_msg1
	s max=depth
    } else {
	w !,"All "_msg1
	set max=999999999
    }
    w " sorted by Total "_$S(optionC:"Calls",1:"Bytes"),!
    set msg=msg2
    s column1Width=27,column2Width=45
    if (optionE>0) {
    	s column1Width=column1Width+20,column2Width=column2Width+20
    }
    set $e(msg,column1Width) = "Total Bytes"
    set $e(msg,column2Width) = "Total Calls"
    write !,msg,!,!
    set key=$O(sorted(""),-1) , done = 0, TotalTotalBytes = 0 , TotalTotalCalls = 0
    while (key'="")&&(done<=max) {
	s id=$O(sorted(key,""),1,data)
	while (id'="")&&(done<=max) {
	    s msg=$zstrip($lg(data,1),"<>W"),TotalBytes=$lg(data,2),TotalCalls=$lg(data,3)
	    set $e(msg,column1Width)=" "_$fn(TotalBytes,",")
	    set $e(msg,column2Width)=" "_$fn(TotalCalls,",")
	    w msg,!
	    set done=done+1
	    set TotalTotalBytes=TotalTotalBytes+TotalBytes, TotalTotalCalls=TotalTotalCalls+TotalCalls
	    set id=$O(sorted(key,id),1,data)
	}
	set key=$O(sorted(key),-1) 
    }
    s msg="Totals ------",$e(msg,column1Width)=$fn(TotalTotalBytes,","),$e(msg,column2Width)=$fn(TotalTotalCalls,",")
    w msg,!
}
general() [] PUBLIC {
    d mem
    q
}
memory() [] PUBLIC {
    s stats = $zu(187,3)
    s text=$lb( 
	"Total data space allocated",			// Field <1>
	"Total data space committed memory",		// Field <2>
	"'C' Stack currently in use",			// Field <3>
	"'C' Stack peak usage",				// Field <4>
	"'C' Stack committed memory",			// Field <5>
	"Anonymous memory region peak",			// Field <6>
	"Anonymous memory region vm in use",		// Field <7>
	"Anonymous memory region committed memory",	// Field <8>
    	"Total bytes malloc in use",			// Field <9>
	"Total bytes malloc free space",		// Field <10>
	"Partition maps allocated",			// Field <11>
	"Partition maps committed memory",		// Field <12>
	"String Stack : Total size",			// Field <13>
	"               Committed memory",		// Field <14>
	"               Allocation type",		// Field <15>
	"Frame Stack  : Total size",			// Field <16>
	"               Committed memory",		// Field <17>
	"               Allocation type",		// Field <18>
	"Error Stack  : Total size",			// Field <19>
	"               Committed memory",		// Field <20>
	"               Allocation type",		// Field <21>
	"RESERVED" )
    s ll=$ll(text),maxl=0,lp=$l(stats,",")
    for llnext=1:1:ll {
    	s datal=$l($lg(text,llnext))
	s:datal>maxl maxl=datal
    }
    s l2=$SELECT(lp>ll:lp,1:ll)
    for l3=1:1:l2 {
    	s txt=$lg(text,l3),value=$p(stats,",",l3)
	continue:txt="RESERVED"
	s:txt="" txt="Unknown value"
	s:((value+0)=value) value=$fnumber(value,",")
	s msg=l3,$e(msg,4)=txt,$e(msg,maxl+6)=value
	w msg,!
    }
}
user(jobid = 0) [] PUBLIC {
    s stats = $system.Memory.ProcessStats(jobid + 0 )
    s text=$lb( 
	"Total heap space allocated", 0,			// Field <1>
	"Total partition space allocated", 0,			// Field <2>
	"Total Cache internal stack allocated", 0,		// Field <3>
	"Total of additional memory maps", 0,			// Field <4>
	"Private memory overhead of shared memory segments", 0,	// Field<5>
	"C stack committed memory", 0 , 			// Field <6>
	"Application memory in use", 0,				// Field <7>
	"Application memory maximum", 0,			// Field <8>
	"Application memory in free space", 0,			// Field <9>
	"Application memory peak", 0,				// Field <10>
	"Application memory fragmentation index", 0,		// Field <11>
	"Memory allocated for long strings", 0,			// Field <12>
	"Shared memory Total", 0,				// Field <13>
	"Shared memory used for globals" , 0,			// Field <14>
	"Shared memory used for routines" , 0,			// Field <15>
	"Shared memory used for heap" , 0,			// Field <16>
	"Shared memory other" , 0,				// Field <17>
	"Shared memory page size", 0 , 				// Field <18>
	"String stack: total allocated" , 0,			// Field <19>
	"String stack: committed" , 0,				// Field <20>
	"String stack: source" , 0,				// Field <21>
	"Frame stack: total allocated" , 0,			// Field <22>
	"Frame stack: committed" , 0,				// Field <23>
	"Frame stack: source" , 0,				// Field <24>
	"Error stack: total allocated" , 0,			// Field <25>
	"Error stack: committed" , 0,				// Field <26>
	"Error stack: source" , 0,				// Field <27>
	"Number of <STORE> errors thrown" , 0,			// Field <28>
	"Reason for last <STORE> error", 6,			// Field <29>
	"Buddy code size that caused last <STORE> error", 0,	// Field <30>
	"Scope in use at the last <STORE> error", 0,		// Field <31>
	"Number of memory cleanup attempts", 0,			// Field <32>
	"Number of array defragmentations", 0)			// Field <33>
    ;
    ; Display in a common routine.
    ;
    d displayStatsLIST(.text,.stats)
    q
}
displayStatsLIST(text,stats) [] PRIVATE {
    ;
    ; Display to terminate the stats.
    ;
    s ll=$ll(text),maxl=0,lp=$ll(stats)
    for llnext=1:2:ll {
    	s datal=$l($lg(text,llnext))
	s:datal>maxl maxl=datal
    }
    s textno = 1
    for l3=1:1:lp {
    	s txt=$lg(text,textno),special=$lg(text,textno+1),textno=textno+2
	s value=$lg(stats,l3)
	continue:txt="RESERVED"
	s:txt="" txt="Unknown value"
	;
	; Handle special formatting of the data
	;
	if (special > 0) {
	    s value=$$mapoptions(special,value,stats)
	    if (special = 3) {
		s msg=l3,$e(msg,4)=txt,$e(msg,maxl+6)=$lg(value,1)
		w msg,!
		for i1=2:1:$ll(value) {
		    s msg=$j("",maxl+5)_$lg(value,i1)
		    w msg,!
		}
		continue
	    }
	} else {
	    s:((value+0)=value) value=$fnumber(value,",")
	}
	;
	; Format the output and display it.
	;
	s msg=l3,$e(msg,4)=txt,$e(msg,maxl+6)=value
	w msg,!
    }
}
displayStats(text,stats) [] PRIVATE {
    ;
    ; Display to terminate the stats.
    ;
    s ll=$ll(text),maxl=0,lp=$l(stats,",")
    for llnext=1:2:ll {
    	s datal=$l($lg(text,llnext))
	s:datal>maxl maxl=datal
    }
    s textno = 1
    for l3=1:1:lp {
    	s txt=$lg(text,textno),special=$lg(text,textno+1),textno=textno+2
	s value=$p(stats,",",l3)
	continue:txt="RESERVED"
	s:txt="" txt="Unknown value"
	;
	; Handle special formatting of the data
	;
	if (special > 0) {
	    s value=$$mapoptions(special,value,stats)
	    if (special = 3) {
		s msg=l3,$e(msg,4)=txt,$e(msg,maxl+6)=$lg(value,1)
		w msg,!
		for i1=2:1:$ll(value) {
		    s msg=$j("",maxl+5)_$lg(value,i1)
		    w msg,!
		}
		continue
	    }
	} else {
	    s:((value+0)=value) value=$fnumber(value,",")
	}
	;
	; Format the output and display it.
	;
	s msg=l3,$e(msg,4)=txt,$e(msg,maxl+6)=value
	w msg,!
    }
}
vars(jobnumber = 0 ) [] PUBLIC {
    s ans = $system.Memory.VariableStats(jobnumber)
    s (totMemory , totLong , totOref , totSubscripts) = 0
    w "Var name       PROC  Scope Total     Long      OREF    Subs",!
    w "--------       ----  ----- -----     ----      ----    ----",!
    for next=1:1:ans.Count() {
    	s var = ans.Data(next)				// Get next variable
    	s msg = $lg(var,1)				// Name of variable
	s $e(msg,16) = $lg(var,2)			// The PROC level
	s $e(msg,22) = $lg(var,3)			// Scope level of memory allocation
	s thisMemory = $lg(var,5) 			// Extract total memory used
	s thisLong = $lg(var,6) 			// Extract memory used for long strings
	s thisOref = $lg(var,10) 			// Extract number of orefs
	s thisSubscripts = $lg(var,11) 			// Extract number of subscripts
	s $e(msg,28) = $$makeMB(thisMemory)		// Total memory used
	s $e(msg,38) = $$makeMB(thisLong)		// Long string memory
	s $e(msg,48) = $fn(thisOref,",")		// Number of object references
	s $e(msg,56) = $fn(thisSubscripts,",")		// Number of subscripts
	s totMemory = totMemory + thisMemory
	s totLong = totLong + thisLong
	s totOref = totOref + thisOref
	s totSubscripts = totSubscripts + thisSubscripts
	w msg,!
    }
    w "--------       ----  ----- -----     ----      ----    ----",!
    s msg = "Totals"
    s $e(msg,28) = $$makeMB(totMemory)
    s $e(msg,38) = $$makeMB(totLong)
    s $e(msg,48) = $fn(totOref,",")
    s $e(msg,56) = $fn(totSubscripts,",")
    w msg,!
}
makeMB(totbytes) PUBLIC {
    s suffix=""
    if (totbytes>10485760) {
	set totbytes=(totbytes*10/1048576\1/10),suffix="Mb"
    } elseif (totbytes > 10240) {
	set totbytes=(totbytes/1024*10)\1/10,suffix="Kb"
    }
    q $fnumber(totbytes,",")_suffix
}
mem() [] PUBLIC {
    s stats = $zu(187,4,1)
    s text=$lb( "Buddy block total memory maps", 0,		// Field <1>
	"Buddy block total memory unmaps", 0,			// Field <2>
	"Buddy block total bytes mapped", 0,			// Field <3>
	"Buddy block total bytes unmapped", 0,			// Field <4>
	"Buddy block bytes currently in use", 0,		// Field <5>
	"Buddy block peak value bytes in use", 0,		// Field <6>
	"Buddy block total bytes including overheads", 0,	// Field <7>
	"System-wide extended memory flag", 1,			// Field <8>
	"System-wide allocation type", 2,			// Field <9>
	"System-wide diagnostic flags", 3,			// Field <10>
	"System-wide memory map size", 0,			// Field <11>
	"System-wide maximum string size", 0,			// Field <12>
	"Process-specific extended memory flag", 1,		// Field <13>
	"Process-specific memory limit", 0,			// Field <14>
	"Process-specific number of STORE errors" , 0,		// Field <15>
	"Process-specific diagnostic flags" , 3,		// Field <16>
	"Buddy block allocations" , 0,				// Field <17>
	"Buddy block releases" , 0,				// Field <18>
	"Buddy blocks in use" , 0,				// Field <19>
	"Buddy blocks bytes in use" , 0,			// Field <20>
	"Heap space allocations" , 0,				// Field <21>
	"Heap space releases" , 0,				// Field <22>
	"Heap space in use" , 0,				// Field <23>
	"Heap space bytes in use" , 0,				// Field <24>
	"Memory map allocations" , 0,				// Field <25>
	"Memory map releases" , 0,				// Field <26>
	"Memory map in use" , 0,				// Field <27>
	"Memory map bytes in use" , 0,				// Field <28>
	"OS reported heap space used", 0,			// Field <29>
	"OS reported heap space free", 0,			// Field <30>
	"OS reported Size", 0,					// Field <31>
	"OS reported Resident Set Size", 0,			// Field <32>
	"OS reported Process Actual Size", 0,			// Field <33>
	"Memory defragmentation operations", 0,			// Field <34>
	"Reason for last <STORE> error", 6,			// Field <35>
	"The scope in effect at last <STORE> error", 0,		// Field <36>
	"The size attempted at last <STORE> error", 0,		// Field <37>
	"Current status of <STORE> error handling", 4,		// Field <38>
	"Number of recoveries before <STORE> error", 0,		// Field <39>
	"Extended Memory Function type", 5)			// Field <40>
    ;
    ; Display in a common routine.
    ;
    d displayStats(.text,.stats)
    q
}
diag(flags) [] PUBLIC
{
    ;
    ; Dump extended information about the maps.
    ;
    s:'$d(flags) flags=0
    d $zu(187,10,flags)
}
mapoptions(type,value,stats) [] PUBLIC {
    s rtn = "",value=value+0
    if (type =1) {
	s rtn=$S(value<=0:"Off",1:"On")
    } elseif (type=2) {
	s stats = $p(stats,",",10)+0
	if ($zb(stats,2048,1)) {
	    s text="2048 - Each block uses a unique mmap() call"
	} elseif ($zb(stats,4096,1)) {
	    s text="4096 - Each block uses a unique malloc() call"
	} else {
	    s:(value=0) value=1
	     s text = value_" - "_$CASE( value,1:"Anonymous memory maps",2:"File based memory maps",:"Unknown")
	}
	d mapadd(text,.rtn)
    } elseif (type=3) {
	set rtn = $lb(value)
	s:($zb(value,1,1)) rtn = rtn _ $lb("0x0001 Major ops")
	s:($zb(value,2,1)) rtn = rtn _ $lb("0x0002 Minor ops")
	s:($zb(value,4,1)) rtn = rtn _ $lb("0x0004 Runtime diagnostics")
	s:($zb(value,8,1)) rtn = rtn _ $lb("0x0008 Checks and display on exit")
	s:($zb(value,16,1)) rtn = rtn _ $lb("0x0010 Suppress terminal")
	s:($zb(value,32,1)) rtn = rtn _ $lb("0x0020 File output")
	s:($zb(value,128,1)) rtn = rtn _ $lb("0x0080 Throw <SYSTEM> on error")
	s:($zb(value,256,1)) rtn = rtn _ $lb("0x0100 Process hang on error")
	s:($zb(value,512,1)) rtn = rtn _ $lb("0x0200 Log <STORE> errors to messages.log")
	s:($zb(value,1024,1)) rtn = rtn _ $lb("0x0400 Double buddy checks")
	s:($zb(value,2048,1)) rtn = rtn _ $lb("0x0800 Minor sanity check for each operation")
	s:($zb(value,4096,1)) rtn = rtn _ $lb("0x1000 Major sanity check for each operation")
	s:($zb(value,32768,1)) rtn = rtn _ $lb("0x8000 Never reuse same memory map")
	s:($zb(value,65536,1)) rtn = rtn _ $lb("0x10000 Output to stdout not current device")
	s:(rtn="") rtn = rtn _ $lb("Off")
    } elseif (type=4) {
    	; Low memory status
	s rtn = value _ " - " _ $CASE(value,
		0:"NORMAL",
		1:"LOW MEMORY",
		2:"EXTRA 1M",
		3:"EXHAUSTED",
		:"UNKNOWN")
    } elseif (type=5) {
    	; Extended memory function type
	s rtn = value _ " - " _ $CASE(value,
		0:"NORMAL",
		1:"DIAGNOSTIC",
		2:"LOW MEMORY",
		:"UNKNOWN")
    } elseif (type=6) {
    	; Reason for last store error
	s rtn = value _ " - " _ $CASE(value,
		0:"NONE",
		1:"LOW MEMORY",
		2:"COMPLETE EXHAUSTION",
		3:"SYSTEM RESOURCES",
		:"UNKNOWN")
    } else  {
    	d mapadd("Unknown",.rtn)
    }
    q rtn
}
mapadd(txt,rtn) [] PRIVATE {
    s:(rtn'="") rtn=rtn_","
    s rtn=rtn_txt
    q
}
purge(pid,depth,verbose) [] PUBLIC {
    set ourpid=$J
    set:'$D(pid) pid=ourpid
    set:pid="" pid=ourpid
    set:'$D(depth) depth=2
    set:'$d(verbose) verbose=1
    write:verbose>=1 "Purging XM trace files for process id '"_pid_"' to a depth of "_depth,!
    set mgrdirectory=##class(%Library.File).ManagerDirectory()
    do ##class(%Library.File).FileSetExecute(.qhandle,mgrdirectory,"xmtrace*")
    set ctr=0
    kill pidlist
    for {
    	do ##class(%Library.File).FileSetFetch(.qhandle,.row,.atend)
	q:$ll(row)<6
	set ctr = ctr + 1
	set fullpath=$lg(row,1),filename=$lg(row,6)
	set thispid=$p(filename,"_",2),index=$p(filename,"_",3)
	if (pid="*")||(thispid=pid) {
	    if (index="") {
	    	set pidlist(thispid)=fullpath
	    } else {
	    	set pidlist(thispid,index)=fullpath
	    }
	}
	quit:atend
    }
    do ##class(%Library.File).FileSetClose(.qhandle)
    write:verbose>=1 "Found "_$fn(ctr,",")_" trace files in directory "_mgrdirectory,!
    set thispid=$O(pidlist(""),1,pathname)
    set purgecount = 0
    while (thispid'="") {
	set d1=$d(pidlist(thispid))
	if (d1=1)||(d1=11) {
	    if (depth=0)&&($d(pathname)) {
		set purgecount=purgecount+1
		do ##class(%Library.File).Delete(pathname)
		write:verbose>=2 "Trace file "_pathname_" deleted.",!
	    }
	}
	if (d1=10)||(d1=11) {
	    set thisindex=$O(pidlist(thispid,""),-1,pathname)
	    set indexcount=0
	    while (thisindex'="") {
		set indexcount=indexcount+1
		if (indexcount > depth) {
		    set purgecount=purgecount+1
		    do ##class(%Library.File).Delete(pathname)
		    write:verbose>=2 "Trace file "_pathname_" deleted.",!
		}
		set thisindex=$O(pidlist(thispid,thisindex),-1,pathname)
	    }
	}
	set thispid=$O(pidlist(thispid),1,pathname)
    }
    if (verbose>=1) {
    	if (purgecount=0) {
	    w "No files found to be purged",!
	} else {
	    w "Purged "_$fn(purgecount,",")_" files.",!
	}
    }
    q purgecount
}

cmprtest^INT^1^67214,47331
Start(JfIn,JfOut="",engine="all",blkno=0) Public {
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
	k ^||Result,^||FileSize,^||BlkNum,^||TextOut
	s ^||TU="us"
	s cmd=$SYSTEM.Util.BinaryDirectory()_"cmprtest"_$s(($zversion(1)=2):".exe",1:"")
	if $zu(140,4,cmd)'=0 w !,"Could not find cmprtest executable." Quit
	if blkno > 256 s blkno=256
	if blkno < 0 {
		s blkno=1
	} elseif blkno>1 {
		s blkno= blkno+15\16*16
	}
	if engine="all" {
		for eng="zlib","zstd","lz4" {
			d OneEngine(JfIn,JfOut,eng,blkno)
		}
	} else {
		if '$case(engine,"zlib":1,"lz4":1,"zstd":1,:0) {
			w !,"Bad enigne name '",engine,"'."
			q
		}
		d OneEngine(JfIn,JfOut,engine,blkno)
	}
	if '$d(^||Result) {
		w !,"No testing result found." q
	}
	w !!,"Compress file ",JfIn," Size: ",^||FileSize/1024/1024," MB, # JrnBlock: ",^||BlkNum
	w !,"Time Unit is ",$s(^||TU="us":"micro second",1:"milli second")
	if engine="all" {
		w !,"CmpSz",?18,"ZLIB",?43,"ZSTD",?68,"LZ4"
		w !,?6,"Compress|Decmpres|Ratio",?31,"Compress|Decmpres|Ratio",?56,"Compress|Decmpres|Ratio"
	} else {
		w !,"CmpSz",?18,$zconvert(engine,"U")
		w !,?6,"Compress|Decmpres|Ratio"
	}
	s blkno=$o(^||Result(""))
	while blkno'="" {
		w !,$s(blkno=1:"64KB",1:$j(blkno/16,2)_"MB")
		s eng=$o(^||Result(blkno,""),1,data)
		while eng'="" {
			s col=$s(engine="all":$case(eng,0:6,1:31,:56),1:6)
			s text=$j($p(data,",")/$s(^||TU="ms":1000,1:1),8,2)_"|"_$j($p(data,",",2)/$s(^||TU="ms":1000,1:1),8,2)_"|"_$j($p(data,",",3),5,2)
			w ?col,text
			s eng=$o(^||Result(blkno,eng),1,data)
		}
		s blkno=$o(^||Result(blkno))
	}
	k ^||Result,^||FileSize,^||BlkNum,^||TextOut,^||TU
	q
}
OneEngine(JfIn,JfOut,engine,blkno) {
	s $p(x,"*",1000)="*"
	s engineok=1
	Try {
		s y=$SYSTEM.Util.Compress(x,engine)
	} catch {
		i $ze["<ILLEGAL VALUE>" {
			s engineok=0
		} else {
			throw
		}
	}
	if 'engineok w !,"Failed to load '",engine,"' library." q
	w !,"Processing '",engine,"' compression algorithm."
	if 'blkno {
		For bn=0:1:16 {
			s blkno=$s('bn:1,1:bn*16)
			d OneBlockNum(JfIn,JfOut,engine,blkno)
		}
	} else {
		d OneBlockNum(JfIn,JfOut,engine,blkno)
	}
}
OneBlockNum(JfIn,JfOut,engine,blkno) {
	w "."
	s JfOut=$s(JfOut="":"DontCare",1:JfOut_"_"_engine_"_"_blkno)
	s engno=$case(engine,"zlib":0,"zstd":1,:2)
	s cmd=$SYSTEM.Util.BinaryDirectory()_"cmprtest"
	s args($i(args))="-e"
	s args($i(args))=engine
	s args($i(args))="-j"
	s args($i(args))=JfOut
	s args($i(args))="-b"
	s args($i(args))=blkno
	s args($i(args))=JfIn
	s iosave=$I
	s zusav=$zu(68,40,1),ret=""
	s cmptime=0
	try {
		set dev="|CPIPE|"
		open dev:(/COMMAND=cmd:/ARGS=args...:/READ)
		For ii=0:1 {
			use dev read x Q:$zeof
			s ^||TextOut(engno,$i(^||TextOut))=x
			if $E(x,1,5)="Found" s:'$G(^||BlkNum) ^||BlkNum=+$zstrip($p(x,"Found",2),"<>W") continue
			if x["filesize=" s:'$G(^||FileSize) ^||FileSize=+$p(x,"filesize=",2) continue
			if x["Compression:" s cmptime=+$zstrip($p(x,"Compression:",2),"<>W") s:cmptime>1000000 ^||TU="ms" continue
			if x["Decompression:" s decmptime=+$zstrip($p(x,"Decompression:",2),"<>W") s:decmptime>1000000 ^||TU="ms" continue
			if x["Ratio:" s ratio=+$zstrip($p(x,"Ratio:",2),"<>W") continue
		} 
		close dev
	} catch { close dev}
	use iosave
	d $zu(68,40,zusav)
	if 'cmptime {
		w !,"Failed to run cmprtest program, error:"
		s i=$o(^||TextOut(engno,""),1,text)
		while i'="" {
			w !,text
			s i=$o(^||TextOut(engno,i),1,text)
		}
	} else {
		s ^||Result(blkno,engno)=cmptime_","_decmptime_","_ratio
	}
}

mgstat^INT^1^67214,47331
mgstat(dly,cnt,reqname,pagesz)
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 /*   Utility documentation
 Performance monitoring routine.  Filename is now generated, and follows the form
 hostname_configname_yyyymmdd_hhmm.mgst. On VMS due to filename length restrictions
 the configname may be truncated and the hostname may be missing or truncated.
 File output is csv format and set for a companion Excel analyser program.
 Column names must therefore be strictly alphanumeric characters only. %ages use "p"
 Columns must be single figures, most data is output in per second rates
 (wdqsiz, wdphase are obvious exceptions).
 This routine can be imported and run unchanged on any version of Cache from 5.0.1 upwards.
 Columns:
 Date, Time, Local Global References, Remote Global References, Ratio of Local to Global refs,
 Physical Reads, Ratio of logical to physical reads, 
 Global Updates, Remote Updates, Routine calls, Remote Routine Calls, Routine loads&saves, Remote Routine loads&saves,
 Physical writes, Write Daemon Queue Size, 5.1 and up - Cachetemp wd queue size,
 Write Daemon Phase, WIJ writes - 5.2 and up, Routine Cache Misses - 2007.1 and up, 
 Journal writes,  5.1 and up Write Daemon pass, IJUCnt, IJULock
 Seize columns: are in sets of 3, the seizes, Nseizes and Aseizes.
 For 5.x the default seizes are Global, Routine and Object
 For 2007+ the default seizes are Global, Object and Per-BDB.
 For 2010+ the default product setting is that no seize statistics are collected at all, 
 so if you need these you will need to re-enable them before running mgstat.  Call WRC Performance team for details.
 However these can be changed
  - find the line in init section commented "// seize statistics"
  - two variables sznames and sztag are used, keep these in step
    sznames is a comma separated list of the actual counters required (from $zu(162,0)
    sztag is the display name for the columns in the file
      for column alignment, use only 3 character tagnames.
 All the resource names are (as of 2013.2): tags on following line.
 Pid,Routine,Lock,Global,Dirset,SatMap,BlSplit,Journal,Stat,GfileTab,Unused,Misc,LockDev,ObjClass,GmemHeap,IjcDev,TtyHash,Unused,Unused,StrTab,CPT,RCT,ECP_ALL_C,ECP_S_BLK,ECP_S_SES,ECP_S_WORK,ECP_S_JRN,EnqEvt,EnqJrnIO,Mirror,Expand,Volqueue,iKnow,WIJEnc,Unused,Unused,Unused,Unused,Unused,Unused,Unused,Unused,Unused,Unused,Unused,Unused,Unused,Unused,LockHTAB,LockLHB,TransCB,StrTab,Per-BDB,NetBig_C,NetBig_S,NetBig_R,NetBig_L
 Pid,Rtn,Lck,Gbl,Dir,Sat,Bsp,Jrn,Stt,Gft,Unu,Msc,Lck,Obj,GmH,IJC,TTY,Unu,Unu,Str,CPT,RCT,ECP,ESb,ESs,ESw,ESj,Evt,EJI,Mir,Exp,Vlq,iKw,WIJ,Unu,Unu,Unu,Unu,Unu,Unu,Unu,Unu,Unu,Unu,Unu,Unu,Unu,Unu,LHt,LHB,TCB,Str,BDB,NBC,NBS,NBR,NBL
 Run using format: %SYS> job ^mgstat([sampletime],[cnt])
 where sampletime is the interval at which data is recorded, cnt is the number of data points to gather
 */
 ;
 ;
 n (dly,cnt,reqname,pagesz)
 d init
 d loop
 q
init
 s $zt="initerr" ; for class errors mainly??? the vers exist in 4.1
 d GetVersionInfo(.Majver,.Minver,.OS)
 s pmode=($zj\1#2),fileok=1
 i Majver<5 w "Sorry, this won't work on this version",! q  // not supported on pre-5.0 systems.
 s reqname=$g(reqname),logdir=$g(^%SYS("PTools","logdir")) i logdir="" s logdir=$g(^IRIS.SystemPerformance("logdir"))  ; logdir is canonical (prevalidated)
 i reqname="" { // generate the filename (default use!)
	s svrname=$p($zu(54,0),"."),config=$p($zu(86),"*",2)
	s fdate=$zd($h,8),ftime=$tr($zt($p($h,",",2),2),":",""),fname=fdate_"_"_ftime_".mgst"
	i OS["VMS" { ; VMS has filename length restrictions
		s cfglen=$l(config)
		i cfglen>16 { s fname=$e(config,1,18)_"_"_fname }
		else { s fname=$e(svrname,1,17-cfglen)_"_"_config_"_"_fname }
	} else {
		s fname=svrname_"_"_config_"_"_fname
	}
	s hfname=fname
	s fname=logdir_fname
 } else { // reqname not null
	s plat=$zversion(1),dirchk=$s(plat=1:"]",plat=2:"\",1:"/")
	i (reqname[dirchk)||(logdir="") { s (fname,hfname)=reqname }
	else {
		if reqname[logdir { s fname=reqname,hfname=$p(reqname,logdir,2) }
		else { s hfname=reqname,fname=logdir_hfname }
	}
 }
 s (odly,dly)=$g(dly,2),(lcnt,cnt)=$g(cnt,10) i dly>10 s dly=10
 i cnt=-1 { s lcnt=99999 } else { i odly'=dly { s durn=cnt*odly,lcnt=durn+dly-1\dly } }
 i pmode { s pagesz=$g(pagesz,0) i pagesz'=0 { i pagesz<5 s pagesz=5 } }
 ; set common memory offsets
 s maxval4=4294967295
 s wdwchk=$ZU(40,2,146),wdphaseoff=$ZU(40,2,145)
 s wdcycle=$ZU(79,1),stilen=$zu(40,0,1),szctrs=1
 s (globufs,glostr)=$v($ZU(40,2,135),-2,stilen)/512 f i=1:1:5  { s tmp=$v($ZU(40,2,135)+(i*stilen),-2,stilen)*(2**(1+i))/1024,globufs=globufs+tmp,glostr=glostr_"^"_tmp } s globufs=globufs_"MB:"_glostr
 if Majver>2008||((Majver=2008)&&(Minver>1)) { s roustr=$tr($system.Util.RoutineBuffers(),",","^"),roubufs=0 f i=1:1:$l(roustr,"^") { s roubufs=roubufs+$p(roustr,"^",i) } s roubufs=roubufs_"MB:"_roustr }
 else {
	i (Majver=5)&&(Minver<1) { s rbufsiz=32,rbstr=",routinebuffersize=assumed 32K" } else { s rbufsiz=$v($zu(40,2,164),-2,4)+240\1024,rbstr=",routinebuffersize="_rbufsiz_"K" }
	s roubufs=$fn($V($zu(40,2,26),-2,stilen)*rbufsiz/1024,"",0)_"MB"_rbstr
 }
 s ncpus=$system.Util.NumberOfCPUs()
 if Majver>2000 { // really > 5.2
 	s sznames="Global,ObjClass,Per-BDB",sztag="Gbl,Obj,BDB",szstr=$$GetSzctr(sznames)  // seize statistics
 	if Majver>2008 { 
		if Majver>2009 {
			if ($zbitlen($zversion(0))<49)||('$zbitget($zversion(0),49)) {
				s szctrs=$zu(69,74) ;0 for off, 1 for on - new in 2010.x - chg for API in 2011
			}
		}
		s $zt="initcpuerr"
		s ncpus=ncpus_":"_$$GetArchChipsCores()  ;Arch^Chips^Cores
initcpuerr ;
		k n
		s $zt=""
 	}
 } else {
	s szstr="4,2,14",sztag="Gbl,Rou,Obj" // 5.2 and lower - glo,rou,obj
 }
 i szstr="" { s nszctrs=0 } else { s nszctrs=szctrs*$l(szstr,",") }
 s numsz=nszctrs*3 // Sz, Nsz, Asz for each one.
 ; decide on offsets where they move between versions...
 i (Majver=5)&&(Minver<1) {
	;5.0 specific - no zu190!!! - oldstyle gather() and wd info
	s getwdq="getwdinf50()",maxvalglo=maxval4,glocnt=11,gmethod=0,roubase=$zu(40,2,1)
	s bdb0off=$ZU(40,2,128),bdbbase=$V($ZU(40,2,21),-2,"P"),bdbsiz=$ZU(40,29,0),wdqsizoff=$ZU(40,29,2),off=$V(bdb0off,-2,4),vwlocn=bdbbase+wdqsizoff
	s ppgstats=0
 } else {
	s getwdq="getwdinfzu()",numbuff=$zu(190,2),ijulock=1,glocnt=$l($zu(190,6,1),","),gmethod=1
	s ppgstats=glocnt'<20
	s jrninzu=glocnt'<23
 	i $zu(40,0,76)=4 { s maxvalglo=maxval4 } else { s maxvalglo=18446744073709551610 }
 	; wij only appears in >= 5.1... but handled by glocnt
 	; routine cache misses appears in >= 2007.1 but handled by glocnt
 	i glocnt>14 s glocnt=14
 }
 s ecpconncol=glocnt+numsz+2,alen=ecpconncol+5,maxeccon=$system.ECP.MaxClientConnections() i 'maxeccon s alen=ecpconncol-1
 o fname:"AWS":5
 i '$T s fileok=0 w "unable to open output file ("_fname_")",!
 e  d heading(fname)
 i pmode&&'pagesz d heading(0)
 q
initerr
 ; handle init errs
 q
loop
 d gather(.oldval,gmethod)
 f ii=1:1:lcnt {
 	g:(cnt=-1)&&$d(^zmgstat(reqname,"stop")) End
 	h dly
	d gather(.newval,gmethod)
	d diffandfix()
	i fileok u fname d output
	i pmode { u 0 i pagesz&&(ii-1#pagesz=0) { d heading(0) } d output }
 }
End i fileok u fname w ! c fname i (reqname'="")&&($d(^zmgstat(reqname))) k ^zmgstat(reqname)
 q
gather(array,usezu)
 i usezu {
	s zustats1=$zu(190,6,1) ; glostat
	For i=1:1:glocnt S array(i)=$P(zustats1,",",i)
 } else {	; old (5.0) glostat, gloref,glorefclient,logrd,phyrd,phywr,gloset,glosetclient,roulines
	for i=1:1:glocnt s array(i)=$v((i-1)*4+roubase,-2,4) ;;;incomplete!!???10/22
 }
 d @getwdq,getwdp()
 s i=glocnt
 i $g(jrninzu) {
	 s array($i(i))=$p(zustats1,",",23) ; jrnwrites
 } else {
	 s array($i(i))=$v($zu(40,2,94),-2,4) ; jrnwrites
 }
 for jsz=1:1:nszctrs { s j=$p(szstr,",",jsz),szstat=$zu(162,3,j),array($i(i))=$p(szstat,","),array($i(i))=$p(szstat,",",2),array($i(i))=$p(szstat,",",3) }
 i maxeccon s estats=$p($system.ECP.GetProperty("ClientStats"),",",1,21),array($i(i))=+$system.ECP.NumClientConnections(),array($i(i))=$p(estats,",",2),array($i(i))=$p(estats,",",6),array($i(i))=$p(estats,",",7),array($i(i))=$p(estats,",",19),array($i(i))=$p(estats,",",20)
 i ppgstats s array($i(i))=$p(zustats1,",",20),array($i(i))=$p(zustats1,",",21)
 q
diffandfix() ; note - this does not work if someone zeroed the counters manually
 f i=1:1:glocnt {
	i newval(i)<oldval(i) {
		s dispval(i)=(maxvalglo-oldval(i)+newval(i))\dly
		i dispval(i)>1000000000 s dispval(i)=newval(i)\dly
	} else {
		s dispval(i)=(newval(i)-oldval(i))\dly
	}
	s oldval(i)=newval(i)
 }
 s rdratio=$s(dispval(8)=0:0,1:$num(dispval(7)/dispval(8),2))
 s grratio=$s(dispval(6)=0:0,1:$num(dispval(5)/dispval(6),2))
 i maxeccon s dispval(ecpconncol)=newval(ecpconncol)
 f i=glocnt+1:1:ecpconncol-1,ecpconncol+1:1:alen+$s(ppgstats:2,1:0) {
	i newval(i)<oldval(i) {
		s dispval(i)=(maxval4-oldval(i)+newval(i))\dly
		i dispval(i)>1000000000 s dispval(i)=newval(i)\dly
	} else {
		s dispval(i)=(newval(i)-oldval(i))\dly
	}
	s oldval(i)=newval(i)
 }
 if nszctrs>0 {
	f i=glocnt+2:3:glocnt+numsz-1 {
		i 'dispval(i) { 
			s (dispval(i+1),dispval(i+2))="0"
		} else {
			s dispval(i+1)=$num(dispval(i+1)/dispval(i)*100,2)
			s dispval(i+2)=$num(dispval(i+2)/dispval(i)*100,2)
		}
	}
 }
 q
output
 k nodisp
 if $I=$P merge nodisp=NODisp
 w !,$zd($h)_", "_$zt($p($h,",",2))
 w:'$G(nodisp(1)) ","_$j(dispval(5),9)
 w:'$G(nodisp(2)) ","_$j(dispval(6),9)
 w:'$G(nodisp(3)) ","_$j(grratio,8)
 w:'$G(nodisp(4)) ","_$j(dispval(8),8)
 w:'$G(nodisp(5)) ","_$j(rdratio,8)
 w:'$G(nodisp(6)) ","_$j(dispval(10),8)
 w:'$G(nodisp(7)) ","_$j(dispval(11),9)
 w:'$G(nodisp(8)) ","_$j(dispval(1),8)
 w:'$G(nodisp(9)) ","_$j(dispval(2),9)
 w:'$G(nodisp(10)) ","_$j(dispval(3),8)
 w:'$G(nodisp(11)) ","_$j(dispval(4),8)
 w:'$G(nodisp(12)) ","_$j(dispval(9),8)
 w:'$G(nodisp(13)) ","_$j(wdqsz,8)
 i '$G(nodisp(14)),$d(numbuff) w ","_$j(twdq,8)
 w:'$G(nodisp(15)) ","_$j(wdphase,8) 
 i glocnt>12 w:'$G(nodisp(16)) ","_$j(dispval(13),8) 
 i glocnt>13 w:'$G(nodisp(17)) ","_$j(dispval(14),8)
 w:'$G(nodisp(18)) ","_$j(dispval(glocnt+1),8) 
 s icnt=1
 f i=1:1:numsz {
     ; global/rou/obj nseize/aseize are nodisp-100+
     ; and start at dispval(glocnt+2) and go up...
	 w:'$G(nodisp(100+icnt)) ","_$j(dispval(i+glocnt+1),8) 
	 s icnt=icnt+1
 }
 s icnt=0
 f i=glocnt+numsz+2:1:alen {
     ; ECP are nodisp 19-24 and start at glocnt+numsz+1 and go up...
	 w:'$G(nodisp(19+icnt)) ","_$j(dispval(i),8) 
	 s icnt=icnt+1
 }
 i $d(ijulock) {
	 w:'$G(nodisp(25)) ","_$j(wdpass,8)
	 w:'$G(nodisp(26)) ","_$j(ijucnt,8)
	 w:'$G(nodisp(27)) ","_$j(ijulock,8)
 }
 i ppgstats {
	 ; PPG are nodisp 28,29 and start at alen+1
	 f i=0,1 w:'$G(nodisp(28+i)) ","_$j(dispval(alen+i+1),8)
 }
 q
   ;External entry point where terminal display is limited to
   ;132 columns but output file contains full set of stats. You
   ; can choose which columns you want.
   ;  0 - display column in output
   ;  1 - don't display column 
dsp132(dly,cnt,reqname,pagesz)  ; 
 n (dly,cnt,reqname,pagesz)
 s NODisp(1)=0    ; Glorefs
 s NODisp(2)=1    ; RemGrefs
 s NODisp(3)=0    ; GRratio
 s NODisp(4)=0    ; PhyRds
 s NODisp(5)=1    ; Rdratio
 s NODisp(6)=0    ; Gloupds
 s NODisp(7)=1    ; RemGupds
 s NODisp(8)=0    ; Rourefs
 s NODisp(9)=1    ; RemRrefs
 s NODisp(10)=1   ; RouLaS
 s NODisp(11)=1   ; RemRLaS
 s NODisp(12)=0   ; PhyWrs
 s NODisp(13)=0   ; WDQsz 
 s NODisp(14)=1   ; WDtmpq
 s NODisp(15)=0   ; WDphase 
 s NODisp(16)=1   ; WIJwri 
 s NODisp(17)=1   ; RouCMs
 s NODisp(18)=0   ; Jrnwrts
 s NODisp(19)=1   ; ActECP
 s NODisp(20)=1   ; Addblk
 s NODisp(21)=1   ; PrgBufL
 s NODisp(22)=1   ; PrgSrvR
 s NODisp(23)=1   ; BytSnt
 s NODisp(24)=1   ; BytRcd
 s NODisp(25)=0   ; WDpass
 s NODisp(26)=0   ; IJUcnt
 s NODisp(27)=0   ; IJULock
 s NODisp(28)=1   ; PPGrefs
 s NODisp(29)=1   ; PPGupds
 ; seizes change w/version now
 s NODisp(101)=1  ; GblSz
 s NODisp(102)=1  ; pGblNsz
 s NODisp(103)=1  ; pGblAsz
 s NODisp(104)=1  ; RouSz/ObjSz
 s NODisp(105)=1  ; ''pNsz
 s NODisp(106)=1  ; ''pAsz
 s NODisp(107)=1  ; ObjSz/BDBSz
 s NODisp(108)=1  ; ''pNsz
 s NODisp(109)=1  ; ''pAsz
 d init
 d loop
 q
heading(file) 
 u file
 i file'=0 w hfname_","_"MGSTATv2.9a"_",wdcycle="_wdcycle_",globalbuffers="_globufs_",routinebuffers="_roubufs_",numberofcpus="_ncpus_",productversion="_$zv
 k nodisp
 if file=0 merge nodisp=NODisp
 w !,"Date,       Time    "
 w:'$G(nodisp(1)) ",  Glorefs"
 w:'$G(nodisp(2)) ", RemGrefs"
 w:'$G(nodisp(3)) ", GRratio"
 w:'$G(nodisp(4)) ",  PhyRds"
 w:'$G(nodisp(5)) ", Rdratio"
 w:'$G(nodisp(6)) ", Gloupds"
 w:'$G(nodisp(7)) ", RemGupds"
 w:'$G(nodisp(8)) ", Rourefs"
 w:'$G(nodisp(9)) ", RemRrefs"
 w:'$G(nodisp(10)) ",  RouLaS"
 w:'$G(nodisp(11)) ", RemRLaS"
 w:'$G(nodisp(12)) ",  PhyWrs"
 w:'$G(nodisp(13)) ",   WDQsz" 
 i '$G(nodisp(14)),$d(numbuff) w ",  WDtmpq"
 w:'$G(nodisp(15)) ", WDphase" 
 i '$G(nodisp(16)),(glocnt>12) w ",  WIJwri" 
 i '$G(nodisp(17)),(glocnt>13) w ",  RouCMs"
 w:'$G(nodisp(18)) ", Jrnwrts"  ;glocnt+1
 s icnt=100
 f i=1:1:nszctrs {
	s rsc=$p(sztag,",",i)
 	w:'$G(nodisp(icnt+i)) ",   "_rsc_"Sz"
 	w:'$G(nodisp(icnt+i)) ", p"_rsc_"Nsz"
 	w:'$G(nodisp(icnt+i)) ", p"_rsc_"Asz"
 	s icnt=icnt+3
 }
 i maxeccon {
	 w:'$G(nodisp(19)) ",  ActECP"
	 w:'$G(nodisp(20)) ",  Addblk"
	 w:'$G(nodisp(21)) ", PrgBufL"
	 w:'$G(nodisp(22)) ", PrgSrvR"
	 w:'$G(nodisp(23)) ",  BytSnt"
	 w:'$G(nodisp(24)) ",  BytRcd"
 }
 i $d(ijulock) {
	 w:'$G(nodisp(25)) ",  WDpass"
	 w:'$G(nodisp(26)) ",  IJUcnt"
	 w:'$G(nodisp(27)) ", IJULock"
 }
 i ppgstats {
	 w:'$G(nodisp(28)) ", PPGrefs"
	 w:'$G(nodisp(29)) ", PPGupds"
 }
 q
getwdinfzu()
 s twdq=0 f b=1:1:numbuff { s twdq=twdq+$p($zu(190,2,b),",",10) }
 s wdinf=$zu(190,13),wdpass=$p(wdinf,","),wdqsz=$p(wdinf,",",2),twdq=twdq-wdqsz i twdq<0 s twdq=0
 s misc=$zu(190,4),ijulock=$p(misc,",",4),ijucnt=$p(misc,",",5)
 q
getwdinf50()
 s wdqsz=0,last=maxval4
 f i=0:1:5 d  q:off=maxval4
 . s off=$V(bdb0off+(i*4),-2,4)
 . q:(off=last)!(off=maxval4)
 . s wdqsz=wdqsz+$V(vwlocn+off,-3,4)
 . s last=off
 Q
getwdp()
 s wdphase=0 q:'$V(wdwchk,-2,4)
 q:'wdphaseoff
 s wdphase=$V(wdphaseoff,-2,4)
 Q
version()	q "MGSTATv2.9a"
start(dly,rqname)
 n (dly,rqname)
 q:($l(rqname)=0) 0
 q:dly<1 0
 s $zt="chkjob"
 i rqname'["." s rqname=rqname_".mgst"
 s cj=$g(^zmgstat(rqname),1)
 s stat=$v(-1,cj)
 i stat["mgstat" q 0
 k ^zmgstat(rqname)
carryon
 j ^mgstat(dly,-1,rqname)::5
 i '$T q 0
 s ^zmgstat(rqname)=$zc
 q $zc
chkjob ; error trap for start
 i $ze["NOJOB" g carryon
 q 0
stop(rqname) ;
 q:($l(rqname)=0) 0
 i rqname'["." s rqname=rqname_".mgst"
 i $d(^zmgstat(rqname)) s ^zmgstat(rqname,"stop")=1 q 1
 q 0
GetArchChipsCores() private {  ;Returns <Arch>^<# Chips>^<# Cores>
    if $D(^oddDEF("%SYSTEM.CPU")) {
	   s n=##class(%SYSTEM.CPU).%New() 
	   s Arch=n.Arch
	   s nChips=n.nChips
	   s nCores=n.nCores
    } else {
	   ; These are all here in case we want more later
 	   Set Arch=$zu(204,1)
	   Set Model=$zu(204,2)
	   Set Vendor=$zu(204,3)
	   Set nThreads=$zu(204,4)
	   Set nCores=$zu(204,5)
	   Set nChips=$zu(204,6)
	   Set nThreadsPerCore=$zu(204,7)
	   Set nCoresPerChip=$zu(204,8)
	   Set MTSupported=$zu(204,9)
	   Set MTEnabled=$zu(204,10)
	   Set MHz=$zu(204,11)	
    }
	quit Arch_"^"_nChips_"^"_nCores
}
GetVersionInfo(majver,minver,os) PRIVATE {
    if $D(^oddDEF("%SYSTEM.CPU")) {
 	   s majver=$System.Version.GetMajor()
 	   s minver=$System.Version.GetMinor()
	   s os=$System.Version.GetCompBuildOS()
    } else {
	   s zv=$ZV
 	   s majver=$p($p($p(zv,") ",2)," ",1),".",1)
 	   s minver=$p($p($p(zv,") ",2)," ",1),".",2)
	   If zv["Windows" {
		   Set os="Windows"
	   } elseif zv["UNIX" {
		   Set os="UNIX"
	   } elseif zv["VMS" {
		   Set os="VMS"
	   } else {
 		   Set os="N/A"
	   }
    }
}
GetSzctr(Longnames) private {
	s allsznames=$zu(162,0)_",",zuctr=""
	f i=1:1:$l(Longnames,",") {
		s ctr=$p(Longnames,",",i)
		continue:(ctr="")||(ctr="Unused")
		s nctr=$l($e(allsznames,1,$find(allsznames,ctr)),",")-1
		continue:nctr=0
		i zuctr="" {
			s zuctr=nctr
		} else {
			s zuctr=zuctr_","_nctr
		}
	}
	quit zuctr
}

mrstat^INT^1^67214,47331
run(file, deltas, wait, lines, pages) public {
	; Copyright (c) 2025 by InterSystems Corporation.
	; Cambridge, Massachusetts, U.S.A.  All rights reserved.
	; Confidential property of InterSystems Corporation.
 try {
	s:'$d(wait) wait=2
	s:'$d(lines) lines=10
	s:'$d(pages) pages=1
	s hdr0=$zu(190,6,-4),hdr1=$zu(190,6,-5),hdr2=$zu(190,6,-6)
	if $d(file) {
		o file:"NW":3 e  w !,"Failed to open ",file q
		use file
	}
	set last=$zu(190,6,6)
	for i=1:1:pages {
		w "time,",hdr1,hdr2,"Rtn cache,Cls cache,",!
		for j=1:1:lines {
			h wait
			s stats=$zu(190,6,6)
	    		s time=$zdt($h,3)
			w time,",",$zu(190,6,5)
			i '$get(deltas) { w $zu(190,6,6) }
			else {
				; print deltas of $zu(190,6,6) stats
				f d1=1:1:$l(stats,",")-1 {
					s sp=$p(stats,",",d1),lp=$p(last,",",d1)
					if sp["^" {
						f d2=1:1:$l(sp,"^")-1 w $p(sp,"^",d2)-$p(lp,"^",d2),"^"
						w ","
					} else { w sp-lp,"," }
				}
				s last=stats
			}
			w $tr($zu(96,29),",","^"),",",$tr($zu(96,36),",","^"),",",!
	    	}
	}	
 } catch {
	if $d(file) {
     		c file
     	}
 }
}




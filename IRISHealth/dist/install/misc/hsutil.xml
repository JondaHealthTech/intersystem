<?xml version="1.0" encoding="UTF-8"?>
<Export generator="IRIS" version="26" zv="IRIS for Windows (x86-64) 2024.1.3 (Build 456U)" ts="2025-01-09 13:37:50">
<Class name="%ZHSLIB.AbstractAvailability">
<Description>
Determine whether a module is available for a particular namespace</Description>
<Abstract>1</Abstract>
<TimeChanged>67214,49066.4187633</TimeChanged>
<TimeCreated>67214,49066.4187633</TimeCreated>

<Method name="IsAvailable">
<Description>
Callback that is invoked from %IPM.Main.IsAvailable()
Subclasses SHOULD override this method.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace:%String,pArgs...</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit 1
]]></Implementation>
</Method>
</Class>


<Class name="%ZHSLIB.AbstractInstaller">
<Description>
Abstract base class that defines the interface for product-level
Installer.Install classes.</Description>
<Abstract>1</Abstract>
<TimeChanged>67214,49066.4208369</TimeChanged>
<TimeCreated>67214,49066.4208369</TimeCreated>

<Parameter name="Version">
<Description><![CDATA[
DEPRECATED. NO LONGER USED. Version is read from module.xml instead. <br />]]></Description>
<Deprecated>1</Deprecated>
<Abstract>1</Abstract>
</Parameter>

<Parameter name="MaintenanceVersion">
<Description><![CDATA[
DEPRECATED. NO LONGER USED. Version is read from module.xml instead. <br />]]></Description>
<Deprecated>1</Deprecated>
</Parameter>

<Method name="OnInstallComponent">
<Description><![CDATA[
Callback that is invoked during product installation to allow for
system-level changes to be performed. Common examples of such changes include:
<ul>
<li>Definition of resources and roles</li>
<li>Definition/configuration of the product library database</li>
<li>Import of localized messages for the product</li>
</ul>
Subclasses SHOULD override this method.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDatabase:%String,pVerbose:%Boolean=0,pDevMode:%Boolean=0,pIsUpgrade:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnUnInstallComponent">
<Description>
Callback that is invoked when removing a product.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDatabase:%String,pVerbose:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnComponentVersion">
<Description><![CDATA[
DEPRECATED. NO LONGER USED. Version is read from module.xml instead. <br />

Callback to return the major version of the component. This implementation uses the <parameter>Version</parameter>, 
which must by implemented by the installer subclass (or else the subclass must override this method using some other approach). 
If not overridden, and the Version parameter is not populated, this method will throw an exception (not merely return an error status). 
<var>pMajorVersion</var> is generally set to the value of a product-level macro which defines
the major version, e.g. <code>$$$HSLIBmajorVersion</code> for HealthShare Core.]]></Description>
<Deprecated>1</Deprecated>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pMajorVersion:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	kill pMajorVersion
	Set pMajorVersion = ..#Version
	if pMajorVersion = "" {
		$$$ThrowStatus($$$ERROR($$$NotImplemented))
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnComponentMaintenanceVersion">
<Description><![CDATA[
DEPRECATED. NO LONGER USED. Version is read from module.xml instead. <br />

Callback to return the minor version of the component. This implementation uses the <parameter>MaintenanceVersion</parameter>, 
which must by implemented by the installer subclass (or else the subclass must override this method using some other approach). 
If not overridden, and the Version parameter is not populated, this method will throw an exception (not merely return an error status). 
<var>pMinorVersion</var> is generally set to the value of a product-level macro which defines
the minor version, e.g. <code>$$$HSLIBminorVersion</code> for HealthShare Core.]]></Description>
<Deprecated>1</Deprecated>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pMinorVersion:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	kill pMinorVersion
	Set pMinorVersion = ..#MaintenanceVersion
	if pMinorVersion = "" {
		$$$ThrowStatus($$$ERROR($$$NotImplemented))
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnConfigureComponent">
<Description><![CDATA[
<p>Callback that is invoked during namespace (re)activation.
Subclasses SHOULD override this method. </p><p>
pVars is an array of miscellaneous information, populated by the calling code in the installation/configuration 
framework (mainly <class>HS.Util.Installer</class>). 
Subscripts appearing in pVars include: </p>
<ul><li>
Production - set to (namespace)_"PKG.FoundationProduction"
</li><li>
LogFile - current log file for install operation 
</li><li>
Upgrade - boolean, indicating whether the current operation is an upgrade
</li><li>
Type - hardcoded to "Foundation"
</li><li>
Component - current component name
</li></ul>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pNamespace:%String,pVerbose:%Boolean=0,&pVars]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnUnconfigureComponent">
<Description>
Callback that is invoked when removing a product from a namespace.
Subclasses SHOULD override this method.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pNamespace:%String,pVerbose:%Boolean=0,pPurgeFiles:%Boolean=0,&pVars]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnUpgradeSteps">
<Description>
What to do system wide (not specific namespaces) during an upgrade. Not currently called by the framework, but present for future use. </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pPreviousVersion:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// note: if we adopt this then we may need to revisit the argument list - pPreviousVersion is ambiguous about major/minor
	set tSC = $$$OK
	
	try {
	} catch ex {
		Set tSC=ex.AsStatus()
	}
	
	quit tSC
]]></Implementation>
</Method>

<XData name="InstallationInfo">
<Description><![CDATA[
XML block that should contain XML for a <class>%ZHSLIB.Component</class>
instance that describes the current component.
Note that this XML may make use of the following expressions that will be substituted during parsing:
<ul>
<li><code>{$expression{COSExpression}}</code></li>
<li><code>{$method{COSExpression}}</code></li>
</ul>
Where <code>COSExpression</code> is a valid expression.
An example of such an expression would be as follows:
<example language="none">
&lt;Version>{$expression{$parameter("Installer.Install","Version")}}&lt;/Version>
</example>]]></Description>
</XData>
</Class>


<Class name="%ZHSLIB.AbstractStartupItem">
<Description><![CDATA[
Abstract base class for system startup items. Some characteristics are defined
via overridable class parameters, and the main set of behavior is determined
only by the implemented logic. An implementation of the OnSystemStartup method
does not take input parameters.<br>]]></Description>
<Abstract>1</Abstract>
<TimeChanged>67214,49066.408355</TimeChanged>
<TimeCreated>67214,49066.408355</TimeCreated>

<Parameter name="Name">
<Description>
Optional descriptive name to use in logging messages regarding the execution of this class.</Description>
<Type>STRING</Type>
</Parameter>

<Parameter name="ExecutionContext">
<Description>
Permitted execution context. 1 = Startup only (default), 2 = System becoming primary (also startup in non-mirrored)</Description>
<Type>INTEGER</Type>
<Default>1</Default>
</Parameter>

<Method name="OnSystemStartup">
<Description><![CDATA[
Method invoked by Startup loop. Implementation of this class implements this method.<br>
- Expected startup mode is as a background job.<br>
- Expected startup namespace is HSLIB.<br>]]></Description>
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
</Method>

<Method name="AddToStartupTable">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[	$$$ThrowOnError( ##class(%ZHSLIB.HealthShareMgr).InsertStartupItem($Classname()) )
]]></Implementation>
</Method>
</Class>


<Class name="%ZHSLIB.Audit.Log">
<Description>
To use the audit log, first define a log entry by calling:
##ClassMethod(%ZHSLIB.Audit.Log).CreateLog( arguments ) to define the overall entry.  This will return a reference to a log object.
Next, on the log object, for each "participant" (patient, doctor, etc.) call AddParticipant( arguments) to add these to the log.
If SDA is being logged, that needs its own call: LogSDA(sda)
Finally, on the log object, call SaveLog().

See the documentation for CreateLog for chaining log items together.</Description>
<IncludeCode>%ZHSLIB</IncludeCode>
<Super>%Persistent,%XML.Adaptor</Super>
<System>4</System>
<TimeChanged>67214,49066.5908306</TimeChanged>
<TimeCreated>67214,49066.5908306</TimeCreated>
<Inheritance>right</Inheritance>

<Property name="LogID">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN"/>
</Property>

<Index name="LogIDIndex">
<Properties>LogID</Properties>
</Index>

<Property name="InitiatingLogID">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN"/>
</Property>

<Index name="InitiatingLogIDIndex">
<Properties>InitiatingLogID</Properties>
</Index>

<Property name="EventID">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN"/>
</Property>

<Property name="OtherEvent">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="LogStart">
<Type>%TimeStamp</Type>
</Property>

<Property name="LogEnd">
<Type>%TimeStamp</Type>
</Property>

<Property name="SourceID">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="UserID">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="ProxyUserID">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="Roles">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="AccessGateway">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="Participants">
<Type>%ZHSLIB.Audit.LogParticipant</Type>
<Cardinality>children</Cardinality>
<Inverse>Log</Inverse>
<Relationship>1</Relationship>
</Property>

<Method name="CreateLog">
<Description><![CDATA[
Arguments:
<li> pLogRef: By reference, to return the OREF to the created log
<li> pInitiaingLogID: This argument is used by reference to chain log events together.  For the first event, pass in an empty string, and this will generate a log ID.
For subsequent events, pass in this generated log ID.  The log ID is unique throughout the HealthShare installation.
It's generated by a combination that identifies the computer name, ensemble instance, namespace, and a sequential number.
<li> pEventID: This identifies the type of event being logged.  Choices are (so far): ConsentUpdate,
PatientSearch, SearchPatient, BreakGlass, RecordRequest, and Other
<li> pOtherEvent:Required for event ID of Other
<li> pLogStart: Optionally, pass in a timestamp.  If missing, this will use the current time
<li> pSourceID: Optionally, pass is an identifier of the unique "application" that was the source of
this audit event.  If missing, this will use the same prefix as the generated log ID.
<li> pUserID: Pass is an identifier of the user who was the "active participant" for this event.
The User might not be a person, for system generated events. UserID must uniquely identify
a person or system within the Source ID
<li> pRoles: Pass in the Roles for this user
<li> pAccessGateway: Pass in the name of the access gateway where it all started
<li> pProxyUserID - if the user is acting as a proxy for someone else, this will be the proxied one
<br> Returns: a status message - $$$OK, etc.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pLogRef:%ZHSLIB.Audit.Log,&pInitiatingLogID:%String="",pEventID:%String="",pOtherEvent:%String="",pLogStart:%TimeStamp={$ZDT($ZTIMESTAMP,3,1,3)},pSourceID:%String="",pUserID:%String="",pRoles:%String="",pAccessGateway:%String="",pProxyUserID:%String=""]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set pLogRef= ##Class(%ZHSLIB.Audit.Log).%New(.err, pInitiatingLogID, pEventID, pOtherEvent, pLogStart, pSourceID, pUserID, pRoles, pAccessGateway, pProxyUserID)
	IF 'pLogRef {QUIT err}
	Set pInitiatingLogID=pLogRef.InitiatingLogID
	QUIT $$$OK
]]></Implementation>
</Method>

<Method name="AddParticipant">
<Description><![CDATA[
Arguments:
<li> pType: (see %ZHSLIB.Audit.LogParticipant)
<li> pOtherType: if type is O, this is required
<li> pID: The identifier (i.e. the MRN, or patient ID, or doctor or facility identifier, etc.)
<li> pIDText: Optional string name for pID - ex: patient or doctor name
<li> pDetail: Optional string blob with details specific to each type of event & participant.
See audit trail design document on HealthShare Wiki for what should go here.]]></Description>
<FormalSpec>pType:%String="",pOtherType:%String="",pID:%String="",pIDText:%String="",pDetail:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s err=""
	S x=##Class(%ZHSLIB.Audit.LogParticipant).%New(.err, pType, pOtherType, pID, pIDText, pDetail, ##this)
	IF 'x Q err
	S n=..ParticipantList.Insert(x)
	QUIT $$$OK
]]></Implementation>
</Method>

<Method name="LogSDA">
<Description>
Argument: SDA document.
 SDA is kept separate from the rest of the data in order to preserve privacy and confidentiality
 It can be a string, a Stream, or an XML adapter</Description>
<FormalSpec>pSDA</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:pSDA="" $$$OK
	IF '$IsObject(pSDA) {DO ..SDA.Write(pSDA) QUIT $$$OK}
	If 'pSDA.%Extends("%Stream.Object") {
		IF '(pSDA.%Extends("%XML.Adaptor")) {
			Do ##class(Ens.Util.Log).LogError($Classname(),"LogSDA","invalid argument, class was " _ pSDA.%PackageName()_"."_pSDA.%ClassName()_", expected %Stream.Object or %XML.Adaptor")
			Quit $$$ERROR($$$InvalidArgument)
		}
		Set tSDA=##Class(%Stream.GlobalCharacter).%New()
		Do pSDA.XMLExportToStream(.tSDA)
		Set ..SDA=tSDA Quit $$$OK
	}
	Set tSC=..SDA.CopyFrom(pSDA) Quit tSC
]]></Implementation>
</Method>

<Method name="SaveLog">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set:..LogEnd="" ..LogEnd=$ZDT($ZTIMESTAMP,3,1,3)
	//IF $SYSTEM.SQL.RoleExists("%DB_HSAudit") {New $Roles Set $Roles="%DB_HSAudit"}
	Lock +^HS.Audit("Singlethread") //Force the save to be single threaded, to avoid contention from simultaneous saves of stream
	Try {
		Set tSC=..%Save()
	} Catch ex {
		Set tSC=ex.AsStatus()
	}
	Lock -^HS.Audit("Singlethread") Quit tSC
]]></Implementation>
</Method>

<Method name="SaveIHE">
<Description>
Utility Method used to save IHE logs, when stored in a secured tamperproof database</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pIHELog:%Persistent</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If '(pIHELog.%IsA("HS.IHE.ATNA.Repository.Data.AuditMessage"))&&'(pIHELog.%IsA("HS.IHE.ATNA.Repository.Aggregation")) Quit $$$ERROR($$$HSAudErrSaveIHEType)
	Set tDB=$G(^%SYS("HealthShare","AuditDB"))
	IF tDB'=""&&$SYSTEM.SQL.RoleExists("%DB_"_tDB)&&'pIHELog.%Id() {
		Set tRoles=$Roles
		New $Roles Set $Roles=tRoles_",%DB_"_tDB
	}
	Quit pIHELog.%Save()
]]></Implementation>
</Method>

<Method name="NewInitiatingLog">
<Description>
Utility Method to generate unique initiating log ID</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	//IF $SYSTEM.SQL.RoleExists("%DB_HSAudit") {New $Roles Set $Roles="%DB_HSAudit"}
	Set tGlobalTime = $ZTIMESTAMP
	Quit $$$UniqueGlobalLoginID(tGlobalTime)
]]></Implementation>
</Method>

<Method name="AddSDA">
<Description>
This may be called to add SDA to an already saved log.
It will return an error if the SDA already has been logged</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pLogID,pSDA</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	IF pSDA="" QUIT $$$OK
	&sql(SELECT %ID INTO :tID FROM Log WHERE LogID=:pLogID)
	IF %ROWCOUNT'=1 QUIT $$$ERROR($$$HSAudErrAddSDANoLog)
	Set tLog=##Class(%ZHSLIB.Audit.Log).%OpenId(tID)
	IF '(tLog.SDA.IsNull()) QUIT $$$ERROR($$$HSAudErrOverwriteSDA)
	Set tSC=tLog.LogSDA(pSDA) Q:'tSC tSC
	Quit tLog.SaveLog()
	/*IF $SYSTEM.SQL.RoleExists("%DB_HSAudit") {New $Roles Set $Roles="%DB_HSAudit"}
	IF $D(^HS.Audit("LogSDA",pLogID)) QUIT $$$ERROR($$$HSAudErrOverwriteSDA)
	S ^HS.Audit("LogSDA",pLogID)=pSDA
	QUIT $$$OK */
]]></Implementation>
</Method>

<Method name="CreateSDALog">
<Description>
New Method used as of SMB1026 to create a log to store the fetched SDA</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pInitiatingLogID:%String,pEventID:%String,pSDA:%Stream.Object,*pLogId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tLog=..%New("SDA",.pInitiatingLogID,pEventID),pLogId=tLog.LogID
	Set tSC=tLog.SDA.CopyFrom(pSDA) Quit:$$$ISERR(tSC) tSC
	//IF $SYSTEM.SQL.RoleExists("%DB_HSAudit") {New $Roles Set $Roles="%DB_HSAudit"}
	Quit tLog.%Save()
]]></Implementation>
</Method>

<Method name="%OnNew">
<Description>
Method is being transitioned as of SMB1026 - the data will only be used to store the fetched SDAs on the edge,
and we will no longer log anything else here.  To ease the transition, we'll pass in pErr as "SDA" for new uses,
along with pEventId and pInitiatingLogID</Description>
<FormalSpec><![CDATA[&pErr:%String,pInitiatingLogID:%String,pEventID:%String,pOtherEvent:%String="",pLogStart:%TimeStamp={$ZDATETIME($ZTIMESTAMP,3,1,3)},pSourceID:%String,pUserID:%String,pRoles:%String,pAccessGateway:%String,pProxyUserID:%String=""]]></FormalSpec>
<Private>1</Private>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	If $G(pErr)="SDA" {
		//IF $SYSTEM.SQL.RoleExists("%DB_HSAudit") {New $Roles Set $Roles="%DB_HSAudit"}
		Set ..EventID=pEventID, ..InitiatingLogID=pInitiatingLogID
		Set tGlobalTime = $ZTIMESTAMP
		Set ..LogID = $$$UniqueGlobalLoginID(tGlobalTime)
		Set ..LogStart = pLogStart
		Quit $$$OK
	}
	Set pErr="",source=$ZU(131,1)_":"_$ZNSPACE
	Set:pSourceID="" pSourceID=source
	IF ",ConsentUpdate,PatientSearch,SearchPatient,SearchPatientBreakGlass,RecordRequestBreakGlass,RecordRequest,ViewRecords,ExportRecords,DocumentRequest,DocumentSend,AddRelationship,RemoveRelationship,Other,ConsentEvaluation,ConsentEvaluationBreakGlass,"'[(","_$P(pEventID,"-")_",") { s pErr= $$$ERROR($$$HSAudErrBadEventID) QUIT pErr}
	IF pUserID="" { s pErr= $$$ERROR($$$HSAudErrMissingUserID) QUIT '$$$OK}
	IF (pEventID="Other") & (pOtherEvent="") {s pErr= $$$ERROR($$$HSAudErrMissingOtherEvent) QUIT '$$$OK}
	Set ..EventID=pEventID, ..LogStart=pLogStart, ..SourceID=pSourceID, ..UserID=pUserID, ..Roles=pRoles
	IF pOtherEvent'="" {Set ..OtherEvent=pOtherEvent}
	//Set tSC=##Class(%SYS.AuditGeneric).Increment("^HS.Audit.LogCounter",.logCounter)
	//IF 'tSC {s pErr=tSC QUIT tSC}
	//Set ..LogID=source_":"_logCounter /// systemwide unique ID
	//IF $SYSTEM.SQL.RoleExists("%DB_HSAudit") {New $Roles Set $Roles="%DB_HSAudit"}
	Set tGlobalTime = $ZTIMESTAMP
	Set ..LogID = $$$UniqueGlobalLoginID(tGlobalTime) /// systemwide unique ID
	IF pInitiatingLogID = "" Set pInitiatingLogID = ..LogID
	Set ..InitiatingLogID = pInitiatingLogID
	Set:pAccessGateway="" pAccessGateway=$P(pInitiatingLogID,":",1,3)
	Set ..AccessGateway = pAccessGateway
	Set ..ProxyUserID=pProxyUserID
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="AssignLogID">
<Description>
This class method can be called form the hub or any gateway to increment the log counter
and to assign a globally unique log ID.  It can be called, for instance, on the access gateway
in order to get the initiating log ID that will be used to tie together a sequence of lookups, retrievals,
and viewing.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pLogID:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	//IF $SYSTEM.SQL.RoleExists("%DB_HSAudit") {New $Roles Set $Roles="%DB_HSAudit"}
	Set tGlobalTime = $ZTIMESTAMP
	Set pLogID = $$$UniqueGlobalLoginID(tGlobalTime)
	Quit $$$OK
]]></Implementation>
</Method>

<Property name="ParticipantList">
<Type>%ZHSLIB.Audit.LogParticipant</Type>
<Collection>list</Collection>
<Private>1</Private>
<Transient>1</Transient>
</Property>

<Property name="SDA">
<Type>%Stream.GlobalCharacter</Type>
</Property>

<Query name="ByEventID">
<Description><![CDATA[
Query used for Audit Actions.  Two arguments:
<li> EventType - the type of event desire.
<li> AfterID - to retrieve all audit events whose %ID is after this argument (0 means all)]]></Description>
<Type>%SQLQuery</Type>
<FormalSpec>EventType:%String,AfterID:%Integer</FormalSpec>
<SqlQuery><![CDATA[SELECT %ID,EventID,InitiatingLogID,LogEnd,LogID,LogStart,OtherEvent,SourceID,UserID,Roles,AccessGateway FROM Log
 WHERE ( (EventID = :EventType) OR (:EventType='') ) AND (%ID > :AfterID)
 ORDER BY %ID]]></SqlQuery>
<Parameter name="CONTAINID" value="1"/>
</Query>

<Query name="AfterID">
<Type>%SQLQuery</Type>
<FormalSpec>AfterID:%Integer</FormalSpec>
<SqlQuery><![CDATA[SELECT %ID,EventID,InitiatingLogID,LogEnd,LogID,LogStart,OtherEvent,SourceID,UserID,Roles,AccessGateway FROM Log
 WHERE  %ID > :AfterID
 ORDER BY %ID]]></SqlQuery>
<Parameter name="CONTAINID" value="1"/>
</Query>

<Method name="NextID">
<ClassMethod>1</ClassMethod>
<FormalSpec>pAfterID:%Integer</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	&SQL(SELECT TOP 1 %ID INTO :tID FROM Log WHERE %ID > :pAfterID ORDER BY %ID)
	Set:SQLCODE'=0 tID=0
	Quit tID
]]></Implementation>
</Method>

<Method name="NextSysAudit">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pUTCTimeStamp:%String,&pSystemID:%String,&pAuditIndex:%BigInt,&pProperties:%String]]></FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set tNext="A",tTime=pUTCTimeStamp,tSys=pSystemID,tAud=pAuditIndex,tFound=0,tNS=$ZNSPACE
	IF ","_$Roles_","[",%All," {
		Set $ZT="Trap"
		ZN "%SYS"
		Do {
			IF tTime=""!(tNext="T") {Set tTime=$O($$$HSAuditGbl(tTime)) QUIT:tTime=""}
			IF tSys="" !(tNext="S") Set tSys=$O($$$HSAuditGbl(tTime,tSys)) IF tSys="" {Set tNext="T" CONTINUE}
			Set tAud=$O($$$HSAuditGbl(tTime,tSys,tAud)) IF tAud="" {Set tNext="S" CONTINUE}
			Set tFound=1
		} WHILE tTime'=""&'tFound
		IF tFound {
			Set pUTCTimeStamp=tTime,pSystemID=tSys,pAuditIndex=tAud
			DO ##Class(%SYS.Audit).Get(pUTCTimeStamp, pSystemID, pAuditIndex, .pProperties)
		}
		ZN tNS
	}
Exit	
	Quit tFound
Trap 
	ZN tNS
	Set $ZT=""
	GOTO Exit
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^HS.Audit("LogD")</DataLocation>
<DefaultData>LogDefaultData</DefaultData>
<IdLocation>^HS.Audit("LogD")</IdLocation>
<IndexLocation>^HS.Audit("LogI")</IndexLocation>
<StreamLocation>^HS.Audit("LogS")</StreamLocation>
<ExtentSize>100000</ExtentSize>
<Data name="LogDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>LogID</Value>
</Value>
<Value name="3">
<Value>InitiatingLogID</Value>
</Value>
<Value name="4">
<Value>EventID</Value>
</Value>
<Value name="5">
<Value>OtherEvent</Value>
</Value>
<Value name="6">
<Value>LogStart</Value>
</Value>
<Value name="7">
<Value>LogEnd</Value>
</Value>
<Value name="8">
<Value>SourceID</Value>
</Value>
<Value name="9">
<Value>UserID</Value>
</Value>
<Value name="10">
<Value>Roles</Value>
</Value>
<Value name="11">
<Value>AccessGateway</Value>
</Value>
<Value name="12">
<Value>SDA</Value>
</Value>
<Value name="13">
<Value>ProxyUserID</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZHSLIB.Audit.LogParticipant">
<IncludeCode>%ZHSLIB</IncludeCode>
<Super>%Persistent,%Populate,%XML.Adaptor</Super>
<System>4</System>
<TimeChanged>67214,49066.5786567</TimeChanged>
<TimeCreated>67214,49066.5786567</TimeCreated>
<Inheritance>right</Inheritance>

<Property name="IDTypeCode">
<Description>
We are using 21, defined by RFC 3881 as "Job Stream", for the Ensemble Session ID</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="DISPLAYLIST" value=",MRN,Patient MPIID,Report,Criteria,Other,Doctor,Facility,Session"/>
<Parameter name="VALUELIST" value=",1,2,3,10,O,D,F,21"/>
</Property>

<Property name="OtherType">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="Identifier">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN"/>
</Property>

<Property name="IdentifierText">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Index name="IdentifierIndex">
<Properties>IDTypeCode,Identifier</Properties>
</Index>

<Property name="Detail">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="Log">
<Type>%ZHSLIB.Audit.Log</Type>
<Cardinality>parent</Cardinality>
<Inverse>Participants</Inverse>
<Relationship>1</Relationship>
</Property>

<Method name="%OnNew">
<FormalSpec>*pErr:%String,pType:%String="",pOtherType:%String="",pID:%String="",pIDText:%String="",pDetail:%String="",pLog:%ZHSLIB.Audit.Log</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	IF ",1,2,3,10,D,F,O,21," '[(","_pType_",") {s pErr=$$$ERROR($$$HSAudErrBadParticipantType) QUIT '$$$OK}
	IF (pType="O") & (pOtherType="") {s pErr=$$$ERROR($$$HSAudErrMissingOtherType) QUIT '$$$OK}
	IF pID="" {s pErr= $$$ERROR($$$HSAudErrMissingIdentifier) QUIT '$$$OK}
	IF '$ISOBJECT(pLog) {s pErr= $$$ERROR($$$HSAudErrMissingParentLog) QUIT '$$$OK}
	s ..IDTypeCode=pType
	s ..OtherType=pOtherType
	Set ..Identifier=pID, ..IdentifierText=pIDText
	IF pDetail'="" Set ..Detail=pDetail
	Set ..Log=pLog
	QUIT $$$OK
]]></Implementation>
</Method>

<Query name="ByLogIDType">
<Description>
Query: pass in an ID from %ZHSLIB.Audit.Log, and a comma separated string of participant types
   1: MRN, 2: Patient MPIID, etc. as above (ex: "1,2" will pass both MRN and UID)
Note - the change requiring the comma separator is new for 2009.1, but has been required
because the types can be multiple characters</Description>
<Type>%SQLQuery</Type>
<FormalSpec>LogID:%String,Types:%String</FormalSpec>
<SqlQuery>SELECT %ID,Detail,Identifier,IdentifierText,IDTypeCode,OtherType FROM LogParticipant
 WHERE (Log = :LogID) AND (IDTypeCode %INLIST $LISTFROMSTRING(:Types,','))</SqlQuery>
<Parameter name="CONTAINID" value="1"/>
</Query>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>{%%PARENT}("Participants")</DataLocation>
<DefaultData>LogParticipantDefaultData</DefaultData>
<IdLocation>^HS.Audit("LogC","Participants")</IdLocation>
<IndexLocation>^HS.Audit("LogParticipantI")</IndexLocation>
<StreamLocation>^HS.Audit("LogParticipantS")</StreamLocation>
<Data name="LogParticipantDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>IDTypeCode</Value>
</Value>
<Value name="3">
<Value>OtherType</Value>
</Value>
<Value name="4">
<Value>Identifier</Value>
</Value>
<Value name="5">
<Value>IdentifierText</Value>
</Value>
<Value name="6">
<Value>Detail</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZHSLIB.CodeGenUtils.VerifyAbstractMembersDefined">
<Abstract>1</Abstract>
<System>3</System>
<TimeChanged>67214,49066.5772969</TimeChanged>
<TimeCreated>67214,49066.5772969</TimeCreated>

<Method name="CheckCompiledClassValidityAgainstAbstractClass">
<Description>
Checks if the necessary abstract methods and parameters have implementations in non abstract subclasses</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCompiledClassToCheck:%Dictionary.CompiledClass,pClassNameToCheckAgainst:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tBaseClass = pCompiledClassToCheck
	Quit:tBaseClass.Abstract $$$OK
	
	Set tClassWithAbstractDefinitions = pClassNameToCheckAgainst
	Set tStatus = $$$OK
	
	// #### Check that necessary methods are implemented ####
	#define GetMethodOrigin(%className, %methodName) $$$comMemberKeyGet(%className, $$$cCLASSmethod, %methodName, $$$cMETHorigin)
	#define IsAbstractMethod(%className, %methodName) $$$comMemberKeyGet(%className, $$$cCLASSmethod, %methodName, $$$cMETHabstract)
	// Get abstract method names in tClassWithAbstractDefinitions
	Set tMethodsToBeImplemented = "", tMethodName = ""
	While 1 {
		Set tMethodName = $$$comMemberNext(tClassWithAbstractDefinitions, $$$cCLASSmethod, tMethodName)
		Quit:(tMethodName = "")
		If $$$IsAbstractMethod(tClassWithAbstractDefinitions, tMethodName) {
			Set tMethodsToBeImplemented = tMethodsToBeImplemented_","_tMethodName
		}
	}
	Set tMethodsToBeImplementedList = $ListFromString(tMethodsToBeImplemented)
	// Loop through abstract methods, throwing an error if not implemented
	Set tPtr = 0
	While $ListNext(tMethodsToBeImplementedList, tPtr, tMethodName) {
		Continue:(tMethodName = "")
		If $$$GetMethodOrigin(tBaseClass.Name, tMethodName) = tClassWithAbstractDefinitions {
			Set tStatus = $$$ERROR($$$GeneralError, "Implementation must be provided for method "_tMethodName)
			Quit
		}
	}
	
	// #### Check that necessary parameters are initialized ####
	#define GetParameterValue(%className, %paramName) $$$comMemberKeyGet(%className, $$$cCLASSparameter, %paramName, $$$cPARAMVALUEdefault)
	#define IsAbstractParameter(%className, %paramName) $$$comMemberKeyGet(%className, $$$cCLASSparameter, %paramName, $$$cPARAMabstract)
	// Get abstract parameter names in tClassWithAbstractDefinitions
	Set tParametersToBeInitialized = "", tParamName = ""
	While 1 {
		Set tParamName = $$$comMemberNext(tClassWithAbstractDefinitions, $$$cCLASSparameter, tParamName)
		Quit:(tParamName = "")
		If $$$IsAbstractParameter(tClassWithAbstractDefinitions, tParamName) {
			Set tParametersToBeInitialized = tParametersToBeInitialized_","_tParamName
		}
	}
	Set tParametersToBeInitializedList = $ListFromString(tParametersToBeInitialized)
	// Loop through abstract parameters, throwing an error if not initialized
	Set tPtr = 0
	While $ListNext(tParametersToBeInitializedList, tPtr, tParamName) {
		Continue:(tParamName = "")
		If $$$GetParameterValue(tBaseClass.Name, tParamName) = "" {
			Set tStatus = $$$ERROR($$$GeneralError, "Value must be provided for parameter "_tParamName)
			Quit
		}
	}
	Quit tStatus
]]></Implementation>
</Method>
</Class>


<Class name="%ZHSLIB.Component.Build">
<Description>
Contains internal API methods for the building of all HealthShare products.</Description>
<Abstract>1</Abstract>
<Hidden>1</Hidden>
<Super>%ZHSLIB.Component.Utils</Super>
<TimeChanged>67214,49066.6146675</TimeChanged>
<TimeCreated>67214,49066.6146675</TimeCreated>

<Method name="RunProd">
<Description><![CDATA[
Run a production build that can be kitted. <br />
@API.Method <br />
@Modifier	Availability	InterSystems <br />
@Argument	pRootDirectory			Root directory of component to be built (path to module.xml file of the component). <br />
@Argument	pComponentMapLowerCase	Space-separated list of component names to their Perforce depot paths. <br />
@Argument	pDatabase				The component database being built (e.g. HSLIB, VIEWERLIB etc.). <br />
@Argument	pRepositoryPaths		Comma-separated list of paths for which to create Perforce based repositories. <br />
@Argument	pFileSpec				Changelist to use when syncing repository files. <br />
@Argument	pLabel					Perforce label to apply to repository files that were used during the build. <br />
@Argument	pShelves				Space-separated list of shelved changelists to unshelve before building repositories. <br />
@Argument	pBuildNumber			Optionally provide build number which will be populated in global. <br />]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pRootDirectory:%String,pComponentMapLowerCase:%String,pDatabase:%String,pRepositoryPaths:%String,pFileSpec:%String,pLabel:%String,pShelves:%String,pBuildNumber:%String=""</FormalSpec>
<Implementation><![CDATA[
	Set sc = $$$OK
	Try {
		// Write out method arguments
		$$$WriteBoldNewLine("Method arguments:")
		Write !, "pRootDirectory: "_pRootDirectory
		Write !, "pComponentMapLowerCase: "_pComponentMapLowerCase
		Write !, "pDatabase: "_pDatabase
		Write !, "pRepositoryPaths: "_pRepositoryPaths
		Write !, "pFileSpec: "_pFileSpec
		Write !, "pLabel: "_pLabel
		Write !, "pShelves: "_pShelves
		Write !, "pBuildNumber: "_pBuildNumber
		Write !
		
		// Do pre-build steps such as start logging, disable I/O redirection etc.
		Do ..PreBuildSteps(0)
		
		Set repoList = $ListFromString(pRepositoryPaths, ",")
		Set shelvesList = $ListFromString(pShelves, " ")
		
		Do ..CreateDefaultDatabaseGlobals()
		
		// Needed so that the build number exists in the IRIS.DAT that is kitted. Only needed for HSLIB
		// This needs to take place before loading Run() since the buildNumber is required for the Angular Artifact Processor
		If (pBuildNumber '= "") && ($ZConvert(pDatabase, "U") = "HSLIB") {
			Do ##class(%ZHSLIB.HealthShareMgr).PopulateBuildNumberInGlobal(pBuildNumber)
		}
				
		// Set Perforce client (configured in RelEng build process)
		// This is a hack - the P4CONFIG environment variable isn't respected for some reason.
		// It would be good to figure out why, but in the meanwhile, this works.
		Set sc = ##class(%Studio.SourceControl.ISC).RunCmd("type p4config.txt", .typeOutput)
		$$$ThrowOnError(sc)
		If '$Data(typeOutput(1), p4config) {
			$$$ThrowStatus($$$ERROR($$$GeneralError, "No Perforce workspace setting found p4config.txt"))
		}
		Set workspace = $Piece(p4config, "=", 2)
		Do ##class(%Studio.SourceControl.ISC).SetCredentials("build", , workspace)

		// Configure repositories
		$$$WriteBoldNewLine("Creating AppModule repositories")
		
		#dim commandArray As %Library.DynamicArray = []
		#dim modifiersJson As %Library.DynamicObject
		Set index = 0
		Set ptr = 0
		While $ListNext(repoList, ptr, appModule) {
			Set modifiersJson = {
				"name": ("Repository"_$Increment(index)),
				"perforce": "",
				"path": (appModule)
			}
			If (pFileSpec '= "") {
				Do modifiersJson.%Set("spec", "@"_pFileSpec)
			}
			If ($ListLength(shelvesList) > 0) {
				Do modifiersJson.%Set("shelves", $ListToString(shelvesList, ","))
			}
			// Add to array
			Do commandArray.%Push({
				"command": "repo",
				"modifiers": (modifiersJson)	
			})
		}
		Write !, "Constructed following JSON commands to run:", !
		Set formatter = ##class(%JSON.Formatter).%New()
		Set sc = formatter.Format(commandArray)
		$$$ThrowOnError(sc)
		Write !
		
		// Actually create the repos
		Do ..RunCommandsFromDynamicArray(commandArray,1)
		
		// Increase storage and lock threshold before loading all modules when in non-dev mode
		Set $ZStorage = (2 * $ZStorage)
		Do $System.SQL.SetLockThreshold(10000)
		
		// Install modules
		Do ..Run(pRootDirectory, 0, 1, 1)
		
		
		// Stash the current build info so that ConfigureAsBuilt can use it
		Do ..StoreBuildConfigInfoInGlobals(pDatabase, pRootDirectory, pComponentMapLowerCase, repoList)
		
		// Apply label on repo paths
		If (pLabel '= "") {
			Write !, "Setting label for repository paths:", !
			Do ..SetLabelForRepositories(pLabel, repoList)
		}
		
		// Delete all repositories when production build
		Set command = "repo -delete-all"
		$$$PackageManagerCommand(command,1)
		
		// Needed by RelEng
		Do ##class(%ZHSLIB.Component).BuildUpdateINI()
		// So it doesn't get exported
		Kill ^ZEN.IncludeDir
		// Compact and shrink the database
		Do ..CompactAndShrinkDatabase($ZConvert(pDatabase, "L"))
	} Catch ex {
		Set sc = ex.AsStatus()
		$$$WriteBoldNewLine("Build aborted due to the following error:")
		Write !, $System.Status.GetErrorText(sc)
	}
	Do ..PostBuildSteps(0, sc)
]]></Implementation>
</Method>

<Method name="RunDev">
<Description><![CDATA[
Run a developer build. <br />
@API.Method <br />
@Modifier	Availability	InterSystems <br />
@Argument	pVerbose		Whether verbose output should be provided during the build. <br />
@Argument	pSync			Whether to sync file-system based repositories and this module's contents before running build. <br />
@Argument	pSkipZHSLIB		Whether to skip re-installing ZHSLIB. <br />
@Argument	pVersion 		Version of the base module to be installed. If not specified, default to be the latest available version. <br />
@Argument	pInstallIPM		Whether to install IPM modules (IPM, ISC.IRIS.IPMPerforce,ISC.IRIS.IPMStudioUI) together with RunDev. Specify this to 1 if want to do development on %IPM.* files. <br />]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pVerbose:%Boolean=0,pSync:%Boolean=0,pSkipZHSLIB:%Boolean=0,pVersion:%String="",pInstallIPM:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	Set sc = $$$OK
	Try {
		// Do pre-build steps such as start logging, disable I/O redirection etc.
		New %SourceControl
		Do ..PreBuildSteps(1)
		
		// Ensure module exists in configured repositories
		Set moduleName = $Get($$$BuildConfigBaseModule)
		If (moduleName = "") {
			$$$ThrowStatus($$$ERROR($$$GeneralError,"No base module found to uninstall. Run one of the Configure* methods."))
		}
		#dim moduleReference As %IPM.Storage.QualifiedModuleInfo
		Set moduleReference = ..FindModuleInRepositories(moduleName, pVersion, .found)
		If 'found {
			Set errorMessage = "Environment is configured to use base module "_$$$QUOTE(moduleName)_" of version "_pVersion_" but it was not found in any repositories."_
				"Run one of the Configure* functions to configure repositories."
			$$$ThrowStatus($$$ERROR($$$GeneralError,errorMessage))
		}
		
		// Get root directory for module
		#dim repoManager As %IPM.Repo.Manager
		Set repoManager = ##class(%IPM.Repo.Manager).%Get(.sc)
		$$$ThrowOnError(sc)
		#dim packageService As %IPM.Repo.IPackageService
		Set packageService = repoManager.CheckServiceCache(moduleReference.ServerName, .isAvailable)
		If '$Get(isAvailable,0) {
			$$$ThrowStatus($$$ERROR($$$GeneralError,"Repository "_moduleReference.ServerName_" is unavailable"))
		}
		Set rootDirectory = packageService.GetModuleDirectory(moduleReference)
			
		If pSync {
			// Sync now because this could result in files needing resolve in local workspace
			Set sc = ##class(%IPM.Extension.SourceControl.Perforce.Main).SyncFilesystemRepositories(pVerbose)
			$$$ThrowOnError(sc)
			Set sc = ##class(%Studio.SourceControl.ISC).P4Cmd("sync "_rootDirectory_"...#head")
			If $$$ISERR(sc) && ($System.Status.GetErrorText(sc) '[ "file(s) up-to-date") {
				// Not fatal so do not throw error
				Write !, "WARNING: Following error occurred while syncing base module's files: "_$System.Status.GetErrorText(sc)
				Set sc = $$$OK
			}
		}
		If '##class(%IPM.Extension.SourceControl.Perforce.Main).Disconnected() {
			// Check for files pending resolve in local workspace
			#dim list As %IPM.Extension.SourceControl.Perforce.FileList
			Set sc = ##class(%IPM.Extension.SourceControl.Perforce.Main).ListFilesPendingResolve(.list)
			$$$ThrowOnError(sc)
			If 'list.IsEmpty() {
				Write $Char(7)
				$$$WriteBoldNewLine("WARNING: File(s) pending resolve in Perforce workspace.")
				Write !
				Write $Char(9), list.ToString($$$NL_$Char(9))
				Write !,"This is likely to lead to build errors. Consider resolving these files before continuing."
				Set continue = 1
				Set response = ##class(%Library.Prompt).GetYesNo("Continue with build?", .continue, , $$$TrapCtrlCMask+$$$EnableQuitCharMask)
				If (response '= $$$SuccessResponse) || 'continue {
					$$$WriteBoldNewLine("build aborted.")
					Return
				}
			}
		}
		
		// Re-install IPM modules in current namespace
		If pInstallIPM {
			Do ..ConfigureIPMRepo()
			Set IPMModules = $ListBuild("ZPM", "ISC.IRIS.IPMStudioUI", "ISC.IRIS.IPMPerforce")
			Set ptr = 0
			Set index = 0
			While $ListNext(IPMModules, ptr, IPMModuleName) {
				Set command = "install -dev "_IPMModuleName_" "_$Case(pVerbose, 1: " -v", : "")
				$$$PackageManagerCommand(command,pVerbose)
			}
		}
		
		// Install ZHSLIB in current namespace
		If 'pSkipZHSLIB {
			// Default is to install latest in dev mode
			Set versionToInstall = "-latest"
			// Whether to use built version
			Set builtVersion = $Get($$$BuildConfigZHSLIBVersion)
			If (builtVersion '= "") {
				Set versionToInstall = builtVersion _ " " _ versionToInstall
			}
			Set command = "install -dev ZHSLIB "_versionToInstall_$Case(pVerbose, 1: " -v", : "")
			$$$PackageManagerCommand(command,pVerbose)
		}

		// Recreate source control class, in case its compiled behavior or that of referenced classes changed.
		Set sc = ##class(%Studio.SourceControl.Interface).SourceControlCreate()
		$$$ThrowOnError(sc)
		
		// Clear slate for conflict detection.
		Set sc = ##class(%IPM.Storage.LoadedResource).Clear()
		$$$ThrowOnError(sc)
		
		// Install modules with IsDev and ignore installed modules
		Do ..Run(rootDirectory, 1, pVerbose,, 1)
	} Catch ex {
		Set sc = ex.AsStatus()
		$$$WriteBoldNewLine("Build aborted due to the following error:")
		Write !, $System.Status.GetErrorText(sc)
	}
	Do ..PostBuildSteps(1, sc)
]]></Implementation>
</Method>

<Method name="ConfigureDev">
<Description><![CDATA[
Configure a dev environment. All arguments are optional. If not provided, you
will be prompted i.e. the method will be run in interactive mode.<br />
@API.Method <br />
@Modifier	Availability	InterSystems <br />
@Argument	pBaseModuleName		Name of base module to install. <br />
@Argument	pRepositoryArray	JSON array of zpm repo commands to run. Run the following:
<code>Do ##class(%IPM.Main).Shell("help run")</code> in terminal to view the
expected JSON format of the commands. <br />
@Argument	pWorkspace			Perforce workspace to connect to this namespace. <br />]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pBaseModuleName:%String="",pRepositoryArray:%Library.DynamicArray="",pWorkspace:%String=""</FormalSpec>
<Implementation><![CDATA[
	Try {
		Do ..PreConfigureSteps()

		/* Optional override of workspace */
		
		If (pWorkspace '= "") {
			Do ##class(%Studio.SourceControl.ISC).SetCredentials(,,pWorkspace)
			Write !, "Perforce workspace to use for namespace "_$$$QUOTE($Namespace)_" set to be "_pWorkspace
		}
		
		/* Do initialization + configuration */
		
		// Initialize package manager
		$$$WriteBoldNewLine("Initializing package manager...")
		Set sc = ##class(%IPM.Main).Shell("init -quiet -extension %IPM.Extension.SourceControl.Perforce.Main -menuextension %IPM.Extension.ServerMenu.MenuItems")
		$$$ThrowOnError(sc)
		Set sc = ##class(%IPM.Main).UpdateLanguageExtensions()
		$$$ThrowOnError(sc)

		// Recreate source control class, in case it changed.
		New %SourceControl
		Set sc = ##class(%Studio.SourceControl.Interface).SourceControlCreate()
		$$$ThrowOnError(sc)
		
		// Update default database to be writeable
		Do ..UpdateDefaultDatabaseReadOnly(0)
		
		/* Configure repositories */

		// Check for repositories. Prompt user to create dev environment accordingly.
		Write !
		$$$WriteBoldNewLine("Found the following repositories:")
		Set sc = ##class(%IPM.Main).Shell("repo -list")
		$$$ThrowOnError(sc)
		
		If $IsObject(pRepositoryArray) {
			If 'pRepositoryArray.%IsA("%Library.DynamicArray") {
				$$$ThrowStatus($$$ERROR($$$GeneralError,"pRepositoryArray expected to be JSON array but is not"))
			}
			$$$WriteBoldNewLine("Deleting all existing repositories...")
			$$$PackageManagerCommand("repo -delete-all",1)
			$$$WriteBoldNewLine("Creating repositories from provided JSON array...")
			Do ..RunCommandsFromDynamicArray(pRepositoryArray, 1)
		} Else {
			// Default is to use existing
			Set repoManageResponse = 1
			Kill menuArray
			Set menuArray($Increment(menuArray)) = "Use existing repositories"
			Set menuArray($Increment(menuArray)) = "Create more repositories (will leave the existing ones untouched)"
			Set menuArray($Increment(menuArray)) = "Delete and recreate repositories"
			Set repoManageMessage = "How would you like to manage your repositories?"
			While 1 {
				Set response = ##class(%Library.Prompt).GetMenu(repoManageMessage, .repoManageResponse, .menuArray, , $$$InitialDisplayMask+$$$TrapCtrlCMask+$$$EnableQuitCharMask)
				If (response = $$$ErrorResponse) {
					Write !, $$$FormattedLine($$$Red,"Invalid option. Try again"), !
					Continue
				}
				If (response = $$$CtrlCResponse) || (response = $$$QuitResponse) {
					Return
				}
				Quit
			}
			
			If (repoManageResponse = 3) {
				$$$WriteBoldNewLine("Deleting all existing repositories...")
				$$$PackageManagerCommand("repo -delete-all",1)
			}
			
			If ((repoManageResponse = 2) || (repoManageResponse = 3)) {
				// Prompt for more repo creation
				While 1 {
					Write !
					Set wantToCreate = 1
					Set response = ##class(%Library.Prompt).GetYesNo("Would you like to create a repository?", .wantToCreate, , $$$TrapCtrlCMask+$$$EnableQuitCharMask)
					If (response '= $$$SuccessResponse) {
						Write !
						$$$WriteBoldNewLine("Configuration aborted due to invalid response")
						Write !
						Return
					}
					If 'wantToCreate {
						Quit
					}
					$$$PackageManagerCommand("repo",0)
				}
			}
		}
		
		/* Get base module name and verify it exists */		
		
		If (pBaseModuleName '= "") {
			// Verify module exists in configured repos
			Do ..FindModuleInRepositories(pBaseModuleName,, .found)
			If 'found {
				$$$ThrowStatus($$$ERROR($$$GeneralError,"Module "_$$$QUOTE(pBaseModuleName)_" not found in any repository in this namespace"))
			}
			// Stuff base module name in config global to be used by RunDev
			Set $$$BuildConfigBaseModule = pBaseModuleName
		} Else {
			// Prompt for base module name
			While 1 {
				Set helpText = "The name can be found by looking at the <Name> element of the module.xml file."
				Set moduleName = $Get($$$BuildConfigBaseModule)
				Set response = ##class(%Library.Prompt).GetString("Enter the name of the base component/module to install (e.g. HSBASE): ", .moduleName, 1, , , $$$TrapCtrlCMask+$$$EnableQuitCharMask)
				If (response '= $$$SuccessResponse) {
					Write !
					$$$WriteBoldNewLine("Configuration aborted due to invalid response")
					Write !
					Return
				}
				Do ..FindModuleInRepositories(moduleName,, .found)
				If found {
					Set $$$BuildConfigBaseModule = moduleName
					Quit
				}
				Write !!, $$$FormattedLine($$$Red,"The module was not found in configured repositories. Try again"), !
			}
		}
		Write !, "Base module to be used in this namespace is set to be: "_$$$BuildConfigBaseModule
		Write !
	} Catch ex {
		#dim ex As %Exception.AbstractException
		Set sc = ex.AsStatus()
		Set errorText = $Piece($System.Status.GetErrorText(sc), ": ", 2, *)
		Write !, $$$FormattedLine($$$Red,"The following error occurred: "_errorText), !
	}
]]></Implementation>
</Method>

<Method name="ConfigureAsBuilt">
<Description><![CDATA[
Configure a dev environment for the provided library database, using the same branches of
code that were used to build this kit. <br />
When running <method>RunDev</method> after calling this, code is loaded in developer mode
which means source control hooks are configured, code is not deployed etc. <br />
@API.Method <br />
@Modifier	Availability	InterSystems <br />
@Argument	pDatabase		The database build to replicate (e.g. HSLIB, VIEWERLIB etc.). <br />]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDatabase:%String</FormalSpec>
<Implementation><![CDATA[
	If ($Get(pDatabase) = "") {
		$$$ThrowStatus($$$ERROR($$$GeneralError,"Database argument must be provided"))
	}
	Do ..PreConfigureSteps()

	// Set ZHSLIB version to be used in RunDev(). This is how to obtain the version in the kit.
	Set $$$BuildConfigZHSLIBVersion = ..Version("ZHSLIB")
	
	// Obtain module name
	Set moduleName = $Get($$$BuildConfigBuiltBaseModuleName(pDatabase))
	If (moduleName = "") {
		Set errorMessage = "This kit does not contain necessary info to build the environment from scratch. Use ConfigureDev() instead."
		$$$ThrowStatus($$$ERROR($$$GeneralError,errorMessage))
	}
	
	// Construct repo array
	#dim commandArray As %Library.DynamicArray = []
	Set repoList = $Get($$$BuildConfigBuiltRepoPaths(pDatabase))
	Set ptr = 0
	Set index = 0
	While $ListNext(repoList, ptr, repoPath) {
		Set modifiersJson = {
			"name": ("Repository"_$Increment(index)),
			"p4": "",
			"path": (repoPath)
		}
		Do commandArray.%Push({
			"command": "repo",
			"modifiers": (modifiersJson)	
		})
	}
	
	Do ..ConfigureDev(moduleName, commandArray)
]]></Implementation>
</Method>

<Method name="ConfigureIPMRepo">
<Description>
Create IPM repositories</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	Set repoPath = "//projects/ipm-modules/sysmodules/"
	If ##class(%IPM.Repo.Extension.Perforce.Definition).RootIndexExists(repoPath) {
		Return
	}
	#dim commandArray As %Library.DynamicArray = []
	Set modifiersJson = {
		"name": ("IPM-P4-Repo"),
		"p4": "",
		"path": (repoPath)
	}
	Do commandArray.%Push({
		"command": "repo",
		"modifiers": (modifiersJson)	
	})
	Do ..RunCommandsFromDynamicArray(commandArray, 1)
]]></Implementation>
</Method>

<Method name="Clean">
<Description><![CDATA[
Uninstall the root module and its dependencies. <br />
@API.Method <br />
@Modifier	Availability	InterSystems <br />]]></Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	// Get base module name from global
	Set moduleName = $Get($$$BuildConfigBaseModule)
	If (moduleName = "") {
		$$$ThrowStatus($$$ERROR($$$GeneralError,"No base module found to uninstall. Run one of the Configure* methods."))
	}

	// Uninstall module and its dependencies
	$$$WriteBoldNewLine("Uninstalling module "_$$$QUOTE(moduleName)_" and its dependencies...")
	$$$PackageManagerCommand("uninstall -r -f "_moduleName,1)
	$$$WriteBoldNewLine("Successfully uninstalled the module and its dependencies.")
]]></Implementation>
</Method>

<Method name="UnconfigureDev">
<Description><![CDATA[
Delete configuration of base module and repositories. <br />
@API.Method <br />
@Modifier	Availability	InterSystems <br />]]></Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	Set baseModule = $Get($$$BuildConfigBaseModule)
	If (baseModule = "") {
		Write !, "No base module configured for this namespace so nothing to delete."
	} Else {
		Kill $$$BuildConfigBaseModule
		Write !, "De-registered the following as the base module for this namespace: "_baseModule
	}
	Write !
	$$$PackageManagerCommand("repo -delete-all",1)
	Write !, "Deleted all existing repositories"
	Write !
]]></Implementation>
</Method>

<Method name="Run">
<Description><![CDATA[
Runs a build. Internal method ONLY. All attempts at running builds are funnelled through this method. <br />
This method intentionally has NO DEFAULTS to force the developer to think about EXACTLY what parameters
should be used for any API methods that call this method. <br />
@Argument	pRootDirectory		Root directory of component to be built (path to module.xml file of the component). <br />
@Argument	pIsDev				Whether the build is running in developer mode. <br />
@Argument	pVerbose			Whether verbose output should be provided during the build. <br />
@Argument	pIsKitBuild			Whether the current call is during an actual kit build. <br />
@Argument	pIgnoreInstalled 	Whether to ignore installed modules during dependency graph building. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pRootDirectory:%String,pIsDev:%Boolean,pVerbose:%Boolean,pIsKitBuild:%Boolean=0,pIgnoreInstalled:%Boolean=0</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	Set productionsWereRunning = 0
	
	#dim namespaceConfig As %IPM.Storage.ModuleSetting.NamespaceConfig
	Set namespaceConfig = ..GetNamespaceConfig(pRootDirectory)
	
	// Configure mappings and stop productions if present
	Do ..ConfigureMappings(namespaceConfig, pVerbose, .productionsWereRunning)
			
	If pIsDev {
		Kill ^ZEN.IncludeDir
	} Else {
		// During the production build, we need to add the following, to make sure ZEN
		// compiles .js and .css files into the correct directory
		Set zendir = "kit/common/release/csp/broker"
		Set ^ZEN.IncludeDir = pRootDirectory_"../../"_zendir
		Set ^%ISC.ZENBackgroundGenerate = 0
	}
	
	// Need to set up mappings only if EnableHealthShare set to 1.
	// This is because if core HS packages are being mapped from HSLIB, any packages installed as
	// part of this component need to forcibly be mapped from this component's default database
	// to prevent them from being loaded into HSLIB.
	Set noMapping = 'namespaceConfig.EnableHealthShare
	Do ..LoadBaseModuleAndDependencies(
		pRootDirectory,
		pIsDev,
		pVerbose,
		noMapping,
		pIsKitBuild,
		pIgnoreInstalled
	)
	
	// Clean this up - it's huge and serves no purpose
	Kill ^rINDEXSQL("sqlidx")
	
	If productionsWereRunning {
		$$$WriteBoldNewLine("Starting productions:")
		Set sc = ##class(HS.Director).StartAll()
		If $$$ISERR(sc) {
			// Failure to start productions should not be fatal. Just give a warning.
			Write !, "WARNING: Failed to start productions due to the following error:"
			Write !, $System.Status.GetErrorText(sc)
		}
		Write !
	}
]]></Implementation>
</Method>

<Method name="ConfigureCINamespace">
<Description><![CDATA[
Configure a new namespace for CI purpose, with the namespace name. <br />
@API.Method <br />
@Modifier	Availability	InterSystems <br />
@Argument	pName			Unique name of the new namespace. <br />]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pName:%String</FormalSpec>
<Implementation><![CDATA[
	Set NSConfig = ##class(%IPM.Storage.ModuleSetting.NamespaceConfig).%New()
	Set NSConfig.EnableEnsemble = 1

	// Creating brand new database with the same name as the new namespace.
	// If such database already exists, error out
	Set tSC = ##class(%IPM.Utils.Build).CreateDatabase(pName)
	$$$ThrowOnError(tSC)
	// Using the same database for Code and Data db of the namespace
	// If such namespace aleady exists, error out
	Set tSC = ##class(%IPM.Utils.Build).CreateNamespace(pName, pName, pName, 1, NSConfig)
	$$$ThrowOnError(tSC)
]]></Implementation>
</Method>

<Method name="Version">
<Description>
@API.Method</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pModuleName:%String,pNamespace:%String=$Namespace</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	$$$AddAllRoleTemporary
	New $Namespace
	Set $Namespace = pNamespace
	If ##class(%IPM.Storage.Module).NameExists(pModuleName, .id) {
		Return ##class(%IPM.Storage.Module).VersionStringGetStored(id)
	}
	Return ""
]]></Implementation>
</Method>
</Class>


<Routine name="%ZHSLIB.Component.Build" type="INC" timestamp="67214,49066.359524"><![CDATA[
#include %occInclude
#include %syPrompt
#include %ZHSLIB.Formatting
#include %ZHSLIB

/// Initialise total time variable for the build
#define InitTotalTime Set %bigtime = $ZHorolog
/// Generic macro to calculate elapsed time since value stored in a given variable, write prefix text before the elapsed time
#define TimeElapsedSinceVariable(%var,%text) If $Data(%var) { Set %var = ($ZHorolog - %var) Write %text_$Case((%var > 60), 1: (%var\60)_" minutes ", : "")_(%var#60)_" seconds" }
/// Time elapsed since initialization of bigtime variable
#define ElapsedTotalTime $$$TimeElapsedSinceVariable(%bigtime,$$$NL_$$$NL_"COMPLETE!"_$$$NL_"Overall Elapsed Time: ")
/// Write bold line to terminal
#define WriteBoldLine(%line) Write $$$FormattedLine($$$Bold, %line)
/// Write bold line to terminal, on a new line
#define WriteBoldNewLine(%line) Write ! $$$WriteBoldLine(%line)
/// Process private global for build errors. This is populated in I/O redirection of ^%buildutil.
#define BuildErrorsPPG ^||%BUILDERRORS
/// Run a command in the Package Manager Shell
#define PackageManagerCommand(%command, %verbose) If (%verbose) { Write !, "zpm> "_%command } Set sc = ##class(%IPM.Main).Shell(%command) $$$ThrowOnError(sc)

/// Config global to store build environment info
#define BuildConfigGbl ^HS.Component.BuildConfig
/// Config global to store build environment info of kit that is built
#define BuildConfigBuiltGbl(%db,%sub) ^|("^^"_$$$HSLibraryDatabaseDirectory(%db))|HS.Component.BuildConfigBuilt(%sub)
/// Config global to store base module name for developer builds
#define BuildConfigBaseModule $$$BuildConfigGbl("BaseModule")
/// Config global to store ZHSLIB version for developer builds
#define BuildConfigZHSLIBVersion $$$BuildConfigGbl("ZHSLIBVersion")
/// Config global to store built base module name
#define BuildConfigBuiltBaseModuleName(%db) $$$BuildConfigBuiltGbl(%db,"BuiltBaseModuleName")
/// Config global to store repository paths used in built kit as a $ListBuild list
#define BuildConfigBuiltRepoPaths(%db) $$$BuildConfigBuiltGbl(%db,"BuiltRepoPaths")
]]></Routine>


<Class name="%ZHSLIB.Component">
<IncludeCode>%ZHSLIB</IncludeCode>
<Super>%RegisteredObject,%XML.Adaptor</Super>
<TimeChanged>67214,49066.4320173</TimeChanged>
<TimeCreated>67214,49066.4320173</TimeCreated>

<Property name="Name">
<Type>%String</Type>
</Property>

<Property name="Version">
<Type>%String</Type>
</Property>

<Property name="Prerequisites">
<Type>Component</Type>
<Collection>list</Collection>
</Property>

<Property name="Compatibility">
<Description>
Minimum version for other components when installing this component
ie HSAA version 5 minimum version for this version of HSLIB</Description>
<Type>Component</Type>
<Collection>list</Collection>
</Property>

<Property name="List">
<Description>
List is used to keep track of a list of components</Description>
<Type>Component</Type>
<Collection>list</Collection>
</Property>

<Method name="UpdateComponentINI">
<ClassMethod>1</ClassMethod>
<FormalSpec>pComponent:Component,pFile="Components.ini",pDirectory=$System.Util.ManagerDirectory()_"utils/",pFromBuild=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	try {
		#dim tList as List of Component
		Set tSC = ##class(%File).CreateDirectoryChain(pDirectory) Quit:$$$ISERR(tSC)
		Set tSC = ..LoadComponentINI(.tList,pFile,pDirectory)
		Quit:$$$ISERR(tSC)
		Set tFound=0
		For tIdx = 1:1:tList.Count() {
			If $zcvt(tList.GetAt(tIdx).Name,"U")=$zcvt(pComponent.Name,"U") Do tList.RemoveAt(tIdx),tList.InsertAt(pComponent,tIdx) Set tFound=1 Quit
		}
		If 'tFound do tList.Insert(pComponent)
		Set pDirectory=##class(%File).NormalizeDirectory(pDirectory)
		Set tFileObject=##class(%File).%New(pDirectory_pFile)
		Do tFileObject.Open("NWS")
		For tIdx = 1:1:tList.Count() {
			#dim tItem as Component
			Set tItem=tList.GetAt(tIdx)
			// Check if item exists on this kit (may not after an upgrade)
			Set databaseDirectory = $$$HSLibraryDatabaseDirectory(tItem.Name)
			If '##class(%Library.File).DirectoryExists(databaseDirectory) {
				Continue
			}
			Do tFileObject.WriteLine("["_$zcvt(tItem.Name,"U")_"]")
			Do:pFromBuild tFileObject.WriteLine("CompiledOnVersion="_$system.Version.GetMajor()_"."_$system.Version.GetMinor()_"."_$S($system.Version.GetPoint()="":"0",1:$system.Version.GetPoint()))
			Do ##class(%ZHSLIB.HealthShareMgr).ComponentVersion(tItem.Name,.tVersion)
			Do tFileObject.WriteLine("Version="_tVersion)
			For tIdxC=1:1:tItem.Compatibility.Count() {
				Set tCompatibilityItem = tItem.Compatibility.GetAt(tIdxC)
				Do tFileObject.WriteLine("Compatibility_"_$zcvt(tCompatibilityItem.Name,"U")_"="_tCompatibilityItem.Version)
			}
			For tIdxC=1:1:tItem.Prerequisites.Count() {
				Set tPrerequisiteItem = tItem.Prerequisites.GetAt(tIdxC)
				Do tFileObject.WriteLine("Prerequisites_"_$zcvt(tPrerequisiteItem.Name,"U")_"="_tPrerequisiteItem.Version)
			}
		}		
	} Catch ex {
		Set tSC=ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="LoadComponentINI">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pList,pFile="Components.ini",pDirectory=$zu(12)_"utils/"]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	try {
		Set tThis=..%New()
		Set pList=tThis.List,tComponent=""
		Set pDirectory=##class(%File).NormalizeDirectory(pDirectory)
		Set tFileObject=##class(%File).%New(pDirectory_pFile)
		If tFileObject.Size=0 Quit
		Do tFileObject.Open("R")
		For  {
			Quit:tFileObject.AtEnd
			Set tLine=tFileObject.ReadLine()
			If $E(tLine)="[" {
				Set tComponent=##class(Component).%New()
				Set tComponent.Name=$E(tLine,2,*-1)
				Do pList.Insert(tComponent)
				continue
			} 
			If '$IsObject(tComponent) Continue
			Set tItem=$zstrip($zcvt($p(tLine,"="),"l"),"<>W")
			Set tValue=$p(tLine,"=",2)
			If $L(tItem,"_")>1 {
				Set tItemValue=$p(tItem,"_",2)
				Set tCompatibleComponent=..%New()
				Set tCompatibleComponent.Version=tValue
				Set tCompatibleComponent.Name=$zstrip($p($p(tLine,"_",2),"="),"<>W")
			}
			If tItem="version" {
				Set tComponent.Version=tValue
			} ElseIf $p(tItem,"_")="compatibility" {
				Do tComponent.Compatibility.Insert(tCompatibleComponent)
			} ElseIf $p(tItem,"_")="prerequisites" {
				Do tComponent.Prerequisites.Insert(tCompatibleComponent)
			}
		}
	} Catch ex {
		Set tSC=ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="BuildUpdateINI">
<ClassMethod>1</ClassMethod>
<FormalSpec>pFileName="Component_"_$namespace_".ini"</FormalSpec>
<Implementation><![CDATA[
	try {
		Set tSC = ..GetXDataAsStreamWithSubstitutions("XData://Installer.Install:InstallationInfo",.tStream)
		Quit:$$$ISERR(tSC)
		Set tReader = ##class(%XML.Reader).%New()
		Do tReader.Correlate("Component", "%ZHSLIB.Component")
		Do tReader.OpenStream(tStream)
		If tReader.Next(.tComponent, .tSC) {
			Do ..UpdateComponentINI(tComponent,pFileName,,1)
		}
	} Catch ex {
		Set tSC=ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="InstallUpdateINI">
<Description>
When installing a new component update the Components.ini file in the installation directory</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pFileName="Components.ini",pDirectory=$system.Util.InstallDirectory()</FormalSpec>
<Implementation><![CDATA[
	try {
		Set tSC = ..GetXDataAsStreamWithSubstitutions("XData://Installer.Install:InstallationInfo",.tStream)
		Quit:$$$ISERR(tSC)
		Set tReader = ##class(%XML.Reader).%New()
		Do tReader.Correlate("Component", "%ZHSLIB.Component")
		Do tReader.OpenStream(tStream)
		If tReader.Next(.tComponent, .tSC) {
			Do ..UpdateComponentINI(tComponent,pFileName,pDirectory)	
		}
	} Catch ex {
		Set tSC=ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetXDataAsStreamWithSubstitutions">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pXData,&pStream]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	try {
		If pXData'[":" {
			Set tClassname=$classname()
			Set tNode=pXData
		} Else {
			Set tClassname=$p($p(pXData,"//",2),":")
			Set tNode=$p($p(pXData,"//",2),":",2)
		}

		Set tClass=##class(%Dictionary.ClassDefinition).%OpenId(tClassname,0,.tSC)
		If $$$ISERR(tSC) Quit
		Set tStream=$$$NULLOREF		
		Do {
			Set tIndex = tClass.XDatas.FindObjectId(tClassname_"||"_tNode)
			If tIndex'="" {
				#; Get XDATA as stream
				Set tStream = tClass.XDatas.GetAt(tIndex).Data
				Quit:$IsObject(tStream)
			}
			#; If not found in ClassDefinition, try in CompiledClass		
			Set tClass=##class(%Dictionary.CompiledClass).%OpenId(tClassname,0,.tSC)
			If $$$ISERR(tSC) Quit
	
			Set tIndex = tClass.XDatas.FindObjectId(tClassname_"||"_tNode)
			If tIndex'="" {
				#; Get XDATA as stream
				Set tStream = tClass.XDatas.GetAt(tIndex).Data
				Quit
			}
		} While 0

		If '$IsObject(tStream) Set tSC=$$$ERROR($$$GeneralError,"XData not found") Quit
	
		New %expression,%value
		Set tString=tStream.Read(30000000000)
		For  {
			Set tPos=$f(tString,"{$expression{")
			Quit:'tPos
			Set tPosEnd=$f(tString,"}}",tPos)
			Quit:'tPosEnd
			Set %expression=$e(tString,tPos,tPosEnd-3)
			X "Set %value="_%expression
			Set tString=$e(tString,1,tPos-14)_%value_$e(tString,tPosEnd,*)
		}
		For  {
			Set tPos=$f(tString,"{$method{")
			Quit:'tPos
			Set tPosEnd=$f(tString,"}}",tPos)
			Quit:'tPosEnd
			Set %expression=$e(tString,tPos,tPosEnd-3)
			X "Set %value="_%expression
			Set tString=$e(tString,1,tPos-10)_%value_$e(tString,tPosEnd,*)
		}
		Set pStream=##class(%Stream.GlobalCharacter).%New()
		Do pStream.Write(tString),pStream.Rewind()
	} catch ex {
		Set tSC=ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%ZHSLIB.Component.SourceCode.API">
<Description><![CDATA[
Supports all HS / HC versions including and after HS21.1 and HC21.1
Usage 1: Do ##class(%ZHSLIB.Component.SourceCode.API).LoadSourceCodeForDatabase("<DB you want to load sourcecode for>")
Usage 2: Do ##class(%ZHSLIB.Component.SourceCode.API).LoadAllSourceCode()]]></Description>
<Abstract>1</Abstract>
<Hidden>1</Hidden>
<TimeChanged>67214,49066.6400533</TimeChanged>
<TimeCreated>67214,49066.6400533</TimeCreated>

<Parameter name="CLEANBEFOREBUILD">
<Description>
Determines whether it's a version of HS instance that needs database rebuild to load the sourcecode</Description>
<Expression>'$System.CLS.IsMthd("%IPM.Main", "Shell")</Expression>
</Parameter>

<Method name="LoadSourceCodeForDatabase">
<Description>
Load the source code of a specific lib database
pTargetLIB: name of the LIB database to load source code for. E.g. HSLIB, HSPILIB, etc.
pJSONPayload: Optional input that can be in the following formats. See comments in %ZHSLIB.Component.SourceCode.Utils:SetP4Credentials for the JSON's expected format.
	1) File path string to a JSON file containing P4 Info
	2) %DynamicObject containing P4 Info
	3) JSON string containing P4 Info</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTargetLIB:%String,pJSONPayload:%RawString=""</FormalSpec>
<Implementation><![CDATA[
	// Switch to HSLIB namespace to make sure %IPM classes are available if it's an IPM enabled HS version
	New $Namespace
	Set $Namespace = "HSLIB"
	Do ##class(%ZHSLIB.Component.SourceCode.Utils).SetP4Credentials(pJSONPayload)
	Do ##class(%ZHSLIB.Component.SourceCode.Utils).SetDatabaseRW(pTargetLIB)
	Do ##class(%ZHSLIB.Component.SourceCode.Utils).PrepareP4Extension()
	Do ..LoadSourceCode(pTargetLIB, ..#CLEANBEFOREBUILD)
]]></Implementation>
</Method>

<Method name="LoadAllSourceCode">
<Description>
Load source code for all HealthShare lib-databases that exist on this instance
pJSONPayload: Optional input that can be in the following formats. See comments in %ZHSLIB.Component.SourceCode.Utils:SetP4Credentials for the JSON's expected format.
	1) File path string to a JSON file containing P4 Info
	2) %DynamicObject containing P4 Info
	3) JSON string containing P4 Info</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pJSONPayload:%RawString=""</FormalSpec>
<Implementation><![CDATA[
	// Switch to HSLIB namespace to make sure %IPM classes are available if it's an IPM enabled HS version
	New $Namespace
	Set $Namespace = "HSLIB"
	Do ##class(%ZHSLIB.Component.SourceCode.Utils).SetP4Credentials(pJSONPayload)
	Set dbList = ##class(%ZHSLIB.HealthShareMgr).GetDatabasesInKit()
	Set ptr = 0
	While $ListNext(dbList, ptr, targetLIB) {
		Do ##class(%ZHSLIB.Component.SourceCode.Utils).SetDatabaseRW(targetLIB)
	}
	Do ##class(%ZHSLIB.Component.SourceCode.Utils).PrepareP4Extension()
	Set ptr = 0
	While $ListNext(dbList, ptr, targetLIB) {
		Do ..LoadSourceCode(targetLIB, ..#CLEANBEFOREBUILD)
	}
]]></Implementation>
</Method>

<Method name="LoadSourceCode">
<Description>
Actual helper method to:
1. Create default LIB namespace if not yet exists
2. build pm repos based on how the lib database is built in kit
3. load source code for DB by installing component in dev mode
4. disable source control for its namespace</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTargetLIB:%String,pCleanBeforeRebuild:%Boolean</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	Set targetLIB = $ZConvert(pTargetLIB,"U")
	Set dbList = ##class(%ZHSLIB.HealthShareMgr).GetDatabasesInKit()
	If ($ListFind(dbList, targetLIB) = 0) {
		$$$ThrowStatus($$$ERROR($$$GeneralError, targetLIB_" is not a valid LIB database that comes with this kit!"))
	}
	Do ##class(%ZHSLIB.Component.SourceCode.Utils).PrepareLIBNamespace(targetLIB)
	New $Namespace
	Set $Namespace = targetLIB
	Write !, "Switching to target namespace: "_targetLIB
	If pCleanBeforeRebuild {
		Do ##class(%ZHSLIB.Component.SourceCode.Utils).UnInstallAll(targetLIB)
	}
	Do ##class(%ZHSLIB.Component.SourceCode.Utils).SyncModuleManifests(targetLIB)
	Write !, "Loading source code for database "_targetLIB_"..."
	Write !, "This could take around 20 minutes for HSLIB..."
	Do ##class(%ZHSLIB.Component.Build).ConfigureAsBuilt(targetLIB)
	Try {
		// Can skip re-loading ZHSLIB, since the only difference would be the existance of the two %ZHSLIB.Component.SourceCode.* classes
		Do ##class(%ZHSLIB.Component.Build).RunDev(,,1)
	} Catch ex {
		If (ex.Name = "<PARAMETER>") {
			// likely RunDev does not yet support a third parameter in an early version of HS
			Do ##class(%ZHSLIB.Component.Build).RunDev()
		} Else {
			Set sc = ex.AsStatus()
			$$$ThrowStatus(sc)
		}
	}
	// remove source control
	Do ##class(%Studio.SourceControl.Interface).SourceControlClassSet("",targetLIB)
	Kill ^Sources
]]></Implementation>
</Method>
</Class>


<Class name="%ZHSLIB.Component.SourceCode.Utils">
<Abstract>1</Abstract>
<Hidden>1</Hidden>
<IncludeCode>%ZHSLIB,%ZHSLIB.Component.Build</IncludeCode>
<TimeChanged>67214,49066.6471831</TimeChanged>
<TimeCreated>67214,49066.6471831</TimeCreated>

<Method name="PrepareP4Extension">
<Description>
Prepare for loading the source code by setting up necessary p4 extension info</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	// Initialize package manager
	Write !, "Initializing package manager..."
	If '$System.CLS.IsMthd("%IPM.Main", "Shell") {
		$$$ThrowOnError(##class(%ZHSLIB.PackageManager).Shell("init -quiet -extension %ZHSLIB.PackageManager.Developer.Extension.SourceControl.ISC"))
		$$$ThrowOnError(##class(%ZHSLIB.PackageManager).UpdateLanguageExtensions())
	} Else {
		$$$ThrowOnError(##class(%IPM.Main).Shell("init -quiet -extension %IPM.Extension.SourceControl.Perforce.Main -menuextension %IPM.Extension.ServerMenu.MenuItems"))
		$$$ThrowOnError(##class(%IPM.Main).UpdateLanguageExtensions())
	}
	
	// Recreate source control class, in case it changed.
	$$$ThrowOnError(##class(%Studio.SourceControl.Interface).SourceControlCreate())
	
	// Configure p4 user and workspace info
	If '$System.CLS.IsMthd("%IPM.Main", "Shell") {
		Set tPrimaryClass = ##class(%ZHSLIB.PackageManager.Developer.Extension.Composite).GetPrimaryExtensionClass()
	} Else {
		Set tPrimaryClass = ##class(%IPM.ExtensionBase.Composite).GetPrimaryExtensionClass()
	}
	//$$$ThrowOnError($ClassMethod(tPrimaryClass,"Configure"))
]]></Implementation>
</Method>

<Method name="PrepareLIBNamespace">
<Description>
Make sure lib namespace exists and RW before loading source code for it</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTargetLIBNS:%String</FormalSpec>
<Implementation><![CDATA[
	If (##class(%SYS.Namespace).Exists(pTargetLIBNS)) {
		// we only made LIB DB RO after HS 25.0 (the release when we create default NS for LIB DBs), so only need to set LIB DB RO here
		Do ..SetDatabaseRW(pTargetLIBNS)
	} Else {
		Write !, "Creating LIB database's default namespace..."
		// Likely a version before HS 23.1 that the lib-database default namespace does not exist yet
		Do ..CreateLIBNamespace(pTargetLIBNS)
	}
]]></Implementation>
</Method>

<Method name="SetDatabaseRW">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pNS:%String</FormalSpec>
<Implementation><![CDATA[
	If '$System.CLS.IsMthd("%IPM.Main", "Shell") {
		Try {
			Set directory = ##class(%ZHSLIB.PackageManager.Developer.Utils).GetRoutineDatabaseDir(pNS)
		} Catch e {
			Set directory = $$$HSLibraryDatabaseDirectory(pNS)
		}
	} Else {
		Set directory = ##class(%IPM.Utils.Module).GetRoutineDatabaseDir(pNS)
	}
	New $Namespace
	Set $Namespace = "%SYS"
	Set database = ##class(SYS.Database).%OpenId(directory,, .sc)
	$$$ThrowOnError(sc)
	If database.ReadOnly {
		Set database.ReadOnly = 0
		$$$ThrowOnError(database.%Save())
	}
]]></Implementation>
</Method>

<Method name="CreateLIBNamespace">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pNS:%String</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
    New $Namespace
    Set $Namespace = "%SYS"
    // one more check
    If $ClassMethod("Config.Namespaces", "Exists", pNS) {
        Return
    }
    Kill props
    Set props("Globals") = pNS
    Set props("Routines") = pNS
    Set sc = $ClassMethod("Config.Namespaces", "Create", pNS, .props)
]]></Implementation>
</Method>

<Method name="UnInstallAll">
<Description>
Uninstall all existing appmodules before RunDev() as in early versions of ZHSLIB RunDev() would skip installed dependencies even if they are not installed in developermode</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTargetLIB:%String</FormalSpec>
<Implementation><![CDATA[
	Write !
	Write !, "Uninstalling all appmodules in order to load source code freshly..."
	Write !, "This could take several minutes..."
	If '$System.CLS.IsMthd("%IPM.Main", "Shell") {
		$$$ThrowOnError(##class(%ZHSLIB.PackageManager).Shell("uninstall -all"))
	} Else {
		$$$ThrowOnError(##class(%IPM.Main).Shell("uninstall -all"))
	}
]]></Implementation>
</Method>

<Method name="SetP4Credentials">
<Description><![CDATA[
Set P4 crdential
pJSONPayload: Optional input that can be in the following formats:
	1) File path string to a JSON file containing P4 Info
	2) %DynamicObject containing P4 Info
	3) JSON string containing P4 Info
Expected format:
{
    "P4Info": {
        "P4User": "<p4user>",
        "P4Password": "<p4password>",
        "P4Workspace": "<p4workspace>",
        "P4Port": "<p4port>"
    }
}]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pJSONPayload:%RawString</FormalSpec>
<Implementation><![CDATA[
	If $IsObject(pJSONPayload) {
		// an %DynamicObject is passed in; directly use it
		Set JSON = pJSONPayload
	} ElseIf (pJSONPayload '= "") {
		// a string is passed in; check whether it's a file path string or a JSON string
		If ##class(%File).Exists(pJSONPayload) {
			// the string passed in is a file path string so convert it to a stream object
			Set stream = ##class(%Stream.FileCharacter).%New()
			$$$ThrowOnError(stream.LinkToFile(pJSONPayload))
			Set JSON = ##class(%DynamicAbstractObject).%FromJSON(stream)
		} Else {
			// the string passed in is a JSON string
			Set JSON = ##class(%DynamicAbstractObject).%FromJSON(pJSONPayload)
		}
	}
	Set P4Info = JSON.P4Info
	If (P4Info '= "") {
		Do ##class(%Studio.SourceControl.ISC).SetCredentials(P4Info.P4User,P4Info.P4Password,P4Info.P4Workspace, ,P4Info.P4Port)
	}
]]></Implementation>
</Method>

<Method name="SyncModuleManifests">
<Description>
P4 force sync all and only the module.xml files from each repository
To ensure the corresponding appmodule / component module can be identified</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTargetLIB:%String</FormalSpec>
<Implementation><![CDATA[
	Set repoList = $Get($$$BuildConfigBuiltRepoPaths(pTargetLIB))
	If (##class(%Studio.SourceControl.ISC).GetCredentials(,,.workspace) = 0) {
		$$$ThrowStatus($$$ERROR($$$GeneralError,"P4 Credentials not yet set"))
	}
	Set ptr = 0
	Set index = 0
	While $ListNext(repoList, ptr, repoPath) {
		Set path = $Select($Extract(repoPath, *)="/": repoPath, 1:repoPath_"/")
		Set p4Cmd = "-c "_workspace_" sync -f "_path_".../module.xml"
		Write !, "Running p4 command: p4 "_p4Cmd_" ..."
		$$$ThrowOnError(##class(%Studio.SourceControl.ISC).P4Cmd(p4Cmd))
	}
]]></Implementation>
</Method>
</Class>


<Class name="%ZHSLIB.Component.TLSCertificate">
<TimeChanged>67214,49066.6104975</TimeChanged>
<TimeCreated>67214,49066.6104975</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
// Step 1

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// Create a demo certificate authority server to handle certificate signing request

]]></Content>
</UDLText>

<Method name="ConfigureDemoCAServer">
<ClassMethod>1</ClassMethod>
<FormalSpec>pCAServerConfig:%Library.DynamicObject</FormalSpec>
<Implementation><![CDATA[
	zw "Configuring Demo CA server..."
	#dim server as PKI.CAServer
	Set server = ##class(PKI.CAServer).%New()
	Set server.CAFilename = pCAServerConfig.pCAFileName
	Set server.CAPath = $Select(pCAServerConfig.pCAPath="": ##class(%File).NormalizeDirectory(""), 1: pServerConfig.pCAPath)
	//C,ST,L,O,OU,CN
	Set $LIST(attrlist,1) = pCAServerConfig.pCountry
	Set $LIST(attrlist,2) = pCAServerConfig.pStateProvince
	Set $LIST(attrlist,3) = pCAServerConfig.pLocality
	Set $LIST(attrlist,4) = pCAServerConfig.pOrganization
	Set $LIST(attrlist,5) = pCAServerConfig.pOrganizationalUnit
	Set $LIST(attrlist,6) = $Select(pCAServerConfig.pCommonName="": ##class(%SYS.System).GetInstanceName()_" CA", 1: pCAServerConfig.pCommonName)

	Set result = ##class(PKI.CAServer).Configure(server, attrlist, pCAServerConfig.pServerPassword, pCAServerConfig.pValidDays, .tSC)
	zw "Configuring Demo CA server finished: "
    zw result
	$$$ThrowOnError(tSC)
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// Step 2

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// Once demo CA server is configured and openssl.cnf exists, update it to have localhost

]]></Content>
</UDLText>

<Method name="UpdateSSLConfig">
<ClassMethod>1</ClassMethod>
<FormalSpec>pCAPath:%String=""</FormalSpec>
<Implementation><![CDATA[
	zw "Updating SSL config file..."
	// open target file, and create a temp file to store the content
	Set fileName=##class(%File).NormalizeFilename(pCAPath_"openssl.cnf")
	Set file=##class(%File).%New(fileName)
	Set newFile=##class(%File).%New(fileName_"new") // create a temporary new file
    If 'file.IsOpen {
		$$$ThrowOnError(file.Open("RW", 2)) // try open for 2 seconds
		If 'file.IsOpen {
			$$$ThrowOnError($$$ERROR($$$GeneralError, "Cannot open openssl.cnf file"))
		}
	}
	$$$ThrowOnError(newFile.Open("RWN", 2))
	Do file.Rewind()
	// write content to temp file; add the line of localhost in [ TLS_extensions ] section
    while 'file.AtEnd {
        Set line = file.ReadLine(,.tSC)
        $$$ThrowOnError(tSC)
		$$$ThrowOnError(newFile.WriteLine(line))
        If (line["[ TLS_extensions ]") {
			$$$ThrowOnError(newFile.WriteLine("subjectAltName = DNS:localhost"))
		}
    }
	Do file.Close()
	Do newFile.Close()
	// delete old openssl.cnf file; rename temp file to openssl.cnf
	If '##class(%File).Delete(fileName) {
		$$$ThrowOnError($$$ERROR($$$GeneralError, "Cannot update openssl.cnf file"))
	}
	If '##class(%File).Rename(fileName_"new", fileName) {
		$$$ThrowOnError($$$ERROR($$$GeneralError, "Cannot update openssl.cnf file"))
	}
	zw "Updating SSL config file finished."
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// Step 3

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// Configure a local certificate authority client

]]></Content>
</UDLText>

<Method name="ConfigureLocalCAClient">
<ClassMethod>1</ClassMethod>
<FormalSpec>pCAClientConfig:%Library.DynamicObject</FormalSpec>
<Implementation><![CDATA[
	zw "Start Configuring Local CA Client..."
	Set client = ##class(PKI.CAClient).%New()
	Set client.Server = pCAClientConfig.pCAServerHostname
	$$$ThrowOnError(##class(%RoutineMgr).GetWebServerPort(.webPort))
	Set client.Port = $Select(pCAClientConfig.pCAServerPort = "": webPort, 1: pCAClientConfig.pCAServerPort)
	Set client.ContactName = $Select(pCAClientConfig.pContactName = "": $USERNAME, 1: pCAClientConfig.pContactName)
	Set result = ##class(PKI.CAClient).Configure(client, .tSC)
	zw "Configure Local CA Client finished: "
	zw result
	$$$ThrowOnError(tSC)
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// Step 4

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// Submit Certificate Signing Request to Certificate Authority server

]]></Content>
</UDLText>

<Method name="SubmitSigningRequestToCAServer">
<ClassMethod>1</ClassMethod>
<FormalSpec>pCertSignRequestConfig:%Library.DynamicObject</FormalSpec>
<Implementation><![CDATA[
	zw "Submitting signing request to CA server..."
	//C,ST,L,O,OU,CN
	Set $LIST(attrlist,1) = pCertSignRequestConfig.pCountry
	Set $LIST(attrlist,2) = pCertSignRequestConfig.pStateProvince
	Set $LIST(attrlist,3) = pCertSignRequestConfig.pLocality
	Set $LIST(attrlist,4) = pCertSignRequestConfig.pOrganization
	Set $LIST(attrlist,5) = pCertSignRequestConfig.pOrganizationalUnit
	Set $LIST(attrlist,6) = $Select(pCertSignRequestConfig.pCommonName="": ##class(%SYS.System).GetInstanceName()_" Client", 1: pCertSignRequestConfig.pCommonName)
	Set client = ##class(PKI.CAClient).%OpenId("IRIS CA")
	Set result = client.SubmitCSR(pCertSignRequestConfig.pFileNameRoot, attrlist, pCertSignRequestConfig.pPassword, .tSC)
	zw "Submitting signing request to CA server finished: "
	zw result
	$$$ThrowOnError(tSC)
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// Step 5

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// Process pending Certificate Signing Requests

]]></Content>
</UDLText>

<Method name="ProcessCertificateSigningRequest">
<ClassMethod>1</ClassMethod>
<FormalSpec>pCertReqProcessConfig:%Library.DynamicObject</FormalSpec>
<Implementation><![CDATA[
	zw "Processing certificate signing request..."
	Set requestID = ""
	Set query = "Select ID From PKI.CSR"
	Set statement = ##class(%SQL.Statement).%New()
	$$$ThrowOnError(statement.%Prepare(query))
	Set RS = statement.%Execute()
	While RS.%Next(.tSC) {
		$$$ThrowOnError(tSC)
		If RS.ID[pCertReqProcessConfig.pFileNameRoot {
			Set requestID = RS.ID
			Quit
		}
	}
	$$$ThrowOnError(tSC)
	If requestID = "" {
		$$$ThrowOnError($$$ERROR($$$GeneralError, "Cannot find a satisfied pending signing request"))
	}
	Set server = ##class(PKI.CAServer).%OpenId("IRIS CA")
	Set result = server.Sign(requestID, pCertReqProcessConfig.pPassword, pCertReqProcessConfig.pCertificateType, .tSC)
	zw "Processing certificate signing request finished: "
	zw result
	$$$ThrowOnError(tSC)
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// Step 6

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// Get Certificate(s) from Certificate Authority server

]]></Content>
</UDLText>

<Method name="GetCertificateFromCAServer">
<ClassMethod>1</ClassMethod>
<FormalSpec>pFileNameRoot:%String="HSDEMOCAClient"</FormalSpec>
<Implementation><![CDATA[
	zw "Getting Certificate(s) from Certificate Authority server..."
	Set client = ##class(PKI.CAClient).%OpenId("IRIS CA")
	Set RS = client.ListCertificates(,,.tSC)
	$$$ThrowOnError(tSC)
	While RS.Next(.tSC) {
		// each row contains 4 parts: serial number, hostname, instancename, filename
		$$$ThrowOnError(tSC)
		Set certificateFileNameRoot = RS.GetData(4) 
		If certificateFileNameRoot = pFileNameRoot {
			Set result = client.GetCertificate(RS.GetData(1), .tSC)
			zw "Getting Certificate(s) from Certificate Authority server finished: "
			zw result
			$$$ThrowOnError(tSC)
			Return
		}
	}
	$$$ThrowOnError(tSC)
	$$$ThrowOnError($$$ERROR($$$GeneralError, "Cannot find a satisfied certificate."))
]]></Implementation>
</Method>

<Method name="CreateDemoTLSCertificates">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New $namespace
	Set $namespace="%SYS"
	Set pCAServerConfig = {"pCAFileName": "HSDEMOCA", "pCAPath": "", "pServerPassword": "mypassword", "pCountry": "US", "pStateProvince": "MA", "pLocality": "Cambridge", "pOrganization": "InterSystems", "pOrganizationalUnit": "HealthShare", "pCommonName": "", "pValidDays": 364}
	Set pCAClientConfig = {"pCAServerHostname": "localhost", "pCAServerPort": "", "pContactName": ""}
	Set pCertSignRequestConfig = {"pFileNameRoot": "HSDEMOCAClient", "pCountry": "US", "pStateProvince": "MA", "pLocality": "Cambridge", "pOrganization": "InterSystems", "pOrganizationalUnit": "HealthShare", "pCommonName": "", "pPassword": ""}
	Set pCertReqProcessConfig = {"pFileNameRoot": "HSDEMOCAClient", "pPassword": "mypassword", "pCertificateType": 1}
	Do ..ConfigureDemoCAServer(pCAServerConfig)
	Do ..UpdateSSLConfig()
	Do ..ConfigureLocalCAClient(pCAClientConfig)
	Do ..SubmitSigningRequestToCAServer(pCertSignRequestConfig)
	Do ..ProcessCertificateSigningRequest(pCertReqProcessConfig)
	Do ..GetCertificateFromCAServer()
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%ZHSLIB.Component.Utils">
<Description>
Utility methods for HS component builds.</Description>
<Abstract>1</Abstract>
<Hidden>1</Hidden>
<IncludeCode>%ZHSLIB.Component.Build,%occXSLT</IncludeCode>
<TimeChanged>67214,49066.638594</TimeChanged>
<TimeCreated>67214,49066.638594</TimeCreated>

<Method name="PreConfigureSteps">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	// Update default database to be writeable
	Do ..UpdateDefaultDatabaseReadOnly(0)

	// The next two lines of code will enable seeing hidden classes
	Do ##class(%ZHSLIB.UsersAndRoles).AddRole("ISC_Internal", "")
	Do ##class(%ZHSLIB.UsersAndRoles).AddUserRolesGroups($Username, "ISC_Internal")
]]></Implementation>
</Method>

<Method name="PreBuildSteps">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pIsDev:%Boolean</FormalSpec>
<Implementation><![CDATA[
	// Set $$$BuildFlag, create %SourceControl, and back up ^Sources
	Set sc = ##class(%IPM.ExtensionBase.SourceControl.Interface).%OnBeforeBuild(pIsDev)
	$$$ThrowOnError(sc)

	// Suspend Task Manager. Can ignore error. Not fatal
	Do $System.Task.SuspendSet(1)
	// Disable IO redirection
	Do ##class(%Library.Device).ReDirectIO(0)
	
	$$$InitTotalTime
	Kill $$$BuildErrorsPPG
	Do StartLog^%buildutil()
]]></Implementation>
</Method>

<Method name="PostBuildSteps">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pIsDev:%Boolean,pStatus:%Status</FormalSpec>
<Implementation><![CDATA[
	$$$ElapsedTotalTime
	$$$WriteBoldNewLine("Build finished on "_$ZDateTime($Horolog))

	Do EndLog^%buildutil()
	Set numberOfErrors = +$Get($$$BuildErrorsPPG)
	If (numberOfErrors > 0) {
		Write !, $Char(7)
		$$$WriteBoldNewLine("WARNING: At least "_numberOfErrors_" errors occurred during the build.")
	} Else {
		Write !
		$$$WriteBoldNewLine("No errors detected.")
	}
	// Restore ^Sources if errors occurred (or if there were modules installed that aren't part of the build)
	Do ##class(%IPM.ExtensionBase.SourceControl.Interface).%OnAfterBuild(pIsDev, $$$ISOK(pStatus))
	Do $System.Task.SuspendSet(0)
]]></Implementation>
</Method>

<Method name="CreateDefaultDatabaseGlobals">
<Description><![CDATA[
Creates default globals such as ^oddCOM, ^oddDEF etc. that are necessary before loading and compiling any code. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	New $namespace
	Set $Namespace = "%SYS"
	Set destDir = $Piece(##class(%SYS.Namespace).GetRoutineDest($Namespace), "^" , 2)
	Set sc = ##class(SYS.Database).CreateDefaultGlobals(destDir)
	$$$ThrowOnError(sc)
]]></Implementation>
</Method>

<Method name="RunCommandsFromDynamicArray">
<Description><![CDATA[
Given a dynamic array of commands, calls the package manager "run-from-file" command
passing it the array to run commands sequentially. To see the expected format of
each JSON object command within the array, run zpm "help run-from-file". <br /.
@Argument	pArray		JSON array of commands to run, where each command is represented as a JSON object. <br />
@Argument	pVerbose	Whether to use verbose logging. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pArray:%Library.DynamicArray,pVerbose:%Boolean</FormalSpec>
<Implementation><![CDATA[
	Set tempStream = ##class(%Stream.FileCharacter).%New()
	Set tempFilename = ##class(%Library.File).TempFilename("json")
	$$$ThrowOnError(tempStream.LinkToFile(tempFilename))
	#dim commandsJson As %Library.DynamicObject
	Set commandsJson = { "commands": (pArray) }
	Do commandsJson.%ToJSON(tempStream)
	$$$ThrowOnError(tempStream.%Save())
	Set command = "run-from-file "_tempFilename
	$$$PackageManagerCommand(command,pVerbose)
]]></Implementation>
</Method>

<Method name="FindModuleInRepositories">
<Description><![CDATA[
Looks for module by name in configured repositories and returns a module reference to the first occurrence
of the module found. If the module was not found in any repositories, <var>pFound</var> is set to 0. <br />
@Argument	pModuleName		Name of module to look for. <br />
@Argument	pVersion		Version of the module to look for. If not specified, default to find the latest version. <br />
@Argument	pFound			Whether the module was found in repositories in this namespace. <br />
ReturnType: %IPM.Storage.QualifiedModuleInfo]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pModuleName:%String,pVersion:%String="",*pFound:%Boolean</FormalSpec>
<ReturnType>%RegisteredObject</ReturnType>
<Implementation><![CDATA[
	Set pFound = 0
	Set searchCriteria = ##class(%IPM.Repo.SearchCriteria).%New()
	Set searchCriteria.Name = pModuleName
	If ($ZConvert(pVersion, "L") = "latest") {
		Set pVersion  = ""
	}
	Set searchCriteria.VersionExpression = pVersion
	#dim resultList As %Library.ListOfObjects
	Write !, "Looking for module in configured repositories..."
	Set sc = ##class(%IPM.Repo.Utils).SearchRepositoriesForModule(searchCriteria, .resultList)
	$$$ThrowOnError(sc)
	Write "Done."
	If (resultList.Count() '= 0) {
		Set pFound = 1
	}
	Return resultList.GetAt(1)
]]></Implementation>
</Method>

<Method name="GetNamespaceConfig">
<Description><![CDATA[
Obtains namespace config object for a module given its root directory (i.e. local path to module.xml file). <br />
ReturnType: %IPM.Storage.ModuleSetting.NamespaceConfig]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pRootDirectory:%String</FormalSpec>
<ReturnType>%RegisteredObject</ReturnType>
<Implementation><![CDATA[
	#dim module As %IPM.Storage.Module
	Set module = ##class(%IPM.Utils.Module).GetModuleObjectFromPath(pRootDirectory, .found)
	If 'found {
		$$$ThrowStatus($$$ERROR($$$GeneralError,"Unable to parse module contents from stream"))
	}
	Return module.GetNamespaceConfig()
]]></Implementation>
</Method>

<Method name="ConfigureMappings">
<Description><![CDATA[
Configures mappings from ENSLIB and/or HSLIB depending on the namespace config passed in. <br />
@Argument	pNamespaceConfig		Namespace config that determines which mappings to configure. <br />
@Argument	pVerbose				Whether to do verbose logging of steps being performed. <br />
@Argument	pProductionsWereRunning	Whether productions were running in the current namespace (if they were, then they are stopped). <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespaceConfig:%RegisteredObject,pVerbose:%Boolean=0,*pProductionsWereRunning:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	#dim pNamespaceConfig As %IPM.Storage.ModuleSetting.NamespaceConfig
	// Configure mappings from ENSLIB
	If (pNamespaceConfig.EnableEnsemble) {
		$$$WriteBoldNewLine("Enabling Ensemble Library Namespace")
		$$$ThrowOnError(##class(%EnsembleMgr).map2enslib($Namespace, pVerbose))
		Write !
	
		$$$WriteBoldNewLine("Cleaning productions from "_$Namespace)
		$$$ThrowOnError(##class(Ens.Config.Production).%KillExtent())
		$$$ThrowOnError(##class(Ens.Config.Item).%KillExtent())
	
		If ##class(%Dictionary.CompiledClass).%ExistsId("HS.Director") {
			Set pProductionsWereRunning = 1
			$$$WriteBoldNewLine("Stopping any running HealthShare productions")
			Set sc = ##class(HS.Director).StopAll()	
			If $$$ISERR(sc) {
				// Failure to stop productions should not be fatal. Just give a warning
				// because we always want to continue with the build.
				Write !, "WARNING: Failed to start productions due to the following error:"
				Write !, $System.Status.GetErrorText(sc)
			}
			Write !
		}
	}
	
	// Configure mappings from HSLIB
	If (pNamespaceConfig.EnableHealthShare) {
		// Need for force HSLIB from itself on kit builds for %-classes that
		// could be in HSLIB.
		$$$WriteBoldNewLine("Force Enabling Mappings for HSLIB from HSLIB")
		Write !
		$$$ThrowOnError(##class(%ZHSLIB.HealthShareMgr).MapComponent("HSLIB", "HSLIB", pVerbose))
		Write !
		$$$WriteBoldNewLine("Enabling Mappings for "_$Namespace_" from HSLIB")
		Write !
		$$$ThrowOnError(##class(%ZHSLIB.HealthShareMgr).MapComponent("HSLIB", $Namespace, pVerbose))
		Write !
	}
]]></Implementation>
</Method>

<Method name="LoadBaseModuleAndDependencies">
<Description><![CDATA[
Installs the provided module, along with its dependencies. <br />
@Argument	pRootDirectory		Directory containing base module to install. <br />
@Argument	pIsDev				Whether the build is running in developer mode. <br />
@Argument	pVerbose			Whether verbose output should be provided during the build. <br />
@Argument	pNoMapping			Value to use for NoMapping modifier. <br />
@Argument	pIsKitBuild			Whether the current call is during an actual kit build. <br />
@Argument	pIgnoreInstalled 	Whether to ignore installed modules during dependency graph building. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pRootDirectory:%String,pIsDev:%Boolean,pVerbose:%Boolean,pNoMapping:%Boolean,pIsKitBuild:%Boolean=0,pIgnoreInstalled:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	If $Data(^ZEN.IncludeDir, zenDirectory)#2 {
		Set zenDirectory = ##class(%Library.File).NormalizeDirectory(zenDirectory)
		Set success = ##class(%Library.File).CreateDirectoryChain(zenDirectory, .return)
		If 'success {
			$$$ThrowStatus($$$ERROR($$$GeneralError, $$$FormatText("Could not create directory '%1': %2"), zenDirectory, $ZUtil(209, return)))
		}
	}
	
	// MUST do AFTER reinstalling ZHSLIB in this namespace because dev builds will obtain from there
	Do ..GetInputParametersFromRootDirectory(pRootDirectory, pIsDev, pVerbose, .inputParameters)
	
	If pIsDev && $Data(inputParameters) {
		// Put input parameters into namespace defaults
		$$$WriteBoldNewLine("Putting custom input parameters obtained from parameters.json into namespace default modifiers")
		Do ##class(%IPM.Main).SetNamespaceDefaultModifiers(.inputParameters)
	}
	Merge params = inputParameters
		
	// Load the root module (and dependencies)
	Set params("DeveloperMode") = pIsDev
	Set params("Verbose") = pVerbose
	Set params("NoMapping") = pNoMapping
	Set params("IsKitBuild") = pIsKitBuild
	Set params("IgnoreInstalled") = pIgnoreInstalled
	// pass build number into PackageManager methods as parameters so PM does not depend on build number knowledge
	If pIsKitBuild {
		Try {
			Set params("IsKitBuild", "BuildNumber") = $$$BuildNumberGbl
		} Catch e {
			// do nothing; buildnumber not yet available
		}
	}
	Set params("UpdateSnapshots") = 1
	Set params("NoTransaction") = 1
	Set params("NoJournal") = 1
	Set params("NoStudioProject") = 1
	If 'pIsDev {
		Set params("AngularBuild", "Run") = 1
		Set params("AngularArtifact", "Run") = 1
		// Set parameters from settings.xml, specifically serverURL, username and password
		Write !, "About to parse settings.xml to obain Artifactory info..."
		Set fileName = "settings.xml"
		If ($$$isUNIX) {
			Set fileName = ##class(%File).NormalizeFilename(fileName, "~/.m2")
		} ElseIf ($$$isWINDOWS) {
			// write the home dir value to a temporary userProfile.txt file using $ZF(-100), and read from it
			Set userProfileFileDir = ##class(%File).NormalizeFilename("userProfile.txt")
			Set status = $ZF(-100, "/SHELL /STDOUT="_userProfileFileDir,"echo", "%USERPROFILE%")
			If (status '= 0) {
				$$$ThrowStatus($$$ERROR($$$GeneralError,"Unable to find USERPROFILE. Error code: "_status))
			}
			// read from the temp file
			Set stream = ##class(%Stream.FileCharacter).%New()
  			$$$ThrowOnError(stream.LinkToFile(userProfileFileDir))
			Set homeDir = stream.ReadLine(, .sc)
			$$$ThrowOnError(sc)
			Set fileName = ##class(%File).NormalizeFilename(fileName, homeDir_"\.m2")
		}
		If (fileName = "") {
			$$$ThrowStatus($$$ERROR($$$GeneralError, "Could not find the directory containing settings.xml file."))
		}
		Write !, "Found the full path of the settings.xml file: ", fileName
		Write !, "Start parsing..."
		Do ##class(%ZHSLIB.Component.Utils).ParseArtiSettingsXML(fileName, .username, .password, .server)
		Set params("Artifactory", "Server") = server
		Set params("Artifactory", "Username") = username
		Set params("Artifactory", "Password") = password
		Write !, "Parsing done."
	}
	
	// Ensure mapping is created for % classes before loading modules if NoMapping = 1 during a kit build
	// NEED this to not occur during dev build so that the classes appropriately get put in IRISSYS
	// NOTE: This code should be generalized with resource attributes for %Z resources so that this code is
	// not needed.
	If ($Get(params("NoMapping"), 0) = 1) && 'pIsDev {
		Set defaultCodeDatabase = ##class(%IPM.Utils.Module).GetRoutineDatabase($Namespace)
		Set percentMappingList = $ListBuild("%ZHS", "%ZHSMOD")
		Set ptr = 0
		While $ListNext(percentMappingList, ptr, percentMapping) {
			Write !, "Adding mapping for "_percentMapping_" for namespace "_$Namespace_" from database "_defaultCodeDatabase
			Set sc = ##class(%IPM.Utils.Module).AddPackageMapping($Namespace, percentMapping, defaultCodeDatabase)
			$$$ThrowOnError(sc)
		}
	}
	
	Write !!, "Loading module from directory "_pRootDirectory
	Set sc = ##class(%IPM.Utils.Module).LoadNewModule(pRootDirectory, .params, , 1)
	$$$ThrowOnError(sc)

	// After build, update isc.rest data for all namespaces.
	// Only relevant for dev builds.
	If pIsDev {
		New %SourceControl
		Do ..UpdateIscRESTData()
	}
	
	// Additionally, report any conflicts between modules.
	Do ##class(%IPM.Storage.LoadedResource).ReportConflicts()
]]></Implementation>
</Method>

<Method name="UpdateIscRESTData">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	New $Namespace
	Set $Namespace = "HSSYS"
	If '$System.CLS.IsMthd("HS.Util.Installer.ConfigItem","CreateProjectionsForRESTModelClasses") {
		Return
	}
	// Query all namespaces and update persistent metadata
	Set query = "SELECT ID FROM HS_Util_Installer.ConfigItem"
	#dim resultSet As %SQL.StatementResult
	Set resultSet = ##class(%SQL.Statement).%ExecDirect(, query)
	$$$ThrowSQLIfError(resultSet.%SQLCODE,resultSet.%Message)
	// Iterate through results + add HSSYS (no need for HSCUSTOM as it has no REST APIs).
	// Hard-code getting projections for HSSYS from HSLIB.
	Kill namespaceToDatabaseArray
	Set namespaceToDatabaseArray("HSSYS") = "HSLIB"
	While resultSet.%Next(.sc) {
		$$$ThrowOnError(sc)
		Set namespace = $ZConvert(resultSet.%Get("ID"), "U")
		If '##class(%SYS.Namespace).Exists(namespace) {
			// Never been activated which is ok. Can skip
			Continue
		}
		Set configItem = ##class(HS.Util.Installer.ConfigItem).%OpenId(namespace, , .sc)
		$$$ThrowOnError(sc)
		Set namespaceToDatabaseArray(namespace) = configItem.GetInstallerDatabase()
	}
	$$$ThrowOnError(sc)

	// For each namespace, copy persistent data to it
	Set namespace = ""
	While 1 {
		Set namespace = $Order(namespaceToDatabaseArray(namespace),1,database)
		If (namespace = "") {
			Quit
		}
		If (database = "") {
			// Should never happen but if so, just skip to avoid errors.
			Continue
		}
		Do ##class(HS.Util.Installer.ConfigItem).CreateProjectionsForRESTModelClasses(namespace, database)
	}
]]></Implementation>
</Method>

<Method name="GetInputParametersFromRootDirectory">
<Description><![CDATA[
Get the custom input parameters from the parameters.json file from
a standard path location in pRootDirectory if in non-dev mode. <br />
If in dev mode, checks root directory of ZHSLIB. <br />
This includes information such as server names and ports that
should never be harcoded in shipping code. <br />
@Argument	pRootDirectory			Directory containing base module to install. <br />
@Argument	pIsDev					Whether the build is running in developer mode. <br />
@Argument	pVerbose				Whether verbose output should be provided during the build. <br />
@Argument	pInputParameterArray	Multi-dimensional array containing the the parameter values obtained from the file. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pRootDirectory:%String,pIsDev:%Boolean,pVerbose:%Boolean,*pInputParameterArray</FormalSpec>
<Implementation><![CDATA[
	Kill pInputParameterArray
	Set inputParametersFilename = ""
	// The /build/integration directory is overlaid across HS components and since ZHSLIB is part of every HS build
	// AND is built first, the parameters.json from it makes its way into THIS component's /build/integration directory
	Set integrationDirectory = pRootDirectory_"../../build/integration"
	If pIsDev {
		// In dev mode, no overlay occurs so look directly in ZHSLIB
		// ZHSLIB has to have been loaded so find its root directory and then back-track to find parameters.json
		#dim moduleObj As %IPM.Storage.Module
		Set moduleObj = ##class(%IPM.Storage.Module).NameOpen("ZHSLIB", , .sc)
		If '$IsObject(moduleObj) || $$$ISERR(sc) {
			// Error is not fatal so do not kill build
			If pVerbose {
				Write !, "Unable to find ZHSLIB module in current namespace so not loading parameters.json file"
			}
			Return
		}
		Set integrationDirectory = moduleObj.Root_"build/integration"
	}
	Set inputParametersFilename = ##class(%Library.File).NormalizeFilename("parameters.json", integrationDirectory)
	If (inputParametersFilename '= "") && ##class(%Library.File).Exists(inputParametersFilename) {
		Set fileStream = ##class(%Stream.FileCharacter).%New()
		$$$ThrowOnError(fileStream.LinkToFile(inputParametersFilename))
		Set inputParametersJson = ##class(%Library.DynamicObject).%FromJSON(fileStream)
		Do ..DynamicObjectToMultiDimensional(inputParametersJson, .pInputParameterArray)
	} Else {
		If pVerbose {
			// Preserving backwards compatibility for builds that may not have this file defined
			Write !, "Could not find parameters.json. Skipping import"
			Return
		}
	}
]]></Implementation>
</Method>

<Method name="DynamicObjectToMultiDimensional">
<Description><![CDATA[
Parse the provided JSON object into a multi-dimensional array. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pObj:%Library.DynamicObject,&pArray]]></FormalSpec>
<Implementation><![CDATA[
	Set iter = pObj.%GetIterator()
	While iter.%GetNext(.key, .value) {
		If $IsObject(value) {
			Kill tempNode
			Do ..DynamicObjectToMultiDimensional(value, .tempNode)
			Merge pArray(key) = tempNode
		} Else {
			Set pArray(key) = value
		}
	}
]]></Implementation>
</Method>

<Method name="StoreBuildConfigInfoInGlobals">
<Description><![CDATA[
Store the name of the base module and repositories to configure
when ConfigureAsBuilt() is used. Base module name is extracted from
<var>pRootDirectory</var>.
This info is stored in a global in <var>pDatabase</var>. <br />
@Argument	pDatabase				Database to store global in. <br />
@Argument	pRootDirectory			Directory containing base module to install. <br />
@Argument	pComponentMapLowerCase	Space-separated list of component names to their Perforce depot paths. <br />
@Argument	pRepoList				List of Perforce depot repository paths. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDatabase:%String,pRootDirectory:%String,pComponentMapLowerCase:%String,pRepoList:%Library.List</FormalSpec>
<Implementation><![CDATA[
	// Transform to map
	Set componentMapList = $ListFromString(pComponentMapLowerCase, ",")
	Set ptr = 0
	While $ListNext(componentMapList,ptr,value) {
		Set $ListBuild(name, depotPath) = $ListFromString(value,":")
		Set nameToDepotPathMap(name) = depotPath
	}
	// Get module object and store its name
	#dim moduleObj As %IPM.Storage.Module
	Set moduleObj = ##class(%IPM.Utils.Module).GetModuleObjectFromPath(pRootDirectory)
	Set baseModuleName = moduleObj.Name
	Set $$$BuildConfigBuiltBaseModuleName(pDatabase) = baseModuleName
	
	// Compute depot paths used to create repositories
	// Special handling for HealthConnect because it is not a part of the component array
	If ($ZConvert(baseModuleName, "U") = $ZConvert("HealthConnect", "U")) {
		Set baseModuleDepotPath = $Get(nameToDepotPathMap("healthconnect"))
	} Else {
		// Component array contains metadata of each HS component database stored in
		// LibraryDatabaseMetadata XData block in %ZHSLIB.HealthShareMgr
		Do ##class(%ZHSLIB.HealthShareMgr).GetComponentArray(.componentArray)
		Set database = ""
		While 1 {
			Set database = $Order(componentArray(database))
			If (database = "") {
				Quit
			}
			Set moduleName = $Get(componentArray(database, $$$SubscriptModule))
			Set buildSpecName = $ZConvert($Get(componentArray(database, $$$SubscriptBuildSpec)), "L")
			If ($ZConvert(moduleName, "U") = $ZConvert(baseModuleName, "U")) {
				Set baseModuleDepotPath = $Get(nameToDepotPathMap(buildSpecName))
				Quit
			}
		}
	}
	If (baseModuleDepotPath = "") {
		// Something went horribly wrong. Base module depot path not found
		$$$ThrowStatus($$$ERROR($$$GeneralError,"Unable to find base module depot path"))
	}
	
	// Add depot path to front of list to ensure base module is taken
	// from this repo always in ConfigureAsBuilt()
	Set $$$BuildConfigBuiltRepoPaths(pDatabase) = $ListBuild(baseModuleDepotPath) _ pRepoList
]]></Implementation>
</Method>

<Method name="SetLabelForRepositories">
<Description><![CDATA[
Set the provided Perforce label to the list of repository paths. <br />
@Argument	pLabel		Perforce label to apply. <br />
@Argument	pRepoList	List of Perforce depot paths to apply the label to. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pLabel:%String,pRepoList:%Library.List</FormalSpec>
<Implementation><![CDATA[
	Set ptr = 0
	While $ListNext(pRepoList, ptr, repo) {
		// Apply the label
		Set sc = ##class(%Studio.SourceControl.ISC).RunCmd("p4 tag -l "_pLabel_" "_repo_"...#have", .tagOutput)
		If $$$ISERR(sc) {
			Set errorText = $System.Status.GetErrorText(sc)
			If (errorText [ "label in sync") {
				// If the label is already up to date (e.g., for an adhoc build), it's not actually an error.
				Set sc = $$$OK
			} ElseIf (errorText [ "no such file(s)") || (errorText [ "file(s) not on client") || (errorText [ "file(s) not opened on this client") {
				// If there were no files to label (e.g., no dependencies pulled in), it's not actually an error.
				Set sc = $$$OK
			}
		}
		$$$ThrowOnError(sc)

		// Write all files tagged with the label
		For i = 1:1:$Get(tagOutput) {
			Write !, $Get(tagOutput(i))
		}
	}
]]></Implementation>
</Method>

<Method name="CompactAndShrinkDatabase">
<Description><![CDATA[
Compact and shrink the provided database once build is complete. <br />
@Argument	pDatabaseLower		Name of the component database (lower case). <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDatabaseLower:%String</FormalSpec>
<Implementation><![CDATA[
	New $Namespace
	Set $Namespace = "%SYS"
	Write !, "Compacting database..."
	Set sc = ##class(SYS.Database).CompactDatabase(pDatabaseLower, 99, .proc, .comp, 0, 0)
	$$$ThrowOnError(sc)
	Write !, "Done."
	Write !, "Processed: "_proc_", Compacted to: "_comp
	Write !, "Compacting IRIS.DAT..."
	Set sc = ##class(SYS.Database).FileCompact(pDatabaseLower, -1, .free)
	$$$ThrowOnError(sc)
	Write "Done."
	Write !, "Freed: "_free
	Write !, "Shrinking database..."
	Set rc = $ZUtil(30, pDatabaseLower, 0)
	Write !, "Done."
	Write !, "Shrunk database size: "_rc
]]></Implementation>
</Method>

<Method name="UpdateDefaultDatabaseReadOnly">
<Description><![CDATA[
Set "ReadOnly" property of the default routine database of the current namespace. <br />
@Argument	pReadOnly	Value of the "ReadOnly" property for the database. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pReadOnly:%Boolean</FormalSpec>
<Implementation><![CDATA[
	Set directory = ##class(%IPM.Utils.Module).GetRoutineDatabaseDir($Namespace)
	New $Namespace
	Set $Namespace = "%SYS"
	Set database = ##class(SYS.Database).%OpenId(directory, , .sc)
	$$$ThrowOnError(sc)
	If (database.ReadOnly '= pReadOnly) {
		Set database.ReadOnly = pReadOnly
		Set sc = database.%Save()
		$$$ThrowOnError(sc)
	}
]]></Implementation>
</Method>

<Method name="GetValueFromEvaluateResult">
<Description><![CDATA[
From an XML XPATH evaluation result, output the single string value of the element. <br />
@Argument	pResults	Value of the DOM-type XML XPATH evaluation result. <br />
@Argument	pValue		Single value of stored in the element in the evaluation result. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pResults:%XML.XPATH.Result,*pValue:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  If (pResults.Count() < 1) {
    Return $$$ERROR($$$GeneralError, "Did not find snapshots server in settings.xml file.")
  }
  // get the first valid value
  Set targetResult=pResults.GetAt(1)
  If (targetResult.Type=$$$XPATHDOM) {
    While targetResult.Read() {  
      If targetResult.NodeType="chars" {
        Set pValue = targetResult.Value
        Return $$$OK
      }
    }
  } Else {
    Return $$$ERROR($$$GeneralError, "Something went wrong. Evaluation evalution type is: "_targetResult.Type_". Should be 2:DOM.")
  }
]]></Implementation>
</Method>

<Method name="ParseArtiSettingsXML">
<Description><![CDATA[
Output server username, server password, and artifactory server url from a settings xml file. <br />
@Argument	pFileName		Value of the full path of the settings.xml file. <br />
@Argument	pServerUsername	Value of the <username> element of <server> whose id is snapshots. <br />
@Argument	pServerPassword	Value of the <password> element of <server> whose id is snapshots. <br />
@Argument	pArtiURL		Value of the <url> element of the first <respository> element. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pFileName:%String,*pServerUsername:%String,*pServerPassword:%String,*pArtiURL</FormalSpec>
<Implementation><![CDATA[
  // use prefixMapping parameter to avoid the situation where an element belongs to a namespace but does not have a namespace prefix
  $$$ThrowOnError(##class(%XML.XPATH.Document).CreateFromFile(pFileName,.document, , , , , "s https://maven.apache.org/SETTINGS/1.1.0"))
  // parse to get <server> element whose <id> is snapshots, and get its username
  $$$ThrowOnError(document.EvaluateExpression("/s:settings/s:servers/s:server[s:id='snapshots']","s:username",.usernameResults))
  // parse to get <server> element whose <id> is snapshots, and get its password
  $$$ThrowOnError(document.EvaluateExpression("/s:settings/s:servers/s:server[s:id='snapshots']","s:password",.passwordResults))
  // parse to get <url> property of the first <repository> element
  $$$ThrowOnError(document.EvaluateExpression("/s:settings/s:profiles/s:profile/s:repositories/s:repository","s:url",.urlResults))
  
  $$$ThrowOnError(..GetValueFromEvaluateResult(usernameResults, .pServerUsername))
  $$$ThrowOnError(..GetValueFromEvaluateResult(passwordResults, .pServerPassword))
  $$$ThrowOnError(..GetValueFromEvaluateResult(urlResults, .pArtiURL))
  Set pArtiURL = $Piece(pArtiURL, "/", *-1)
]]></Implementation>
</Method>

<Method name="DeleteNamespace">
<Description><![CDATA[
Delete the given namespace with name <var>pNSName</var>. <br />
Optionally indicate whether this is a component namespace (like HSLIB). <br />
Copied over from %IPM.Utils.Build.cls to be called from %SYS namespace]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pNSName:%String,pVerbose:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New $Namespace
	Set tFinalStatus = $$$OK
	Try {
    	If pVerbose Write !,"Deleting namespace: " _ pNSName
		Set $Namespace = "%SYS"
		Set tLowerName = $ZConvert(pNSName,"L")
		// The csp directory is lower case on unix but upper case on windows
		Set tCSP = "csp"
		If $$$isWINDOWS {
			Set tCSP = $ZConvert(tCSP, "U")
		}
		// All directories under the csp directory are lower case (on all platforms)
		Set tCSPChildName = $ZConvert(pNSName, "L")
		Set tWebPath = ##class(%Library.File).NormalizeDirectory(##class(%File).ParentDirectoryName(##class(%File).ManagerDirectory()) _ tCSP) _ tCSPChildName
		Set tWebPath = ##class(%Library.File).NormalizeDirectory(tWebPath)
		Set tWebPathExists = ##class(%Library.File).DirectoryExists(tWebPath)
		
		// Delete Web Applications
		Set tSC = ..DeleteWebApplications(pNSName)
		Set tFinalStatus = $$$ADDSC(tFinalStatus,tSC)
		// Delete csp directory
		If tWebPathExists {
			Set tDirRemoved = ##class(%Library.File).RemoveDirectoryTree(tWebPath)
			If 'tDirRemoved {
				// This isn't a fatal error so just write to console log as a warning
				Do ##class(%SYS.System).WriteToConsoleLog("Error removing directory '"_tWebPath_"'", , 1)
			}
		}

    	// Delete namespace
		If ##class(Config.Namespaces).Exists(pNSName) {
			Do ##class(Config.Namespaces).Get(pNSName, .params)
			Set tSC = ##class(Config.Namespaces).Delete(pNSName)
			Set tFinalStatus = $$$ADDSC(tFinalStatus,tSC)
		}
		
		// Disable if ensemble enabled (only on primary if mirrored because it tries to modify
		// globals in read-only databases if run on backup which causes <PROTECT> errors)
		If '$System.Mirror.IsMember() || $System.Mirror.IsPrimary() {
		 	If ((##class(%Library.EnsembleMgr).IsEnsembleInstalled() || ##class(%Library.EnsembleMgr).IsHealthShareInstalled())) {
		 		Set tSC = ##class(%Library.EnsembleMgr).DisableNamespace(pNSName)
		 		If $$$ISERR(tSC) {
					Set tFinalStatus = $$$ADDSC(tFinalStatus,tSC)
		 		}
		 	}
		}
	} Catch e {
		Set tFinalStatus = $$$ADDSC(tFinalStatus,e.AsStatus())
	}
	Quit tFinalStatus
]]></Implementation>
</Method>

<Method name="DeleteDatabase">
<Description><![CDATA[
Delete the given database with name <var>pDBName</var>. <br />
Optionally indicate whether this is a component library database (like HSLIB). <br />
Copied over from %IPM.Utils.Build.cls to be called from %SYS namespace]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDBName:%String,pIsLibraryDatabase:%Boolean=0,pVerbose:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#define Log(%msg,%severity) If (pVerbose) { Do ##class(%SYS.System).WriteToConsoleLog(%msg, , %severity) }
	New $Namespace
	Set tFinalStatus = $$$OK
	Try {
		Set $Namespace = "%SYS"
		Set tPath = ##class(%Library.File).NormalizeDirectory(##class(%Library.File).ManagerDirectory() _ pDBName)
		If pIsLibraryDatabase {
			Set tPath = $$$HSLibraryDatabaseDirectory(pDBName)
		}
		
		If ##class(Config.Databases).Exists(pDBName) {
			// Delete database
			Set tSC = ##class(Config.Databases).Delete(pDBName)
			Set tFinalStatus = $$$ADDSC(tFinalStatus,tSC)
		}

		// Delete database file
		If ##class(%Library.File).Exists(tPath_"IRIS.DAT") {
			// It is fine if this fails because the directory will be removed below, so no need to check status
			Do ##class(SYS.Database).DeleteDatabase(tPath)
			$$$Log("Deleted database file: "_tPath_"IRIS.DAT", 1)
		}
		// Check for legacy file to delete as well
		If ##class(%Library.File).Exists(tPath_"CACHE.DAT") {
			// It is fine if this fails because the directory will be removed below, so no need to check status
			Do ##class(SYS.Database).DeleteDatabase(tPath)
			$$$Log("Deleted database file: "_tPath_"CACHE.DAT", 1)
		}

		// Delete directories
		If ##class(%Library.File).DirectoryExists(tPath) {
			Set tDirRemoved = ##class(%Library.File).RemoveDirectoryTree(tPath)
			If 'tDirRemoved {
				Set tFinalStatus = $$$ADDSC(tFinalStatus,$$$ERROR($$$GeneralError,"Error removing directory '"_tPath_"'"))
			}
			$$$Log("Deleted database directory: "_tPath, 1)
		}
		
		Set tRoleResourceName = "%DB_" _ $zconvert(pDBName,"U")
		// If the role for the database exists, remove it
		If ##class(Security.Roles).Exists(tRoleResourceName) {
			Set tSC = ##class(Security.Roles).Delete(tRoleResourceName)
			Set tFinalStatus = $$$ADDSC(tFinalStatus,tSC)
		}
		// If the resource for the database exists, remove it
		If ##class(Security.Resources).Exists(tRoleResourceName) {
			Set tSC = ##class(Security.Resources).Delete(tRoleResourceName)
			Set tFinalStatus = $$$ADDSC(tFinalStatus,tSC)
		}

	} Catch e {
		Set tFinalStatus = $$$ADDSC(tFinalStatus,e.AsStatus())
	}
	Quit tFinalStatus
]]></Implementation>
</Method>

<Method name="DeleteWebApplications">
<Description>
Delete all web applications within namespace pNamespace
Copied over from %IPM.Utils.Build.cls to be called from %SYS namespace</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New $Namespace
	Set tFinalStatus = $$$OK
	Try {
		Set $Namespace = "%SYS"
		Set tApps = ##class(%SQL.Statement).%ExecDirect(,
			"select Name from Security.Applications where Namespace = ?",pNamespace)
		If (tApps.%SQLCODE < 0) {
			Throw ##class(%Exception.SQL).CreateFromSQLCODE(tApps.%SQLCODE,tApps.%Message)
		}
		While tApps.%Next(.tSC) {
			$$$ThrowOnError(tSC)
			Set tSC = ##class(Security.Applications).Delete(tApps.%Get("Name"))
			Set tFinalStatus = $$$ADDSC(tFinalStatus,tSC)
		}
		$$$ThrowOnError(tSC)
	} Catch e {
		Set tFinalStatus = $$$ADDSC(tFinalStatus,e.AsStatus())
	}
	Quit tFinalStatus
]]></Implementation>
</Method>

<Method name="IsModuleAvailable">
<Description>
Check whether a module is available is a given namespace
Duplicated from %IPM.Main to enable calling from non-LIB namespaces</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pModule:%String,pNamespace:%String="HSLIB"</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	// switch from application namespace to HSSYS in order to invoke IPM class
	New $Namespace
	Set $Namespace = "HSSYS"
	Return ##class(%IPM.Main).IsAvailable(pModule, pNamespace)
]]></Implementation>
</Method>

<Method name="BeginCaptureOutput">
<Description><![CDATA[
Duplicated from %IPM.Utils.Module to enable calling from non-LIB namespaces
This method enables I/O redirection (see EndCaptureOutput for retrieval). <var>pCookie</var> has the previous I/O redirection info.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pCookie:%String</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New tSC,e

	#dim tSC As %Status = $$$OK
	#dim e As %Exception.AbstractException

	Try {
		#; This facility is not re-entrant
		If $Data(^||%capture) Set tSC=$$$ERROR($$$GeneralError,"Capture Already Active") Quit

		#; If re-direction is already active
		If $zutil(82,12) {
			#; Retain the name of the re-directed routine
			Set pCookie=$ZU(96,12)
		} else {
			Set pCookie=""
		}

		#; Use THIS routine for redirection
		Use $io::("^"_$ZNAME)

		#; Switch redirection on
		Do $zutil(82,12,1)

		Kill ^||%capture

	} Catch (e) {
	Set tSC=e.AsStatus()
	}
	Quit tSC
    
   #; Internal Entry points for device re-direction
rstr(sz,to) [rt] public {
	New rt Set vr="rt"
	Set rd=$zutil(82,12,0)
	Set:$data(sz) vr=vr_"#"_sz Set:$data(to) vr=vr_":"_to
	Read @vr
	Do:$data(to) $zutil(96,4,$t)
	Do $zutil(82,12,rd)
	Quit rt
  }
wchr(s)public { Do write($char(s)) }
wff() public { Do write($char(12)) }
wnl() public {
	If '$data(^||%capture(0)) Set ^||%capture(0)=1,^(1)=""
	Set ^||%capture($increment(^||%capture(0)))=""
  }
wstr(s) public { Do write(s) }
wtab(s) public { Do write($justify("",s-$x)) }
write(s) public {
	Set lf=$find(s,$C(10))
	While lf {
	    Do write($Extract(s,1,lf-2)),wnl()
	    Set s=$Extract(s,lf,*)
	    Set lf=$find(s,$C(10))
	}
	Set lno=$get(^||%capture(0)) Set:lno="" lno=1,^||%capture(0)=1
	Set ^||%capture(lno)=$get(^||%capture(lno))_$translate(s,$char(13))
  }
]]></Implementation>
</Method>

<Method name="EndCaptureOutput">
<Description>
Duplicated from %IPM.Utils.Module to enable calling from non-LIB namespaces
This method captures the output from a program and delivers it as an array of lines</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCookie:%String,*pText</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tLast,tKey,tValue As %String

	If pCookie'="" {
		#; Use the original redirected routine
		Use $io::("^"_pCookie)
	} else {
		#; Otherwise switch redirection off
		Do $zutil(82,12,0)
	}

	Try {
		Set tLast=$Get(^||%capture(0),0)
		For tKey=1:1:tLast-1 {
			Set pText($i(pText)) = ^||%capture(tKey)
		}
		If tLast,^||%capture(tLast)'="" {
			Set pText($i(pText)) = ^||%capture(tLast)
		}
	} Catch {
		Set pText($i(pText)) = "Capture error: "_$ZE
	}

	Kill ^||%capture

	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%ZHSLIB.Context.InitializerBase">
<Description><![CDATA[
Interface to initialize per-process singleton services. <br />
@API.Extensible
@Modifier	Availability	InterSystems]]></Description>
<Abstract>1</Abstract>
<Super>%RegisteredObject</Super>
<TimeChanged>67214,49066.6699459</TimeChanged>
<TimeCreated>67214,49066.6699459</TimeCreated>

<Method name="%%CheckClassValidity">
<Description>
Checks if the necessary methods and parameters have implementations in non abstract subclasses.</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<ForceGenerate>1</ForceGenerate>
<Implementation><![CDATA[	$$$ThrowOnError(##class(%ZHSLIB.CodeGenUtils.VerifyAbstractMembersDefined).CheckCompiledClassValidityAgainstAbstractClass(%compiledclass, "%ZHSLIB.Context.InitializerBase"))
]]></Implementation>
</Method>

<Method name="OnStart">
<Description><![CDATA[
Should call RegisterService present in <var>pContext</var>. <br />
@API.Overrideable
@Argument	pContext		Per-process HealthShare context instance]]></Description>
<Abstract>1</Abstract>
<FormalSpec>pContext:%ZHSLIB.Context.Manager</FormalSpec>
</Method>
</Class>


<Class name="%ZHSLIB.Context.Manager">
<IncludeCode>%ZHSLIB</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeChanged>67214,49066.6808624</TimeChanged>
<TimeCreated>67214,49066.6808624</TimeCreated>

<Parameter name="ContextNode">
<Type>%String</Type>
<Default>^|"HSLIB"|HSContext</Default>
</Parameter>

<Parameter name="HealthShareContextClass">
<Type>%String</Type>
<Default>%SYSTEM.Context.HealthShare.Manager</Default>
</Parameter>

<Parameter name="HealthShareContextPropName">
<Type>%String</Type>
<Default>HSContext</Default>
</Parameter>

<Property name="Services">
<Description>
Services available for this process, subscripted by service name and version (and, optionally, namespace)</Description>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="NamedInstances">
<Description>
Non-singleton services registered for this process, subscripted by instance-key and namespace.</Description>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="InitializedNamespaces">
<Description>
Array of namespace names for which services have been initialized</Description>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="UpdateIndex">
<Description>
Time at which this instance had the latest version of services available</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
<Private>1</Private>
</Property>

<UDLText name="T">
<Content><![CDATA[
/*
 * Getter and setter methods for private variables
 * ONLY needed to enable unit testing
 */
]]></Content>
</UDLText>

<Method name="GetServices">
<FormalSpec>*pServices</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	Kill pServices
	Merge pServices = ..Services
]]></Implementation>
</Method>

<Method name="SetServices">
<FormalSpec><![CDATA[&pServices]]></FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	Kill ..Services
	Merge ..Services = pServices
]]></Implementation>
</Method>

<Method name="GetInitializedNamespaces">
<FormalSpec>*pInitializedNamespaces</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	Kill pInitializedNamespaces
	Merge pInitializedNamespaces = ..InitializedNamespaces
]]></Implementation>
</Method>

<Method name="SetInitializedNamespaces">
<FormalSpec><![CDATA[&pInitializedNamespaces]]></FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	Kill ..InitializedNamespaces
	Merge ..InitializedNamespaces = pInitializedNamespaces
]]></Implementation>
</Method>

<Method name="GetUpdateIndex">
<Private>1</Private>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[	Return ..UpdateIndex
]]></Implementation>
</Method>

<Method name="SetUpdateIndex">
<FormalSpec>pUpdateIndex:%Integer</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[	Set ..UpdateIndex = pUpdateIndex
]]></Implementation>
</Method>

<Method name="%OnNew">
<Description>
Starts all services defined in the current namespace</Description>
<Final>1</Final>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set ..UpdateIndex = $Get(@..#ContextNode@("UpdateIndex"), 0)
	Try {
		Kill ..Services
		Kill ..InitializedNamespaces
		Do ..Initialize()
	} Catch ex {
		Do ex.Log()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="Initialize">
<Description>
Initializes services for the current namespace</Description>
<Private>1</Private>
<Implementation><![CDATA[
	// Get all subclasses of %ZHSLIB.Context.InitializerBase
	Set tResultSet = ##class(%SQL.Statement).%ExecDirect(,"Select ID from %Dictionary.ClassDefinition WHERE Super [ '%ZHSLIB.Context.InitializerBase' AND Abstract = 0")
	$$$ThrowSQLIfError(tResultSet.%SQLCODE,tResultSet.%Message)
	
	Set tStartSC = $$$OK
	
	// Create new instances of services found in tResultSet, add to local array and start them
	While tResultSet.%Next(.tSC) {
		$$$ThrowOnError(tSC)
		Set tClassName = tResultSet.ID
		Set tService = $ClassMethod(tClassName, "%New")
		Try {
			// NOTE: Property Services is initialized in OnStart by calling RegisterService
			Do tService.OnStart($This)
		} Catch e {
			Set tStartSC = $$$ADDSC(tStartSC,e.AsStatus())
		}
	}
	$$$ThrowOnError(tSC)
	
	// Even if an error occurred starting a service, treat namespace as initialized (to avoid significant performance impact)
	Set ..InitializedNamespaces($Namespace) = ""
	$$$ThrowOnError(tStartSC)
]]></Implementation>
</Method>

<Method name="Instance">
<Description>
Returns the per-process instance of this class</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%ZHSLIB.Context.Manager</ReturnType>
<Implementation><![CDATA[	Quit ##class(%SYSTEM.Context)."HealthShare.Manager"().HSContext
]]></Implementation>
</Method>

<Method name="RegisterNamedInstance">
<Description><![CDATA[
Named Instances are non-singleton instances of a service within a namespace.  This supports multiple instances of the same service
with different configurations running in the same namespace.  <class>HS.FHIRService.Service</class> is an example as a single namespace can support
multiple FHIR endpoints with different FHIR versions.]]></Description>
<FormalSpec>pServiceInstance:%ZHSLIB.Context.NamedInstanceBase,pInstanceKey:%String,pNamespace:%String=$Namespace</FormalSpec>
<Implementation><![CDATA[
	// Hold onto the provided service instance.
	Set ..NamedInstances(pNamespace, pInstanceKey) = pServiceInstance
]]></Implementation>
</Method>

<Method name="FindNamedInstance">
<Description><![CDATA[
Named Instances are non-singleton instances of a service within a namespace.  This supports multiple instances of the same service
with different configurations running in the same namespace.  <class>HS.FHIRService.Service</class> is an example as a single namespace can support
multiple FHIR endpoints with different FHIR versions.]]></Description>
<FormalSpec>pInstanceKey:%String,pNamespace:%String=$Namespace</FormalSpec>
<ReturnType>%ZHSLIB.Context.NamedInstanceBase</ReturnType>
<Implementation><![CDATA[
	// Return the instance that we are holding (if any)
	Set instance = $Get(..NamedInstances(pNamespace, pInstanceKey))
	if $IsObject(instance) && 'instance.%IsLatest() {
		// Unless the instance has been recompiled, in which case we treat it
		// as unregistered.
		Kill ..NamedInstances(pNamespace, pInstanceKey)
		Set instance = ""
	}
	Return instance
]]></Implementation>
</Method>

<Method name="RegisterService">
<Description><![CDATA[
Adds a service to the Service property using the ServiceKey and ServiceVersion in <var>pServiceInstance</var>.
May be namespace-specific (if <var>pNamespace</var> is specified), or instance-wide (if not).]]></Description>
<FormalSpec>pServiceInstance:%ZHSLIB.Context.ServiceBase,pNamespace:%String=""</FormalSpec>
<Implementation><![CDATA[
	If (pNamespace = "") {
		Set ..Services(pServiceInstance.#ServiceKey, pServiceInstance.#ServiceVersion) = pServiceInstance
	} Else {
		Set ..Services(pServiceInstance.#ServiceKey, pServiceInstance.#ServiceVersion, pNamespace) = pServiceInstance
	}
]]></Implementation>
</Method>

<Method name="CheckForService">
<Description><![CDATA[
Internal helper method for <method>GetService</method>. Returns a service matching
the provided parameters if found. If not, returns null oref.]]></Description>
<FormalSpec>pServiceKey:%String,pMajorVersion:%Integer,pMinimumMinorVersion:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%ZHSLIB.Context.ServiceBase</ReturnType>
<Implementation><![CDATA[
	#dim service As %ZHSLIB.Context.ServiceBase = $$$NULLOREF
	Set sc = $$$OK
	Try {
		If ..UpdateIndex '= $Get(@..#ContextNode@("UpdateIndex"), 0) {
			Do ..Update()
		}
		If '$Data(..InitializedNamespaces($Namespace)) {
			Try {
				Do ..Initialize()
			} Catch e {
				Do e.Log()
			}
		}
		
		// Iterate through namespace specific services looking for the highest versioned valid service
		Set version = ""
		While 1 {
			Set version = $Order(..Services(pServiceKey, version), -1)
			If (version = "") {
				Quit
			}
			// Get namespace specific service
			Set service = $Get(..Services(pServiceKey, version, $Namespace))
			If '$IsObject(service) {
				Continue
			}
			Do ..ExtractMajorMinorVersion(version, .majorVersion, .minorVersion)
			If (majorVersion = pMajorVersion) && (minorVersion >= pMinimumMinorVersion) {
				Quit
			}
			// Clear out service if it does not match criteria
			Set service = $$$NULLOREF
		}
		If $IsObject(service) {
			Quit
		}
		// No namespace specific service found so look through globallly available services
		Set version = ""
		While 1 {
			Set version = $Order(..Services(pServiceKey, version), -1)
			If (version = "") {
				Quit
			}
			// Get global service
			Set service = $Get(..Services(pServiceKey, version))
			If '$IsObject(service) {
				Continue
			}
			Do ..ExtractMajorMinorVersion(version, .majorVersion, .minorVersion)
			If (majorVersion = pMajorVersion) && (minorVersion >= pMinimumMinorVersion) {
				Quit
			}
		}
	} Catch ex {
		// TODO: Should have a specific error code for this!
		Set outerStatus = $$$ServiceNotAvailable(pServiceKey, pMajorVersion, pMinimumMinorVersion)
		Set reasonStatus = ex.AsStatus()
		Set sc = $$$EMBEDSC(outerStatus, reasonStatus)
	}
	$$$ThrowOnError(sc)
	Return service
]]></Implementation>
</Method>

<Method name="GetService">
<Description><![CDATA[
Returns a per-process service instance matching the following parameters:
<ul>
<li> Service key = composite key built from <var>pServiceKey</var> and <var>pInstanceName</var> </li>
<li> Service major version = <var>pMajorVersion</var> </li>
<li> Service minor version >= <var>pMinimumMinorVersion </li>
<li> Service patch version = latest available </li>
</ul>
Throws an error if no service matching the above conditions is found.]]></Description>
<FormalSpec>pServiceKey:%String,pMajorVersion:%Integer,UNUSED="",pMinimumMinorVersion:%Integer=0</FormalSpec>
<ReturnType>%ZHSLIB.Context.ServiceBase</ReturnType>
<Implementation><![CDATA[
	Set service = ..CheckForService(pServiceKey, pMajorVersion, pMinimumMinorVersion)
	If (service = "") {
		$$$ThrowStatus($$$ServiceNotFound(pServiceKey, pMajorVersion, pMinimumMinorVersion))		
	}
	Quit service
]]></Implementation>
</Method>

<Method name="Update">
<Description>
For Development Only. Creates a new Manager and installs into the HealthShare context object.  
This is intended for development and testing of this class which is typically instantiated at instance startup.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	// Need to have If instead of Do because Do $Increment is not supported until IRIS 2018.2.0
	If $Increment(@..#ContextNode@("UpdateIndex"))
	Set tInstance = ..%New()
	Try {
		Set ##class(%SYSTEM.Context)."HealthShare.Manager"().HSContext = tInstance
	} Catch ex {
		Write "Must run Bootstrap First: "_$System.Status.GetErrorText(ex.AsStatus()),!
	}
]]></Implementation>
</Method>

<Method name="BootstrapMappings">
<Description>
Create package mappings for %SYSTEM.Context.HealthShare.* in %ALL</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pMapFromDatabase:%String="HSLIB"</FormalSpec>
<Implementation><![CDATA[
	New $Namespace
	Set $Namespace = "%SYS"
	// If %ALL namespace exists, mappings defined for the %ALL namespace automatically apply to all namespaces
	// Create %ALL namespace if it doesn't already exist
	If '##class(Config.Namespaces).Exists("%ALL") {
		// tDefaultProps initialization is taken from the Management Portal
		Set tDefaultProps("Globals") = "%DEFAULTDB"
		Set tDefaultProps("Routines") = "%DEFAULTDB"
		Set tDefaultProps("Library") = "IRISLIB"
		Set tDefaultProps("SysGlobals") = "IRISSYS"
		Set tDefaultProps("SysRoutines") = "IRISSYS"
		Set tDefaultProps("TempGlobals") = "IRISTEMP"
		$$$ThrowOnError(##class(Config.Namespaces).Create("%ALL", .tDefaultProps))
	}
	// Switch namespace in order to call %IPM class from a non-%SYS namespace which contains %IPM mapping
	Set $Namespace = pMapFromDatabase
	// This package mapping enables any namespace to access %SYSTEM.Context.HealthShare.* from the pMapFromDatabase database
	$$$ThrowOnError(##class(%IPM.Utils.Module).AddPackageMapping("%ALL", $Piece(..#HealthShareContextClass,".",1,*-1), pMapFromDatabase))
]]></Implementation>
</Method>

<Method name="ExtractMajorMinorVersion">
<Description>
Use IPM SemanticVersion utility to extract major and minor version info from a version string
Implement in its own helper method so as to execute namespace switch to ensure %IPM classes are available</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pVersionString:%String,*pMajor,*pMinor</FormalSpec>
<Implementation><![CDATA[
	// Switch to HSSYS to make sure %IPM classes are presented
	New $Namespace
	Set $Namespace = "HSSYS"
	#dim versionObj As %IPM.General.SemanticVersion
	Set versionObj = ##class(%IPM.General.SemanticVersion).FromString(pVersionString)
	Set pMajor = versionObj.Major
	Set pMinor = versionObj.Minor
]]></Implementation>
</Method>
</Class>


<Class name="%ZHSLIB.Context.NamedInstanceBase">
<Abstract>1</Abstract>
<Super>%RegisteredObject</Super>
<TimeChanged>67214,49066.681558</TimeChanged>
<TimeCreated>67214,49066.681558</TimeCreated>

<Parameter name="Global">
<Type>%String</Type>
<Final>1</Final>
<Default>^IRIS.Temp.ZHSLIB.NamedInstance</Default>
</Parameter>

<Property name="InstanceKey">
<Description>
The 'instance key' used to acquire this instance object</Description>
<Type>%String</Type>
</Property>

<Property name="%InstanceKey">
<Description>
The 'instance key' used to acquire this instance object</Description>
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="%instantiation">
<Type>%Integer</Type>
<Private>1</Private>
</Property>

<Method name="%OnNew">
<FormalSpec>pKey:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set ..%InstanceKey = pKey
	//Ensure the instantiation node is always defined. This gives us
	//a record of which keys have been accessed and may have a
	//service instance cached.
	if '$data(@..#Global@($namespace, ..fullKey(pKey), "instantiation")) {
		set @..#Global@($namespace, ..fullKey(pKey), "instantiation") = 0
	}
	Set ..%instantiation = @..#Global@($namespace, ..fullKey(pKey), "instantiation")
	return $$$OK
]]></Implementation>
</Method>

<Method name="%IsLatest">
<Description>
This method deprecated but still called from the Context Manager.</Description>
<Final>1</Final>
<Internal>1</Internal>
<Deprecated>1</Deprecated>
<CodeMode>expression</CodeMode>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[1
]]></Implementation>
</Method>

<Method name="InstanceKeyGet">
<Description>
Implement Get for the Calculated 'Instance' property</Description>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[..%InstanceKey
]]></Implementation>
</Method>

<Method name="CreateInstance">
<Description>
This abstract method MUST be implemented by a subclass.  It must create and initialize
an instance based on the specified key (usually a key to the configuration data).</Description>
<Internal>1</Internal>
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec>pKey:%String</FormalSpec>
<ReturnType>%ZHSLIB.Context.NamedInstanceBase</ReturnType>
</Method>

<Method name="EnsureInstance">
<Description>
This method is called to acquire a specific Named instance of a service.  The service
instance may have been previously registered with the Context using RegisterNamedInstance.
First the Context object is called to attempt to acquire a previously registered instance. If
the instance is present and its class has not be re-compiled since it was registered, then the
registered instance is returned.  Otherwise, the subclass implementation of CreateInstance is
called to acquire and register an instance.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pKey:%String</FormalSpec>
<ReturnType>%ZHSLIB.Context.NamedInstanceBase</ReturnType>
<Implementation><![CDATA[
	#dim contextMgr As %ZHSLIB.Context.Manager = ##class(%ZHSLIB.Context.Manager).Instance()
	
	Set fullKey = ..fullKey(pKey)
	Set instance = contextMgr.FindNamedInstance(fullKey)
	if $Get(@..#Global@($namespace, fullKey, "debug")) {
		// Kill any old instance
		Do contextMgr.RegisterNamedInstance("", fullKey)
		// Always create a new instance
		Set instance = ..CreateInstance(pKey)
	} else {
		if $IsObject(instance) {
			if ($Get(@..#Global@($namespace, fullKey, "instantiation")) '= instance.%instantiation) {
				// Kill any old instance before creating the new instance to ensure that its %OnClose is
				// invoked.  This is subtle, but if the old instance is holding a stale, open persistent object, any %OpenId
				// in the new instance will use the cached instance and not get new data from the database unless
				// the old instance has been closed.
				Do contextMgr.RegisterNamedInstance("", fullKey)
				Set instance = ""
			}
		}
		if '$IsObject(instance) {
			// Have the sub-class create and initialize the instance
			Set instance = ..CreateInstance(pKey)
			Do contextMgr.RegisterNamedInstance(instance, fullKey)
		}
	}	
	return instance
]]></Implementation>
</Method>

<Method name="SetDebugMode">
<Description>
This method provides control of debug mode.  When in debug mode, the EnsureInstance
method will always force a CreateInstance.  This is useful during the development of a service, 
but adds overhead in production because the service instance is created and initialized on each
request. </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pKey:%String,newMode:%Boolean</FormalSpec>
<Implementation><![CDATA[
	Set fullKey = ..fullKey(pKey)
	if $D(@..#Global@($namespace, fullKey, "debug")) '= (newMode = 1) {
		// Mode is changing
		if newMode {
			// Enter Debug Mode
			Set @..#Global@($namespace, fullKey, "debug") = 1
			Set fullKey = ..%ClassName(1) _ "|" _ pKey
		} else {
			kill @..#Global@($namespace, fullKey, "debug")
		}
		Do ..InvalidateInstances(pKey)
	}
]]></Implementation>
</Method>

<Method name="InvalidateInstances">
<Description>
Calling this method ensures that the next time EnsureInstance is called, a new service
will be instantiated and initialized.  Call this method after changing settings that the
service caches in order to have the setting take effect.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pKey:%String</FormalSpec>
<Implementation><![CDATA[
	#dim contextMgr As %ZHSLIB.Context.Manager = ##class(%ZHSLIB.Context.Manager).Instance()
	do $I(@..#Global@($namespace, ..fullKey(pKey), "instantiation"))
	Do contextMgr.RegisterNamedInstance("", ..fullKey(pKey))
]]></Implementation>
</Method>

<Method name="InvalidateAllInstances">
<Description>
This method will ensure that, for all named instances registered with this class, a new
service will be instantiated and initialized the next time EnsureInstance is called.
This may be used after making changes which affect all keys registed from a class, rather
than just a single key (which could use the InvalidateInstances method).</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	set fullKey = ""
	for {
		//This global will contain an instantiation node for every
		//key that has been instantiated.
		set fullKey = $order(@..#Global@($namespace, fullKey))
		quit:fullKey=""
		
		set className = $piece(fullKey, "|", 1)
		set key = $piece(fullKey, "|", 2, *)
		
		if className = ..%ClassName(1) {
			do ..InvalidateInstances(key)
		}
	}
]]></Implementation>
</Method>

<Method name="fullKey">
<ClassMethod>1</ClassMethod>
<FormalSpec>pKey:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	return ..%ClassName(1) _ "|" _ pKey
]]></Implementation>
</Method>

<Method name="%%CheckSubClassValidity">
<Description>
Ensure non-abstract subclasses have abstract parameters defined correctly</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<ForceGenerate>1</ForceGenerate>
<Implementation><![CDATA[
	Set sc = ##class(%ZHSLIB.CodeGenUtils.VerifyAbstractMembersDefined).CheckCompiledClassValidityAgainstAbstractClass(%compiledclass, "%ZHSLIB.Context.NamedInstanceBase")
	$$$ThrowOnError(sc)
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%ZHSLIB.Context.ServiceBase">
<Description>
This is a base class for a HealthShare Service. A Service is a singleton
object that is instantiated when a HealthShare Instance is started.
@API.Extensible
@Modifier	Availability	InterSystems</Description>
<Abstract>1</Abstract>
<IncludeCode>%occKeyword,%occReference</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeChanged>67214,49066.7118067</TimeChanged>
<TimeCreated>67214,49066.7118067</TimeCreated>

<Parameter name="ServiceKey">
<Description><![CDATA[
The unique key for the service (e.g. classname). <br />
@API.Overrideable]]></Description>
<Type>STRING</Type>
<Abstract>1</Abstract>
</Parameter>

<Parameter name="ServiceVersion">
<Description><![CDATA[
Semantic version of the Service. Must be a version string with the following format:
<major>.<minor>.<patch>
@API.Overrideable]]></Description>
<Type>STRING</Type>
<Abstract>1</Abstract>
</Parameter>

<Parameter name="CheckValidityOfSubclassMethodSignatures">
<Description>
Can be overridden to indicate that overridden methods in subclasses will have
their signatures checked to verify that they are compatible with the
corresponding signatures of the base methods defined in the current class.
@API.Overrideable</Description>
<Type>BOOLEAN</Type>
<Default>0</Default>
</Parameter>

<Method name="Instance">
<Description><![CDATA[
Returns the singleton service to use for this instance. The service returned will be
have the same major version as that in <parameter>ServiceVersion</parameter>. The
latest minor and patch version available for the service will be returned.
If <var>pMinimumMinorVersion</var> is provided, then a service is returned only if
one is found with at least the provided minor version.
Throws errors if service not found. <br />]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pMinimumMinorVersion:%Integer=0</FormalSpec>
<ReturnType>%ZHSLIB.Context.ServiceBase</ReturnType>
<Implementation><![CDATA[
	Do ##class(%ZHSLIB.Context.Manager).ExtractMajorMinorVersion(..#ServiceVersion, .majorVersion, .minorVersion)
	Quit ##class(%ZHSLIB.Context.Manager).Instance().GetService(..#ServiceKey, majorVersion, , pMinimumMinorVersion)
]]></Implementation>
</Method>

<Method name="%%CheckSubClassValidity">
<Description>
Ensure non-abstract subclasses have abstract parameters defined correctly</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<ForceGenerate>1</ForceGenerate>
<Implementation><![CDATA[
	// If service version is abstract, no need to check validity
	Set serviceVersionName = "ServiceVersion"
	If $$$comMemberKeyGet(%class.Name, $$$cCLASSparameter, serviceVersionName, $$$cPARAMabstract) {
		Quit $$$OK
	}
	Set sc = ##class(%ZHSLIB.CodeGenUtils.VerifyAbstractMembersDefined).CheckCompiledClassValidityAgainstAbstractClass(%compiledclass, "%ZHSLIB.Context.ServiceBase")
	$$$ThrowOnError(sc)
	Set serviceVersion = $Get(%parameter(serviceVersionName))
	Set sc = ##class(%IPM.General.SemanticVersion).IsValid(serviceVersion)
	$$$ThrowOnError(sc)
	Set checkSubclassSignatures = $Get(%parameter("CheckValidityOfSubclassMethodSignatures"), 0)
	If 'checkSubclassSignatures {
		Quit $$$OK
	}

	// Find all sub-classes of current class
	#dim statement As %SQL.Statement
	Set statement = ##class(%SQL.Statement).%New()
	Set sc = statement.%PrepareClassQuery("%Dictionary.ClassDefinition", "SubclassOf")
	$$$ThrowOnError(sc)
	#dim resultSet As %SQL.StatementResult
	Set resultSet = statement.%Execute(%class.Name)
	If resultSet.%SQLCODE < 0 {
		Throw ##class(%Exception.SQL).CreateFromSQLCODE(resultSet.%SQLCODE, resultSet.%Message)
	}

	While resultSet.%Next(.sc) {
		$$$ThrowOnError(sc)
		Set subclass = resultSet.%Get("Name")
		// For each method defined in this class, check if defined in subclass.
		// If defined, do method signature validation
		Set methodName = ""
		While 1 {
			Set methodName = $$$defMemberNext(%class.Name, $$$cCLASSmethod, methodName)
			If (methodName = "") {
				Quit
			}
			If $$$defMemberDefined(subclass, $$$cCLASSmethod, methodName) {
				Set methodSign = $ListFromString($$$defMemberKeyGet(%class.Name, $$$cCLASSmethod, methodName, $$$cMETHformalspec),",")
				Set subclassMethodSign = $ListFromString($$$defMemberKeyGet(subclass, $$$cCLASSmethod, methodName, $$$cMETHformalspec),",")
				Set ptr = 0
				For i = 1:1:$ListLength(methodSign) {
					Set param = $ListGet(methodSign,i)
					Set subParam = $ListGet(subclassMethodSign,i)
					Set type = $Piece(param, ":", 2)
					Set subType = $Piece(subParam, ":", 2)
					If (type = subType) || ($System.CLS.IsMthd(subType, "%Extends") && $ClassMethod(subType, "%Extends", type)) {
						// Valid
						Continue
					}
					Return $$$ERROR($$$GeneralError,"Subclass "_$$$QUOTE(subclass)_" method "_$$$QUOTE(methodName)_" has signature which does not match parent class "_$$$QUOTE(%class.Name))
				}
			}
		}
	}
	$$$ThrowOnError(sc)
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Routine name="%ZHSLIB.Formatting" type="INC" timestamp="67214,49066.3573054"><![CDATA[
#; Contains utility macros for formatting lines printed to Terminal

/// Returns a line with given formatting, clearing the formatting at the end of the line
#define FormattedLine(%formatCode, %line) $$$ControlSequence(%formatCode)_%line_$$$ControlSequence($$$ResetAll)

/// Creates the control sequence for the formatting based on the code
#define ControlSequence(%code) $Char(27)_"["_%code_"m"

#; Codes to add to convert format types
#define Reset 20
#define Background 10

#; All font formats (bold, underline etc.)
#define Bold 1
#define Bright 1
#define Dim 2
#define Underlined 4
#define Blink 5
#define Reverse 7
#define Hidden 8

#; All font format resets
#define ResetAll 0
#define ResetFontFormat(%format) ($$$Reset + %format)

#; Text colour conversions
#define BackgroundColor(%fgColor) ($$$Background + %fgColor)

#; All text colors in foreground
#define Default 39
#define Black 30
#define Red 31
#define Green 32
#define Yellow 33
#define Blue 34
#define Magenta 35
#define Cyan 36
#define White 97
]]></Routine>


<Class name="%ZHSLIB.HealthShareMgr">
<IncludeCode>%ZHSLIB,%occErrors</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Library.EnsembleMgr</Super>
<System>4</System>
<TimeChanged>67214,49066.6800953</TimeChanged>
<TimeCreated>67214,49066.6800953</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
/*
 * NOTE: If a new component (library) database is to be added to HealthShare, the ONLY updates required in
 * this class are in the LibraryDatabaseMetadata block. Instructions to edit this block:
 * Add a new key with the name of the library database
 * The value of the key MUST be an object with the following fields:
 * - LicenseName: Name used in license keys to refer to access to the component
 * - ModuleName: Name of the component module in the module.xml file for the component
 * - VersionStringName: Name of the component in the version string (displayed by the VersionInfo method in this class)
 * - BuildSpecName: Name of the component as it appears in the componentmap in a build spec
 * The new key MUST be placed last unless the database should be built before one of the other databases already present
 * The sequence of keys in the XData block is very important as it is used to determine the sequence in which
 * databases are initialized when there are multiple library databases in a single kit.
 */
]]></Content>
</UDLText>

<XData name="LibraryDatabaseMetadata">
<Description>
Keep track of metadata for each library database</Description>
<Internal>1</Internal>
<MimeType>application/json</MimeType>
<Data><![CDATA[
{
	"HSLIB":{
		"LicenseName": "",
		"ModuleName": "HSBASE",
		"VersionStringName": "Core",
		"BuildSpecName": "HSCore"
	},
	"VIEWERLIB":{
		"LicenseName": "Clinician Viewer",
		"ModuleName": "HSViewer",
		"VersionStringName": "Clinical Viewer",
		"BuildSpecName": "HSViewer"
	},
	"HSPILIB":{
		"LicenseName": "Patient Index",
		"ModuleName": "HSPI",
		"VersionStringName": "Patient Index",
		"BuildSpecName": "HSPI"
	},
	"HSAALIB":{
		"LicenseName": "Active Analytics",
		"ModuleName": "HSAA",
		"VersionStringName": "Health Insight",
		"BuildSpecName": "HSAA"
	},
	"HSPDLIB":{
		"LicenseName": "Provider Directory",
		"ModuleName": "HSProviderDirectory",
		"VersionStringName": "Provider Directory",
		"BuildSpecName": "HSPD"
	},
	"HSCOMMLIB":{
		"LicenseName": "Personal Community",
		"ModuleName": "HSPersonalCommunity",
		"VersionStringName": "Community Portal",
		"BuildSpecName": "HSCommunity"
	},
	"HSCMLIB":{
		"LicenseName": "Care Community",
		"ModuleName": "HSCC",
		"VersionStringName": "Care Community",
		"BuildSpecName": "HSCM"
	},
	"HSEDSLIB":{
		"LicenseName": "Healthcare Action Engine",
		"ModuleName": "HSDecisionSupport",
		"VersionStringName": "Healthcare Action Engine",
		"BuildSpecName": "HSEDS"
	}
}
]]></Data>
</XData>

<Method name="PreInstallSetup">
<Description>
Called during installation %Library.EnsembleMgr (Install)</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	try {
		Do ##class(%SYS.System).WriteToConsoleLog("Setting Routine Cache to 300")
		Set tSC=$$$OK
		New $namespace
		Set $namespace="%SYS"
		//bump routine cache for new installs
		Set tConfig=##Class(Config.config).Open()
		Set tConfig.routines=300
		Do tConfig.%Save()
		Do ##class(%SYS.System).WriteToConsoleLog("Routine Cache Set to 300 OK")
	} Catch ex {
		Set tSC=ex.AsStatus()
		Do ##class(%SYS.System).WriteToConsoleLog("Error Setting Routine Cache to 300: "_$system.Status.GetErrorText(tSC))
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="PreUpgradeSetup">
<Description><![CDATA[
Called during installation %Library.EnsembleMgr (Install)
Writes errors to console log. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	/*
	 * On upgrade check if any library databases had their corresponding namespaces
	 * Ensemble enabled. If so, disable them.
	 */
		
	// Remove ensemble definition but leave mappings
	
	Set isHsInstance = ..IsHealthShareInstance()
	// On HS, can have many LIB databases per kit. In HC/I4H, only have HSLIB
	Set databasesInKitList = $Case(isHsInstance, 1: ..GetDatabasesInKit(), : $ListBuild("HSLIB"))
	Set ptr = 0
	While $ListNext(databasesInKitList,ptr,db) {
		Do ##class(%Library.EnsembleMgr).DisableNamespace(db,1)
	}
	Do ##class(%Library.EnsembleMgr).DisableNamespace("HSSYS",1,1)
	Do ##class(%Library.EnsembleMgr).DisableNamespace("HSCUSTOM",1)

	// Only needs to run on HS (which can have multiple library databases)
	If 'isHsInstance {
		Return
	}
	
	#def1arg WriteToConsoleLog(%args) Do ##class(%SYS.System).WriteToConsoleLog(%args)
	
	$$$WriteToConsoleLog("START: Checking for HealthShare namespaces that are Ensemble enabled")
	Try {
		New $Namespace
		Set $Namespace = "%SYS"
		
		Set hsDatabaseList = ..GetDatabaseList()
		Set ptr = 0
		While $ListNext(hsDatabaseList, ptr, database) {
			Try {
				// If not in kit, then disable
				If '$ListFind(databasesInKitList, database) {
					// Set existence to false
					Set $$$HSLibraryDatabaseExistsGlobal(database) = 0
					// Disable namespace
					If ##class(Config.Namespaces).Exists(database) {
						Set sc = ##class(%Library.EnsembleMgr).DisableNamespace(database)
						If $$$ISERR(sc) {
							Set outerStatus = $$$ERROR($$$GeneralError, "Failed to disable namespace "_database)
							$$$ThrowStatus($$$EMBEDSC(outerStatus, sc))
						}
						$$$WriteToConsoleLog("Disabled namespace: "_database)
					}
				}
			} Catch ex {
				$$$WriteToConsoleLog($System.Status.GetErrorText(ex.AsStatus()))
			}
		}
	} Catch ex {
		Set sc = ex.AsStatus()
		Set errorMessage = "The following unexpected errors occurred while attempting to delete non-existent library databases: "
		$$$WriteToConsoleLog(errorMessage_$System.Status.GetErrorText(sc), , 1)
	}
	$$$WriteToConsoleLog("END: Checking for HealthShare namespaces that are Ensemble enabled")
]]></Implementation>
</Method>

<Method name="GetDatabasesInKit">
<Description><![CDATA[
Returns list of databases that should be present in this instance (based on the type of kit). <br />
ONLY used on HealthShare instances. <br />
Writes to Console log. <br />
Throws errors. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ReturnType>%Library.List</ReturnType>
<Implementation><![CDATA[
	#def1arg WriteToConsoleLog(%args) Do ##class(%SYS.System).WriteToConsoleLog(%args)

	// Get ordered databases present on the current kit being installed
	// It is written to a file in build.MAC which is then copied to
	// <install dir>/dist/install/misc/component_list.txt during installation
	Set componentFilePath = ##class(%Library.File).NormalizeFilename($System.Util.InstallDirectory()_"dist/install/misc/component_list.txt")
	If '##class(%Library.File).Exists(componentFilePath) {
		$$$WriteToConsoleLog("No component_list.txt file found so no checking done")
		Return ""
	}
	
	// Get components present in the kit
	Set fileStream = ##class(%Stream.FileCharacter).%New()
	$$$ThrowOnError(fileStream.LinkToFile(componentFilePath))
	Set line = fileStream.ReadLine(, .sc)
	$$$ThrowOnError(sc)
	// Strip leading and trailing white space and control characters
	Set componentList = $ListFromString($ZConvert($ZStrip(line, "<>WC"), "L"), " ")
	$$$WriteToConsoleLog("HealthShare components present in this kit: "_line)
	
	// Get info on all possible components
	Do ..GetComponentArray(.componentArray)
	Set hsDatabaseList = ..GetDatabaseList()
	
	Set databasesInKitList = ""
	Set ptr = 0
	While $ListNext(hsDatabaseList, ptr, database) {
		Set componentForDatabase = $ZConvert($Get(componentArray($ZConvert(database, "U"), $$$SubscriptBuildSpec)), "L")
		If $ListFind(componentList, componentForDatabase) {
			Set databasesInKitList = databasesInKitList _ $ListBuild(database)
		}
	}
	Return databasesInKitList
]]></Implementation>
</Method>

<Method name="GetNamespacesOnInstance">
<Description><![CDATA[
Returns all namespaces found on this instance. <br />
Throws errors. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ReturnType>%Library.List</ReturnType>
<Implementation><![CDATA[
	New $Namespace
	Set $Namespace = "%SYS"
	#dim resultSet As %SQL.StatementResult
	Set resultSet = ..RunClassQuery("Config.Namespaces", "List")
	Set list = ""
	While resultSet.%Next(.sc) {
		$$$ThrowOnError(sc)
		Set list = list _ $ListBuild(resultSet.%Get("Namespace"))
	}
	$$$ThrowOnError(sc)
	Return list
]]></Implementation>
</Method>

<Method name="DeleteMappingsFromDatabaseForNamespace">
<Description><![CDATA[
Deletes any mappings present from the given database for the given namespace. <br />
Throws errors. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDatabase:%String,pNamespace:%String</FormalSpec>
<ReturnType>%Library.Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Try {
		If (pNamespace = pDatabase) {
			Quit
		}
		New $Namespace
		Set $Namespace = "%SYS"
		// All tables on which mappings need to be checked
		Set tableList = $ListBuild("Config.MapGlobals", "Config.MapRoutines", "Config.MapPackages")
		
		// Accumulate mappings to delete
		#dim mappingNameArray As %String
		// For each table obtain mappings and delete any that map from the provided database
		Set ptr = 0
		While $ListNext(tableList, ptr, table) {
			#dim resultSet As %SQL.StatementResult
			Set resultSet = ..RunClassQuery(table, "List", pNamespace)
			While resultSet.%Next(.sc) {
				$$$ThrowOnError(sc)
				Set mappingName = resultSet.%Get("Name")
				Set database = resultSet.%Get("Database")
				If (database = pDatabase) {
					Set mappingTableList = $ListBuild(table)
					If $Data(mappingNameArray(mappingName), existingMappingTableList)#2 {
						Set mappingTableList = mappingTableList _ existingMappingTableList
					}
					Set mappingNameArray(mappingName) = mappingTableList
				}
			}
			$$$ThrowOnError(sc)
		}
		
		// Iterate mappings in reverse order so that subscript mappings are removed before top level ones
		Set mappingName = ""
		While 1 {
			Set mappingName = $Order(mappingNameArray(mappingName), -1, tableList)
			If (mappingName = "") {
				Quit
			}
			Set ptr = 0
			While $ListNext(tableList, ptr, table) {
				Do ##class(%SYS.System).WriteToConsoleLog("Deleting mapping "_mappingName_" for namespace "_pNamespace_" from database "_pDatabase)
				$$$ThrowOnError($ClassMethod(table, "Delete", pNamespace, mappingName))
			}
		}
	} Catch ex {
		Set sc = ex.AsStatus()
	}
	Return sc
]]></Implementation>
</Method>

<Method name="RunClassQuery">
<Description><![CDATA[
Runs a class query using dynamic SQL and returns the result set. <br />
Throws errors. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClassname:%String,pQueryName:%String,pArguments...</FormalSpec>
<Private>1</Private>
<ReturnType>%SQL.StatementResult</ReturnType>
<Implementation><![CDATA[
	Set statement = ##class(%SQL.Statement).%New()
	$$$ThrowOnError(statement.%PrepareClassQuery(pClassname, pQueryName))
	#dim resultSet As %SQL.StatementResult
	Set resultSet = statement.%Execute(pArguments...)
	If (resultSet.%SQLCODE < 0) {
		Throw ##class(%Exception.SQL).CreateFromSQLCODE(resultSet.%SQLCODE, resultSet.%Message)
	}
	Return resultSet
]]></Implementation>
</Method>

<Method name="DeleteNonExistentLibraryDatabases">
<Description>
Checks which databases should be present on this instance based on the kit.
Deletes any databases that were present but should not be.
Also deletes corresponding namespaces.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<Private>1</Private>
<Implementation><![CDATA[
	#def1arg WriteToConsoleLog(%args) Do ##class(%SYS.System).WriteToConsoleLog(%args)
	
	// Only needs to run on HS (which can have multiple library databases)
	If '..IsHealthShareInstance() {
		Return
	}
	
	$$$WriteToConsoleLog("START: Checking for HealthShare component databases to delete")
	Try {
		New $Namespace
		Set $Namespace = "%SYS"
		
		Set databasesInKitList = ..GetDatabasesInKit()
		$$$WriteToConsoleLog("Databases in this kit: "_$ListToString(databasesInKitList, " "))
		Set hsDatabaseList = ..GetDatabaseList()
		Set ptr = 0
		While $ListNext(hsDatabaseList, ptr, database) {
			Set databaseDirectory = $$$HSLibraryDatabaseDirectory(database)
			If '$ListFind(databasesInKitList, database) && ##class(%Library.File).Exists(databaseDirectory) {
				// Have error handling here so that if one database isn't deleted correctly,
				// an attempt is still made to delete remaining.
				Try {
					// Iterate all existing namespaces to delete any mappings to this database
					Set namespaceList = ..GetNamespacesOnInstance()
					Set namespacePtr = 0
					While $ListNext(namespaceList, namespacePtr, namespace) {
						// Check if mappings exist to current database for this namespace
						Set sc = ..DeleteMappingsFromDatabaseForNamespace(database, namespace)
						If $$$ISERR(sc) {
							Set outerStatus = $$$ERROR($$$GeneralError, "Failed to delete mappings from database "_database_" for namespace "_namespace)
							$$$ThrowStatus($$$EMBEDSC(outerStatus, sc))
						}
					}
					$$$WriteToConsoleLog("Successfully removed all mappings to component library database: "_database)
					// Delete namespace definition and disable it
					Set sc = ##class(%ZHSLIB.Component.Utils).DeleteNamespace(database, 1)
					If $$$ISERR(sc) {
						Set outerStatus = $$$ERROR($$$GeneralError, "Failed to delete namespace "_database)
						$$$ThrowStatus($$$EMBEDSC(outerStatus, sc))
					}
					$$$WriteToConsoleLog("Successfully removed namespace for component library database: "_database)
					// Delete database definition once namespace deleted
					Set sc = ##class(%ZHSLIB.Component.Utils).DeleteDatabase(database, 1, 1)
					If $$$ISERR(sc) {
						Set outerStatus = $$$ERROR($$$GeneralError, "Failed to delete database "_database)
						$$$ThrowStatus($$$EMBEDSC(outerStatus, sc))
					}
					$$$WriteToConsoleLog("Successfully removed component library database: "_database)
				} Catch ex {
					$$$WriteToConsoleLog($System.Status.GetErrorText(ex.AsStatus()))
				}
			}
		}
	} Catch ex {
		Set sc = ex.AsStatus()
		Set errorMessage = "The following unexpected errors occurred while attempting to delete non-existent library databases: "
		$$$WriteToConsoleLog(errorMessage_$System.Status.GetErrorText(sc), , 1)
	}
	$$$WriteToConsoleLog("END: Checking for HealthShare component databases to delete")
]]></Implementation>
</Method>

<Method name="InitializeHealthShare">
<Description>
Initialize HealthShare</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pVerbose:%Boolean=0,pHSLib:%String=..#HSLIB,&pIsPrimary:%Boolean=1]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#ifndef REPORT
	#define REPORT(%l,%x) Write:pVerbose !,?%l,%x
	#endif
	Try {
		New $namespace
		Do ##class(%SYS.System).WriteToConsoleLog("Installation initialization sequence starting")
		#dim tSC As %Status = $$$OK
		// During ^INSTALL %Library.EnsembleMgr:Install is called which sets ^%SYS("HealthShare") in %SYS (global mappings are not in place at that time)
		// can't set into ^%SYS("HealthShare") on non primary mirror member - will cause protect error - on HealthConnect HSSYS may or may not be mirrored
		Set tSetHSSYS = 1
		If $system.Mirror.IsMember() && '$system.Mirror.IsPrimary() {
			Do ..findMirroredNamespaces(.tMirrored)
			Set tSetHSSYS = '$Data(tMirrored("HSSYS"))
		}
		Set tNsSYS="^^"_$System.Util.ManagerDirectory()
		Set tSysString = $G(^|tNsSYS|%SYS("HealthShare"))  
		Set sysIsUpgrade = +tSysString
		; %SYS("HealthShare") could be defined in two places, once in the %SYS namespace and once in the current namespace
		; If it's not defined here, or it looks like an upgrade in the %SYS namespace, copy it over
		if (tSetHSSYS && (('$D(^%SYS("HealthShare"))) || (sysIsUpgrade)) && $D(^|tNsSYS|%SYS("HealthShare")))
		{
			Set ^%SYS("HealthShare") = ^|tNsSYS|%SYS("HealthShare")
		}
		Set tIsUpgrade=+$G(^%SYS("HealthShare"))||sysIsUpgrade
		
		// Only for HealthShare which can have multiple component library databases
		If tIsUpgrade && ..IsHealthShareInstance() {
			// Delete component library databases that should no longer be on this instance post upgrade
			// before any database initialization (databases may not exist in the kit being upgraded to).
			Do ..DeleteNonExistentLibraryDatabases()
		}
		Set tSC = ..DefineLibraryDBs(pVerbose,tIsUpgrade)

		Quit:$$$ISERR(tSC)
		If tIsUpgrade {
			Set tSC = ..RemoveMPRLLIB()  /// for IRIS for Health / HealthConnect
			Set tSC = ..RemoveENSDEMO()  /// for IRIS for Health / HealthConnect
			Set tSC = ..TypeFoundationNamespaces() 
			If $$$ISERR(tSC) {
				$$$REPORT(6,"+ Failed to update Foundation Namespaces "_$system.Status.GetErrorText(tSC))
				Quit
			}
			Set tSC = ..UpdateXSLTFiles()
			If $$$ISERR(tSC) {
				$$$REPORT(6,"+ Failed to update XSLT files "_$system.Status.GetErrorText(tSC))
			} Else {
				$$$REPORT(6,"+ Updated XSLT files")
			}
		}
		Do ..SetJWTIssuer()
		If ..IsHealthShareInstance() {
			Do ..AddDelegated()
			Do ..UpdateSystemWebAppsAutheEnabled()
			Do:'tIsUpgrade ..MapZAUTHENTICATE(pHSLib,pVerbose)
			// Bootstrap $System.Context.HealthShare.Manager
			Do ##class(%ZHSLIB.Context.Manager).BootstrapMappings()
		} Else {
			Set tSC = ..UpdateComponentsVersion()
			If $$$ISERR(tSC) {
				$$$REPORT(6,"+ Failed to update Component Version "_$system.Status.GetErrorText(tSC))
			}
		}
		
		// Generate KitManager class
		Do ..GenerateHSKitManager()

		/// IRIS does not have ENSDEMO / ENSEMBLE namespaces
		If 'tIsUpgrade && ($zv'["IRIS") {
			For tItem="ENSDEMO","ENSEMBLE" { Set tSC = ..EnableHealthShareNamespace(tItem,pVerbose,pIsPrimary,1) }
		} 
		Quit:$$$ISERR(tSC)
		If tSetHSSYS { 
			Set $PIECE(^%SYS("HealthShare"),"^",3)=$ZDT($H,3)
		}
		
	} Catch ex {
		Set tSC = ex.AsStatus()
		Do ##class(%SYS.System).WriteToConsoleLog("Error: "_$system.Status.GetErrorText(tSC), , 2)
	}
	Do ##class(%SYS.System).WriteToConsoleLog("Installation initialization sequence complete "_$S($$$ISOK(tSC):"",1:"Error: "_$system.Status.GetErrorText(tSC)))
	Quit tSC
]]></Implementation>
</Method>

<Method name="RemoveMPRLLIB">
<Description>
Upgrades for HealthConnect / IRIS for Health </Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New $namespace
	Set $namespace="HSLIB"
	Set tSC = $$$OK
	/// For IRIS instances (IRIS for Health & 2019.1 HealthConnect
	Set database = "MPRLLIB"
	If (##class(%File).Exists($$$HSLibraryDatabaseDirectory(database)_$$$DatabaseFilename)) {
		Set tSC = ##class(HS.Util.SystemAPI).Invoke("DeleteDatabase",$zcvt(database,"l"),$zcvt(database,"l"))
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="RemoveENSDEMO">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	New $namespace
	Set $namespace="HSLIB"
	/// For IRIS instances (IRIS for Health & 2019.1 HealthConnect
	If ..InstanceType()'=$$$HSisHealthShare{
		If ##class(HS.Util.Installer.ConfigItem).%ExistsId("ENSDEMO") {
			d ##class(%Library.EnsembleMgr).DisableNamespace("ENSDEMO")
			d ##class(%Library.EnsembleMgr).DisableNamespace("SAMPLES")
		}
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="UpdateXSLTFiles">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	New $namespace
	Set $namespace="HSLIB"
	Set tSC = $classMethod("HS.HC.Util.Installer.Upgrade.XSLTDirectoryCopy","Update",1)
	Quit tSC
]]></Implementation>
</Method>

<Method name="UpdateComponentsVersion">
<Description>
for HealthConnect and IRISforHealth update the Version information</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	Set tSC = $$$OK
	try {
		New $namespace
		Set $namespace="HSLIB"
		Set tTypeName = $Case(..InstanceType(),$$$HSisHealthConnect:"HealthConnect",:"Health")
		Set tRS = ##class(%SQL.Statement).%ExecDirect(,"select VersionString from %IPM_Storage.ModuleItem WHERE NAME=?","HealthConnect")
		If 'tRS.%Next() {
			Set tSC = $$$ERROR($$$GeneralError,"Unable to locate HealthConnect version")
		} Else {
			/// if upgrading we want to remove the HealthConnect version, if not upgrading, it doesn't matter because we're replacing it 
 			Kill ^%SYS("Components","HealthConnect") //support change to IRIS for Health
 			Kill ^%SYS("Components","Health")  //support change IFH to HealthConnect
			Set ^%SYS("Components",tTypeName)=$lb(tTypeName_":"_tRS.VersionString)
		}
	} catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="TypeFoundationNamespaces">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New $namespace
	Set $Namespace="HSLIB"
	Set tSC = $$$OK
	try {
		Set tConfigItem=""
		For  {
			Set tConfigItem=$O(^%SYS("HealthShare","Instances",tConfigItem)) Quit:tConfigItem=""
			Continue:",ENSEMBLE,ENSDEMO,"[(","_tConfigItem_",")
			If $lg(^%SYS("HealthShare","Instances",tConfigItem))'="~HS.Util.Installer.Foundation~" Continue
			Set $namespace=tConfigItem
			Do ##class(Ens.Director).ParseConfigItemName("",.tProductionClass)
			Continue:tProductionClass="" 
			Set tProdRef=##class(Ens.Config.Production).%OpenId(tProductionClass)
			Continue:'$IsObject(tProdRef)
			For tIdx=1:1:tProdRef.Items.Count() {
				Set tItem=tProdRef.Items.GetAt(tIdx)
				If tItem.ClassName="HSPI.Server.APIWebService" {
					Do ##class(HS.Util.Installer.HSPILIB).MakeAType(tConfigItem)
					Quit
				}
				ElseIf tItem.ClassName="HSAA.TransferSDA3.WebServices" {
					Do ##class(HS.Util.Installer.HSAALIB).MakeAType(tConfigItem)
					Quit
				}
			}	
		}
	} catch ex {
		Set tSC=ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="IsHealthShareInstalled">
<Description>
Checks for HealthShare installation</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[$D(^%SYS("HealthShare"))>0
]]></Implementation>
</Method>

<Method name="CheckDBInstalled">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDB=""</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	// any privilege checking should go here
	Set tReturn = ..SecureCheckDBInstalled(pDB)
	Quit tReturn
]]></Implementation>
</Method>

<Method name="SecureCheckDBInstalled">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDB=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$AddAllRoleTemporary
	If pDB="" {
		#; check for installed after everything is installed / configured
		#; and store this information in %SYS
		Set tDatabaseList = ..GetDatabaseList()
		Set tPtr = 0
		While $ListNext(tDatabaseList, tPtr, tDatabase) {
			do ..SecureCheckDBInstalled(tDatabase)
		}
		Quit 1 ; completed check successfully
	}
	Set tReturn=$$switchNS(pDB)
	Try {
		Set $$$HSLibraryDatabaseExistsGlobal(pDB) = tReturn
	} Catch(ex) {
		//ok if set fails - it means we're on non-primary mirror member
	}
	Quit tReturn
switchNS(pDB)	///return 1 if database is installed, 0 otherwise
	Set tOK=1
	try {
		Set tDirectory = $$$HSLibraryDatabaseDirectory(pDB)
		/// Check to see that the database file exists before trying to change to it
		If '##class(%File).Exists(tDirectory_$$$DatabaseFilename) {
			Set tOK=0
			Quit
		}
		New $namespace
		ZN "^^"_tDirectory
	} catch {
		Set tOK=0 ; an exception means the database is not installed
	}	
	Quit tOK
]]></Implementation>
</Method>

<Method name="IsHealthShareNamespace">
<Description>
Checks if current namespace is HealthShare-enabled
Called by %Library.EnsembleMgr</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace=$namespace</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit ..SecureIsHealthShareNamespace(pNamespace)
]]></Implementation>
</Method>

<Method name="SecureIsHealthShareNamespace">
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace=$namespace</FormalSpec>
<Private>1</Private>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$AddAllRoleTemporary
	Try {
		New $Namespace
		Set $Namespace="HSSYS"
		Set tNS = $zconvert(pNamespace,"U")
		Set tIsHSNS = $select(tNS = "%SYS": 0, 1: ''$data(^%SYS("HealthShare","Instances",tNS)))
	}
	Catch {
		#; If the above check fails, the user doesn't have permission for the HealthShare ^oddCOM nodes in the specified namespace
		#; or, there's no HSSYS namespace, which means it isn't a HealthShare system
		Set tIsHSNS = 0
	}
	Quit tIsHSNS
]]></Implementation>
</Method>

<Method name="IsRunningAuditInstance">
<Description>
This is used at runtime to decide how we are going to audit - locally in the current namespace
(for Foundation), locally in the registry namespace for old configurations, locally in the HSAUDIT
database if either the registry instance is configured for audit or if we have an AuditRepository
configured, or otherwise remotely.
A non primary mirror member can't be the audit instance</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pAuditDB:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set pAuditDB=""
	If $system.Mirror.IsMember(),'$system.Mirror.IsPrimary() Quit 0
	Quit ..IsAuditInstance(.pAuditDB)
]]></Implementation>
</Method>

<Method name="IsAuditInstance">
<Description>
This is used as we are configuring audit database connections</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pAuditDB:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set pAuditDB=$G(^%SYS("HealthShare","AuditDB")) Quit:pAuditDB'="" 1
	//If the current namespace is a pure foundation one (and not a "foundation type" such as analytics)
	//then it is its own audit repository
	If $G(^%SYS("HealthShare","Instances",$namespace,"Type"))="Foundation" {
		Set tConfig=##Class(HS.Util.Installer.ConfigItem).%OpenId($namespace)
		If $IsObject(tConfig),$ClassName(tConfig)="HS.Util.Installer.Foundation" {
			Set pAuditDB=$namespace
			Quit 1
		}
	}
	Quit 0
]]></Implementation>
</Method>

<Method name="GetHealthShareNamespaceType">
<Description>
Returns Hub, EdgeGateway, etc., or null if the namespace is not a HealthShare component namespace</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace=$namespace</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit $G(^%SYS("HealthShare","Instances",pNamespace,"Type"))
]]></Implementation>
</Method>

<Method name="GetHealthShareNamespaceIsAllInOnePatientIndex">
<Description>
Returns true if the namespace contains an All-In-One Patient Index configuration</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace=$namespace</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit $G(^%SYS("HealthShare","Instances",pNamespace,"IsAllInOnePatientIndex"))
]]></Implementation>
</Method>

<Method name="DefineLibraryDBs">
<Description>
Define HSLIB / VIEWERLIB / HSPI/ HSPD / HSAA</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pVerbose:%Boolean,pIsUpgrade:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#ifndef REPORT
	#define REPORT(%l,%x) Write:pVerbose !,?%l,%x
	#endif

	New $Namespace
	Try {
		Set tSC = $$$OK
		If $Piece($Get(^%SYS("HealthShare")),"^",2)="HealthShare" {
			Set tDBList = ..GetDatabaseList()
		} Else {
			Set tDBList = $ListBuild(..#HSLIB)
		}
		If pIsUpgrade && $$$InAContainer {
			// Make database writeable on upgrade because map2enslib() in InstallComponent() tries to edit globals.
			// Make folder writeable before database.
			// TODO: Remove this once map2enslib() is fixed.
			Do ..SetLibDirsWriteable()
		}
		For tIdx = 1:1:$ListLength(tDBList) {
			Set tDB = $List(tDBList,tIdx)
			Continue:'##class(%File).DirectoryExists($$$HSLibraryDatabaseDirectory(tDB))
			Set tSC=$$$ADDSC(tSC,..InstallComponent(tDB,pVerbose,,pIsUpgrade))
			$$$REPORT(6,"+ Installed component "_tDB_$Select($$$ISERR(tSC):" Failed "_$System.Status.GetErrorText(tSC),1:" successfully"))
			Quit:$$$ISERR(tSC)
			/// Make LIB databases read-only.
			/// Put into a loop to try multiple times with wait, in case database is expanding
			For idx=1:1:10 {
				Try {
					Set tSC = $$$OK
					Do ##class(%ZHSLIB.HealthShareMgr).UpdateReadWrite(tDB,1)
					Quit
				} Catch ex {
					Set tSC = ex.AsStatus()
					Hang 15
				}
			}
			$$$ThrowOnError(tSC)
		}
		Quit:$$$ISERR(tSC)
		Set tSC = ..CheckDBInstalled("")
	} Catch ex {
		Set tSC = ex.AsStatus()	
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="SetLibDirsWriteable">
<Description><![CDATA[
Helper method to add write permission to /transient-root/mgr/hs*lib dirs <br />
Needed in the short term until we can stop needing to mount LIB databases R/W during instance
install/upgrade or namespace activation. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	Set dbList = ..GetDatabaseList()
	Set sc = $$$OK
	Set ptr = 0
	While $ListNext(dbList,ptr,db) {
		Set dir = $$$HSLibraryDatabaseDirectory(db)
		If ##class(%File).DirectoryExists(dir) && '##class(%File).Writeable(dir) {
			// only add write permission, so writeonly=0
			Set status = ##class(%File).SetWriteable(dir, 0, .return)
			If 'status {
				Set error = $$$ERROR($$$GeneralError, "Error when setting "_dir_" to be writeable. System Return Code: "_return)
				Set sc = $$$ADDSC(sc, error)
			} Else {
				Write !, "The following directory has been set writeable: "_dir
			}
		}
	}
	$$$ThrowOnError(sc)
]]></Implementation>
</Method>

<Method name="MapZAUTHENTICATE">
<Description>
map zauthenticate into HSLIB, but only on new Installs and only for HealthShare (not HealthConnect or IRIS for Health)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pHSLib,pVerbose</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New $namespace
	try {
		Set tSC=$$$OK
		/// no mapping if it's not healthshare (ie is HealthConnect or IRIS for Health)
		Quit:'..IsHealthShareInstance()
		Set $namespace="%SYS"
		Set tRtn="ZAUTHENTICATE"
		$$$REPORT(8,"+ Adding routine mapping "_tRtn_" -> "_pHSLib)
		If '##Class(Config.MapRoutines).Exists("%SYS",tRtn) {
			k p
			s p("Database")=pHSLib
			Set tSC = ##Class(Config.MapRoutines).Create("%SYS",tRtn,.p)
			If $$$ISERR(tSC) {
				$$$REPORT(0,"ERROR: Failed to create routine mapping for "_tRtn_" -> "_pHSLib_"\: "_$system.Status.GetErrorText(tSC))
				Quit
			}
		} Else {
			$$$REPORT(8,"+ Routine mapping "_tRtn_" already exists ... skipping")
		}
	} Catch ex {
		Set tSC = ex.AsStatus()	
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="LoadLocalizedMessages">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDB:%String,pVerbose:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#ifndef REPORT
	#define REPORT(%l,%x) Write:pVerbose !,?%l,%x
	#endif

	Set tSC=$$$OK
	try {
		Quit:$$$InAContainer
		Set tSC = ..UpdateReadWrite(pDB,0,.readOnly)
		// Load localized messages into the specified database
		$$$REPORT(6,"- Loading localized messages into "_pDB)
		New $Namespace
		Set tTo=$S($E(pDB)="^":pDB,1:"^^"_$$$HSLibraryDatabaseDirectory(pDB))
		Set $Namespace=tTo
		
		Set tRS = ##class(%ResultSet).%New("%File:FileSet")
		If '$IsObject(tRS) Set tSC = %objlasterror Quit
		
		Set tLocaleDir = $$$LOCALEPATH
		Set tSC = tRS.Execute(tLocaleDir,"allmessages"_pDB_"_*.xml")
		If $$$ISERR(tSC) Quit
		
		// Now, traverse the matching XML files
		While (tRS.Next()) {
			Set tFile = tRS.Data("Name")
			
			// Sanity checking on the filename (incl. ignoring the version separator ';' on VMS)
			If (tRS.Data("Type")'="F") || ($ZCVT($P($P(tFile,".",$L(tFile,".")),";"),"l")'="xml") Continue
			
			$$$REPORT(8,"+ Loading: "_tFile)
			
			// Load the messages
			Set tSC = $$Import^%occMsgXML(tFile)
			Do:$$$ISERR(tSC) $system.OBJ.DisplayError(tSC)
		}

		If readOnly {	
			Set tSC = ..UpdateReadWrite(pDB,1)
		}
		
		// We ignore any errors during loading, other than to report them.
		Set tSC = $$$OK
	} Catch ex {
		Set tSC = ex.AsStatus()	
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetComponentArray">
<Description><![CDATA[
Returns an array with information of the components in its subscripts by reading the 
LibraryDatabaseMetadata XData block in this class.
The structure of the array is the following: <br />
pComponentArray(&lt;database name&gt;, $$$SubscriptLicense) = &lt;LicenseName value&gt; <br />
pComponentArray(&lt;database name&gt;, $$$SubscriptBuildSpec) = &lt;BuildSpecName value&gt; <br />
pComponentArray(&lt;database name&gt;, $$$SubscriptModule) = &lt;ModuleName value&gt; <br />
pComponentArray(&lt;database name&gt;, $$$SubscriptVersionString) = &lt;VersionString value&gt; <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>*pComponentArray:%String</FormalSpec>
<Implementation><![CDATA[
	// Generate a line of code, prepended by a tab
	#define Generate(%line) Do %code.WriteLine($Char(9)_%line)
	Set xDataBlockName = "LibraryDatabaseMetadata"
	
	// Read the XData
	Set stream = $$$NULLOREF
	For i = 1:1:%compiledclass.XDatas.Count() {
		#dim xData As %Dictionary.XDataDefinition
		Set xData = %compiledclass.XDatas.GetAt(i)
		If (xData.Name = xDataBlockName) {
			Set stream = xData.Data
			Quit
		}
	}
	
	// Throw an error and Quit if stream is not an object
	If '$IsObject(stream) {
		$$$ThrowStatus($$$ERROR($$$GeneralError, "XData block "_$$$QUOTE(xDataBlockName)_" contents could not be read"))
	}
	// Kill the variable
	Set outputVariable = "pComponentArray"
	$$$Generate("Kill "_outputVariable)
	// Create a dynamic object that is populated with a stream of databases and its values
	#dim iter As %Iterator.Object
	Set obj = ##class(%Library.DynamicAbstractObject).%FromJSON(stream)
	Set iter = obj.%GetIterator()
	Set orderedDatabaseList = ""
	While iter.%GetNext(.key, .value) {
		Set orderedDatabaseList = orderedDatabaseList _ $ListBuild(key)
		$$$Generate("Set "_outputVariable_"("_$$$QUOTE(key)_", $$$SubscriptLicense) = "_$$$QUOTE(value.LicenseName))
		$$$Generate("Set "_outputVariable_"("_$$$QUOTE(key)_", $$$SubscriptModule) = "_$$$QUOTE(value.ModuleName))
		$$$Generate("Set "_outputVariable_"("_$$$QUOTE(key)_", $$$SubscriptVersionString) = "_$$$QUOTE(value.VersionStringName))
		$$$Generate("Set "_outputVariable_"("_$$$QUOTE(key)_", $$$SubscriptBuildSpec) = "_$$$QUOTE(value.BuildSpecName))
	}
	$$$Generate("Set "_outputVariable_" = "_##class(%Library.Utility).FormatString(orderedDatabaseList))
]]></Implementation>
</Method>

<Method name="GetDatabaseList">
<Description><![CDATA[
Returns a list of library database names available in HealthShare, ordered by the sequence in which they should
be initialized if multiple are present on a single instance. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ReturnType>%Library.List</ReturnType>
<Implementation><![CDATA[
	Do ..GetComponentArray(.componentArray)
	Return $Get(componentArray)
]]></Implementation>
</Method>

<Method name="GetReverseOrderedDatabaseList">
<Description><![CDATA[
Returns the database name list obtained from <method>GetDatabaseList<method>, returned in reverse order. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ReturnType>%Library.List</ReturnType>
<Implementation><![CDATA[
	Set orderedDatabaseList = ..GetDatabaseList()
	Set reverseDatabaseList = ""
	Set ptr = 0
	While $ListNext(orderedDatabaseList, ptr, database) {
		Set reverseDatabaseList = $ListBuild(database) _ reverseDatabaseList
	}
	Return reverseDatabaseList
]]></Implementation>
</Method>

<Method name="GetKitName">
<Description><![CDATA[
Returns the kit name by looking for it in the <ExternalName> element in the available component modules. <br />
@Argument	pAvailableDatabaseArray		Subscripted array who's keys are names of databases
that are available on the system (and licensed). Values are ignored.]]></Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pAvailableDatabaseArray]]></FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set externalProductName = ""
	// Parse databases in reverse order because the ones that should be initialized last
	// are the ones that are the primary components of their respective instances
	// (ex. in a Personal Community kit, HSCOMMLIB restrictions should override HSLIB restrictions)
	Set databaseList = ..GetReverseOrderedDatabaseList()
	Do ..GetComponentArray(.componentArray)

	// Role escalation to ensure ALL users can seen version info
	New $Roles
	Set $Roles = "%All"
	New $Namespace
	Set pointer = 0
	While $ListNext(databaseList, pointer, database) {
		// If database exists, check if module has external name
		If $Data(pAvailableDatabaseArray(database)) {
			Set moduleName = $Get(componentArray(database, $$$SubscriptModule))
			If (moduleName '= "") {
				Set initNamespace = $Namespace
				Set $Namespace = database
				// directly reference the module storage definition since the module class cannot be called in implied namespace
				Set module = ##class(%IPM.Storage.Module).NameOpen(moduleName, , .sc)
				If $$$ISOK(sc) {
					// Only assign if actually found
					Set externalName = module.ExternalName
					If (externalName '= "") {
						Set externalProductName = externalName
						Quit
					}
				}
				Set $Namespace = initNamespace
			}
		}
	}
	Return externalProductName
]]></Implementation>
</Method>

<Method name="VersionInfo">
<Description>
Return the version information for the core technology and all components installed
pMultiLine = 1 is used/parsed by %SYSTEM.Version, so we can't change its format</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pMultiLine=0</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set fullVersionString = ""
	Set productList = ""
	Set delimiter = $Case(pMultiLine, 1: $$$NL, : " + ")
	Set systemVersion = $System.Version.Format()
	Do ..GetComponentArray(.componentArray)
	
	// Keep track of which databases are available on the system
	#dim availableDatabaseArray As %String
	If ..IsHealthShareInstance() {
		Set database = ""
		While 1 {
			Set database = $Order(componentArray(database))
			If (database = "") {
				Quit
			}
			
			Set isAvailable = ..ComponentStatus(database)
			If 'isAvailable {
				Continue
			}
			// If the version is found, then add to product list
			If $$$ISOK(..ComponentVersion(database, .version)) {
				Set availableDatabaseArray(database) = ""
				Set componentName = $Get(componentArray(database, $$$SubscriptVersionString))
				Set productList = productList _ $ListBuild(componentName_":"_version)
			}
		}
		Set productsString = $ListToString(productList, delimiter)
		If pMultiLine {
			Set fullVersionString = systemVersion_" "_delimiter_"HealthShare Modules:"_delimiter_productsString
		} Else {
			// Sample version string (excluding the $zv part of it):
			// HealthShare Unified Care Record 2021.1.0 Build: 1234 [HealthShare Modules: Core:21.0 + Health Insight:21.0 + Patient Index:21.0]
			Set kitName = ..GetKitName(.availableDatabaseArray)
			Set versionString = ##class(%ZHSLIB.Version).GetNumber()
			Set build = ##class(%ZHSLIB.Version).GetBuildNumber()
			Set patch = ##class(%ZHSLIB.Version).GetPatch()
			Set adhoc = ##class(%ZHSLIB.Version).GetAdhocNumber()
			// Always start with "HealthShare"
			Set partsList = $ListBuild("HealthShare")
			If (kitName '= "") {
				Set partsList = partsList _ $ListBuild(kitName)
			}
			Set partsList = partsList _ $ListBuild(versionString, "Build: "_build)
			If (patch '= 0) {
				Set partsList = partsList _ $ListBuild("Patch: "_patch)
			}
			If (adhoc '= 0) {
				Set partsList = partsList _ $ListBuild("Adhoc: "_adhoc)
			}
			Set prefix = $ListToString(partsList, " ")
			Set fullVersionString = prefix_" [HealthShare Modules: "_productsString_"] - "_systemVersion
		}
	} Else {
		Set node = $Case(..IsIRISHealthInstance(), 1: "Health", : "HealthConnect")
		Set string = $ListGet($Get(^%SYS("Components", node)))
		Set fullVersionString = systemVersion_" "_$Case(pMultiLine, 0: "[", 1: delimiter)_string_$Case(pMultiLine, 0: "]", 1: "")
	}
	Return fullVersionString
]]></Implementation>
</Method>

<Method name="ComponentStatus">
<Description>
Use $$$CheckComponentStatus("VIEWER") or $$$ValidateComponentStatus("VIEWER")</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pComponent="",pLicensed=1,pRevalidate=0</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	#; Given a component check to see if it is installed and optionally licensed
	#; If not installed returns 0 (whether licensed or not)
	#; If pLicensed is 0 does not check the licensing
	#; If pRevalidate is 1 do not used cached value, but recheck to see if the database exists
	If (pComponent = "") {
		Return 0
	}
	Set isInstalled = 0
	Set isLicensed = 0
	// Append LIB if missing
	Set libraryDatabase = $Case(($Extract(pComponent, *-2, *) = "LIB"), 1: pComponent, : (pComponent_"LIB"))
	Do ..GetComponentArray(.componentArray)
	If pLicensed {
		Set licenseName = $Get(componentArray(libraryDatabase, $$$SubscriptLicense))
		Set isLicensed = $Case((licenseName = ""), 1: 1, : $$$HSLicensed(licenseName))
	}
	If pRevalidate { 
		Set isInstalled = ..CheckDBInstalled(libraryDatabase)
	} Else { 
		Set isInstalled = $Get($$$HSLibraryDatabaseExistsGlobal(libraryDatabase))
		If 'isInstalled {
			Set isInstalled = ..CheckDBInstalled(libraryDatabase)
		}
	}
	Return isInstalled && $Case(pLicensed, 1: isLicensed, : 1)
]]></Implementation>
</Method>

<Method name="SetJWTIssuer">
<Description>
Set JWT issuer for the instance.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	New $Namespace
	Set $Namespace = "%SYS"
	Set sc = $ClassMethod("Security.System", "Get", , .props)
	$$$ThrowOnError(sc)
	Set sc = ##class(%RoutineMgr).GetWebServerPort(, .server)
	$$$ThrowOnError(sc)
	If '($Data(props("JWTIssuer"))#2) {
		// If no JWT issuer present, set a unique one based on machine + instance name
		Set props("JWTIssuer") = server _ ":" _ ##class(%SYS.System).GetInstanceName()
		Set sc = $ClassMethod("Security.System", "Modify", , .props)
		$$$ThrowOnError(sc)
	}
]]></Implementation>
</Method>

<Method name="AddDelegated">
<Description>
For HealthShare, this is called to enable system wide delegated authentication.
Returns 0 if no changes were made.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	New $Namespace
	Set $Namespace = "%SYS"
	// Enable delegated authentication, if not already enabled
	Set tSC=##Class(Security.System).Get(,.tProp) Quit:$$$ISERR(tSC) 0
	If '$zb(+tProp("AutheEnabled"),$$$AutheDelegated,1) {
		Set tProp("AutheEnabled")=tProp("AutheEnabled")+$$$AutheDelegated
		Set tSC=##Class(Security.System).Modify(,.tProp) Quit:$$$ISERR(tSC) 0
	}
	For tService="%Service_Terminal","%Service_Console","%Service_Bindings" {
		//not all services will exist - it's OK if this get fails
		Set tSC2=##Class(Security.Services).Get(tService,.tProp) Continue:$$$ISERR(tSC2)
		If '$zb(+tProp("AutheEnabled"),$$$AutheDelegated,1) {
			Set tProp("AutheEnabled")=tProp("AutheEnabled")+$$$AutheDelegated
			Set tSC=##Class(Security.Services).Modify(tService,.tProp) Quit:$$$ISERR(tSC)
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="UpdateSystemWebAppsAutheEnabled">
<Description>
For HealthShare, update IRIS web apps for which we want to support delegated
authentication.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New $Namespace
	Set $Namespace = "%SYS"

	// Only these web apps 
	Set webAppList = ..GetSystemPortalWebAppNameList()
	Set ptr = 0
	While $ListNext(webAppList, ptr, webApp) {
		Set sc = ##class(Security.Applications).Get(webApp, .props)
		$$$ThrowOnError(sc)
		Set autheEnabled = $Get(props("AutheEnabled"))
		// Remove unauthenticated and add delegated
		If $ZBoolean(autheEnabled, $$$AutheUnauthenticated, 1) {
			Set autheEnabled = autheEnabled - $$$AutheUnauthenticated
		}
		If '$ZBoolean(autheEnabled, $$$AutheDelegated, 1) {
			Set autheEnabled = autheEnabled + $$$AutheDelegated
		}
		Set props("AutheEnabled") = autheEnabled
		Set sc = ##class(Security.Applications).Modify(webApp, .props)
		$$$ThrowOnError(sc)
	}
]]></Implementation>
</Method>

<Method name="GetSystemPortalWebAppNameList">
<Description>
Returns a $ListBuild() list of web app names used by the core Management
Portal.</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%Library.List</ReturnType>
<Implementation><![CDATA[
$ListBuild(
	"/csp/sys", 
	"/csp/sys/exp", 
	"/csp/sys/mgr", 
	"/csp/sys/op", 
	"/csp/sys/sec"
)
]]></Implementation>
</Method>

<Method name="GetCSPAppPath">
<ClassMethod>1</ClassMethod>
<FormalSpec>pApplication=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Quit:pApplication=""
	New $Roles,$Namespace
	Set $Roles="%All"
	Set $namespace="%SYS"
	If ##class(Security.Applications).%ExistsId(pApplication) {
		Quit ##class(Security.Applications).PathGetStored(pApplication)
	}
	Quit ""
]]></Implementation>
</Method>

<Method name="IsFoundationInstalled">
<Description>
Deprecated - should no longer be used</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[0
]]></Implementation>
</Method>

<Method name="InstanceType">
<Description>
0 - HealthShare 	$$$HSisHealthShare
1 - Connect			$$$HSisHealthConnect
2 - IRISforHealth	$$$HSisIRISforHealth</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	If $D(%session) {
		Set tInstanceType = $G(%session.Data("InstanceType"))
		If tInstanceType '= "" {
			Quit tInstanceType
		}
	}
	New $Namespace
	New $Roles
	Set $Roles="%All"
	/// During install on backup Mirrored member HSSYS is not updated because it's mirrored, just always grab the value from %SYS 
	Set type = $Piece($Get(^["^^"_$zu(12)]%SYS("HealthShare"),$G(^%SYS("HealthShare"))),"^",2)
	If type = "" {
		// During a build this global is empty. It is set during a kit install
		// So for calls during a build to work, the below logic is needed.
		
		// The GetComponentArray() method returns a subscripted array with
		// metadata for all HealthShare library databases.
		// Once the module name is found, check if the package manager persistent module
		// object exists in the implied namespace of HSLIB (since HSLIB may not have namespace).
		// If it does, this MUST be a HealthShare instance (not a HealthConnect/IRIS for Health one)
		// because this module exists only in HSLIB for HealthShare products AND MUST exist for
		// every HealthShare product.
		Do ..GetComponentArray(.tComponentArray)
		Set $Namespace = "HSLIB"
		Set tExists = ##class(%IPM.Storage.Module).NameExists(tComponentArray("HSLIB", $$$SubscriptModule))
		Set tInstanceType = $Case(tExists, 1: $$$HSisHealthShare, : $$$HSisIRISforHealth)
	} Else {
		Set tInstanceType = $Case($zcvt(type,"l"),"healthshare":$$$HSisHealthShare,"healthconnect":$$$HSisHealthConnect,"irishealth":$$$HSisIRISforHealth)
	}
	If $D(%session) {
		Set %session.Data("InstanceType") = tInstanceType
	}
	Quit tInstanceType
]]></Implementation>
</Method>

<Method name="IsHealthShareInstance">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[..InstanceType()=$$$HSisHealthShare
]]></Implementation>
</Method>

<Method name="IsHealthConnectInstance">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[..InstanceType()=$$$HSisHealthConnect
]]></Implementation>
</Method>

<Method name="IsIRISHealthInstance">
<Description>
  </Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[..InstanceType()=$$$HSisIRISforHealth
]]></Implementation>
</Method>

<Method name="EnableFoundationNamespace">
<Description>
Deprecated call, replaced with EnableHealthShareNamespace</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pTargetNS:%String,pVerbose:%Boolean=0,&pIsPrimary:%Boolean=1,pFromEnableEnsemble:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ..EnableHealthShareNamespace(pTargetNS,pVerbose,pIsPrimary,pFromEnableEnsemble)
]]></Implementation>
</Method>

<Method name="GetAuthNS">
<Description>
Namespace to use for executing calls to Hub / Registry</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	New $namespace
	Set tNS=""
	try {
		//find a valid healthshare namespace, ideally a hub
		Set tN=""
		For {
			Set tN=$O(^%SYS("HealthShare","Instances",tN)) Quit:tN=""
			IF ^%SYS("HealthShare","Instances",tN,"Type")="Hub" {
				//found a hub
				Set tNS=tN
				Quit
			}
			//validate that the namespace can connect to the hub
			Set $namespace=tN
			Set:$IsObject(##class(HS.Registry.Service.SOAP).EndPointForNameType("HSREGISTRY","SOAP")) tNS=tN
		}
	} catch ex {
	}
	Quit tNS
]]></Implementation>
</Method>

<Method name="EnableHealthShareNamespace">
<Description>
Create Foundation namespace
pFromEnableEnsemble is for when this gets called by %Library.EnsembleMgr.  In that case,
a database has already been created, and we're enabling the namespace for Ensemble</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pTargetNS:%String,pVerbose:%Boolean=0,&pIsPrimary:%Boolean=1,pFromEnableEnsemble:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Check for namespace validity
	Quit:'..validateNamespace(.pTargetNS,0,.tSC) tSC
	#ifndef REPORT
	#define REPORT(%l,%x) Write:pVerbose !,?%l,%x
	#endif
	try {
		If 'pFromEnableEnsemble && '..IsEnsembleNamespace(pTargetNS) Set tSC = ..EnableNamespace(pTargetNS,pVerbose) Quit:$$$ISERR(tSC)
		Set tWhere = $namespace
	
		Set $namespace="%SYS"

		Set tHSLIB = ..#HSLIB
		Set pTargetNS = $zcvt(pTargetNS,"U")
		Set tSC=..MapComponent(..#HSLIB,pTargetNS,pVerbose) Quit:$$$ISERR(tSC)
		Set tSC=..UpdateAndReloadCPF(pVerbose,pTargetNS) Quit:$$$ISERR(tSC)
		Set $Namespace=pTargetNS
		set tSC=##class(HS.Util.Installer.ConfigItem).GetComponentByName(pTargetNS,.tComponent,1,"Foundation",tHSLIB)
		//We're passing this in to suppress creation of a new database
		//The normal check for DB already exists might not work here, because the database might be in mixed case
		If pFromEnableEnsemble Set tVars("FromEnableEnsemble")=1
		Set tSC = tComponent.Install(pTargetNS,.tVars)
		Do tComponent.MarkActivated()
	}
	catch tException {
		set tSC = tException.AsStatus()
	}
	If $g(tWhere)]"" Set $Namespace=tWhere
	quit tSC
]]></Implementation>
</Method>

<Method name="GetDBNSInfo">
<Description><![CDATA[
Fetch structure about a namespaces' globalsDatabase, whether it is mirrored, and the resource name. <br />
@Throws This method throws unexpected errors<br />
@Argument pNamespace  A namespace name<br />
@Argument pInfo       A variable by reference which will be populated with a dynamic object about the namespace and globals database<br />
@ReturnValue          Boolean value whether Namespace exists<br />]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace:%String,*pInfo:%DynamicObject</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set pInfo=""
	If pNamespace="" {
		Return 0
	}
	$$$AddAllRoleTemporary
	New $namespace
	Set $namespace = "%SYS"
	Set exists = 0
	Set sc = $classMethod("Config.Namespaces","Get",pNamespace,.nsProps)
	If $system.Status.GetErrorCodes(sc)=$$$CPFNameDoesNotExist {
		Return 0  /// namespace doesn't exist
	}
	Set pInfo = {"name":(pNamespace),"globalsDatabase":{}}
	$$$ThrowOnError(sc)
	Set exists = 1
	Set sc = $classMethod("Config.Databases","Get",nsProps("Globals"),.dbProps)
	$$$ThrowOnError(sc)
	Set pInfo.globalsDatabase.name=nsProps("Globals")
	Set dbObj = $classMethod("SYS.Database","%OpenId",dbProps("Directory"))
	Set pInfo.globalsDatabase.directory = dbProps("Directory")
	Set pInfo.globalsDatabase.mirrored = dbObj.Mirrored
	Set pInfo.globalsDatabase.resourceName = dbObj.ResourceName
	Quit exists
]]></Implementation>
</Method>

<Method name="UpdateReadWrite">
<Description>
Update the write status of a code database, returning the previous state</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pDB,pReadOnly,&pPreviousState]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	try {
		New $Namespace
		Set $Namespace="%SYS"
		Set tSC=$$$OK,tDB=$zcvt(pDB,"l"),tState=0
		If '##class(SYS.Database).%ExistsId(tDB) {
			// it could be that the database is in a container and therefore in the InstallDirectory
			Set tDB = ##class(%File).NormalizeDirectory($system.Util.InstallDirectory()_"mgr/"_tDB)
			If '##class(SYS.Database).%ExistsId(tDB) {
				Set tSC = $$$ERROR($$$GeneralError,"Database does not exist "_pDB)
				Quit
			}
		}
		Set tDBObj = ##class(SYS.Database).%OpenId(tDB)
		Set pPreviousState=tDBObj.ReadOnly
		Set tDBObj.ReadOnly=pReadOnly
		Set tSC = tDBObj.%Save() Quit:$$$ISERR(tSC)
	} catch ex {
		Set tSC=ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="namespaceAndDatabaseSetup">
<Description>
This is a method generator whose code is generated by XGL.
Create explicit namespace, with its database correlated to the one in mgr directory that comes with the instance</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec><![CDATA[&pVars,pLogLevel:%Integer]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; Let our XGL document generate code for this method. 
	Quit ##class(%Installer.Manifest).%Generate(%compiledclass, %code, "HSCOMPONENT")
]]></Implementation>
</Method>

<XData name="HSCOMPONENT">
<XMLNamespace>INSTALLER</XMLNamespace>
<Data><![CDATA[
<Manifest>
<Var Name="DBRESOURCE" Value="%DB_${DATABASE}"/>
<Var Name="NAMESPACELOWERCASE" Value='#{$ZCVT("${NAMESPACE}","L")}'/>
<Var Name="DATABASEDIR" Value='#{##class(%File).NormalizeDirectory($system.Util.InstallDirectory()_"mgr/"_"${NAMESPACELOWERCASE}")}'/>

<!-- namespace created here should be same as database -->
<Namespace Name="${DATABASE}"
          Create="yes"
          Ensemble="0">

<Configuration>

<!-- Create a database -->
<Database Name="${DATABASE}"
		 Dir="${DATABASEDIR}"
		 Create="no"
		  Resource="${DBRESOURCE}"/>

<!-- Create IPM mapping from the namespace to itself -->
<!-- Enable the following line once IPM is in place -->
<ClassMapping Package="%IPM" From="${NAMESPACE}" />

</Configuration>

</Namespace>
</Manifest>
]]></Data>
</XData>

<Method name="InstallComponent">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDB:%String="",pVerbose:%Boolean=0,pDev:%Boolean=0,pIsUpgrade:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:pDB="" $$$ERROR($$$GeneralError,"No database defined")
	try {
		Set tSC=$$$OK

		Kill vars
		Set vars("DATABASE")=pDB
		Set vars("NAMESPACE")=pDB
		If (pVerbose) {
			Write !!, "%ZHSLIB.HealthShareMgr - Installing namespace and database "_pDB_" ...",!
		}
		Set tSC = ..namespaceAndDatabaseSetup(.vars,''pVerbose*3)
		If $$$ISERR(tSC) {
			Quit
		}
		New $Namespace
		Set $Namespace = pDB
		If (pIsUpgrade) {
			// Make database writeable on upgrade because map2enslib() tries to edit globals.
			// TODO: Remove this once map2enslib() is fixed.
			$$$ThrowOnError(..UpdateReadWrite(pDB, 0))
			If (pVerbose) {
				Write !, "Mounted database "_pDB_" read/write"
			}
		}
		// Add ensemble mappings without making the namespace Ensemble aware i.e.
		// add just the mappings but do not permit creation of ensemble productions
		// in LIB namespaces.
		Set sc = ##class(%EnsembleMgr).map2enslib(pDB, pVerbose)
		$$$ThrowOnError(sc)
		// Check if pIsUpgrade exists as an argument and accordingly add it to the call.
		// Needed for backwards compatibility.
		Set tFormalSpecList = $$$comMemberKeyGet("Installer.Install", $$$cCLASSmethod, "OnInstallComponent", $$$cMETHformalspecparsed)
		If ($ListLength(tFormalSpecList) = 4) {
			Set tSC=##class(Installer.Install).OnInstallComponent(pDB,pVerbose,pDev,pIsUpgrade)
		} Else {
			Set tSC=##class(Installer.Install).OnInstallComponent(pDB,pVerbose,pDev)
		}
		Do:$$$ISERR(tSC) ##class(%SYS.System).WriteToConsoleLog(pDB_" OnInstallComponent Error: "_$system.Status.GetErrorText(tSC),,3)
		Quit:$$$ISERR(tSC)
		#; potentially the OnInstallComponent has left us in a different database
		Set $Namespace = pDB
		If ..IsHealthShareInstance() {
			Do ##Class(%ZHSLIB.Component).InstallUpdateINI()
			// Add HSLIB mappings for namespaces (that are built from component) with settings EnableHealthShare=1
			Do ..GetComponentArray(.componentArray)
			Set NSModuleName = $Get(componentArray($ZConvert(pDB, "U"), $$$SubscriptModule))
			Set NSModule = ##class(%IPM.Storage.Module).NameOpen(NSModuleName,,.tSC)
			If $$$ISERR(tSC) {
				Quit
			}
			Set NSConfig = NSModule.GetNamespaceConfig()
			If (NSConfig.EnableHealthShare) {
				Set tSC = ..MapComponent("HSLIB", pDB, pVerbose)
				If $$$ISERR(tSC) {
					Quit
				}
			}
		} Else {
			/// Components.ini is no longer used by the installer (per Alexander Enis January 28, 2022), no need for I4H or HC to keep it
			Do ##class(%File).Delete($system.Util.InstallDirectory()_"Components.ini")  /// Just cleaning up we don't care if it doesn't exist or fails
		}

	} catch ex {
		Set tSC=ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="UnInstallComponent">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDB="",pVerbose=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:pDB="" $$$ERROR($$$GeneralError,"No database defined")
	try {
		Set tSC=$$$OK
		New $namespace
		zn "^^"_$$$HSLibraryDatabaseDirectory(pDB)
		Set tSC=##class(Installer.Install).OnUnInstallComponent(pDB,pVerbose)
	} catch ex {
		Set tSC=ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="PopulateBuildNumberInGlobal">
<Description><![CDATA[
Stashes the kit build number into the appropriate global for the <method>VersionInfo</method>
to pull from. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pBuildNumber:%String</FormalSpec>
<Implementation><![CDATA[	Set $$$BuildNumberGbl = pBuildNumber
]]></Implementation>
</Method>

<Method name="GetComponentVersion">
<Description><![CDATA[
Wrapper around <method>ComponentVersion</method> that returns a string version. <br />
DOES NOT throw errors. Returns "" if the LIB namespace is not found. <br />
@Argument	pLIBNamespace		LIB namespace name. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pLIBNamespace:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    Set sc = ..ComponentVersion("HSLIB", .version)
    If $$$ISERR(sc) {
        Return ""
    }
    Return version
]]></Implementation>
</Method>

<Method name="ComponentVersion">
<Description>
Version of the installed Component version</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDB:%String="",*pVersion:%String="",pConfigItem:%Persistent=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pVersion = ""
	Quit:pDB="" $$$ERROR($$$GeneralError,"No database defined")
	Return ..SecureComponentVersion(pDB, .pVersion, pConfigItem)
]]></Implementation>
</Method>

<Method name="SecureComponentVersion">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDB:%String="",*pVersion:%String="",pConfigItem:%Persistent=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Quit:pDB="" $$$ERROR($$$GeneralError,"No database defined")
	$$$AddAllRoleTemporary
	Try {
		New $Namespace
		Set tVars("Component") = pConfigItem
		Set tProductKey = pDB
		If ($Extract(pDB,1) = "^") {
			Set tSlash = $Select($$$isWINDOWS: "\", 1: "/")
			Set tSlashOffset = 0
			If ($Extract(pDB,*) = tSlash) {
				Set tSlashOffset = 1
			}
			Set tProductKey = $ZConvert($Piece(pDB,tSlash,*-tSlashOffset),"U")
		}
		
		Set tTo = tProductKey
		If $IsObject(pConfigItem) && (pConfigItem.%IsA("HS.Util.Installer.ConfigItem")) {
			Set tTo = pConfigItem.GetInstallerDatabase(.tVars,tProductKey)
		}
		
		If (tTo = "HSLIB") && '..IsHealthShareInstance() {
			// For I4H, module name is different
			Set tModuleName = "HealthConnect"
		} Else {
			Do ..GetComponentArray(.tComponentArray)
			Set tModuleName = $Get(tComponentArray(tTo, $$$SubscriptModule))
			If (tModuleName = "") {
				$$$ThrowStatus($$$ERROR($$$GeneralError,"No base module found for database: "_tModuleName))
			}
		}
		// Switch to namespace to read module version
		Set $Namespace = tTo
		#dim tModule As %IPM.Storage.Module
		Set tModule = ##class(%IPM.Storage.Module).NameOpen(tModuleName, 0, .sc)
		$$$ThrowOnError(sc)
		Set pVersion = tModule.Version.Major _ "." _ tModule.Version.Minor
	} Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="ConfigureComponent">
<Description>
Add mappings for a Namespace and additional configuration items
##class(%ZHSLIB.HealthShareMgr).ConfigureComponent("HSPILIB","HSREGISTRY",$g(pVerbose),.pVars)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pDB="",pNamespace="",pVerbose=0,&pVars]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:pDB="" $$$ERROR($$$GeneralError,"No database defined")
	try {
		Set tSC=$$$OK
		New $namespace
		Set $namespace="HSLIB"
		zn "^^"_$$$HSLibraryDatabaseDirectory(pDB)
		
		Set tInstallerClass = ..GetInstallerClass(.pVars)
		try {
			#; introduced a new parameter, catch if it throws an error and try without
			Set tSC = $classmethod(tInstallerClass,"OnConfigureComponent",pNamespace,pVerbose,.pVars)
		} catch {
			Set tSC = $classmethod(tInstallerClass,"OnConfigureComponent",pNamespace,pVerbose)
		}
	} catch ex {
		Set tSC=ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="UnconfigureComponent">
<Description>
Remove mappings for a Namespace (to a component) ##class(%ZHSLIB.HealthShareMgr).UnconfigureComponent("HSPILIB","HSREGISTRY",$g(pVerbose))</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pDB="",pNamespace="",pVerbose=0,pPurgeFiles=0,&pVars]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:pDB="" $$$ERROR($$$GeneralError,"No database defined")
	try {
		Set tSC=$$$OK
		New $namespace
		Set tComponent = $get(pVars("Component"))
		If '$isobject(tComponent) {
			Set tComponent = ##class(HS.Util.Installer.ConfigItem).%OpenId(pNamespace,,.tSC)
			If $$$ISERR(tSC) {
				Quit
			}
			Set pVars("Component") = tComponent
		}
		Set tInstallerDatabase = tComponent.GetInstallerDatabase(.pVars)
		zn "^^"_$$$HSLibraryDatabaseDirectory(tInstallerDatabase)
		
		Set tInstallerClass = ..GetInstallerClass(.pVars)
		try {
			#; introduced a new parameter, catch if it throws an error and try without
			Set tSC = $classmethod(tInstallerClass,"OnUnconfigureComponent",pNamespace,pVerbose,pPurgeFiles,.pVars)
		} catch {
			Set tSC = $classmethod(tInstallerClass,"OnUnconfigureComponent",pNamespace,pVerbose,pPurgeFiles)
		}
	} catch ex {
		Set tSC=ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetInstallerClass">
<Description><![CDATA[
Helper method to retrieve installer class name from <var>pVars("Component")</var>.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pVars,pProduct:%String=""]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Dictionary.Classname</ReturnType>
<Implementation><![CDATA[
	Set tInstallerClass = "Installer.Install"
	Set tComponent = $get(pVars("Component"))
	If $isobject(tComponent) {
		Try {
			Set tInstallerClass = tComponent.GetInstallerClass(.pVars,pProduct)
		}
		Catch {}
	}
	
	Quit tInstallerClass
]]></Implementation>
</Method>

<Method name="MapComponent">
<Description>
Add mappings for a Namespace (to a component) ##class(%ZHSLIB.HealthShareMgr).MapComponent("HSPILIB","HSREGISTRY",$g(pVerbose))</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDB="",pNamespace="",pVerbose=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ..ConfigureComponent(pDB,pNamespace,pVerbose)
]]></Implementation>
</Method>

<Method name="ValidateComponent">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDB="",pVerbose=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:pDB="" $$$ERROR($$$GeneralError,"No database defined")
	try {
		Set tSC=$$$OK
		New $namespace
		zn "^^"_$$$HSLibraryDatabaseDirectory(pDB)
		Set tSC=##class(Installer.Install).OnValidateComponent(pVerbose)
	} catch ex {
		Set tSC=ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="ComponentUpgrade">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDB="",pPreviousVersion="",pVerbose=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:pDB="" $$$ERROR($$$GeneralError,"No database defined")
	try {
		Set tSC=$$$OK
		New $namespace
		zn "^^"_$$$HSLibraryDatabaseDirectory(pDB)
		Set tSC=##class(Installer.Install).OnComponentUpgrade(pPreviousVersion,pVerbose)
	} catch ex {
		Set tSC=ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="ResetComponent">
<Description>
Method called when user is trying to clear out patient data, but leave configuration information</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDB="",pNamespace="",pVerbose=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:pDB="" $$$ERROR($$$GeneralError,"No database defined")
	try {
		Set tSC=$$$OK
		New $namespace
		zn "^^"_$$$HSLibraryDatabaseDirectory(pDB)
		try {
			Set tSC=##class(Installer.Install).OnResetComponent(pNamespace,pVerbose)
		} catch ex {
			#; don't throw the method does not exist
			If ex.Code'=148 Throw ex
		}
	} catch ex {
		Set tSC=ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="MapZHSLIB">
<ClassMethod>1</ClassMethod>
<FormalSpec>pTargetNamespace=$namespace</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	New $namespace
	try {
		set $namespace = "%SYS"
		if '##class(Config.MapPackages).Exists(pTargetNamespace,"%ZHSLIB") {
			Kill tProperties
			Set tProperties("Database") = "HSLIB"
			Set tSC=##class(Config.MapPackages).Create(pTargetNamespace,"%ZHSLIB",.tProperties)
			quit:$$$ISERR(tSC)
		}
		if '##class(Config.MapRoutines).Exists(pTargetNamespace,"%ZHSLIB") {
			Kill tProperties
			Set tProperties("Database") = "HSLIB"
			Set tSC=##class(Config.MapRoutines).Create(pTargetNamespace,"%ZHSLIB",.tProperties)
			quit:$$$ISERR(tSC)
		}
	} Catch ex {
		Set tSC=ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="MapZHSLIBForAll">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	New $namespace
	try {
		set $namespace = "%SYS"
		Set tNS=""
		For  {
			Set tNS=$O(^%SYS("HealthShare","Instances",tNS)) Quit:tNS=""
			Set tSC=..MapZHSLIB(tNS)
		}
	} Catch ex {
		Set tSC=ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="CopyClassesToHSCUSTOM">
<Description><![CDATA[
Copy classes from a library database to HSCUSTOM. The entire package provided is copied.
Each class is only copied to HSCUSTOM if it does not already exist so as to not overwrite
customizations customers may have made to classes in HSCUSTOM. <br />
@Argument	pPackage		Package to copy. <br />
@Argument	pDB				Database to copy from. <br />
@Argument	pCompileFlags	Compilation flags to use when importing the class into HSCUSTOM. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pPackage:%String,pDB:%String,pCompileFlags:%String="ck-d"</FormalSpec>
<Implementation><![CDATA[
	If ($Extract(pPackage,*) '= ".") {
		// Ensure package ends with a period
		Set pPackage = pPackage _ "."
	}
	// Copy missing classes from HSLIB's HS.Local package into HSCUSTOM
	Write !, "Copying classes in package: "_pPackage_" from database "_pDB_" to HSCUSTOM"
	Set ns = "^^"_$$$HSLibraryDatabaseDirectory(pDB)
	Set class = pPackage
	For {
		Set class = $Order(^|ns|oddCOM(class))
		If ($Extract(class,1,$Length(pPackage)) '= pPackage) {
			Quit
		}
		Do ..CopyClassToHSCUSTOM(class,pDB,pCompileFlags)
		Write !, " - Copied class "_class
	}
]]></Implementation>
</Method>

<Method name="CopyClassToHSCUSTOM">
<Description><![CDATA[
Copy class from the provided database to HSCUSTOM. If the class is already in HSCUSTOM, it is
not copied. <br />
@Argument	pClass		Class to copy. <br />
@Argument	pDB			Database to copy to. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClass:%Dictionary.Classname,pDB:%String,pCompileFlags:%String</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	If $Data(^|"HSCUSTOM"|oddCOM(pClass)) {
		// Class exists so no-op
		Return
	}
	New $Namespace
	Set $Namespace = "^^"_$$$HSLibraryDatabaseDirectory(pDB)
	Set stream = ##class(%Stream.TmpCharacter).%New()
	Set sc = $System.OBJ.ExportToStream(pClass_".cls",.stream,"-d")
	$$$ThrowOnError(sc)
	Set $Namespace = "HSCUSTOM"
	Set sc = $System.OBJ.LoadStream(stream,pCompileFlags)
	$$$ThrowOnError(sc)
]]></Implementation>
</Method>

<Method name="OnStartHealthShare">
<Description>
Will happen on startup as well as when we become primary</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pIsStartup:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	Try {
		If '##class(%SYS.Namespace).Exists("HSSYS") {
			// Nothing to do if namespace doesn't exist yet
			Quit
		}
		New $Namespace
		Set $Namespace = "HSSYS"
		Do ##class(HS.Util.MirrorMonitorAgent).ManageInstanceGUID()
		If 'pIsStartup {
			// In a mirror failover
			If $system.Mirror.IsMember() && $system.Mirror.IsPrimary() {
				Do ..RunQueuedOnStartSteps()
				//This happens on failover.
				//If the backup member was upgraded, and the primary was not and was failed over,
				//then we need to check if the productions should be de-activate (since that
				//couldn't happen on a backup member)
				Set sc = ##Class(HS.Director).DeactivateAll()
				Do ..StartStartupItems( , 2)
			}
		} Else {
			// If in a container, copy XSLT files from the transient install directory to a durable storage
			// location (if they're not present there already).
			Set tXSLTDir = ##class(%Library.File).NormalizeDirectory($System.Util.DataDirectory()_"csp/xslt")
			If $$$InAContainer && '##class(%File).DirectoryExists(tXSLTDir) {
				Do ##class(%ZHSLIB.HealthShareMgr).UpdateXSLTFiles()
			}
			
			// Non Mirrored (execute contexts 1 & 2) 
			// Mirrored - Is Primary (execute contexts 1 & 2)
			// Mirrored - not primary (execute context 1)
			Do ..StartStartupItems(,$S('$system.Mirror.IsMember():"",$system.Mirror.IsPrimary():"",1:1))
		}
	} Catch (ex) {
		Set text = "Error occurred during "_$Case(pIsStartup, 1: "startup", : "failover")_": "_$System.Status.GetErrorText(ex.AsStatus())
		Do ##class(%SYS.System).WriteToConsoleLog(text,3)
	}
]]></Implementation>
</Method>

<Method name="RunQueuedOnStartSteps">
<Description><![CDATA[
Run steps queued up in the OnStart global by <class>Installer.Install</class>.
to run on a mirrored upgrade when the instance first become a primary mirror member.
Intentionally do not mark as private in case the method needs to be invoked to re-run jobs. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	Set index = ""
	While 1 {
		Set index = $Order($$$OnStartGblUpgradeStepsArgs(index))
		If (index = "") {
			Quit
		}
		Set namespace = $$$OnStartGblUpgradeStepsArgs(index,"namespace")
		Set method = $$$OnStartGblUpgradeStepsArgs(index,"method")
		// Run all queued up upgrade steps
		If (namespace = "") || (method = "") {
			// Invalid entry so delete and skip
			Kill $$$OnStartGblUpgradeStepsArgs(index)
			Continue
		}
		Kill methodArgs
		Merge methodArgs = $$$OnStartGblUpgradeStepsArgs(index,"arguments")
		Do ..RunMethodInNamespace(index, namespace, method, methodArgs...)
	}
]]></Implementation>
</Method>

<Method name="RunMethodInNamespace">
<Description><![CDATA[
Run specified method with the provided arguments in the provided namespace.
The method will run on the class <class>Installer.Install</class>. <br />
@Argument	pIndex			Index subscript of OnStart global with queued up steps. <br />
@Argument	pNamespace		Namespace in which to run method. <br />
@Argument	pMethodName		Name of method to run. <br />
@Argument	pArgs			Arguments to pass to method call. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pIndex:%Integer,pNamespace:%String,pMethodName:%String,pArgs...</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set classname = "Installer.Install"
	Try {
		// Hard-code to only allow running methods in Installer.Install
		// for now. Could perhaps extend this if needed later to
		// support running in other classes.
		New $Namespace
		Set $Namespace = pNamespace
		If (pMethodName '= "") && $System.CLS.IsMthd(classname,pMethodName) {
			Do $ClassMethod(classname, pMethodName, pArgs...)
			Set text = "Successfully completed running the following as an upgrade step now that the current instance is a primary mirror member: "_classname_":"_pMethodName
			Write !, text
			Do ##class(%SYS.System).WriteToConsoleLog(text)
		} Else {
			Set text = "Skipped invalid upgrade step: "_classname_":"_pMethodName
			Write !, text
			Do ##class(%SYS.System).WriteToConsoleLog(text)
		}
		// Kill to indicate upgrade steps have run. Only kill if run successfully
		Kill $$$OnStartGblUpgradeStepsArgs(pIndex)
	} Catch (ex) {
		Set sc = ex.AsStatus()
		Set text = "Error occurred running upgrade step "_classname_":"_pMethodName_": "_$System.Status.GetErrorText(sc)
		Write !, text
		Do ##class(%SYS.System).WriteToConsoleLog(text, , 2)
	}
]]></Implementation>
</Method>

<Method name="RunOrQueueOnStartUpgradeStep">
<Description><![CDATA[
For the given method, runs it on class Installer.Install in the provided namespace if the
instance is not mirrored or is the primary. If the instance is mirrored and is not a primary,
the method is queued up to be run when the instance becomes primary. <br />
NOTE: Steps that are queued up MUST be independent as there is no guarantee of sequence in 
which steps are run.]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace:%String,pMethodName:%String,pArgs...</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	If '$System.Mirror.IsMember() || $System.Mirror.IsPrimary() {
		Do $ClassMethod("Installer.Install", pMethodName, pArgs...)
		Write !, "Finished running Installer.Install:"_pMethodName
	} Else {
		Set index = $Increment($$$OnStartGblUpgradeSteps)
		Set $$$OnStartGblUpgradeStepsArgs(index,"namespace") = pNamespace
		Set $$$OnStartGblUpgradeStepsArgs(index,"method") = pMethodName
		Merge $$$OnStartGblUpgradeStepsArgs(index,"arguments") = pArgs
	}
]]></Implementation>
</Method>

<Method name="ReportPackageHash">
<Description>

Report class hash information and summarize with a SHA1 hash
</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pStream:%Stream.GlobalCharacter=$$$NULLOREF,pPackage:%String="HS"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tException As %Exception.AbstractException
	#dim tStatus As %Status = $$$OK
	Try {
		
		#dim tClass As %String
		#dim tHash As %String
		#dim tInfo As %List
		#dim tOutput As %Stream.GlobalCharacter


		If $E(pPackage,*) '= "." {
			Set pPackage = pPackage _ "."
		}

		If '$IsObject($GET(pStream)) {
			Set pStream=##class(%Stream.FileCharacter).%New()
			Do pStream.LinkToFile(##class(%File).NormalizeFilename(##class(%Library.File).NormalizeDirectory($System.Util.InstallDirectory()_"mgr")_"/Temp/_class_hash.txt"))
		}
		Set tOutput = pStream
	
		Set tClass = pPackage
		For {
			Set tClass = $ORDER(^rINDEXCLASS(tClass),1,tInfo)
			Quit:$E(tClass,1,$L(pPackage))'=pPackage
		
			Do tOutput.WriteLine($LI(tInfo,2)_" 12:"_$LI(tInfo,12)_" 13:"_$LI(tInfo,13))
		}

		Do tOutput.Rewind()

		If '$IsObject($GET(pStream)) {
			Do tOutput.OutputToDevice()
		}		
		
	} Catch (tException) {
		Set tStatus = tException.AsStatus()
	}
	
	Quit tStatus
]]></Implementation>
</Method>

<Method name="UpdateEnsembleCSPApplicationForNamespace">
<Description><![CDATA[
Helper method to update the CSP application under <code>/csp/<namespace></code>
that may be created automatically for some Ensemble-enabled namespaces to have a
Session Events class.
The method returns a boolean to indicate whether an update was performed.
This method throws exceptions.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	New $namespace
	
	Set $namespace = "HSLIB"
	Set tNamespaceUpper = $zconvert(pNamespace,"U")
	
	// We should perform the update if any one of the following is true:
	//   * The namespace is HSSYS
	//   * A ConfigItem exists for the namespace (i.e. it's a configured HealthShare namespace)
	//   * The namespace is one of the library databases we support
	Set tUpdateNeeded     = 0
	Set tConfigItemExists = 0
	If (tNamespaceUpper = "HSSYS") {
		Set tUpdateNeeded = 1
	}
	ElseIf ##class(HS.Util.Installer.ConfigItem).%ExistsId(tNamespaceUpper) {
		Set tUpdateNeeded     = 1
		Set tConfigItemExists = 1
	}
	Else {
		Set tSupportedLibraryDatabases = ..GetDatabaseList()
		
		Set tLibraryPointer = 0
		While ('tUpdateNeeded) && $ListNext(tSupportedLibraryDatabases, tLibraryPointer, tLibraryDatabase) {
			Set tUpdateNeeded = (tLibraryDatabase = tNamespaceUpper)
		}
	}
	If ('tUpdateNeeded) {
		Return 0
	}
	
	Set tEventClass = ""
	Set tLoginPage = ""
	If (tConfigItemExists) {
		// Get any configuration values while we have access to the HealthShare code in HSLIB
		Set tEventClass = ##class(HS.Util.Installer.ConfigItem).GetDefaultCSPSessionEventsClassForNamespace(tNamespaceUpper)
		Set tLoginPage = ##class(HS.Util.Installer.ConfigItem).GetDefaultCSPCustomLoginPageForNamespace(tNamespaceUpper)
	}
	ElseIf ..IsHealthShareInstance() && ##class(%Dictionary.CompiledClass).%ExistsId("HS.Util.Installer.HealthShareType") {
		Set tEventClass = ##class(HS.Util.Installer.HealthShareType).GetDefaultCSPSessionEventsClass()
		Set tLoginPage = ##class(HS.Util.Installer.HealthShareType).GetDefaultCSPCustomLoginPage()
	}
	Else {
		Set tEventClass = ##class(HS.Util.Installer.ConfigItem).GetDefaultCSPSessionEventsClass()
		Set tLoginPage = ##class(HS.Util.Installer.ConfigItem).GetDefaultCSPCustomLoginPage()
	}
	
	// If we don't have anything to do, we can return now
	If (tEventClass = "") && (tLoginPage = "") {
		Return 0
	}
	If (tEventClass '= "") {
		Set tUpdateProperties("EventClass") = tEventClass
	}
	If (tLoginPage '= "") {
		Set tUpdateProperties("LoginPage") = tLoginPage
	}
	
	Set $namespace = "%SYS"
	
	Set tExpectedCSPApplication = "/csp/" _ $zconvert(pNamespace,"L")
	Set tStatus = $$$OK
	If '##class(Security.Applications).Exists(tExpectedCSPApplication, .tCSPApplication, .tStatus) {
		// No action needed if the CSP application doesn't exist
		Return 0
	}
	$$$ThrowOnError(tStatus)
	
	Set tUpdated  = 0
	Set tProperty = ""
	While 1 {
		Set tProperty = $order(tUpdateProperties(tProperty),1,tPropertyValue)
		If (tProperty = "") {
			Quit
		}
		// Only perform an update if we have a non-empty value and the existing value is empty
		If (tPropertyValue '= "") && ($property(tCSPApplication,tProperty) = "")  {
			Set $property(tCSPApplication,tProperty) = tPropertyValue
			Set tUpdated = 1
		}
	}
	
	If (tUpdated) {
		Set tSaveStatus  = tCSPApplication.%Save()
	}
	Else {
		Set tSaveStatus = $$$OK
	}
	// Make sure we destroy the reference to the CSP application before we pop the stack
	Kill tCSPApplication
	
	$$$ThrowOnError(tSaveStatus)
	
	Return tUpdated
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
/*
 * Code used to generate %ZHSLIB.KitManager and other helper methods for applying
 * restrictions on HSLIB depending on the type of kit (based on which non-HSLIB
 * library databases are present (example: if VIEWERLIB is present then only allow
 * creation of Viewer Access Gateways).
 * ######################################## BEGIN #######################################
 */
]]></Content>
</UDLText>

<XData name="KitRestrictions">
<Description>
Kit restrictions to be applied based on which library database(s) is/are present.</Description>
<Internal>1</Internal>
<MimeType>application/json</MimeType>
<Data><![CDATA[
{
	"VIEWERLIB": {
		"$ErrorMessage": "Not accessible on a Clinical Viewer instance and must be run on a Unified Care Record instance.",
		"HS.Util.Installer": {
			"RestrictedMethods": [
				"Install",
				"InstallDemo",
				"InstallBusDemo"
			]
		},
		"HS.UI.Installer.Welcome": {
			"AllowedButtons": [
				"ConfigureNetworkHost",
				"ConfigureSSLAccess",
				"ConfigureOAuthNetworkInfo",
				"ConfigureAccessGateway",
				"ConfigureFoundation"
			]
		},
		"HS.Util.Installer.AccessGateway": {
			"AllowedTemplates": [
				"HS.Sample.Production.AccessGateway.ViewerProduction"
			]
		}
	},
	"HSLIB": {
		"HS.Util.Installer.AccessGateway": {
			"RestrictedTemplates": [
				"HS.Sample.Production.AccessGateway.ViewerProduction"
			]
		}
	}
}
]]></Data>
</XData>

<Method name="GetHSRestrictionKey">
<Description><![CDATA[
Returns the restriction key for this kit which determines which key to use in KitRestrictions. <br />
Returns "" if no kit restriction found. <br />
@Argument	pKitRestrictionJson			JSON object containing contents of KitRestrictions XData block. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pKitRestrictionJson:%Library.DynamicObject</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	// Parse databases in reverse order because the ones that should be initialized last
	// are the ones that are the primary components of their respective instances
	// (ex. in a Personal Community kit, HSCOMMLIB restrictions should override HSLIB restrictions)
	Set reverseDatabaseList = ..GetReverseOrderedDatabaseList()
	Set ptr = 0
	While $ListNext(reverseDatabaseList, ptr, database) {
		// If library database exists AND a kit restriction file for it exists, use it.
		If ##class(%Library.File).DirectoryExists($$$HSLibraryDatabaseDirectory(database)) && $IsObject(pKitRestrictionJson.%Get(database)) {
			Return database
		}
	}
	Return ""
]]></Implementation>
</Method>

<Method name="GenerateHSKitManager">
<Description><![CDATA[
Based on <xdata>KitRestrictions</xdata>, generate HealthShare Kit Manager to manage user access
to parts of HSLIB. <br />
Throws errors. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	// Either open existing class definition (during upgrades) or create a new one
	If ##class(%Dictionary.ClassDefinition).%ExistsId($$$HSKitManagerClassname) {
		Set classDefinition = ##class(%Dictionary.ClassDefinition).%OpenId($$$HSKitManagerClassname, , .sc)
		$$$ThrowOnError(sc)
	} Else {
		Set classDefinition = ##class(%Dictionary.ClassDefinition).%New()
		Set classDefinition.Name = $$$HSKitManagerClassname
		Set classDefinition.ProcedureBlock = 1
		Set classDefinition.Description = "Kit manager class that is generated during kit build in build.MAC. Controls restrictions to parts of HSLIB."
		Set classDefinition.GeneratedBy = $Classname()
	}
	
	// Generate the only method: HasAccessTo()
	
	Set methodDefinition = ##class(%Dictionary.MethodDefinition).%New()
	Set methodDefinition.ClassMethod = 1
	Set methodDefinition.Name = "HasAccessTo"
	Set methodDefinition.Description = "Return the components that a kit has access to. <br />"_$$$NL_
		"@API.Method"_$$$NL_
		"@Argument	pErrorMessage	Error message to use when kit restrictions are not met. <br />"_$$$NL_
		"@Argument	pClassname		Name of class for which restrictions need to be checked. <br />"_$$$NL_
		"@Argument	pArguments...	Optional feature (possibly nested) and its value to be checked. <br />"
	Set methodDefinition.FormalSpec = "*pErrorMessage:%String,pClassname:%Dictionary.Classname,pArguments..."
	
	Set implementation = ##class(%Stream.TmpCharacter).%New()
	#define Tab $Char(9)
	#define Tabs(%num) ##class(%ZHSLIB.HealthShareMgr).RepeatString($$$Tab, %num)
	#define WriteLine(%line) Do implementation.WriteLine($$$Tab_%line)
	
	// Load JSON file into a dynamic object
	Set xData = ##class(%Dictionary.CompiledXData).%OpenId($Classname()_"||KitRestrictions", , .sc)
	$$$ThrowOnError(sc)
	Set stream = xData.Data
	#dim kitRestrictionsJson As %Library.DynamicAbstractObject
	Set kitRestrictionsJson = ##class(%Library.DynamicAbstractObject).%FromJSON(stream)
	
	Set restrictionKey = ..GetHSRestrictionKey(kitRestrictionsJson)
	If (restrictionKey = "") {
		Return
	}
	Set databaseRestrictions = kitRestrictionsJson.%Get(restrictionKey)
	// If restrictions found, then generate access check code.
	If $IsObject(databaseRestrictions) {
		$$$WriteLine("Set pErrorMessage = "_$$$QUOTE(databaseRestrictions.%Get("$ErrorMessage")))
		// Iterate classnames
		#dim databaseRestrictions As %Library.DynamicObject
		#dim classIterator As %Iterator.Object
		Set classIterator = databaseRestrictions.%GetIterator()
		While classIterator.%GetNext(.classname, .classRestrictions) {
			// Skip any property prefixed by $ as it's metadata and not a classname
			If (classname [ "$") {
				Continue
			}
			$$$WriteLine("If (pClassname = "_$$$QUOTE(classname)_") {")
			#dim classRestrictions As %Library.DynamicObject
			#dim restrictionsIterator As %Iterator.Object
			Set restrictionsIterator = classRestrictions.%GetIterator()
			While restrictionsIterator.%GetNext(.name, .value) {
				Do ..GenerateConditionsForFeature(implementation, name, value)
			}
			$$$WriteLine("}")
		}
	}
	$$$WriteLine("Return 1")
	Set methodDefinition.Implementation = implementation
	
	$$$ThrowOnError(classDefinition.Methods.Clear())
	$$$ThrowOnError(classDefinition.Methods.Insert(methodDefinition))
	$$$ThrowOnError(classDefinition.%Save())
	$$$ThrowOnError($System.OBJ.Compile($$$HSKitManagerClassname, "ck"))
]]></Implementation>
</Method>

<Method name="GenerateConditionsForFeature">
<Description><![CDATA[
Code generation for a single feature. <br />
@Argument	pStream				Stream to write generated code to. <br />
@Argument	pName				Name of the feature. <br />
@Argument	pValue				Value of the feature. <br />
@Argument	pArgumentCounter	Counter to keep track of how far nested the feature
is in the pArguments array of the generated method in the HS Kit Manager class. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pStream:%Stream.Object,pName:%String,pValue:%Library.DynamicAbstractObject,pArgumentCounter:%Integer=1</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	#define Tab $Char(9)
	#define Tabs(%num) ##class(%ZHSLIB.HealthShareMgr).RepeatString($$$Tab, %num)
	#define WriteLine(%line) Do pStream.WriteLine($$$Tab_%line)
	// Name of the feature
	#dim feature As %String
	Set isAllowed = ""
	// Parse name to check if it has prefix of Allowed or Restricted
	If $Match(pName, "Allowed.*") {
		Set feature = $Piece(pName, "Allowed", 2)
		Set isAllowed = 1
	} ElseIf $Match(pName, "Restricted.*") {
		Set feature = $Piece(pName, "Restricted", 2)
		Set isAllowed = 0
	} Else {
		Set feature = pName
	}
	
	Set tabNumber = pArgumentCounter
	$$$WriteLine($$$Tabs(tabNumber)_"If ($Get(pArguments("_pArgumentCounter_")) = "_$$$QUOTE(feature)_") {")
	Do $Increment(pArgumentCounter)
	If (feature '= pName) {
		// Had prefix so the value is a dynamic array
		Set featureList = ""
		Set featureValueIterator = pValue.%GetIterator()
		While featureValueIterator.%GetNext(, .featureValue) {
			Set featureList = featureList _ $ListBuild(featureValue)
		}
		Set negation = $Case(isAllowed, "":"", 1:"''", 0:"'")
		Set formattedList = ##class(%Library.Utility).FormatString(featureList)
		$$$WriteLine($$$Tabs(tabNumber+1)_"Return "_negation_"$ListFind("_formattedList_", $Get(pArguments("_pArgumentCounter_")))")
	} Else {
		// No prefix so need to dig deeper
		Set featureIterator = pValue.%GetIterator()
		While featureIterator.%GetNext(.featureName, .featureValue) {
			Do ..GenerateConditionsForFeature(pStream, featureName, featureValue, pArgumentCounter)
		}
	}
	$$$WriteLine($$$Tabs(tabNumber)_"}")
]]></Implementation>
</Method>

<Method name="RepeatString">
<Description><![CDATA[
Helper method to replicate a string a given number of times. <br />
@Argument	pString		String to replicate. <br />
@Argument	pNumber		Number of times to replicate. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pString:%String,pNumber:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set string = ""
	For i=1:1:pNumber {
		Set string = string _ pString
	}
	Return string
]]></Implementation>
</Method>

<Parameter name="RequiredStartupItemBase">
<Type>STRING</Type>
<Default>%ZHSLIB.AbstractStartupItem</Default>
</Parameter>

<Method name="StartStartupItems">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pLogFile:%File,pContext:%String]]></FormalSpec>
<Implementation><![CDATA[
	#def1arg WriteToConsoleLog(%args) Do ##class(%SYS.System).WriteToConsoleLog(%args)
	
	New $Namespace
	
	Set $Namespace = "HSLIB"
	
	Try {
		Do ..GetStartupItems(.startupItems)
		
		Set startedOne = 0
		
		Set startupIndex = ""
		
		For {
			Set startupIndex = $Order(startupItems(startupIndex))
			If startupIndex = "" Quit
			
			Try {
				Set $Namespace = "HSLIB"
				
				Set class = startupItems(startupIndex, "Class")
				
				// Initialize name to class in case class does not exist and we throw error.
				Set name = class
				Set name = $Parameter(class, "Name")
				If name = "" {
					Set name = class
				}
				
				Set requiredSuper = ..#RequiredStartupItemBase
				If '$ClassMethod(class, "%Extends", requiredSuper) {
					$$$ThrowStatus($$$ERROR($$$GeneralError, class _ " does not extend " _ requiredSuper))
				}
				
				// This class must be permitted to run in the current startup context (1 - startup or 2 - become primary, also startup for non-mirrored ).
				If pContext && ($Parameter(class, "ExecutionContext") '= pContext) {
					Continue
				}
				
				// Class must implement class method "OnSystemStartup", with no input parameters.
				Job $ClassMethod(class, "OnSystemStartup")::10
				
				If '$T {
					Set text = "JOB command timed out"
					$$$ThrowStatus($$$ERROR($$$GeneralError, text))
				}

				// log last start of class
				Set ^%SYS("HealthShare", "SystemStartup",class)=$H
				If 'startedOne {
					Set text = $Classname() _ " started items for " _ $Select(pContext=1:"Startup",2:"Failover",1:"Startup and Failover") _ " context. Check relevant log files and Event Logs for outcomes."
					$$$WriteToConsoleLog(text, 1)
					Set startedOne = 1
				}
				
			} Catch executeEx {
				Set executeStatus = executeEx.AsStatus()
				Set name = $Get(name, "(unknown name)")
				$$$WriteToConsoleLog($Classname() _ " startup of item '" _ name _ "' failed: " _ $system.Status.GetErrorText(executeStatus), 1, 3)
			}
		}
		
	} Catch mainEx {
		Set mainStatus = mainEx.AsStatus()
		$$$WriteToConsoleLog($Classname() _ " startup item loop failed: " _ $system.Status.GetErrorText(mainStatus), 1, 3)
	}
	
	Return
]]></Implementation>
</Method>

<Method name="GetStartupItems">
<Description>
Abstract the manner in which startup item data is obtained.
Return an array of pStartupItems(index, property) = value</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pStartupItems</FormalSpec>
<Implementation><![CDATA[
	Kill pStartupItems
	
	Set class = ""
	
	For {
		Set class = $Order(^%SYS("HealthShare", "SystemStartup", class))
		If class = "" Quit
		Do $i(startupIndex)
		Set pStartupItems(startupIndex, "Class") = class
	}
	
	Quit
]]></Implementation>
</Method>

<Method name="InsertStartupItem">
<Description><![CDATA[
@API<br>
API method for adding an item to the startup table.<br>
Input:<br>
- pClass: (required) Class name for startup item. Will be treated as unique - multiple adds
          of the same class will end up with only single startup item. Class must extend
          <class>%ZHSLIB.AbstractStartupItem</class> either directly or indirectly.<br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClass:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set status = $$$OK
	
	Try {
		Set requiredSuper = ..#RequiredStartupItemBase
		If '$ClassMethod(pClass, "%Extends", requiredSuper) {
			$$$ThrowStatus($$$ERROR($$$GeneralError, pClass _ " does not extend " _ requiredSuper))
		}
		
		Set ^%SYS("HealthShare", "SystemStartup", pClass) = ""
		
	} Catch eException {
		Set status = eException.AsStatus()
	}
	
	Return status
]]></Implementation>
</Method>

<Method name="RemoveStartupItem">
<Description><![CDATA[
@API<br>
API method for removing an item from the startup table.<br>
Inputs:<br>
- pClass: (required) Class name for startup item to remove.<br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClass:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set status = $$$OK
	
	Try {
		Kill ^%SYS("HealthShare", "SystemStartup", pClass)
		
	} Catch eException {
		Set status = eException.AsStatus()
	}
	
	Return status
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
/*
 * ######################################## END #######################################
 */
]]></Content>
</UDLText>

<Method name="FixSystemSecurityVersion">
<Description><![CDATA[
Helper method for customers on IRIS 2020.1 based versions of HS to fix their
security version due to the core-tech adhoc of IRIS for those HS versions providing
a higher security version than it should have had. <br />
This method can be run from any namespace. <br />
@API.Method <br />]]></Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	Set expectedSecurityVersion = "2020.1"
	Set version = $System.Version.GetNumber()
	If (version '= expectedSecurityVersion) {
		Write !, "Underlying IRIS version is not "_expectedSecurityVersion_" so this method is not runnable"
		Return
	}
	If $Get($$$SecurityGlobalVersion) > expectedSecurityVersion {
		Set $$$SecurityGlobalVersion = expectedSecurityVersion
	}
	Write !, "Successfully update security version"
]]></Implementation>
</Method>
</Class>


<Routine name="%ZHSLIB" type="INC" timestamp="67214,49066.3568295"><![CDATA[
#; Role/ Resource related macros
#define GroupPrefix   "HSGroup_"
/// Username of HS Services user
#define HSServiceUserName "HS_Services"
/// Role assigned to HS Services user
#define HSServiceRole "%HS_ServiceRole"
#; Deprecated as services user and role created on installation so no need to
#; create again.
#define HSServiceUserGetMake $$$HSServiceUserName
#define HSServiceRoleGetMake $$$HSServiceRole

#define HSTaskUserName "_Ensemble"
#define HSRolesPrefixList $ListBuild("HS", "%HS", "MPRL_")
#define HSSystemRolesPrefixList $ListBuild("%HS", "MPRL_", "HSPortal")
#define HSUserRolesPrefixList $ListBuild("HS")
#define HSDatabaseRolesPrefixList $ListBuild("%HS_DB")
#define StartSwitch(%PERMISSION)   If '$SYSTEM.Security.Check(%PERMISSION,$$$PermWriteName) {Quit $$$ERROR($$$GeneralError,"Insufficient Privileges to perform operation")} $$$StartSwitchNP
#define StartSwitchNP   Set $ZT="Trap" Set tStatus=$$$OK $$$AddAllRoleTemporary Set tLocation=$zu(5) Set tNS=$zu(5,"%SYS") if tNS'="%SYS" {zt ("Unable To Switch Namespaces") } 
#define PermWriteName "WRITE"
#define PrefixMatch(%value, %prefix) ($Extract(%value, 1, $Length(%prefix)) = %prefix)

#; SSL/TLS information for the instance

/// Network Host Name to use for making connections to this instance.
#define HSNetworkHostName 					$S($G(^|"HSSYS"|%SYS("HealthShare","NetworkHostName"))]"":^("NetworkHostName"),1:$ZConvert($ZU(54,0),"L"))
/// $$$HSSecureHostName is deprecated, as the host name used for SSL should be the same as the network host name. Use $$$HSNetworkHostName instead.
#define HSSecureHostName $$$HSNetworkHostName
/// Port to use for secure communication with this instance.
#define HSSecurePort     					$Select($G(^|"HSSYS"|%SYS("HealthShare","SSLAccess", "Port"))="443": "", 1: $G(^|"HSSYS"|%SYS("HealthShare","SSLAccess", "Port")))
/// Prefix to use for secure communication with this instance.
#define HSSecurePrefix   					$G(^|"HSSYS"|%SYS("HealthShare","SSLAccess", "Prefix"))
/// Whether to use secure communication settings set for this instance.
#; Ensure macro always returns a boolean value
#define HSSecureIsActive 					''$G(^|"HSSYS"|%SYS("HealthShare","SSLAccess", "Active"))
/// IRIS SSL/TLS Configuration to use when using secure communication with this instance.
#define HSSecureSSLConfig	                $G(^|"HSSYS"|%SYS("HealthShare","SSLAccess", "SSLConfig"))

#define SetHSNetworkHostName(%host) 		Set ^|"HSSYS"|%SYS("HealthShare","NetworkHostName") = %host
/// SetHSSecureHostName is deprecated as $$$HSSecureHostName is deprecated
#define SetHSSecureHostName(%host)			$$$SetHSNetworkHostName(%host)
#define SetHSSecurePort(%port)				Set ^|"HSSYS"|%SYS("HealthShare","SSLAccess", "Port") = %port
#define SetHSSecurePrefix(%prefix)			Set ^|"HSSYS"|%SYS("HealthShare","SSLAccess", "Prefix") = %prefix
#define SetHSSecureActive(%active)			Set ^|"HSSYS"|%SYS("HealthShare","SSLAccess", "Active") = %active
#define SetHSSecureSSLConfig(%sslconfig)	Set ^|"HSSYS"|%SYS("HealthShare","SSLAccess", "SSLConfig") = %sslconfig

/// Unique global time string "65324-00123-000456" (with padding) with %timeStamp = $ZTIMESTAMP format for better readability
#define UniqueGlobalTimeStampString(%timeStamp) $Piece(%timeStamp,",",1)_"-"_$Extract(100000+$Piece($Piece(%timeStamp,",",2),".",1),2,*)_"-"_$Extract(1000000+$Piece($Piece(%timeStamp,",",2),".",2),2,*)
/// Insert unique global time string (for better sortability) to the original InitiatingLogId formular to force uniqueness even when ^HS.Audit gets cleared
#define UniqueGlobalLoginID(%timeStamp) $ZU(131,1)_":"_$ZNSPACE_":"_$$$UniqueGlobalTimeStampString(%timeStamp)_":"_$Increment(^HS.Audit("LogCounter"))

#; Used in %ZHSLIB.HealthShareMgr:OnStartHealthShare() to keep track of
#; items to run during instance startup/mirror failover. IS NOT mirrored.

#define OnStartGbl ^%SYS("HealthShareLocal","OnStartHealthShare")
#def1arg OnStartGblArgs(%args) ^%SYS("HealthShareLocal","OnStartHealthShare",%args)
#define OnStartGblUpgradeSteps $$$OnStartGblArgs("UpgradeSteps")
#def1arg OnStartGblUpgradeStepsArgs(%args) $$$OnStartGblArgs("UpgradeSteps",%args)

#; Resources/Roles available on all HS/I4H/HC instances

#define HSAdminConsentManagement "%HSAdmin_ConsentManagement"
#define HSAdminFacilityConsentManagement "%HSAdmin_FacilityConsentManagement"
#define HSAdministrator "%HS_Administrator"
#define HSEmergencyAccess "%HS_EmergencyAccess"
#define HSGroupAssignment "%HSAdmin_GroupAssignment"
#define HSHubManagement "%HSAdmin_HubManagement"
#define HSBusManagement "%HSAdmin_BusManagement"
#define HSGatewayManagement "%HSAdmin_GatewayManagement"
#define HSInstallationManagement "%HSAdmin_InstallationManagement"
#define HSUserManagement "%HSAdmin_UserManagement"
#define HSFacilityUserManagement "%HSAdmin_FacilityUserManagement"
#define HSGroupManagement "%HSAdmin_GroupManagement"
#define HSPatientRetrieval "%HS_PatientRetrieval"
#define HSPatientRegistration "%HS_PatientRegistration"
#define HSPatientSearch "%HS_PatientSearch"
#define HSProviderSearch "%HS_ProviderSearch"
#define HSSystemService "%HS_SystemService"

#define HSFacilTaskErr						"<HSErr>BadFacilityUpdateType"
	;#Audit Includes
#define HSAudErrBadEventID					"<HSErr>BadAuditEventID"
#define HSAudErrMissingUserID				"<HSErr>MissingAuditUserID"
#define HSAudErrMissingOtherEvent			"<HSErr>MissingAuditOtherEvent"
#define HSAudErrBadParticipantType			"<HSErr>BadAuditParticipantType"
#define HSAudErrMissingOtherType			"<HSErr>MissingAuditOtherType"
#define HSAudErrMissingIdentifier			"<HSErr>MissingAuditIdentifier"
#define HSAudErrMissingParentLog			"<HSErr>MissingAuditParentLog"
#define HSAudErrOverwriteSDA				"<HSErr>AttemptToOverwriteAuditSDA"
#define HSAudErrOverwriteIHE				"<HSErr>AttemptToOverwriteIHEAuditMessage"
#define HSAudErrSaveIHEType					"<HSErr>AttemptToSaveNonIHEAuditMessage"
#define HSAudErrAddSDANoLog					"<HSErr>AddAuditSDALogNotFound"
 
#define HSAudit
 
#IfDef HSAudit
#define HSAuditPatientSearch(%Log,%Criteria,%ProxyUserID) ##Class(HS.Audit.LogSimple).PatientSearch(%Log,%Criteria,%ProxyUserID)
#define HSAuditSearchPatient(%Id,%User,%Roles,%Gateway,%MPIlist,%MRNlist,%Criteria,%BreakGlass,%ESession,%ProxyUserID) ##Class(HS.Audit.LogSimple).SearchPatient(%Id,%User,%Roles,%Gateway,%MPIlist,%MRNlist,%Criteria,%BreakGlass,%ESession,%ProxyUserID)
#define HSAuditRecordRequest(%Id,%User,%Roles,%Gateway,%MRN,%SDA,%Criteria,%BreakGlass,%ESession,%ProxyUserID,%PatName,%MPIID) ##Class(HS.Audit.LogSimple).RecordRequest(%Id,%User,%Roles,%Gateway,%MRN,%SDA,%Criteria,%BreakGlass,%ESession,%ProxyUserID,%PatName,%MPIID)
#define HSAuditRecordRequestV2(%Id,%User,%Roles,%Gateway,%MRN,%SDA,%Criteria,%BreakGlass,%ESession,%ProxyUserID,%PatName,%MPIID,%EdgeSession) ##Class(HS.Audit.LogSimple).RecordRequest(%Id,%User,%Roles,%Gateway,%MRN,%SDA,%Criteria,%BreakGlass,%ESession,%ProxyUserID,%PatName,%MPIID,%EdgeSession)
#define HSAuditViewRecords(%LogID,%InitId,%User,%Roles,%Gateway,%MRNlist,%ESession,%ProxyUserID,%PatName,%MPIlist) ##Class(HS.Audit.LogSimple).ViewRecords(%LogID,%InitId,%User,%Roles,%Gateway,%MRNlist,%ESession,%ProxyUserID,%PatName,0,%MPIlist)
#define HSAuditExportRecords(%LogID,%InitId,%User,%Roles,%Gateway,%MRNlist,%ESession,%ProxyUserID,%PatName,%MPIlist) ##Class(HS.Audit.LogSimple).ViewRecords(%LogID,%InitId,%User,%Roles,%Gateway,%MRNlist,%ESession,%ProxyUserID,%PatName,1,%MPIlist)
#define HSAuditAddSDA(%ID,%SDA) ##Class(%ZHSLIB.Audit.Log).AddSDA(%ID,%SDA)
#define HSAuditConsentPolicy(%User,%Roles,%Gateway,%MPIID,%Policies,%Type,%PatName) ##Class(HS.Audit.LogSimple).ConsentUpdate(%User,%Roles,%Gateway,%MPIID,%Policies, %Type,%PatName)
#define HSAuditConsentEvaluation(%Id,%User,%Roles,%Gateway,%MRN,%MPIID,%BreakGlass,%PolicySnapshots,%ESession,%ProxyUserID,%PatName) ##Class(HS.Audit.LogSimple).ConsentEvaluation(%Id,%User,%Roles,%Gateway,%MRN,%MPIID,%BreakGlass,%PolicySnapshots,%ESession,%ProxyUserID,%PatName)
#define HSAuditDocumentRequest(%User,%Roles,%Gateway,%MPIID,%DocumentId,%Source,%PatName) ##Class(HS.Audit.LogSimple).DocumentRequest(%User,%Roles,%Gateway,%MPIID,%DocumentId,%Source,%PatName)
#define HSAuditDocumentSend(%User,%Roles,%Gateway,%MPIID,%DocumentId,%Source,%PatName,%DocType) ##Class(HS.Audit.LogSimple).DocumentSend(%User,%Roles,%Gateway,%MPIID,%DocumentId,%Source,%PatName,%DocType)
#define HSAuditAddRemoveRelationship(%User,%Roles,%Gateway,%MPIID,%AddOrRemove,%Details,%PatName,%MRNs) ##Class(HS.Audit.LogSimple).AddRemoveRelationShip(%User,%Roles,%Gateway,%MPIID,%AddOrRemove,%Details,%PatName,%MRNs)
#define HSAuditAddRemoveRelationshipWithNote(%User,%Roles,%Gateway,%MPIID,%AddOrRemove,%Details,%PatName,%MRNs,%Note) ##Class(HS.Audit.LogSimple).AddRemoveRelationShip(%User,%Roles,%Gateway,%MPIID,%AddOrRemove,%Details,%PatName,%MRNs,%Note)
#define HSAuditActorStart(%Actor) ##Class(HS.Audit.LogSimple).ActorStart(%Actor)
#define HSAuditActorStop(%Actor) ##Class(HS.Audit.LogSimple).ActorStop(%Actor)
#define HSAuditPasswordResetRequested(%LoginID,%Domain) ##Class(%ZHSLIB.UsersAndRoles).PasswordResetRequested(%LoginID, %Domain)
#define HSAuditPasswordResetSendEmailFailure(%LoginID,%Domain,%Details) ##Class(%ZHSLIB.UsersAndRoles).PasswordResetSendEmailFailure(%LoginID,%Domain,%Details)
#define HSAuditPasswordResetFailure(%LoginID,%Domain,%Details) ##Class(%ZHSLIB.UsersAndRoles).PasswordResetFailure(%LoginID,%Domain,%Details)
#define HSAuditPasswordResetSuccess(%LoginID,%Domain) ##Class(%ZHSLIB.UsersAndRoles).PasswordResetSuccess(%LoginID,%Domain)


#Else
#define HSAuditPatientSearch(%Log,%Criteria,%ProxyUserID) $$$OK
#define HSAuditSearchPatient(%Id,%User,%Roles,%Gateway,%MPIlist,%MRNlist,%Criteria,%ESession,%ProxyUserID) $$$OK
#define HSAuditRecordRequest(%Id,%User,%Roles,%Gateway,%MRN,%SDA,%ESession,%ProxyUserID,%PatName,%MPIID) $$$OK
#define HSAuditViewRecords(%LogID,%InitId,%User,%Roles,%Gateway,%MRNlist,%ESession,%ProxyUserID,%PatName,%MPIlist) $$$OK
#define HSAuditAddSDA(%ID,%SDA) $$$OK
#define HSAuditConsentPolicy(%User,%Roles,%Gateway,%MPIID,%Policies, %Type,%PatName) $$$OK
#define HSAuditConsentEvaluation(%Id,%User,%Roles,%Gateway,%MRN,%MPIID,%BreakGlass,%PolicySnapshots,%ESession,%ProxyUserID,%PatName) $$$OK
#define HSAuditDocumentRequest(%User,%Roles,%Gateway,%MPIID,%DocumentId,%Source,%PatName) $$$OK
#define HSAuditDocumentSend(%User,%Roles,%Gateway,%MPIID,%DocumentId,%Source,%PatName) $$$OK
#define HSAuditAddRemoveRelationship(%User,%Roles,%Gateway,%MPIID,%AddOrRemove,%Details,%PatName) $$$OK
#define HSAuditActorStart(%Actor) $$$OK
#define HSAuditActorStop(%Actor) $$$OK
#define HSAuditPasswordResetRequested(%LoginID, %Domain) $$$OK
#define HSAuditPasswordResetSendEmailFailure(%LoginID,%Domain,%Details) $$$OK
#define HSAuditPasswordResetFailure(%LoginID,%Domain,%Details) $$$OK
#define HSAuditPasswordResetSuccess(%LoginID,%Domain) $$$OK

#EndIf

	;Licensing
	//#define HSLicenseTest

	;For testing, until we get real keys to play with
#IfDef HSLicenseTest
#define HSLicensed(%Component) '$D(^%SYS("HealthShare","TestLicenseFail",%Component))

#Else
#define HSLicensed(%Component) $System.License.IsAppLicensed("ISC.HealthShare",%Component)
#EndIf
#; Needed to run on IRIS
#include %syAudit
#define DatabaseFilename $S($$$IsIRIS:"IRIS.DAT",1:"CACHE.DAT")
#define HSisHealthShare 	0
#define HSisHealthConnect 	1
#define HSisIRISforHealth 	2
#define IsIRIS $S($zv["IRIS":1,1:0)
/// Get the directory that contains the *.DAT file for the given HS database
/// DO NOT modify to use $System.Util.ManagerDirectory() because it is not the same as 
/// $System.Util.InstallDirectory_"mgr/" on docker containers.
#define HSLibraryDatabaseDirectory(%db) ##class(%Library.File).NormalizeDirectory($System.Util.InstallDirectory()_"mgr/"_$ZConvert(%db, "l"))
#define HSNonLibDatabaseDirectory(%db) $Select(##class(%SYS.Namespace).GetRoutineDest(%db)'="": ##class(%SYS.Namespace).GetRoutineDest(%db), 1: ##class(%Library.File).NormalizeDirectory($System.Util.ManagerDirectory()_$ZConvert(%db, "l")))
#define HSDatabaseDirectory(%db) $Select($Extract($ZConvert(%db, "l"), *-2,*)="lib":$$$HSLibraryDatabaseDirectory(%db), 1:$$$HSNonLibDatabaseDirectory(%db))

/// Stores boolean value for each subscripted database as to whether it exists on this instance.
#define HSLibraryDatabaseExistsGlobal(%db) ^%SYS("HealthShare", "ComponentDatabase", %db)
#If $$$IsIRIS
#define	HSAuditGbl $$$AuditGbl
#Else
#define HSAuditGbl $$$CacheAuditGbl
#EndIf

/// Global that stores the kit build number
#define BuildNumberGbl ^|("^^"_$$$HSLibraryDatabaseDirectory("hslib"))|HS.Upgrade("FullBuildNumber")

#; web browser tab icon handling 2018.1+ and 2018.1-.
#if ('$data(^rINC("%products")))
#define ISCFAVORITEICON "portal/icon_healthshare.png"
#else
#include %products
#endif

/// Whether instance is in a container
#define InAContainer  (($system.Util.InstallDirectory()_"mgr")'=$E($system.Util.ManagerDirectory(),1,*-1))

#; Macros for the subscripts of the returned array from %ZHSLIB.HealthShareMgr:GetComponentArray
/// Subscript which holds the License name for a library database
#define SubscriptLicense "License"
/// Subscript which holds the Module name for a library database
#define SubscriptModule "Module"
/// Subscript which holds the Version String name for a library database
#define SubscriptVersionString "VersionString"
/// Subscript which holds the Build Spec name for a library database
#define SubscriptBuildSpec "BuildSpec"

#; Macros for generation of KitManager class

/// Name of kit manager class
#define HSKitManagerClassname "%ZHSLIB.KitManager"

#; Error macros for %ZHSLIB.Context
#; TODO: should be moved to localization file

/// Service not available because some exception occurred while retrieving service
#define ServiceNotAvailable(%key, %majorVersion, %minMinorVersion) $$$ERROR($$$GeneralError, "Service not available: "_%key_" @ Major Version: "_%majorVersion_", Minimum Minor Version: "_%minMinorVersion)
/// Service not found matching given conditions
#define ServiceNotFound(%key, %majorVersion, %minMinorVersion) $$$ERROR($$$GeneralError, "Service not found: "_%key_" @ Major Version: "_%majorVersion_", Minimum Minor Version: "_%minMinorVersion)

#; Macros for confuguring SSL access and establishing a Demo TLS/SSL Configuration

/// Name of the demo SSL configuration created by %ZHSLIB.TLS.API
#define HSDemoSSLConfigName "HS.Secure.Demo"

#; Globals to track whether the instance is undergoing installation/upgrade

/// Whether we are in an installation/upgrade.
#define InInstanceInstallation ($Data(^%SYS("Ensemble","RunOnce","InitializeEnsemble")))
]]></Routine>


<Class name="%ZHSLIB.LockManager">
<Description><![CDATA[
Internal use of LockManager to be available systemwide and accessible from application namespaces
Internal replacement of %IPM.Utils.LockManager
Utility to make managing locking/unlocking easier in more complex settings.
Usage pattern:
<ol>
<li>Create an instance of this class at the beginning of a method.</li>
<li>Call the Lock() and (optionally) Unlock() methods.</li>
<li>When the object goes out of scope, remaining locks are automatically released with the correct flags.</li>
</ol>]]></Description>
<Super>%RegisteredObject</Super>
<TimeChanged>67214,49066.4600196</TimeChanged>
<TimeCreated>67214,49066.4600196</TimeCreated>

<Property name="Cache">
<Description><![CDATA[
Map of (<global>,<flags>) to lock count]]></Description>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="OIDCache">
<Description><![CDATA[
Map of (<class>,<id>) to lock count]]></Description>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="ImmediateReleaseOnClose">
<Description>
If true, locks are released immediately when the instance of this class goes out of scope.
(If not, standard handling for transactions will apply instead.)</Description>
<Type>%Boolean</Type>
<Private>1</Private>
</Property>

<Method name="%OnNew">
<Description><![CDATA[
Set <var>pImmediateRelease</var> to 0 to keep locks in an instance of this class
until the end of the current transaction even once the instance goes out of scope.]]></Description>
<FormalSpec>pImmediateRelease:%Boolean=1</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set ..ImmediateReleaseOnClose = pImmediateRelease
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Lock">
<FormalSpec>pGlobalName:%String,pFlags:%String="",pTimeout:%Integer=$$$LockTimeout</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Lock +@pGlobalName#pFlags:pTimeout
		If '$Test {
			Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Failed to lock %1",pGlobalName))
			Quit
		}
		
		If $Increment(i%Cache(pGlobalName,$Case(pFlags,"":$c(0),:pFlags)))
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="Unlock">
<FormalSpec>pGlobalName:%String,pFlags:%String="",pImmediate:%Boolean=0,pUpdateCache:%Boolean=1</FormalSpec>
<Implementation><![CDATA[
	If (pFlags = $c(0)) {
		Set pFlags = ""
	}
	Lock -@pGlobalName#pFlags_$Select(pImmediate:"I",1:"")
	If pUpdateCache {
		Set i%Cache(pGlobalName,$Case(pFlags,"":$c(0),:pFlags)) = $Get(i%Cache(pGlobalName,$Case(pFlags,"":$c(0),:pFlags)),0) - 1
		If (i%Cache(pGlobalName,$Case(pFlags,"":$c(0),:pFlags)) <= 0) {
			Kill i%Cache(pGlobalName,$Case(pFlags,"":$c(0),:pFlags))
		}
	}
]]></Implementation>
</Method>

<Method name="LockClassId">
<FormalSpec>pClassName:%Dictionary.Classname,pID:%String,pShared:%Boolean=0,pTimeout:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $classmethod(pClassName,"%LockId",pID,pShared,.pTimeout)
	If $$$ISOK(tSC) {
		Set tOID = $$$oidCompose(pID,pClassName)
		Set i%OIDCache(tOID,pShared) = $Get(i%OIDCache(tOID,pShared)) + 1
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="UnlockClassId">
<FormalSpec>pClassName:%Dictionary.Classname,pID:%String,pShared:%Boolean=0,pImmediate:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	Set tOID = $$$oidCompose(pID,pClassName)
	If $Data(i%OIDCache(tOID,pShared),tLockCount) {
		Do $classmethod(pClassName,"%UnlockId",pID,pShared,pImmediate)
		Set i%OIDCache(tOID,pShared) = tLockCount - 1
	}
]]></Implementation>
</Method>

<Method name="UnlockAll">
<FormalSpec>pImmediate:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tGlobalName = ""
		For {
			Set tGlobalName = $Order(i%Cache(tGlobalName))
			If (tGlobalName = "") {
				Quit
			}
			Set tFlags = ""
			For {
				Set tFlags = $Order(i%Cache(tGlobalName,tFlags),1,tLockCount)
				If (tFlags = "") {
					Quit
				}
				For i=1:1:tLockCount {
					Do ..Unlock(tGlobalName,tFlags,pImmediate,0)
				}
			}
		}
		Kill i%Cache
		
		Set tOID = ""
		For {
			Set tOID = $Order(i%OIDCache(tOID))
			If (tOID = "") {
				Quit
			}
			Set tShared = ""
			For {
				Set tShared = $Order(i%OIDCache(tOID,tShared),1,tLockCount)
				If (tShared = "") {
					Quit
				}
				Set tID = $$$oidPrimary(tOID)
				Set tClassName = $$$oidClassName(tOID)
				For i=1:1:tLockCount {
					Do ..UnlockClassId(tClassName,tID,tShared,pImmediate)
				}
			}
		}
		Kill i%OIDCache
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%OnClose">
<Description>
Performs an immediate unlock </Description>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	Quit ..UnlockAll(..ImmediateReleaseOnClose)
]]></Implementation>
</Method>

<Method name="LockClassesRecursive">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pLockManager=..%New(),&pClasses,&pSharedLockedClasses]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Based on LockClassesRecursive^%occLock.
	// This method (and the rest of the class to support it) is really just a workaround for PL 149632
	Set tSC = $$$OK
	Try {
		Set tLockManager = ..%New()
		Merge tVisited = pSharedLockedClasses
		Set tClassKey = ""
		For {
			Set tClassKey = $Order(pClasses(tClassKey))
			If (tClassKey = "") {
				Quit
			}
			
			Set tClassName = tClassKey
			If ($ZConvert($Extract(tClassKey,*-3,*),"U") = ".CLS") {
				// This isn't actually a legal classname - must be class with extension included.
				Set tClassName = $Extract(tClassKey,1,*-4)
			}
			
			// Based on lockoneclassrecursive^%occLock, but locks each dependency in shared mode.
			// We always lock the top-level class, because it may need to be locked exclusively; pVisited is just for
			// classes locked in shared mode.
			$$$ThrowOnError(tLockManager.LockClassDefinition(tClassName))
			If $Data(tVisited(tClassName)) {
				Continue
			}
			
			// It would be nice if there was an API for this that accepted tVisited.
			Kill tDependencies
			Do getalldependencyclasses^%occDepend(tClassName,.tDependencies,.tVisited,,,,,1)
			
			Set tDependencyKey = "A" //Start at 'A' to skip % classes.
			For {
				Set tDependencyKey = $Order(tDependencies(tDependencyKey))
				If (tDependencyKey = "") {
					Quit
				}
				
				$$$ThrowOnError(tLockManager.LockClassDefinition(tDependencyKey,1))
			}
		}
		
		// If all classes were locked successfully, record that they were,
		// and move ownership of the locks from tLockManager to pLockManager.
		// If an error occurred, any locks taken out will be released when tLockManager
		// goes out of scope.
		Merge pSharedLockedClasses = tVisited
		Do tLockManager.MergeTo(pLockManager)
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="LockClassDefinition">
<FormalSpec>pClass:%String,pShared:%Boolean=0,pTimeout:%Integer=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Based on ^%occLock (particularly, the error handling and $$Function^%SYS.* calls are taken from there).
	Set tSourceNamespace = $$GetClassLockDatabase^%SYS.SECURITY(pClass,"")
	If tSourceNamespace = "" {
		Quit $$$OK
	}
	Set tLockGlobal = $Name(^|tSourceNamespace|oddDEF(pClass))
	Set tSC = ..Lock(tLockGlobal,$Select(pShared:"SE",1:"E"),pTimeout)
	If $$$ISERR(tSC) {
		Set tEscalate = 0
		Set tType = $$FindLockOwner^%SYS.cspServer2(tSourceNamespace,"^oddDEF",pClass,.tJob,.tUser,.tEscalate)
		If (tType = 2) {
			Quit $$$ERROR($$$ClassLockTableFull,pClass)
		} ElseIf (tType = 1) {
			If tEscalate {
				Quit $$$ERROR($$$ClassLockEscalate,pClass,tUser,tJob)
			} Else {
				Quit $$$ERROR($$$CanNotLockRoutineInfo,pClass_".cls",tUser,tJob)
			}
		}
		If pShared {
			Quit $$$ERROR($$$ClassSharedLockFailed,pClass)
		} Else {
			Quit $$$ERROR($$$ClassExclusiveLockFailed,pClass)
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="MergeTo">
<FormalSpec>pTargetLockManager:%ZHSLIB.LockManager</FormalSpec>
<Implementation><![CDATA[
	Set tGlobalName = ""
	For {
		Set tGlobalName = $Order(i%Cache(tGlobalName))
		If (tGlobalName = "") {
			Quit
		}
		
		Set tFlags = ""
		For {
			Set tFlags = $Order(i%Cache(tGlobalName,tFlags),1,tLockCount)
			If (tFlags = "") {
				Quit
			}
			If $Increment(pTargetLockManager.Cache(tGlobalName,tFlags),tLockCount)
		}
	}
		
	Kill i%Cache
		
	Set tOID = ""
	For {
		Set tOID = $Order(i%OIDCache(tOID))
		If (tOID = "") {
			Quit
		}
		Set tShared = ""
		For {
			Set tShared = $Order(i%OIDCache(tOID,tShared),1,tLockCount)
			If (tShared = "") {
				Quit
			}
			If $Increment(pTargetLockManager.OIDCache(tOID,tShared),tLockCount)
		}
	}
	
	Kill i%OIDCache
]]></Implementation>
</Method>
</Class>


<Class name="%ZHSLIB.Login.LoginData">
<Description><![CDATA[
Object to represent how a HealthShare login failure should be processed.
<property>LoginContext</property> is the most important property for processing requests in a login
page, as it captures the context needed by a login page or REST API to perform subsequent steps.
See the documentation for individual properties to understand the various possibilities.]]></Description>
<Super>%RegisteredObject</Super>
<TimeChanged>67214,49066.7137602</TimeChanged>
<TimeCreated>67214,49066.7137602</TimeCreated>

<Parameter name="CONTEXTChallengeAvailable">
<Default>challenge-available</Default>
</Parameter>

<Parameter name="CONTEXTChallengeResponse">
<Default>challenge-response</Default>
</Parameter>

<Parameter name="CONTEXTChangePassword">
<Default>change-password</Default>
</Parameter>

<Property name="LoginStatus">
<Description><![CDATA[
Status to capture the detailed status that was encountered, but does not provide much
useful information. Callers should make use of <method>IsLoginError</method>() and/or
<property>LoginContext</property> to understand what happened with a login request.
<p>
This will almost always be <code>$$$AccessDenied</code> when it is a failure.
</p>]]></Description>
<Type>%Status</Type>
<InitialExpression>$$$OK</InitialExpression>
</Property>

<Property name="LoginContext">
<Description><![CDATA[
Helper property to indicate what information was identified in the login
data. The supported values are as follows:
<ul>
<li><code>..#CONTEXTChallengeAvailable</code> - the login failed (so <method>IsLoginError</method>() = 1 and 
<property>LoginStatus</property> is an error), but we have data available in 
<property>ChallengeQuestion</property> and <property>ChallengeForLogin</property> to allow the user
to request a password reset.</li>
<li><code>..#CONTEXTChallengeResponse</code> - this value is returned from a password reset request, which is 
<strong>not</strong> treated as a login failure, but the caller should display the value of 
<property>ChallengeResponse</property> to the user.</li>
<li><code>..#CONTEXTChangePassword</code> - the user needs to change their password. This should only be returned
when logins are being processed by a REST API or a similar CSP dispatch class, as standard CSP and Zen 
login pages automatically handle password change conditions by redirecting to the change password page for 
the current CSP application.</li>
</ul>]]></Description>
<Type>%String</Type>
<Parameter name="VALUELIST" value=",challenge-available,challenge-response,change-password"/>
</Property>

<Property name="ChallengeQuestion">
<Description><![CDATA[
When <property>LoginContext</property> = <code>..#CONTEXTChallengeAvailable</code>, this property will contain
a challenge question that the user must answer correctly to request a password reset.]]></Description>
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="ChallengeForLogin">
<Description><![CDATA[
When <property>LoginContext</property> = <code>..#CONTEXTChallengeAvailable</code>, this property will contain
the user that the challenge is for, and this value will need to be sent back to the server
along with the answer to <property>ChallengeQuestion</property> to request a password reset.]]></Description>
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="ChallengeResponse">
<Description><![CDATA[
When <property>LoginContext</property> = <code>..#CONTEXTChallengeResponse</code>, it indicates
that the user has requested a password reset, and this message should be displayed to the user
to communicate what occurred on the registry in response to the user's request.
The message should be displayed to the user so that they understand what occurred.]]></Description>
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Method name="IsLoginError">
<Description>
Boolean flag to indicate whether a login error occurred.</Description>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit $$$ISERR(..LoginStatus)
]]></Implementation>
</Method>
</Class>


<Class name="%ZHSLIB.Login.Utils">
<Description>
General class to contain login-related APIs to simplify the process 
of setting up server-side data to handle login failures and password changes.</Description>
<Abstract>1</Abstract>
<TimeChanged>67214,49066.7111987</TimeChanged>
<TimeCreated>67214,49066.7111987</TimeCreated>

<Method name="GatherChangePasswordData">
<Description>
API to be called from a change password page to correctly initialize the 
server-side data to support the subsequent password change request.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCSPSession:%CSP.Session=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try {
		If ('$isobject(pCSPSession)) || ('pCSPSession.%IsA("%CSP.Session")) || ('pCSPSession.%ExistsId(pCSPSession.SessionId)) {
			Set tStatus = $$$ERROR($$$GeneralError,"Invalid CSP session")
			Quit
		}
		Kill ^CacheTemp.Login(pCSPSession.SessionId)

		Set ^CacheTemp.Login(pCSPSession.SessionId,"ID") = $get(pCSPSession.Data("LoginID"))
		Set ^CacheTemp.Login(pCSPSession.SessionId,"Domain") = $get(pCSPSession.Data("LoginDomain"))
		Set ^CacheTemp.Login(pCSPSession.SessionId,"Token") = $get(pCSPSession.Data("LoginToken"))
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="CheckLoginRequest">
<Description><![CDATA[
API to wrap checks for login pages to work out whether a login failed,
and whether there are any values related to HealthShare logins that 
should drive the page's behaviour.
<p>
The API returns a <class>%ZHSLIB.Login.LoginData</class> instance
that indicates what happened on the previous incoming request,
particularly when there was some sort of failure on the previous request.
</p></p>
The arguments to the method are as follows:
<ul>
  <li><var>pLoginData</var> - the object that indicates what the state of the login was.</li>
  <li><var>pCSPRequest</var> - the incoming <class>%CSP.Request</class> instance, 
         which defaults to <code>%request</code>.</li>
  <li><var>pCSPSession</var> - the current <class>%CSP.Session</class> instance,
         which defaults to <code>%session</code>.</li>
  <li><var>pClearRequestError</var> -  a flag to control whether the <code>Error:ErrorCode</code>
         field in the request object should be removed in cases where there should not be an error
         reported to downstream code.</li>
</ul></p>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pLoginData:%ZHSLIB.Login.LoginData,pCSPRequest:%CSP.Request=$get(%request),pCSPSession:%CSP.Session=$get(%session),pClearRequestError:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try {
		Set pLoginData = ##class(%ZHSLIB.Login.LoginData).%New()

		If ('$isobject(pCSPRequest)) || ('pCSPRequest.%IsA("%CSP.Request")) {
			Set tStatus = $$$ERROR($$$GeneralError,"Invalid CSP Request")
			Quit
		}
		If ('$isobject(pCSPSession)) || ('pCSPSession.%IsA("%CSP.Session")) || ('pCSPSession.%ExistsId(pCSPSession.SessionId)) {
			Set tStatus = $$$ERROR($$$GeneralError,"Invalid CSP Session")
			Quit
		}

		Set tErrorHandled = 0
		// Check to see if we have an error that should get special handling
		Set tErrorStatus = $get(pCSPRequest.Data("Error:ErrorCode",1))
		If (tErrorStatus '= "") {
			Set pLoginData.LoginStatus = tErrorStatus

			// The most common error is for access denied, which encompasses multiple possible
			// situations.
			If ($system.Status.Equals(tErrorStatus,$$$ERRORCODE($$$AccessDenied))) {
				// Check whether we previously answered a password challenge
				If $data(^CacheTemp.Login(pCSPSession.SessionId,"ForgotPWResponse"),tForgotPWResponse) {
					// For this case, we don't report the error, as we need to let the caller
					// interpret the response to our answer
					Set pLoginData.LoginStatus = $$$OK
					Set pLoginData.LoginContext = ##class(%ZHSLIB.Login.LoginData).#CONTEXTChallengeResponse
					Set pLoginData.ChallengeResponse = tForgotPWResponse

					Kill ^CacheTemp.Login(pCSPSession.SessionId)
					Set tErrorHandled = 1
				}
				// Otherwise check if we have a challenge question that we could answer
				ElseIf $data(^CacheTemp.Login(pCSPSession.SessionId,"ChallengeQ"),tChallengeQuestion) {
					// Note that we still return an error here, as the login did fail,
					// but we can allow the user to trigger a Forgot Password workflow.
					Set pLoginData.LoginContext = ##class(%ZHSLIB.Login.LoginData).#CONTEXTChallengeAvailable
					Set pLoginData.ChallengeQuestion = tChallengeQuestion
					Set pLoginData.ChallengeForLogin = $get(^CacheTemp.Login(pCSPSession.SessionId,"login"))
					Set tErrorHandled = 1
				}
			}
			// Could just be a message that the user needs to authenticate - e.g., on initial page load.
			// This is not treated as an error.
			ElseIf ($system.Status.Equals(tErrorStatus,$$$ERRORCODE($$$RequireAuthentication))) {
				Set pLoginData.LoginStatus = $$$OK
				Set tErrorHandled = 1
			}
			// Check if we got a password change required error
			// This should only be triggered when we are using a Dispatch Class for the CSP application,
			// which is most likely when using REST.
			// In a standard CSP context, a password change error automatically redirects the user
			// to the Password Change page for the CSP application.
			ElseIf ($system.Status.Equals(tErrorStatus,$$$ERRORCODE($$$PasswordChangeRequired))) {
				Set pLoginData.LoginContext = ##class(%ZHSLIB.Login.LoginData).#CONTEXTChangePassword
				Set tErrorHandled = 1
			}
		}
		
		If (pClearRequestError) && (tErrorHandled) {
			Kill pCSPRequest.Data("Error:ErrorCode",1)
		}
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>
</Class>


<Class name="%ZHSLIB.NonHSSolution.Utils">
<Hidden>1</Hidden>
<TimeChanged>67214,49066.7188795</TimeChanged>
<TimeCreated>67214,49066.7188795</TimeCreated>

<Method name="CreateCMS0057Namespace">
<Description><![CDATA[
1. Create a namespace and database based on pName
2. Enable namespace for interoperability productions but has no mappings to HSLIB
3. Load IPM packages
4. Set up p4 info
5. Configure a repo for 0057 appmodules directory
------------- Arguments --------------------------------------------------
pName: Name of the namespace for 0057 solution development
pLocalPathToIPM: Local path to p4 directory: //healthshare/appmodules/ZHSLIB/latest/databases/hscommon/build/ (e.g. c:\Users\bzhang\Perforce\bzhang_tcdp\healthshare\appmodules\ZHSLIB\latest\databases\hscommon\build\)
pJSONPayload: Optional input that can be in the following formats.
	1) File path string to a JSON file containing P4 Info
	2) %DynamicObject containing P4 Info
	3) JSON string containing P4 Info
	Expected format:
	{
    	"P4Info": {
        	"P4User": "<p4user>",
        	"P4Password": "<p4password>",
        	"P4Workspace": "<p4workspace>",
        	"P4Port": "<p4port>"
    	}
	}]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pName:%String,pLocalPathToIPM:%String,pJSONPayload:%RawString=""</FormalSpec>
<Implementation><![CDATA[
	/// 1. Create a namespace and database based on pName & 2. Enable namespace for interoperability productions but has no mappings to HSLIB
	Write !, "Creating Namespace and database..."
	New $Namespace
	Set $Namespace = "HSLIB"
	Set NSConfig = ##class(%IPM.Storage.ModuleSetting.NamespaceConfig).%New()
	Set NSConfig.EnableEnsemble = 1
	Set NSConfig.EnableHealthShare = 0
	$$$ThrowOnError(##class(%IPM.Utils.Build).CreateDatabase(pName))
	$$$ThrowOnError(##class(%IPM.Utils.Build).CreateNamespace(pName, pName, pName, 1, NSConfig))
	Write !, "Loading IPM packages..."
	/// 3. Load IPM packages
	Set $Namespace = pName
	Do $system.OBJ.Load(pLocalPathToIPM_"NewZPM2NoReg.xml", "ck")
	Do $system.OBJ.Load(pLocalPathToIPM_"NewStudioUI2.xml", "ck")
	Do $system.OBJ.Load(pLocalPathToIPM_"NewPerforce2.xml", "ck")
	Do $system.OBJ.Load(pLocalPathToIPM_"HS.IPM.xml", "ck")
	Write !, "Setting up p4 and configuring repositories..."
	/// 4. Set up p4 info
	Do ##class(%ZHSLIB.Component.SourceCode.Utils).SetP4Credentials(pJSONPayload)
	/// 5. Configure 0057 appmodules repo
	Do ##class(%ZHSLIB.Component.SourceCode.Utils).PrepareP4Extension()
	Do ##class(%IPM.Main).Shell("repo -n 0057AppModules -p4 -path //projects/healthshare/appmodules/CMS-0057-WIP/")
]]></Implementation>
</Method>
</Class>


<Class name="%ZHSLIB.REST.AngularHandler">
<Description>
Dispatch class for any web app that is serving static Angular files
This ensures that the Angular app can use the path location strategy instead of
the hash location strategy by correctly serving the static files.</Description>
<Super>%CSP.REST</Super>
<TimeChanged>67214,49066.7849885</TimeChanged>
<TimeCreated>67214,49066.7849885</TimeCreated>

<XData name="UrlMap">
<XMLNamespace>http://www.intersystems.com/urlmap</XMLNamespace>
<Data><![CDATA[
<Routes>
    <Route Url="/(.*)" Method="GET" Call="ServeStaticFile" />
</Routes>
]]></Data>
</XData>

<Method name="AccessCheck">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pAuthorized:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    // No access check needed. Just returning static files
    Set pAuthorized = 1
    Return $$$OK
]]></Implementation>
</Method>

<Method name="ServeStaticFile">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pPath:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		If $Match(pPath, "^(assets/.*|.*\.(woff|woff2))$") {
			Do %response.SetHeader("cache-control", "public, max-age=31536000")
		}
		If '$Match(pPath,"^(assets/.*|.*\.(js|map|html|css|woff|woff2))$") || (pPath = "index.html") {
			// Special handling for index.html / any Angular route where we always serve index.html
			Do ..UpdateBaseHrefForHTMLRouting()
			Quit
		}
		// Always first check if web app directory has files. The web app directory
		// is where any customization files will live. The physical files path 
		// will be the kitted location and hence we have that as the default below.
		Set customFile = $System.Util.DataDirectory() _ $Extract(%request.AppMatch,2,*) _ pPath
		If ##class(%File).Exists(customFile) {
			Set file = customFile
			// NOTE: Below is copied from %CSP.StreamServer to match way in which it serves files
			Do ##class(%CSP.StreamServer).FileClassify($Piece(file,".",*),.type,,.charset)
			Set stream = ##class(%Stream.FileBinary).%New()
			Set sc = stream.LinkToFile(file)
			$$$ThrowOnError(sc)
			If (type '= "") {
				Set %response.ContentType = type
			}
			Set tmp = $Translate(file,"\","/")
			Set tmp = $Piece(tmp,"/",*)
			If tmp?.E1(1" ",1";",1",",1"(",1")",1"<",1">",1"@",1":",1"\",1"""",1"/",1"[",1"]",1"?",1"=",1"{",1"}").E {
				Set tmp = """"_$Extract($ZUtil(144,1,"z"_tmp),3,*)
			}
			If (tmp '= "") {
				Do %response.SetHeader("Content-Disposition","inline; filename="_tmp)
			}
			Set %response.NoCharSetConvert = 1
			If ($Get(charset) '= "") {
				Set %response.CharSet=charset
			}
			Set sc = stream.OutputToDevice()
			$$$ThrowOnError(sc)
			Quit
		}
		// NOTE: This type of setting ensure that pPath is resolved relative to
		// the "Path" property of the web application in %CSP.StreamServer
		Set %request.Data("FILE",1) = %request.Application_pPath
		Set sc = ##class(%CSP.StreamServer).Page()
		$$$ThrowOnError(sc)
	} Catch (ex) {
		// NOTE: Cannot rely on default %CSP.REST handling here for errors due 
		// to PROTECT errors so handle it here itself.
		// If web app config is correct, should never get an error here.
		Set sc = ex.AsStatus()
		Set json = {
			"code": ($System.Status.GetErrorCodes(sc)),
			"text": ($System.Status.GetErrorText(sc))
		}
		Set %response.Status = ..#HTTP500INTERNALSERVERERROR
		Set %response.ContentType = ..#CONTENTTYPEJSON
		Do json.%ToJSON()
	}
	Return $$$OK
]]></Implementation>
</Method>

<Method name="GetWebAppInfo">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pWebAppName:%String,*pProps</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
    Kill pProps
    $$$AddAllRoleTemporary
    New $Namespace
    Set $Namespace = "%SYS"
    Set sc = $ClassMethod("Security.Applications", "Get", pWebAppName, .pProps)
    $$$ThrowOnError(sc)
]]></Implementation>
</Method>

<Method name="UpdateBaseHrefForHTMLRouting">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<Private>1</Private>
<Implementation><![CDATA[
	// NOTE: In angular.json of the Angular app, the build configuration MUST
	// provide a base href matching {$webAppPath} for this to work.
	Set patternToReplace = "(?i)\{\$webAppPath\}"
	Do ..GetWebAppInfo(%request.AppMatch, .webAppInfo)
	Set directory = $Get(webAppInfo("Path"))
	// Update index.html file
	Set pathToIndexFile = directory _ "index.html"
	If '##class(%Library.File).Exists(pathToIndexFile) {
		$$$ThrowStatus($$$ERROR($$$GeneralError,"index.html missing for web app: " _ %request.AppMatch))
	}
	#dim fileStream As %Stream.FileCharacter
	Set fileStream = ##class(%Stream.FileCharacter).%New()
	$$$ThrowOnError(fileStream.LinkToFile(pathToIndexFile))
	$$$ThrowOnError(fileStream.Rewind())
	#dim tmpStream As %Stream.TmpCharacter
	Set tmpStream = ##class(%Stream.TmpCharacter).%New()
	Set webAppPath = %request.Application
	If ($Extract(webAppPath, *) '= "/") {
		// MUST have trailing slash or else the final path element will be dropped by Angular
		Set webAppPath = webAppPath _ "/"
	}
	While 'fileStream.AtEnd {
		Set content = fileStream.Read(, .sc)
		$$$ThrowOnError(sc)
		If $Locate(content,patternToReplace) {
			Set content = ..RegExReplace(content, patternToReplace, webAppPath)
		}
		$$$ThrowOnError(tmpStream.Write(content))
	}
	$$$ThrowOnError(tmpStream.Flush())
	// Below handling of serving a file is adapted from %CSP.StreamServer:OnPreHTTP
	Set %response.ContentType = "text/html"
	Set %response.Expires = $Get(webAppInfo("Expires"),3600)
	Set sc = tmpStream.OutputToDevice()
	$$$ThrowOnError(sc)
]]></Implementation>
</Method>

<Method name="RegExReplace">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pString:%String,pRegEx:%String,pValue:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit ##class(%Regex.Matcher).%New(pRegEx,pString).ReplaceAll($Replace(pValue,"\","\\"))
]]></Implementation>
</Method>
</Class>


<Class name="%ZHSLIB.Services.Client">
<Description>

This is the client side class for the SOAP NVPair Service.
Users must initiate the object, set the Location property before calling the GetNVPair method.
Here is an example of invoking this WebService to get Role information from a remote system

set wsclient=##class(%ZHSLIB.Services.Client).%New()
set wsclient.Location="http://localhost:57773/csp/hshub/_ZHSLIB.Services.Server.cls"
set nvpair=wsclient.GetNVPair("ResourcesAndRoles")

After this, 'nvpair' is an object of %ZHSLIB.Services.NVPair containing the information returned from the server.
</Description>
<IncludeCode>%ZHSLIB</IncludeCode>
<Super>%SOAP.WebClient</Super>
<System>4</System>
<TimeChanged>67214,49066.7969128</TimeChanged>
<TimeCreated>67214,49066.7969128</TimeCreated>

<Parameter name="SERVICENAME">
<Default>HS.Hub.SoapNVPair</Default>
</Parameter>

<Parameter name="NAMESPACE">
<Default>http://www.intersystems.com/hs/hub/soapnvpair</Default>
</Parameter>

<Parameter name="OUTPUTTYPEATTRIBUTE">
<Description>
Use xsi:type attribute for literal types.</Description>
<Default>1</Default>
</Parameter>

<Method name="GetNVPair">
<Final>1</Final>
<FormalSpec>pType:%String,pParameter:%String=""</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%ZHSLIB.Services.NVPair</ReturnType>
<WebMethod>1</WebMethod>
<SoapBindingStyle>document</SoapBindingStyle>
<SoapBodyUse>literal</SoapBodyUse>
<Implementation><![CDATA[ 	Quit ..WebMethod("GetNVPair").Invoke(##this,"http://HS.Hub.SoapNVPair/%ZHSLIB.Services.Server.GetNVPair",.pType,.pParameter)
]]></Implementation>
</Method>

<Method name="SyncConfiguration">
<ClassMethod>1</ClassMethod>
<FormalSpec>pHost:%String="",pPath:%String="",pPort:%String="",pFullSync:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	try {
		Set tWhere=$zu(5),tSC=$$$OK
		Do ##class(HS.Util.MirrorMonitorAgent).ManageInstanceGUID()
		Set tSystemGUID=##class(%SYS.System).InstanceGUID()
		Set tNS="HSSYS"
		//Ideally, this would use $$$HSNetworkHostName, but it can't because this class gets loaded
		//as part of the system bootstrap, before mappings exist that enable HS.Common
		If pHost="" Set pHost=$S($G(^%SYS("HealthShare","NetworkHostName"))]"":^("NetworkHostName"),1:$ZU(54,0))
		Set tSSLConfig = ""
		If pPort="" {
			Set tSC=##class(%RoutineMgr).GetWebServerPort(.pPort,,.tUrlPrefix) 
			Quit:'tSC
		}
		If $$$HSSecureIsActive {
			Set tConfig = ##class(HS.Util.Installer.ConfigItem).%OpenId($Namespace)
			If $IsObject(tConfig) {
				Set tSSLConfig = $$$ConfigValue(tConfig, "SSLConfig")
			}
		}
		// If user specifies an non-empty SSLConfig on gateway creation, use that and connect securely to hub by using secure port and prefix
		// otherwise, keep unsecure connection to hub, even if SSL is activated
		If (tSSLConfig '= "") {
			Set pPort = $$$HSSecurePort
			Set tUrlPrefix = $$$HSSecurePrefix
		}
		If pPath="" {
			Set pPath=$zcvt("/csp/healthshare/hssys/services","l")
			Set pPath=$S($D(^["%SYS"]SYS("Security","ApplicationsD",pPath)):pPath,1:"") if pPath="" Set tSC=$$$ERROR($$$GeneralError,"Unknown path") Quit 
			Set tComponent="HS.Sync.Services.cls"
			Set pPath=$S(tUrlPrefix'="":"/"_tUrlPrefix,1:"")_pPath_"/"_tComponent
		}
		Set tDelim="||"
		#; if the service registry is empty it must be a full sync, reset pFullSync
		Set tTableEmpty=##class(HS.Registry.Service.Abstract).TableEmpty()
		If tTableEmpty Set pFullSync=1
		#; send the versison so hub can detect upgrade for partial sync
		$$$ThrowOnError(##class(%ZHSLIB.HealthShareMgr).ComponentVersion("HSLIB",.tVersion))
		Set tMajorMinor = $P(tVersion,".",1,2)
		Set pParameter=tSystemGUID_tDelim_"HSSYS"_tDelim_pHost_tDelim_pPath_tDelim_pPort_tDelim_pFullSync_tDelim_tMajorMinor_tDelim_tSSLConfig
		Set tSC = ##class(%ZHSLIB.UsersAndRoles).GetNewSystemRoles(.tRoles,##class(HS.Sync.Utils).IsSyncSlave())
		
		For tUseRegistry=1,0 {
			If (tTableEmpty && tUseRegistry) {Continue} 
			Set tSC=..InvokeHubService(tUseRegistry,"HS.Hub.HSWS.WebServices","HS.Hub.HSWS.WebServicesClient","DefineSynchronization",.tResponse,pParameter,tRoles) 
			Quit:$$$ISOK(tSC)  
			Quit:$system.Status.GetErrorCodes(tSC)=6248
		}
	} catch eException {
		Set tSC=eException.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetSysSyncState">
<ClassMethod>1</ClassMethod>
<FormalSpec>pHost:%String="",pPath:%String="",pPort:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	try {
		Set tWhere=$zu(5),tSC=$$$OK
		Set tSystemGUID=##class(%SYS.System).InstanceGUID()
		Set tNS="HSSYS"
		For tUseRegistry=1,0 Set tSC=..InvokeHubService(tUseRegistry,"HS.Hub.HSWS.WebServices","HS.Hub.HSWS.WebServicesClient","GetSysSyncState",.tResponse,tNS,tSystemGUID) Quit:$$$ISOK(tSC)
		If $$$ISERR(tSC) {
			Write !,$$$FormatText("Failed to complete synchronization: %1"),!
			Set tResponse="Error communicating with HUB"
		}
	} catch eException {
		Set tResponse=eException.DisplayString()
	}
	Quit tResponse
]]></Implementation>
</Method>

<Method name="InvokeHubService">
<Description>
Called by SyncConfiguration to determine the Hub endpoint</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pUseRegistry:%Boolean,pServiceClassName:%String,pProxyClassName:%String,pMethodName:%String,*pResponse,pArgs...</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tSC = $$$OK
		If $e(pServiceClassName)="%" Set $E(pServiceClassName)="_"
		// Get the value of a property on a config item object if the property exists
		// If it does not, return ""
		#define ConfigValue(%instance, %property) $Case(+$$$comMemberDefined($Classname(%instance), $$$cCLASSproperty, %property), 0: "", : $Property(%instance, %property))
		If pUseRegistry {
			#dim tConfig as HS.Registry.Service.SOAP = ##class(HS.Registry.Service.SOAP).EndPointForNameType("HSREGISTRY","SOAP")
			If $IsObject(tConfig) {
				Set tURL = tConfig.EndPoint
				Set tEnsembleUser = tConfig.UsernameTokenProfileConfig
				Set tSSLConfig = $$$ConfigValue(tConfig, "SSLConfig")
				If ($$$HSSecureIsActive && (tSSLConfig = "")) {
					// When activating SSL, $$$HSSecureSSLConfig will set to be the default instance wide SSL Configuration
					Set tSSLConfig = $$$HSSecureSSLConfig
				}
			}
		} Else {
			Set tEnsembleUser = $$$HSServiceUserGetMake
			Set tConfig = ##class(HS.Util.Installer.ConfigItem).%OpenId($Namespace)
			If $IsObject(tConfig) {
				Set tType = tConfig.Type
				Set tSSLConfig = $$$ConfigValue(tConfig, "SSLConfig")
				Set tURL = $$$ConfigValue(tConfig, "HubEndpoint")
			} Else {
				Set tType = $Get(^%SYS("HealthShare","Instances",$namespace,"Type"), " ")
				Set tSSLConfig = ""
				Set tURL = $ListGet($Get(^%SYS("HealthShare","Instances",$namespace,tType)), 1)
			}
		}
		#dim tCredentials As Ens.Config.Credentials
		Set tCredentials = ##class(Ens.Config.Credentials).%OpenId(tEnsembleUser)
		
		Set tSoap=$zobjclassmethod(pProxyClassName,"%New")
		Set tSoap.SSLConfiguration=tSSLConfig
		Set tSoap.OpenTimeout=10
		Set tSoap.Location=$p(tURL,"/",1,$l(tURL,"/")-1)_"/"_pServiceClassName_".cls"
		Set tSC=tSoap.WSSecurityLogin(tCredentials.Username,tCredentials.Password) QUIT:'tSC
		Set pResponse=$zobjmethod(tSoap,pMethodName,pArgs...),tSC=$$$OK
		QUIT

	} catch ex {
		If $ZERROR["<ZSOAP" {
			Set tSC = $$$ERROR($system.Status.GetErrorCodes(%objlasterror),tSoap.SoapFault.faultstring)
		} Else {
			Set tSC = ex.AsStatus()
		}
	}
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%ZHSLIB.Services.NVPair">
<Super>%RegisteredObject,%XML.Adaptor</Super>
<System>4</System>
<TimeChanged>67214,49066.7430077</TimeChanged>
<TimeCreated>67214,49066.7430077</TimeCreated>
<Inheritance>right</Inheritance>

<Property name="Type">
<Type>%String</Type>
<Parameter name="MAXLEN" value="1024"/>
</Property>

<Property name="Name">
<Type>%String</Type>
<Parameter name="MAXLEN" value="255"/>
</Property>

<Property name="Value">
<Type>%String</Type>
<Collection>array</Collection>
<Parameter name="MAXLEN"/>
</Property>

<Property name="SubItems">
<Type>%ZHSLIB.Services.NVPair</Type>
<Collection>list</Collection>
</Property>
</Class>


<Class name="%ZHSLIB.Services.Server">
<IncludeCode>%ZHSLIB</IncludeCode>
<Super>%SOAP.WebService</Super>
<System>4</System>
<TimeChanged>67214,49066.7871128</TimeChanged>
<TimeCreated>67214,49066.7871128</TimeCreated>

<Parameter name="SERVICENAME">
<Default>HS.Hub.SoapNVPair</Default>
</Parameter>

<Parameter name="NAMESPACE">
<Default>http://www.intersystems.com/hs/hub/soapnvpair</Default>
</Parameter>

<Method name="GetNVPair">
<ClassMethod>1</ClassMethod>
<FormalSpec>pType:%String="Roles",pParameter:%String=""</FormalSpec>
<ReturnType>%ZHSLIB.Services.NVPair</ReturnType>
<WebMethod>1</WebMethod>
<Implementation><![CDATA[
	set $zt="Trap",tSC=$$$OK,tNVP=$$$NULLOREF
	;
	if pType="ResourcesAndRoles" {
		set tSC=..getResourcesAndRoles(.tNVP,.pParameter) 
	} elseif pType="SetResourcesAndRolesTime" {
		Set tSC=##class(%ZHSLIB.UsersAndRoles).SetUpdatedRolesResources($p(pParameter,"^",1),$p(pParameter,"^",2))
	} elseif pType="Facilities" {
		set tSC=..getFacilities(.tNVP,.pParameter)
	} elseif pType="InfoTypes" {
		set tSC=..getInfoTypes(.tNVP,.pParameter)
	} else {
		set tSC=$$$ERROR($$$GeneralError,"Invalid type: "_pType)
	}
	;
Exit
	if $$$ISERR(tSC) do ..returnStatusError(tSC)
	quit tNVP
Trap
	set $ZT="",tSC=$$$ERROR($$$ObjectScriptError,$ZE)
	Do BACK^%ETN
	goto Exit
]]></Implementation>
</Method>

<Method name="returnStatusError">
<ClassMethod>1</ClassMethod>
<FormalSpec>pStatusCode:%Status</FormalSpec>
<Implementation><![CDATA[
	do $system.Status.DecomposeStatus(pStatusCode,.tErrorText)
	set tFault=##class(%SOAP.Fault).%New()
	set tFault.faultcode=$$$FAULTServer
	set tFault.detail=$g(tErrorText(1))
	set tFault.faultstring="application error"
	// ReturnFault must be called to send the fault to the client.
	// ReturnFault will not return here.
	do ..ReturnFault(tFault)
	quit
]]></Implementation>
</Method>

<Method name="getResourcesAndRoles">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pNVP:%ZHSLIB.Services.NVPair,pParameter:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap"
	Set pNVP=##class(%ZHSLIB.Services.NVPair).%New()
	Set pNVP.Type="ResourcesAndRoles"

	Set tStatus=##class(%ZHSLIB.UsersAndRoles).UpdatedRolesResources(pParameter,.tAry)
	Quit:'tStatus tStatus

	#; add the update date/time as an item
	Set tSubItem=##class(%ZHSLIB.Services.NVPair).%New()
	Set tSubItem.Type="DateTime"
	Set tSubItem.Name="DateTime"
	Do tSubItem.Value.SetAt($G(tAry("LastCheck")),"LastCheck")
	Do pNVP.SubItems.Insert(tSubItem)

	For tNode1="Modified","Deleted" {
		For tNode2="Resource","Role" {
			Set tName=""
			For  {
				Set tName=$o(tAry(tNode1,tNode2,tName)) Quit:tName=""
				Set tSubItem=##class(%ZHSLIB.Services.NVPair).%New()
				Set tSubItem.Type=tNode2
				Set tSubItem.Name=tName
				If tNode1="Modified" {
					If tNode2="Role" {
						Do:$d(tAry("Modified","Role",tName,"Description")) tSubItem.Value.SetAt(tAry("Modified","Role",tName,"Description"),"Description")
						Do:$d(tAry("Modified","Role",tName,"Roles")) tSubItem.Value.SetAt(tAry("Modified","Role",tName,"Roles"),"GrantedRoles")
						Do:$d(tAry("Modified","Role",tName,"Resources")) tSubItem.Value.SetAt(tAry("Modified","Role",tName,"Resources"),"Resources")
					} Else {
						Do:$d(tAry("Modified","Resource",tName,"Description")) tSubItem.Value.SetAt(tAry("Modified","Resource",tName,"Description"),"Description")
						Do:$d(tAry("Modified","Resource",tName,"PublicPermission")) tSubItem.Value.SetAt(tAry("Modified","Resource",tName,"PublicPermission"),"PublicPermission")
					}
				} Else {
					Do tSubItem.Value.SetAt(1,"Deleted")
				}
 				Do pNVP.SubItems.Insert(tSubItem)
			}
		}
 	}
Exit	///
	Quit tStatus
Trap	///
	Set $ZT="",tStatus=$$$ERROR($$$ObjectScriptError,$ze)
	ZN tLocation
	Goto Exit
]]></Implementation>
</Method>

<Method name="getFacilities">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pNVP:%ZHSLIB.Services.NVPair,pParameter:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap2"
	Set pNVP=##class(%ZHSLIB.Services.NVPair).%New()
	Set pNVP.Type="Facilities"
	Do pNVP.Value.SetAt($ZDT($H,3),"CheckTime") // return to caller, so it can track it
	Set tRset=##class(%ResultSet).%New()
	Set tRset.ClassName="HS.Facility.Config"
	Set tRset.QueryName="GetUpdatedFacilities"
	Set tStatus=tRset.Execute(pParameter)
	Quit:'tStatus tStatus
	While tRset.Next(tStatus)
	{
		Quit:'tStatus
		Set tSubItem=##class(%ZHSLIB.Services.NVPair).%New()
		Set tSubItem.Type="Facility"
		Set tSubItem.Name=tRset.Data("Name")
		Do tSubItem.Value.SetAt(tRset.Data("FacilityCode"),"FacilityCode")
		Do tSubItem.Value.SetAt(tRset.Data("Description"),"Description")
		Do tSubItem.Value.SetAt(tRset.Data("FacilityId"),"FacilityId")
		Do tSubItem.Value.SetAt(tRset.Data("ConsentGroup"),"ConsentGroup")

		#; add facility end points
		Set tFacility = ##class(HS.Facility.Config).%OpenId(tRset.Data("FacilityCode"))
		Set tEndPoints = ##class(%ZHSLIB.Services.NVPair).%New()
		Set tEndPoints.Type="EndPoints"
		Set tEndPoints.Name="EndPoints"
		Do tSubItem.SubItems.Insert(tEndPoints)
		Set tKey=""
		Do {
			Set tValue = tFacility.EndPoints.GetNext(.tKey)
			Do:tKey]"" tEndPoints.Value.SetAt(tValue,tKey)
		} While tKey]""
		Do pNVP.SubItems.Insert(tSubItem)
	}
	Do tRset.Close()
Exit2	///
	Quit tStatus
Trap2	///
	Set $ZT="",tStatus=$$$ERROR($$$ObjectScriptError,$ze)
	Goto Exit2
]]></Implementation>
</Method>

<Method name="getInfoTypes">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pNVP:%ZHSLIB.Services.NVPair,pParameter:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap3"
	Set pNVP=##class(%ZHSLIB.Services.NVPair).%New()
	Set pNVP.Type="InfoTypes"
	//Do pNVP.Value.SetAt($ZDT($H,3),"CheckTime") // return to caller, so it can track it
	Set tRset=##class(%ResultSet).%New()
	Set tRset.ClassName="HS.InfoType.Config"
	Set tRset.QueryName="ListInfoTypes"
	Set tStatus=tRset.Execute()
	Quit:'tStatus tStatus
	While tRset.Next(tStatus)
	{
		Quit:'tStatus
		Set tSubItem=##class(%ZHSLIB.Services.NVPair).%New()
		Set tSubItem.Type="InfoType"
		Do tSubItem.Value.SetAt(tRset.Data("PrimaryType"),"PrimaryType")
		Do tSubItem.Value.SetAt(tRset.Data("InfoTypeId"),"InfoTypeId")
		Do tSubItem.Value.SetAt(tRset.Data("Subtype"),"Subtype")
		Do tSubItem.Value.SetAt(tRset.Data("Icon"),"Icon")
		Do pNVP.SubItems.Insert(tSubItem)		
	}
	Do tRset.Close()
Exit3	///
	Quit tStatus
Trap3	///
	Set $ZT="",tStatus=$$$ERROR($$$ObjectScriptError,$ze)
	Goto Exit3
]]></Implementation>
</Method>

<Method name="OnPreWebMethod">
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	If '$SYSTEM.Security.Check("%HS_WebServices","USE") {
		Set tFault = ..MakeSecurityFault("FailedAuthentication")
		Do ..ReturnFault(tFault)
	}
	Quit
]]></Implementation>
</Method>
</Class>


<Class name="%ZHSLIB.Services.TaskCalculateUpdatedRAndR">
<Description>

This is the task definition for calculating which roles and resources have been updated
on the HUB
 </Description>
<IncludeCode>%ZHSLIB</IncludeCode>
<Super>%SYS.Task.Definition</Super>
<System>4</System>
<TimeChanged>67214,49066.7758083</TimeChanged>
<TimeCreated>67214,49066.7758083</TimeCreated>

<Method name="OnTask">
<Description>
Determine which roles and resources have changed since the last check</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set tStatus = ##class(%ZHSLIB.UsersAndRoles).GetNewSystemRoles(.tRoles,##class(HS.Sync.Utils).IsSyncSlave()) //should only be run on the hub, so IsSyncSlave would return 0
	Set:$$$ISERR(tStatus) tSC=$System.Status.AppendStatus(tStatus,tSC)
	Set tStatus = ##class(HS.Registry.Role).AddUpdateRoles(.tRoles)
	Set:$$$ISERR(tStatus) tSC=$System.Status.AppendStatus(tStatus,tSC)
	Set tStatus =  ##class(%ZHSLIB.UsersAndRoles).CalculateUpdatedRolesResources()
	Set:$$$ISERR(tStatus) tSC=$System.Status.AppendStatus(tStatus,tSC)
	Quit tSC
]]></Implementation>
</Method>

<Method name="Schedule">
<ClassMethod>1</ClassMethod>
<FormalSpec>pNS</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim task as %SYS.Task
	#define TaskName "Calculate Updated Roles And Resources"
	// Some temporary cleanup more than one of these were created for each namespace
	Set tTaskID="",tIsNew=0
	Set tRS=##class(%ResultSet.SQL).%Prepare("SELECT count(ID),ID from %SYS.Task where Name=? AND Namespace=?",.tER,"",$$$TaskName,pNS)
	If '$isObject(tER) {
		Do tRS.%Next() 
		Set tTaskID=tRS.%GetData(2)
		if tRS.%GetData(1)>1 {
			While tRS.%Next() {
				Set tTaskID=tRS.%GetData(2)
				Set tSC=$system.Task.%DeleteId(tTaskID)
				Set tTaskID=""
			}
		}
	}
	If tTaskID {
		/// loop for up to 3 minutes
		For idx=1:1:(3*4) { Set tTaskObj=$system.Task.%OpenId(tTaskID) Quit:$isObject(tTaskObj)  Hang 15}
	} Else {
		Set tTaskObj=$system.Task.%New(),tIsNew=1
	}
	Set tTaskObj.Name=$$$TaskName
	Set tTaskObj.TaskClass=..%ClassName(1)  // The name of the Task Class (where OnTask is)
	Set tTaskObj.NameSpace=pNS  // Namespace the task will run in
	Set tTaskObj.RunAsUser=$$$HSTaskUserName
	if tIsNew {
		Set tTaskObj.DailyFrequency=tTaskObj.DailyFrequencyDisplayToLogical("Several")
		Set tTaskObj.DailyFrequencyTime=tTaskObj.DailyFrequencyTimeDisplayToLogical("Minutes")
		Set tTaskObj.DailyIncrement=5  // (every x hour or x minutes depending on DailyFrequencyTime)
		Set tTaskObj.Expires=1
		Set tTaskObj.StartDate=+$H
	}
	Set tSC=tTaskObj.%Save()
	If tSC Do $System.Task.Resume(tTaskObj.%Id())
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%ZHSLIB.Services.TaskUpdateRolesAndResources">
<Description>

This is the task definition for fetching the updated resources and roles from the HUB
</Description>
<IncludeCode>%ZHSLIB</IncludeCode>
<Super>%SYS.Task.Definition</Super>
<System>4</System>
<TimeChanged>67214,49066.814527</TimeChanged>
<TimeCreated>67214,49066.814527</TimeCreated>

<Method name="OnTask">
<Description>
Fetch updates from hub and process locally</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tPairs As %ZHSLIB.Services.NVPair
	Set tSC = ##class(HS.Util.HubServices).InvokeHubService(
		"%ZHSLIB.Services.Server",
		"%ZHSLIB.Services.Client",
		"GetNVPair",
		.tPairs,
		"ResourcesAndRoles",
		##class(%SYS.System).InstanceGUID()
	)
	IF '$$$ISOK(tSC) {
		If tSC["ZSOAP" {
			For tI=1:1:10 {
				Hang 120
				Set tSC = ##class(HS.Util.HubServices).InvokeHubService(
					"%ZHSLIB.Services.Server",
					"%ZHSLIB.Services.Client",
					"GetNVPair",
					.tPairs,
					"ResourcesAndRoles",
					##class(%SYS.System).InstanceGUID()
				)
				Quit:$$$ISOK(tSC)
			}
		}
		If $$$ISERR(tSC) {
			DO ##Class(Ens.Util.Log).LogError("%ZHSLIB.Services.TaskUpdateRolesAndResources","OnTask",tSC)
			Quit $$$OK
		}
	}
	$$$AddAllRoleTemporary
	// Subscripted array of the format:
	// tDependentRoleNameArray(<role name>) = <instance of %ZHSLIB.Services.NVPair>
	// tDependentRoleNameArray(<role name>, <granted role>) = ""
	Kill tDependentRoleNameArray
	Set tOverallSC = $$$OK
	For idx=1:1:tPairs.SubItems.Count() {
		#dim tItem As %ZHSLIB.Services.NVPair
		Set tItem=tPairs.SubItems.GetAt(idx)
		Set tSC=$$$OK
		If (tItem.Type = "DateTime") {
			Set tDateTime = tItem.Value.GetAt("LastCheck")
			Continue
		} ElseIf (tItem.Type = "Resource") {
			Set tSC = ..HandleResourceChanges(tItem)
		} ElseIf (tItem.Type = "Role") {
			Set tGrantedRoles = tItem.Value.GetAt("GrantedRoles")
			// If deletion or no granted roles, then add
			If (tItem.Value.GetAt("Deleted") = 1) || (tGrantedRoles = "") {
				Set tSC = ..HandleRoleChanges(tItem)
			} Else {
				// Check if all granted roles already exist
				Set tGrantedRolesList = $ListFromString(tGrantedRoles, ",")
				Set tAllRolesExist = 1
				Set tRolePtr = 0
				While $ListNext(tGrantedRolesList, tRolePtr, tGrantedRole) {
					If '..RoleExists(tGrantedRole) {
						Set tAllRolesExist = 0
						Set tDependentRoleNameArray(tItem.Name) = tItem
						Set tDependentRoleNameArray(tItem.Name, tGrantedRole) = ""
					}
				}
				If tAllRolesExist {
					Set tSC = ..HandleRoleChanges(tItem)
				}
			}

		}
		Set tOverallSC = $$$ADDSC(tOverallSC,tSC)
	}

	// Iterate dependent role array and add roles
	Set tRole = ""
	Kill tItem
	// NOTE: This will never end up in an infinite loop/is guaranteed to end.
	// This is because we can never have cyclic dependencies of role A granted to
	// role B and role B granted back to role A (IRIS would prevent this).
	While $Data(tDependentRoleNameArray) {
		Set tRole = $Order(tDependentRoleNameArray(tRole), 1, tItem)
		If (tRole = "") {
			// Restart looping from beginning
			Set tRole = $Order(tDependentRoleNameArray(tRole), 1, tItem)
		}
		// Iterate dependent roles
		Set tContinueWaiting = 0
		Set tDependentRole = ""
		While 1 {
			Set tDependentRole = $Order(tDependentRoleNameArray(tRole, tDependentRole))
			If (tDependentRole = "") {
				Quit
			}
			If '..RoleExists(tDependentRole) {
				Set tContinueWaiting = 1
				Quit
			}
		}
		If tContinueWaiting {
			Continue
		}
		// All granted roles exist so can create this role
		Set tSC = ..HandleRoleChanges(tItem)
		Set tOverallSC = $$$ADDSC(tOverallSC,tSC)
		// Kill entry since role has now been created
		Kill tDependentRoleNameArray(tRole)
	}
	/// issue update with datetime if everything processed okay
	If $$$ISOK(tOverallSC) && ($Get(tDateTime) '= "") {
		Set tSC = ##class(HS.Util.HubServices).InvokeHubService(
			"%ZHSLIB.Services.Server",
			"%ZHSLIB.Services.Client",
			"GetNVPair",
			.tPairs,
			"SetResourcesAndRolesTime",
			##class(%SYS.System).InstanceGUID()_"^"_tDateTime
		)
	}
Exit	Quit tOverallSC
Trap	Set $ZT="",tOverallSC=$$$ERROR($$$ObjectScriptError,$ze)
	goto Exit
]]></Implementation>
</Method>

<Method name="Schedule">
<ClassMethod>1</ClassMethod>
<FormalSpec>pNS:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim task as %SYS.Task
	#define TaskName "Fetch Updated Roles And Resources"

	Set tSC=$$$OK,tTaskID="",tClass=..%ClassName(1)
	#; if only 1 task defined we are done
	&sql(Select count(*),ID into :tRowCount,:ID from %SYS.Task where TaskClass=:tClass)
	#; if there is only one task, make sure we resume it
	If 'SQLCODE && (tRowCount=1) Do $System.Task.Resume(ID) Quit tSC
	#; Some temporary cleanup more than one of these were created for each namespace
	#; try 4 times / min for 5 minutes
	For tIdx=1:1:(5*4) {
		Set tRS=##class(%ResultSet).%New()
		Set tSC=tRS.Prepare("DELETE from %SYS.Task where TaskClass=?")
		Set tSC=tRS.Execute(tClass)
		If $$$ISOK(tSC) Quit
		Hang 15
	}
	IF $$$ISERR(tSC) Quit tSC
	#; if we locate a task %ZHSLIB.Services.TaskCalculateUpdatedRAndR then we must be on the HUB so don't
	#; create a fetch job
	If '..HubIsLocal() {
		Set tTaskObj=$system.Task.%New()
		Set tTaskObj.Name=$$$TaskName
		IF tTaskObj.Description="" {Set tTaskObj.Description=$$$TaskName_" from Hub "}
		Set tTaskObj.TaskClass=..%ClassName(1)  // The name of the Task Class (where OnTask is)
		Set tTaskObj.NameSpace=pNS
		Set tTaskObj.DailyFrequency=tTaskObj.DailyFrequencyDisplayToLogical("Several")
		Set tTaskObj.DailyFrequencyTime=tTaskObj.DailyFrequencyTimeDisplayToLogical("Hourly")
		Set tTaskObj.DailyIncrement=1  // (every x hour or x minutes depending on DailyFrequencyTime)
		Set tTaskObj.Expires=1
		Set tTaskObj.StartDate=+$H
		Set tTaskObj.RunAsUser=$$$HSTaskUserName
		Set tSC=tTaskObj.%Save()
		If tSC Do $System.Task.Resume(tTaskObj.%Id())
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="RunNow">
<ClassMethod>1</ClassMethod>
<FormalSpec>pNS:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim task as %SYS.Task
	#define TaskName "Fetch Updated Roles And Resources"

	Set tSC=$$$OK,tTaskID="",tClass=..%ClassName(1)
	#; if only 1 task defined we are done
	&sql(Select count(*),ID into :tRowCount,:ID from %SYS.Task where TaskClass=:tClass)
	#; if there is only one task, run it
	If ('SQLCODE && (tRowCount=1))
	{
		Do ##class(%SYS.Task).RunNow(ID)
		Do ##class(%SYS.Task).WakeTASKMGR()
		Quit tSC
	}
	#; Some temporary cleanup more than one of these were created for each namespace
	#; try 4 times / min for 5 minutes
	For tIdx=1:1:(5*4) {
		Set tRS=##class(%ResultSet).%New()
		Set tSC=tRS.Prepare("DELETE from %SYS.Task where TaskClass=?")
		Set tSC=tRS.Execute(tClass)
		If $$$ISOK(tSC) Quit
		Hang 15
	}
	IF $$$ISERR(tSC) Quit tSC
	#; if we locate a task %ZHSLIB.Services.TaskCalculateUpdatedRAndR then we must be on the HUB so don't
	#; create a fetch job
	If '..HubIsLocal() {
		Set tTaskObj=##class(%SYS.Task).%New()
		Set tTaskObj.Name=$$$TaskName
		IF tTaskObj.Description="" {Set tTaskObj.Description=$$$TaskName_" from Hub "}
		Set tTaskObj.TaskClass=..%ClassName(1)  // The name of the Task Class (where OnTask is)
		Set tTaskObj.NameSpace=pNS
		Set tTaskObj.TimePeriodEvery=5 // Only run on demand
		Set tTaskObj.Expires=1
		Set tTaskObj.RunAsUser=$$$HSTaskUserName
		Set tSC=tTaskObj.%Save()
		If tSC
		{
			Do ##class(%SYS.Task).RunNow(tTaskObj.%Id())
			Do ##class(%SYS.Task).WakeTASKMGR()
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="HubIsLocal">
<ClassMethod>1</ClassMethod>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set tRS=##class(%ResultSet.SQL).%Prepare("Select ID from %SYS.Task where TaskClass=?",.tER,"","%ZHSLIB.Services.TaskCalculateUpdatedRAndR")
	Quit tRS.%Next()
]]></Implementation>
</Method>

<Method name="RoleExists">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pRoleName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	New $Namespace
	Set $Namespace = "%SYS"
	Return $ClassMethod("Security.Roles", "Exists", pRoleName)
]]></Implementation>
</Method>

<Method name="HandleRoleChanges">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pItem:%ZHSLIB.Services.NVPair</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Try {
		If (pItem.Value.GetAt("Deleted") = 1) {
			Do ##class(HS.HC.SystemConfig.API).DeleteRole($Namespace, pItem.Name)
		} Else {
			Do ##class(HS.HC.SystemConfig.API).AddUpdateRole(
				$Namespace,
				pItem.Name,
				pItem.Value.GetAt("Description"),
				pItem.Value.GetAt("Resources"),
				pItem.Value.GetAt("GrantedRoles")
			)
		}
	} Catch (ex) {
		Set sc = ex.AsStatus()
	}
	Return sc
]]></Implementation>
</Method>

<Method name="HandleResourceChanges">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pItem:%ZHSLIB.Services.NVPair</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Try {
		If (pItem.Value.GetAt("Deleted") = 1) {
			Do ##class(HS.HC.SystemConfig.API).DeleteResource($Namespace, pItem.Name)
		} Else {
			Do ##class(HS.HC.SystemConfig.API).AddUpdateResource(
				$Namespace,
				pItem.Name,
				pItem.Value.GetAt("Description"),
				pItem.Value.GetAt("PublicPermission")
			)
		}
	} Catch (ex) {
		Set sc = ex.AsStatus()
	}
	Return sc
]]></Implementation>
</Method>
</Class>


<Class name="%ZHSLIB.SessionEventUtil">
<Description>
Utility class for use with HealthShare CSP sessions.</Description>
<Abstract>1</Abstract>
<IncludeCode>%sySecurity</IncludeCode>
<System>4</System>
<TimeChanged>67214,49066.466766</TimeChanged>
<TimeCreated>67214,49066.466766</TimeCreated>

<Parameter name="HomeRegistryKey">
<Description>
Config registry key for home page of any HealthShare namespace.</Description>
<Type>STRING</Type>
<Default>\UI\Home</Default>
</Parameter>

<Method name="GetDefaultHomePageForInstance">
<Description>
Returns the default home page for this instance (different depending on
HS/HC/I4H instance).</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$Select(##class(%ZHSLIB.HealthShareMgr).IsHealthShareInstance(): "HS.UI.Home.cls", 1: "HS.HC.UI.Home.cls")
]]></Implementation>
</Method>

<Method name="GetHealthSharePortalLink">
<Description>
This can be invoked from HSLIB or other non-activated namespaces
Is invoked by %CSP.Portal.Home so DO NOT change.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tURL = ..GetHomePageForNamespace(pNamespace)
	Set tType = ##class(%ZHSLIB.HealthShareMgr).GetHealthShareNamespaceType()
	Set tURL = "/csp/healthshare"_$Select((tType = ""): "", 1: "/"_$Namespace)_"/"_tURL
	Set tURL = ##class(%CSP.Page).Link(tURL)
	While (tURL [ "$NAMESPACE=") {
		// Strip it out - we don't want this
		Set tU1 = $Piece(tURL, "$NAMESPACE=")
		Set tU2 = $Piece(tURL, "$NAMESPACE=", 2, *)
		Set tURL = tU1_$Piece(tU2, "&", 2, *)
	}
	Quit tURL
]]></Implementation>
</Method>

<Method name="GetHomePageForNamespace">
<Description>
Returns the CSP/Zen home page stored in the config registry for the provided
namespace. If no namespace is provided, fallback on the default home page
for the instance/federation.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace:%String=""</FormalSpec>
<Implementation><![CDATA[
	Set tNamespaceKey = ..#HomeRegistryKey_"\"_$Case((pNamespace = ""), 1: $Namespace, : pNamespace)
	If '$Data(%session.Data("UILink", tNamespaceKey), tURL) {
		// First try to get namespace specific config registry key
		Set tURL = ..GetRegistryConfigValue(tNamespaceKey, "", pNamespace)
		If (tURL = "") {
			Set tKey = ..#HomeRegistryKey
			// If not present, fall back to global config registry key,
			// which further falls back on hardcoded defaults.
			Set tURL = ..GetRegistryConfigValue(tKey, ..GetDefaultHomePageForInstance(), pNamespace)
		}
		Set %session.Data("UILink", tNamespaceKey) = tURL
	}
	Return tURL
]]></Implementation>
</Method>

<Method name="GetRegistryConfigValue">
<Description>
This can be invoked from HSLIB or other non-activated namespaces</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pKey:%String,pDefault:%String,pNamespace:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	// Need to find the right namespace to find the configuration registry
	// First, look to see if there are any non-Foundation ones that have been activated and aren't disabled
	Set tNamespace = pNamespace
	If (pNamespace = "") {
		Set tNamespace = ""
		While 1 {
			Set tNamespace = $Order(^%SYS("HealthShare", "Instances", tNamespace), 1, tData)
			If (tNamespace = "") {
				Quit
			}
			Set tType = ##class(%ZHSLIB.HealthShareMgr).GetHealthShareNamespaceType(tNamespace)
			Continue:($ListGet(tData, 6) = "")  // Never activated
			Continue:($ListGet(tData, 8))  // Disabled
			Continue:(tType = "Foundation")
			Quit
		}
		// Next, see if the current namespace is an activated non-disabled one which can be Foundation
		If (tNamespace = "") && $Data(^%SYS("HealthShare", "Instances", $Namespace), tData) {
			If ($ListGet(tData, 6) '= "") && '$ListGet(tData, 8) {
				Set tNamespace = $Namespace
			}
		}
	}
	If (tNamespace = "") {
		// If there is no activated namespace
		Quit pDefault
	}
	Quit ..SecureGetRegistryConfigValue(pKey,pDefault,tNamespace)
]]></Implementation>
</Method>

<Method name="SecureGetRegistryConfigValue">
<ClassMethod>1</ClassMethod>
<FormalSpec>pKey,pDefault,pNamespace:%String=""</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tVal = pDefault
	$$$AddAllRoleTemporary
	New $Namespace
	Try {
		Set $Namespace = pNamespace
		Set tVal = ##class(HS.Registry.Config).GetKeyValue(pKey,pDefault)
	} Catch { 
		// In case ^%SYS("HealthShare","Instances" has been corrupted due to a bad uninstall
		Set tVal = pDefault
	}
	Quit tVal
]]></Implementation>
</Method>

<Method name="GetCSPApplicationTimeout">
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	If '$IsObject($Get(%request)) {
		Quit ""
	}
	Quit ..SecureGetCSPApplicationTimeout()
]]></Implementation>
</Method>

<Method name="SecureGetCSPApplicationTimeout">
<ClassMethod>1</ClassMethod>
<Private>1</Private>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set tTimeout= ""
	$$$AddAllRoleTemporary
	Try {
		Set tApplication = %request.Application
		If ($Extract(tApplication, *) = "/") {
			Set tApplication = $Extract(tApplication,1,*-1)
		}
		If $$$SecurityApplicationsExists(tApplication,tAppRecord) {
			Set tTimeout = $$$GetSecurityApplicationsTimeout(tAppRecord)
		}
	} Catch {
		Set tTimeout = ""
	}
	Quit tTimeout
]]></Implementation>
</Method>
</Class>


<Class name="%ZHSLIB.TLS.API">
<TimeChanged>67214,49066.8537944</TimeChanged>
<TimeCreated>67214,49066.8537944</TimeCreated>

<XData name="DemoJSONConfig">
<MimeType>application/json</MimeType>
<Data><![CDATA[
{
  "CAServerConfig": {
    "CAFileName": "HSDEMOCA",
    "CAPath": "",
    "serverPassword": "mypassword",
    "country": "US",
    "stateProvince": "MA",
    "locality": "Cambridge",
    "organization": "InterSystems",
    "organizationalUnit": "HealthShare",
    "commonName": "",
    "validDays": 364
  },
  "UpdateSSLConfig": { "CAPath": "" },
  "CAClientConfig": {
    "CAServerHostName": "",
    "CAServerPort": "",
    "contactName": ""
  },
  "CertSignRequestConfig": {
    "fileNameRoot": "HSDEMOCAClient",
    "country": "US",
    "stateProvince": "MA",
    "locality": "Cambridge",
    "organization": "InterSystems",
    "organizationalUnit": "HealthShare",
    "commonName": "",
    "password": ""
  },
  "CertReqProcessConfig": {
    "fileNameRoot": "HSDEMOCAClient",
    "password": "mypassword",
    "certificateType": 1
  },
  "GetCertConfig": { "fileNameRoot": "HSDEMOCAClient" },
  "WebServerConfig": {
    "webServerPort": "",
    "normalizePort": 1,
    "certFileName": "HSDEMOCAClient.cer",
    "certKeyFileName": "HSDEMOCAClient.key"
  },
  "IRISTLSConfig": {
	"CAFile": "HSDEMOCA.cer",
	"Type": 0,
	"VerifyPeer": 0,
    "CertificateFile": "HSDEMOCAClient.cer",
    "PrivateKeyType": 2,
    "PrivateKeyFile": "HSDEMOCAClient.key",
    "PrivateKeyPassword": "mypassword",
    "Protocols": 24
  }
}
]]></Data>
</XData>

<Method name="ConfigSecureHSDemo">
<Description>
Configurating with default values provided</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
   Set xdataID="%ZHSLIB.TLS.API||DemoJSONConfig"
   Set compiledXdata=##class(%Dictionary.CompiledXData).%OpenId(xdataID,,.sc)
   $$$ThrowOnError(sc)
   Set stream=compiledXdata.Data
   If '$IsObject(stream) {
	   $$$ThrowOnError(%objlasterror)
   }

   // Create a dynamic object from the JSON content and write it as a string
   Set demoConfig = {}.%FromJSON(stream)
	// Create Certificates
	Do ##class(%ZHSLIB.TLS.Utils).ConfigureDemoCAServer(demoConfig.CAServerConfig.%ToJSON())
	Do ##class(%ZHSLIB.TLS.Utils).UpdateSSLConfig(demoConfig.UpdateSSLConfig.%ToJSON())
	Do ##class(%ZHSLIB.TLS.Utils).ConfigureLocalCAClient(demoConfig.CAClientConfig.%ToJSON())
	Do ##class(%ZHSLIB.TLS.Utils).SubmitSigningRequestToCAServer(demoConfig.CertSignRequestConfig.%ToJSON())
	Do ##class(%ZHSLIB.TLS.Utils).ProcessCertificateSigningRequest(demoConfig.CertReqProcessConfig.%ToJSON())
	Do ##class(%ZHSLIB.TLS.Utils).GetCertificateFromCAServer(demoConfig.GetCertConfig.%ToJSON())
	// Config web server to support HTTPS
	Do ##class(%ZHSLIB.TLS.Utils).ConfigWebServerForHTTPS(demoConfig.WebServerConfig.%ToJSON())
	// Config TLS/SSL
    Do ##class(%ZHSLIB.TLS.Utils).CreateIRISTLSConfig(demoConfig.IRISTLSConfig.%ToJSON())
    Do ##class(%ZHSLIB.TLS.Utils).ConfigTLSAccess("{}")
]]></Implementation>
</Method>

<Method name="ConfigSecureHSDemoFromJSON">
<Description>
Configurating with the option to take in a JSON file URI that contains the configuration</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pFilePath:%String</FormalSpec>
<Implementation><![CDATA[
	Do ##class(%ZHSLIB.TLS.Utils).ConfigureDemoCAServer(pFilePath)
	Do ##class(%ZHSLIB.TLS.Utils).UpdateSSLConfig(pFilePath)
	Do ##class(%ZHSLIB.TLS.Utils).ConfigureLocalCAClient(pFilePath)
	Do ##class(%ZHSLIB.TLS.Utils).SubmitSigningRequestToCAServer(pFilePath)
	Do ##class(%ZHSLIB.TLS.Utils).ProcessCertificateSigningRequest(pFilePath)
	Do ##class(%ZHSLIB.TLS.Utils).GetCertificateFromCAServer(pFilePath)
	// Config web server to support HTTPS
	Do ##class(%ZHSLIB.TLS.Utils).ConfigWebServerForHTTPS(pFilePath)
	// Config TLS/SSL
    Do ##class(%ZHSLIB.TLS.Utils).CreateIRISTLSConfig(pFilePath)
    Do ##class(%ZHSLIB.TLS.Utils).ConfigTLSAccess(pFilePath)
]]></Implementation>
</Method>
</Class>


<Class name="%ZHSLIB.TLS.Utils">
<IncludeCode>%ZHSLIB</IncludeCode>
<TimeChanged>67214,49066.8247002</TimeChanged>
<TimeCreated>67214,49066.8247002</TimeCreated>

<Method name="ConfigureDemoCAServer">
<Description><![CDATA[
////////////////////// Utils for creating TLS Certificates //////////////////////////////////////
Step 1
Create a demo certificate authority server to handle certificate signing request
@Argument pCAServerConfig is a string, that can be:
	1. String containing the JSON, e.g. "{""CAFileName"": ""HSDEMOCA""}"
	2. File URI where the source can be read. "C:\testConfig.JSON", which contains:
			2.1 {"CAFileName": "HSDEMOCA"}
			2.2 or {"CAServerConfig": {"CAFileName": "HSDEMOCA"}}
		We support 2.2 in case user want to put multiple configs in a single JSON file.
CAServerConfig: {
    "CAFileName": (Required) String file name root of the CA certificate and private key files (without extension).
    "CAPath": Directory for CA certificate and private key files. Default to be manager directory.
    "serverPassword": (Required) Password to CA's Private Key file.
	"country", "stateProvince", "locality", "organization", "organizationalUnit": Attributes used in constructing this CA server's Subject Distinguished Name.
	"commonName": Attributes used in constructing this CA server's Subject Distinguished Name. Default to be <instanceName> CA
	"validDays": Numeric (days) validity period for CA certificate & certificate issued by CA.
}]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCAServerConfig:%String</FormalSpec>
<Implementation><![CDATA[
	Try {
		Set pCAServerConfig = ##class(%DynamicAbstractObject).%FromJSON(pCAServerConfig)
		If (pCAServerConfig.CAServerConfig '= "") {
			Set pCAServerConfig = pCAServerConfig.CAServerConfig
		}
	} Catch ex {
         $$$ThrowOnError($$$ERROR($$$GeneralError, "Cannot JSON parse "_pCAServerConfig))
	}
	Write !, "Configuring Demo CA server..."
	New $namespace
	Set $namespace="%SYS"
	#dim server as PKI.CAServer
	Set server = ##class(PKI.CAServer).%New()
	Set server.CAFilename = pCAServerConfig.CAFileName
	Set server.CAPath = $Select(pCAServerConfig.CAPath="": $System.Util.ManagerDirectory(), 1: pCAServerConfig.CAPath)
	//C,ST,L,O,OU,CN
	Set $LIST(attrlist,1) = pCAServerConfig.country
	Set $LIST(attrlist,2) = pCAServerConfig.stateProvince
	Set $LIST(attrlist,3) = pCAServerConfig.locality
	Set $LIST(attrlist,4) = pCAServerConfig.organization
	Set $LIST(attrlist,5) = pCAServerConfig.organizationalUnit
	Set $LIST(attrlist,6) = $Select(pCAServerConfig.commonName="": ##class(%SYS.System).GetInstanceName()_" CA", 1: pCAServerConfig.commonName)

	Set result = ##class(PKI.CAServer).Configure(server, attrlist, pCAServerConfig.serverPassword, pCAServerConfig.validDays, .tSC)
	Write !, "Configuring Demo CA server finished: "
    zw result
	$$$ThrowOnError(tSC)
]]></Implementation>
</Method>

<Method name="UpdateSSLConfig">
<Description>
Step 2
Once demo CA server is configured and openssl.cnf exists, update it to have a DNS name (subject alternative name)
which will be the hostname to access server via SSL. This should be the fully qualified host name of your server. In our case, $$$HSNetworkHostName
e.g. USE999myname 
@Argument pUpdateSSLConfig is a string, that can be:
	1. String of the path in JSON, e.g. "{""CAPath"": """"}"
	2. File URI where the path can be read. "C:\testConfig.JSON", which contains:
			2.1 {"CAPath": ""}
			2.2 or {"UpdateSSLConfig": {"CAPath": ""}}
UpdateSSLConfig: {
	CAPath: Directory for CA certificate and private key files. Default to be manager directory.
}</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pUpdateSSLConfig:%String</FormalSpec>
<Implementation><![CDATA[
	Try {
		Set pUpdateSSLConfig = ##class(%DynamicAbstractObject).%FromJSON(pUpdateSSLConfig)
		If (pUpdateSSLConfig.UpdateSSLConfig '= "") {
			Set pUpdateSSLConfig = pUpdateSSLConfig.CAServerConfig
		}
		Set pCAPath = pUpdateSSLConfig.CAPath
	} Catch ex {
         $$$ThrowOnError($$$ERROR($$$GeneralError, "Cannot JSON parse "_pUpdateSSLConfig))
	}
	Write !, "Updating SSL config file..."
	// open target file, and create a temp file to store the content
	Set CAPath = $Select(pCAPath="": $System.Util.ManagerDirectory(), 1: pCAPath)
	Set fileName=##class(%File).NormalizeFilename("openssl.cnf", CAPath)
	Set file=##class(%File).%New(fileName)
	Set newFile=##class(%File).%New(fileName_"new") // create a temporary new file
    If 'file.IsOpen {
		$$$ThrowOnError(file.Open("RW", 2)) // try openning for 2 seconds
		If 'file.IsOpen {
			$$$ThrowOnError($$$ERROR($$$GeneralError, "Cannot open openssl.cnf file"))
		}
	}
	$$$ThrowOnError(newFile.Open("RWN", 2))
	Do file.Rewind()
	// write content to temp file; add the line of $$$HSNetworkHostName in [ TLS_extensions ] section
    while 'file.AtEnd {
        Set line = file.ReadLine(,.tSC)
        $$$ThrowOnError(tSC)
		$$$ThrowOnError(newFile.WriteLine(line))
        If (line["[ TLS_extensions ]") {
			$$$ThrowOnError(newFile.WriteLine("subjectAltName = DNS:"_$$$HSNetworkHostName))
		}
    }
	Do file.Close()
	Do newFile.Close()
	// delete old openssl.cnf file; rename temp file to openssl.cnf
	If '##class(%File).Delete(fileName) {
		$$$ThrowOnError($$$ERROR($$$GeneralError, "Cannot update openssl.cnf file"))
	}
	If '##class(%File).Rename(fileName_"new", fileName) {
		$$$ThrowOnError($$$ERROR($$$GeneralError, "Cannot update openssl.cnf file"))
	}
	Write !, "Updating SSL config file finished."
]]></Implementation>
</Method>

<Method name="ConfigureLocalCAClient">
<Description>
Step 3
Configure a local certificate authority client
@Argument pCAClientConfig is a string, that can be:
	1. String containing the JSON, e.g. "{""CAServerHostName"": ""USE999myname""}"
	2. File URI where the source can be read. "C:\testConfig.JSON", which contains:
			2.1 {"CAServerHostName": "USE999myname"}
			2.2 or {"CAClientConfig": {"CAServerHostName": "USE999myname"}}
		We also support 2.2 in case user want to put multiple configs in a single JSON file.
CAClientConfig: {
	"CAServerHostName": Defeault to $$$HSNetworkHostName
	"CAServerPort": CA webserver's port number. Default to be instance's web server port.
	"contactName": Default to be current username.
}</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCAClientConfig:%String</FormalSpec>
<Implementation><![CDATA[
	Try {
		Set pCAClientConfig = ##class(%DynamicAbstractObject).%FromJSON(pCAClientConfig)
		If (pCAClientConfig.CAClientConfig '= "") {
			Set pCAClientConfig = pCAClientConfig.CAClientConfig
		}
	} Catch ex {
         $$$ThrowOnError($$$ERROR($$$GeneralError, "Cannot JSON parse "_pCAClientConfig))
	}
	Write !, "Start Configuring Local CA Client..."
	New $namespace
	Set $namespace="%SYS"
	Set client = ##class(PKI.CAClient).%New()
	Set client.Server = $Select(pCAClientConfig.CAServerHostName="": $$$HSNetworkHostName, 1:pCAClientConfig.CAServerHostName)
	$$$ThrowOnError(##class(%RoutineMgr).GetWebServerPort(.webPort))
	Set client.Port = $Select(pCAClientConfig.CAServerPort = "": webPort, 1: pCAClientConfig.CAServerPort)
	Set client.ContactName = $Select(pCAClientConfig.contactName = "": $USERNAME, 1: pCAClientConfig.contactName)
	Set result = ##class(PKI.CAClient).Configure(client, .tSC)
	Write !, "Configure Local CA Client finished: "
	zw result
	$$$ThrowOnError(tSC)
]]></Implementation>
</Method>

<Method name="SubmitSigningRequestToCAServer">
<Description><![CDATA[
Step 4
Submit Certificate Signing Request to Certificate Authority server
@Argument pCertSignRequestConfig is a string, that can be:
	1. String containing the JSON, e.g. "{""fileNameRoot"": ""HSDEMOCAClient""}"
	2. File URI where the source can be read. "C:\testConfig.JSON", which contains:
			2.1 {"fileNameRoot": "HSDEMOCAClient"}
			2.2 or {"CertSignRequestConfig": {"fileNameRoot": "HSDEMOCAClient"}}
		We also support 2.2 in case user want to put multiple configs in a single JSON file.
CertSignRequestConfig: {
	"fileNameRoot": (Required) Name of the certificate file without file type extension.
	"country", "stateProvince", "locality", "organization", "organizationalUnit": Attributes used in constructing this CA server's Subject Distinguished Name.
	"commonName": Attributes used in constructing this CA server's Subject Distinguished Name. Default to be <instanceName> Client
	"password":  Optional password used to protect Private Key file.
}]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCertSignRequestConfig:%String</FormalSpec>
<Implementation><![CDATA[
	Try {
		Set pCertSignRequestConfig = ##class(%DynamicAbstractObject).%FromJSON(pCertSignRequestConfig)
		If (pCertSignRequestConfig.CertSignRequestConfig '= "") {
			Set pCertSignRequestConfig = pCertSignRequestConfig.CertSignRequestConfig
		}
	} Catch ex {
         $$$ThrowOnError($$$ERROR($$$GeneralError, "Cannot JSON parse "_pCertSignRequestConfig))
	}
	Write !, "Submitting signing request to CA server..."
	//C,ST,L,O,OU,CN
	Set $LIST(attrlist,1) = pCertSignRequestConfig.country
	Set $LIST(attrlist,2) = pCertSignRequestConfig.stateProvince
	Set $LIST(attrlist,3) = pCertSignRequestConfig.locality
	Set $LIST(attrlist,4) = pCertSignRequestConfig.organization
	Set $LIST(attrlist,5) = pCertSignRequestConfig.organizationalUnit
	Set $LIST(attrlist,6) = $Select(pCertSignRequestConfig.commonName="": ##class(%SYS.System).GetInstanceName()_" Client", 1: pCertSignRequestConfig.commonName)
	// The default Certificate Authority client has the name "IRIS CA"
	New $namespace
	Set $namespace="%SYS"
	Set client = ##class(PKI.CAClient).%OpenId("IRIS CA")
	Set result = client.SubmitCSR(pCertSignRequestConfig.fileNameRoot, attrlist, pCertSignRequestConfig.password, .tSC)
	Write !, "Submitting signing request to CA server finished: "
	zw result
	$$$ThrowOnError(tSC)
]]></Implementation>
</Method>

<Method name="ProcessCertificateSigningRequest">
<Description>
Step 5
Process pending Certificate Signing Requests
@Argument pCertReqProcessConfig is a string, that can be:
	1. String containing the JSON, e.g. "{""fileNameRoot"": ""HSDEMOCAClient""}"
	2. File URI where the source can be read. "C:\testConfig.JSON", which contains:
			2.1 {"fileNameRoot": "HSDEMOCAClient"}
			2.2 or {"CertReqProcessConfig": {"fileNameRoot": "HSDEMOCAClient"}}
		We also support 2.2 in case user want to put multiple configs in a single JSON file.
CertReqProcessConfig: {
	"fileNameRoot": (Required) Name of the certificate file without file type extension.
	"password": (Required) Password for this CA server's Private Key file.
	"certificateType": (Required) Intended usage of the issued certificate. 1 = TLS/SSL, 2 = Intermediate CA server.
	}</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCertReqProcessConfig:%String</FormalSpec>
<Implementation><![CDATA[
	Try {
		Set pCertReqProcessConfig = ##class(%DynamicAbstractObject).%FromJSON(pCertReqProcessConfig)
		If (pCertReqProcessConfig.CertReqProcessConfig '= "") {
			Set pCertReqProcessConfig = pCertReqProcessConfig.CertReqProcessConfig
		}
	} Catch ex {
         $$$ThrowOnError($$$ERROR($$$GeneralError, "Cannot JSON parse "_pCertReqProcessConfig))
	}
	Write !, "Processing certificate signing request..."
	New $namespace
	Set $namespace="%SYS"
	Set requestID = ""
	Set query = "Select ID From PKI.CSR"
	Set statement = ##class(%SQL.Statement).%New()
	$$$ThrowOnError(statement.%Prepare(query))
	Set RS = statement.%Execute()
	While RS.%Next(.tSC) {
		$$$ThrowOnError(tSC)
		If RS.ID[pCertReqProcessConfig.fileNameRoot {
			Set requestID = RS.ID
			Quit
		}
	}
	$$$ThrowOnError(tSC)
	If requestID = "" {
		$$$ThrowOnError($$$ERROR($$$GeneralError, "Cannot find a satisfied pending signing request"))
	}
	// The default Certificate Authority server has the name "IRIS CA"
	Set server = ##class(PKI.CAServer).%OpenId("IRIS CA")
	Set result = server.Sign(requestID, pCertReqProcessConfig.password, pCertReqProcessConfig.certificateType, .tSC)
	Write !, "Processing certificate signing request finished: "
	zw result
	$$$ThrowOnError(tSC)
]]></Implementation>
</Method>

<Method name="GetCertificateFromCAServer">
<Description>
Step 6
Get Certificate(s) from Certificate Authority server
@Argument pGetCertConfig is a string, that can be:
	1. String containing the JSON, e.g. "{""fileNameRoot"": ""HSDEMOCAClient""}"
	2. File URI where the source can be read. "C:\testConfig.JSON", which contains:
			2.1 {"fileNameRoot": "HSDEMOCAClient"}
			2.2 or {"GetCertConfig": {"fileNameRoot": "HSDEMOCAClient"}}
		We also support 2.2 in case user want to put multiple configs in a single JSON file.
fileNameRoot: (Required) Name of the certificate file without file type extension.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pGetCertConfig:%String</FormalSpec>
<Implementation><![CDATA[
	Try {
		Set pGetCertConfig = ##class(%DynamicAbstractObject).%FromJSON(pGetCertConfig)
		If (pGetCertConfig.GetCertConfig '= "") {
			Set pGetCertConfig = pGetCertConfig.GetCertConfig
		}
		Set pFileNameRoot = pGetCertConfig.fileNameRoot
	} Catch ex {
         $$$ThrowOnError($$$ERROR($$$GeneralError, "Cannot JSON parse "_pGetCertConfig))
	}
	Write !, "Getting Certificate(s) from Certificate Authority server..."
	New $namespace
	Set $namespace="%SYS"
	// The default Certificate Authority client has the name "IRIS CA"
	Set client = ##class(PKI.CAClient).%OpenId("IRIS CA")
	Set RS = client.ListCertificates(,,.tSC)
	$$$ThrowOnError(tSC)
	While RS.Next(.tSC) {
		// each row contains 4 parts: serial number, hostname, instancename, filename
		$$$ThrowOnError(tSC)
		Set certificateFileNameRoot = RS.GetData(4)
		If certificateFileNameRoot = pFileNameRoot {
			Set result = client.GetCertificate(RS.GetData(1), .tSC)
			Write !, "Getting Certificate(s) from Certificate Authority server finished: "
			zw result
			$$$ThrowOnError(tSC)
			Return
		}
	}
	$$$ThrowOnError(tSC)
	$$$ThrowOnError($$$ERROR($$$GeneralError, "Cannot find a satisfied certificate."))
]]></Implementation>
</Method>

<Method name="ConfigWebServerForHTTPS">
<Description>
////////////////////// Utils for configuring web server //////////////////////////////////////
Re-Configuring Small/Private Apache Web Server to Serve HTTPS 
Requires that the HealthShare instance's Apache web server to have SSL enabled, specifically:
For Windows, check that httpd/modules directory exists and contains mod file (only need to check for the existance of one file inside)
For Unix, mod_ssl is statically linked into httpd so no need to double check 
This method should be called after TLS certificate has being created
Once webserver restarted, should be able to access SMP of the HS instance
@Argument pWebServerConfig is a string, that can be:
	1. String containing the JSON, e.g. "{""webServerPort"": """"}"
	2. File URI where the source can be read. "C:\testConfig.JSON", which contains:
			2.1 {"webServerPort": ""}
			2.2 or {"WebServerConfig": {"webServerPort": ""}}
		We also support 2.2 in case user want to put multiple configs in a single JSON file.
WebServerConfig: {
    "webServerPort": Numeric port that the web server should be running on. Default to be the port the IRIS web server is running on.
    "normalizePort": Boolean value indicating whether to normalize the port to be in registered port range. Default to be 1.
    "certFileName": (Required) Name of the certificate file WITH file type extension, such as filename.cer, filename.crt. Require full file name including extension to allow flexible and customized certificates.
	"certKeyFileName": (Required) Name of the certificate key file WITH file type extension, such as filename.key.
}</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pWebServerConfig:%String</FormalSpec>
<Implementation><![CDATA[
	Try {
		Set pWebServerConfig = ##class(%DynamicAbstractObject).%FromJSON(pWebServerConfig)
		If (pWebServerConfig.WebServerConfig '= "") {
			Set pWebServerConfig = pWebServerConfig.WebServerConfig
		}
	} Catch ex {
         $$$ThrowOnError($$$ERROR($$$GeneralError, "Cannot JSON parse "_pWebServerConfig))
	}
    // extract the config arguments
    $$$ThrowOnError(##class(%RoutineMgr).GetWebServerPort(.webServerPort))
    Set webServerPort = $Select(pWebServerConfig.webServerPort = "": webServerPort, 1: pWebServerConfig.webServerPort)
    Set normalizePort = $Select(pWebServerConfig.normalizePort = "": 1, 1: pWebServerConfig.normalizePort)
    Set certFileName = pWebServerConfig.certFileName
	Set certKeyFileName = pWebServerConfig.certKeyFileName
    // If need to normalize, use a unique port within the registered port range of 1024-49151
    // Specifically, the new port will be 444 + the last two digits of the original port
	Set webServerPort = $Select(normalizePort = 1: "444"_($Extract("0"_(webServerPort#100), *-1, *)), 1: webServerPort)

    // some helper vals
	Set installDir=$System.Util.DataDirectory()
	Set mgrDir = $System.Util.ManagerDirectory()
	Set pathSep=$EXTRACT(installDir, *)
	Set isWindows = ($SYSTEM.Version.GetOS() = "Windows")

	// Load Apache modules not shipped in the stripped down Apache shipped with HS, specifically for Windows
    If isWindows {
    	Write !, "Checking module file exists or not: "_installDir_"httpd\modules\mod_ssl.so..."
        Set moduleDir = "modules/"
        Set modFileToCheck = ##class(%File).NormalizeFilename("mod_ssl.so", installDir_"httpd"_pathSep_"modules")
		If '##class(%File).Exists(modFileToCheck) {
			$$$ThrowOnError($$$ERROR($$$GeneralError, "Cannot find target file. TLS/SSL is not supported."))
		}
    }	

	Write !, "TLS/SSL supported."
	Write !, "Updating Apache configuration to use TLS..."

	Set configFile=##class(%File).NormalizeFilename(installDir_"httpd"_pathSep_"conf"_pathSep_"httpd-local.conf")
	Open configFile:("RWN"):5 // try opening in Read/Write/New mode for 5 seconds
	If '$Test {
		// Failed to open file
		$$$ThrowStatus($$$ERROR($$$GeneralError,"Cannot open config file: "_configFile_" in RWN mode."))
	}

	// Hard-code config file content and write to file 
	Use configFile
	If isWindows {
		Write "LoadModule headers_module modules/mod_headers.so"
        Write !, "LoadModule ssl_module modules/mod_ssl.so"
	}

	Write !, "Listen "_webServerPort
	Write !, "<VirtualHost _default_:"_webServerPort_">"
	Write !, "	# Header always set Strict-Transport-Security ""max-age=31536000; includeSubDomains"" "
	Write !, "	ErrorLog "_installDir_"httpd"_pathSep_"logs"_pathSep_"ssl_error.log"
	Write !, "	TransferLog logs"_pathSep_"ssl_access.log"
	Write !, "	LogLevel warn"
	Write !, "	SSLEngine on"
	Write !, "	SSLProtocol all -SSLv2"
	Write !, "	SSLCipherSuite ALL:!ADH:!EXPORT:!SSLv2:RC4+RSA:+HIGH:+MEDIUM:+LOW"
	Write !, "	SSLCertificateFile """_##class(%File).NormalizeFilename(certFileName,mgrDir)_""""
	Write !, "	SSLCertificateKeyFile """_##class(%File).NormalizeFilename(certKeyFileName,mgrDir)_""""
	Write !, "	<Files ~ ""\.(cgi|shtml|phtml|php3?)$"">"
	Write !, "		SSLOptions +StdEnvVars"
	Write !, "	</Files>"
	Write !, "	<Directory ""/var/www/cgi-bin"">"
	Write !, "		SSLOptions +StdEnvVars"
	Write !, "	</Directory>"
	Write !, "	CustomLog logs/ssl_request.log \"
	Write !, "		""%t %h %{SSL_PROTOCOL}x %{SSL_CIPHER}x \""%r\"" %b"" "
	Write !, "</VirtualHost>"
	Close configFile

	
	Write !, "Configuration file: "_configFile_" created and updated. Restarting web server..."
	New $namespace
	Set $namespace="%SYS"
	$$$ThrowOnError(##class(Config.Startup).RestartWebServer())
	Write !, "Configuration done."
]]></Implementation>
</Method>

<Method name="CreateIRISTLSConfig">
<Description><![CDATA[
////////////////////// Utils for establishing SSL/TLS Configuration //////////////////////////////////////
Create a new IRIS SSL/TLS configuration
This should happen after getting signed certificates and getting HTTPS support for local instance
Please refer to <class>Security.SSLConfigs</class> for further details on properties
@Argument pIRISTLSConfig is a string, that can be:
	1. String containing the JSON, e.g. "{""Name"":""<your config name>""}"
	2. File URI where the source can be read. "C:\testConfig.JSON", which contains:
			2.1 {"Name":"<your config name>"}
			2.2 or {"IRISTLSConfig": {"Name":"your config name"}}
		We also support 2.2 in case user want to put multiple configs in a single JSON file.
Here are the default arguments we used to create a secure HS Demo in <class>%ZHSLIB.TLS.API</class>
The properties should match the properties in <class>Security.SSLConfigs</class>
IRISTLSConfig: {
     Name: Default to "HS.Secure.Demo" (macro $$$HSDemoSSLConfigName).
     Description: Optional description.
     Enabled: Default to true.
     CAFile: Filename (with extension) of file containing trusted Certificate Authority certificate.
     Type: Default to 0 (Client).
     VerifyPeer: Default to 1 (Require server certificate).
     CertificateFile: Filename (with extension) of file containing this client/server(depends on type)'s certificate.
     PrivateKeyType: Default to 2 (RSA).
     PrivateKeyFile: Filename (with extension) of this configuration's private key.
     PrivateKeyPassword: Password to CA's Private Key file.
     Protocols: Default to 24 (TLSv1.1 + TLSv1.2)
    }
}]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pIRISTLSConfig:%String</FormalSpec>
<Implementation><![CDATA[
	Try {
		Set pIRISTLSConfig = ##class(%DynamicAbstractObject).%FromJSON(pIRISTLSConfig)
		If (pIRISTLSConfig.IRISTLSConfig '= "") {
			Set pIRISTLSConfig = pIRISTLSConfig.IRISTLSConfig
		}
	} Catch ex {
         $$$ThrowOnError($$$ERROR($$$GeneralError, "Cannot JSON parse "_pIRISTLSConfig))
	}
    New $namespace
	Set $namespace="%SYS"
	// Only for configuration name, we provide a default value: $$$HSDemoSSLConfigName, if it is not provided in input
	// Since we need a name to find the object	
	If (pIRISTLSConfig.Name = "") {
		Set pIRISTLSConfig.Name = $$$HSDemoSSLConfigName
	}
	#dim config As Security.SSLConfigs
	If ##class(Security.SSLConfigs).%ExistsId(pIRISTLSConfig.Name) {
		// If already exists, update fields with non-empty input
		Set config = ##class(Security.SSLConfigs).%OpenId(pIRISTLSConfig.Name,,.sc)
		$$$ThrowOnError(sc)
	} Else {
		Set config = ##class(Security.SSLConfigs).%New()
	}
	Set iterator = pIRISTLSConfig.%GetIterator()
	While iterator.%GetNext(.key, .val) {
		Set $Property(config, key) = val
	}
	$$$ThrowOnError(config.%Save())
    Write !, "Configuration saved."
]]></Implementation>
</Method>

<Method name="ConfigTLSAccess">
<Description>
Configure TLS Access so that production web clients can know what TLS settings to use to connect to the web server via SSL/TLS.
@Argument TLSConfig is a string, that can be:
	1. String containing the JSON, e.g. "{""host"": ""USE999myname""}"
	2. File URI where the source can be read. "C:\testConfig.JSON", which contains:
			2.1 {"host": "USE999myname"}
			2.2 or {"TLSConfig": {"host": "USE999myname"}}
		We also support 2.2 in case user want to put multiple configs in a single JSON file.
TLSConfig: {
    host: Webserver host name. Default to be $$$HSNetworkHostName (unchanged).
    port: Webserver port. Default to be the port the IRIS web server is running on.
    webServerPrefix: Only necessary if you are configuring one web server to connect to multiple HealthShare instances.
    active: Boolean value indicating whether the SSL settings are active. Default to 1.
    normalizePort: Boolean value indicating whether to normalize the testing port. Default to be 1.
	secureConfig: IRIS SSL/TLS configuration used for accepting all incoming requests. Default to be $$$HSDemoSSLConfigName.
}</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTLSConfig:%String</FormalSpec>
<Implementation><![CDATA[
	Try {
		Set pTLSConfig = ##class(%DynamicAbstractObject).%FromJSON(pTLSConfig)
		If (pTLSConfig.TLSConfig '= "") {
			Set pTLSConfig = pTLSConfig.TLSConfig
		}
	} Catch ex {
         $$$ThrowOnError($$$ERROR($$$GeneralError, "Cannot JSON parse "_pTLSConfig))
	}
    Write !, "Configuring SSL Access..."
    Set host = $Select(pTLSConfig.host="": $$$HSNetworkHostName, 1: pTLSConfig.host)
    $$$ThrowOnError(##class(%RoutineMgr).GetWebServerPort(.webServerPort))
    Set webServerPort = $Select(pTLSConfig.port = "": webServerPort, 1: pTLSConfig.port)
    Set normalizePort = $Select(pTLSConfig.normalizePort = "": 1, 1: pTLSConfig.normalizePort)
    Set port = $Select(normalizePort=1:"444"_($Extract("0"_(webServerPort#100), *-1, *)), 1: webServerPort)
    Set active = $Select(pTLSConfig.active="":1, 1: pTLSConfig.active)
    Set secureConfig = $Select(pTLSConfig.secureConfig="": $$$HSDemoSSLConfigName, 1: pTLSConfig.secureConfig)
	$$$SetHSNetworkHostName(host)
	$$$SetHSSecurePort(port)
	$$$SetHSSecurePrefix(pTLSConfig.webServerPrefix)
	$$$SetHSSecureActive(active)
	$$$SetHSSecureSSLConfig(secureConfig)
    Write !, "SSL Configuration Done."
]]></Implementation>
</Method>
</Class>


<Class name="%ZHSLIB.UserChangePassword">
<IncludeCode>%ZHSLIB,%occInclude,%occErrors</IncludeCode>
<Super>%ZEN.Component.page</Super>
<System>4</System>
<TimeChanged>67214,49066.4869855</TimeChanged>
<TimeCreated>67214,49066.4869855</TimeCreated>

<Parameter name="APPLICATION">
<Description>
Class name of application this page belongs to.</Description>
<Default>HS.UI.Application</Default>
</Parameter>

<Parameter name="PAGENAME">
<Description>
Displayed name of this page.</Description>
<Default>ChangePassword</Default>
</Parameter>

<Parameter name="DOMAIN">
<Description>
Domain used for localization.</Description>
<Default>HS</Default>
</Parameter>

<XData name="Style">
<Description>
This Style block contains page-specific CSS style definitions.</Description>
<Data><![CDATA[
<style type="text/css">
.centerbox {
	height:100px;
	width: 350px;	
	padding: 5px;
	margin-top:3px;
	border:solid darkblue 3px;
	background: White;
}
body {
	font-family: verdana,Tahoma;
	background-color: AliceBlue;
	background-image: url(/csp/hslib/images/spacer.gif);
	background-repeat: repeat-x;
	background-position: top;
}
.pwbox {
	height:100px;
	width:210px;
	padding: 20px;
	margin-top:0px;
	border:solid lightblue 2px;
	background: AliceBlue;
	}
</style>
]]></Data>
</XData>

<XData name="Contents">
<Description>
This XML block defines the contents of this page.</Description>
<XMLNamespace>http://www.intersystems.com/zen</XMLNamespace>
<Data><![CDATA[
<page xmlns="http://www.intersystems.com/zen" title="Login">
<spacer height="30"/>
 <vgroup align="center" groupClass="centerbox" >
 <!--image width="350" height="125" src="/csp/hslib/images/yourlogo.jpg" align="right"/-->
 <html>
<div style="margin-left: 30px; font-size: 13px; font-weight: bold;">Patient Information Portal</div>
</html>
  <hgroup>
  <spacer width="20"/>
  <loginForm id="passwordForm" groupClass="pwbox">
    <spacer height="0.5"/>
    <hgroup>
    <spacer width="10"/>
    <vgroup>
    <spacer height="10"/>
    <text id="user" name="CacheUserName" label="Username:" />
    <password id="oldpassword" name="CacheOldPassword" label="Old Password:"/>
    <password id="password" name="CachePassword" label="New Password:"/>
    <password id="confirmpw" name="CacheRepeatPassword" label="Confirm Password:" />
    <spacer height="10"/>
    <button id="submit" caption="Submit" onclick="zenPage.confirmPassword();"/>
    <spacer height="10"/>
    </vgroup>
    </hgroup>
  </loginForm>
  </hgroup>
  <html id="ErrorMessageDiv" OnDrawContent="ShowErrorMessage"/>
</vgroup>

</page>
]]></Data>
</XData>

<Method name="confirmPassword">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (zenPage.getComponentById('password').getValue() != zenPage.getComponentById('confirmpw').getValue() ) {
		alert('Passwords not confirmed.  Please correct and try again.');	
	}	
	else {
		zenPage.getComponentById('passwordForm').submit();	
	}
]]></Implementation>
</Method>

<Method name="ShowErrorMessage">
<ClassMethod>1</ClassMethod>
<FormalSpec>pSeed:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if $get(%session.Data("PasswordChangeError",1)) '= "" {
		write %session.Data("PasswordChangeError",1)
		set %session.Data("PasswordChangeError",1) = ""
	}
	else {
		#dim tLoginData As %ZHSLIB.Login.LoginData
		
		Set tStatus = ##class(%ZHSLIB.Login.Utils).CheckLoginRequest(.tLoginData,%request,%session)
		If $$$ISERR(tStatus) {
			Quit tStatus
		}
		If tLoginData.IsLoginError() {
			If (tLoginData.LoginContext = tLoginData.#CONTEXTChangePassword) {
				Write $$$TextHTML("Password Change Required")
			}
			ElseIf ('$system.Status.Equals(tLoginData.LoginStatus,$$$ERRORCODE($$$RequireAuthentication))) {
				Do ShowError^%apiCSP(tLoginData.LoginStatus)
			}
		}
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="onkeydownHandler">
<FormalSpec>evt</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (evt.keyCode == 13) {
		zenPage.confirmPassword();
		return false ;
	}
]]></Implementation>
</Method>

<Method name="onloadHandler">
<Description>
This client event, if present, is fired when the page is loaded.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	zenPage.getComponentById('user').focus();
]]></Implementation>
</Method>

<Method name="%OnAfterCreatePage">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ##class(%ZHSLIB.Login.Utils).GatherChangePasswordData(%session)
]]></Implementation>
</Method>
</Class>


<Class name="%ZHSLIB.UserLogin">
<Super>%ZEN.Component.page</Super>
<System>4</System>
<TimeChanged>67214,49066.5303159</TimeChanged>
<TimeCreated>67214,49066.5303159</TimeCreated>

<Parameter name="APPLICATION">
<Description>
Class name of application this page belongs to.</Description>
<Default>HS.UI.Application</Default>
</Parameter>

<Parameter name="PAGENAME">
<Description>
Displayed name of this page.</Description>
<Default>Login</Default>
</Parameter>

<Parameter name="DOMAIN">
<Description>
Domain used for localization.</Description>
<Default>HS</Default>
</Parameter>

<Parameter name="CHALLENGETIMEOUT">
<Description>
Parameter to control how many seconds we should retain challenge 
information after a failed login attempt.</Description>
<Default>60</Default>
</Parameter>

<Property name="challengeTimeout">
<Description><![CDATA[
Client-side property to store the challenge timeout specified by 
<parameter>CHALLENGETIMEOUT</parameter> in milliseconds.]]></Description>
<Type>%Integer</Type>
<InitialExpression><![CDATA[(1000 * $select(..#CHALLENGETIMEOUT > 0: ..#CHALLENGETIMEOUT, 1: 60))]]></InitialExpression>
</Property>

<XData name="Style">
<Description>
This Style block contains page-specific CSS style definitions.</Description>
<Data><![CDATA[
<style type="text/css">
.centerbox {
	height:100px;
	width: 350px;	
	padding: 5px;
	margin-top:3px;
	border:solid #D3E1EE 5px;
	background: white;
}
body {
	font-family: verdana,Tahoma;
	background-color: AliceBlue;
	background-image: url(/csp/hslib/images/spacer.gif);
	background-repeat: repeat-x;
	background-position: top;
}
.loginbox {
	height:100px;
	width:210px;
	padding: 10px;
	margin-top:0px;
	border:solid gray 1px;
	background: #D3E1EE;
}
.mainTitle {
	font-size: 13px;
	font-weight: bold;
	margin-left: 30px;
}
.loginfailure {
	color: red;
	display: block;
	font-size: 12px;
	font-weight: bold;
	margin-left: auto;
	margin-right: auto;
	padding: 0px;
	padding-top: 10px;
	text-align: center;
}
</style>
]]></Data>
</XData>

<XData name="Contents">
<Description>
This XML block defines the contents of this page.</Description>
<XMLNamespace>http://www.intersystems.com/zen</XMLNamespace>
<Data><![CDATA[
<page xmlns="http://www.intersystems.com/zen" title="Login">
<spacer height="20"/>
 <vgroup align="center" groupClass="centerbox" >
 <!--image width="350" height="100" src="/csp/hslib/images/yourlogo.jpg" align="right"/-->
<label label="Patient Information Portal" labelClass="mainTitle" />
<hgroup>
<spacer width="20"/>
<loginForm id="loginForm" groupClass="loginbox">
<spacer height="0.5"/>
<hgroup>
<spacer width="10"/>
<vgroup>
<text id="user" name="CacheUserName" label="Username:" />
<password id="password" name="CachePassword" label="Password:" />
<spacer height="1"/>
<hgroup>
<submit id="login" caption="Login" />
<spacer width="1"/>
</hgroup>
<label id="loginfailed" hidden="true" label="Login failed!" labelClass="loginfailure" />
<spacer height="1"/>
<button caption="Forgot Password?" id="btnForgotPW" hidden="true" onclick="zenPage.forgotPW();"/>
<label id="lblForgotPWResponse" hidden="true"/>
 </vgroup>
</hgroup>
</loginForm>
</hgroup>
<vgroup id="grpForgotPW" hidden="true">
<spacer height="1"/>
<text id="txtShowUser" label="Username:" disabled="true"/>
<spacer height="1"/>
<text id="txtChallenge" label="Question?" labelClass="caption" size="35"/>
<spacer height="1"/>
<button caption="Request Email" onclick="zenPage.requestEmail();"/>
</vgroup>
</vgroup>

 <!--vgroup id="loginStatement" align="center">
<html>
<div style='text-align:left; padding-left:175px; padding-right: 175px; padding-top: 20px; padding-bottom: 30px; font-weight: normal; font-size: 11px;'>
<i><div style="text-align:center">Customer Acknowledgement:</div>
<br/>
<div>By logging in to this portal, I am acknowledging the following:</div>
<br/>
<div>This is a secure, web-based system to be used for the purpose of exchanging health information among hospitals and providers.  The information contained within this system is confidential and may contain sensitive patient information. All access to the system is recorded and subject to audit. Unauthorized access is prohibited. Sharing of user names and passwords is also prohibited.</div>
<br/>
<div>It is understood that the receipt and review of information found here will not substitute for independent examination, diagnosis, and treatment of the patient. We will not be responsible in whole or in part for any judgments or decisions made based on information obtained from the system.</div>
</i>
</div>
</html>
</vgroup-->
</page>
]]></Data>
</XData>

<Method name="%OnAfterCreatePage">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tLoginData As %ZHSLIB.Login.LoginData

	Set tStatus = ##class(%ZHSLIB.Login.Utils).CheckLoginRequest(.tLoginData,%request,%session,1)
	If $$$ISERR(tStatus) {
		Quit tStatus
	}
	Set ..%GetComponentById("loginfailed").hidden = 'tLoginData.IsLoginError()
	
	If (tLoginData.LoginContext = tLoginData.#CONTEXTChallengeResponse) {
		Set ..%GetComponentById("lblForgotPWResponse").hidden = 0
		Set ..%GetComponentById("lblForgotPWResponse").value = tLoginData.ChallengeResponse
		Set ..%GetComponentById("loginfailed").hidden = 1
	}
	ElseIf (tLoginData.LoginContext = tLoginData.#CONTEXTChallengeAvailable) {
		Set ..%GetComponentById("txtChallenge").label = tLoginData.ChallengeQuestion
		Set ..%GetComponentById("txtShowUser").value = tLoginData.ChallengeForLogin
		Set ..%GetComponentById("btnForgotPW").hidden = 0
	}
 	Quit $$$OK
]]></Implementation>
</Method>

<Method name="forgotPW">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	zen('loginForm').setHidden(true);
	zen('grpForgotPW').setHidden(false);
]]></Implementation>
</Method>

<Method name="requestEmail">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	zenPage.getComponentById("user").setValue(zenPage.getComponentById("txtShowUser").getValue())
	var pwchallenge="*forgot*"+zenPage.getComponentById("txtChallenge").getValue()
	zenPage.getComponentById("password").setValue(pwchallenge)
	zenPage.getComponentById("loginForm").submit();
]]></Implementation>
</Method>

<Method name="onkeydownHandler">
<FormalSpec>evt</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (evt.keyCode == 13) {
		if (!zen("loginForm").getProperty("hidden")){
			zenPage.getComponentById("loginForm").submit();
		}
		else{
			zenPage.requestEmail();	//don't try to log in again from the forgot password screen
		}
	}
]]></Implementation>
</Method>

<Method name="forceReload">
<Description>
Helper method to force the current page to reload and log the user out.
The method is intended to be used when a user's login fails and we have
challenge information available in the browser.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var newLoc = document.location.href;
	var query = document.location.search;
	if (query !== '') {
		newLoc = newLoc.substring(0,newLoc.length - query.length);
	}
	newLoc += '?IRISLogout=end';
	document.location = newLoc;
]]></Implementation>
</Method>

<Method name="onloadHandler">
<Description>
This client event, if present, is fired when the page is loaded.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	zenPage.getComponentById('user').focus();
	var forgotPWButton = zen('btnForgotPW');
	if (forgotPWButton && !forgotPWButton.hidden) {
		var challengeTimeout = parseInt(zenPage.challengeTimeout,10);
		if ((typeof challengeTimeout != 'number') || (challengeTimeout === NaN)) {
			challengeTimeout = 30000;
		}
		// Ensure that we don't keep forgot password challenge in the browser longer than necessary
		setTimeout(zenPage.forceReload, challengeTimeout);
	}
]]></Implementation>
</Method>
</Class>


<Class name="%ZHSLIB.UsersAndRoles">
<Description>
This interface is used specifically for the HealthShare user maintenance interface</Description>
<IncludeCode>%sySecurity,%ZHSLIB</IncludeCode>
<Super>%RegisteredObject</Super>
<System>4</System>
<TimeChanged>67214,49066.5417992</TimeChanged>
<TimeCreated>67214,49066.5417992</TimeCreated>

<Parameter name="DOMAIN">
<Default>%Utility</Default>
</Parameter>

<Method name="GetServiceUser">
<Description>
This will create the special service user, if needed</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	$$$StartSwitch($$$HSInstallationManagement)
	Set tUser=$$$HSServiceUserName,tUserFullName="HealthShare Services and Tasks User", tSC=$$$OK
	// If HS_Services user does not exist, create it.  Updated to pass AccountNeverExpires and PasswordNeverExpires properties.
	If '##class(Security.Users).Exists(tUser,.User) {
		Set $Namespace="HSLIB"
		Set tSC=##class(HS.Util.SystemAPI).Invoke("CreateServiceUser")
	}
	ZN tLocation
Exit	///
	IF $$$ISERR(tSC) Quit ""
	Quit tUser
Trap	///
	Set $ZT="",tStatus=$$$ERROR($$$ObjectScriptError,$ze), tUser=""
	ZN tLocation
	Goto Exit
]]></Implementation>
</Method>

<Method name="GetCreateServiceRole">
<Description><![CDATA[
Check if the service role exists. If not, creates the role.
Returns the name of the service role. <br />
Throws errors. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	New $Namespace
	Set $Namespace = "HSSYS"
	// This will check and create the role if it does not exist
	$$$ThrowOnError(##class(HS.Util.SystemAPI).Invoke("CreateServiceRole"))
	Return $$$HSServiceRole
]]></Implementation>
</Method>

<Method name="AddGroupRoles">
<Description>
need to add validation
Add a Group or Role definiton</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pName:%String,pDescription:%String,pType:%String="Groups"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If pType="Groups" {
		Set tStatus=$$$OK
		If $zcvt($E(pName,1,$l($$$GroupPrefix)),"l")'=$zcvt($$$GroupPrefix,"l") Set pName=$$$GroupPrefix_pName
		Set tName=$p(pName,$$$GroupPrefix,2)
		If $TR($zstrip(tName,"*AN"),".")]"" Set tStatus=$$$ERROR($$$GeneralError,"Only Alpha / Numeric characters separated with . allowed")
		If tStatus For idx=1:1:$l(tName,".") Set tItem=$p(tName,".",idx) if tItem="" Set tStatus=$$$ERROR($$$GeneralError,"Only Alpha / Numeric characters separated with . allowed") Quit
		Quit:'tStatus tStatus
		#;ensure case is correct
		Set $e(pName,1,$l($$$GroupPrefix))=$$$GroupPrefix  
	} Else {
		
	}
	Set tStatus=..AddRole(pName,pDescription) Quit:'tStatus tStatus
	For idx=1:1:($l(pName,".")-1) {
		Set tItem=$p(pName,".",1,idx)
		Set tStatus=..AddRole(tItem,"") Quit:'tStatus
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="AddRole">
<ClassMethod>1</ClassMethod>
<FormalSpec>pName:%String,pDescription:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$StartSwitch($$$HSGroupManagement)
	If ##class(Security.Roles).Exists(pName) {
		Set tProperties("Description")=pDescription
		;# don't want to overwrite the description someone has set just because they add another sub level
		Set:pDescription]"" tStatus=##class(Security.Roles).Modify(pName,.tProperties)
	} Else {
		Set tRole=##class(Security.Roles).%New()
		Set tRole.Name=pName
		Set tRole.Description=pDescription
		Set tStatus=tRole.%Save()
		Set tRole=""
	}
	ZN tLocation
Exit	///
	Quit tStatus
Trap	///
	Set $ZT="",tStatus=$$$ERROR($$$ObjectScriptError,$ze)
	ZN tLocation
	Goto Exit
]]></Implementation>
</Method>

<Method name="UpdateUserStatus">
<ClassMethod>1</ClassMethod>
<FormalSpec>pUsername:%String="",pStatus:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$StartSwitch($$$HSUserManagement)
	Set tProperties("Enabled")=pStatus
	Set tStatus = ##class(Security.Users).Modify(pUsername,.tProperties)
	ZN tLocation
Exit	///
	Quit tStatus
Trap	///
	Set $ZT="",tStatus=$$$ERROR($$$ObjectScriptError,$ze)
	ZN tLocation
	Goto Exit
]]></Implementation>
</Method>

<Method name="AddUserRolesGroups">
<ClassMethod>1</ClassMethod>
<FormalSpec>pUsername:%String,pRoles:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tUsername=$username
	$$$StartSwitch($$$HSUserManagement)
	#; ensure that the user copying has all the roles being copied (HSGroup handled separately)
	Set tStatus=##class(%ZHSLIB.UsersAndRoles).GetUserProperties(tUsername,.tUser) Quit:'tStatus tStatus
	Set tUserRoles=$G(tUser("Roles"))
	Set tRoleFound=0
	If (","_tUserRoles_",")[(","_"%All"_",") Set tRoleFound=1
	Set:'tRoleFound tRoleFound = (","_tUserRoles_",")[(","_pRoles_",")
	If $e(pRoles,1,8)="HSGroup_" && $system.Security.Check($$$HSGroupAssignment,"WRITE") Set tRoleFound=1
	If tRoleFound {
		Set tStatus=##class(Security.Users).AddRoles(pUsername,pRoles,1)
	} Else {
		Set tStatus=$$$ERROR($$$GeneralError,"The user does not have privileges to copy (move) role: "_pRoles)
	}
	ZN tLocation
Exit	///
	Quit tStatus
Trap	///
	Set $ZT="",tStatus=$$$ERROR($$$ObjectScriptError,$ze)
	ZN tLocation
	Goto Exit
]]></Implementation>
</Method>

<Method name="RemoveUserRolesGroups">
<ClassMethod>1</ClassMethod>
<FormalSpec>pUsername:%String,pRoles:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$StartSwitch($$$HSUserManagement)
	Set tStatus=##class(Security.Users).RemoveRoles(pUsername,pRoles)
	ZN tLocation
Exit	///
	Quit tStatus
Trap	///
	Set $ZT="",tStatus=$$$ERROR($$$ObjectScriptError,$ze)
	ZN tLocation
	Goto Exit
]]></Implementation>
</Method>

<Method name="AddUser">
<ClassMethod>1</ClassMethod>
<FormalSpec>pNewUser:%Boolean=1,pCopyFrom:%String,pUsername:%String="",pName:%String="",pPassword:%String="",pComment="",pChangePassword:%Boolean=0,pEnabled:%Boolean=1,pExpirationDate:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tUsername=$username
	$$$StartSwitch($$$HSUserManagement)
	Set tStatus=$$$OK
	If pNewUser {
		If pCopyFrom]"" {
			#; ensure that the user copying has all the roles being copied (HSGroup handled separately)
			Set tStatus=##class(%ZHSLIB.UsersAndRoles).GetUserProperties(tUsername,.tUser) Quit:'tStatus tStatus
			Set tUserRoles=$G(tUser("Roles"))
			Set tStatus=##class(%ZHSLIB.UsersAndRoles).GetUserProperties(pCopyFrom,.tSourceUser) Quit:'tStatus tStatus
			If (","_tUserRoles_",")'[(","_"%All"_",") {
				For tIdx=1:1:$l($g(tSourceUser("Roles")),",") {
					Set tRole=$p(tSourceUser("Roles"),",",tIdx)
					Set tRoleFound = (","_tUserRoles_",")[(","_tRole_",")
					If tRoleFound Continue
					If $e(tRole,1,8)="HSGroup_" && $system.Security.Check($$$HSGroupAssignment,"WRITE") Continue
					Set tStatus=$$$ERROR($$$GeneralError,"The user does not have privileges to copy (move) role: "_tRole) Quit
				}
			}
			If $$$ISERR(tStatus) Quit tStatus
			Set tStatus = ##class(Security.Users).Copy(pCopyFrom,pUsername,pName,$g(SQLSysPrivs,1),$g(SQLObjPrivs,1))
			If $$$ISOK(tStatus) {
				Set pNewUser=0
				Set tStatus = ##class(Security.Users).Get(pCopyFrom,.Properties)
				Set tProperties("Roles") = Properties("Roles")
			}
		} Else {
			Set tStatus=##class(Security.Users).Create(pUsername,"",pPassword,pName,$g(pNamespace),$g(pRoutine),$g(pExpirationDate),$g(pChangePassword),$g(pEnabled),$g(pComment))
		}
	} 
	#; could be reset by copyFrom above
	If tStatus && 'pNewUser {
		Set tProperties("Comment")=pComment
		Set tProperties("FullName")=pName
		Set:pPassword'="" tProperties("Password")=pPassword
		Set tProperties("ChangePassword")=pChangePassword
		Set tProperties("Enabled")=pEnabled
		Set tProperties("ExpirationDate")=pExpirationDate
		Set tStatus=##class(Security.Users).Modify(pUsername,.tProperties)
	}
	ZN tLocation
Exit	///
	Quit tStatus
Trap	///
	Set $ZT="",tStatus=$$$ERROR($$$ObjectScriptError,$ze)
	ZN tLocation
	Goto Exit
]]></Implementation>
</Method>

<Query name="QueryAvailableGroups">
<Description>
only show Group rows which user holds</Description>
<Type>%Query</Type>
<Parameter name="ROWSPEC" value="Name:%String,Description:%String"/>
</Query>

<Method name="QueryAvailableGroupsExecute">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ..AvailableRolesGroups(.qHandle,"Groups")
]]></Implementation>
</Method>

<Method name="QueryAvailableGroupsClose">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>QueryAvailableGroupsExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set idx=$lg(qHandle) if idx Kill ^["^"]HS.ConsentGroups(idx)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="QueryAvailableGroupsFetch">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>QueryAvailableGroupsExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set idx=$lg(qHandle),tItem=$lg(qHandle,2)
	Set Row="",AtEnd=0
	Set tItem=$O(^["^"]HS.ConsentGroups(idx,tItem)) 
	If tItem="" Set AtEnd=1 
	Else  Set Row=^["^"]HS.ConsentGroups(idx,tItem)
	Set $li(qHandle,2)=tItem
	Quit $$$OK
]]></Implementation>
</Method>

<Query name="QueryAvailableRoles">
<Type>%Query</Type>
<Parameter name="ROWSPEC" value="Name:%String,Description:%String"/>
</Query>

<Method name="QueryAvailableRolesExecute">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ..AvailableRolesGroups(.qHandle,"Roles")
]]></Implementation>
</Method>

<Method name="QueryAvailableRolesClose">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>QueryAvailableRolesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set idx=$lg(qHandle) if idx Kill ^["^"]HS.ConsentGroups(idx)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="QueryAvailableRolesFetch">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>QueryAvailableRolesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set idx=$lg(qHandle),tItem=$lg(qHandle,2)
	Set Row="",AtEnd=0
	Set tItem=$O(^["^"]HS.ConsentGroups(idx,tItem)) 
	If tItem="" Set AtEnd=1 
	Else  Set Row=^["^"]HS.ConsentGroups(idx,tItem)
	Set $li(qHandle,2)=tItem
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="AvailableRolesGroups">
<Description>
pType = "Groups" or "Roles"</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,pType:%String,pShowAll:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tRoles = $Roles
	If $System.Security.Check($$$HSGroupAssignment, "WRITE") {
		Set pShowAll = 1
	}
	$$$StartSwitchNP
	#; can only show roles which the user executing the query holds unless they
	#; have GroupAssignment
	For idx=1:1:$Length(tRoles, ",") {
		Set tRole=$Piece(tRoles, ",", idx)
		If (pType = "Groups") {
			If '..IsHealthShareGroupRole(tRole) {
				Set tRole = ""
			}
			For idx2=1:1:($Length(tRole, ".")-1) {
				Set tItem = $Piece(tRole, ".", 1, idx2)
				If (tItem '= "") {
					Set tARoles(tItem) = ""
				}
			}
		} Else {
			If ..IsHealthShareRole(tRole) {
				If ..IsHealthShareGroupRole(tRole) {
					Set tRole = ""
				}
			} Else {
				Set tRole = ""
			}
		}
		If (tRole '= "") {
			Set tARoles(tRole) = ""
		}
	}
	Set idx = $Increment(^["^"]HS.ConsentGroups)
	Set tRS = ##class(%ResultSet).%New("Security.Roles:List")
 	Set tStatus = tRS.Execute()
 	If $$$ISERR(tStatus) {
	 	Return tStatus
 	}
 	Set count = 0
 	While tRS.Next(.tStatus) {
	 	If $$$ISERR(tStatus) {
		 	Return tStatus
	 	}
	 	Set tRole = tRS.GetData(1)
		If (pType = "Groups") {
			If '..IsHealthShareGroupRole(tRole) {
				Set tRole = ""
			}
		} Else {
			If ..IsHealthShareRole(tRole) {
				If ..IsHealthShareGroupRole(tRole) {
					Set tRole = ""
				}
			} Else {
				Set tRole = ""
			}
		}
		If (tRole = "") {
			Continue
		}
		If pShowAll {
			Set tFound = 1
		} Else {
			Set tFound = $Data(tARoles(tRole))
		}
		If 'tFound {
			For idx2=1:1:($Length(tRole, ".")-1) {
				If $Data(tARoles($Piece(tRole, ".", 1, idx2))) {
					Set tFound = 1
				}
			}
		}
		If 'tFound {
			Continue
		}
	 	Set tDescription = tRS.GetData(2)
	 	Set count = count + 1
	 	Set ^["^"]HS.ConsentGroups(idx, count) = $ListBuild(tRole, tDescription)
 	}
 	Set qHandle = $ListBuild(idx, 0)
 	Set tRS = ""
	ZN tLocation
Exit	///
	Quit tStatus
Trap	///
	Set $ZT = ""
	Set tStatus = $$$ERROR($$$ObjectScriptError, $ze)
	ZN tLocation
	Goto Exit
]]></Implementation>
</Method>

<Method name="GetNewSystemRoles">
<Description>
Returns an HS.Message.Roles populated with all healthshare roles that are on the system but not populated into HS.Registry.Role,
where healthshare roles are any roles starting with "%HS" or "HS", but not "%HS_DB"</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pRoles,pIsSyncSlave:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set pRoles=##class(HS.Message.Roles).%New()
	Set pRoles.IsSyncSlave = pIsSyncSlave
	Try{
		For tQuery="QueryAvailableRoles","QueryAllGroups"{
			Set tRS = ##class(%ResultSet).%New("%ZHSLIB.UsersAndRoles:"_tQuery)
			Set tSC = tRS.Execute()
			Quit:$$$ISERR(tSC)
			While (tRS.Next()){
				Set tRoleName=tRS.Data("Name")
				// Skip if not a HealthShare role
				If '..IsHealthShareRole(tRoleName) {
					Continue
				}
				// Skip if its a database access role
				If ..IsHealthShareDatabaseRole(tRoleName) {
					Continue
				}
				// Only support user-created roles being created on the registry instance
				// Make sure the role doesn't match a System level role. This check is needed for cases such as the following:
				// User roles can start with "HS" but Personal Community roles start with "HSPortal" and those can be created
				// on non-registry instances
				If pIsSyncSlave {
					If ..IsHealthShareUserRole(tRoleName) && '..IsHealthShareSystemRole(tRoleName) {
						Continue
					}
				}
				Do ..RecurseRoles(tRoleName,.tGrantedRoles)
				Set tNewRole = ##class(HS.Registry.Role).%New()
				Set tNewRole.RoleName=tRoleName
				Set tCount=1
				For{
						set tGRole = $p(tGrantedRoles,",",tCount)
						Quit:tGRole=""
						Set tCount=tCount+1
						Continue:tGRole=tRoleName
						Do tNewRole.GrantedRoles.Insert(tGRole)
				}
				Set tExistingRole = ##class(HS.Registry.Role).%OpenId(tRoleName)
				If (('$IsObject(tExistingRole))||($e(tRoleName,1,2)="HS")){	//always send user-created roles so we can check for deletions
					Do pRoles.Roles.Insert(tNewRole)
				}
				Else{ ; compare granted roles
					Set tCount=1
					Set tIsDifferent=0
					For{
						set tGRole = $p(tGrantedRoles,",",tCount)
						Set tCount=tCount+1
						Quit:tGRole=""
						Continue:(tGRole=tRoleName)
						Set:(tExistingRole.GrantedRoles.Find(tGRole)=0) tIsDifferent=1
						Quit:(tIsDifferent)
					}
					Continue:'tIsDifferent
					Do pRoles.Roles.Insert(tNewRole)
				}
			}
		}
	}
	Catch ex{
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Query name="QuerySelectedGroups">
<Type>%Query</Type>
<FormalSpec>pUsername:%String=""</FormalSpec>
<Parameter name="ROWSPEC" value="Name:%String,Description:%String"/>
</Query>

<Method name="QuerySelectedGroupsExecute">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,pUsername:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ..SelectedRolesGroups(.qHandle,pUsername,"Groups")
]]></Implementation>
</Method>

<Method name="QuerySelectedGroupsClose">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>QuerySelectedGroupsExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set idx=$lg(qHandle) if idx Kill ^["^"]HS.ConsentGroups(idx)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="QuerySelectedGroupsFetch">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>QuerySelectedGroupsExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set idx=$lg(qHandle),tItem=$lg(qHandle,2)
	Set Row="",AtEnd=0
	Set tItem=$O(^["^"]HS.ConsentGroups(idx,tItem)) 
	If tItem="" Set AtEnd=1 
	Else  Set Row=^["^"]HS.ConsentGroups(idx,tItem)
	Set $li(qHandle,2)=tItem
	Quit $$$OK
]]></Implementation>
</Method>

<Query name="QuerySelectedRoles">
<Type>%Query</Type>
<FormalSpec>pUsername:%String=""</FormalSpec>
<Parameter name="ROWSPEC" value="Name:%String,Description:%String"/>
</Query>

<Method name="QuerySelectedRolesExecute">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,pUsername:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ..SelectedRolesGroups(.qHandle,pUsername,"Roles")
]]></Implementation>
</Method>

<Method name="QuerySelectedRolesClose">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>QuerySelectedRolesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set idx=$lg(qHandle) if idx Kill ^["^"]HS.ConsentGroups(idx)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="QuerySelectedRolesFetch">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>QuerySelectedRolesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set idx=$lg(qHandle),tItem=$lg(qHandle,2)
	Set Row="",AtEnd=0
	Set tItem=$O(^["^"]HS.ConsentGroups(idx,tItem)) 
	If tItem="" Set AtEnd=1 
	Else  Set Row=^["^"]HS.ConsentGroups(idx,tItem)
	Set $li(qHandle,2)=tItem
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="SelectedRolesGroups">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>qHandle:%Binary,pUsername:%String,pType:%String="Groups"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$StartSwitch($$$HSUserManagement)
	Set idx = $i(^["^"]HS.ConsentGroups)
	Set tRS = ##class(%ResultSet).%New("%SQL.Manager.CatalogPriv:UserRole")
	Set tStatus = tRS.Execute(pUsername)
	Set count = 0
	While tRS.Next() {
		Set tRole = tRS.GetData(1)
		Set tDescription = tRS.GetData(2)
		If (pType = "Groups") {
			If '..IsHealthShareGroupRole(tRole) {
				Set tRole = ""
			}
		} Else {
			If ..IsHealthShareRole(tRole) {
				If ..IsHealthShareGroupRole(tRole) {
					Set tRole = ""
				}
			} Else {
				Set tRole=""
			}
		}
		If (tRole = "") {
			Continue
		}
	 	Set count = count + 1
	 	Set ^["^"]HS.ConsentGroups(idx, count) = $ListBuild(tRole, tDescription)
	}
	Set qHandle = $ListBuild(idx, 0)
	ZN tLocation
Exit	///
	Quit tStatus
Trap	///
	Set $ZT = ""
	Set tStatus = $$$ERROR($$$ObjectScriptError, $ze)
	ZN tLocation
	Goto Exit
]]></Implementation>
</Method>

<Method name="DeleteRole">
<Description>
Delete Group or Role</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$StartSwitch($$$HSGroupManagement)
	Set tStatus=##class(Security.Roles).Delete(pName)
	Set tRS=##class(%ResultSet).%New("Security.Roles:List")
	Set tStatus=tRS.Execute(pName_".*")
	If tStatus {
		While tRS.Next() {
			Set tName=tRS.GetData(1)
			Set tAry(tName)=""
			//Set tStatus=##class(Security.Roles).Delete(tName)
			
		}
		Set tName=""
		For  {
			Set tName=$o(tAry(tName)) Quit:tName=""
			Set tStatus=##class(Security.Roles).Delete(tName)
		}
	}
	Set tRS=""
	ZN tLocation
Exit	///
	Quit tStatus
Trap	///
	Set $ZT="",tStatus=$$$ERROR($$$ObjectScriptError,$ze)
	ZN tLocation
	Goto Exit
]]></Implementation>
</Method>

<Method name="DeleteUser">
<Description>
Delete User</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$StartSwitch($$$HSUserManagement)
	Set tStatus=##class(Security.Users).Delete(pName)
	ZN tLocation
Exit	///
	Quit tStatus
Trap	///
	Set $ZT="",tStatus=$$$ERROR($$$ObjectScriptError,$ze)
	ZN tLocation
	Goto Exit
]]></Implementation>
</Method>

<Method name="GetRoleGroupDescription">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pName:%String="",&pDescription]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$StartSwitch($$$HSGroupManagement)
	Set tStatus=##class(Security.Roles).Get(pName,.tProperties)
	If tStatus Set pDescription=tProperties("Description")
	ZN tLocation
Exit	///
	Quit tStatus
Trap	///
	Set $ZT="",tStatus=$$$ERROR($$$ObjectScriptError,$ze)
	ZN tLocation
	Goto Exit
]]></Implementation>
</Method>

<Method name="UpdateRoleGroupDescription">
<ClassMethod>1</ClassMethod>
<FormalSpec>pName:%String="",pDescription:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$StartSwitch($$$HSGroupManagement)
	Set tProperties("Description")=pDescription
	Set tStatus=##class(Security.Roles).Modify(pName,.tProperties)
	ZN tLocation
Exit	///
	Quit tStatus
Trap	///
	Set $ZT="",tStatus=$$$ERROR($$$ObjectScriptError,$ze)
	ZN tLocation
	Goto Exit
]]></Implementation>
</Method>

<Method name="GetUserProperties">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pUsername:%String,&pProperties]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$StartSwitch($$$HSUserManagement)
	Set tStatus=##class(Security.Users).Get(pUsername,.pProperties)
	ZN tLocation
Exit	///
	Quit tStatus
Trap	///
	Set $ZT="",tStatus=$$$ERROR($$$ObjectScriptError,$ze)
	ZN tLocation
	Goto Exit
]]></Implementation>
</Method>

<Query name="QueryAvailableUsers">
<Type>%Query</Type>
<FormalSpec>pFilter:%String=""</FormalSpec>
<Parameter name="ROWSPEC" value="Username:%String,Name:%String,Enabled:%Boolean"/>
</Query>

<Method name="QueryAvailableUsersExecute">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,pFilter:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$StartSwitch($$$HSUserManagement)
	Set idx=$i(^["^"]HS.ConsentGroups)
	Set pFilter=$zcvt(pFilter,"l")
	Set tRS=##class(%ResultSet).%New("%SQL.Manager.CatalogPriv:Users")
 	Set tStatus=tRS.Execute() Quit:'tStatus tStatus
 	Set count=0
 	While tRS.Next() {
	 	Set tUsername=tRS.Get("USERNAME")
	 	If pFilter]"" && ($zcvt($e(tUsername,1,$l(pFilter)),"l")'=pFilter) Continue
	 	Set count=count+1
	 	Set ^["^"]HS.ConsentGroups(idx,count)=$lb(tUsername,tRS.Get("FULLNAME"),tRS.Get("ENABLED"))
 	}
 	Set qHandle=$lb(idx,0),tRS=""
	ZN tLocation
Exit	///
	Quit tStatus
Trap	///
	Set $ZT="",tStatus=$$$ERROR($$$ObjectScriptError,$ze)
	ZN tLocation
	Goto Exit
]]></Implementation>
</Method>

<Method name="QueryAvailableUsersClose">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>QueryAvailableUsersExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set idx=$lg(qHandle) if idx Kill ^["^"]HS.ConsentGroups(idx)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="QueryAvailableUsersFetch">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>QueryAvailableUsersExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set idx=$lg(qHandle),tItem=$lg(qHandle,2)
	Set Row="",AtEnd=0
	Set tItem=$O(^["^"]HS.ConsentGroups(idx,tItem)) 
	If tItem="" Set AtEnd=1 
	Else  Set Row=^["^"]HS.ConsentGroups(idx,tItem)
	Set $li(qHandle,2)=tItem
	Quit $$$OK
]]></Implementation>
</Method>

<Query name="QueryAllGroups">
<Type>%Query</Type>
<Parameter name="ROWSPEC" value="Name:%String,Description:%String"/>
</Query>

<Method name="QueryAllGroupsExecute">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ..AvailableRolesGroups(.qHandle,"Groups",1)
]]></Implementation>
</Method>

<Method name="QueryAllGroupsClose">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>QueryAllGroupsExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set idx=$lg(qHandle) if idx Kill ^["^"]HS.ConsentGroups(idx)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="QueryAllGroupsFetch">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>QueryAllGroupsExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set idx=$lg(qHandle),tItem=$lg(qHandle,2)
	Set Row="",AtEnd=0
	Set tItem=$O(^["^"]HS.ConsentGroups(idx,tItem)) 
	If tItem="" Set AtEnd=1 
	Else  Set Row=^["^"]HS.ConsentGroups(idx,tItem)
	Set $li(qHandle,2)=tItem
	Quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
/*
	Roles changed since last run
	^HS.RandR("Current","Role",tRole,"Roles")=granted roles
	^HS.RandR("Current","Role",tRole,"Resources")=resources
	^HS.RandR("Current","Role",tRole,"Description")=description
	
	^HS.RandR("Current","Resource",tResource,"Description")=Description
	^HS.RandR("Current","Resource",tResource,"PublicPermission")=PublicPermission
	
	^HS.RandR("Modified",Date,Time,"Resource",tResource)=""
	^HS.RandR("Modified",Date,Time,"Role",tRole)=""
	*/
]]></Content>
</UDLText>

<Method name="CalculateUpdatedRolesResources">
<Description>
Determine the roles / resources that have changed since the last time run</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	#define Storage ^[tLocation]HS.RandR
	
	$$$StartSwitchNP
	LOCK +($$$Storage)
	
	Set tModifiedDate=$H,tModifiedTime=$p(tModifiedDate,",",2),tModifiedDate=+tModifiedDate
	Kill $$$Storage("Exists")
	// Get HealthShare role/resource prefixes
	Set tHealthShareRolePrefixList = ""
	Set tRolePointer = 0
	While $ListNext($$$HSRolesPrefixList, tRolePointer, tRolePrefix) {
		Set tHealthShareRolePrefixList = tHealthShareRolePrefixList _ $ListBuild(tRolePrefix_"*")
	}
	Set tHealthShareRolePrefixString = $ListToString(tHealthShareRolePrefixList)
	
	Set tRS=##class(%ResultSet).%New("Security.Resources:List")
	Set tStatus=tRS.Execute(tHealthShareRolePrefixString)
	While tRS.Next() {
		Set tName=tRS.Get("Name")
		Set tDescription=tRS.Get("Description")
		Set tPublicPermission=tRS.Get("PublicPermission")
		Set tModified=0
		if $G($$$Storage("Current","Resource",tName,"PublicPermission"))'=tPublicPermission Set tModified=1,$$$Storage("Current","Resource",tName,"PublicPermission")=tPublicPermission 
		if $G($$$Storage("Current","Resource",tName,"Description"))'=tDescription Set tModified=1,$$$Storage("Current","Resource",tName,"Description")=tDescription
		Set:tModified $$$Storage("Modified","Resource",tModifiedDate,tModifiedTime,tName)=""
		Set $$$Storage("Exists","Resource",tName)=""
	}
	Set tRS="" Kill tAry
	Set tRS=##class(%ResultSet).%New("Security.Roles:Detail")
	Set tStatus=tRS.Execute(tHealthShareRolePrefixString)
	While tRS.Next() {
		Set tName=tRS.Get("Name")
		If ..IsHealthShareDatabaseRole(tName) {
			Continue
		}
		Set tAry(tName,"Description")=tRS.Get("Description")
		Set tAry(tName,"GrantedRoles")=tRS.Get("GrantedRoles")
		Set tAry(tName,"Resources")=$g(tAry(tName,"Resources"))_","_tRS.Get("Resources")
	}
	Set tName=""
	For  {
		Set tName=$o(tAry(tName)) Quit:tName=""
		Set tModified=0
		Set tDescription=tAry(tName,"Description")
		Set tGrantedRoles=tAry(tName,"GrantedRoles")
		Set tResources=$e(tAry(tName,"Resources"),2,*)
		Set:$G($$$Storage("Current","Role",tName,"Roles"),$C(1))'=tGrantedRoles tModified=1,$$$Storage("Current","Role",tName,"Roles")=tGrantedRoles 
		Set:$G($$$Storage("Current","Role",tName,"Resources"),$c(1))'=tResources tModified=1,$$$Storage("Current","Role",tName,"Resources")=tResources
		Set:$G($$$Storage("Current","Role",tName,"Description"),$c(1))'=tDescription tModified=1,$$$Storage("Current","Role",tName,"Description")=tDescription
		Set:tModified $$$Storage("Modified","Role",tModifiedDate,tModifiedTime,tName)=""
		Set $$$Storage("Exists","Role",tName)=""
	}
	Set $$$Storage("Current")=tModifiedDate_","_tModifiedTime

	#; items may have been previously deleted and now recreated, if so, remove the deleted entry
	Set (tType,tDate,tTime,tName)=""
	For {
		Set tType=$O($$$Storage("Deleted",tType)) Quit:tType=""
		For  {
			Set tDate=$O($$$Storage("Deleted",tType,tDate)) Quit:tDate=""
			For  {
				Set tTime=$O($$$Storage("Deleted",tType,tDate,tTime)) Quit:tTime=""
				For  {
					Set tName=$O($$$Storage("Deleted",tType,tDate,tTime,tName)) Quit:tName=""
					If '$D($$$Storage("Exists",tType,tName)) Continue
					Kill $$$Storage("Deleted",tType,tDate,tTime,tName)
				}
			}
		}
	}

	For tNode2="Role","Resource" {
		Set tName="" 
		For  {
			Set tName=$O($$$Storage("Current",tNode2,tName)) Quit:tName=""
			If $D($$$Storage("Exists",tNode2,tName)) Continue
			Set $$$Storage("Deleted",tNode2,tModifiedDate,tModifiedTime,tName)=""
			Kill $$$Storage("Current",tNode2,tName)
		}
	}

	Set tRS=""
	ZN tLocation
Exit	///
    LOCK -($$$Storage)
	Quit tStatus
Trap	///
	Set $ZT="",tStatus=$$$ERROR($$$ObjectScriptError,$ze)
	ZN tLocation
	Goto Exit
]]></Implementation>
</Method>

<Method name="UpdatedRolesResources">
<Description>
build list of resources/roles that have been updated since a point in time</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pSystem:%String="",&pAry:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $zt="Error"
	#define Storage ^HS.RandR
	Set pModifiedDateTime=$G($$$Storage("LastCheck",pSystem)),tNow=$$$Storage("Current")
	For tNode2="Resource","Role" {
		For tNode1="Modified","Deleted" {
			Set tName=""
			Do getStartInfo(pModifiedDateTime,.tStartDate,.tStartTime,tNode1,tNode2)
			Continue:tStartDate=""
			For  {
				For  {
					Set tStartTime=$O($$$Storage(tNode1,tNode2,tStartDate,tStartTime)) Quit:tStartTime=""
					For  {
						Set tName=$O($$$Storage(tNode1,tNode2,tStartDate,tStartTime,tName)) Quit:tName=""
						If tNode1="Modified" {
							Merge pAry(tNode1,tNode2,tName)=$$$Storage("Current",tNode2,tName)
						} Else {
							Set pAry(tNode1,tNode2,tName)=""
						}
					}
				}
				Set tStartDate=$O($$$Storage(tNode1,tNode2,tStartDate)) Quit:tStartDate=""
			}
		}
	}
	Set pAry("LastCheck")=tNow
	Quit $$$OK
Error	///
	Do BACK^%ETN
	Quit $$$ERROR($$$ObjectScriptError,$ze)

getStartInfo(pModifiedDateTime,tStartDate,tStartTime,tNode1,tNode2)
	If pModifiedDateTime="" {
		Set (tStartDate,tStartTime)=""
	} Else {
		Set tStartDate=+pModifiedDateTime,tStartTime=$p(pModifiedDateTime,",",2)
	}
	Set:tStartDate="" tStartDate=$o($$$Storage(tNode1,tNode2,""))
	Quit
]]></Implementation>
</Method>

<Method name="SetUpdatedRolesResources">
<ClassMethod>1</ClassMethod>
<FormalSpec>pSystem:%String="",pTime:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#define Storage ^HS.RandR
	Set $$$Storage("LastCheck",pSystem)=pTime
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="CheckPermission">
<ClassMethod>1</ClassMethod>
<FormalSpec>pRoles:%String,pResource:%String,pPermission:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	//Any privilege checking should occur here
	Set tSC = ..SecureGetResourceSet(pRoles,.tResources)
	Set pPermission=$ZCVT($E(pPermission_"U"),"U"), tResources=","_$ZCVT(tResources,"U"), pResource=$ZCVT(pResource,"U")_":"
	Set tPerm=$P($P(tResources,pResource,2),",")
	Quit tPerm[pPermission
]]></Implementation>
</Method>

<Method name="SecureGetResourceSet">
<ClassMethod>1</ClassMethod>
<FormalSpec>pRoles:%String,*pResourceSet:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$AddAllRoleTemporary
	New $Namespace Set $Namespace="%SYS"
	Set tSC=##Class(Security.Users).GetResourceSet(,pRoles,.pResourceSet)
	Quit tSC
]]></Implementation>
</Method>

<Method name="RecurseRoles">
<ClassMethod>1</ClassMethod>
<FormalSpec>pLoginRoles:%String,*pUserRoles:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	//Any privilege checking should occur here
	Quit ..RecurseRolesSecure(pLoginRoles,.pUserRoles)
]]></Implementation>
</Method>

<Method name="RecurseRolesSecure">
<ClassMethod>1</ClassMethod>
<FormalSpec>pLoginRoles:%String,*pUserRoles:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$AddAllRoleTemporary
	New $Namespace Set $Namespace="%SYS"
	Quit ##Class(Security.Roles).RecurseRoleSet(pLoginRoles,.pUserRoles)
]]></Implementation>
</Method>

<Method name="CheckAndCreateEvent">
<Description>
Check whether a specific event exists or not; if not, create the event</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pSource:%String,pType:%String,pName:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$AddAllRoleTemporary
	New $Namespace 
	Set $Namespace="%SYS"
	Set tEventExists = ##class(Security.Events).Exists(pSource, pType, pName, ,.tSC)
	If ('tEventExists) {
		Set tSC = ##class(Security.Events).Create(pSource, pType, pName, "Create audit event "_pType)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="PasswordResetRequested">
<Description>
This will be called when the user click the forgot password link on universal-login page
After the user submits a pair of username and domain successfully, this event will be logged
Default to be excluded</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pLoginID:%String,pDomain:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tEventType = "PasswordResetRequested"
	Set tDetails = "User requested to reset their password from the Universal Login Application."
	Quit ..PasswordResetEvents(tEventType, pLoginID, pDomain, tDetails)
]]></Implementation>
</Method>

<Method name="PasswordResetSendEmailFailure">
<Description>
Audit event for failure in sending the email which contains the link to the password reset page
Default to be excluded</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pLoginID:%String,pDomain:%String,pDetails:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tEventType = "PasswordResetSendEmailFailure"
	Set pDetails = "Failed to send the email containing reset-password link to the user. Error: "_pDetails
	Quit ..PasswordResetEvents(tEventType, pLoginID, pDomain, pDetails)
]]></Implementation>
</Method>

<Method name="PasswordResetFailure">
<Description>
Audit event for failure in resetting the password (after submitting the new password on password reset page)
Default to be excluded</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pLoginID:%String,pDomain:%String,pDetails:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tEventType = "PasswordResetFailure"
	Set pDetails = "Failed to reset the user's password. Error: "_pDetails
	Quit ..PasswordResetEvents(tEventType, pLoginID, pDomain, pDetails)
]]></Implementation>
</Method>

<Method name="PasswordResetSuccess">
<Description>
Audit event for successfully resetting the password
Default to be excluded</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pLoginID:%String,pDomain:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tEventType = "PasswordResetSuccess"
	Set tDetails = "Successfully reset the user's password."
	Quit ..PasswordResetEvents(tEventType, pLoginID, pDomain, tDetails)
]]></Implementation>
</Method>

<Method name="PasswordResetEvents">
<ClassMethod>1</ClassMethod>
<FormalSpec>pEventType:%String,pLoginID:%String,pDomain:%String,pDetails:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim %request As %CSP.Request
	Set tData = ""
	If $IsObject(%request) {
		Set tData = "Web Application: "_%request.URL
	}
	Set tData = tData_pEventType_" - Username: "_pLoginID_"  Domain: "_pDomain
	If ($Data(pDetails) && $Length(pDetails)) {
		Set tData = tData_"  Details: "_pDetails
	}
	Set tDescription = $Piece(pDetails, "Error:")
	Set tSC = ..CheckAndCreateEvent("HS_System", "HS_Security", pEventType)
	If $$$ISERR(tSC) {
		Quit tSC
	}
	Quit $system.Security.Audit("HS_System", "HS_Security", pEventType, tData, tDescription)
]]></Implementation>
</Method>

<Method name="AuditOAuth2Login">
<Description><![CDATA[
Helper method to audit logins for OAuth 2.0-driven authentication and authorization events.
<p>
<strong>WARNING:</strong> This method is for InterSystems internal use only and is subject to change
in future releases.
</p>]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pUsername:%String=$username,pRoles:%String=$roles,pCSPApplication:%String,pMode:%String(VALUELIST=",authenticate,authorize")</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tInitialUsername = $username
	Try {
		// NOTE: We don't call $$$AuditLoginSuccess here because it can only log roles from $roles for truly completed logins
		// As such, we mimic the structure of the audit event produced from that code if login auditing is enabled
		If $$$LoginAuditIsOn {
			$$$AddAllRoleTemporaryInTryCatch
			
			// Set pUsername into $username
			Set tParseStatus = $$$ParseUsername(pUsername,,,,1)
			// Note that we will continue with the code here if tParseStatus returns an error,

			Set tRoleStringLimit = 3000
			Set tRoleInfo = $select($length(pRoles) <= tRoleStringLimit: pRoles, 1: $extract(pRoles,1,tRoleStringLimit)_"(TRUNCATED)")
			Set tAuditDescription = $$$FormatMsg($$$UsersMsg,"ApplicationServiceLogin",pCSPApplication)
			Set tAuditDetails = ""
			Set tAuditPadding = $justify("",20)
			Set tAuditDetails = tAuditDetails _ $extract($$$GetMsg($$$UsersMsg,"CSPApplicationC")_tAuditPadding,1,$length(tAuditPadding)) _ pCSPApplication _ $char(13,10)
			Set tAuditDetails = tAuditDetails _ $extract($$$GetMsg($$$UsersMsg,"LoginRolesC")_tAuditPadding,1,$length(tAuditPadding)) _ tRoleInfo _ $char(13,10)
			Set tAuditDetails = tAuditDetails _ $extract($$$GetMsg($$$UsersMsg,"DollarIC")_tAuditPadding,1,$length(tAuditPadding))_ $IO _ $char(13,10)
			Set tAuditDetails = tAuditDetails _ $extract($$$GetMsg($$$UsersMsg,"DollarPC")_tAuditPadding,1,$length(tAuditPadding))_ $PRINCIPAL _ $char(13,10)
			Set tOAuthAction = $case(pMode, "authenticate": "Authentication", "authorize": "Authorization", : "")
			Set tOAuthAction = "OAuth2.0" _ $select(tOAuthAction = "": "", 1: " " _ tOAuthAction)
			Set tAuditDetails = tAuditDetails _ tOAuthAction _ $char(13,10)
			Set tStatus = $system.Security.Audit($$$SourceSystem,$$$TypeLogin,$$$NameLogin,tAuditDetails,tAuditDescription)
		}
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If (tInitialUsername '= $username) {
		// Ensure that we reset the username before we pop up the stack
		Set tStatus = $$$ADDSC(tStatus,$$$ParseUsername(tInitialUsername,,,,1))
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="IsHealthShareRole">
<Description><![CDATA[
Checks if the role <var>pRole</var> is a valid HealthShare role by checking if its prefix
matches one of the allowed prefixes. <br />
Returns 1 if at least one of the prefixes is matched against. 0 otherwise.
@Argument	pRole		Name of role. <br />]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pRole:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit ..StringMatchesPrefixInList(pRole, $$$HSRolesPrefixList)
]]></Implementation>
</Method>

<Method name="IsHealthShareSystemRole">
<Description><![CDATA[
Checks if the role <var>pRole</var> is a valid HealthShare system role by checking if its
prefix matches one of the allowed system prefixes. <br />
Returns 1 if at least one of the prefixes is matched against. 0 otherwise.
@Argument	pRole		Name of role. <br />]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pRole:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit ..StringMatchesPrefixInList(pRole, $$$HSSystemRolesPrefixList)
]]></Implementation>
</Method>

<Method name="IsHealthShareUserRole">
<Description><![CDATA[
Checks if the role <var>pRole</var> is a valid HealthShare user role by checking if its
prefix matches one of the allowed user prefixes. <br />
Returns 1 if at least one of the prefixes is matched against. 0 otherwise.
@Argument	pRole		Name of role. <br />]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pRole:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit ..StringMatchesPrefixInList(pRole, $$$HSUserRolesPrefixList)
]]></Implementation>
</Method>

<Method name="IsHealthShareDatabaseRole">
<Description><![CDATA[
Checks if the role <var>pRole</var> is a valid HealthShare database role by checking if its
prefix matches one of the allowed database prefixes. <br />
Returns 1 if at least one of the prefixes is matched against. 0 otherwise.
@Argument	pRole		Name of role. <br />]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pRole:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit ..StringMatchesPrefixInList(pRole, $$$HSDatabaseRolesPrefixList)
]]></Implementation>
</Method>

<Method name="IsHealthShareGroupRole">
<Description><![CDATA[
Checks if the role <var>pRole</var> is a valid HealthShare group role by checking if its
prefix matches one of the allowed group prefixes. <br />
Returns 1 if at least one of the prefixes is matched against. 0 otherwise.
@Argument	pRole		Name of role. <br />]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pRole:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit ..StringMatchesPrefixInList(pRole, $ListBuild($$$GroupPrefix))
]]></Implementation>
</Method>

<Method name="StringMatchesPrefixInList">
<Description><![CDATA[
Checks if the string <var>pItem</var> has a prefix that matches one of the elements of the given
list of prefixes <var>pPrefixList</var> <br />
Returns 1 if at least one of the prefixes is matched against. 0 otherwise. <br />
@Argument	pItem			String to match. <br />
@Argument	pPrefixList		List of strings that represent prefixes to match against. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pItem:%String,pPrefixList:%List</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set tPointer = 0
	While $ListNext(pPrefixList, tPointer, tPrefix) {
		If $$$PrefixMatch(pItem, tPrefix) {
			// Match found
			Return 1
		}
	}
	// No match found
	Return 0
]]></Implementation>
</Method>
</Class>


<Class name="%ZHSLIB.Version">
<Description><![CDATA[
This class provides various HealthShare product version information.
Format and method naming is inspired by <class>%SYSTEM.Version</class>.]]></Description>
<Abstract>1</Abstract>
<IncludeCode>%ZHSLIB</IncludeCode>
<TimeChanged>67214,49066.5375553</TimeChanged>
<TimeCreated>67214,49066.5375553</TimeCreated>

<Method name="GetFullBuildNumber">
<Description><![CDATA[
Returns the full build number <major>.<minor>.<maintenance>.<number>.<patch>.<adhoc>
for the product. <br />
@API.Method]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$BuildNumberGbl
]]></Implementation>
</Method>

<Method name="GetNumber">
<Description><![CDATA[
Returns the <major>.<minor>.<maintenance> part of the full build number for the product with format:
<major>.<minor>.<maintenance>.<number>.<patch>.<adhoc>. <br />
@Argument	pBuildNumber		Unique build number of the build. Default to be the current build number. <br />
@API.Method]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pBuildNumber:%String=$Get($$$BuildNumberGbl)</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[..GetMajor(pBuildNumber)_"."_..GetMinor(pBuildNumber)_"."_..GetMaintenance(pBuildNumber)
]]></Implementation>
</Method>

<Method name="GetNumberWithSuffix">
<Description><![CDATA[
Returns the <major>.<minor>.<maintenance> part of the full build number for the product with format:
<major>.<minor>.<maintenance>.<number>.<patch>.<adhoc>. <br />
The <maintenance> number is returned with its character suffix. <br />
@Argument	pBuildNumber		Unique build number of the build. Default to be the current build number. <br />
@API.Method]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pBuildNumber:%String=$Get($$$BuildNumberGbl)</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[..GetMajor(pBuildNumber)_"."_..GetMinor(pBuildNumber)_"."_..GetMaintenanceWithSuffix(pBuildNumber)
]]></Implementation>
</Method>

<Method name="GetMajor">
<Description><![CDATA[
Returns the major version of the full build number for the product with format:
<major>.<minor>.<maintenance>.<number>.<patch>.<adhoc>. <br />
@Argument	pBuildNumber		Unique build number of the build. Default to be the current build number. <br />
@API.Method]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pBuildNumber:%String=$Get($$$BuildNumberGbl)</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[+$Piece(pBuildNumber,".",1)
]]></Implementation>
</Method>

<Method name="GetMinor">
<Description><![CDATA[
Returns the minor version of the full build number for the product with format:
<major>.<minor>.<maintenance>.<number>.<patch>.<adhoc>. <br />
@Argument	pBuildNumber		Unique build number of the build. Default to be the current build number. <br />
@API.Method]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pBuildNumber:%String=$Get($$$BuildNumberGbl)</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[+$Piece(pBuildNumber,".",2)
]]></Implementation>
</Method>

<Method name="GetMaintenance">
<Description><![CDATA[
Returns the maintenance version of the full build number for the product with format:
<major>.<minor>.<maintenance>.<number>.<patch>.<adhoc>. <br />
@Argument	pBuildNumber		Unique build number of the build. Default to be the current build number. <br />
@API.Method]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pBuildNumber:%String=$Get($$$BuildNumberGbl)</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[+..GetMaintenanceWithSuffix(pBuildNumber)
]]></Implementation>
</Method>

<Method name="GetMaintenanceWithSuffix">
<Description><![CDATA[
Returns the maintenance version of the full build number for the product with format:
<major>.<minor>.<maintenance>.<number>.<patch>.<adhoc>. <br />
Does not force to an integer so any character suffix (such as 0HS) remains. <be />
@Argument	pBuildNumber		Unique build number of the build. Default to be the current build number. <br />
@API.Method]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pBuildNumber:%String=$Get($$$BuildNumberGbl)</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$Piece(pBuildNumber,".",3)
]]></Implementation>
</Method>

<Method name="GetBuildNumber">
<Description><![CDATA[
Returns the number of the full build number for the product with format:
<major>.<minor>.<maintenance>.<number>.<patch>.<adhoc>. <br />
@Argument	pBuildNumber		Unique build number of the build. Default to be the current build number. <br />
@API.Method]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pBuildNumber:%String=$Get($$$BuildNumberGbl)</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[+$Piece(pBuildNumber,".",4)
]]></Implementation>
</Method>

<Method name="GetPatch">
<Description><![CDATA[
Returns the patch number of the full build number for the product with format:
<major>.<minor>.<maintenance>.<number>.<patch>.<adhoc>. <br />
@Argument	pBuildNumber		Unique build number of the build. Default to be the current build number. <br />
@API.Method]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pBuildNumber:%String=$Get($$$BuildNumberGbl)</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[+$Piece(pBuildNumber,".",5)
]]></Implementation>
</Method>

<Method name="GetAdhocNumber">
<Description><![CDATA[
Returns the adhoc number of the full build number for the product with format:
<major>.<minor>.<maintenance>.<number>.<patch>.<adhoc>. <br />
Returns 0 if no adhoc number present. <br />
@Argument	pBuildNumber		Unique build number of the build. Default to be the current build number. <br />
@API.Method]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pBuildNumber:%String=$Get($$$BuildNumberGbl)</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[+$Piece(pBuildNumber,".",6)
]]></Implementation>
</Method>

<Method name="IsReleaseBuild">
<Description><![CDATA[
Identify whether a build is a release build from the build number
@Argument	pBuildNumber		Unique build number of the build. Default to be the current build number. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pBuildNumber:%String=$Get($$$BuildNumberGbl)</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	// Release builds will have build number ranged from 1000-1999
	Set number = ..GetBuildNumber(pBuildNumber)
	Return (number >= 1000) && (number <= 1999)
]]></Implementation>
</Method>

<Method name="IsLatestBuild">
<Description><![CDATA[
Identify whether a build is a latest build from the build number
@Argument	pBuildNumber		Unique build number of the build. Default to be the current build number. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pBuildNumber:%String=$Get($$$BuildNumberGbl)</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	// Latest builds will have build number ranged from 2000-2999
	Set number = ..GetBuildNumber(pBuildNumber)
	Return (number >= 2000) && (number <= 2999)
]]></Implementation>
</Method>

<Method name="IsProjectBuild">
<Description><![CDATA[
Identify whether a build is a project build from the build number
@Argument	pBuildNumber		Unique build number of the build. Default to be the current build number. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pBuildNumber:%String=$Get($$$BuildNumberGbl)</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	// Project builds will have build number ranged from 3000-9999
	Set number = ..GetBuildNumber(pBuildNumber)
	Return (number >= 3000) && (number <= 9999)
]]></Implementation>
</Method>

<Method name="IsAdhocBuild">
<Description><![CDATA[
Identify whether a build is an adhoc build from the build number
@Argument	pBuildNumber		Unique build number of the build. Default to be the current build number. <br />]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pBuildNumber:%String=$Get($$$BuildNumberGbl)</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	// Adhoc builds will have an additional number at the end of the regular build number
	Set number = ..GetAdhocNumber(pBuildNumber)
	Return '(number = 0)
]]></Implementation>
</Method>
</Class>


<Project name="ZHSLIB" LastModified="2025-01-09 13:37:50.2920073">
  <Items>
    <ProjectItem name="%ZHSLIB.AbstractAvailability" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.AbstractInstaller" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.AbstractStartupItem" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.Audit.Log" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.Audit.LogParticipant" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.CodeGenUtils.VerifyAbstractMembersDefined" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.Component.Build" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.Component.SourceCode.API" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.Component.SourceCode.Utils" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.Component.TLSCertificate" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.Component.Utils" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.Component" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.Context.InitializerBase" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.Context.Manager" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.Context.NamedInstanceBase" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.Context.ServiceBase" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.HealthShareMgr" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.LockManager" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.Login.LoginData" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.Login.Utils" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.NonHSSolution.Utils" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.REST.AngularHandler" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.Services.Client" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.Services.NVPair" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.Services.Server" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.Services.TaskCalculateUpdatedRAndR" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.Services.TaskUpdateRolesAndResources" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.SessionEventUtil" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.TLS.API" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.TLS.Utils" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.UserChangePassword" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.UserLogin" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.UsersAndRoles" type="CLS"></ProjectItem>
    <ProjectItem name="%ZHSLIB.Version" type="CLS"></ProjectItem>
    <ProjectItem name="bootstrap.MAC" type="MAC"></ProjectItem>
    <ProjectItem name="%ZHSLIB.INC" type="MAC"></ProjectItem>
    <ProjectItem name="%ZHSLIB.Component.Build.INC" type="MAC"></ProjectItem>
    <ProjectItem name="%ZHSLIB.Formatting.INC" type="MAC"></ProjectItem>
  </Items>
</Project>


<Routine name="bootstrap" type="MAC" languagemode="0" timestamp="67214,43604"><![CDATA[
 /*
	HealthShare Package Manager and Common Code Bootstrap Routine	
 */

#include %occInclude
#define InitTotalTime s bigtime=$zh
#define InitTime s time1=$zh
#define ElapsedTime s time1=$zh-time1 w "Elapsed time: "_$s(time1>60:(time1\60)_" minutes ",1:"")_(time1#60)_" seconds"
#define ElapsedTotalTime i $d(bigtime) s bigtime=$zh-bigtime Write !!,"COMPLETE!",!,"Overall Elapsed Time: "_$s(bigtime>60:(bigtime\60)_" minutes ",1:"")_(bigtime#60)_" seconds"

#; Main entry point
	Do install()
	Quit
	
install(pClean=0) [ Root ] {
	$$$InitTotalTime
	Do StartLog^%buildutil()
	Try {
		If '$Data(Root) {
			Try {
				Set Root = ##class(%IPM.Storage.Module).NameOpen("ZHSLIB").Root
			} Catch e {
				//Ignore
			}
		}
		
		If pClean {
			// For a clean build, get rid of %SourceControl
			New %SourceControl
			Kill %SourceControl
			// Try to delete the %ZHSLIB package - display but ignore errors.
			Do $System.OBJ.DeletePackage("%ZHSLIB")
		}
		
		// Bootstrap: import everything normally
		Set tSC = $System.OBJ.ImportDir(Root_"/databases/hscommon/inc","*.inc","ck",,1)
		$$$ThrowOnError(tSC)
		Set tSC = $System.OBJ.ImportDir(Root_"/databases/hscommon/cls","*.cls","ck",,1)
		$$$ThrowOnError(tSC)
		
		// Reload using the package manager. This will also export the build artifact for %ZHSLIB (hsutil.xml).
		Set tShellCommand = "load -DNoMapping=1 -DNoTransaction=1 -verbose " _ Root
		Set tSC = ##class(%IPM.Main).Shell(tShellCommand)
		$$$ThrowOnError(tSC)
	} Catch e {
		Set tSC = e.AsStatus()
	}
	If $$$ISERR(tSC) {
		Write "Error: ",$System.Status.GetErrorText(tSC),!
	}
	$$$ElapsedTotalTime
	Do EndLog^%buildutil()
}

clean
	Do install(1)
	Quit
]]></Routine>
</Export>
